['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/DateTime.sol\n', '\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', '// File: contracts/ISimpleCrowdsale.sol\n', '\n', 'interface ISimpleCrowdsale {\n', '    function getSoftCap() external view returns(uint256);\n', '    function isContributorInLists(address contributorAddress) external view returns(bool);\n', '    function processReservationFundContribution(\n', '        address contributor,\n', '        uint256 tokenAmount,\n', '        uint256 tokenBonusAmount\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/fund/ICrowdsaleFund.sol\n', '\n', '/**\n', ' * @title ICrowdsaleFund\n', ' * @dev Fund methods used by crowdsale contract\n', ' */\n', 'interface ICrowdsaleFund {\n', '    /**\n', '    * @dev Function accepts user`s contributed ether and logs contribution\n', '    * @param contributor Contributor wallet address.\n', '    */\n', '    function processContribution(address contributor) external payable;\n', '    /**\n', '    * @dev Function is called on the end of successful crowdsale\n', '    */\n', '    function onCrowdsaleEnd() external;\n', '    /**\n', '    * @dev Function is called if crowdsale failed to reach soft cap\n', '    */\n', '    function enableCrowdsaleRefund() external;\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/MultiOwnable.sol\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\n', ' * functions, this simplifies the implementation of "users permissions".\n', ' */\n', 'contract MultiOwnable {\n', '    address public manager; // address used to set owners\n', '    address[] public owners;\n', '    mapping(address => bool) public ownerByAddress;\n', '\n', '    event SetOwners(address[] owners);\n', '\n', '    modifier onlyOwner() {\n', '        require(ownerByAddress[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev MultiOwnable constructor sets the manager\n', '     */\n', '    function MultiOwnable() public {\n', '        manager = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to set owners addresses\n', '     */\n', '    function setOwners(address[] _owners) public {\n', '        require(msg.sender == manager);\n', '        _setOwners(_owners);\n', '\n', '    }\n', '\n', '    function _setOwners(address[] _owners) internal {\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            ownerByAddress[owners[i]] = false;\n', '        }\n', '\n', '\n', '        for(uint256 j = 0; j < _owners.length; j++) {\n', '            ownerByAddress[_owners[j]] = true;\n', '        }\n', '        owners = _owners;\n', '        SetOwners(_owners);\n', '    }\n', '\n', '    function getOwners() public constant returns (address[]) {\n', '        return owners;\n', '    }\n', '}\n', '\n', '// File: contracts/token/IERC20Token.sol\n', '\n', '/**\n', ' * @title IERC20Token - ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract IERC20Token {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value)  public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\n', '    function approve(address _spender, uint256 _value)  public returns (bool success);\n', '    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/token/ERC20Token.sol\n', '\n', '/**\n', ' * @title ERC20Token - ERC20 base implementation\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Token is IERC20Token, SafeMath {\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '// File: contracts/token/ITokenEventListener.sol\n', '\n', '/**\n', ' * @title ITokenEventListener\n', ' * @dev Interface which should be implemented by token listener\n', ' */\n', 'interface ITokenEventListener {\n', '    /**\n', '     * @dev Function is called after token transfer/transferFrom\n', '     * @param _from Sender address\n', '     * @param _to Receiver address\n', '     * @param _value Amount of tokens\n', '     */\n', '    function onTokenTransfer(address _from, address _to, uint256 _value) external;\n', '}\n', '\n', '// File: contracts/token/ManagedToken.sol\n', '\n', '/**\n', ' * @title ManagedToken\n', ' * @dev ERC20 compatible token with issue and destroy facilities\n', ' * @dev All transfers can be monitored by token event listener\n', ' */\n', 'contract ManagedToken is ERC20Token, MultiOwnable {\n', '    bool public allowTransfers = false;\n', '    bool public issuanceFinished = false;\n', '\n', '    ITokenEventListener public eventListener;\n', '\n', '    event AllowTransfersChanged(bool _newState);\n', '    event Issue(address indexed _to, uint256 _value);\n', '    event Destroy(address indexed _from, uint256 _value);\n', '    event IssuanceFinished();\n', '\n', '    modifier transfersAllowed() {\n', '        require(allowTransfers);\n', '        _;\n', '    }\n', '\n', '    modifier canIssue() {\n', '        require(!issuanceFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev ManagedToken constructor\n', '     * @param _listener Token listener(address can be 0x0)\n', '     * @param _owners Owners list\n', '     */\n', '    function ManagedToken(address _listener, address[] _owners) public {\n', '        if(_listener != address(0)) {\n', '            eventListener = ITokenEventListener(_listener);\n', '        }\n', '        _setOwners(_owners);\n', '    }\n', '\n', '    /**\n', '     * @dev Enable/disable token transfers. Can be called only by owners\n', '     * @param _allowTransfers True - allow False - disable\n', '     */\n', '    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n', '        allowTransfers = _allowTransfers;\n', '        AllowTransfersChanged(_allowTransfers);\n', '    }\n', '\n', '    /**\n', '     * @dev Set/remove token event listener\n', '     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n', '     */\n', '    function setListener(address _listener) public onlyOwner {\n', '        if(_listener != address(0)) {\n', '            eventListener = ITokenEventListener(_listener);\n', '        } else {\n', '            delete eventListener;\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n', '        bool success = super.transfer(_to, _value);\n', '        if(hasListener() && success) {\n', '            eventListener.onTokenTransfer(msg.sender, _to, _value);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '        if(hasListener() && success) {\n', '            eventListener.onTokenTransfer(_from, _to, _value);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    function hasListener() internal view returns(bool) {\n', '        if(eventListener == address(0)) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Issue tokens to specified wallet\n', '     * @param _to Wallet address\n', '     * @param _value Amount of tokens\n', '     */\n', '    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n', '        totalSupply = safeAdd(totalSupply, _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Issue(_to, _value);\n', '        Transfer(address(0), _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy tokens on specified address (Called by owner or token holder)\n', '     * @dev Fund contract address must be in the list of owners to burn token during refund\n', '     * @param _from Wallet address\n', '     * @param _value Amount of tokens to destroy\n', '     */\n', '    function destroy(address _from, uint256 _value) external {\n', '        require(ownerByAddress[msg.sender] || msg.sender == _from);\n', '        require(balances[_from] >= _value);\n', '        totalSupply = safeSub(totalSupply, _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        Transfer(_from, address(0), _value);\n', '        Destroy(_from, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From OpenZeppelin StandardToken.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From OpenZeppelin StandardToken.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Finish token issuance\n', '     * @return True if success\n', '     */\n', '    function finishIssuance() public onlyOwner returns (bool) {\n', '        issuanceFinished = true;\n', '        IssuanceFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/Fund.sol\n', '\n', 'contract Fund is ICrowdsaleFund, SafeMath, MultiOwnable {\n', '    enum FundState {\n', '        Crowdsale,\n', '        CrowdsaleRefund,\n', '        TeamWithdraw,\n', '        Refund\n', '    }\n', '\n', '    FundState public state = FundState.Crowdsale;\n', '    ManagedToken public token;\n', '\n', '    uint256 public constant INITIAL_TAP = 192901234567901; // (wei/sec) == 500 ether/month\n', '\n', '    address public teamWallet;\n', '    uint256 public crowdsaleEndDate;\n', '\n', '    address public referralTokenWallet;\n', '    address public foundationTokenWallet;\n', '    address public reserveTokenWallet;\n', '    address public bountyTokenWallet;\n', '    address public companyTokenWallet;\n', '    address public advisorTokenWallet;\n', '\n', '    uint256 public tap;\n', '    uint256 public lastWithdrawTime = 0;\n', '    uint256 public firstWithdrawAmount = 0;\n', '\n', '    address public crowdsaleAddress;\n', '    mapping(address => uint256) public contributions;\n', '\n', '    event RefundContributor(address tokenHolder, uint256 amountWei, uint256 timestamp);\n', '    event RefundHolder(address tokenHolder, uint256 amountWei, uint256 tokenAmount, uint256 timestamp);\n', '    event Withdraw(uint256 amountWei, uint256 timestamp);\n', '    event RefundEnabled(address initiatorAddress);\n', '\n', '    /**\n', '     * @dev Fund constructor\n', '     * @param _teamWallet Withdraw functions transfers ether to this address\n', '     * @param _referralTokenWallet Referral wallet address\n', '     * @param _companyTokenWallet Company wallet address\n', '     * @param _reserveTokenWallet Reserve wallet address\n', '     * @param _bountyTokenWallet Bounty wallet address\n', '     * @param _advisorTokenWallet Advisor wallet address\n', '     * @param _owners Contract owners\n', '     */\n', '    function Fund(\n', '        address _teamWallet,\n', '        address _referralTokenWallet,\n', '        address _foundationTokenWallet,\n', '        address _companyTokenWallet,\n', '        address _reserveTokenWallet,\n', '        address _bountyTokenWallet,\n', '        address _advisorTokenWallet,\n', '        address[] _owners\n', '    ) public\n', '    {\n', '        teamWallet = _teamWallet;\n', '        referralTokenWallet = _referralTokenWallet;\n', '        foundationTokenWallet = _foundationTokenWallet;\n', '        companyTokenWallet = _companyTokenWallet;\n', '        reserveTokenWallet = _reserveTokenWallet;\n', '        bountyTokenWallet = _bountyTokenWallet;\n', '        advisorTokenWallet = _advisorTokenWallet;\n', '        _setOwners(_owners);\n', '    }\n', '\n', '    modifier withdrawEnabled() {\n', '        require(canWithdraw());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == crowdsaleAddress);\n', '        _;\n', '    }\n', '\n', '    function canWithdraw() public returns(bool);\n', '\n', '    function setCrowdsaleAddress(address _crowdsaleAddress) public onlyOwner {\n', '        require(crowdsaleAddress == address(0));\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '    }\n', '\n', '    function setTokenAddress(address _tokenAddress) public onlyOwner {\n', '        require(address(token) == address(0));\n', '        token = ManagedToken(_tokenAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Process crowdsale contribution\n', '     */\n', '    function processContribution(address contributor) external payable onlyCrowdsale {\n', '        require(state == FundState.Crowdsale);\n', '        uint256 totalContribution = safeAdd(contributions[contributor], msg.value);\n', '        contributions[contributor] = totalContribution;\n', '    }\n', '\n', '    /**\n', '     * @dev Callback is called after crowdsale finalization if soft cap is reached\n', '     */\n', '    function onCrowdsaleEnd() external onlyCrowdsale {\n', '        state = FundState.TeamWithdraw;\n', '        ISimpleCrowdsale crowdsale = ISimpleCrowdsale(crowdsaleAddress);\n', '        firstWithdrawAmount = safeDiv(crowdsale.getSoftCap(), 2);\n', '        lastWithdrawTime = now;\n', '        tap = INITIAL_TAP;\n', '        crowdsaleEndDate = now;\n', '    }\n', '\n', '    /**\n', '     * @dev Callback is called after crowdsale finalization if soft cap is not reached\n', '     */\n', '    function enableCrowdsaleRefund() external onlyCrowdsale {\n', '        require(state == FundState.Crowdsale);\n', '        state = FundState.CrowdsaleRefund;\n', '    }\n', '\n', '    /**\n', '    * @dev Function is called by contributor to refund payments if crowdsale failed to reach soft cap\n', '    */\n', '    function refundCrowdsaleContributor() external {\n', '        require(state == FundState.CrowdsaleRefund);\n', '        require(contributions[msg.sender] > 0);\n', '\n', '        uint256 refundAmount = contributions[msg.sender];\n', '        contributions[msg.sender] = 0;\n', '        token.destroy(msg.sender, token.balanceOf(msg.sender));\n', '        msg.sender.transfer(refundAmount);\n', '        RefundContributor(msg.sender, refundAmount, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease tap amount\n', '     * @param _tap New tap value\n', '     */\n', '    function decTap(uint256 _tap) external onlyOwner {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(_tap < tap);\n', '        tap = _tap;\n', '    }\n', '\n', '    function getCurrentTapAmount() public constant returns(uint256) {\n', '        if(state != FundState.TeamWithdraw) {\n', '            return 0;\n', '        }\n', '        return calcTapAmount();\n', '    }\n', '\n', '    function calcTapAmount() internal view returns(uint256) {\n', '        uint256 amount = safeMul(safeSub(now, lastWithdrawTime), tap);\n', '        if(address(this).balance < amount) {\n', '            amount = address(this).balance;\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    function firstWithdraw() public onlyOwner withdrawEnabled {\n', '        require(firstWithdrawAmount > 0);\n', '        uint256 amount = firstWithdrawAmount;\n', '        firstWithdrawAmount = 0;\n', '        teamWallet.transfer(amount);\n', '        Withdraw(amount, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw tap amount\n', '     */\n', '    function withdraw() public onlyOwner withdrawEnabled {\n', '        require(state == FundState.TeamWithdraw);\n', '        uint256 amount = calcTapAmount();\n', '        lastWithdrawTime = now;\n', '        teamWallet.transfer(amount);\n', '        Withdraw(amount, now);\n', '    }\n', '\n', '    // Refund\n', '    /**\n', '     * @dev Called to start refunding\n', '     */\n', '    function enableRefund() internal {\n', '        require(state == FundState.TeamWithdraw);\n', '        state = FundState.Refund;\n', '        token.destroy(companyTokenWallet, token.balanceOf(companyTokenWallet));\n', '        token.destroy(reserveTokenWallet, token.balanceOf(reserveTokenWallet));\n', '        token.destroy(foundationTokenWallet, token.balanceOf(foundationTokenWallet));\n', '        token.destroy(bountyTokenWallet, token.balanceOf(bountyTokenWallet));\n', '        token.destroy(referralTokenWallet, token.balanceOf(referralTokenWallet));\n', '        token.destroy(advisorTokenWallet, token.balanceOf(advisorTokenWallet));\n', '        RefundEnabled(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Function is called by contributor to refund\n', '    * Buy user tokens for refundTokenPrice and destroy them\n', '    */\n', '    function refundTokenHolder() public {\n', '        require(state == FundState.Refund);\n', '\n', '        uint256 tokenBalance = token.balanceOf(msg.sender);\n', '        require(tokenBalance > 0);\n', '        uint256 refundAmount = safeDiv(safeMul(tokenBalance, address(this).balance), token.totalSupply());\n', '        require(refundAmount > 0);\n', '\n', '        token.destroy(msg.sender, tokenBalance);\n', '        msg.sender.transfer(refundAmount);\n', '\n', '        RefundHolder(msg.sender, refundAmount, tokenBalance, now);\n', '    }\n', '}\n', '\n', '// File: contracts/fund/IPollManagedFund.sol\n', '\n', '/**\n', ' * @title IPollManagedFund\n', ' * @dev Fund callbacks used by polling contracts\n', ' */\n', 'interface IPollManagedFund {\n', '    /**\n', '     * @dev TapPoll callback\n', '     * @param agree True if new tap value is accepted by majority of contributors\n', '     * @param _tap New tap value\n', '     */\n', '    function onTapPollFinish(bool agree, uint256 _tap) external;\n', '\n', '    /**\n', '     * @dev RefundPoll callback\n', '     * @param agree True if contributors decided to allow refunding\n', '     */\n', '    function onRefundPollFinish(bool agree) external;\n', '}\n', '\n', '// File: contracts/poll/BasePoll.sol\n', '\n', '/**\n', ' * @title BasePoll\n', ' * @dev Abstract base class for polling contracts\n', ' */\n', 'contract BasePoll is SafeMath {\n', '    struct Vote {\n', '        uint256 time;\n', '        uint256 weight;\n', '        bool agree;\n', '    }\n', '\n', '    uint256 public constant MAX_TOKENS_WEIGHT_DENOM = 1000;\n', '\n', '    IERC20Token public token;\n', '    address public fundAddress;\n', '\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    bool checkTransfersAfterEnd;\n', '\n', '    uint256 public yesCounter = 0;\n', '    uint256 public noCounter = 0;\n', '    uint256 public totalVoted = 0;\n', '\n', '    bool public finalized;\n', '    mapping(address => Vote) public votesByAddress;\n', '\n', '    modifier checkTime() {\n', '        require(now >= startTime && now <= endTime);\n', '        _;\n', '    }\n', '\n', '    modifier notFinalized() {\n', '        require(!finalized);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev BasePoll constructor\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     */\n', '    function BasePoll(address _tokenAddress, address _fundAddress, uint256 _startTime, uint256 _endTime, bool _checkTransfersAfterEnd) public {\n', '        require(_tokenAddress != address(0));\n', '        require(_startTime >= now && _endTime > _startTime);\n', '\n', '        token = IERC20Token(_tokenAddress);\n', '        fundAddress = _fundAddress;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        finalized = false;\n', '        checkTransfersAfterEnd = _checkTransfersAfterEnd;\n', '    }\n', '\n', '    /**\n', '     * @dev Process user`s vote\n', '     * @param agree True if user endorses the proposal else False\n', '     */\n', '    function vote(bool agree) public checkTime {\n', '        require(votesByAddress[msg.sender].time == 0);\n', '\n', '        uint256 voiceWeight = token.balanceOf(msg.sender);\n', '        uint256 maxVoiceWeight = safeDiv(token.totalSupply(), MAX_TOKENS_WEIGHT_DENOM);\n', '        voiceWeight =  voiceWeight <= maxVoiceWeight ? voiceWeight : maxVoiceWeight;\n', '\n', '        if(agree) {\n', '            yesCounter = safeAdd(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeAdd(noCounter, voiceWeight);\n', '\n', '        }\n', '\n', '        votesByAddress[msg.sender].time = now;\n', '        votesByAddress[msg.sender].weight = voiceWeight;\n', '        votesByAddress[msg.sender].agree = agree;\n', '\n', '        totalVoted = safeAdd(totalVoted, 1);\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke user`s vote\n', '     */\n', '    function revokeVote() public checkTime {\n', '        require(votesByAddress[msg.sender].time > 0);\n', '\n', '        uint256 voiceWeight = votesByAddress[msg.sender].weight;\n', '        bool agree = votesByAddress[msg.sender].agree;\n', '\n', '        votesByAddress[msg.sender].time = 0;\n', '        votesByAddress[msg.sender].weight = 0;\n', '        votesByAddress[msg.sender].agree = false;\n', '\n', '        totalVoted = safeSub(totalVoted, 1);\n', '        if(agree) {\n', '            yesCounter = safeSub(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeSub(noCounter, voiceWeight);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function is called after token transfer from user`s wallet to check and correct user`s vote\n', '     *\n', '     */\n', '    function onTokenTransfer(address tokenHolder, uint256 amount) public {\n', '        require(msg.sender == fundAddress);\n', '        if(votesByAddress[tokenHolder].time == 0) {\n', '            return;\n', '        }\n', '        if(!checkTransfersAfterEnd) {\n', '             if(finalized || (now < startTime || now > endTime)) {\n', '                 return;\n', '             }\n', '        }\n', '\n', '        if(token.balanceOf(tokenHolder) >= votesByAddress[tokenHolder].weight) {\n', '            return;\n', '        }\n', '        uint256 voiceWeight = amount;\n', '        if(amount > votesByAddress[tokenHolder].weight) {\n', '            voiceWeight = votesByAddress[tokenHolder].weight;\n', '        }\n', '\n', '        if(votesByAddress[tokenHolder].agree) {\n', '            yesCounter = safeSub(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeSub(noCounter, voiceWeight);\n', '        }\n', '        votesByAddress[tokenHolder].weight = safeSub(votesByAddress[tokenHolder].weight, voiceWeight);\n', '    }\n', '\n', '    /**\n', '     * Finalize poll and call onPollFinish callback with result\n', '     */\n', '    function tryToFinalize() public notFinalized returns(bool) {\n', '        if(now < endTime) {\n', '            return false;\n', '        }\n', '        finalized = true;\n', '        onPollFinish(isSubjectApproved());\n', '        return true;\n', '    }\n', '\n', '    function isNowApproved() public view returns(bool) {\n', '        return isSubjectApproved();\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter;\n', '    }\n', '\n', '    /**\n', '     * @dev callback called after poll finalization\n', '     */\n', '    function onPollFinish(bool agree) internal;\n', '}\n', '\n', '// File: contracts/RefundPoll.sol\n', '\n', '/**\n', ' * @title RefundPoll\n', ' * @dev Enables fund refund mode\n', ' */\n', 'contract RefundPoll is BasePoll {\n', '    uint256 public holdEndTime = 0;\n', '\n', '    /**\n', '     * RefundPoll constructor\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     */\n', '    function RefundPoll(\n', '        address _tokenAddress,\n', '        address _fundAddress,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _holdEndTime,\n', '        bool _checkTransfersAfterEnd\n', '    ) public\n', '        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, _checkTransfersAfterEnd)\n', '    {\n', '        holdEndTime = _holdEndTime;\n', '    }\n', '\n', '    function tryToFinalize() public returns(bool) {\n', '        if(holdEndTime > 0 && holdEndTime > endTime) {\n', '            require(now >= holdEndTime);\n', '        } else {\n', '            require(now >= endTime);\n', '        }\n', '\n', '        finalized = true;\n', '        onPollFinish(isSubjectApproved());\n', '        return true;\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter && yesCounter >= safeDiv(token.totalSupply(), 3);\n', '    }\n', '\n', '    function onPollFinish(bool agree) internal {\n', '        IPollManagedFund fund = IPollManagedFund(fundAddress);\n', '        fund.onRefundPollFinish(agree);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/TapPoll.sol\n', '\n', '/**\n', ' * @title TapPoll\n', ' * @dev Poll to increase tap amount\n', ' */\n', 'contract TapPoll is BasePoll {\n', '    uint256 public tap;\n', '    uint256 public minTokensPerc = 0;\n', '\n', '    /**\n', '     * TapPoll constructor\n', '     * @param _tap New tap value\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     * @param _minTokensPerc - Min percent of tokens from totalSupply where poll is considered to be fulfilled\n', '     */\n', '    function TapPoll(\n', '        uint256 _tap,\n', '        address _tokenAddress,\n', '        address _fundAddress,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _minTokensPerc\n', '    ) public\n', '        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, false)\n', '    {\n', '        tap = _tap;\n', '        minTokensPerc = _minTokensPerc;\n', '    }\n', '\n', '    function onPollFinish(bool agree) internal {\n', '        IPollManagedFund fund = IPollManagedFund(fundAddress);\n', '        fund.onTapPollFinish(agree, tap);\n', '    }\n', '\n', '    function getVotedTokensPerc() public view returns(uint256) {\n', '        return safeDiv(safeMul(safeAdd(yesCounter, noCounter), 100), token.totalSupply());\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter && getVotedTokensPerc() >= minTokensPerc;\n', '    }\n', '}\n', '\n', '// File: contracts/PollManagedFund.sol\n', '\n', '/**\n', ' * @title PollManagedFund\n', ' * @dev Fund controlled by users\n', ' */\n', 'contract PollManagedFund is Fund, DateTime, ITokenEventListener {\n', '    uint256 public constant TAP_POLL_DURATION = 3 days;\n', '    uint256 public constant REFUND_POLL_DURATION = 7 days;\n', '    uint256 public constant MAX_VOTED_TOKEN_PERC = 10;\n', '\n', '    TapPoll public tapPoll;\n', '    RefundPoll public refundPoll;\n', '\n', '    uint256 public minVotedTokensPerc = 0;\n', '    uint256 public secondRefundPollDate = 0;\n', '    bool public isWithdrawEnabled = true;\n', '\n', '    uint256[] public refundPollDates = [\n', '        1530403200, // 01.07.2018\n', '        1538352000, // 01.10.2018\n', '        1546300800, // 01.01.2019\n', '        1554076800, // 01.04.2019\n', '        1561939200, // 01.07.2019\n', '        1569888000, // 01.10.2019\n', '        1577836800, // 01.01.2020\n', '        1585699200  // 01.04.2020\n', '    ];\n', '\n', '    modifier onlyTokenHolder() {\n', '        require(token.balanceOf(msg.sender) > 0);\n', '        _;\n', '    }\n', '\n', '    event TapPollCreated();\n', '    event TapPollFinished(bool approved, uint256 _tap);\n', '    event RefundPollCreated();\n', '    event RefundPollFinished(bool approved);\n', '\n', '    /**\n', '     * @dev PollManagedFund constructor\n', '     * params - see Fund constructor\n', '     */\n', '    function PollManagedFund(\n', '        address _teamWallet,\n', '        address _referralTokenWallet,\n', '        address _foundationTokenWallet,\n', '        address _companyTokenWallet,\n', '        address _reserveTokenWallet,\n', '        address _bountyTokenWallet,\n', '        address _advisorTokenWallet,\n', '        address[] _owners\n', '        ) public\n', '    Fund(_teamWallet, _referralTokenWallet, _foundationTokenWallet, _companyTokenWallet, _reserveTokenWallet, _bountyTokenWallet, _advisorTokenWallet, _owners)\n', '    {\n', '    }\n', '\n', '    function canWithdraw() public returns(bool) {\n', '        if(\n', '            address(refundPoll) != address(0) &&\n', '            !refundPoll.finalized() &&\n', '            refundPoll.holdEndTime() > 0 &&\n', '            now >= refundPoll.holdEndTime() &&\n', '            refundPoll.isNowApproved()\n', '        ) {\n', '            return false;\n', '        }\n', '        return isWithdrawEnabled;\n', '    }\n', '\n', '    /**\n', '     * @dev ITokenEventListener implementation. Notify active poll contracts about token transfers\n', '     */\n', '    function onTokenTransfer(address _from, address /*_to*/, uint256 _value) external {\n', '        require(msg.sender == address(token));\n', '        if(address(tapPoll) != address(0) && !tapPoll.finalized()) {\n', '            tapPoll.onTokenTransfer(_from, _value);\n', '        }\n', '         if(address(refundPoll) != address(0) && !refundPoll.finalized()) {\n', '            refundPoll.onTokenTransfer(_from, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update minVotedTokensPerc value after tap poll.\n', '     * Set new value == 50% from current voted tokens amount\n', '     */\n', '    function updateMinVotedTokens(uint256 _minVotedTokensPerc) internal {\n', '        uint256 newPerc = safeDiv(_minVotedTokensPerc, 2);\n', '        if(newPerc > MAX_VOTED_TOKEN_PERC) {\n', '            minVotedTokensPerc = MAX_VOTED_TOKEN_PERC;\n', '            return;\n', '        }\n', '        minVotedTokensPerc = newPerc;\n', '    }\n', '\n', '    // Tap poll\n', '    function createTapPoll(uint8 tapIncPerc) public onlyOwner {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(tapPoll == address(0));\n', '        require(getDay(now) == 10);\n', '        require(tapIncPerc <= 50);\n', '        uint256 _tap = safeAdd(tap, safeDiv(safeMul(tap, tapIncPerc), 100));\n', '        uint256 startTime = now;\n', '        uint256 endTime = startTime + TAP_POLL_DURATION;\n', '        tapPoll = new TapPoll(_tap, token, this, startTime, endTime, minVotedTokensPerc);\n', '        TapPollCreated();\n', '    }\n', '\n', '    function onTapPollFinish(bool agree, uint256 _tap) external {\n', '        require(msg.sender == address(tapPoll) && tapPoll.finalized());\n', '        if(agree) {\n', '            tap = _tap;\n', '        }\n', '        updateMinVotedTokens(tapPoll.getVotedTokensPerc());\n', '        TapPollFinished(agree, _tap);\n', '        delete tapPoll;\n', '    }\n', '\n', '    // Refund poll\n', '    function checkRefundPollDate() internal view returns(bool) {\n', '        if(secondRefundPollDate > 0 && now >= secondRefundPollDate && now <= safeAdd(secondRefundPollDate, 1 days)) {\n', '            return true;\n', '        }\n', '\n', '        for(uint i; i < refundPollDates.length; i++) {\n', '            if(now >= refundPollDates[i] && now <= safeAdd(refundPollDates[i], 1 days)) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function createRefundPoll() public onlyTokenHolder {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(address(refundPoll) == address(0));\n', '        require(checkRefundPollDate());\n', '\n', '        if(secondRefundPollDate > 0 && now > safeAdd(secondRefundPollDate, 1 days)) {\n', '            secondRefundPollDate = 0;\n', '        }\n', '\n', '        uint256 startTime = now;\n', '        uint256 endTime = startTime + REFUND_POLL_DURATION;\n', '        bool isFirstRefund = secondRefundPollDate == 0;\n', '        uint256 holdEndTime = 0;\n', '\n', '        if(isFirstRefund) {\n', '            holdEndTime = toTimestamp(\n', '                getYear(startTime),\n', '                getMonth(startTime) + 1,\n', '                1\n', '            );\n', '        }\n', '        refundPoll = new RefundPoll(token, this, startTime, endTime, holdEndTime, isFirstRefund);\n', '        RefundPollCreated();\n', '    }\n', '\n', '    function onRefundPollFinish(bool agree) external {\n', '        require(msg.sender == address(refundPoll) && refundPoll.finalized());\n', '        if(agree) {\n', '            if(secondRefundPollDate > 0) {\n', '                enableRefund();\n', '            } else {\n', '                uint256 startTime = refundPoll.startTime();\n', '                secondRefundPollDate = toTimestamp(\n', '                    getYear(startTime),\n', '                    getMonth(startTime) + 2,\n', '                    1\n', '                );\n', '                isWithdrawEnabled = false;\n', '            }\n', '        } else {\n', '            secondRefundPollDate = 0;\n', '            isWithdrawEnabled = true;\n', '        }\n', '        RefundPollFinished(agree);\n', '\n', '        delete refundPoll;\n', '    }\n', '\n', '    function forceRefund() public onlyOwner {\n', '        enableRefund();\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/DateTime.sol\n', '\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', '// File: contracts/ISimpleCrowdsale.sol\n', '\n', 'interface ISimpleCrowdsale {\n', '    function getSoftCap() external view returns(uint256);\n', '    function isContributorInLists(address contributorAddress) external view returns(bool);\n', '    function processReservationFundContribution(\n', '        address contributor,\n', '        uint256 tokenAmount,\n', '        uint256 tokenBonusAmount\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/fund/ICrowdsaleFund.sol\n', '\n', '/**\n', ' * @title ICrowdsaleFund\n', ' * @dev Fund methods used by crowdsale contract\n', ' */\n', 'interface ICrowdsaleFund {\n', '    /**\n', '    * @dev Function accepts user`s contributed ether and logs contribution\n', '    * @param contributor Contributor wallet address.\n', '    */\n', '    function processContribution(address contributor) external payable;\n', '    /**\n', '    * @dev Function is called on the end of successful crowdsale\n', '    */\n', '    function onCrowdsaleEnd() external;\n', '    /**\n', '    * @dev Function is called if crowdsale failed to reach soft cap\n', '    */\n', '    function enableCrowdsaleRefund() external;\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/MultiOwnable.sol\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\n', ' * functions, this simplifies the implementation of "users permissions".\n', ' */\n', 'contract MultiOwnable {\n', '    address public manager; // address used to set owners\n', '    address[] public owners;\n', '    mapping(address => bool) public ownerByAddress;\n', '\n', '    event SetOwners(address[] owners);\n', '\n', '    modifier onlyOwner() {\n', '        require(ownerByAddress[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev MultiOwnable constructor sets the manager\n', '     */\n', '    function MultiOwnable() public {\n', '        manager = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to set owners addresses\n', '     */\n', '    function setOwners(address[] _owners) public {\n', '        require(msg.sender == manager);\n', '        _setOwners(_owners);\n', '\n', '    }\n', '\n', '    function _setOwners(address[] _owners) internal {\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            ownerByAddress[owners[i]] = false;\n', '        }\n', '\n', '\n', '        for(uint256 j = 0; j < _owners.length; j++) {\n', '            ownerByAddress[_owners[j]] = true;\n', '        }\n', '        owners = _owners;\n', '        SetOwners(_owners);\n', '    }\n', '\n', '    function getOwners() public constant returns (address[]) {\n', '        return owners;\n', '    }\n', '}\n', '\n', '// File: contracts/token/IERC20Token.sol\n', '\n', '/**\n', ' * @title IERC20Token - ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract IERC20Token {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value)  public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\n', '    function approve(address _spender, uint256 _value)  public returns (bool success);\n', '    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/token/ERC20Token.sol\n', '\n', '/**\n', ' * @title ERC20Token - ERC20 base implementation\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Token is IERC20Token, SafeMath {\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '// File: contracts/token/ITokenEventListener.sol\n', '\n', '/**\n', ' * @title ITokenEventListener\n', ' * @dev Interface which should be implemented by token listener\n', ' */\n', 'interface ITokenEventListener {\n', '    /**\n', '     * @dev Function is called after token transfer/transferFrom\n', '     * @param _from Sender address\n', '     * @param _to Receiver address\n', '     * @param _value Amount of tokens\n', '     */\n', '    function onTokenTransfer(address _from, address _to, uint256 _value) external;\n', '}\n', '\n', '// File: contracts/token/ManagedToken.sol\n', '\n', '/**\n', ' * @title ManagedToken\n', ' * @dev ERC20 compatible token with issue and destroy facilities\n', ' * @dev All transfers can be monitored by token event listener\n', ' */\n', 'contract ManagedToken is ERC20Token, MultiOwnable {\n', '    bool public allowTransfers = false;\n', '    bool public issuanceFinished = false;\n', '\n', '    ITokenEventListener public eventListener;\n', '\n', '    event AllowTransfersChanged(bool _newState);\n', '    event Issue(address indexed _to, uint256 _value);\n', '    event Destroy(address indexed _from, uint256 _value);\n', '    event IssuanceFinished();\n', '\n', '    modifier transfersAllowed() {\n', '        require(allowTransfers);\n', '        _;\n', '    }\n', '\n', '    modifier canIssue() {\n', '        require(!issuanceFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev ManagedToken constructor\n', '     * @param _listener Token listener(address can be 0x0)\n', '     * @param _owners Owners list\n', '     */\n', '    function ManagedToken(address _listener, address[] _owners) public {\n', '        if(_listener != address(0)) {\n', '            eventListener = ITokenEventListener(_listener);\n', '        }\n', '        _setOwners(_owners);\n', '    }\n', '\n', '    /**\n', '     * @dev Enable/disable token transfers. Can be called only by owners\n', '     * @param _allowTransfers True - allow False - disable\n', '     */\n', '    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n', '        allowTransfers = _allowTransfers;\n', '        AllowTransfersChanged(_allowTransfers);\n', '    }\n', '\n', '    /**\n', '     * @dev Set/remove token event listener\n', '     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n', '     */\n', '    function setListener(address _listener) public onlyOwner {\n', '        if(_listener != address(0)) {\n', '            eventListener = ITokenEventListener(_listener);\n', '        } else {\n', '            delete eventListener;\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n', '        bool success = super.transfer(_to, _value);\n', '        if(hasListener() && success) {\n', '            eventListener.onTokenTransfer(msg.sender, _to, _value);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '        if(hasListener() && success) {\n', '            eventListener.onTokenTransfer(_from, _to, _value);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    function hasListener() internal view returns(bool) {\n', '        if(eventListener == address(0)) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Issue tokens to specified wallet\n', '     * @param _to Wallet address\n', '     * @param _value Amount of tokens\n', '     */\n', '    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n', '        totalSupply = safeAdd(totalSupply, _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Issue(_to, _value);\n', '        Transfer(address(0), _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy tokens on specified address (Called by owner or token holder)\n', '     * @dev Fund contract address must be in the list of owners to burn token during refund\n', '     * @param _from Wallet address\n', '     * @param _value Amount of tokens to destroy\n', '     */\n', '    function destroy(address _from, uint256 _value) external {\n', '        require(ownerByAddress[msg.sender] || msg.sender == _from);\n', '        require(balances[_from] >= _value);\n', '        totalSupply = safeSub(totalSupply, _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        Transfer(_from, address(0), _value);\n', '        Destroy(_from, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From OpenZeppelin StandardToken.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From OpenZeppelin StandardToken.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Finish token issuance\n', '     * @return True if success\n', '     */\n', '    function finishIssuance() public onlyOwner returns (bool) {\n', '        issuanceFinished = true;\n', '        IssuanceFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/Fund.sol\n', '\n', 'contract Fund is ICrowdsaleFund, SafeMath, MultiOwnable {\n', '    enum FundState {\n', '        Crowdsale,\n', '        CrowdsaleRefund,\n', '        TeamWithdraw,\n', '        Refund\n', '    }\n', '\n', '    FundState public state = FundState.Crowdsale;\n', '    ManagedToken public token;\n', '\n', '    uint256 public constant INITIAL_TAP = 192901234567901; // (wei/sec) == 500 ether/month\n', '\n', '    address public teamWallet;\n', '    uint256 public crowdsaleEndDate;\n', '\n', '    address public referralTokenWallet;\n', '    address public foundationTokenWallet;\n', '    address public reserveTokenWallet;\n', '    address public bountyTokenWallet;\n', '    address public companyTokenWallet;\n', '    address public advisorTokenWallet;\n', '\n', '    uint256 public tap;\n', '    uint256 public lastWithdrawTime = 0;\n', '    uint256 public firstWithdrawAmount = 0;\n', '\n', '    address public crowdsaleAddress;\n', '    mapping(address => uint256) public contributions;\n', '\n', '    event RefundContributor(address tokenHolder, uint256 amountWei, uint256 timestamp);\n', '    event RefundHolder(address tokenHolder, uint256 amountWei, uint256 tokenAmount, uint256 timestamp);\n', '    event Withdraw(uint256 amountWei, uint256 timestamp);\n', '    event RefundEnabled(address initiatorAddress);\n', '\n', '    /**\n', '     * @dev Fund constructor\n', '     * @param _teamWallet Withdraw functions transfers ether to this address\n', '     * @param _referralTokenWallet Referral wallet address\n', '     * @param _companyTokenWallet Company wallet address\n', '     * @param _reserveTokenWallet Reserve wallet address\n', '     * @param _bountyTokenWallet Bounty wallet address\n', '     * @param _advisorTokenWallet Advisor wallet address\n', '     * @param _owners Contract owners\n', '     */\n', '    function Fund(\n', '        address _teamWallet,\n', '        address _referralTokenWallet,\n', '        address _foundationTokenWallet,\n', '        address _companyTokenWallet,\n', '        address _reserveTokenWallet,\n', '        address _bountyTokenWallet,\n', '        address _advisorTokenWallet,\n', '        address[] _owners\n', '    ) public\n', '    {\n', '        teamWallet = _teamWallet;\n', '        referralTokenWallet = _referralTokenWallet;\n', '        foundationTokenWallet = _foundationTokenWallet;\n', '        companyTokenWallet = _companyTokenWallet;\n', '        reserveTokenWallet = _reserveTokenWallet;\n', '        bountyTokenWallet = _bountyTokenWallet;\n', '        advisorTokenWallet = _advisorTokenWallet;\n', '        _setOwners(_owners);\n', '    }\n', '\n', '    modifier withdrawEnabled() {\n', '        require(canWithdraw());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == crowdsaleAddress);\n', '        _;\n', '    }\n', '\n', '    function canWithdraw() public returns(bool);\n', '\n', '    function setCrowdsaleAddress(address _crowdsaleAddress) public onlyOwner {\n', '        require(crowdsaleAddress == address(0));\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '    }\n', '\n', '    function setTokenAddress(address _tokenAddress) public onlyOwner {\n', '        require(address(token) == address(0));\n', '        token = ManagedToken(_tokenAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Process crowdsale contribution\n', '     */\n', '    function processContribution(address contributor) external payable onlyCrowdsale {\n', '        require(state == FundState.Crowdsale);\n', '        uint256 totalContribution = safeAdd(contributions[contributor], msg.value);\n', '        contributions[contributor] = totalContribution;\n', '    }\n', '\n', '    /**\n', '     * @dev Callback is called after crowdsale finalization if soft cap is reached\n', '     */\n', '    function onCrowdsaleEnd() external onlyCrowdsale {\n', '        state = FundState.TeamWithdraw;\n', '        ISimpleCrowdsale crowdsale = ISimpleCrowdsale(crowdsaleAddress);\n', '        firstWithdrawAmount = safeDiv(crowdsale.getSoftCap(), 2);\n', '        lastWithdrawTime = now;\n', '        tap = INITIAL_TAP;\n', '        crowdsaleEndDate = now;\n', '    }\n', '\n', '    /**\n', '     * @dev Callback is called after crowdsale finalization if soft cap is not reached\n', '     */\n', '    function enableCrowdsaleRefund() external onlyCrowdsale {\n', '        require(state == FundState.Crowdsale);\n', '        state = FundState.CrowdsaleRefund;\n', '    }\n', '\n', '    /**\n', '    * @dev Function is called by contributor to refund payments if crowdsale failed to reach soft cap\n', '    */\n', '    function refundCrowdsaleContributor() external {\n', '        require(state == FundState.CrowdsaleRefund);\n', '        require(contributions[msg.sender] > 0);\n', '\n', '        uint256 refundAmount = contributions[msg.sender];\n', '        contributions[msg.sender] = 0;\n', '        token.destroy(msg.sender, token.balanceOf(msg.sender));\n', '        msg.sender.transfer(refundAmount);\n', '        RefundContributor(msg.sender, refundAmount, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease tap amount\n', '     * @param _tap New tap value\n', '     */\n', '    function decTap(uint256 _tap) external onlyOwner {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(_tap < tap);\n', '        tap = _tap;\n', '    }\n', '\n', '    function getCurrentTapAmount() public constant returns(uint256) {\n', '        if(state != FundState.TeamWithdraw) {\n', '            return 0;\n', '        }\n', '        return calcTapAmount();\n', '    }\n', '\n', '    function calcTapAmount() internal view returns(uint256) {\n', '        uint256 amount = safeMul(safeSub(now, lastWithdrawTime), tap);\n', '        if(address(this).balance < amount) {\n', '            amount = address(this).balance;\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    function firstWithdraw() public onlyOwner withdrawEnabled {\n', '        require(firstWithdrawAmount > 0);\n', '        uint256 amount = firstWithdrawAmount;\n', '        firstWithdrawAmount = 0;\n', '        teamWallet.transfer(amount);\n', '        Withdraw(amount, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw tap amount\n', '     */\n', '    function withdraw() public onlyOwner withdrawEnabled {\n', '        require(state == FundState.TeamWithdraw);\n', '        uint256 amount = calcTapAmount();\n', '        lastWithdrawTime = now;\n', '        teamWallet.transfer(amount);\n', '        Withdraw(amount, now);\n', '    }\n', '\n', '    // Refund\n', '    /**\n', '     * @dev Called to start refunding\n', '     */\n', '    function enableRefund() internal {\n', '        require(state == FundState.TeamWithdraw);\n', '        state = FundState.Refund;\n', '        token.destroy(companyTokenWallet, token.balanceOf(companyTokenWallet));\n', '        token.destroy(reserveTokenWallet, token.balanceOf(reserveTokenWallet));\n', '        token.destroy(foundationTokenWallet, token.balanceOf(foundationTokenWallet));\n', '        token.destroy(bountyTokenWallet, token.balanceOf(bountyTokenWallet));\n', '        token.destroy(referralTokenWallet, token.balanceOf(referralTokenWallet));\n', '        token.destroy(advisorTokenWallet, token.balanceOf(advisorTokenWallet));\n', '        RefundEnabled(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Function is called by contributor to refund\n', '    * Buy user tokens for refundTokenPrice and destroy them\n', '    */\n', '    function refundTokenHolder() public {\n', '        require(state == FundState.Refund);\n', '\n', '        uint256 tokenBalance = token.balanceOf(msg.sender);\n', '        require(tokenBalance > 0);\n', '        uint256 refundAmount = safeDiv(safeMul(tokenBalance, address(this).balance), token.totalSupply());\n', '        require(refundAmount > 0);\n', '\n', '        token.destroy(msg.sender, tokenBalance);\n', '        msg.sender.transfer(refundAmount);\n', '\n', '        RefundHolder(msg.sender, refundAmount, tokenBalance, now);\n', '    }\n', '}\n', '\n', '// File: contracts/fund/IPollManagedFund.sol\n', '\n', '/**\n', ' * @title IPollManagedFund\n', ' * @dev Fund callbacks used by polling contracts\n', ' */\n', 'interface IPollManagedFund {\n', '    /**\n', '     * @dev TapPoll callback\n', '     * @param agree True if new tap value is accepted by majority of contributors\n', '     * @param _tap New tap value\n', '     */\n', '    function onTapPollFinish(bool agree, uint256 _tap) external;\n', '\n', '    /**\n', '     * @dev RefundPoll callback\n', '     * @param agree True if contributors decided to allow refunding\n', '     */\n', '    function onRefundPollFinish(bool agree) external;\n', '}\n', '\n', '// File: contracts/poll/BasePoll.sol\n', '\n', '/**\n', ' * @title BasePoll\n', ' * @dev Abstract base class for polling contracts\n', ' */\n', 'contract BasePoll is SafeMath {\n', '    struct Vote {\n', '        uint256 time;\n', '        uint256 weight;\n', '        bool agree;\n', '    }\n', '\n', '    uint256 public constant MAX_TOKENS_WEIGHT_DENOM = 1000;\n', '\n', '    IERC20Token public token;\n', '    address public fundAddress;\n', '\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    bool checkTransfersAfterEnd;\n', '\n', '    uint256 public yesCounter = 0;\n', '    uint256 public noCounter = 0;\n', '    uint256 public totalVoted = 0;\n', '\n', '    bool public finalized;\n', '    mapping(address => Vote) public votesByAddress;\n', '\n', '    modifier checkTime() {\n', '        require(now >= startTime && now <= endTime);\n', '        _;\n', '    }\n', '\n', '    modifier notFinalized() {\n', '        require(!finalized);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev BasePoll constructor\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     */\n', '    function BasePoll(address _tokenAddress, address _fundAddress, uint256 _startTime, uint256 _endTime, bool _checkTransfersAfterEnd) public {\n', '        require(_tokenAddress != address(0));\n', '        require(_startTime >= now && _endTime > _startTime);\n', '\n', '        token = IERC20Token(_tokenAddress);\n', '        fundAddress = _fundAddress;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        finalized = false;\n', '        checkTransfersAfterEnd = _checkTransfersAfterEnd;\n', '    }\n', '\n', '    /**\n', '     * @dev Process user`s vote\n', '     * @param agree True if user endorses the proposal else False\n', '     */\n', '    function vote(bool agree) public checkTime {\n', '        require(votesByAddress[msg.sender].time == 0);\n', '\n', '        uint256 voiceWeight = token.balanceOf(msg.sender);\n', '        uint256 maxVoiceWeight = safeDiv(token.totalSupply(), MAX_TOKENS_WEIGHT_DENOM);\n', '        voiceWeight =  voiceWeight <= maxVoiceWeight ? voiceWeight : maxVoiceWeight;\n', '\n', '        if(agree) {\n', '            yesCounter = safeAdd(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeAdd(noCounter, voiceWeight);\n', '\n', '        }\n', '\n', '        votesByAddress[msg.sender].time = now;\n', '        votesByAddress[msg.sender].weight = voiceWeight;\n', '        votesByAddress[msg.sender].agree = agree;\n', '\n', '        totalVoted = safeAdd(totalVoted, 1);\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke user`s vote\n', '     */\n', '    function revokeVote() public checkTime {\n', '        require(votesByAddress[msg.sender].time > 0);\n', '\n', '        uint256 voiceWeight = votesByAddress[msg.sender].weight;\n', '        bool agree = votesByAddress[msg.sender].agree;\n', '\n', '        votesByAddress[msg.sender].time = 0;\n', '        votesByAddress[msg.sender].weight = 0;\n', '        votesByAddress[msg.sender].agree = false;\n', '\n', '        totalVoted = safeSub(totalVoted, 1);\n', '        if(agree) {\n', '            yesCounter = safeSub(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeSub(noCounter, voiceWeight);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function is called after token transfer from user`s wallet to check and correct user`s vote\n', '     *\n', '     */\n', '    function onTokenTransfer(address tokenHolder, uint256 amount) public {\n', '        require(msg.sender == fundAddress);\n', '        if(votesByAddress[tokenHolder].time == 0) {\n', '            return;\n', '        }\n', '        if(!checkTransfersAfterEnd) {\n', '             if(finalized || (now < startTime || now > endTime)) {\n', '                 return;\n', '             }\n', '        }\n', '\n', '        if(token.balanceOf(tokenHolder) >= votesByAddress[tokenHolder].weight) {\n', '            return;\n', '        }\n', '        uint256 voiceWeight = amount;\n', '        if(amount > votesByAddress[tokenHolder].weight) {\n', '            voiceWeight = votesByAddress[tokenHolder].weight;\n', '        }\n', '\n', '        if(votesByAddress[tokenHolder].agree) {\n', '            yesCounter = safeSub(yesCounter, voiceWeight);\n', '        } else {\n', '            noCounter = safeSub(noCounter, voiceWeight);\n', '        }\n', '        votesByAddress[tokenHolder].weight = safeSub(votesByAddress[tokenHolder].weight, voiceWeight);\n', '    }\n', '\n', '    /**\n', '     * Finalize poll and call onPollFinish callback with result\n', '     */\n', '    function tryToFinalize() public notFinalized returns(bool) {\n', '        if(now < endTime) {\n', '            return false;\n', '        }\n', '        finalized = true;\n', '        onPollFinish(isSubjectApproved());\n', '        return true;\n', '    }\n', '\n', '    function isNowApproved() public view returns(bool) {\n', '        return isSubjectApproved();\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter;\n', '    }\n', '\n', '    /**\n', '     * @dev callback called after poll finalization\n', '     */\n', '    function onPollFinish(bool agree) internal;\n', '}\n', '\n', '// File: contracts/RefundPoll.sol\n', '\n', '/**\n', ' * @title RefundPoll\n', ' * @dev Enables fund refund mode\n', ' */\n', 'contract RefundPoll is BasePoll {\n', '    uint256 public holdEndTime = 0;\n', '\n', '    /**\n', '     * RefundPoll constructor\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     */\n', '    function RefundPoll(\n', '        address _tokenAddress,\n', '        address _fundAddress,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _holdEndTime,\n', '        bool _checkTransfersAfterEnd\n', '    ) public\n', '        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, _checkTransfersAfterEnd)\n', '    {\n', '        holdEndTime = _holdEndTime;\n', '    }\n', '\n', '    function tryToFinalize() public returns(bool) {\n', '        if(holdEndTime > 0 && holdEndTime > endTime) {\n', '            require(now >= holdEndTime);\n', '        } else {\n', '            require(now >= endTime);\n', '        }\n', '\n', '        finalized = true;\n', '        onPollFinish(isSubjectApproved());\n', '        return true;\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter && yesCounter >= safeDiv(token.totalSupply(), 3);\n', '    }\n', '\n', '    function onPollFinish(bool agree) internal {\n', '        IPollManagedFund fund = IPollManagedFund(fundAddress);\n', '        fund.onRefundPollFinish(agree);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/TapPoll.sol\n', '\n', '/**\n', ' * @title TapPoll\n', ' * @dev Poll to increase tap amount\n', ' */\n', 'contract TapPoll is BasePoll {\n', '    uint256 public tap;\n', '    uint256 public minTokensPerc = 0;\n', '\n', '    /**\n', '     * TapPoll constructor\n', '     * @param _tap New tap value\n', '     * @param _tokenAddress ERC20 compatible token contract address\n', '     * @param _fundAddress Fund contract address\n', '     * @param _startTime Poll start time\n', '     * @param _endTime Poll end time\n', '     * @param _minTokensPerc - Min percent of tokens from totalSupply where poll is considered to be fulfilled\n', '     */\n', '    function TapPoll(\n', '        uint256 _tap,\n', '        address _tokenAddress,\n', '        address _fundAddress,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _minTokensPerc\n', '    ) public\n', '        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, false)\n', '    {\n', '        tap = _tap;\n', '        minTokensPerc = _minTokensPerc;\n', '    }\n', '\n', '    function onPollFinish(bool agree) internal {\n', '        IPollManagedFund fund = IPollManagedFund(fundAddress);\n', '        fund.onTapPollFinish(agree, tap);\n', '    }\n', '\n', '    function getVotedTokensPerc() public view returns(uint256) {\n', '        return safeDiv(safeMul(safeAdd(yesCounter, noCounter), 100), token.totalSupply());\n', '    }\n', '\n', '    function isSubjectApproved() internal view returns(bool) {\n', '        return yesCounter > noCounter && getVotedTokensPerc() >= minTokensPerc;\n', '    }\n', '}\n', '\n', '// File: contracts/PollManagedFund.sol\n', '\n', '/**\n', ' * @title PollManagedFund\n', ' * @dev Fund controlled by users\n', ' */\n', 'contract PollManagedFund is Fund, DateTime, ITokenEventListener {\n', '    uint256 public constant TAP_POLL_DURATION = 3 days;\n', '    uint256 public constant REFUND_POLL_DURATION = 7 days;\n', '    uint256 public constant MAX_VOTED_TOKEN_PERC = 10;\n', '\n', '    TapPoll public tapPoll;\n', '    RefundPoll public refundPoll;\n', '\n', '    uint256 public minVotedTokensPerc = 0;\n', '    uint256 public secondRefundPollDate = 0;\n', '    bool public isWithdrawEnabled = true;\n', '\n', '    uint256[] public refundPollDates = [\n', '        1530403200, // 01.07.2018\n', '        1538352000, // 01.10.2018\n', '        1546300800, // 01.01.2019\n', '        1554076800, // 01.04.2019\n', '        1561939200, // 01.07.2019\n', '        1569888000, // 01.10.2019\n', '        1577836800, // 01.01.2020\n', '        1585699200  // 01.04.2020\n', '    ];\n', '\n', '    modifier onlyTokenHolder() {\n', '        require(token.balanceOf(msg.sender) > 0);\n', '        _;\n', '    }\n', '\n', '    event TapPollCreated();\n', '    event TapPollFinished(bool approved, uint256 _tap);\n', '    event RefundPollCreated();\n', '    event RefundPollFinished(bool approved);\n', '\n', '    /**\n', '     * @dev PollManagedFund constructor\n', '     * params - see Fund constructor\n', '     */\n', '    function PollManagedFund(\n', '        address _teamWallet,\n', '        address _referralTokenWallet,\n', '        address _foundationTokenWallet,\n', '        address _companyTokenWallet,\n', '        address _reserveTokenWallet,\n', '        address _bountyTokenWallet,\n', '        address _advisorTokenWallet,\n', '        address[] _owners\n', '        ) public\n', '    Fund(_teamWallet, _referralTokenWallet, _foundationTokenWallet, _companyTokenWallet, _reserveTokenWallet, _bountyTokenWallet, _advisorTokenWallet, _owners)\n', '    {\n', '    }\n', '\n', '    function canWithdraw() public returns(bool) {\n', '        if(\n', '            address(refundPoll) != address(0) &&\n', '            !refundPoll.finalized() &&\n', '            refundPoll.holdEndTime() > 0 &&\n', '            now >= refundPoll.holdEndTime() &&\n', '            refundPoll.isNowApproved()\n', '        ) {\n', '            return false;\n', '        }\n', '        return isWithdrawEnabled;\n', '    }\n', '\n', '    /**\n', '     * @dev ITokenEventListener implementation. Notify active poll contracts about token transfers\n', '     */\n', '    function onTokenTransfer(address _from, address /*_to*/, uint256 _value) external {\n', '        require(msg.sender == address(token));\n', '        if(address(tapPoll) != address(0) && !tapPoll.finalized()) {\n', '            tapPoll.onTokenTransfer(_from, _value);\n', '        }\n', '         if(address(refundPoll) != address(0) && !refundPoll.finalized()) {\n', '            refundPoll.onTokenTransfer(_from, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update minVotedTokensPerc value after tap poll.\n', '     * Set new value == 50% from current voted tokens amount\n', '     */\n', '    function updateMinVotedTokens(uint256 _minVotedTokensPerc) internal {\n', '        uint256 newPerc = safeDiv(_minVotedTokensPerc, 2);\n', '        if(newPerc > MAX_VOTED_TOKEN_PERC) {\n', '            minVotedTokensPerc = MAX_VOTED_TOKEN_PERC;\n', '            return;\n', '        }\n', '        minVotedTokensPerc = newPerc;\n', '    }\n', '\n', '    // Tap poll\n', '    function createTapPoll(uint8 tapIncPerc) public onlyOwner {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(tapPoll == address(0));\n', '        require(getDay(now) == 10);\n', '        require(tapIncPerc <= 50);\n', '        uint256 _tap = safeAdd(tap, safeDiv(safeMul(tap, tapIncPerc), 100));\n', '        uint256 startTime = now;\n', '        uint256 endTime = startTime + TAP_POLL_DURATION;\n', '        tapPoll = new TapPoll(_tap, token, this, startTime, endTime, minVotedTokensPerc);\n', '        TapPollCreated();\n', '    }\n', '\n', '    function onTapPollFinish(bool agree, uint256 _tap) external {\n', '        require(msg.sender == address(tapPoll) && tapPoll.finalized());\n', '        if(agree) {\n', '            tap = _tap;\n', '        }\n', '        updateMinVotedTokens(tapPoll.getVotedTokensPerc());\n', '        TapPollFinished(agree, _tap);\n', '        delete tapPoll;\n', '    }\n', '\n', '    // Refund poll\n', '    function checkRefundPollDate() internal view returns(bool) {\n', '        if(secondRefundPollDate > 0 && now >= secondRefundPollDate && now <= safeAdd(secondRefundPollDate, 1 days)) {\n', '            return true;\n', '        }\n', '\n', '        for(uint i; i < refundPollDates.length; i++) {\n', '            if(now >= refundPollDates[i] && now <= safeAdd(refundPollDates[i], 1 days)) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function createRefundPoll() public onlyTokenHolder {\n', '        require(state == FundState.TeamWithdraw);\n', '        require(address(refundPoll) == address(0));\n', '        require(checkRefundPollDate());\n', '\n', '        if(secondRefundPollDate > 0 && now > safeAdd(secondRefundPollDate, 1 days)) {\n', '            secondRefundPollDate = 0;\n', '        }\n', '\n', '        uint256 startTime = now;\n', '        uint256 endTime = startTime + REFUND_POLL_DURATION;\n', '        bool isFirstRefund = secondRefundPollDate == 0;\n', '        uint256 holdEndTime = 0;\n', '\n', '        if(isFirstRefund) {\n', '            holdEndTime = toTimestamp(\n', '                getYear(startTime),\n', '                getMonth(startTime) + 1,\n', '                1\n', '            );\n', '        }\n', '        refundPoll = new RefundPoll(token, this, startTime, endTime, holdEndTime, isFirstRefund);\n', '        RefundPollCreated();\n', '    }\n', '\n', '    function onRefundPollFinish(bool agree) external {\n', '        require(msg.sender == address(refundPoll) && refundPoll.finalized());\n', '        if(agree) {\n', '            if(secondRefundPollDate > 0) {\n', '                enableRefund();\n', '            } else {\n', '                uint256 startTime = refundPoll.startTime();\n', '                secondRefundPollDate = toTimestamp(\n', '                    getYear(startTime),\n', '                    getMonth(startTime) + 2,\n', '                    1\n', '                );\n', '                isWithdrawEnabled = false;\n', '            }\n', '        } else {\n', '            secondRefundPollDate = 0;\n', '            isWithdrawEnabled = true;\n', '        }\n', '        RefundPollFinished(agree);\n', '\n', '        delete refundPoll;\n', '    }\n', '\n', '    function forceRefund() public onlyOwner {\n', '        enableRefund();\n', '    }\n', '}']
