['pragma solidity ^0.4.7;\n', 'contract MobaBase {\n', '    address public owner = 0x0;\n', '    bool public isLock = false;\n', '    constructor ()  public  {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    event transferToOwnerEvent(uint256 price);\n', '    \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"only owner can call this function");\n', '        _;\n', '    }\n', '    \n', '    modifier notLock {\n', '        require(isLock == false,"contract current is lock status");\n', '        _;\n', '    }\n', '    \n', '    modifier msgSendFilter() {\n', '        address addr = msg.sender;\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size <= 0,"address must is not contract");\n', '        require(msg.sender == tx.origin, "msg.sender must equipt tx.origin");\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function transferToOwner()    \n', '    onlyOwner \n', '    msgSendFilter \n', '    public {\n', '        uint256 totalBalace = address(this).balance;\n', '        owner.transfer(totalBalace);\n', '        emit transferToOwnerEvent(totalBalace);\n', '    }\n', '    \n', '    function updateLock(bool b) onlyOwner public {\n', '        \n', '        require(isLock != b," updateLock new status == old status");\n', '        isLock = b;\n', '    }\n', '    \n', '   \n', '}\n', '\n', 'contract IConfigData {\n', '   function getPrice() public view returns (uint256);\n', '   function getWinRate(uint8 winCount) public pure returns (uint);\n', '   function getOverRate(uint8 winCount) public pure returns (uint);\n', '   function getPumpRate() public view returns(uint8);\n', '   function getRandom(bytes32 param) public returns (bytes32);\n', '   function GetAddressByName(bytes32 name) public view returns (address);\n', '   function getInviteRate() public view returns (uint);\n', '   function loseHandler(address addr,uint8 wincount) public ;\n', '}\n', '\n', 'contract BRBasketballControl is MobaBase {\n', '    \n', '    Winner public mWinner;\n', '    bytes32 mRandomValue;\n', '\n', '    uint gameIndex;\n', '    IConfigData public mConfig;\n', '    IConfigData public mNewConfig;\n', '   \n', '    constructor(address config) public {\n', '        mConfig = IConfigData(config);\n', '        startNewGame();\n', '    }\n', '    event pkEvent(address winAddr,address pkAddr,bytes32 pkInviteName,uint winRate,uint overRate,uint curWinRate,uint curOverRate,bool pkIsWin,uint256 price);\n', '    event gameOverEvent(uint gameIndex,address winAddr,uint256 price,uint256 totalBalace);\n', '    struct Winner {\n', '        uint8 num;\n', '        uint8 winCount;\n', '        address addr;\n', '    }\n', '    \n', '    function updateConfig(address newAddr)\n', '    onlyOwner \n', '    public{\n', '        mNewConfig = IConfigData(newAddr);\n', '  \n', '    }\n', '    \n', '    function PK(uint8 num,bytes32 name) \n', '    notLock\n', '    msgSendFilter\n', '    public payable {\n', '        \n', '        require(msg.value == mConfig.getPrice(),"msg.value is error");\n', '        require(msg.sender != mWinner.addr,"msg.sender != winner");\n', '        uint winRate  = mConfig.getWinRate(mWinner.winCount);\n', '\n', '        uint curWinRate ; uint curOverRate;\n', '        (curWinRate,curOverRate) = getRandom(100);\n', '        \n', '  \n', '                \n', '        inviteHandler(name);\n', '        address oldWinAddr = mWinner.addr;\n', '        if(mWinner.addr == address(0) ) {\n', '            mWinner = Winner(num,0,msg.sender);\n', '        }\n', '        else if( winRate < curWinRate ) {\n', '            mWinner = Winner(num,1,msg.sender);\n', '        }\n', '        else{\n', '            mWinner.winCount = mWinner.winCount + 1;\n', '        }\n', '        uint overRate = mConfig.getOverRate(mWinner.winCount);\n', '        emit pkEvent(mWinner.addr,msg.sender,name, winRate, overRate, curWinRate, curOverRate,msg.sender == mWinner.addr, mConfig.getPrice());\n', '        if(oldWinAddr != address(0) && curOverRate < overRate  ) {\n', '        \n', '          require(mWinner.addr != address(0),"Winner.addr is null");\n', '          \n', '          uint pumpRate = mConfig.getPumpRate();\n', '          uint totalBalace = address(this).balance;\n', '          uint giveToOwn   = totalBalace * pumpRate / 100;\n', '          uint giveToActor = totalBalace - giveToOwn;\n', '          owner.transfer(giveToOwn);\n', '          mWinner.addr.transfer(giveToActor);\n', '            \n', '         emit gameOverEvent(gameIndex, mWinner.addr,mConfig.getPrice(),giveToActor);\n', '          startNewGame();\n', '        }\n', '    }\n', '    \n', '    function startNewGame() private {\n', '        \n', '        gameIndex++;\n', '        mWinner = Winner(0,1,address(0));\n', '        if(mNewConfig != address(0) && mNewConfig != mConfig){\n', '            mConfig = mNewConfig;\n', '        }\n', '    }\n', '    \n', '    function inviteHandler(bytes32 inviteName) private {\n', '        \n', '        if(mConfig == address(0)) {\n', '          return ;\n', '        }\n', '        address inviteAddr = mConfig.GetAddressByName(inviteName);\n', '        if(inviteAddr != address(0)) {\n', '           uint giveToEth   = msg.value * mConfig.getInviteRate() / 100;\n', '           inviteAddr.transfer(giveToEth);\n', '        }\n', '    }\n', '    function getRandom(uint maxNum) private returns(uint,uint) {\n', '     \n', '        bytes32 curRandom = keccak256(abi.encodePacked(msg.sender,mRandomValue));\n', '        curRandom = mConfig.getRandom(curRandom);\n', '        curRandom = keccak256(abi.encodePacked(msg.sender,mRandomValue));\n', '        uint value1 = (uint(curRandom) % maxNum);\n', '        \n', '        curRandom  = keccak256(abi.encodePacked(msg.sender,curRandom,value1));\n', '        uint value2 = (uint(curRandom) % maxNum);\n', '        mRandomValue = curRandom;\n', '        return (value1,value2);\n', '    }\n', '    \n', '    function getGameInfo() public view returns (uint index,uint price,uint256 balace, \n', '                                          uint winNum,uint winCount,address WinAddr,uint winRate,uint winOverRate,\n', '                                          uint pkOverRate\n', '                                          ){\n', '        uint curbalace    = address(this).balance;\n', '        uint winnernum   = mWinner.num;\n', '        uint winnercount = mWinner.winCount;\n', '        address winneraddr  = mWinner.addr;\n', '        uint curWinRate  = mConfig.getWinRate(mWinner.winCount);\n', '        uint curOverRate = mConfig.getOverRate(mWinner.winCount);\n', '        uint curPkOverRate= mConfig.getOverRate(1);\n', '        return (gameIndex, mConfig.getPrice(), curbalace,\n', '                winnernum,winnercount,winneraddr,curWinRate,curOverRate,\n', '                curPkOverRate);\n', '    }\n', '}']
['pragma solidity ^0.4.7;\n', 'contract MobaBase {\n', '    address public owner = 0x0;\n', '    bool public isLock = false;\n', '    constructor ()  public  {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    event transferToOwnerEvent(uint256 price);\n', '    \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"only owner can call this function");\n', '        _;\n', '    }\n', '    \n', '    modifier notLock {\n', '        require(isLock == false,"contract current is lock status");\n', '        _;\n', '    }\n', '    \n', '    modifier msgSendFilter() {\n', '        address addr = msg.sender;\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size <= 0,"address must is not contract");\n', '        require(msg.sender == tx.origin, "msg.sender must equipt tx.origin");\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function transferToOwner()    \n', '    onlyOwner \n', '    msgSendFilter \n', '    public {\n', '        uint256 totalBalace = address(this).balance;\n', '        owner.transfer(totalBalace);\n', '        emit transferToOwnerEvent(totalBalace);\n', '    }\n', '    \n', '    function updateLock(bool b) onlyOwner public {\n', '        \n', '        require(isLock != b," updateLock new status == old status");\n', '        isLock = b;\n', '    }\n', '    \n', '   \n', '}\n', '\n', 'contract IConfigData {\n', '   function getPrice() public view returns (uint256);\n', '   function getWinRate(uint8 winCount) public pure returns (uint);\n', '   function getOverRate(uint8 winCount) public pure returns (uint);\n', '   function getPumpRate() public view returns(uint8);\n', '   function getRandom(bytes32 param) public returns (bytes32);\n', '   function GetAddressByName(bytes32 name) public view returns (address);\n', '   function getInviteRate() public view returns (uint);\n', '   function loseHandler(address addr,uint8 wincount) public ;\n', '}\n', '\n', 'contract BRBasketballControl is MobaBase {\n', '    \n', '    Winner public mWinner;\n', '    bytes32 mRandomValue;\n', '\n', '    uint gameIndex;\n', '    IConfigData public mConfig;\n', '    IConfigData public mNewConfig;\n', '   \n', '    constructor(address config) public {\n', '        mConfig = IConfigData(config);\n', '        startNewGame();\n', '    }\n', '    event pkEvent(address winAddr,address pkAddr,bytes32 pkInviteName,uint winRate,uint overRate,uint curWinRate,uint curOverRate,bool pkIsWin,uint256 price);\n', '    event gameOverEvent(uint gameIndex,address winAddr,uint256 price,uint256 totalBalace);\n', '    struct Winner {\n', '        uint8 num;\n', '        uint8 winCount;\n', '        address addr;\n', '    }\n', '    \n', '    function updateConfig(address newAddr)\n', '    onlyOwner \n', '    public{\n', '        mNewConfig = IConfigData(newAddr);\n', '  \n', '    }\n', '    \n', '    function PK(uint8 num,bytes32 name) \n', '    notLock\n', '    msgSendFilter\n', '    public payable {\n', '        \n', '        require(msg.value == mConfig.getPrice(),"msg.value is error");\n', '        require(msg.sender != mWinner.addr,"msg.sender != winner");\n', '        uint winRate  = mConfig.getWinRate(mWinner.winCount);\n', '\n', '        uint curWinRate ; uint curOverRate;\n', '        (curWinRate,curOverRate) = getRandom(100);\n', '        \n', '  \n', '                \n', '        inviteHandler(name);\n', '        address oldWinAddr = mWinner.addr;\n', '        if(mWinner.addr == address(0) ) {\n', '            mWinner = Winner(num,0,msg.sender);\n', '        }\n', '        else if( winRate < curWinRate ) {\n', '            mWinner = Winner(num,1,msg.sender);\n', '        }\n', '        else{\n', '            mWinner.winCount = mWinner.winCount + 1;\n', '        }\n', '        uint overRate = mConfig.getOverRate(mWinner.winCount);\n', '        emit pkEvent(mWinner.addr,msg.sender,name, winRate, overRate, curWinRate, curOverRate,msg.sender == mWinner.addr, mConfig.getPrice());\n', '        if(oldWinAddr != address(0) && curOverRate < overRate  ) {\n', '        \n', '          require(mWinner.addr != address(0),"Winner.addr is null");\n', '          \n', '          uint pumpRate = mConfig.getPumpRate();\n', '          uint totalBalace = address(this).balance;\n', '          uint giveToOwn   = totalBalace * pumpRate / 100;\n', '          uint giveToActor = totalBalace - giveToOwn;\n', '          owner.transfer(giveToOwn);\n', '          mWinner.addr.transfer(giveToActor);\n', '            \n', '         emit gameOverEvent(gameIndex, mWinner.addr,mConfig.getPrice(),giveToActor);\n', '          startNewGame();\n', '        }\n', '    }\n', '    \n', '    function startNewGame() private {\n', '        \n', '        gameIndex++;\n', '        mWinner = Winner(0,1,address(0));\n', '        if(mNewConfig != address(0) && mNewConfig != mConfig){\n', '            mConfig = mNewConfig;\n', '        }\n', '    }\n', '    \n', '    function inviteHandler(bytes32 inviteName) private {\n', '        \n', '        if(mConfig == address(0)) {\n', '          return ;\n', '        }\n', '        address inviteAddr = mConfig.GetAddressByName(inviteName);\n', '        if(inviteAddr != address(0)) {\n', '           uint giveToEth   = msg.value * mConfig.getInviteRate() / 100;\n', '           inviteAddr.transfer(giveToEth);\n', '        }\n', '    }\n', '    function getRandom(uint maxNum) private returns(uint,uint) {\n', '     \n', '        bytes32 curRandom = keccak256(abi.encodePacked(msg.sender,mRandomValue));\n', '        curRandom = mConfig.getRandom(curRandom);\n', '        curRandom = keccak256(abi.encodePacked(msg.sender,mRandomValue));\n', '        uint value1 = (uint(curRandom) % maxNum);\n', '        \n', '        curRandom  = keccak256(abi.encodePacked(msg.sender,curRandom,value1));\n', '        uint value2 = (uint(curRandom) % maxNum);\n', '        mRandomValue = curRandom;\n', '        return (value1,value2);\n', '    }\n', '    \n', '    function getGameInfo() public view returns (uint index,uint price,uint256 balace, \n', '                                          uint winNum,uint winCount,address WinAddr,uint winRate,uint winOverRate,\n', '                                          uint pkOverRate\n', '                                          ){\n', '        uint curbalace    = address(this).balance;\n', '        uint winnernum   = mWinner.num;\n', '        uint winnercount = mWinner.winCount;\n', '        address winneraddr  = mWinner.addr;\n', '        uint curWinRate  = mConfig.getWinRate(mWinner.winCount);\n', '        uint curOverRate = mConfig.getOverRate(mWinner.winCount);\n', '        uint curPkOverRate= mConfig.getOverRate(1);\n', '        return (gameIndex, mConfig.getPrice(), curbalace,\n', '                winnernum,winnercount,winneraddr,curWinRate,curOverRate,\n', '                curPkOverRate);\n', '    }\n', '}']
