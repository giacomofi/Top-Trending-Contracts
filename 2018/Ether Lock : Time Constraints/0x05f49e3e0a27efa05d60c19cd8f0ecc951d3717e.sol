['pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, &#39;Only the owner can call this method&#39;);\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * In the event of the shortage of funds for the level payments\n', ' * stabilization the contract of the stabilization fund provides backup support to the investment fund. \n', ' */\n', 'contract EtherheroStabilizationFund {\n', '\n', '    address public etherHero;\n', '    uint public investFund;\n', '    uint estGas = 200000;\n', '    event MoneyWithdraw(uint balance);\n', '    event MoneyAdd(uint holding);\n', '\n', '    constructor() public {\n', '        etherHero = msg.sender;\n', '    }\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyHero() {\n', '        require(msg.sender == etherHero, &#39;Only Hero call&#39;);\n', '        _;\n', '    }\n', '\n', '    function ReturnEthToEtherhero() public onlyHero returns(bool) {\n', '\n', '        uint balance = address(this).balance;\n', '        require(balance > estGas, &#39;Not enough funds for transaction&#39;);\n', '\n', '        if (etherHero.call.value(address(this).balance).gas(estGas)()) {\n', '            emit MoneyWithdraw(balance);\n', '            investFund = address(this).balance;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        investFund += msg.value;\n', '        emit MoneyAdd(msg.value);\n', '    }\n', '}\n', '\n', 'contract Etherhero is Ownable {\n', '\n', '    using SafeMath\n', '    for uint;\n', '    // array containing information about beneficiaries\n', '    mapping(address => uint) public userDeposit;\n', '    //array containing information about the time of payment\n', '    mapping(address => uint) public userTime;\n', '    //fund fo transfer percent\n', '    address public projectFund = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;\n', '    EtherheroStabilizationFund public stubF = new EtherheroStabilizationFund();\n', '    uint public percentProjectFund = 10;\n', '    uint public percentDevFund = 1;\n', '    uint public percentStubFund = 10;\n', '    address public addressStub;\n', '    //Gas cost\n', '    uint estGas = 150000;\n', '    uint standartPercent = 30; //3%\n', '    uint responseStubFundLimit = 150; //15%\n', '    uint public minPayment = 5 finney;\n', '    //time through which you can take dividends\n', '    uint chargingTime = 1 days;\n', '\n', '    event NewInvestor(address indexed investor, uint deposit);\n', '    event dividendPayment(address indexed investor, uint value);\n', '    event NewDeposit(address indexed investor, uint value);\n', '\n', '    //public variables for DAPP\n', '    uint public counterDeposits;\n', '    uint public counterPercents;\n', '    uint public counterBeneficiaries;\n', '    uint public timeLastayment;\n', '\n', '    //Memory for user for DAPP\n', '    struct Beneficiaries {\n', '        address investorAddress;\n', '        uint registerTime;\n', '        uint percentWithdraw;\n', '        uint ethWithdraw;\n', '        uint deposits;\n', '        bool real;\n', '    }\n', '\n', '    mapping(address => Beneficiaries) beneficiaries;\n', '\n', '    constructor() public {\n', '        addressStub = stubF;\n', '    }\n', '    //Add beneficiary record\n', '    function insertBeneficiaries(address _address, uint _percentWithdraw, uint _ethWithdraw, uint _deposits) private {\n', '\n', '        Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '\n', '        if (!s_beneficiaries.real) {\n', '            s_beneficiaries.real = true;\n', '            s_beneficiaries.investorAddress = _address;\n', '            s_beneficiaries.percentWithdraw = _percentWithdraw;\n', '            s_beneficiaries.ethWithdraw = _ethWithdraw;\n', '            s_beneficiaries.deposits = _deposits;\n', '            s_beneficiaries.registerTime = now;\n', '            counterBeneficiaries += 1;\n', '        } else {\n', '            s_beneficiaries.percentWithdraw += _percentWithdraw;\n', '            s_beneficiaries.ethWithdraw += _ethWithdraw;\n', '        }\n', '    }\n', '    \n', '    //Get beneficiary record\n', '    function getBeneficiaries(address _address) public view returns(address investorAddress, uint persentWithdraw, uint ethWithdraw, uint registerTime) {\n', '\n', '        Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '\n', '        require(s_beneficiaries.real, &#39;Investor Not Found&#39;);\n', '\n', '        return (\n', '            s_beneficiaries.investorAddress,\n', '            s_beneficiaries.percentWithdraw,\n', '            s_beneficiaries.ethWithdraw,\n', '            s_beneficiaries.registerTime\n', '        );\n', '    }\n', '\n', '    modifier isIssetUser() {\n', '        require(userDeposit[msg.sender] > 0, "Deposit not found");\n', '        _;\n', '    }\n', '\n', '    modifier timePayment() {\n', '        require(now >= userTime[msg.sender].add(chargingTime), "Too fast payout request");\n', '        _;\n', '    }\n', '\n', '    function calculationOfPayment() public view returns(uint) {\n', '        uint interestRate = now.sub(userTime[msg.sender]).div(chargingTime);\n', '        //If the contribution is less than 1 ether, dividends can be received only once a day\n', '        if (userDeposit[msg.sender] < 10 ether) {\n', '            if (interestRate >= 1) {\n', '                return (1);\n', '            } else {\n', '                return (interestRate);\n', '            }\n', '        }\n', '        //If the contribution is less than 10 ether, dividends can be received only once a 3 day\n', '        if (userDeposit[msg.sender] >= 10 ether && userDeposit[msg.sender] < 50 ether) {\n', '            if (interestRate > 3) {\n', '                return (3);\n', '            } else {\n', '                return (interestRate);\n', '            }\n', '        }\n', '        //If the contribution is less than 50 ether, dividends can be received only once a 7 day\n', '        if (userDeposit[msg.sender] >= 50 ether) {\n', '            if (interestRate > 7) {\n', '                return (7);\n', '            } else {\n', '                return (interestRate);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function receivePercent() isIssetUser timePayment internal {\n', '       // verification that funds on the balance sheet are more than 15% of the total number of deposits\n', '        uint balanceLimit = counterDeposits.mul(responseStubFundLimit).div(1000);\n', '        uint payoutRatio = calculationOfPayment();\n', '        //calculate 6% of total deposits\n', '        uint remain = counterDeposits.mul(6).div(100);\n', '        \n', '        if(addressStub.balance > 0){\n', '            if (address(this).balance < balanceLimit) {\n', '                stubF.ReturnEthToEtherhero();\n', '            }\n', '        }\n', '        //If the balance is less than 6% of total deposits, stop paying\n', '        require(address(this).balance >= remain, &#39;contract balance is too small&#39;);\n', '\n', '        uint rate = userDeposit[msg.sender].mul(standartPercent).div(1000).mul(payoutRatio);\n', '        userTime[msg.sender] = now;\n', '        msg.sender.transfer(rate);\n', '        counterPercents += rate;\n', '        timeLastayment = now;\n', '        insertBeneficiaries(msg.sender, standartPercent, rate, 0);\n', '        emit dividendPayment(msg.sender, rate);\n', '    }\n', '\n', '    function makeDeposit() private {\n', '        uint value = msg.value;\n', '        uint calcProjectPercent = value.mul(percentProjectFund).div(100);\n', '        uint calcStubFundPercent = value.mul(percentStubFund).div(100);\n', '        \n', '        if (msg.value > 0) {\n', '            //check for minimum deposit \n', '            require(msg.value >= minPayment, &#39;Minimum deposit 1 finney&#39;);\n', '            \n', '            if (userDeposit[msg.sender] == 0) {\n', '                emit NewInvestor(msg.sender, msg.value);\n', '            }\n', '            \n', '            userDeposit[msg.sender] = userDeposit[msg.sender].add(msg.value);\n', '            userTime[msg.sender] = now;\n', '            insertBeneficiaries(msg.sender, 0, 0, msg.value);\n', '            projectFund.transfer(calcProjectPercent);\n', '            stubF.call.value(calcStubFundPercent).gas(estGas)();\n', '            counterDeposits += msg.value;\n', '            emit NewDeposit(msg.sender, msg.value);\n', '        } else {\n', '            receivePercent();\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.sender != addressStub) {\n', '            makeDeposit();\n', '        }\n', '    }\n', '}']