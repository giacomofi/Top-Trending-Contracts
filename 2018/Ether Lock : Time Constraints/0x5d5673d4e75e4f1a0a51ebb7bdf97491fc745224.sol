['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/// @title BibBom Token Holding Incentive Program\n', '/// @author TranTho - <thoff@bigbom.com>.\n', '/// For more information, please visit https://bigbom.com.\n', 'contract BBOHoldingContract {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '   \n', '    // During the first 60 days of deployment, this contract opens for deposit of BBO.\n', '    uint public constant DEPOSIT_PERIOD             = 60 days; // = 2 months\n', '\n', '    // 18 months after deposit, user can withdrawal all or part of his/her BBO with bonus.\n', "    // The bonus is this contract's initial BBO balance.\n", '    uint public constant WITHDRAWAL_DELAY           = 360 days; // = 1 year \n', '\n', '    // Send 0.001ETH per 10000 BBO partial withdrawal, or 0 for a once-for-all withdrawal.\n', '    // All ETH will be returned.\n', '    uint public constant WITHDRAWAL_SCALE           = 1E7; // 1ETH for withdrawal of 10,000,000 BBO.\n', '\n', '    // Ower can drain all remaining BBO after 3 years.\n', '    uint public constant DRAIN_DELAY                = 720 days; // = 2 years.\n', '    \n', '    address public bboTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '\n', '    uint public bboDeposited        = 0;\n', '    uint public depositStartTime    = 0;\n', '    uint public depositStopTime     = 0;\n', '\n', '    struct Record {\n', '        uint bboAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) records;\n', '    \n', '    /* \n', '     * EVENTS\n', '     */\n', '\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted when all BBO are drained.\n', '    event Drained(uint _bboAmount);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint _bboAmount);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _bboAmount);\n', '\n', '    /// @dev Initialize the contract\n', '    /// @param _bboTokenAddress BBO ERC20 token address\n', '    constructor (address _bboTokenAddress, address _owner) public {\n', '        require(_bboTokenAddress != address(0));\n', '        require(_owner != address(0));\n', '\n', '        bboTokenAddress = _bboTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev start the program.\n', '    function start() public {\n', '        require(msg.sender == owner);\n', '        require(depositStartTime == 0);\n', '\n', '        depositStartTime = now;\n', '        depositStopTime  = depositStartTime + DEPOSIT_PERIOD;\n', '\n', '        emit Started(depositStartTime);\n', '    }\n', '\n', '\n', '    /// @dev drain BBO.\n', '    function drain() public {\n', '        require(msg.sender == owner);\n', '        require(depositStartTime > 0 && now >= depositStartTime + DRAIN_DELAY);\n', '\n', '        uint balance = bboBalance();\n', '        require(balance > 0);\n', '\n', '        require(ERC20(bboTokenAddress).transfer(owner, balance));\n', '\n', '        emit Drained(balance);\n', '    }\n', '\n', '    function () payable {\n', '        require(depositStartTime > 0);\n', '\n', '        if (now >= depositStartTime && now <= depositStopTime) {\n', '            depositBBO();\n', '        } else if (now > depositStopTime){\n', '            withdrawBBO();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @return Current BBO balance.\n', '    function bboBalance() public constant returns (uint) {\n', '        return ERC20(bboTokenAddress).balanceOf(address(this));\n', '    }\n', '    function holdBalance() public constant returns (uint) {\n', '        return records[msg.sender].bboAmount;\n', '    }\n', '    function lastDeposit() public constant returns (uint) {\n', '        return records[msg.sender].timestamp;\n', '    }\n', '    /// @dev Deposit BBO.\n', '    function depositBBO() payable {\n', '        require(depositStartTime > 0);\n', '        require(msg.value == 0);\n', '        require(now >= depositStartTime && now <= depositStopTime);\n', '        \n', '        ERC20 bboToken = ERC20(bboTokenAddress);\n', '        uint bboAmount = bboToken\n', '            .balanceOf(msg.sender)\n', '            .min256(bboToken.allowance(msg.sender, address(this)));\n', '\n', '        if(bboAmount > 0){\n', '            require(bboToken.transferFrom(msg.sender, address(this), bboAmount));\n', '            Record storage record = records[msg.sender];\n', '            record.bboAmount = record.bboAmount.add(bboAmount);\n', '            record.timestamp = now;\n', '            records[msg.sender] = record;\n', '\n', '            bboDeposited = bboDeposited.add(bboAmount);\n', '            emit Deposit(depositId++, msg.sender, bboAmount);\n', '        }\n', '    }\n', '\n', '    /// @dev Withdrawal BBO.\n', '    function withdrawBBO() payable {\n', '        require(depositStartTime > 0);\n', '        require(bboDeposited > 0);\n', '\n', '        Record storage record = records[msg.sender];\n', '        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n', '        require(record.bboAmount > 0);\n', '\n', '        uint bboWithdrawalBase = record.bboAmount;\n', '        if (msg.value > 0) {\n', '            bboWithdrawalBase = bboWithdrawalBase\n', '                .min256(msg.value.mul(WITHDRAWAL_SCALE));\n', '        }\n', '\n', '        uint bboBonus = getBonus(bboWithdrawalBase);\n', '        uint balance = bboBalance();\n', '        uint bboAmount = balance.min256(bboWithdrawalBase + bboBonus);\n', '        \n', '        bboDeposited = bboDeposited.sub(bboWithdrawalBase);\n', '        record.bboAmount = record.bboAmount.sub(bboWithdrawalBase);\n', '\n', '        if (record.bboAmount == 0) {\n', '            delete records[msg.sender];\n', '        } else {\n', '            records[msg.sender] = record;\n', '        }\n', '\n', '        emit Withdrawal(withdrawId++, msg.sender, bboAmount);\n', '\n', '        require(ERC20(bboTokenAddress).transfer(msg.sender, bboAmount));\n', '        if (msg.value > 0) {\n', '            msg.sender.transfer(msg.value);\n', '        }\n', '    }\n', '\n', '    function getBonus(uint _bboWithdrawalBase) constant returns (uint) {\n', '        return internalCalculateBonus(bboBalance() - bboDeposited,bboDeposited, _bboWithdrawalBase);\n', '    }\n', '\n', '    function internalCalculateBonus(uint _totalBonusRemaining, uint _bboDeposited, uint _bboWithdrawalBase) constant returns (uint) {\n', '        require(_bboDeposited > 0);\n', '        require(_totalBonusRemaining >= 0);\n', '\n', '        // The bonus is non-linear function to incentivize later withdrawal.\n', '        // bonus = _totalBonusRemaining * power(_bboWithdrawalBase/_bboDeposited, 1.0625)\n', '        return _totalBonusRemaining\n', '            .mul(_bboWithdrawalBase.mul(sqrt(sqrt(sqrt(sqrt(_bboWithdrawalBase))))))\n', '            .div(_bboDeposited.mul(sqrt(sqrt(sqrt(sqrt(_bboDeposited))))));\n', '    }\n', '\n', '    function sqrt(uint x) internal constant returns (uint) {\n', '        uint y = x;\n', '        while (true) {\n', '            uint z = (y + (x / y)) / 2;\n', '            uint w = (z + (x / z)) / 2;\n', '            if (w == y) {\n', '                if (w < y) return w;\n', '                else return y;\n', '            }\n', '            y = w;\n', '        }\n', '    }\n', '}']