['pragma solidity ^0.4.25;\n', '// expansion on original contract from dav&#39;s stronghands contract\n', '\n', '// introducing features:\n', '// Jackpot - 1 in 1000 chance to get jackpot upon losing\n', '// Refund line for loser to get their initial eth back\n', '\n', '// eth distribution:\n', '// each game seeds 0.01 eth to buy P3D with\n', '// each game seeds 0.005 eth to the refund line making a minimum payback each 20 games played\n', '// 0.1 eth to play per player each round\n', '\n', '\n', '// expansion Coded by spielley \n', '\n', '// Thank you for playing Spielleys contract creations.\n', '// spielley is not liable for any contract bugs and exploits known or unknown.\n', 'contract Slaughter3D {\n', '    using SafeMath for uint;\n', '    struct Stage {\n', '        uint8 numberOfPlayers;\n', '        uint256 blocknumber;\n', '        bool finalized;\n', '        mapping (uint8 => address) slotXplayer;\n', '        mapping (address => bool) players;\n', '        mapping (uint8 => address) setMN;\n', '        \n', '    }\n', '    \n', '    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley&#39;s profit sharing payout\n', '    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\n', '    uint256 constant private P3D_SHARE = 0.005 ether;\n', '    \n', '    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\n', '    uint256 constant public OFFER_SIZE = 0.1 ether;\n', '    uint256 public Refundpot;\n', '    uint256 public Jackpot;// 1% of P3D divs to be allocated to the Jackpot\n', '    uint256 public SPASMfee;//1% of P3D divs to be shared with SPASM holders\n', '    mapping(address => uint256) public ETHtoP3Dbymasternode; //eth to buy P3D masternode\n', '    \n', '    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\n', '    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \n', '    uint256 public winningsPerRound = 0.185 ether;\n', '    \n', '    mapping(address => string) public Vanity;\n', '    mapping(address => uint256) private playerVault;\n', '    mapping(uint256 => Stage) public stages;\n', '    mapping(uint256 => address) public RefundWaitingLine;\n', '    mapping(uint256 => address) public Loser;\n', '    uint256 public  NextInLine;//next person to be refunded\n', '    uint256 public  NextAtLineEnd;//next spot to add loser\n', '    uint256 private numberOfFinalizedStages;\n', '    \n', '    uint256 public numberOfStages;\n', '    \n', '    event JackpotWon(address indexed winner, uint256 SizeOfJackpot);\n', '    event SacrificeOffered(address indexed player);\n', '    event SacrificeChosen(address indexed sarifice);\n', '    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\n', '    event StageInvalidated(uint256 indexed stage);\n', '    // UI view functions\n', '    \n', '    \n', '    function previousstageloser()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (Loser[numberOfFinalizedStages]);\n', '    }\n', '    function previousstageplayer1()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (stages[numberOfFinalizedStages].slotXplayer[0]);\n', '    }\n', '    function previousstageplayer2()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (stages[numberOfFinalizedStages].slotXplayer[2]);\n', '    }\n', '    function currentstageplayer1()\n', '        public\n', '        view\n', '        returns( address )\n', '    {\n', '        return (stages[numberOfStages].slotXplayer[0]);\n', '    }\n', '    function currentstageplayer2()\n', '        public\n', '        view\n', '        returns( address )\n', '    {\n', '        return (stages[numberOfStages].slotXplayer[1]);\n', '    }\n', '    function playervanity(address theplayer)\n', '        public\n', '        view\n', '        returns( string )\n', '    {\n', '        return (Vanity[theplayer]);\n', '    }\n', '    function jackpotinfo()\n', '        public\n', '        view\n', '        returns(uint256 SizeOfJackpot )\n', '    {\n', '        return (Jackpot);\n', '    }\n', '    function checkstatus()// true = ready to vallidate\n', '        public\n', '        view\n', '        returns(bool  )\n', '    {\n', '        bool check;\n', '        if(numberOfStages >= numberOfFinalizedStages)\n', '        {\n', '            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\n', '            {\n', '                check = true;\n', '            }\n', '        }\n', '        return (check);\n', '    }\n', '    \n', '    function nextonetogetpaid()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        \n', '        return (RefundWaitingLine[NextInLine]);\n', '    }\n', '   function contractownsthismanyP3D()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        \n', '        return (p3dContract.balanceOf(address(this)));\n', '    }\n', '    // expansion functions\n', '    \n', '    // Buy P3D by masternode \n', '    function Expand(address masternode) public \n', '    {\n', '    uint256 amt = ETHtoP3Dbymasternode[masternode];\n', '    ETHtoP3Dbymasternode[masternode] = 0;\n', '    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d&#39;s address\n', '    p3dContract.buy.value(amt)(masternode);\n', '    \n', '    }\n', '    //fetch P3D divs\n', '    function DivsToRefundpot ()public\n', '    {\n', '        //allocate p3d dividends to contract \n', '            uint256 dividends = p3dContract.myDividends(true);\n', '            require(dividends > 0);\n', '            uint256 base = dividends.div(100);\n', '            p3dContract.withdraw();\n', '            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n', '            Refundpot = Refundpot.add(base.mul(94));\n', '            Jackpot = Jackpot.add(base.mul(5)); // allocation to jackpot\n', '            //\n', '    }\n', '    //Donate to losers\n', '    function DonateToLosers ()public payable\n', '    {\n', '            require(msg.value > 0);\n', '            Refundpot = Refundpot.add(msg.value);\n', '\n', '    }\n', '    // next loser payout\n', '    function Payoutnextrefund ()public\n', '    {\n', '        //allocate p3d dividends to sacrifice if existing\n', '            uint256 Pot = Refundpot;\n', '            require(Pot > 0.1 ether);\n', '            Refundpot -= 0.1 ether;\n', '            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n', '            NextInLine++;\n', '            //\n', '    }\n', '    //changevanity\n', '    function changevanity(string van , address masternode) public payable\n', '    {\n', '    require(msg.value >= 1  finney);\n', '    Vanity[msg.sender] = van;\n', '    uint256 amt = ETHtoP3Dbymasternode[masternode].add(msg.value);\n', '    ETHtoP3Dbymasternode[masternode] = 0;\n', '    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d&#39;s address\n', '    p3dContract.buy.value(amt)(masternode);\n', '    }\n', '    // Sac dep\n', '    modifier isValidOffer()\n', '    {\n', '        require(msg.value == OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier canPayFromVault()\n', '    {\n', '        require(playerVault[msg.sender] >= OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier hasEarnings()\n', '    {\n', '        require(playerVault[msg.sender] > 0);\n', '        _;\n', '    }\n', '    \n', '    modifier prepareStage()\n', '    {\n', '        //create a new stage if current has reached max amount of players\n', '        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '           stages[numberOfStages] = Stage(0, 0, false );\n', '           numberOfStages++;\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier isNewToStage()\n', '    {\n', '        require(stages[numberOfStages - 1].players[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    constructor()\n', '        public\n', '    {\n', '        stages[numberOfStages] = Stage(0, 0, false);\n', '        numberOfStages++;\n', '    }\n', '    \n', '    function() external payable {}\n', '    \n', '    function offerAsSacrifice(address MN)\n', '        external\n', '        payable\n', '        isValidOffer\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        acceptOffer(MN);\n', '        \n', '        //try to choose a sacrifice in an already full stage (finalize a stage)\n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function offerAsSacrificeFromVault(address MN)\n', '        external\n', '        canPayFromVault\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        playerVault[msg.sender] -= OFFER_SIZE;\n', '        \n', '        acceptOffer(MN);\n', '        \n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function withdraw()\n', '        external\n', '        hasEarnings\n', '    {\n', '        tryFinalizeStage();\n', '        \n', '        uint256 amount = playerVault[msg.sender];\n', '        playerVault[msg.sender] = 0;\n', '        \n', '        emit EarningsWithdrawn(msg.sender, amount); \n', '        \n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function myEarnings()\n', '        external\n', '        view\n', '        hasEarnings\n', '        returns(uint256)\n', '    {\n', '        return playerVault[msg.sender];\n', '    }\n', '    \n', '    function currentPlayers()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return stages[numberOfStages - 1].numberOfPlayers;\n', '    }\n', '    \n', '    function acceptOffer(address MN)\n', '        private\n', '    {\n', '        Stage storage currentStage = stages[numberOfStages - 1];\n', '        \n', '        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\n', '        \n', '        address player = msg.sender;\n', '        \n', '        //add player to current stage\n', '        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\n', '        currentStage.numberOfPlayers++;\n', '        currentStage.players[player] = true;\n', '        currentStage.setMN[currentStage.numberOfPlayers] = MN;\n', '        emit SacrificeOffered(player);\n', '        \n', '        //add blocknumber to current stage when the last player is added\n', '        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '            currentStage.blocknumber = block.number;\n', '        }\n', '        \n', '    }\n', '    \n', '    function tryFinalizeStage()\n', '        public\n', '    {\n', '        assert(numberOfStages >= numberOfFinalizedStages);\n', '        \n', '        //there are no stages to finalize\n', '        if(numberOfStages == numberOfFinalizedStages) {return;}\n', '        \n', '        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\n', '        \n', '        assert(!stageToFinalize.finalized);\n', '        \n', '        //stage is not ready to be finalized\n', '        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\n', '        \n', '        assert(stageToFinalize.blocknumber != 0);\n', '        \n', '        //check if blockhash can be determined\n', '        if(block.number - 256 <= stageToFinalize.blocknumber) {\n', '            //blocknumber of stage can not be equal to current block number -> blockhash() won&#39;t work\n', '            if(block.number == stageToFinalize.blocknumber) {return;}\n', '                \n', '            //determine sacrifice\n', '            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\n', '            uint256 jackpot = uint256(blockhash(stageToFinalize.blocknumber)) % 1000;\n', '            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\n', '            Loser[numberOfFinalizedStages] = sacrifice;\n', '            emit SacrificeChosen(sacrifice);\n', '            \n', '            //allocate winnings to survivors\n', '            allocateSurvivorWinnings(sacrifice);\n', '            \n', '            //check jackpot win\n', '            if(jackpot == 777){\n', '                sacrifice.transfer(Jackpot);\n', '                emit JackpotWon ( sacrifice, Jackpot);\n', '                Jackpot = 0;\n', '            }\n', '            \n', '            \n', '            //add sacrifice to refund waiting line\n', '            RefundWaitingLine[NextAtLineEnd] = sacrifice;\n', '            NextAtLineEnd++;\n', '            \n', '            //set eth to MN for buying P3D \n', '            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[1]].add(0.005 ether);\n', '            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[2]].add(0.005 ether);\n', '            \n', '            //add 0.005 ether to Refundpot\n', '            Refundpot = Refundpot.add(0.005 ether);\n', '            //purchase p3d (using ref) deprecated\n', '            //p3dContract.buy.value(p3dPerStage)(address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\n', '        } else {\n', '            invalidateStage(numberOfFinalizedStages);\n', '            \n', '            emit StageInvalidated(numberOfFinalizedStages);\n', '        }\n', '        //finalize stage\n', '        stageToFinalize.finalized = true;\n', '        numberOfFinalizedStages++;\n', '    }\n', '    \n', '    function allocateSurvivorWinnings(address sacrifice)\n', '        private\n', '    {\n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\n', '            if(survivor != sacrifice) {\n', '                playerVault[survivor] += winningsPerRound;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function invalidateStage(uint256 stageIndex)\n', '        private\n', '    {\n', '        Stage storage stageToInvalidate = stages[stageIndex];\n', '        \n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address player = stageToInvalidate.slotXplayer[i];\n', '            playerVault[player] += OFFER_SIZE;\n', '        }\n', '    }\n', '}\n', '\n', 'interface HourglassInterface {\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function withdraw() external;\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '}\n', 'interface SPASMInterface  {\n', '    function() payable external;\n', '    function disburse() external  payable;\n', '}\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', "// expansion on original contract from dav's stronghands contract\n", '\n', '// introducing features:\n', '// Jackpot - 1 in 1000 chance to get jackpot upon losing\n', '// Refund line for loser to get their initial eth back\n', '\n', '// eth distribution:\n', '// each game seeds 0.01 eth to buy P3D with\n', '// each game seeds 0.005 eth to the refund line making a minimum payback each 20 games played\n', '// 0.1 eth to play per player each round\n', '\n', '\n', '// expansion Coded by spielley \n', '\n', '// Thank you for playing Spielleys contract creations.\n', '// spielley is not liable for any contract bugs and exploits known or unknown.\n', 'contract Slaughter3D {\n', '    using SafeMath for uint;\n', '    struct Stage {\n', '        uint8 numberOfPlayers;\n', '        uint256 blocknumber;\n', '        bool finalized;\n', '        mapping (uint8 => address) slotXplayer;\n', '        mapping (address => bool) players;\n', '        mapping (uint8 => address) setMN;\n', '        \n', '    }\n', '    \n', '    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', "    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n", '    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\n', '    uint256 constant private P3D_SHARE = 0.005 ether;\n', '    \n', '    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\n', '    uint256 constant public OFFER_SIZE = 0.1 ether;\n', '    uint256 public Refundpot;\n', '    uint256 public Jackpot;// 1% of P3D divs to be allocated to the Jackpot\n', '    uint256 public SPASMfee;//1% of P3D divs to be shared with SPASM holders\n', '    mapping(address => uint256) public ETHtoP3Dbymasternode; //eth to buy P3D masternode\n', '    \n', '    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\n', '    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \n', '    uint256 public winningsPerRound = 0.185 ether;\n', '    \n', '    mapping(address => string) public Vanity;\n', '    mapping(address => uint256) private playerVault;\n', '    mapping(uint256 => Stage) public stages;\n', '    mapping(uint256 => address) public RefundWaitingLine;\n', '    mapping(uint256 => address) public Loser;\n', '    uint256 public  NextInLine;//next person to be refunded\n', '    uint256 public  NextAtLineEnd;//next spot to add loser\n', '    uint256 private numberOfFinalizedStages;\n', '    \n', '    uint256 public numberOfStages;\n', '    \n', '    event JackpotWon(address indexed winner, uint256 SizeOfJackpot);\n', '    event SacrificeOffered(address indexed player);\n', '    event SacrificeChosen(address indexed sarifice);\n', '    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\n', '    event StageInvalidated(uint256 indexed stage);\n', '    // UI view functions\n', '    \n', '    \n', '    function previousstageloser()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (Loser[numberOfFinalizedStages]);\n', '    }\n', '    function previousstageplayer1()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (stages[numberOfFinalizedStages].slotXplayer[0]);\n', '    }\n', '    function previousstageplayer2()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return (stages[numberOfFinalizedStages].slotXplayer[2]);\n', '    }\n', '    function currentstageplayer1()\n', '        public\n', '        view\n', '        returns( address )\n', '    {\n', '        return (stages[numberOfStages].slotXplayer[0]);\n', '    }\n', '    function currentstageplayer2()\n', '        public\n', '        view\n', '        returns( address )\n', '    {\n', '        return (stages[numberOfStages].slotXplayer[1]);\n', '    }\n', '    function playervanity(address theplayer)\n', '        public\n', '        view\n', '        returns( string )\n', '    {\n', '        return (Vanity[theplayer]);\n', '    }\n', '    function jackpotinfo()\n', '        public\n', '        view\n', '        returns(uint256 SizeOfJackpot )\n', '    {\n', '        return (Jackpot);\n', '    }\n', '    function checkstatus()// true = ready to vallidate\n', '        public\n', '        view\n', '        returns(bool  )\n', '    {\n', '        bool check;\n', '        if(numberOfStages >= numberOfFinalizedStages)\n', '        {\n', '            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\n', '            {\n', '                check = true;\n', '            }\n', '        }\n', '        return (check);\n', '    }\n', '    \n', '    function nextonetogetpaid()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        \n', '        return (RefundWaitingLine[NextInLine]);\n', '    }\n', '   function contractownsthismanyP3D()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        \n', '        return (p3dContract.balanceOf(address(this)));\n', '    }\n', '    // expansion functions\n', '    \n', '    // Buy P3D by masternode \n', '    function Expand(address masternode) public \n', '    {\n', '    uint256 amt = ETHtoP3Dbymasternode[masternode];\n', '    ETHtoP3Dbymasternode[masternode] = 0;\n', "    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n", '    p3dContract.buy.value(amt)(masternode);\n', '    \n', '    }\n', '    //fetch P3D divs\n', '    function DivsToRefundpot ()public\n', '    {\n', '        //allocate p3d dividends to contract \n', '            uint256 dividends = p3dContract.myDividends(true);\n', '            require(dividends > 0);\n', '            uint256 base = dividends.div(100);\n', '            p3dContract.withdraw();\n', '            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n', '            Refundpot = Refundpot.add(base.mul(94));\n', '            Jackpot = Jackpot.add(base.mul(5)); // allocation to jackpot\n', '            //\n', '    }\n', '    //Donate to losers\n', '    function DonateToLosers ()public payable\n', '    {\n', '            require(msg.value > 0);\n', '            Refundpot = Refundpot.add(msg.value);\n', '\n', '    }\n', '    // next loser payout\n', '    function Payoutnextrefund ()public\n', '    {\n', '        //allocate p3d dividends to sacrifice if existing\n', '            uint256 Pot = Refundpot;\n', '            require(Pot > 0.1 ether);\n', '            Refundpot -= 0.1 ether;\n', '            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n', '            NextInLine++;\n', '            //\n', '    }\n', '    //changevanity\n', '    function changevanity(string van , address masternode) public payable\n', '    {\n', '    require(msg.value >= 1  finney);\n', '    Vanity[msg.sender] = van;\n', '    uint256 amt = ETHtoP3Dbymasternode[masternode].add(msg.value);\n', '    ETHtoP3Dbymasternode[masternode] = 0;\n', "    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n", '    p3dContract.buy.value(amt)(masternode);\n', '    }\n', '    // Sac dep\n', '    modifier isValidOffer()\n', '    {\n', '        require(msg.value == OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier canPayFromVault()\n', '    {\n', '        require(playerVault[msg.sender] >= OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier hasEarnings()\n', '    {\n', '        require(playerVault[msg.sender] > 0);\n', '        _;\n', '    }\n', '    \n', '    modifier prepareStage()\n', '    {\n', '        //create a new stage if current has reached max amount of players\n', '        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '           stages[numberOfStages] = Stage(0, 0, false );\n', '           numberOfStages++;\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier isNewToStage()\n', '    {\n', '        require(stages[numberOfStages - 1].players[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    constructor()\n', '        public\n', '    {\n', '        stages[numberOfStages] = Stage(0, 0, false);\n', '        numberOfStages++;\n', '    }\n', '    \n', '    function() external payable {}\n', '    \n', '    function offerAsSacrifice(address MN)\n', '        external\n', '        payable\n', '        isValidOffer\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        acceptOffer(MN);\n', '        \n', '        //try to choose a sacrifice in an already full stage (finalize a stage)\n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function offerAsSacrificeFromVault(address MN)\n', '        external\n', '        canPayFromVault\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        playerVault[msg.sender] -= OFFER_SIZE;\n', '        \n', '        acceptOffer(MN);\n', '        \n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function withdraw()\n', '        external\n', '        hasEarnings\n', '    {\n', '        tryFinalizeStage();\n', '        \n', '        uint256 amount = playerVault[msg.sender];\n', '        playerVault[msg.sender] = 0;\n', '        \n', '        emit EarningsWithdrawn(msg.sender, amount); \n', '        \n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function myEarnings()\n', '        external\n', '        view\n', '        hasEarnings\n', '        returns(uint256)\n', '    {\n', '        return playerVault[msg.sender];\n', '    }\n', '    \n', '    function currentPlayers()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return stages[numberOfStages - 1].numberOfPlayers;\n', '    }\n', '    \n', '    function acceptOffer(address MN)\n', '        private\n', '    {\n', '        Stage storage currentStage = stages[numberOfStages - 1];\n', '        \n', '        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\n', '        \n', '        address player = msg.sender;\n', '        \n', '        //add player to current stage\n', '        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\n', '        currentStage.numberOfPlayers++;\n', '        currentStage.players[player] = true;\n', '        currentStage.setMN[currentStage.numberOfPlayers] = MN;\n', '        emit SacrificeOffered(player);\n', '        \n', '        //add blocknumber to current stage when the last player is added\n', '        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '            currentStage.blocknumber = block.number;\n', '        }\n', '        \n', '    }\n', '    \n', '    function tryFinalizeStage()\n', '        public\n', '    {\n', '        assert(numberOfStages >= numberOfFinalizedStages);\n', '        \n', '        //there are no stages to finalize\n', '        if(numberOfStages == numberOfFinalizedStages) {return;}\n', '        \n', '        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\n', '        \n', '        assert(!stageToFinalize.finalized);\n', '        \n', '        //stage is not ready to be finalized\n', '        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\n', '        \n', '        assert(stageToFinalize.blocknumber != 0);\n', '        \n', '        //check if blockhash can be determined\n', '        if(block.number - 256 <= stageToFinalize.blocknumber) {\n', "            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\n", '            if(block.number == stageToFinalize.blocknumber) {return;}\n', '                \n', '            //determine sacrifice\n', '            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\n', '            uint256 jackpot = uint256(blockhash(stageToFinalize.blocknumber)) % 1000;\n', '            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\n', '            Loser[numberOfFinalizedStages] = sacrifice;\n', '            emit SacrificeChosen(sacrifice);\n', '            \n', '            //allocate winnings to survivors\n', '            allocateSurvivorWinnings(sacrifice);\n', '            \n', '            //check jackpot win\n', '            if(jackpot == 777){\n', '                sacrifice.transfer(Jackpot);\n', '                emit JackpotWon ( sacrifice, Jackpot);\n', '                Jackpot = 0;\n', '            }\n', '            \n', '            \n', '            //add sacrifice to refund waiting line\n', '            RefundWaitingLine[NextAtLineEnd] = sacrifice;\n', '            NextAtLineEnd++;\n', '            \n', '            //set eth to MN for buying P3D \n', '            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[1]].add(0.005 ether);\n', '            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[2]].add(0.005 ether);\n', '            \n', '            //add 0.005 ether to Refundpot\n', '            Refundpot = Refundpot.add(0.005 ether);\n', '            //purchase p3d (using ref) deprecated\n', '            //p3dContract.buy.value(p3dPerStage)(address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\n', '        } else {\n', '            invalidateStage(numberOfFinalizedStages);\n', '            \n', '            emit StageInvalidated(numberOfFinalizedStages);\n', '        }\n', '        //finalize stage\n', '        stageToFinalize.finalized = true;\n', '        numberOfFinalizedStages++;\n', '    }\n', '    \n', '    function allocateSurvivorWinnings(address sacrifice)\n', '        private\n', '    {\n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\n', '            if(survivor != sacrifice) {\n', '                playerVault[survivor] += winningsPerRound;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function invalidateStage(uint256 stageIndex)\n', '        private\n', '    {\n', '        Stage storage stageToInvalidate = stages[stageIndex];\n', '        \n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address player = stageToInvalidate.slotXplayer[i];\n', '            playerVault[player] += OFFER_SIZE;\n', '        }\n', '    }\n', '}\n', '\n', 'interface HourglassInterface {\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function withdraw() external;\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '}\n', 'interface SPASMInterface  {\n', '    function() payable external;\n', '    function disburse() external  payable;\n', '}\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}']
