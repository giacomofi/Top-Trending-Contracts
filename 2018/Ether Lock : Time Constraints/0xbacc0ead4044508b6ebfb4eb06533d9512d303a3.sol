['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\taddress public controller;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyController() {\n', '\t\trequire(msg.sender == controller);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\tfunction setControler(address _controller) public onlyOwner {\n', '\t\tcontroller = _controller;\n', '\t}\n', '}\n', '\n', 'contract OwnableToken {\n', '\taddress public owner;\n', '\taddress public minter;\n', '\taddress public burner;\n', '\taddress public controller;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tfunction OwnableToken() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyMinter() {\n', '\t\trequire(msg.sender == minter);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyBurner() {\n', '\t\trequire(msg.sender == burner);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyController() {\n', '\t\trequire(msg.sender == controller);\n', '\t\t_;\n', '\t}\n', '  \n', '\tmodifier onlyPayloadSize(uint256 numwords) {                                       \n', '\t\tassert(msg.data.length == numwords * 32 + 4);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\tfunction setMinter(address _minterAddress) public onlyOwner {\n', '\t\tminter = _minterAddress;\n', '\t}\n', '\t\n', '\tfunction setBurner(address _burnerAddress) public onlyOwner {\n', '\t\tburner = _burnerAddress;\n', '\t}\n', '\t\n', '\tfunction setControler(address _controller) public onlyOwner {\n', '\t\tcontroller = _controller;\n', '\t}\n', '}\n', '\n', 'contract KYCControl is OwnableToken {\n', '\tevent KYCApproved(address _user, bool isApproved);\n', '\tmapping(address => bool) public KYCParticipants;\n', '\t\n', '\tfunction isKYCApproved(address _who) view public returns (bool _isAprroved){\n', '\t\treturn KYCParticipants[_who];\n', '\t}\n', '\n', '\tfunction approveKYC(address _userAddress) onlyController public {\n', '\t\tKYCParticipants[_userAddress] = true;\n', '\t\temit KYCApproved(_userAddress, true);\n', '\t}\n', '}\n', '\n', 'contract VernamCrowdSaleToken is OwnableToken, KYCControl {\n', '\tusing SafeMath for uint256;\n', '\t\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '\t/* Public variables of the token */\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public _totalSupply;\n', '\t\n', '\t/*Private Variables*/\n', '\tuint256 constant POW = 10 ** 18;\n', '\tuint256 _circulatingSupply;\n', '\t\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '\t\t\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\tevent Mint(address indexed _participant, uint256 value);\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction VernamCrowdSaleToken() public {\n', '\t\tname = "Vernam Crowdsale Token";                            // Set the name for display purposes\n', '\t\tsymbol = "VCT";                               \t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t// Amount of decimals for display purposes\n', '\t\t_totalSupply = SafeMath.mul(1000000000, POW);     \t\t\t//1 Billion Tokens with 18 Decimals\n', '\t\t_circulatingSupply = 0;\n', '\t}\n', '\t\n', '\tfunction mintToken(address _participant, uint256 _mintedAmount) public onlyMinter returns (bool _success) {\n', '\t\trequire(_mintedAmount > 0);\n', '\t\trequire(_circulatingSupply.add(_mintedAmount) <= _totalSupply);\n', '\t\tKYCParticipants[_participant] = false;\n', '\n', '        balances[_participant] =  balances[_participant].add(_mintedAmount);\n', '        _circulatingSupply = _circulatingSupply.add(_mintedAmount);\n', '\t\t\n', '\t\temit Transfer(0, this, _mintedAmount);\n', '        emit Transfer(this, _participant, _mintedAmount);\n', '\t\temit Mint(_participant, _mintedAmount);\n', '\t\t\n', '\t\treturn true;\n', '    }\n', '\t\n', '\tfunction burn(address _participant, uint256 _value) public onlyBurner returns (bool _success) {\n', '        require(_value > 0);\n', '\t\trequire(balances[_participant] >= _value);   \t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(isKYCApproved(_participant) == true);\n', '\t\tbalances[_participant] = balances[_participant].sub(_value);            // Subtract from the sender\n', '\t\t_circulatingSupply = _circulatingSupply.sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);                      \t\t\t// Updates totalSupply\n', '\t\temit Transfer(_participant, 0, _value);\n', '        emit Burn(_participant, _value);\n', '        \n', '\t\treturn true;\n', '    }\n', '  \n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\t\n', '\tfunction circulatingSupply() public view returns (uint256) {\n', '\t\treturn _circulatingSupply;\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '}\n', '\n', 'contract VernamCrowdSale is Ownable {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t// After day 7 you can contribute only more than 10 ethers \n', '\tuint constant TEN_ETHERS = 10 ether;\n', '\t// Minimum and maximum contribution amount\n', '\tuint constant minimumContribution = 100 finney;\n', '\tuint constant maximumContribution = 500 ether;\n', '\t\n', '\t// \n', '\tuint constant FIRST_MONTH = 0;\n', '\tuint constant SECOND_MONTH = 1;\n', '\tuint constant THIRD_MONTH = 2;\n', '\tuint constant FORTH_MONTH = 3;\n', '\tuint constant FIFTH_MONTH = 4;\n', '\tuint constant SIXTH_MONTH = 5;\t\n', '\t\n', '\taddress public benecifiary;\n', '\t\n', '    // Check if the crowdsale is active\n', '\tbool public isInCrowdsale;\n', '\t\n', '\t// The start time of the crowdsale\n', '\tuint public startTime;\n', '\t// The total sold tokens\n', '\tuint public totalSoldTokens;\n', '\t\n', '\t// The total contributed wei\n', '\tuint public totalContributedWei;\n', '\n', '    // Public parameters for all the stages\n', '\tuint constant public threeHotHoursDuration = 3 hours;\n', '\tuint constant public threeHotHoursPriceOfTokenInWei = 63751115644524 wei; //0.00006375111564452380 ETH per Token // 15686 VRN per ETH\n', '\t\t\n', '\tuint public threeHotHoursTokensCap; \n', '\tuint public threeHotHoursCapInWei; \n', '\tuint public threeHotHoursEnd;\n', '\n', '\tuint public firstStageDuration = 8 days;\n', '\tuint public firstStagePriceOfTokenInWei = 85005100306018 wei;    //0.00008500510030601840 ETH per Token // 11764 VRN per ETH\n', '\n', '\tuint public firstStageEnd;\n', '\t\n', '\tuint constant public secondStageDuration = 12 days;\n', '\tuint constant public secondStagePriceOfTokenInWei = 90000900009000 wei;     //0.00009000090000900010 ETH per Token // 11111 VRN per ETH\n', '    \n', '\tuint public secondStageEnd;\n', '\t\n', '\tuint constant public thirdStageDuration = 41 days;\n', '\tuint constant public thirdStagePriceOfTokenInWei = 106258633513973 wei;          //0.00010625863351397300 ETH per Token // 9411 VRN per ETH\n', '\t\n', '\tuint constant public thirdStageDiscountPriceOfTokenInWei = 95002850085503 wei;  //0.00009500285008550260 ETH per Token // 10526 VRN per ETH\n', '\t\n', '\tuint public thirdStageEnd;\n', '\t\n', '\tuint constant public TOKENS_HARD_CAP = 500000000000000000000000000; // 500 000 000 with 18 decimals\n', '\t\n', '\t// 18 decimals\n', '\tuint constant POW = 10 ** 18;\n', '\t\n', '\t// Constants for Realase Three Hot Hours\n', '\tuint constant public LOCK_TOKENS_DURATION = 30 days;\n', '\tuint public firstMonthEnd;\n', '\tuint public secondMonthEnd;\n', '\tuint public thirdMonthEnd;\n', '\tuint public fourthMonthEnd;\n', '\tuint public fifthMonthEnd;\n', '    \n', '    // Mappings\n', '\tmapping(address => uint) public contributedInWei;\n', '\tmapping(address => uint) public threeHotHoursTokens;\n', '\tmapping(address => mapping(uint => uint)) public getTokensBalance;\n', '\tmapping(address => mapping(uint => bool)) public isTokensTaken;\n', '\tmapping(address => bool) public isCalculated;\n', '\t\n', '\tVernamCrowdSaleToken public vernamCrowdsaleToken;\n', '\t\n', '\t// Modifiers\n', '    modifier afterCrowdsale() {\n', '        require(block.timestamp > thirdStageEnd);\n', '        _;\n', '    }\n', '    \n', '    modifier isAfterThreeHotHours {\n', '\t    require(block.timestamp > threeHotHoursEnd);\n', '\t    _;\n', '\t}\n', '\t\n', '    // Events\n', '    event CrowdsaleActivated(uint startTime, uint endTime);\n', '    event TokensBought(address participant, uint weiAmount, uint tokensAmount);\n', '    event ReleasedTokens(uint _amount);\n', '    event TokensClaimed(address _participant, uint tokensToGetFromWhiteList);\n', '    \n', '    /** @dev Constructor \n', '      * @param _benecifiary \n', '      * @param _vernamCrowdSaleTokenAddress The address of the crowdsale token.\n', '      * \n', '      */\n', '\tconstructor(address _benecifiary, address _vernamCrowdSaleTokenAddress) public {\n', '\t\tbenecifiary = _benecifiary;\n', '\t\tvernamCrowdsaleToken = VernamCrowdSaleToken(_vernamCrowdSaleTokenAddress);\n', '        \n', '\t\tisInCrowdsale = false;\n', '\t}\n', '\t\n', '\t/** @dev Function which activates the crowdsale \n', '      * Only the owner can call the function\n', '      * Activates the threeHotHours and the whole crowdsale\n', '      * Set the duration of crowdsale stages \n', '      * Set the tokens and wei cap of crowdsale stages \n', '      * Set the duration in which the tokens bought in threeHotHours will be locked\n', '      */\n', '\tfunction activateCrowdSale() public onlyOwner {\n', '\t    \t\t\n', '\t\tsetTimeForCrowdsalePeriods();\n', '\t\t\n', '\t\tthreeHotHoursTokensCap = 100000000000000000000000000;\n', '\t\tthreeHotHoursCapInWei = threeHotHoursPriceOfTokenInWei.mul((threeHotHoursTokensCap).div(POW));\n', '\t    \n', '\t\ttimeLock();\n', '\t\t\n', '\t\tisInCrowdsale = true;\n', '\t\t\n', '\t    emit CrowdsaleActivated(startTime, thirdStageEnd);\n', '\t}\n', '\t\n', '\t/** @dev Fallback function.\n', '      * Provides functionality for person to buy tokens.\n', '      */\n', '\tfunction() public payable {\n', '\t\tbuyTokens(msg.sender,msg.value);\n', '\t}\n', '\t\n', '\t/** @dev Buy tokens function\n', '      * Provides functionality for person to buy tokens.\n', '      * @param _participant The investor which want to buy tokens.\n', '      * @param _weiAmount The wei amount which the investor want to contribute.\n', '      * @return success Is the buy tokens function called successfully.\n', '      */\n', '\tfunction buyTokens(address _participant, uint _weiAmount) public payable returns(bool success) {\n', '\t    // Check if the crowdsale is active\n', '\t\trequire(isInCrowdsale == true);\n', '\t\t// Check if the wei amount is between minimum and maximum contribution amount\n', '\t\trequire(_weiAmount >= minimumContribution);\n', '\t\trequire(_weiAmount <= maximumContribution);\n', '\t\t\n', '\t\t// Vaidates the purchase \n', '\t\t// Check if the _participant address is not null and the weiAmount is not zero\n', '\t\tvalidatePurchase(_participant, _weiAmount);\n', '\n', '\t\tuint currentLevelTokens;\n', '\t\tuint nextLevelTokens;\n', '\t\t// Returns the current and next level tokens amount\n', '\t\t(currentLevelTokens, nextLevelTokens) = calculateAndCreateTokens(_weiAmount);\n', '\t\tuint tokensAmount = currentLevelTokens.add(nextLevelTokens);\n', '\t\t\n', '\t\t// If the hard cap is reached the crowdsale is not active anymore\n', '\t\tif(totalSoldTokens.add(tokensAmount) > TOKENS_HARD_CAP) {\n', '\t\t\tisInCrowdsale = false;\n', '\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\t// Transfer Ethers\n', '\t\tbenecifiary.transfer(_weiAmount);\n', '\t\t\n', '\t\t// Stores the participant&#39;s contributed wei\n', '\t\tcontributedInWei[_participant] = contributedInWei[_participant].add(_weiAmount);\n', '\t\t\n', '\t\t// If it is in threeHotHours tokens will not be minted they will be stored in mapping threeHotHoursTokens\n', '\t\tif(threeHotHoursEnd > block.timestamp) {\n', '\t\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].add(currentLevelTokens);\n', '\t\t\tisCalculated[_participant] = false;\n', '\t\t\t// If we overflow threeHotHours tokens cap the tokens for the next level will not be zero\n', '\t\t\t// So we should deactivate the threeHotHours and mint tokens\n', '\t\t\tif(nextLevelTokens > 0) {\n', '\t\t\t\tvernamCrowdsaleToken.mintToken(_participant, nextLevelTokens);\n', '\t\t\t} \n', '\t\t} else {\t\n', '\t\t\tvernamCrowdsaleToken.mintToken(_participant, tokensAmount);        \n', '\t\t}\n', '\t\t\n', '\t\t// Store total sold tokens amount\n', '\t\ttotalSoldTokens = totalSoldTokens.add(tokensAmount);\n', '\t\t\n', '\t\t// Store total contributed wei amount\n', '\t\ttotalContributedWei = totalContributedWei.add(_weiAmount);\n', '\t\t\n', '\t\temit TokensBought(_participant, _weiAmount, tokensAmount);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t/** @dev Function which gets the tokens amount for current and next level.\n', '\t  * If we did not overflow the current level cap, the next level tokens will be zero.\n', '      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\n', '      * It is called by calculateAndCreateTokens function\n', '      */\n', '\tfunction calculateAndCreateTokens(uint weiAmount) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount) {\n', '\n', '\t\tif(block.timestamp < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\n', '\t\t    (_currentLevelTokensAmount, _nextLevelTokensAmount) = tokensCalculator(weiAmount, threeHotHoursPriceOfTokenInWei, firstStagePriceOfTokenInWei, threeHotHoursCapInWei);\n', '\t\t\treturn (_currentLevelTokensAmount, _nextLevelTokensAmount);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < firstStageEnd) {\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(firstStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < secondStageEnd) {\t\t\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(secondStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < thirdStageEnd && weiAmount >= TEN_ETHERS) {\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStageDiscountPriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < thirdStageEnd){\t\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\trevert();\n', '\t}\n', '\t\n', '\t/** @dev Realase the tokens from the three hot hours.\n', '      */\n', '\tfunction release() public {\n', '\t    releaseThreeHotHourTokens(msg.sender);\n', '\t}\n', '\t\n', '\t/** @dev Realase the tokens from the three hot hours.\n', '\t  * It can be called after the end of three hot hours\n', '      * @param _participant The investor who want to release his tokens\n', '      * @return success Is the release tokens function called successfully.\n', '      */\n', '\tfunction releaseThreeHotHourTokens(address _participant) public isAfterThreeHotHours returns(bool success) { \n', '\t    // Check if the _participants tokens are realased\n', '\t    // If not calculate his tokens for every month and set the isCalculated to true\n', '\t\tif(isCalculated[_participant] == false) {\n', '\t\t    calculateTokensForMonth(_participant);\n', '\t\t    isCalculated[_participant] = true;\n', '\t\t}\n', '\t\t\n', '\t\t// Unlock the tokens amount for the _participant\n', '\t\tuint _amount = unlockTokensAmount(_participant);\n', '\t\t\n', '\t\t// Substract the _amount from the threeHotHoursTokens mapping\n', '\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].sub(_amount);\n', '\t\t\n', '\t\t// Mint to the _participant vernamCrowdsaleTokens\n', '\t\tvernamCrowdsaleToken.mintToken(_participant, _amount);        \n', '\n', '\t\temit ReleasedTokens(_amount);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t/** @dev Get contributed amount in wei.\n', '      * @return contributedInWei[_participant].\n', '      */\n', '\tfunction getContributedAmountInWei(address _participant) public view returns (uint) {\n', '        return contributedInWei[_participant];\n', '    }\n', '\t\n', '\t/** @dev Function which calculate tokens for every month (6 months).\n', '      * @param weiAmount Participant&#39;s contribution in wei.\n', '      * @param currentLevelPrice Price of the tokens for the current level.\n', '      * @param nextLevelPrice Price of the tokens for the next level.\n', '      * @param currentLevelCap Current level cap in wei.\n', '      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\n', '      * It is called by three hot hours\n', '      */\n', '      \n', '\tfunction tokensCalculator(uint weiAmount, uint currentLevelPrice, uint nextLevelPrice, uint currentLevelCap) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount){\n', '\t    uint currentAmountInWei = 0;\n', '\t\tuint remainingAmountInWei = 0;\n', '\t\tuint currentLevelTokensAmount = 0;\n', '\t\tuint nextLevelTokensAmount = 0;\n', '\t\t\n', '\t\t// Check if the contribution overflows and you should buy tokens on next level price\n', '\t\tif(weiAmount.add(totalContributedWei) > currentLevelCap) {\n', '\t\t    remainingAmountInWei = (weiAmount.add(totalContributedWei)).sub(currentLevelCap);\n', '\t\t    currentAmountInWei = weiAmount.sub(remainingAmountInWei);\n', '            \n', '            currentLevelTokensAmount = currentAmountInWei.div(currentLevelPrice);\n', '            nextLevelTokensAmount = remainingAmountInWei.div(nextLevelPrice); \n', '\t    } else {\n', '\t        currentLevelTokensAmount = weiAmount.div(currentLevelPrice);\n', '\t\t\tnextLevelTokensAmount = 0;\n', '\t    }\n', '\t    currentLevelTokensAmount = currentLevelTokensAmount.mul(POW);\n', '\t    nextLevelTokensAmount = nextLevelTokensAmount.mul(POW);\n', '\t\t\n', '\t\t\n', '\t\treturn (currentLevelTokensAmount, nextLevelTokensAmount);\n', '\t}\n', '\t\n', '\t/** @dev Function which calculate tokens for every month (6 months).\n', '      * @param _participant The investor whose tokens are calculated.\n', '      * It is called once from the releaseThreeHotHourTokens function\n', '      */\n', '\tfunction calculateTokensForMonth(address _participant) internal {\n', '\t    // Get the max balance of the participant  \n', '\t    uint maxBalance = threeHotHoursTokens[_participant];\n', '\t    \n', '\t    // Start from 10% for the first three months\n', '\t    uint percentage = 10;\n', '\t    for(uint month = 0; month < 6; month++) {\n', '\t        // The fourth month the unlock tokens percentage is increased by 10% and for the fourth and fifth month will be 20%\n', '\t        // It will increase one more by 10% in the last month and will become 30% \n', '\t        if(month == 3 || month == 5) {\n', '\t            percentage += 10;\n', '\t        }\n', '\t        \n', '\t        // Set the participant at which month how much he will get\n', '\t        getTokensBalance[_participant][month] = maxBalance.div(percentage);\n', '\t        \n', '\t        // Set for every month false to see the tokens for the month is not get it \n', '\t        isTokensTaken[_participant][month] = false; \n', '\t    }\n', '\t}\n', '\t\n', '\t\t\n', '\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\n', '      * @param _participant The investor who want to unlock his tokens\n', '      * @return _tokensAmount Tokens which are unlocked\n', '      */\n', '\tfunction unlockTokensAmount(address _participant) internal returns (uint _tokensAmount) {\n', '\t    // Check if the _participant have tokens in threeHotHours stage\n', '\t\trequire(threeHotHoursTokens[_participant] > 0);\n', '\t\t\n', '\t\t// Check if the _participant got his tokens in first month and if the time for the first month end has come \n', '        if(block.timestamp < firstMonthEnd && isTokensTaken[_participant][FIRST_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FIRST_MONTH.add(1)); // First month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between first and second month end\n', '        if(((block.timestamp >= firstMonthEnd) && (block.timestamp < secondMonthEnd)) \n', '            && isTokensTaken[_participant][SECOND_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, SECOND_MONTH.add(1)); // Second month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between second and third month end\n', '        if(((block.timestamp >= secondMonthEnd) && (block.timestamp < thirdMonthEnd)) \n', '            && isTokensTaken[_participant][THIRD_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, THIRD_MONTH.add(1)); // Third month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between third and fourth month end\n', '        if(((block.timestamp >= thirdMonthEnd) && (block.timestamp < fourthMonthEnd)) \n', '            && isTokensTaken[_participant][FORTH_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FORTH_MONTH.add(1)); // Forth month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between forth and fifth month end\n', '        if(((block.timestamp >= fourthMonthEnd) && (block.timestamp < fifthMonthEnd)) \n', '            && isTokensTaken[_participant][FIFTH_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FIFTH_MONTH.add(1)); // Fifth month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is after the end of the fifth month\n', '        if((block.timestamp >= fifthMonthEnd) \n', '            && isTokensTaken[_participant][SIXTH_MONTH] == false) {\n', '            return getTokens(_participant, SIXTH_MONTH.add(1)); // Last month\n', '        }\n', '    }\n', '    \n', '    /** @dev Function for getting the tokens for unlock\n', '      * @param _participant The investor who want to unlock his tokens\n', '      * @param _period The period for which will be unlocked the tokens\n', '      * @return tokensAmount Returns the amount of tokens for unlocing\n', '      */\n', '    function getTokens(address _participant, uint _period) internal returns(uint tokensAmount) {\n', '        uint tokens = 0;\n', '        for(uint month = 0; month < _period; month++) {\n', '            // Check if the tokens fot the current month unlocked\n', '            if(isTokensTaken[_participant][month] == false) { \n', '                // Set the isTokensTaken to true\n', '                isTokensTaken[_participant][month] = true;\n', '                \n', '                // Calculates the tokens\n', '                tokens += getTokensBalance[_participant][month];\n', '                \n', '                // Set the balance for the curren month to zero\n', '                getTokensBalance[_participant][month] = 0;\n', '            }\n', '        }\n', '        \n', '        return tokens;\n', '    }\n', '\t\n', '\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\n', '      * @param _participant The investor who want to buy tokens\n', '      * @param _weiAmount The amount of wei which the investor want to contribute\n', '      */\n', '\tfunction validatePurchase(address _participant, uint _weiAmount) pure internal {\n', '        require(_participant != address(0));\n', '        require(_weiAmount != 0);\n', '    }\n', '\t\n', '\t /** @dev Function which set the duration of crowdsale stages\n', '      * Called by the activateCrowdSale function \n', '      */\n', '\tfunction setTimeForCrowdsalePeriods() internal {\n', '\t\tstartTime = block.timestamp;\n', '\t\tthreeHotHoursEnd = startTime.add(threeHotHoursDuration);\n', '\t\tfirstStageEnd = threeHotHoursEnd.add(firstStageDuration);\n', '\t\tsecondStageEnd = firstStageEnd.add(secondStageDuration);\n', '\t\tthirdStageEnd = secondStageEnd.add(thirdStageDuration);\n', '\t}\n', '\t\n', '\t/** @dev Function which set the duration in which the tokens bought in threeHotHours will be locked\n', '      * Called by the activateCrowdSale function \n', '      */\n', '\tfunction timeLock() internal {\n', '\t\tfirstMonthEnd = (startTime.add(LOCK_TOKENS_DURATION)).add(threeHotHoursDuration);\n', '\t\tsecondMonthEnd = firstMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tthirdMonthEnd = secondMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tfourthMonthEnd = thirdMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tfifthMonthEnd = fourthMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t}\n', '\t\n', '\tfunction getPrice(uint256 time, uint256 weiAmount) public view returns (uint levelPrice) {\n', '\n', '\t\tif(time < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\n', '            return threeHotHoursPriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < firstStageEnd) {\n', '            return firstStagePriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < secondStageEnd) {\n', '            return secondStagePriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < thirdStageEnd && weiAmount > TEN_ETHERS) {\n', '            return thirdStageDiscountPriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < thirdStageEnd){\t\t\n', '\t\t    return thirdStagePriceOfTokenInWei;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction setBenecifiary(address _newBenecifiary) public onlyOwner {\n', '\t\tbenecifiary = _newBenecifiary;\n', '\t}\n', '}\n', 'contract OwnableController {\n', '\taddress public owner;\n', '\taddress public KYCTeam;\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyKYCTeam() {\n', '\t\trequire(msg.sender == KYCTeam);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction setKYCTeam(address _KYCTeam) public onlyOwner {\n', '\t\tKYCTeam = _KYCTeam;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', 'contract Controller is OwnableController {\n', '    \n', '    VernamCrowdSale public vernamCrowdSale;\n', '\tVernamCrowdSaleToken public vernamCrowdsaleToken;\n', '\tVernamToken public vernamToken;\n', '\t\n', '\tmapping(address => bool) public isParticipantApproved;\n', '    \n', '    event Refunded(address _to, uint amountInWei);\n', '\tevent Convert(address indexed participant, uint tokens);\n', '    \n', '    function Controller(address _crowdsaleAddress, address _vernamCrowdSaleToken) public {\n', '        vernamCrowdSale = VernamCrowdSale(_crowdsaleAddress);\n', '\t\tvernamCrowdsaleToken = VernamCrowdSaleToken(_vernamCrowdSaleToken);\n', '    }\n', '    \n', '    function releaseThreeHotHourTokens() public {\n', '        vernamCrowdSale.releaseThreeHotHourTokens(msg.sender);\n', '    }\n', '\t\n', '\tfunction convertYourTokens() public {\n', '\t\tconvertTokens(msg.sender);\n', '\t}\n', '\t\n', '\tfunction convertTokens(address _participant) public {\n', '\t    bool isApproved = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t\tif(isApproved == false && isParticipantApproved[_participant] == true){\n', '\t\t\tvernamCrowdsaleToken.approveKYC(_participant);\n', '\t\t\tisApproved = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t\t}\n', '\t    \n', '\t    require(isApproved == true);\n', '\t    \n', '\t\tuint256 tokens = vernamCrowdsaleToken.balanceOf(_participant);\n', '\t\t\n', '\t\trequire(tokens > 0);\n', '\t\tvernamCrowdsaleToken.burn(_participant, tokens);\n', '\t\tvernamToken.transfer(_participant, tokens);\n', '\t\t\n', '\t\temit Convert(_participant, tokens);\n', '\t}\n', '\t\n', '\tfunction approveKYC(address _participant) public onlyKYCTeam returns(bool _success) {\n', '\t    vernamCrowdsaleToken.approveKYC(_participant);\n', '\t\tisParticipantApproved[_participant] = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t    return isParticipantApproved[_participant];\n', '\t}\n', '\t\n', '\tfunction setVernamOriginalToken(address _vernamToken) public onlyOwner {\n', '\t\tvernamToken = VernamToken(_vernamToken);\n', '\t}\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract VernamToken is ERC20 {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t/* Public variables of the token */\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public _totalSupply;\n', '\t\t\n', '\tmodifier onlyPayloadSize(uint256 numwords) {                                         //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\n', '\t\tassert(msg.data.length == numwords * 32 + 4);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction VernamToken(uint256 _totalSupply_) public {\n', '\t\tname = "Vernam Token";                                   \t// Set the name for display purposes\n', '\t\tsymbol = "VRN";                               \t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t// Amount of decimals for display purposes\n', '\t\t_totalSupply = _totalSupply_;     \t\t\t//1 Billion Tokens with 18 Decimals\n', '\t\tbalances[msg.sender] = _totalSupply_;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\treturn _transfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n', '        require(_value <= allowed[_from][msg.sender]);     \t\t\t\t\t\t\t\t// Check allowance\n', '        \n', '\t\t_transfer(_from, _to, _value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\t\n', '\t\treturn true;\n', '    }\n', '\t\n', '\t/* Internal transfer, only can be called by this contract */\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal returns (bool _success) {\n', '\t\trequire (_to != address(0x0));\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address.\n', '\t\trequire(_value >= 0);\n', '\t\trequire (balances[_from] >= _value);                \t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (balances[_to].add(_value) > balances[_to]); \t\t\t\t\t\t\t\t// Check for overflows\n', '\t\t\n', '\t\tuint256 previousBalances = balances[_from].add(balances[_to]);\t\t\t\t\t// Save this for an assertion in the future\n', '\t\t\n', '\t\tbalances[_from] = balances[_from].sub(_value);        \t\t\t\t   \t\t\t\t// Subtract from the sender\n', '\t\tbalances[_to] = balances[_to].add(_value);                            \t\t\t\t// Add the same to the recipient\n', '\t\t\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\t\n', '\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances); //add safeMath\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction increaseApproval(address _spender, uint256 _addedValue) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\trequire(allowed[msg.sender][_spender].add(_addedValue) <= balances[msg.sender]);\n', '\t\t\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\tuint256 oldValue = allowed[msg.sender][_spender];\n', '\t\t\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '\t\t}\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\t\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '  \n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\t\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256 _remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\taddress public controller;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyController() {\n', '\t\trequire(msg.sender == controller);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\tfunction setControler(address _controller) public onlyOwner {\n', '\t\tcontroller = _controller;\n', '\t}\n', '}\n', '\n', 'contract OwnableToken {\n', '\taddress public owner;\n', '\taddress public minter;\n', '\taddress public burner;\n', '\taddress public controller;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tfunction OwnableToken() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyMinter() {\n', '\t\trequire(msg.sender == minter);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyBurner() {\n', '\t\trequire(msg.sender == burner);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyController() {\n', '\t\trequire(msg.sender == controller);\n', '\t\t_;\n', '\t}\n', '  \n', '\tmodifier onlyPayloadSize(uint256 numwords) {                                       \n', '\t\tassert(msg.data.length == numwords * 32 + 4);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\tfunction setMinter(address _minterAddress) public onlyOwner {\n', '\t\tminter = _minterAddress;\n', '\t}\n', '\t\n', '\tfunction setBurner(address _burnerAddress) public onlyOwner {\n', '\t\tburner = _burnerAddress;\n', '\t}\n', '\t\n', '\tfunction setControler(address _controller) public onlyOwner {\n', '\t\tcontroller = _controller;\n', '\t}\n', '}\n', '\n', 'contract KYCControl is OwnableToken {\n', '\tevent KYCApproved(address _user, bool isApproved);\n', '\tmapping(address => bool) public KYCParticipants;\n', '\t\n', '\tfunction isKYCApproved(address _who) view public returns (bool _isAprroved){\n', '\t\treturn KYCParticipants[_who];\n', '\t}\n', '\n', '\tfunction approveKYC(address _userAddress) onlyController public {\n', '\t\tKYCParticipants[_userAddress] = true;\n', '\t\temit KYCApproved(_userAddress, true);\n', '\t}\n', '}\n', '\n', 'contract VernamCrowdSaleToken is OwnableToken, KYCControl {\n', '\tusing SafeMath for uint256;\n', '\t\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '\t/* Public variables of the token */\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public _totalSupply;\n', '\t\n', '\t/*Private Variables*/\n', '\tuint256 constant POW = 10 ** 18;\n', '\tuint256 _circulatingSupply;\n', '\t\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '\t\t\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\tevent Mint(address indexed _participant, uint256 value);\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction VernamCrowdSaleToken() public {\n', '\t\tname = "Vernam Crowdsale Token";                            // Set the name for display purposes\n', '\t\tsymbol = "VCT";                               \t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t// Amount of decimals for display purposes\n', '\t\t_totalSupply = SafeMath.mul(1000000000, POW);     \t\t\t//1 Billion Tokens with 18 Decimals\n', '\t\t_circulatingSupply = 0;\n', '\t}\n', '\t\n', '\tfunction mintToken(address _participant, uint256 _mintedAmount) public onlyMinter returns (bool _success) {\n', '\t\trequire(_mintedAmount > 0);\n', '\t\trequire(_circulatingSupply.add(_mintedAmount) <= _totalSupply);\n', '\t\tKYCParticipants[_participant] = false;\n', '\n', '        balances[_participant] =  balances[_participant].add(_mintedAmount);\n', '        _circulatingSupply = _circulatingSupply.add(_mintedAmount);\n', '\t\t\n', '\t\temit Transfer(0, this, _mintedAmount);\n', '        emit Transfer(this, _participant, _mintedAmount);\n', '\t\temit Mint(_participant, _mintedAmount);\n', '\t\t\n', '\t\treturn true;\n', '    }\n', '\t\n', '\tfunction burn(address _participant, uint256 _value) public onlyBurner returns (bool _success) {\n', '        require(_value > 0);\n', '\t\trequire(balances[_participant] >= _value);   \t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(isKYCApproved(_participant) == true);\n', '\t\tbalances[_participant] = balances[_participant].sub(_value);            // Subtract from the sender\n', '\t\t_circulatingSupply = _circulatingSupply.sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);                      \t\t\t// Updates totalSupply\n', '\t\temit Transfer(_participant, 0, _value);\n', '        emit Burn(_participant, _value);\n', '        \n', '\t\treturn true;\n', '    }\n', '  \n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\t\n', '\tfunction circulatingSupply() public view returns (uint256) {\n', '\t\treturn _circulatingSupply;\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '}\n', '\n', 'contract VernamCrowdSale is Ownable {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t// After day 7 you can contribute only more than 10 ethers \n', '\tuint constant TEN_ETHERS = 10 ether;\n', '\t// Minimum and maximum contribution amount\n', '\tuint constant minimumContribution = 100 finney;\n', '\tuint constant maximumContribution = 500 ether;\n', '\t\n', '\t// \n', '\tuint constant FIRST_MONTH = 0;\n', '\tuint constant SECOND_MONTH = 1;\n', '\tuint constant THIRD_MONTH = 2;\n', '\tuint constant FORTH_MONTH = 3;\n', '\tuint constant FIFTH_MONTH = 4;\n', '\tuint constant SIXTH_MONTH = 5;\t\n', '\t\n', '\taddress public benecifiary;\n', '\t\n', '    // Check if the crowdsale is active\n', '\tbool public isInCrowdsale;\n', '\t\n', '\t// The start time of the crowdsale\n', '\tuint public startTime;\n', '\t// The total sold tokens\n', '\tuint public totalSoldTokens;\n', '\t\n', '\t// The total contributed wei\n', '\tuint public totalContributedWei;\n', '\n', '    // Public parameters for all the stages\n', '\tuint constant public threeHotHoursDuration = 3 hours;\n', '\tuint constant public threeHotHoursPriceOfTokenInWei = 63751115644524 wei; //0.00006375111564452380 ETH per Token // 15686 VRN per ETH\n', '\t\t\n', '\tuint public threeHotHoursTokensCap; \n', '\tuint public threeHotHoursCapInWei; \n', '\tuint public threeHotHoursEnd;\n', '\n', '\tuint public firstStageDuration = 8 days;\n', '\tuint public firstStagePriceOfTokenInWei = 85005100306018 wei;    //0.00008500510030601840 ETH per Token // 11764 VRN per ETH\n', '\n', '\tuint public firstStageEnd;\n', '\t\n', '\tuint constant public secondStageDuration = 12 days;\n', '\tuint constant public secondStagePriceOfTokenInWei = 90000900009000 wei;     //0.00009000090000900010 ETH per Token // 11111 VRN per ETH\n', '    \n', '\tuint public secondStageEnd;\n', '\t\n', '\tuint constant public thirdStageDuration = 41 days;\n', '\tuint constant public thirdStagePriceOfTokenInWei = 106258633513973 wei;          //0.00010625863351397300 ETH per Token // 9411 VRN per ETH\n', '\t\n', '\tuint constant public thirdStageDiscountPriceOfTokenInWei = 95002850085503 wei;  //0.00009500285008550260 ETH per Token // 10526 VRN per ETH\n', '\t\n', '\tuint public thirdStageEnd;\n', '\t\n', '\tuint constant public TOKENS_HARD_CAP = 500000000000000000000000000; // 500 000 000 with 18 decimals\n', '\t\n', '\t// 18 decimals\n', '\tuint constant POW = 10 ** 18;\n', '\t\n', '\t// Constants for Realase Three Hot Hours\n', '\tuint constant public LOCK_TOKENS_DURATION = 30 days;\n', '\tuint public firstMonthEnd;\n', '\tuint public secondMonthEnd;\n', '\tuint public thirdMonthEnd;\n', '\tuint public fourthMonthEnd;\n', '\tuint public fifthMonthEnd;\n', '    \n', '    // Mappings\n', '\tmapping(address => uint) public contributedInWei;\n', '\tmapping(address => uint) public threeHotHoursTokens;\n', '\tmapping(address => mapping(uint => uint)) public getTokensBalance;\n', '\tmapping(address => mapping(uint => bool)) public isTokensTaken;\n', '\tmapping(address => bool) public isCalculated;\n', '\t\n', '\tVernamCrowdSaleToken public vernamCrowdsaleToken;\n', '\t\n', '\t// Modifiers\n', '    modifier afterCrowdsale() {\n', '        require(block.timestamp > thirdStageEnd);\n', '        _;\n', '    }\n', '    \n', '    modifier isAfterThreeHotHours {\n', '\t    require(block.timestamp > threeHotHoursEnd);\n', '\t    _;\n', '\t}\n', '\t\n', '    // Events\n', '    event CrowdsaleActivated(uint startTime, uint endTime);\n', '    event TokensBought(address participant, uint weiAmount, uint tokensAmount);\n', '    event ReleasedTokens(uint _amount);\n', '    event TokensClaimed(address _participant, uint tokensToGetFromWhiteList);\n', '    \n', '    /** @dev Constructor \n', '      * @param _benecifiary \n', '      * @param _vernamCrowdSaleTokenAddress The address of the crowdsale token.\n', '      * \n', '      */\n', '\tconstructor(address _benecifiary, address _vernamCrowdSaleTokenAddress) public {\n', '\t\tbenecifiary = _benecifiary;\n', '\t\tvernamCrowdsaleToken = VernamCrowdSaleToken(_vernamCrowdSaleTokenAddress);\n', '        \n', '\t\tisInCrowdsale = false;\n', '\t}\n', '\t\n', '\t/** @dev Function which activates the crowdsale \n', '      * Only the owner can call the function\n', '      * Activates the threeHotHours and the whole crowdsale\n', '      * Set the duration of crowdsale stages \n', '      * Set the tokens and wei cap of crowdsale stages \n', '      * Set the duration in which the tokens bought in threeHotHours will be locked\n', '      */\n', '\tfunction activateCrowdSale() public onlyOwner {\n', '\t    \t\t\n', '\t\tsetTimeForCrowdsalePeriods();\n', '\t\t\n', '\t\tthreeHotHoursTokensCap = 100000000000000000000000000;\n', '\t\tthreeHotHoursCapInWei = threeHotHoursPriceOfTokenInWei.mul((threeHotHoursTokensCap).div(POW));\n', '\t    \n', '\t\ttimeLock();\n', '\t\t\n', '\t\tisInCrowdsale = true;\n', '\t\t\n', '\t    emit CrowdsaleActivated(startTime, thirdStageEnd);\n', '\t}\n', '\t\n', '\t/** @dev Fallback function.\n', '      * Provides functionality for person to buy tokens.\n', '      */\n', '\tfunction() public payable {\n', '\t\tbuyTokens(msg.sender,msg.value);\n', '\t}\n', '\t\n', '\t/** @dev Buy tokens function\n', '      * Provides functionality for person to buy tokens.\n', '      * @param _participant The investor which want to buy tokens.\n', '      * @param _weiAmount The wei amount which the investor want to contribute.\n', '      * @return success Is the buy tokens function called successfully.\n', '      */\n', '\tfunction buyTokens(address _participant, uint _weiAmount) public payable returns(bool success) {\n', '\t    // Check if the crowdsale is active\n', '\t\trequire(isInCrowdsale == true);\n', '\t\t// Check if the wei amount is between minimum and maximum contribution amount\n', '\t\trequire(_weiAmount >= minimumContribution);\n', '\t\trequire(_weiAmount <= maximumContribution);\n', '\t\t\n', '\t\t// Vaidates the purchase \n', '\t\t// Check if the _participant address is not null and the weiAmount is not zero\n', '\t\tvalidatePurchase(_participant, _weiAmount);\n', '\n', '\t\tuint currentLevelTokens;\n', '\t\tuint nextLevelTokens;\n', '\t\t// Returns the current and next level tokens amount\n', '\t\t(currentLevelTokens, nextLevelTokens) = calculateAndCreateTokens(_weiAmount);\n', '\t\tuint tokensAmount = currentLevelTokens.add(nextLevelTokens);\n', '\t\t\n', '\t\t// If the hard cap is reached the crowdsale is not active anymore\n', '\t\tif(totalSoldTokens.add(tokensAmount) > TOKENS_HARD_CAP) {\n', '\t\t\tisInCrowdsale = false;\n', '\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\t// Transfer Ethers\n', '\t\tbenecifiary.transfer(_weiAmount);\n', '\t\t\n', "\t\t// Stores the participant's contributed wei\n", '\t\tcontributedInWei[_participant] = contributedInWei[_participant].add(_weiAmount);\n', '\t\t\n', '\t\t// If it is in threeHotHours tokens will not be minted they will be stored in mapping threeHotHoursTokens\n', '\t\tif(threeHotHoursEnd > block.timestamp) {\n', '\t\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].add(currentLevelTokens);\n', '\t\t\tisCalculated[_participant] = false;\n', '\t\t\t// If we overflow threeHotHours tokens cap the tokens for the next level will not be zero\n', '\t\t\t// So we should deactivate the threeHotHours and mint tokens\n', '\t\t\tif(nextLevelTokens > 0) {\n', '\t\t\t\tvernamCrowdsaleToken.mintToken(_participant, nextLevelTokens);\n', '\t\t\t} \n', '\t\t} else {\t\n', '\t\t\tvernamCrowdsaleToken.mintToken(_participant, tokensAmount);        \n', '\t\t}\n', '\t\t\n', '\t\t// Store total sold tokens amount\n', '\t\ttotalSoldTokens = totalSoldTokens.add(tokensAmount);\n', '\t\t\n', '\t\t// Store total contributed wei amount\n', '\t\ttotalContributedWei = totalContributedWei.add(_weiAmount);\n', '\t\t\n', '\t\temit TokensBought(_participant, _weiAmount, tokensAmount);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t/** @dev Function which gets the tokens amount for current and next level.\n', '\t  * If we did not overflow the current level cap, the next level tokens will be zero.\n', '      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\n', '      * It is called by calculateAndCreateTokens function\n', '      */\n', '\tfunction calculateAndCreateTokens(uint weiAmount) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount) {\n', '\n', '\t\tif(block.timestamp < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\n', '\t\t    (_currentLevelTokensAmount, _nextLevelTokensAmount) = tokensCalculator(weiAmount, threeHotHoursPriceOfTokenInWei, firstStagePriceOfTokenInWei, threeHotHoursCapInWei);\n', '\t\t\treturn (_currentLevelTokensAmount, _nextLevelTokensAmount);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < firstStageEnd) {\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(firstStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < secondStageEnd) {\t\t\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(secondStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < thirdStageEnd && weiAmount >= TEN_ETHERS) {\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStageDiscountPriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\tif(block.timestamp < thirdStageEnd){\t\n', '\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStagePriceOfTokenInWei);\n', '\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\n', '\t        \n', '\t\t    return (_currentLevelTokensAmount, 0);\n', '\t\t}\n', '\t\t\n', '\t\trevert();\n', '\t}\n', '\t\n', '\t/** @dev Realase the tokens from the three hot hours.\n', '      */\n', '\tfunction release() public {\n', '\t    releaseThreeHotHourTokens(msg.sender);\n', '\t}\n', '\t\n', '\t/** @dev Realase the tokens from the three hot hours.\n', '\t  * It can be called after the end of three hot hours\n', '      * @param _participant The investor who want to release his tokens\n', '      * @return success Is the release tokens function called successfully.\n', '      */\n', '\tfunction releaseThreeHotHourTokens(address _participant) public isAfterThreeHotHours returns(bool success) { \n', '\t    // Check if the _participants tokens are realased\n', '\t    // If not calculate his tokens for every month and set the isCalculated to true\n', '\t\tif(isCalculated[_participant] == false) {\n', '\t\t    calculateTokensForMonth(_participant);\n', '\t\t    isCalculated[_participant] = true;\n', '\t\t}\n', '\t\t\n', '\t\t// Unlock the tokens amount for the _participant\n', '\t\tuint _amount = unlockTokensAmount(_participant);\n', '\t\t\n', '\t\t// Substract the _amount from the threeHotHoursTokens mapping\n', '\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].sub(_amount);\n', '\t\t\n', '\t\t// Mint to the _participant vernamCrowdsaleTokens\n', '\t\tvernamCrowdsaleToken.mintToken(_participant, _amount);        \n', '\n', '\t\temit ReleasedTokens(_amount);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t/** @dev Get contributed amount in wei.\n', '      * @return contributedInWei[_participant].\n', '      */\n', '\tfunction getContributedAmountInWei(address _participant) public view returns (uint) {\n', '        return contributedInWei[_participant];\n', '    }\n', '\t\n', '\t/** @dev Function which calculate tokens for every month (6 months).\n', "      * @param weiAmount Participant's contribution in wei.\n", '      * @param currentLevelPrice Price of the tokens for the current level.\n', '      * @param nextLevelPrice Price of the tokens for the next level.\n', '      * @param currentLevelCap Current level cap in wei.\n', '      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\n', '      * It is called by three hot hours\n', '      */\n', '      \n', '\tfunction tokensCalculator(uint weiAmount, uint currentLevelPrice, uint nextLevelPrice, uint currentLevelCap) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount){\n', '\t    uint currentAmountInWei = 0;\n', '\t\tuint remainingAmountInWei = 0;\n', '\t\tuint currentLevelTokensAmount = 0;\n', '\t\tuint nextLevelTokensAmount = 0;\n', '\t\t\n', '\t\t// Check if the contribution overflows and you should buy tokens on next level price\n', '\t\tif(weiAmount.add(totalContributedWei) > currentLevelCap) {\n', '\t\t    remainingAmountInWei = (weiAmount.add(totalContributedWei)).sub(currentLevelCap);\n', '\t\t    currentAmountInWei = weiAmount.sub(remainingAmountInWei);\n', '            \n', '            currentLevelTokensAmount = currentAmountInWei.div(currentLevelPrice);\n', '            nextLevelTokensAmount = remainingAmountInWei.div(nextLevelPrice); \n', '\t    } else {\n', '\t        currentLevelTokensAmount = weiAmount.div(currentLevelPrice);\n', '\t\t\tnextLevelTokensAmount = 0;\n', '\t    }\n', '\t    currentLevelTokensAmount = currentLevelTokensAmount.mul(POW);\n', '\t    nextLevelTokensAmount = nextLevelTokensAmount.mul(POW);\n', '\t\t\n', '\t\t\n', '\t\treturn (currentLevelTokensAmount, nextLevelTokensAmount);\n', '\t}\n', '\t\n', '\t/** @dev Function which calculate tokens for every month (6 months).\n', '      * @param _participant The investor whose tokens are calculated.\n', '      * It is called once from the releaseThreeHotHourTokens function\n', '      */\n', '\tfunction calculateTokensForMonth(address _participant) internal {\n', '\t    // Get the max balance of the participant  \n', '\t    uint maxBalance = threeHotHoursTokens[_participant];\n', '\t    \n', '\t    // Start from 10% for the first three months\n', '\t    uint percentage = 10;\n', '\t    for(uint month = 0; month < 6; month++) {\n', '\t        // The fourth month the unlock tokens percentage is increased by 10% and for the fourth and fifth month will be 20%\n', '\t        // It will increase one more by 10% in the last month and will become 30% \n', '\t        if(month == 3 || month == 5) {\n', '\t            percentage += 10;\n', '\t        }\n', '\t        \n', '\t        // Set the participant at which month how much he will get\n', '\t        getTokensBalance[_participant][month] = maxBalance.div(percentage);\n', '\t        \n', '\t        // Set for every month false to see the tokens for the month is not get it \n', '\t        isTokensTaken[_participant][month] = false; \n', '\t    }\n', '\t}\n', '\t\n', '\t\t\n', '\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\n', '      * @param _participant The investor who want to unlock his tokens\n', '      * @return _tokensAmount Tokens which are unlocked\n', '      */\n', '\tfunction unlockTokensAmount(address _participant) internal returns (uint _tokensAmount) {\n', '\t    // Check if the _participant have tokens in threeHotHours stage\n', '\t\trequire(threeHotHoursTokens[_participant] > 0);\n', '\t\t\n', '\t\t// Check if the _participant got his tokens in first month and if the time for the first month end has come \n', '        if(block.timestamp < firstMonthEnd && isTokensTaken[_participant][FIRST_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FIRST_MONTH.add(1)); // First month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between first and second month end\n', '        if(((block.timestamp >= firstMonthEnd) && (block.timestamp < secondMonthEnd)) \n', '            && isTokensTaken[_participant][SECOND_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, SECOND_MONTH.add(1)); // Second month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between second and third month end\n', '        if(((block.timestamp >= secondMonthEnd) && (block.timestamp < thirdMonthEnd)) \n', '            && isTokensTaken[_participant][THIRD_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, THIRD_MONTH.add(1)); // Third month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between third and fourth month end\n', '        if(((block.timestamp >= thirdMonthEnd) && (block.timestamp < fourthMonthEnd)) \n', '            && isTokensTaken[_participant][FORTH_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FORTH_MONTH.add(1)); // Forth month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is in the period between forth and fifth month end\n', '        if(((block.timestamp >= fourthMonthEnd) && (block.timestamp < fifthMonthEnd)) \n', '            && isTokensTaken[_participant][FIFTH_MONTH] == false) {\n', '            // Go and get the tokens for the current month\n', '            return getTokens(_participant, FIFTH_MONTH.add(1)); // Fifth month\n', '        } \n', '        \n', '        // Check if the _participant got his tokens in second month and if the time is after the end of the fifth month\n', '        if((block.timestamp >= fifthMonthEnd) \n', '            && isTokensTaken[_participant][SIXTH_MONTH] == false) {\n', '            return getTokens(_participant, SIXTH_MONTH.add(1)); // Last month\n', '        }\n', '    }\n', '    \n', '    /** @dev Function for getting the tokens for unlock\n', '      * @param _participant The investor who want to unlock his tokens\n', '      * @param _period The period for which will be unlocked the tokens\n', '      * @return tokensAmount Returns the amount of tokens for unlocing\n', '      */\n', '    function getTokens(address _participant, uint _period) internal returns(uint tokensAmount) {\n', '        uint tokens = 0;\n', '        for(uint month = 0; month < _period; month++) {\n', '            // Check if the tokens fot the current month unlocked\n', '            if(isTokensTaken[_participant][month] == false) { \n', '                // Set the isTokensTaken to true\n', '                isTokensTaken[_participant][month] = true;\n', '                \n', '                // Calculates the tokens\n', '                tokens += getTokensBalance[_participant][month];\n', '                \n', '                // Set the balance for the curren month to zero\n', '                getTokensBalance[_participant][month] = 0;\n', '            }\n', '        }\n', '        \n', '        return tokens;\n', '    }\n', '\t\n', '\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\n', '      * @param _participant The investor who want to buy tokens\n', '      * @param _weiAmount The amount of wei which the investor want to contribute\n', '      */\n', '\tfunction validatePurchase(address _participant, uint _weiAmount) pure internal {\n', '        require(_participant != address(0));\n', '        require(_weiAmount != 0);\n', '    }\n', '\t\n', '\t /** @dev Function which set the duration of crowdsale stages\n', '      * Called by the activateCrowdSale function \n', '      */\n', '\tfunction setTimeForCrowdsalePeriods() internal {\n', '\t\tstartTime = block.timestamp;\n', '\t\tthreeHotHoursEnd = startTime.add(threeHotHoursDuration);\n', '\t\tfirstStageEnd = threeHotHoursEnd.add(firstStageDuration);\n', '\t\tsecondStageEnd = firstStageEnd.add(secondStageDuration);\n', '\t\tthirdStageEnd = secondStageEnd.add(thirdStageDuration);\n', '\t}\n', '\t\n', '\t/** @dev Function which set the duration in which the tokens bought in threeHotHours will be locked\n', '      * Called by the activateCrowdSale function \n', '      */\n', '\tfunction timeLock() internal {\n', '\t\tfirstMonthEnd = (startTime.add(LOCK_TOKENS_DURATION)).add(threeHotHoursDuration);\n', '\t\tsecondMonthEnd = firstMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tthirdMonthEnd = secondMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tfourthMonthEnd = thirdMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t\tfifthMonthEnd = fourthMonthEnd.add(LOCK_TOKENS_DURATION);\n', '\t}\n', '\t\n', '\tfunction getPrice(uint256 time, uint256 weiAmount) public view returns (uint levelPrice) {\n', '\n', '\t\tif(time < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\n', '            return threeHotHoursPriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < firstStageEnd) {\n', '            return firstStagePriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < secondStageEnd) {\n', '            return secondStagePriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < thirdStageEnd && weiAmount > TEN_ETHERS) {\n', '            return thirdStageDiscountPriceOfTokenInWei;\n', '\t\t}\n', '\t\t\n', '\t\tif(time < thirdStageEnd){\t\t\n', '\t\t    return thirdStagePriceOfTokenInWei;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction setBenecifiary(address _newBenecifiary) public onlyOwner {\n', '\t\tbenecifiary = _newBenecifiary;\n', '\t}\n', '}\n', 'contract OwnableController {\n', '\taddress public owner;\n', '\taddress public KYCTeam;\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier onlyKYCTeam() {\n', '\t\trequire(msg.sender == KYCTeam);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction setKYCTeam(address _KYCTeam) public onlyOwner {\n', '\t\tKYCTeam = _KYCTeam;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', 'contract Controller is OwnableController {\n', '    \n', '    VernamCrowdSale public vernamCrowdSale;\n', '\tVernamCrowdSaleToken public vernamCrowdsaleToken;\n', '\tVernamToken public vernamToken;\n', '\t\n', '\tmapping(address => bool) public isParticipantApproved;\n', '    \n', '    event Refunded(address _to, uint amountInWei);\n', '\tevent Convert(address indexed participant, uint tokens);\n', '    \n', '    function Controller(address _crowdsaleAddress, address _vernamCrowdSaleToken) public {\n', '        vernamCrowdSale = VernamCrowdSale(_crowdsaleAddress);\n', '\t\tvernamCrowdsaleToken = VernamCrowdSaleToken(_vernamCrowdSaleToken);\n', '    }\n', '    \n', '    function releaseThreeHotHourTokens() public {\n', '        vernamCrowdSale.releaseThreeHotHourTokens(msg.sender);\n', '    }\n', '\t\n', '\tfunction convertYourTokens() public {\n', '\t\tconvertTokens(msg.sender);\n', '\t}\n', '\t\n', '\tfunction convertTokens(address _participant) public {\n', '\t    bool isApproved = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t\tif(isApproved == false && isParticipantApproved[_participant] == true){\n', '\t\t\tvernamCrowdsaleToken.approveKYC(_participant);\n', '\t\t\tisApproved = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t\t}\n', '\t    \n', '\t    require(isApproved == true);\n', '\t    \n', '\t\tuint256 tokens = vernamCrowdsaleToken.balanceOf(_participant);\n', '\t\t\n', '\t\trequire(tokens > 0);\n', '\t\tvernamCrowdsaleToken.burn(_participant, tokens);\n', '\t\tvernamToken.transfer(_participant, tokens);\n', '\t\t\n', '\t\temit Convert(_participant, tokens);\n', '\t}\n', '\t\n', '\tfunction approveKYC(address _participant) public onlyKYCTeam returns(bool _success) {\n', '\t    vernamCrowdsaleToken.approveKYC(_participant);\n', '\t\tisParticipantApproved[_participant] = vernamCrowdsaleToken.isKYCApproved(_participant);\n', '\t    return isParticipantApproved[_participant];\n', '\t}\n', '\t\n', '\tfunction setVernamOriginalToken(address _vernamToken) public onlyOwner {\n', '\t\tvernamToken = VernamToken(_vernamToken);\n', '\t}\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract VernamToken is ERC20 {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t/* Public variables of the token */\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public _totalSupply;\n', '\t\t\n', '\tmodifier onlyPayloadSize(uint256 numwords) {                                         //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\n', '\t\tassert(msg.data.length == numwords * 32 + 4);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction VernamToken(uint256 _totalSupply_) public {\n', '\t\tname = "Vernam Token";                                   \t// Set the name for display purposes\n', '\t\tsymbol = "VRN";                               \t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t// Amount of decimals for display purposes\n', '\t\t_totalSupply = _totalSupply_;     \t\t\t//1 Billion Tokens with 18 Decimals\n', '\t\tbalances[msg.sender] = _totalSupply_;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\treturn _transfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n', '        require(_value <= allowed[_from][msg.sender]);     \t\t\t\t\t\t\t\t// Check allowance\n', '        \n', '\t\t_transfer(_from, _to, _value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\t\n', '\t\treturn true;\n', '    }\n', '\t\n', '\t/* Internal transfer, only can be called by this contract */\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal returns (bool _success) {\n', '\t\trequire (_to != address(0x0));\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address.\n', '\t\trequire(_value >= 0);\n', '\t\trequire (balances[_from] >= _value);                \t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (balances[_to].add(_value) > balances[_to]); \t\t\t\t\t\t\t\t// Check for overflows\n', '\t\t\n', '\t\tuint256 previousBalances = balances[_from].add(balances[_to]);\t\t\t\t\t// Save this for an assertion in the future\n', '\t\t\n', '\t\tbalances[_from] = balances[_from].sub(_value);        \t\t\t\t   \t\t\t\t// Subtract from the sender\n', '\t\tbalances[_to] = balances[_to].add(_value);                            \t\t\t\t// Add the same to the recipient\n', '\t\t\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\t\n', '\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances); //add safeMath\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction increaseApproval(address _spender, uint256 _addedValue) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\trequire(allowed[msg.sender][_spender].add(_addedValue) <= balances[msg.sender]);\n', '\t\t\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\tuint256 oldValue = allowed[msg.sender][_spender];\n', '\t\t\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '\t\t}\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool _success) {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\t\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\t\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '  \n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\t\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256 _remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '}']
