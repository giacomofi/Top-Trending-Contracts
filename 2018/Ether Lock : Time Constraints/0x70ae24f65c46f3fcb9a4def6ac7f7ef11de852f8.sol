['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' *\n', ' * LEPRECHAUN - ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', ' *  - GAIN 4% PER 24 HOURS\n', ' *  - Life-long payments\n', ' *  - Contribution allocation schemes:\n', ' *    -- 95% payments\n', ' *    -- 5% commission/marketing\n', ' *\n', ' * HOW TO USE:\n', ' *  1. Send of ether to make an investment (minimum 0.0001 ETH for the first investment)\n', ' *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don&#39;t care unless you&#39;re spending too much on GAS)\n', ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * PARTNER PROGRAM:\n', ' * At the moment of making the first deposit, the referral indicates in the DATA field the ETH address of the referrer&#39;s wallet,\n', ' * and the referrer then receives 12% of the first attachment of the referral,\n', ' * and the referral also immediately gets back 13% of his deposit\n', ' *\n', ' * NOTES:\n', ' * All ETHs that you&#39;ve sent will be added to your deposit.\n', ' * In order to get an extra profit from your deposit, it is enough to send just 1 wei.\n', ' * It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you\n', ' * have private keys.\n', ' *\n', ' * RECOMMENDED GAS LIMIT: 150000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Addr {\n', '\n', '    function toAddr(uint source) internal pure returns(address) {\n', '        return address(source);\n', '    }\n', '\n', '    function toAddr(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function isZero(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '\n', '    function notZero(address addr) internal pure returns(bool) {\n', '        return !isZero(addr);\n', '    }\n', '\n', '}\n', '\n', 'contract Storage  {\n', '\n', '    using SafeMath for uint;\n', '    address public addrCommission = msg.sender;\n', '\n', '    uint public constant minimalDeposit = 0.0001 ether;\n', '    uint public constant minimalPayout = 0.000001 ether;\n', '    uint public constant profit = 4;\n', '    uint public constant projectCommission = 5;\n', '    uint public constant cashbackInvestor = 13;\n', '    uint public constant cashbackPartner = 12;\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPaid = 0;\n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => uint256) internal timestamps;\n', '\n', '    function getUserInvestBalance(address addr) public view returns(uint) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function getUserPayoutBalance(address addr) public view returns(uint) {\n', '        if (timestamps[addr] > 0) {\n', '            uint time = now.sub(timestamps[addr]);\n', '            return getUserInvestBalance(addr).mul(profit).div(100).mul(time).div(1 days);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract Leprechaun is Storage {\n', '\n', '    using Addr for *;\n', '\n', '    modifier onlyHuman() {\n', '        address addr = msg.sender;\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size == 0, "You&#39;re not a human!");\n', '        _;\n', '    }\n', '\n', '    modifier checkFirstDeposit() {\n', '        require(\n', '            !(getUserInvestBalance(msg.sender) == 0 && msg.value > 0 && msg.value < minimalDeposit),\n', '            "The first deposit is less than the minimum amount"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier fromPartner() {\n', '        if (getUserInvestBalance(msg.sender) == 0 && msg.value > 0) {\n', '            address ref = msg.data.toAddr();\n', '            if (ref.notZero() && ref != msg.sender && balances[ref] > 0) {\n', '                _;\n', '            }\n', '        }\n', '    }\n', '\n', '    constructor() public payable {}\n', '\n', '    function() public payable onlyHuman checkFirstDeposit {\n', '        cashback();\n', '        sendCommission();\n', '        sendPayout();\n', '        updateUserInvestBalance();\n', '    }\n', '\n', '    function cashback() internal fromPartner {\n', '\n', '        uint amountPartner = msg.value.mul(cashbackPartner).div(100);\n', '        transfer(msg.data.toAddr(), amountPartner);\n', '\n', '        uint amountInvestor = msg.value.mul(cashbackInvestor).div(100);\n', '        transfer(msg.sender, amountInvestor);\n', '\n', '        totalPaid = totalPaid.add(amountPartner).add(amountInvestor);\n', '    }\n', '\n', '    function sendCommission() internal {\n', '        if (msg.value > 0) {\n', '            uint commission = msg.value.mul(projectCommission).div(100);\n', '            if (commission > 0) {\n', '                transfer(addrCommission, commission);\n', '            }\n', '        }\n', '    }\n', '\n', '    function sendPayout() internal {\n', '\n', '        if (getUserInvestBalance(msg.sender) > 0) {\n', '\n', '            uint profit = getUserPayoutBalance(msg.sender);\n', '\n', '            if (profit >= minimalPayout) {\n', '                transfer(msg.sender, profit);\n', '                timestamps[msg.sender] = now;\n', '                totalPaid = totalPaid.add(profit);\n', '            }\n', '\n', '        } else if (msg.value > 0) {\n', '            // new user with first deposit\n', '            timestamps[msg.sender] = now;\n', '            countInvestors++;\n', '        }\n', '\n', '    }\n', '\n', '    function updateUserInvestBalance() internal {\n', '        balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '        totalInvest = totalInvest.add(msg.value);\n', '    }\n', '\n', '    function transfer(address addr, uint amount) internal {\n', '\n', '        if (amount <= 0 || addr.isZero()) { return; }\n', '\n', '        require(gasleft() > 3500, "Need more gas for transaction");\n', '\n', '        if (addr.send(amount) == false) {\n', '            // The contract does not have more money and it will be destroyed\n', '            selfdestruct(addrCommission);\n', '        }\n', '\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' *\n', ' * LEPRECHAUN - ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', ' *  - GAIN 4% PER 24 HOURS\n', ' *  - Life-long payments\n', ' *  - Contribution allocation schemes:\n', ' *    -- 95% payments\n', ' *    -- 5% commission/marketing\n', ' *\n', ' * HOW TO USE:\n', ' *  1. Send of ether to make an investment (minimum 0.0001 ETH for the first investment)\n', " *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\n", ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * PARTNER PROGRAM:\n', " * At the moment of making the first deposit, the referral indicates in the DATA field the ETH address of the referrer's wallet,\n", ' * and the referrer then receives 12% of the first attachment of the referral,\n', ' * and the referral also immediately gets back 13% of his deposit\n', ' *\n', ' * NOTES:\n', " * All ETHs that you've sent will be added to your deposit.\n", ' * In order to get an extra profit from your deposit, it is enough to send just 1 wei.\n', ' * It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you\n', ' * have private keys.\n', ' *\n', ' * RECOMMENDED GAS LIMIT: 150000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Addr {\n', '\n', '    function toAddr(uint source) internal pure returns(address) {\n', '        return address(source);\n', '    }\n', '\n', '    function toAddr(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function isZero(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '\n', '    function notZero(address addr) internal pure returns(bool) {\n', '        return !isZero(addr);\n', '    }\n', '\n', '}\n', '\n', 'contract Storage  {\n', '\n', '    using SafeMath for uint;\n', '    address public addrCommission = msg.sender;\n', '\n', '    uint public constant minimalDeposit = 0.0001 ether;\n', '    uint public constant minimalPayout = 0.000001 ether;\n', '    uint public constant profit = 4;\n', '    uint public constant projectCommission = 5;\n', '    uint public constant cashbackInvestor = 13;\n', '    uint public constant cashbackPartner = 12;\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPaid = 0;\n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => uint256) internal timestamps;\n', '\n', '    function getUserInvestBalance(address addr) public view returns(uint) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function getUserPayoutBalance(address addr) public view returns(uint) {\n', '        if (timestamps[addr] > 0) {\n', '            uint time = now.sub(timestamps[addr]);\n', '            return getUserInvestBalance(addr).mul(profit).div(100).mul(time).div(1 days);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract Leprechaun is Storage {\n', '\n', '    using Addr for *;\n', '\n', '    modifier onlyHuman() {\n', '        address addr = msg.sender;\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size == 0, "You\'re not a human!");\n', '        _;\n', '    }\n', '\n', '    modifier checkFirstDeposit() {\n', '        require(\n', '            !(getUserInvestBalance(msg.sender) == 0 && msg.value > 0 && msg.value < minimalDeposit),\n', '            "The first deposit is less than the minimum amount"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier fromPartner() {\n', '        if (getUserInvestBalance(msg.sender) == 0 && msg.value > 0) {\n', '            address ref = msg.data.toAddr();\n', '            if (ref.notZero() && ref != msg.sender && balances[ref] > 0) {\n', '                _;\n', '            }\n', '        }\n', '    }\n', '\n', '    constructor() public payable {}\n', '\n', '    function() public payable onlyHuman checkFirstDeposit {\n', '        cashback();\n', '        sendCommission();\n', '        sendPayout();\n', '        updateUserInvestBalance();\n', '    }\n', '\n', '    function cashback() internal fromPartner {\n', '\n', '        uint amountPartner = msg.value.mul(cashbackPartner).div(100);\n', '        transfer(msg.data.toAddr(), amountPartner);\n', '\n', '        uint amountInvestor = msg.value.mul(cashbackInvestor).div(100);\n', '        transfer(msg.sender, amountInvestor);\n', '\n', '        totalPaid = totalPaid.add(amountPartner).add(amountInvestor);\n', '    }\n', '\n', '    function sendCommission() internal {\n', '        if (msg.value > 0) {\n', '            uint commission = msg.value.mul(projectCommission).div(100);\n', '            if (commission > 0) {\n', '                transfer(addrCommission, commission);\n', '            }\n', '        }\n', '    }\n', '\n', '    function sendPayout() internal {\n', '\n', '        if (getUserInvestBalance(msg.sender) > 0) {\n', '\n', '            uint profit = getUserPayoutBalance(msg.sender);\n', '\n', '            if (profit >= minimalPayout) {\n', '                transfer(msg.sender, profit);\n', '                timestamps[msg.sender] = now;\n', '                totalPaid = totalPaid.add(profit);\n', '            }\n', '\n', '        } else if (msg.value > 0) {\n', '            // new user with first deposit\n', '            timestamps[msg.sender] = now;\n', '            countInvestors++;\n', '        }\n', '\n', '    }\n', '\n', '    function updateUserInvestBalance() internal {\n', '        balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '        totalInvest = totalInvest.add(msg.value);\n', '    }\n', '\n', '    function transfer(address addr, uint amount) internal {\n', '\n', '        if (amount <= 0 || addr.isZero()) { return; }\n', '\n', '        require(gasleft() > 3500, "Need more gas for transaction");\n', '\n', '        if (addr.send(amount) == false) {\n', '            // The contract does not have more money and it will be destroyed\n', '            selfdestruct(addrCommission);\n', '        }\n', '\n', '    }\n', '\n', '}']
