['pragma solidity ^0.4.21;\n', '\n', '/// @title Ownable contract\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/// @title Ownable contract\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev Change ownership\n', '    /// @param newOwner Address of the new owner\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/// @title RateSetter contract\n', 'contract RateSetter {\n', '  \n', '    address public rateSetter;\n', '    event RateSetterChanged(address indexed previousRateSetter, address indexed newRateSetter);\n', '\n', '    function RateSetter() public {\n', '        rateSetter = msg.sender;\n', '    }\n', '\n', '    modifier onlyRateSetter() {\n', '        require(msg.sender == rateSetter);\n', '        _;\n', '    }\n', '\n', '    function changeRateSetter(address newRateSetter) onlyRateSetter public {\n', '        require(newRateSetter != address(0));\n', '        emit RateSetterChanged(rateSetter, newRateSetter);\n', '        rateSetter = newRateSetter;\n', '    }\n', '\n', '}\n', '\n', '/// @title ERC20 contract\n', '/// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/// @title CCWhitelist contract\n', 'contract CCWhitelist {\n', '    function isWhitelisted(address addr) public constant returns (bool);\n', '}\n', '\n', '/// @title Crowdsale contract\n', 'contract Crowdsale is Ownable, RateSetter {\n', '    using SafeMath for uint256;\n', '\n', '    /// Token reference\n', '    ERC20 public token;\n', '    /// Whitelist reference\n', '    CCWhitelist public whitelist;\n', '    /// Presale start time (inclusive)\n', '    uint256 public startTimeIco;\n', '    /// ICO end time (inclusive)\n', '    uint256 public endTimeIco;\n', '    /// Address where the funds will be collected\n', '    address public wallet;\n', '    /// EUR per 1 ETH rate\n', '    uint32 public ethEurRate;\n', '    /// ETH per 1 BTC rate (multiplied by 100)\n', '    uint32 public btcEthRate;\n', '    /// Amount of tokens sold in presale\n', '    uint256 public tokensSoldPre;\n', '    /// Amount of tokens sold in ICO\n', '    uint256 public tokensSoldIco;\n', '    /// Amount of raised ethers expressed in weis\n', '    uint256 public weiRaised;\n', '    /// Amount of raised EUR\n', '    uint256 public eurRaised;\n', '    /// Number of contributions\n', '    uint256 public contributions;\n', '\n', '    /// ICO time phases\n', '    uint256 public icoPhase1Start;\n', '    uint256 public icoPhase1End;\n', '    uint256 public icoPhase2Start;\n', '    uint256 public icoPhase2End;\n', '    uint256 public icoPhase3Start;\n', '    uint256 public icoPhase3End;\n', '    uint256 public icoPhase4Start;\n', '    uint256 public icoPhase4End;\n', '  \n', '\n', '    /// Discount percentages in each phase\n', '    uint8 public icoPhaseDiscountPercentage1;\n', '    uint8 public icoPhaseDiscountPercentage2;\n', '    uint8 public icoPhaseDiscountPercentage3;\n', '    uint8 public icoPhaseDiscountPercentage4;\n', '\n', '    /// Hard cap in EUR\n', '    uint32 public HARD_CAP_EUR = 19170000; // 19 170 000 EUR\n', '    /// Soft cap in EUR\n', '    uint32 public SOFT_CAP_EUR = 2000000; // 2 000 000 EUR\n', '    /// Hard cap in tokens\n', '    uint256 public HARD_CAP_IN_TOKENS = 810 * 10**24; //810m CC tokens\n', '\n', '    /// Mapping for contributors - to limit max contribution and possibly to extract info for refund if soft cap is not reached\n', '    mapping (address => uint) public contributors;\n', '\n', '    function Crowdsale(uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress, uint256 _tokensSoldPre, uint256 _contributions, uint256 _weiRaised, uint256 _eurRaised, uint256 _tokensSoldIco) public {\n', '        require(_endTimeIco >= _startTimeIco);\n', '        require(_ethEurRate > 0 && _btcEthRate > 0);\n', '        require(_wallet != address(0));\n', '        require(_tokenAddress != address(0));\n', '        require(_whitelistAddress != address(0));\n', '        require(_tokensSoldPre > 0);\n', '\n', '        startTimeIco = _startTimeIco;\n', '        endTimeIco = _endTimeIco;\n', '        ethEurRate = _ethEurRate;\n', '        btcEthRate = _btcEthRate;\n', '        wallet = _wallet;\n', '        token = ERC20(_tokenAddress);\n', '        whitelist = CCWhitelist(_whitelistAddress);\n', '        tokensSoldPre = _tokensSoldPre;\n', '        contributions = _contributions;\n', '        weiRaised = _weiRaised;\n', '        eurRaised = _eurRaised;\n', '        tokensSoldIco = _tokensSoldIco;\n', '        // set time phases\n', '        icoPhase1Start = 1520208000;\n', '        icoPhase1End = 1520812799;\n', '        icoPhase2Start = 1520812800;\n', '        icoPhase2End = 1526255999;\n', '        icoPhase3Start = 1526256000;\n', '        icoPhase3End = 1527465599;\n', '        icoPhase4Start = 1527465600;\n', '        icoPhase4End = 1528113600;\n', '        icoPhaseDiscountPercentage1 = 40; // 40% discount\n', '        icoPhaseDiscountPercentage2 = 30; // 30% discount\n', '        icoPhaseDiscountPercentage3 = 20; // 20% discount\n', '        icoPhaseDiscountPercentage4 = 0;  // 0% discount\n', '    }\n', '\n', '\n', '    /// @dev Sets the rates in crowdsale\n', '    /// @param _ethEurRate ETH to EUR rate\n', '    /// @param _btcEthRate BTC to ETH rate \n', '    function setRates(uint32 _ethEurRate, uint32 _btcEthRate) public onlyRateSetter {\n', '        require(_ethEurRate > 0 && _btcEthRate > 0);\n', '        ethEurRate = _ethEurRate;\n', '        btcEthRate = _btcEthRate;\n', '        emit RatesChanged(rateSetter, ethEurRate, btcEthRate);\n', '    }\n', '\n', '\n', '    /// @dev Sets the ICO start and end time\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setICOtime(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        startTimeIco = _start;\n', '        endTimeIco = _end;\n', '        emit ChangeIcoPhase(0, _start, _end);\n', '    }\n', '\n', '\n', '    /// @dev Sets the ICO phase 1 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase1(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase1Start = _start;\n', '        icoPhase1End = _end;\n', '        emit ChangeIcoPhase(1, _start, _end);\n', '    }\n', '\n', '    /// @dev Sets the ICO phase 2 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase2(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase2Start = _start;\n', '        icoPhase2End = _end;\n', '        emit ChangeIcoPhase(2, _start, _end);\n', '    }\n', '\n', '      /// @dev Sets the ICO phase 3 duration\n', '      /// @param _start Start time\n', '      /// @param _end End time  \n', '    function setIcoPhase3(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase3Start = _start;\n', '        icoPhase3End = _end;\n', '        emit ChangeIcoPhase(3, _start, _end);\n', '    }\n', '\n', '    /// @dev Sets the ICO phase 4 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase4(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase4Start = _start;\n', '        icoPhase4End = _end;\n', '        emit ChangeIcoPhase(4, _start, _end);\n', '    }\n', '\n', '    function setIcoDiscountPercentages(uint8 _icoPhaseDiscountPercentage1, uint8 _icoPhaseDiscountPercentage2, uint8 _icoPhaseDiscountPercentage3, uint8 _icoPhaseDiscountPercentage4) external onlyOwner {\n', '        icoPhaseDiscountPercentage1 = _icoPhaseDiscountPercentage1;\n', '        icoPhaseDiscountPercentage2 = _icoPhaseDiscountPercentage2;\n', '        icoPhaseDiscountPercentage3 = _icoPhaseDiscountPercentage3;\n', '        icoPhaseDiscountPercentage4 = _icoPhaseDiscountPercentage4;\n', '        emit DiscountPercentagesChanged(_icoPhaseDiscountPercentage1, _icoPhaseDiscountPercentage2, _icoPhaseDiscountPercentage3, _icoPhaseDiscountPercentage4);\n', '\n', '    }\n', '\n', '    /// @dev Fallback function for crowdsale contribution\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev Buy tokens function\n', '    /// @param beneficiary Address which will receive the tokens\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != address(0));\n', '        require(whitelist.isWhitelisted(beneficiary));\n', '        uint256 weiAmount = msg.value;\n', '        require(weiAmount > 0);\n', '        require(contributors[beneficiary].add(weiAmount) <= 200 ether);\n', '        uint256 tokenAmount = 0;\n', '        if (isIco()) {\n', '            uint8 discountPercentage = getIcoDiscountPercentage();\n', '            tokenAmount = getTokenAmount(weiAmount, discountPercentage);\n', '            /// Minimum contribution 1 token during ICO\n', '            require(tokenAmount >= 10**18); \n', '            uint256 newTokensSoldIco = tokensSoldIco.add(tokenAmount); \n', '            require(newTokensSoldIco <= HARD_CAP_IN_TOKENS);\n', '            tokensSoldIco = newTokensSoldIco;\n', '        } else {\n', '            /// Stop execution and return remaining gas\n', '            require(false);\n', '        }\n', '        executeTransaction(beneficiary, weiAmount, tokenAmount);\n', '    }\n', '\n', '    /// @dev Internal function used for calculating ICO discount percentage depending on phases\n', '    function getIcoDiscountPercentage() internal constant returns (uint8) {\n', '        if (icoPhase1Start >= now && now < icoPhase1End) {\n', '            return icoPhaseDiscountPercentage1;\n', '        }\n', '        else if (icoPhase2Start >= now && now < icoPhase2End) {\n', '            return icoPhaseDiscountPercentage2;\n', '        } else if (icoPhase3Start >= now && now < icoPhase3End) {\n', '            return icoPhaseDiscountPercentage3;\n', '        } else {\n', '            return icoPhaseDiscountPercentage4;\n', '        }\n', '    }\n', '\n', '    /// @dev Internal function used to calculate amount of tokens based on discount percentage\n', '    function getTokenAmount(uint256 weiAmount, uint8 discountPercentage) internal constant returns (uint256) {\n', '        /// Less than 100 to avoid division with zero\n', '        require(discountPercentage >= 0 && discountPercentage < 100); \n', '        uint256 baseTokenAmount = weiAmount.mul(ethEurRate);\n', '        uint256 denominator = 3 * (100 - discountPercentage);\n', '        uint256 tokenAmount = baseTokenAmount.mul(10000).div(denominator);\n', '        return tokenAmount;\n', '    }\n', '\n', '   \n', '    /// point out that it works for the last block\n', '    /// @dev This method is used to get the current amount user can receive for 1ETH -- Used by frontend for easier calculation\n', '    /// @return Amount of CC tokens\n', '    function getCurrentTokenAmountForOneEth() public constant returns (uint256) {\n', '        if (isIco()) {\n', '            uint8 discountPercentage = getIcoDiscountPercentage();\n', '            return getTokenAmount(1 ether, discountPercentage);\n', '        } \n', '        return 0;\n', '    }\n', '  \n', '    /// @dev This method is used to get the current amount user can receive for 1BTC -- Used by frontend for easier calculation\n', '    /// @return Amount of CC tokens\n', '    function getCurrentTokenAmountForOneBtc() public constant returns (uint256) {\n', '        uint256 amountForOneEth = getCurrentTokenAmountForOneEth();\n', '        return amountForOneEth.mul(btcEthRate).div(100);\n', '    }\n', '\n', '    /// @dev Internal function for execution of crowdsale transaction and proper logging used by payable functions\n', '    function executeTransaction(address beneficiary, uint256 weiAmount, uint256 tokenAmount) internal {\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        uint256 eurAmount = weiAmount.mul(ethEurRate).div(10**18);\n', '        eurRaised = eurRaised.add(eurAmount);\n', '        token.transfer(beneficiary, tokenAmount);\n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokenAmount);\n', '        contributions = contributions.add(1);\n', '        contributors[beneficiary] = contributors[beneficiary].add(weiAmount);\n', '        wallet.transfer(weiAmount);\n', '    }\n', '\n', '    /// @dev Check if ICO is active\n', '    function isIco() public constant returns (bool) {\n', '        return now >= startTimeIco && now <= endTimeIco;\n', '    }\n', '\n', '    /// @dev Check if ICO has ended\n', '    function hasIcoEnded() public constant returns (bool) {\n', '        return now > endTimeIco;\n', '    }\n', '\n', '    /// @dev Amount of tokens that have been sold during both presale and ICO phase\n', '    function cummulativeTokensSold() public constant returns (uint256) {\n', '        return tokensSoldPre + tokensSoldIco;\n', '    }\n', '\n', '    /// @dev Function to extract mistakenly sent ERC20 tokens sent to Crowdsale contract and to extract unsold CC tokens\n', '    /// @param _token Address of token we want to extract\n', '    function claimTokens(address _token) public onlyOwner {\n', '        if (_token == address(0)) { \n', '            owner.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 erc20Token = ERC20(_token);\n', '        uint balance = erc20Token.balanceOf(this);\n', '        erc20Token.transfer(owner, balance);\n', '        emit ClaimedTokens(_token, owner, balance);\n', '    }\n', '\n', '    /// Events\n', '    event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);\n', '    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '    event IcoPhaseAmountsChanged(uint256 _icoPhaseAmount1, uint256 _icoPhaseAmount2, uint256 _icoPhaseAmount3, uint256 _icoPhaseAmount4);\n', '    event RatesChanged(address indexed _rateSetter, uint32 _ethEurRate, uint32 _btcEthRate);\n', '    event DiscountPercentagesChanged(uint8 _icoPhaseDiscountPercentage1, uint8 _icoPhaseDiscountPercentage2, uint8 _icoPhaseDiscountPercentage3, uint8 _icoPhaseDiscountPercentage4);\n', '    /// 0 is for changing start and end time of ICO\n', '    event ChangeIcoPhase(uint8 _phase, uint256 _start, uint256 _end);\n', '\n', '}\n', '\n', '/// @title CulturalCoinCrowdsale contract\n', 'contract CulturalCoinCrowdsale is Crowdsale {\n', '\n', '    function CulturalCoinCrowdsale(uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress, uint256 _tokensSoldPre, uint256 _contributions, uint256 _weiRaised, uint256 _eurRaised, uint256 _tokensSoldIco) \n', '    Crowdsale(_startTimeIco, _endTimeIco, _ethEurRate, _btcEthRate, _wallet, _tokenAddress, _whitelistAddress, _tokensSoldPre, _contributions, _weiRaised, _eurRaised, _tokensSoldIco) public {\n', '\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/// @title Ownable contract\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/// @title Ownable contract\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev Change ownership\n', '    /// @param newOwner Address of the new owner\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/// @title RateSetter contract\n', 'contract RateSetter {\n', '  \n', '    address public rateSetter;\n', '    event RateSetterChanged(address indexed previousRateSetter, address indexed newRateSetter);\n', '\n', '    function RateSetter() public {\n', '        rateSetter = msg.sender;\n', '    }\n', '\n', '    modifier onlyRateSetter() {\n', '        require(msg.sender == rateSetter);\n', '        _;\n', '    }\n', '\n', '    function changeRateSetter(address newRateSetter) onlyRateSetter public {\n', '        require(newRateSetter != address(0));\n', '        emit RateSetterChanged(rateSetter, newRateSetter);\n', '        rateSetter = newRateSetter;\n', '    }\n', '\n', '}\n', '\n', '/// @title ERC20 contract\n', '/// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/// @title CCWhitelist contract\n', 'contract CCWhitelist {\n', '    function isWhitelisted(address addr) public constant returns (bool);\n', '}\n', '\n', '/// @title Crowdsale contract\n', 'contract Crowdsale is Ownable, RateSetter {\n', '    using SafeMath for uint256;\n', '\n', '    /// Token reference\n', '    ERC20 public token;\n', '    /// Whitelist reference\n', '    CCWhitelist public whitelist;\n', '    /// Presale start time (inclusive)\n', '    uint256 public startTimeIco;\n', '    /// ICO end time (inclusive)\n', '    uint256 public endTimeIco;\n', '    /// Address where the funds will be collected\n', '    address public wallet;\n', '    /// EUR per 1 ETH rate\n', '    uint32 public ethEurRate;\n', '    /// ETH per 1 BTC rate (multiplied by 100)\n', '    uint32 public btcEthRate;\n', '    /// Amount of tokens sold in presale\n', '    uint256 public tokensSoldPre;\n', '    /// Amount of tokens sold in ICO\n', '    uint256 public tokensSoldIco;\n', '    /// Amount of raised ethers expressed in weis\n', '    uint256 public weiRaised;\n', '    /// Amount of raised EUR\n', '    uint256 public eurRaised;\n', '    /// Number of contributions\n', '    uint256 public contributions;\n', '\n', '    /// ICO time phases\n', '    uint256 public icoPhase1Start;\n', '    uint256 public icoPhase1End;\n', '    uint256 public icoPhase2Start;\n', '    uint256 public icoPhase2End;\n', '    uint256 public icoPhase3Start;\n', '    uint256 public icoPhase3End;\n', '    uint256 public icoPhase4Start;\n', '    uint256 public icoPhase4End;\n', '  \n', '\n', '    /// Discount percentages in each phase\n', '    uint8 public icoPhaseDiscountPercentage1;\n', '    uint8 public icoPhaseDiscountPercentage2;\n', '    uint8 public icoPhaseDiscountPercentage3;\n', '    uint8 public icoPhaseDiscountPercentage4;\n', '\n', '    /// Hard cap in EUR\n', '    uint32 public HARD_CAP_EUR = 19170000; // 19 170 000 EUR\n', '    /// Soft cap in EUR\n', '    uint32 public SOFT_CAP_EUR = 2000000; // 2 000 000 EUR\n', '    /// Hard cap in tokens\n', '    uint256 public HARD_CAP_IN_TOKENS = 810 * 10**24; //810m CC tokens\n', '\n', '    /// Mapping for contributors - to limit max contribution and possibly to extract info for refund if soft cap is not reached\n', '    mapping (address => uint) public contributors;\n', '\n', '    function Crowdsale(uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress, uint256 _tokensSoldPre, uint256 _contributions, uint256 _weiRaised, uint256 _eurRaised, uint256 _tokensSoldIco) public {\n', '        require(_endTimeIco >= _startTimeIco);\n', '        require(_ethEurRate > 0 && _btcEthRate > 0);\n', '        require(_wallet != address(0));\n', '        require(_tokenAddress != address(0));\n', '        require(_whitelistAddress != address(0));\n', '        require(_tokensSoldPre > 0);\n', '\n', '        startTimeIco = _startTimeIco;\n', '        endTimeIco = _endTimeIco;\n', '        ethEurRate = _ethEurRate;\n', '        btcEthRate = _btcEthRate;\n', '        wallet = _wallet;\n', '        token = ERC20(_tokenAddress);\n', '        whitelist = CCWhitelist(_whitelistAddress);\n', '        tokensSoldPre = _tokensSoldPre;\n', '        contributions = _contributions;\n', '        weiRaised = _weiRaised;\n', '        eurRaised = _eurRaised;\n', '        tokensSoldIco = _tokensSoldIco;\n', '        // set time phases\n', '        icoPhase1Start = 1520208000;\n', '        icoPhase1End = 1520812799;\n', '        icoPhase2Start = 1520812800;\n', '        icoPhase2End = 1526255999;\n', '        icoPhase3Start = 1526256000;\n', '        icoPhase3End = 1527465599;\n', '        icoPhase4Start = 1527465600;\n', '        icoPhase4End = 1528113600;\n', '        icoPhaseDiscountPercentage1 = 40; // 40% discount\n', '        icoPhaseDiscountPercentage2 = 30; // 30% discount\n', '        icoPhaseDiscountPercentage3 = 20; // 20% discount\n', '        icoPhaseDiscountPercentage4 = 0;  // 0% discount\n', '    }\n', '\n', '\n', '    /// @dev Sets the rates in crowdsale\n', '    /// @param _ethEurRate ETH to EUR rate\n', '    /// @param _btcEthRate BTC to ETH rate \n', '    function setRates(uint32 _ethEurRate, uint32 _btcEthRate) public onlyRateSetter {\n', '        require(_ethEurRate > 0 && _btcEthRate > 0);\n', '        ethEurRate = _ethEurRate;\n', '        btcEthRate = _btcEthRate;\n', '        emit RatesChanged(rateSetter, ethEurRate, btcEthRate);\n', '    }\n', '\n', '\n', '    /// @dev Sets the ICO start and end time\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setICOtime(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        startTimeIco = _start;\n', '        endTimeIco = _end;\n', '        emit ChangeIcoPhase(0, _start, _end);\n', '    }\n', '\n', '\n', '    /// @dev Sets the ICO phase 1 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase1(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase1Start = _start;\n', '        icoPhase1End = _end;\n', '        emit ChangeIcoPhase(1, _start, _end);\n', '    }\n', '\n', '    /// @dev Sets the ICO phase 2 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase2(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase2Start = _start;\n', '        icoPhase2End = _end;\n', '        emit ChangeIcoPhase(2, _start, _end);\n', '    }\n', '\n', '      /// @dev Sets the ICO phase 3 duration\n', '      /// @param _start Start time\n', '      /// @param _end End time  \n', '    function setIcoPhase3(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase3Start = _start;\n', '        icoPhase3End = _end;\n', '        emit ChangeIcoPhase(3, _start, _end);\n', '    }\n', '\n', '    /// @dev Sets the ICO phase 4 duration\n', '    /// @param _start Start time\n', '    /// @param _end End time \n', '    function setIcoPhase4(uint256 _start, uint256 _end) external onlyOwner {\n', '        require(_start < _end);\n', '        icoPhase4Start = _start;\n', '        icoPhase4End = _end;\n', '        emit ChangeIcoPhase(4, _start, _end);\n', '    }\n', '\n', '    function setIcoDiscountPercentages(uint8 _icoPhaseDiscountPercentage1, uint8 _icoPhaseDiscountPercentage2, uint8 _icoPhaseDiscountPercentage3, uint8 _icoPhaseDiscountPercentage4) external onlyOwner {\n', '        icoPhaseDiscountPercentage1 = _icoPhaseDiscountPercentage1;\n', '        icoPhaseDiscountPercentage2 = _icoPhaseDiscountPercentage2;\n', '        icoPhaseDiscountPercentage3 = _icoPhaseDiscountPercentage3;\n', '        icoPhaseDiscountPercentage4 = _icoPhaseDiscountPercentage4;\n', '        emit DiscountPercentagesChanged(_icoPhaseDiscountPercentage1, _icoPhaseDiscountPercentage2, _icoPhaseDiscountPercentage3, _icoPhaseDiscountPercentage4);\n', '\n', '    }\n', '\n', '    /// @dev Fallback function for crowdsale contribution\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev Buy tokens function\n', '    /// @param beneficiary Address which will receive the tokens\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != address(0));\n', '        require(whitelist.isWhitelisted(beneficiary));\n', '        uint256 weiAmount = msg.value;\n', '        require(weiAmount > 0);\n', '        require(contributors[beneficiary].add(weiAmount) <= 200 ether);\n', '        uint256 tokenAmount = 0;\n', '        if (isIco()) {\n', '            uint8 discountPercentage = getIcoDiscountPercentage();\n', '            tokenAmount = getTokenAmount(weiAmount, discountPercentage);\n', '            /// Minimum contribution 1 token during ICO\n', '            require(tokenAmount >= 10**18); \n', '            uint256 newTokensSoldIco = tokensSoldIco.add(tokenAmount); \n', '            require(newTokensSoldIco <= HARD_CAP_IN_TOKENS);\n', '            tokensSoldIco = newTokensSoldIco;\n', '        } else {\n', '            /// Stop execution and return remaining gas\n', '            require(false);\n', '        }\n', '        executeTransaction(beneficiary, weiAmount, tokenAmount);\n', '    }\n', '\n', '    /// @dev Internal function used for calculating ICO discount percentage depending on phases\n', '    function getIcoDiscountPercentage() internal constant returns (uint8) {\n', '        if (icoPhase1Start >= now && now < icoPhase1End) {\n', '            return icoPhaseDiscountPercentage1;\n', '        }\n', '        else if (icoPhase2Start >= now && now < icoPhase2End) {\n', '            return icoPhaseDiscountPercentage2;\n', '        } else if (icoPhase3Start >= now && now < icoPhase3End) {\n', '            return icoPhaseDiscountPercentage3;\n', '        } else {\n', '            return icoPhaseDiscountPercentage4;\n', '        }\n', '    }\n', '\n', '    /// @dev Internal function used to calculate amount of tokens based on discount percentage\n', '    function getTokenAmount(uint256 weiAmount, uint8 discountPercentage) internal constant returns (uint256) {\n', '        /// Less than 100 to avoid division with zero\n', '        require(discountPercentage >= 0 && discountPercentage < 100); \n', '        uint256 baseTokenAmount = weiAmount.mul(ethEurRate);\n', '        uint256 denominator = 3 * (100 - discountPercentage);\n', '        uint256 tokenAmount = baseTokenAmount.mul(10000).div(denominator);\n', '        return tokenAmount;\n', '    }\n', '\n', '   \n', '    /// point out that it works for the last block\n', '    /// @dev This method is used to get the current amount user can receive for 1ETH -- Used by frontend for easier calculation\n', '    /// @return Amount of CC tokens\n', '    function getCurrentTokenAmountForOneEth() public constant returns (uint256) {\n', '        if (isIco()) {\n', '            uint8 discountPercentage = getIcoDiscountPercentage();\n', '            return getTokenAmount(1 ether, discountPercentage);\n', '        } \n', '        return 0;\n', '    }\n', '  \n', '    /// @dev This method is used to get the current amount user can receive for 1BTC -- Used by frontend for easier calculation\n', '    /// @return Amount of CC tokens\n', '    function getCurrentTokenAmountForOneBtc() public constant returns (uint256) {\n', '        uint256 amountForOneEth = getCurrentTokenAmountForOneEth();\n', '        return amountForOneEth.mul(btcEthRate).div(100);\n', '    }\n', '\n', '    /// @dev Internal function for execution of crowdsale transaction and proper logging used by payable functions\n', '    function executeTransaction(address beneficiary, uint256 weiAmount, uint256 tokenAmount) internal {\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        uint256 eurAmount = weiAmount.mul(ethEurRate).div(10**18);\n', '        eurRaised = eurRaised.add(eurAmount);\n', '        token.transfer(beneficiary, tokenAmount);\n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokenAmount);\n', '        contributions = contributions.add(1);\n', '        contributors[beneficiary] = contributors[beneficiary].add(weiAmount);\n', '        wallet.transfer(weiAmount);\n', '    }\n', '\n', '    /// @dev Check if ICO is active\n', '    function isIco() public constant returns (bool) {\n', '        return now >= startTimeIco && now <= endTimeIco;\n', '    }\n', '\n', '    /// @dev Check if ICO has ended\n', '    function hasIcoEnded() public constant returns (bool) {\n', '        return now > endTimeIco;\n', '    }\n', '\n', '    /// @dev Amount of tokens that have been sold during both presale and ICO phase\n', '    function cummulativeTokensSold() public constant returns (uint256) {\n', '        return tokensSoldPre + tokensSoldIco;\n', '    }\n', '\n', '    /// @dev Function to extract mistakenly sent ERC20 tokens sent to Crowdsale contract and to extract unsold CC tokens\n', '    /// @param _token Address of token we want to extract\n', '    function claimTokens(address _token) public onlyOwner {\n', '        if (_token == address(0)) { \n', '            owner.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 erc20Token = ERC20(_token);\n', '        uint balance = erc20Token.balanceOf(this);\n', '        erc20Token.transfer(owner, balance);\n', '        emit ClaimedTokens(_token, owner, balance);\n', '    }\n', '\n', '    /// Events\n', '    event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);\n', '    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '    event IcoPhaseAmountsChanged(uint256 _icoPhaseAmount1, uint256 _icoPhaseAmount2, uint256 _icoPhaseAmount3, uint256 _icoPhaseAmount4);\n', '    event RatesChanged(address indexed _rateSetter, uint32 _ethEurRate, uint32 _btcEthRate);\n', '    event DiscountPercentagesChanged(uint8 _icoPhaseDiscountPercentage1, uint8 _icoPhaseDiscountPercentage2, uint8 _icoPhaseDiscountPercentage3, uint8 _icoPhaseDiscountPercentage4);\n', '    /// 0 is for changing start and end time of ICO\n', '    event ChangeIcoPhase(uint8 _phase, uint256 _start, uint256 _end);\n', '\n', '}\n', '\n', '/// @title CulturalCoinCrowdsale contract\n', 'contract CulturalCoinCrowdsale is Crowdsale {\n', '\n', '    function CulturalCoinCrowdsale(uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress, uint256 _tokensSoldPre, uint256 _contributions, uint256 _weiRaised, uint256 _eurRaised, uint256 _tokensSoldIco) \n', '    Crowdsale(_startTimeIco, _endTimeIco, _ethEurRate, _btcEthRate, _wallet, _tokenAddress, _whitelistAddress, _tokensSoldPre, _contributions, _weiRaised, _eurRaised, _tokensSoldIco) public {\n', '\n', '    }\n', '\n', '}']
