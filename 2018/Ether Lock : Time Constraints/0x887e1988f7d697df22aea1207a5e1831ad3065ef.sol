['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenID) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenID) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenID) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenID) public;\n', '    function transfer(address _to, uint256 _tokenID) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenID); // solhint-disable-line\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenID);\n', '\n', '    function name() public pure returns (string);\n', '    function symbol() public pure returns (string);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Manageable is Ownable {\n', '\n', '    address public manager;\n', '    bool public contractLock;\n', '\n', '    event ManagerTransferred(address indexed previousManager, address indexed newManager);\n', '    event ContractLockChanged(address admin, bool state);\n', '\n', '    function Manageable() public {\n', '        manager = msg.sender;\n', '        contractLock = false;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require((msg.sender == manager) || (msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '        require(!contractLock);\n', '        _;\n', '    }\n', '\n', '    function transferManager(address newManager) public onlyAdmin {\n', '        require(newManager != address(0));\n', '        ManagerTransferred(manager, newManager);\n', '        manager = newManager;\n', '    }\n', '\n', '    function setContractLock(bool setting) public onlyAdmin {\n', '        contractLock = setting;\n', '        ContractLockChanged(msg.sender, setting);\n', '    }\n', '\n', '    function payout(address _to) public onlyOwner {\n', '        if (_to == address(0)) {\n', '            owner.transfer(this.balance);\n', '        } else {\n', '            _to.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '    function withdrawFunds(address _to, uint256 amount) public onlyOwner {\n', '        require(this.balance >= amount);\n', '        if (_to == address(0)) {\n', '            owner.transfer(amount);\n', '        } else {\n', '            _to.transfer(amount);\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenLayer is ERC721, Manageable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /********************************************** EVENTS **********************************************/\n', '    event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner);\n', '    event TokenDeleted(uint256 tokenId);\n', '\n', '    event TokenSold(\n', '        uint256 tokenId, uint256 oldPrice,\n', '        uint256 newPrice, address prevOwner,\n', '        address winner, bytes32 name,\n', '        uint256 parentId\n', '    );\n', '\n', '    event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice);\n', '    event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId);\n', '    event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName);\n', '    event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta);\n', '\n', '    /******************************************** STORAGE ***********************************************/\n', '    uint256 private constant DEFAULTPARENT = 123456789;\n', '\n', '    mapping (uint256 => Token)   private tokenIndexToToken;\n', '    mapping (address => uint256) private ownershipTokenCount;\n', '\n', '    address public gameAddress;\n', '    address public parentAddr;\n', '\n', '    uint256 private totalTokens;\n', '    uint256 public devFee = 50;\n', '    uint256 public ownerFee = 200;\n', '    uint256[10] private chainFees = [10];\n', '\n', '    struct Token {\n', '        bool exists;\n', '        address approved;\n', '        address owner;\n', '        bytes32 metadata;\n', '        bytes32 name;\n', '        uint256 lastBlock;\n', '        uint256 parentId;\n', '        uint256 price;\n', '    }\n', '\n', '    /******************************************* MODIFIERS **********************************************/\n', '    modifier onlySystem() {\n', '        require((msg.sender == gameAddress) || (msg.sender == manager));\n', '        _;\n', '    }\n', '\n', '    /****************************************** CONSTRUCTOR *********************************************/\n', '    function TokenLayer(address _gameAddress, address _parentAddr) public {\n', '        gameAddress = _gameAddress;\n', '        parentAddr = _parentAddr;\n', '    }\n', '\n', '    /********************************************** PUBLIC **********************************************/\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function name() public pure returns (string) {\n', '        return "CryptoJintori";\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return "JapanToken";\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId, address _from) public onlySystem {\n', '        _approve(_to, _tokenId, _from);\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public isUnlocked {\n', '        _approve(_to, _tokenId, msg.sender);\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    function bundleToken(uint256 _tokenId) public view returns(uint256[8] _tokenData) {\n', '        Token storage token = tokenIndexToToken[_tokenId];\n', '\n', '        uint256[8] memory tokenData;\n', '\n', '        tokenData[0] = uint256(token.name);\n', '        tokenData[1] = token.parentId;\n', '        tokenData[2] = token.price;\n', '        tokenData[3] = uint256(token.owner);\n', '        tokenData[4] = _getNextPrice(_tokenId);\n', '        tokenData[5] = devFee+getChainFees(_tokenId);\n', '        tokenData[6] = uint256(token.approved);\n', '        tokenData[7] = uint256(token.metadata);\n', '        return tokenData;\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId, address _to) public onlySystem {\n', '        _takeOwnership(_tokenId, _to);\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public isUnlocked {\n', '        _takeOwnership(_tokenId, msg.sender);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) public view returns (uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 _totalTokens = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            uint256 tokenId = 0;\n', '            uint256 tokenIndex = 0;\n', '            while (tokenIndex <= _totalTokens) {\n', '                if (exists(tokenId)) {\n', '                    tokenIndex++;\n', '                    if (tokenIndexToToken[tokenId].owner == _owner) {\n', '                        result[resultIndex] = tokenId;\n', '                        resultIndex++;\n', '                    }\n', '                }\n', '                tokenId++;\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function transfer(address _to, address _from, uint256 _tokenId) public onlySystem {\n', '        _checkThenTransfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public isUnlocked {\n', '        _checkThenTransfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public onlySystem {\n', '        _transferFrom(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, uint256 _tokenId) public isUnlocked {\n', '        _transferFrom(_from, msg.sender, _tokenId);\n', '    }\n', '\n', '    function createToken(\n', '        uint256 _tokenId, address _owner,\n', '        bytes32 _name, uint256 _parentId,\n', '        uint256 _price, bytes32 _metadata\n', '    ) public onlyAdmin {\n', '        require(_price > 0);\n', '        require(_addressNotNull(_owner));\n', '        require(_tokenId == uint256(uint32(_tokenId)));\n', '        require(!exists(_tokenId));\n', '\n', '        totalTokens++;\n', '\n', '        Token memory _token = Token({\n', '            name: _name,\n', '            parentId: _parentId,\n', '            exists: true,\n', '            price: _price,\n', '            owner: _owner,\n', '            approved : 0,\n', '            lastBlock : block.number,\n', '            metadata : _metadata\n', '        });\n', '\n', '        tokenIndexToToken[_tokenId] = _token;\n', '\n', '        TokenCreated(_tokenId, _name, _parentId, _owner);\n', '\n', '        _transfer(address(0), _owner, _tokenId);\n', '    }\n', '\n', '    function createTokens(\n', '        uint256[] _tokenIds, address[] _owners,\n', '        bytes32[] _names, uint256[] _parentIds,\n', '        uint256[] _prices, bytes32[] _metadatas\n', '    ) public onlyAdmin {\n', '        for (uint256 id = 0; id < _tokenIds.length; id++) {\n', '            createToken(\n', '                _tokenIds[id], _owners[id], _names[id],\n', '                _parentIds[id], _prices[id], _metadatas[id]\n', '                );\n', '        }\n', '    }\n', '\n', '    function deleteToken(uint256 _tokenId) public onlyAdmin {\n', '        require(_tokenId == uint256(uint32(_tokenId)));\n', '        require(exists(_tokenId));\n', '        totalTokens--;\n', '\n', '        address oldOwner = tokenIndexToToken[_tokenId].owner;\n', '\n', '        ownershipTokenCount[oldOwner] = ownershipTokenCount[oldOwner]--;\n', '        delete tokenIndexToToken[_tokenId];\n', '        TokenDeleted(_tokenId);\n', '    }\n', '\n', '    function incrementPrice(uint256 _tokenId, address _to) public onlySystem {\n', '        require(exists(_tokenId));\n', '        uint256 _price = tokenIndexToToken[_tokenId].price;\n', '        address _owner = tokenIndexToToken[_tokenId].owner;\n', '        uint256 _totalFees = getChainFees(_tokenId);\n', '        tokenIndexToToken[_tokenId].price = _price.mul(1000+ownerFee).div(1000-(devFee+_totalFees));\n', '\n', '        TokenSold(\n', '            _tokenId, _price, tokenIndexToToken[_tokenId].price,\n', '            _owner, _to, tokenIndexToToken[_tokenId].name,\n', '            tokenIndexToToken[_tokenId].parentId\n', '        );\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\n', '        require(exists(_tokenId));\n', '        _owner = tokenIndexToToken[_tokenId].owner;\n', '    }\n', '\n', '    function blocked(uint256 _tokenId) public view returns (bool _blocked) {\n', '        return (tokenIndexToToken[_tokenId].lastBlock == block.number);\n', '    }\n', '\n', '    function exists(uint256 _tokenId) public view returns(bool) {\n', '        return (tokenIndexToToken[_tokenId].exists);\n', '    }\n', '\n', '    /********************************************** SETTERS *********************************************/\n', '    function setLayerParent(address _parent) public onlyAdmin {\n', '        parentAddr = _parent;\n', '    }\n', '\n', '    function setGame(address _gameAddress) public onlyAdmin {\n', '        gameAddress = _gameAddress;\n', '    }\n', '\n', '    function setPrice(uint256 _tokenId, uint256 _price, address _owner) public onlySystem {\n', '        require(_owns(_owner, _tokenId));\n', '        uint256 oldPrice = tokenIndexToToken[_tokenId].price;\n', '        tokenIndexToToken[_tokenId].price = _price;\n', '        PriceChanged(_tokenId, oldPrice, _price);\n', '    }\n', '\n', '    function setParent(uint256 _tokenId, uint256 _parentId) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        uint256 oldParentId = tokenIndexToToken[_tokenId].parentId;\n', '        tokenIndexToToken[_tokenId].parentId = _parentId;\n', '        ParentChanged(_tokenId, oldParentId, _parentId);\n', '    }\n', '\n', '    function setName(uint256 _tokenId, bytes32 _name) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        bytes32 oldName = tokenIndexToToken[_tokenId].name;\n', '        tokenIndexToToken[_tokenId].name = _name;\n', '        NameChanged(_tokenId, oldName, _name);\n', '    }\n', '\n', '    function setMetadata(uint256 _tokenId, bytes32 _metadata) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        bytes32 oldMeta = tokenIndexToToken[_tokenId].metadata;\n', '        tokenIndexToToken[_tokenId].metadata = _metadata;\n', '        MetaDataChanged(_tokenId, oldMeta, _metadata);\n', '    }\n', '\n', '    function setDevFee(uint256 _devFee) public onlyAdmin {\n', '        devFee = _devFee;\n', '    }\n', '\n', '    function setOwnerFee(uint256 _ownerFee) public onlyAdmin {\n', '        ownerFee = _ownerFee;\n', '    }\n', '\n', '    function setChainFees(uint256[10] _chainFees) public onlyAdmin {\n', '        chainFees = _chainFees;\n', '    }\n', '\n', '    /********************************************** GETTERS *********************************************/\n', '    function getToken(uint256 _tokenId) public view returns\n', '    (\n', '        bytes32 tokenName, uint256 parentId, uint256 price,\n', '        address _owner, uint256 nextPrice, uint256 nextPriceFees,\n', '        address approved, bytes32 metadata\n', '    ) {\n', '        Token storage token = tokenIndexToToken[_tokenId];\n', '\n', '        tokenName = token.name;\n', '        parentId = token.parentId;\n', '        price = token.price;\n', '        _owner = token.owner;\n', '        nextPrice = _getNextPrice(_tokenId);\n', '        nextPriceFees = devFee+getChainFees(_tokenId);\n', '        metadata = token.metadata;\n', '        approved = token.approved;\n', '    }\n', '\n', '    function getChainFees(uint256 _tokenId) public view returns (uint256 _total) {\n', '        uint256 chainLength = _getChainLength(_tokenId);\n', '        uint256 totalFee = 0;\n', '        for (uint id = 0; id < chainLength; id++) {\n', '            totalFee = totalFee + chainFees[id];\n', '        }\n', '        return(totalFee);\n', '    }\n', '\n', '    function getChainFeeArray() public view returns (uint256[10] memory _chainFees) {\n', '        return(chainFees);\n', '    }\n', '\n', '    function getPriceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '        require(exists(_tokenId));\n', '        return tokenIndexToToken[_tokenId].price;\n', '    }\n', '\n', '    function getParentOf(uint256 _tokenId) public view returns (uint256 parentId) {\n', '        require(exists(_tokenId));\n', '        return tokenIndexToToken[_tokenId].parentId;\n', '    }\n', '\n', '    function getMetadataOf(uint256 _tokenId) public view returns (bytes32 metadata) {\n', '        require(exists(_tokenId));\n', '        return (tokenIndexToToken[_tokenId].metadata);\n', '    }\n', '\n', '    function getChain(uint256 _tokenId) public view returns (address[10] memory _owners) {\n', '        require(exists(_tokenId));\n', '\n', '        uint256 _parentId = getParentOf(_tokenId);\n', '        address _parentAddr = parentAddr;\n', '\n', '        address[10] memory result;\n', '\n', '        if (_parentId != DEFAULTPARENT && _addressNotNull(_parentAddr)) {\n', '            uint256 resultIndex = 0;\n', '\n', '            TokenLayer layer = TokenLayer(_parentAddr);\n', '            bool parentExists = layer.exists(_parentId);\n', '\n', '            while ((_parentId != DEFAULTPARENT) && _addressNotNull(_parentAddr) && parentExists) {\n', '                parentExists = layer.exists(_parentId);\n', '                if (!parentExists) {\n', '                    return(result);\n', '                }\n', '                result[resultIndex] = layer.ownerOf(_parentId);\n', '                resultIndex++;\n', '\n', '                _parentId = layer.getParentOf(_parentId);\n', '                _parentAddr = layer.parentAddr();\n', '\n', '                layer = TokenLayer(_parentAddr);\n', '            }\n', '\n', '            return(result);\n', '        }\n', '    }\n', '\n', '    /******************************************** PRIVATE ***********************************************/\n', '    function _addressNotNull(address _to) private pure returns (bool) {\n', '        return _to != address(0);\n', '    }\n', '\n', '    function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '        return (tokenIndexToToken[_tokenId].approved == _to);\n', '    }\n', '\n', '    function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '        return claimant == tokenIndexToToken[_tokenId].owner;\n', '    }\n', '\n', '    function _checkThenTransfer(address _from, address _to, uint256 _tokenId) private {\n', '        require(_owns(_from, _tokenId));\n', '        require(_addressNotNull(_to));\n', '        require(exists(_tokenId));\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        ownershipTokenCount[_to]++;\n', '        tokenIndexToToken[_tokenId].owner = _to;\n', '        tokenIndexToToken[_tokenId].lastBlock = block.number;\n', '\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            tokenIndexToToken[_tokenId].approved = 0;\n', '        }\n', '\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _approve(address _to, uint256 _tokenId, address _from) private {\n', '        require(_owns(_from, _tokenId));\n', '\n', '        tokenIndexToToken[_tokenId].approved = _to;\n', '\n', '        Approval(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _takeOwnership(uint256 _tokenId, address _to) private {\n', '        address newOwner = _to;\n', '        address oldOwner = tokenIndexToToken[_tokenId].owner;\n', '\n', '        require(_addressNotNull(newOwner));\n', '        require(_approved(newOwner, _tokenId));\n', '\n', '        _transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function _transferFrom(address _from, address _to, uint256 _tokenId) private {\n', '        require(_owns(_from, _tokenId));\n', '        require(_approved(_to, _tokenId));\n', '        require(_addressNotNull(_to));\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _getChainLength(uint256 _tokenId) private view returns (uint256 _length) {\n', '        uint256 length;\n', '\n', '        uint256 _parentId = getParentOf(_tokenId);\n', '        address _parentAddr = parentAddr;\n', '        if (_parentId == DEFAULTPARENT || !_addressNotNull(_parentAddr)) {\n', '            return 0;\n', '        }\n', '\n', '        TokenLayer layer = TokenLayer(_parentAddr);\n', '        bool parentExists = layer.exists(_parentId);\n', '\n', '        while ((_parentId != DEFAULTPARENT) && _addressNotNull(_parentAddr) && parentExists) {\n', '            parentExists = layer.exists(_parentId);\n', '            if(!parentExists) {\n', '                    return(length);\n', '            }\n', '            _parentId = layer.getParentOf(_parentId);\n', '            _parentAddr = layer.parentAddr();\n', '            layer = TokenLayer(_parentAddr);\n', '            length++;\n', '        }\n', '\n', '        return(length);\n', '    }\n', '\n', '    function _getNextPrice(uint256 _tokenId) private view returns (uint256 _nextPrice) {\n', '        uint256 _price = tokenIndexToToken[_tokenId].price;\n', '        uint256 _totalFees = getChainFees(_tokenId);\n', '        _price = _price.mul(1000+ownerFee).div(1000-(devFee+_totalFees));\n', '        return(_price);\n', '    }\n', '}']
['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenID) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenID) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenID) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenID) public;\n', '    function transfer(address _to, uint256 _tokenID) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenID); // solhint-disable-line\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenID);\n', '\n', '    function name() public pure returns (string);\n', '    function symbol() public pure returns (string);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Manageable is Ownable {\n', '\n', '    address public manager;\n', '    bool public contractLock;\n', '\n', '    event ManagerTransferred(address indexed previousManager, address indexed newManager);\n', '    event ContractLockChanged(address admin, bool state);\n', '\n', '    function Manageable() public {\n', '        manager = msg.sender;\n', '        contractLock = false;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require((msg.sender == manager) || (msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '        require(!contractLock);\n', '        _;\n', '    }\n', '\n', '    function transferManager(address newManager) public onlyAdmin {\n', '        require(newManager != address(0));\n', '        ManagerTransferred(manager, newManager);\n', '        manager = newManager;\n', '    }\n', '\n', '    function setContractLock(bool setting) public onlyAdmin {\n', '        contractLock = setting;\n', '        ContractLockChanged(msg.sender, setting);\n', '    }\n', '\n', '    function payout(address _to) public onlyOwner {\n', '        if (_to == address(0)) {\n', '            owner.transfer(this.balance);\n', '        } else {\n', '            _to.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '    function withdrawFunds(address _to, uint256 amount) public onlyOwner {\n', '        require(this.balance >= amount);\n', '        if (_to == address(0)) {\n', '            owner.transfer(amount);\n', '        } else {\n', '            _to.transfer(amount);\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenLayer is ERC721, Manageable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /********************************************** EVENTS **********************************************/\n', '    event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner);\n', '    event TokenDeleted(uint256 tokenId);\n', '\n', '    event TokenSold(\n', '        uint256 tokenId, uint256 oldPrice,\n', '        uint256 newPrice, address prevOwner,\n', '        address winner, bytes32 name,\n', '        uint256 parentId\n', '    );\n', '\n', '    event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice);\n', '    event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId);\n', '    event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName);\n', '    event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta);\n', '\n', '    /******************************************** STORAGE ***********************************************/\n', '    uint256 private constant DEFAULTPARENT = 123456789;\n', '\n', '    mapping (uint256 => Token)   private tokenIndexToToken;\n', '    mapping (address => uint256) private ownershipTokenCount;\n', '\n', '    address public gameAddress;\n', '    address public parentAddr;\n', '\n', '    uint256 private totalTokens;\n', '    uint256 public devFee = 50;\n', '    uint256 public ownerFee = 200;\n', '    uint256[10] private chainFees = [10];\n', '\n', '    struct Token {\n', '        bool exists;\n', '        address approved;\n', '        address owner;\n', '        bytes32 metadata;\n', '        bytes32 name;\n', '        uint256 lastBlock;\n', '        uint256 parentId;\n', '        uint256 price;\n', '    }\n', '\n', '    /******************************************* MODIFIERS **********************************************/\n', '    modifier onlySystem() {\n', '        require((msg.sender == gameAddress) || (msg.sender == manager));\n', '        _;\n', '    }\n', '\n', '    /****************************************** CONSTRUCTOR *********************************************/\n', '    function TokenLayer(address _gameAddress, address _parentAddr) public {\n', '        gameAddress = _gameAddress;\n', '        parentAddr = _parentAddr;\n', '    }\n', '\n', '    /********************************************** PUBLIC **********************************************/\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function name() public pure returns (string) {\n', '        return "CryptoJintori";\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return "JapanToken";\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId, address _from) public onlySystem {\n', '        _approve(_to, _tokenId, _from);\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public isUnlocked {\n', '        _approve(_to, _tokenId, msg.sender);\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    function bundleToken(uint256 _tokenId) public view returns(uint256[8] _tokenData) {\n', '        Token storage token = tokenIndexToToken[_tokenId];\n', '\n', '        uint256[8] memory tokenData;\n', '\n', '        tokenData[0] = uint256(token.name);\n', '        tokenData[1] = token.parentId;\n', '        tokenData[2] = token.price;\n', '        tokenData[3] = uint256(token.owner);\n', '        tokenData[4] = _getNextPrice(_tokenId);\n', '        tokenData[5] = devFee+getChainFees(_tokenId);\n', '        tokenData[6] = uint256(token.approved);\n', '        tokenData[7] = uint256(token.metadata);\n', '        return tokenData;\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId, address _to) public onlySystem {\n', '        _takeOwnership(_tokenId, _to);\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public isUnlocked {\n', '        _takeOwnership(_tokenId, msg.sender);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) public view returns (uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 _totalTokens = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            uint256 tokenId = 0;\n', '            uint256 tokenIndex = 0;\n', '            while (tokenIndex <= _totalTokens) {\n', '                if (exists(tokenId)) {\n', '                    tokenIndex++;\n', '                    if (tokenIndexToToken[tokenId].owner == _owner) {\n', '                        result[resultIndex] = tokenId;\n', '                        resultIndex++;\n', '                    }\n', '                }\n', '                tokenId++;\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function transfer(address _to, address _from, uint256 _tokenId) public onlySystem {\n', '        _checkThenTransfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public isUnlocked {\n', '        _checkThenTransfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public onlySystem {\n', '        _transferFrom(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, uint256 _tokenId) public isUnlocked {\n', '        _transferFrom(_from, msg.sender, _tokenId);\n', '    }\n', '\n', '    function createToken(\n', '        uint256 _tokenId, address _owner,\n', '        bytes32 _name, uint256 _parentId,\n', '        uint256 _price, bytes32 _metadata\n', '    ) public onlyAdmin {\n', '        require(_price > 0);\n', '        require(_addressNotNull(_owner));\n', '        require(_tokenId == uint256(uint32(_tokenId)));\n', '        require(!exists(_tokenId));\n', '\n', '        totalTokens++;\n', '\n', '        Token memory _token = Token({\n', '            name: _name,\n', '            parentId: _parentId,\n', '            exists: true,\n', '            price: _price,\n', '            owner: _owner,\n', '            approved : 0,\n', '            lastBlock : block.number,\n', '            metadata : _metadata\n', '        });\n', '\n', '        tokenIndexToToken[_tokenId] = _token;\n', '\n', '        TokenCreated(_tokenId, _name, _parentId, _owner);\n', '\n', '        _transfer(address(0), _owner, _tokenId);\n', '    }\n', '\n', '    function createTokens(\n', '        uint256[] _tokenIds, address[] _owners,\n', '        bytes32[] _names, uint256[] _parentIds,\n', '        uint256[] _prices, bytes32[] _metadatas\n', '    ) public onlyAdmin {\n', '        for (uint256 id = 0; id < _tokenIds.length; id++) {\n', '            createToken(\n', '                _tokenIds[id], _owners[id], _names[id],\n', '                _parentIds[id], _prices[id], _metadatas[id]\n', '                );\n', '        }\n', '    }\n', '\n', '    function deleteToken(uint256 _tokenId) public onlyAdmin {\n', '        require(_tokenId == uint256(uint32(_tokenId)));\n', '        require(exists(_tokenId));\n', '        totalTokens--;\n', '\n', '        address oldOwner = tokenIndexToToken[_tokenId].owner;\n', '\n', '        ownershipTokenCount[oldOwner] = ownershipTokenCount[oldOwner]--;\n', '        delete tokenIndexToToken[_tokenId];\n', '        TokenDeleted(_tokenId);\n', '    }\n', '\n', '    function incrementPrice(uint256 _tokenId, address _to) public onlySystem {\n', '        require(exists(_tokenId));\n', '        uint256 _price = tokenIndexToToken[_tokenId].price;\n', '        address _owner = tokenIndexToToken[_tokenId].owner;\n', '        uint256 _totalFees = getChainFees(_tokenId);\n', '        tokenIndexToToken[_tokenId].price = _price.mul(1000+ownerFee).div(1000-(devFee+_totalFees));\n', '\n', '        TokenSold(\n', '            _tokenId, _price, tokenIndexToToken[_tokenId].price,\n', '            _owner, _to, tokenIndexToToken[_tokenId].name,\n', '            tokenIndexToToken[_tokenId].parentId\n', '        );\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\n', '        require(exists(_tokenId));\n', '        _owner = tokenIndexToToken[_tokenId].owner;\n', '    }\n', '\n', '    function blocked(uint256 _tokenId) public view returns (bool _blocked) {\n', '        return (tokenIndexToToken[_tokenId].lastBlock == block.number);\n', '    }\n', '\n', '    function exists(uint256 _tokenId) public view returns(bool) {\n', '        return (tokenIndexToToken[_tokenId].exists);\n', '    }\n', '\n', '    /********************************************** SETTERS *********************************************/\n', '    function setLayerParent(address _parent) public onlyAdmin {\n', '        parentAddr = _parent;\n', '    }\n', '\n', '    function setGame(address _gameAddress) public onlyAdmin {\n', '        gameAddress = _gameAddress;\n', '    }\n', '\n', '    function setPrice(uint256 _tokenId, uint256 _price, address _owner) public onlySystem {\n', '        require(_owns(_owner, _tokenId));\n', '        uint256 oldPrice = tokenIndexToToken[_tokenId].price;\n', '        tokenIndexToToken[_tokenId].price = _price;\n', '        PriceChanged(_tokenId, oldPrice, _price);\n', '    }\n', '\n', '    function setParent(uint256 _tokenId, uint256 _parentId) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        uint256 oldParentId = tokenIndexToToken[_tokenId].parentId;\n', '        tokenIndexToToken[_tokenId].parentId = _parentId;\n', '        ParentChanged(_tokenId, oldParentId, _parentId);\n', '    }\n', '\n', '    function setName(uint256 _tokenId, bytes32 _name) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        bytes32 oldName = tokenIndexToToken[_tokenId].name;\n', '        tokenIndexToToken[_tokenId].name = _name;\n', '        NameChanged(_tokenId, oldName, _name);\n', '    }\n', '\n', '    function setMetadata(uint256 _tokenId, bytes32 _metadata) public onlyAdmin {\n', '        require(exists(_tokenId));\n', '        bytes32 oldMeta = tokenIndexToToken[_tokenId].metadata;\n', '        tokenIndexToToken[_tokenId].metadata = _metadata;\n', '        MetaDataChanged(_tokenId, oldMeta, _metadata);\n', '    }\n', '\n', '    function setDevFee(uint256 _devFee) public onlyAdmin {\n', '        devFee = _devFee;\n', '    }\n', '\n', '    function setOwnerFee(uint256 _ownerFee) public onlyAdmin {\n', '        ownerFee = _ownerFee;\n', '    }\n', '\n', '    function setChainFees(uint256[10] _chainFees) public onlyAdmin {\n', '        chainFees = _chainFees;\n', '    }\n', '\n', '    /********************************************** GETTERS *********************************************/\n', '    function getToken(uint256 _tokenId) public view returns\n', '    (\n', '        bytes32 tokenName, uint256 parentId, uint256 price,\n', '        address _owner, uint256 nextPrice, uint256 nextPriceFees,\n', '        address approved, bytes32 metadata\n', '    ) {\n', '        Token storage token = tokenIndexToToken[_tokenId];\n', '\n', '        tokenName = token.name;\n', '        parentId = token.parentId;\n', '        price = token.price;\n', '        _owner = token.owner;\n', '        nextPrice = _getNextPrice(_tokenId);\n', '        nextPriceFees = devFee+getChainFees(_tokenId);\n', '        metadata = token.metadata;\n', '        approved = token.approved;\n', '    }\n', '\n', '    function getChainFees(uint256 _tokenId) public view returns (uint256 _total) {\n', '        uint256 chainLength = _getChainLength(_tokenId);\n', '        uint256 totalFee = 0;\n', '        for (uint id = 0; id < chainLength; id++) {\n', '            totalFee = totalFee + chainFees[id];\n', '        }\n', '        return(totalFee);\n', '    }\n', '\n', '    function getChainFeeArray() public view returns (uint256[10] memory _chainFees) {\n', '        return(chainFees);\n', '    }\n', '\n', '    function getPriceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '        require(exists(_tokenId));\n', '        return tokenIndexToToken[_tokenId].price;\n', '    }\n', '\n', '    function getParentOf(uint256 _tokenId) public view returns (uint256 parentId) {\n', '        require(exists(_tokenId));\n', '        return tokenIndexToToken[_tokenId].parentId;\n', '    }\n', '\n', '    function getMetadataOf(uint256 _tokenId) public view returns (bytes32 metadata) {\n', '        require(exists(_tokenId));\n', '        return (tokenIndexToToken[_tokenId].metadata);\n', '    }\n', '\n', '    function getChain(uint256 _tokenId) public view returns (address[10] memory _owners) {\n', '        require(exists(_tokenId));\n', '\n', '        uint256 _parentId = getParentOf(_tokenId);\n', '        address _parentAddr = parentAddr;\n', '\n', '        address[10] memory result;\n', '\n', '        if (_parentId != DEFAULTPARENT && _addressNotNull(_parentAddr)) {\n', '            uint256 resultIndex = 0;\n', '\n', '            TokenLayer layer = TokenLayer(_parentAddr);\n', '            bool parentExists = layer.exists(_parentId);\n', '\n', '            while ((_parentId != DEFAULTPARENT) && _addressNotNull(_parentAddr) && parentExists) {\n', '                parentExists = layer.exists(_parentId);\n', '                if (!parentExists) {\n', '                    return(result);\n', '                }\n', '                result[resultIndex] = layer.ownerOf(_parentId);\n', '                resultIndex++;\n', '\n', '                _parentId = layer.getParentOf(_parentId);\n', '                _parentAddr = layer.parentAddr();\n', '\n', '                layer = TokenLayer(_parentAddr);\n', '            }\n', '\n', '            return(result);\n', '        }\n', '    }\n', '\n', '    /******************************************** PRIVATE ***********************************************/\n', '    function _addressNotNull(address _to) private pure returns (bool) {\n', '        return _to != address(0);\n', '    }\n', '\n', '    function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '        return (tokenIndexToToken[_tokenId].approved == _to);\n', '    }\n', '\n', '    function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '        return claimant == tokenIndexToToken[_tokenId].owner;\n', '    }\n', '\n', '    function _checkThenTransfer(address _from, address _to, uint256 _tokenId) private {\n', '        require(_owns(_from, _tokenId));\n', '        require(_addressNotNull(_to));\n', '        require(exists(_tokenId));\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        ownershipTokenCount[_to]++;\n', '        tokenIndexToToken[_tokenId].owner = _to;\n', '        tokenIndexToToken[_tokenId].lastBlock = block.number;\n', '\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            tokenIndexToToken[_tokenId].approved = 0;\n', '        }\n', '\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _approve(address _to, uint256 _tokenId, address _from) private {\n', '        require(_owns(_from, _tokenId));\n', '\n', '        tokenIndexToToken[_tokenId].approved = _to;\n', '\n', '        Approval(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _takeOwnership(uint256 _tokenId, address _to) private {\n', '        address newOwner = _to;\n', '        address oldOwner = tokenIndexToToken[_tokenId].owner;\n', '\n', '        require(_addressNotNull(newOwner));\n', '        require(_approved(newOwner, _tokenId));\n', '\n', '        _transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function _transferFrom(address _from, address _to, uint256 _tokenId) private {\n', '        require(_owns(_from, _tokenId));\n', '        require(_approved(_to, _tokenId));\n', '        require(_addressNotNull(_to));\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _getChainLength(uint256 _tokenId) private view returns (uint256 _length) {\n', '        uint256 length;\n', '\n', '        uint256 _parentId = getParentOf(_tokenId);\n', '        address _parentAddr = parentAddr;\n', '        if (_parentId == DEFAULTPARENT || !_addressNotNull(_parentAddr)) {\n', '            return 0;\n', '        }\n', '\n', '        TokenLayer layer = TokenLayer(_parentAddr);\n', '        bool parentExists = layer.exists(_parentId);\n', '\n', '        while ((_parentId != DEFAULTPARENT) && _addressNotNull(_parentAddr) && parentExists) {\n', '            parentExists = layer.exists(_parentId);\n', '            if(!parentExists) {\n', '                    return(length);\n', '            }\n', '            _parentId = layer.getParentOf(_parentId);\n', '            _parentAddr = layer.parentAddr();\n', '            layer = TokenLayer(_parentAddr);\n', '            length++;\n', '        }\n', '\n', '        return(length);\n', '    }\n', '\n', '    function _getNextPrice(uint256 _tokenId) private view returns (uint256 _nextPrice) {\n', '        uint256 _price = tokenIndexToToken[_tokenId].price;\n', '        uint256 _totalFees = getChainFees(_tokenId);\n', '        _price = _price.mul(1000+ownerFee).div(1000-(devFee+_totalFees));\n', '        return(_price);\n', '    }\n', '}']
