['pragma solidity ^0.4.24;\n', '\n', 'interface ERC20 {\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n', '    function approve(address _spender, uint _value) external returns (bool);\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'interface ERC223 {\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'contract Token {\n', '\n', '    string internal _symbol;\n', '    string internal _name;\n', '\n', '    uint8 internal _decimals;\n', '    uint internal _totalSupply;\n', '\n', '    mapping (address => uint) internal _balanceOf;\n', '    mapping (address => mapping (address => uint)) internal _allowances;\n', '\n', '    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {\n', '        _symbol = symbol;\n', '        _name = name;\n', '        _decimals = decimals;\n', '        _totalSupply = totalSupply;\n', '    }\n', '\n', '    function name()\n', '        public\n', '        view\n', '        returns (string) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol()\n', '        public\n', '        view\n', '        returns (string) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals()\n', '        public\n', '        view\n', '        returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _addr) public view returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '}\n', '\n', 'library SafeMath {\n', '    function sub(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint) {\n', '        assert(_value <= _base);\n', '        return _base - _value;\n', '    }\n', '\n', '    function add(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint _ret) {\n', '        _ret = _base + _value;\n', '        assert(_ret >= _base);\n', '    }\n', '\n', '    function div(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint) {\n', '        assert(_value > 0 && (_base % _value) == 0);\n', '        return _base / _value;\n', '    }\n', '\n', '    function mul(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint _ret) {\n', '        _ret = _base * _value;\n', '        assert(0 == _base || _ret / _base == _value);\n', '    }\n', '}\n', '\n', 'library Addresses {\n', '    function isContract(address _base) internal view returns (bool) {\n', '        uint codeSize;\n', '            assembly {\n', '            codeSize := extcodesize(_base)\n', '            }\n', '        return codeSize > 0;\n', '    }\n', '}\n', '\n', 'contract MyToken is Token("LOCA", "Locanza", 8, 5000000000000000), ERC20, ERC223 {\n', '\n', '    using SafeMath for uint;\n', '    using Addresses for address;\n', '\n', '    address owner;\n', '\n', '    struct lockDetail {\n', '        uint amount;\n', '        uint lockedDate;\n', '        uint daysLocked;\n', '        bool Locked;\n', '    }\n', '\n', '// to keep track of the minting stages\n', '// The meaning of the 5 stages have yet to be determined\n', '// minting will be done after 25 years or earlier when mining bounties are relevant\n', '\n', '    enum Stages {\n', '        FirstLoyaltyProgram,\n', '        Stage1,\n', '        Stage2,\n', '        Stage3,\n', '        Stage4,\n', '        Stage5\n', '    }\n', '    Stages internal stage = Stages.FirstLoyaltyProgram;\n', '\n', '// Locked Balance + Balance = total _totalsupply\n', '    mapping(address=>lockDetail)  _Locked;\n', '\n', '//Lock event\n', '    event Locked(address indexed _locker, uint _amount);\n', '// Unlock event\n', '    event Unlock(address indexed _receiver, uint _amount);\n', '\n', '    modifier onlyOwner () {\n', '        require (owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '//checked\n', '    constructor()\n', '        public {\n', '        owner = msg.sender;\n', '        _balanceOf[msg.sender] = _totalSupply;\n', '    }\n', '\n', '//checked\n', '    function balanceOf(address _addr)\n', '        public\n', '        view\n', '        returns (uint) {\n', '        return _balanceOf[_addr];\n', '    }\n', '//checked\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool) {\n', '        return transfer(_to, _value, "");\n', '    }\n', '//checked\n', '    function transfer(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool) {\n', '        require (_value > 0 &&\n', '            _value <= _balanceOf[msg.sender]); \n', '        \n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '            if (_to.isContract()) {\n', '                ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            }\n', '  \n', '        \n', '\n', '        return true;\n', '    }\n', '//checked\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        returns (bool) {\n', '        return transferFrom(_from, _to, _value, "");\n', '    }\n', '\n', '//checked\n', '    function transferFrom(address _from, address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool) {\n', '        require (_allowances[_from][msg.sender] > 0 && \n', '            _value > 0 &&\n', '            _allowances[_from][msg.sender] >= _value &&\n', '            _balanceOf[_from] >= _value); \n', '\n', '        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        if (_to.isContract()) {\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '            _contract.tokenFallback(msg.sender, _value, _data);\n', '              }\n', '\n', '        return true;\n', '        \n', '    }\n', '// checked\n', '    function approve(address _spender, uint _value)\n', '        public\n', '        returns (bool) {\n', '        require (_balanceOf[msg.sender] >= _value && _value >= 0); \n', '            _allowances[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '    }\n', '// checked\n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        view\n', '        returns (uint) {\n', '        \n', '        return _allowances[_owner][_spender];\n', '       \n', '    }\n', '\n', '// minting and locking functionality\n', '\n', '\n', '// Minted coins are added to the total supply\n', '// Minted coins have to be locked between 30 and 365 to protect tokenholders\n', '// Only minting sets a new stage (first stage is the FirstLoyaltyProgram after initial token creation)\n', '\n', '    function coinMinter (uint _amount, uint _days) public onlyOwner  returns (bool) {\n', '        require(_amount > 0);\n', '        // max 1 year lock only\n', '        require(_days > 30 && _days <= 365);\n', '    // this is where we eventualy set the total supply\n', '        require (_amount + _totalSupply <= 10000000000000000);\n', '        _totalSupply += _amount;\n', '        stage = Stages(uint(stage)+1);\n', '        lockAfterMinting(_amount, _days);\n', '        return true;\n', '    }\n', '// Only one stage at a time can be minted\n', '// Because of the internal call to lockAfterMinting\n', '\n', '    function lockAfterMinting( uint _amount, uint _days) internal onlyOwner returns(bool) {\n', '     // only one token lock (per stage) is possible\n', '        require(_amount > 0);\n', '        require(_days > 30 && _days <= 365);\n', '        require(_Locked[msg.sender].Locked != true);\n', '        _Locked[msg.sender].amount = _amount;\n', '        _Locked[msg.sender].lockedDate = now;\n', '        _Locked[msg.sender].daysLocked = _days;\n', '        _Locked[msg.sender].Locked = true;\n', '        emit Locked(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function lockOwnerBalance( uint _amount, uint _days) public onlyOwner returns(bool) {\n', '   // max 1 year lock only\n', '        require(_amount > 0);\n', '        require(_days > 30 && _days <= 365);\n', '        require(_balanceOf[msg.sender] >= _amount);\n', '   // only one token lock (per stage) is possible\n', '        require(_Locked[msg.sender].Locked != true);\n', '  // extract tokens from the owner balance\n', '        _balanceOf[msg.sender] -= _amount;\n', '\n', '        _Locked[msg.sender].amount = _amount;\n', '        _Locked[msg.sender].lockedDate = now;\n', '        _Locked[msg.sender].daysLocked = _days;\n', '        _Locked[msg.sender].Locked = true;\n', '        emit Locked(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function lockedBalance() public view returns(uint,uint,uint){\n', '        \n', '        return (_Locked[owner].amount,_Locked[owner].lockedDate,_Locked[owner].daysLocked) ;\n', '    }\n', '\n', '// This functions adds te locked tokens to the owner balance\n', '    function unlockOwnerBalance() public onlyOwner returns(bool){\n', '\n', '        require(_Locked[msg.sender].Locked == true);\n', '// require statement regarding the date time require for unlock\n', '// for testing purposes only in seconds\n', '        require(now > _Locked[msg.sender].lockedDate + _Locked[msg.sender].daysLocked * 1 days);\n', '        _balanceOf[msg.sender] += _Locked[msg.sender].amount;\n', '        delete _Locked[msg.sender];\n', '\n', '        emit Unlock(msg.sender, _Locked[msg.sender].amount);\n', '        return true;\n', '    }\n', '\n', '    function getStage() public view returns(string){\n', '\n', '        if (uint(stage)==0) {\n', '            return "FirstLoyalty";\n', '        } else if(uint(stage)==1){\n', '            return "Stage1";\n', '         } else if (uint(stage)==2){\n', '            return "Stage2";\n', '        }  else if(uint(stage)==3){\n', '            return "Stage3" ;\n', '        } else if(uint(stage)==4){\n', '            return "Stage4" ;\n', '        }else if(uint(stage)==5){\n', '            return "Stage5" ;\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface ERC20 {\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n', '    function approve(address _spender, uint _value) external returns (bool);\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'interface ERC223 {\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'contract Token {\n', '\n', '    string internal _symbol;\n', '    string internal _name;\n', '\n', '    uint8 internal _decimals;\n', '    uint internal _totalSupply;\n', '\n', '    mapping (address => uint) internal _balanceOf;\n', '    mapping (address => mapping (address => uint)) internal _allowances;\n', '\n', '    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {\n', '        _symbol = symbol;\n', '        _name = name;\n', '        _decimals = decimals;\n', '        _totalSupply = totalSupply;\n', '    }\n', '\n', '    function name()\n', '        public\n', '        view\n', '        returns (string) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol()\n', '        public\n', '        view\n', '        returns (string) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals()\n', '        public\n', '        view\n', '        returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _addr) public view returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '}\n', '\n', 'library SafeMath {\n', '    function sub(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint) {\n', '        assert(_value <= _base);\n', '        return _base - _value;\n', '    }\n', '\n', '    function add(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint _ret) {\n', '        _ret = _base + _value;\n', '        assert(_ret >= _base);\n', '    }\n', '\n', '    function div(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint) {\n', '        assert(_value > 0 && (_base % _value) == 0);\n', '        return _base / _value;\n', '    }\n', '\n', '    function mul(uint _base, uint _value)\n', '        internal\n', '        pure\n', '        returns (uint _ret) {\n', '        _ret = _base * _value;\n', '        assert(0 == _base || _ret / _base == _value);\n', '    }\n', '}\n', '\n', 'library Addresses {\n', '    function isContract(address _base) internal view returns (bool) {\n', '        uint codeSize;\n', '            assembly {\n', '            codeSize := extcodesize(_base)\n', '            }\n', '        return codeSize > 0;\n', '    }\n', '}\n', '\n', 'contract MyToken is Token("LOCA", "Locanza", 8, 5000000000000000), ERC20, ERC223 {\n', '\n', '    using SafeMath for uint;\n', '    using Addresses for address;\n', '\n', '    address owner;\n', '\n', '    struct lockDetail {\n', '        uint amount;\n', '        uint lockedDate;\n', '        uint daysLocked;\n', '        bool Locked;\n', '    }\n', '\n', '// to keep track of the minting stages\n', '// The meaning of the 5 stages have yet to be determined\n', '// minting will be done after 25 years or earlier when mining bounties are relevant\n', '\n', '    enum Stages {\n', '        FirstLoyaltyProgram,\n', '        Stage1,\n', '        Stage2,\n', '        Stage3,\n', '        Stage4,\n', '        Stage5\n', '    }\n', '    Stages internal stage = Stages.FirstLoyaltyProgram;\n', '\n', '// Locked Balance + Balance = total _totalsupply\n', '    mapping(address=>lockDetail)  _Locked;\n', '\n', '//Lock event\n', '    event Locked(address indexed _locker, uint _amount);\n', '// Unlock event\n', '    event Unlock(address indexed _receiver, uint _amount);\n', '\n', '    modifier onlyOwner () {\n', '        require (owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '//checked\n', '    constructor()\n', '        public {\n', '        owner = msg.sender;\n', '        _balanceOf[msg.sender] = _totalSupply;\n', '    }\n', '\n', '//checked\n', '    function balanceOf(address _addr)\n', '        public\n', '        view\n', '        returns (uint) {\n', '        return _balanceOf[_addr];\n', '    }\n', '//checked\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool) {\n', '        return transfer(_to, _value, "");\n', '    }\n', '//checked\n', '    function transfer(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool) {\n', '        require (_value > 0 &&\n', '            _value <= _balanceOf[msg.sender]); \n', '        \n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '            if (_to.isContract()) {\n', '                ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            }\n', '  \n', '        \n', '\n', '        return true;\n', '    }\n', '//checked\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        returns (bool) {\n', '        return transferFrom(_from, _to, _value, "");\n', '    }\n', '\n', '//checked\n', '    function transferFrom(address _from, address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool) {\n', '        require (_allowances[_from][msg.sender] > 0 && \n', '            _value > 0 &&\n', '            _allowances[_from][msg.sender] >= _value &&\n', '            _balanceOf[_from] >= _value); \n', '\n', '        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        if (_to.isContract()) {\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '            _contract.tokenFallback(msg.sender, _value, _data);\n', '              }\n', '\n', '        return true;\n', '        \n', '    }\n', '// checked\n', '    function approve(address _spender, uint _value)\n', '        public\n', '        returns (bool) {\n', '        require (_balanceOf[msg.sender] >= _value && _value >= 0); \n', '            _allowances[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '    }\n', '// checked\n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        view\n', '        returns (uint) {\n', '        \n', '        return _allowances[_owner][_spender];\n', '       \n', '    }\n', '\n', '// minting and locking functionality\n', '\n', '\n', '// Minted coins are added to the total supply\n', '// Minted coins have to be locked between 30 and 365 to protect tokenholders\n', '// Only minting sets a new stage (first stage is the FirstLoyaltyProgram after initial token creation)\n', '\n', '    function coinMinter (uint _amount, uint _days) public onlyOwner  returns (bool) {\n', '        require(_amount > 0);\n', '        // max 1 year lock only\n', '        require(_days > 30 && _days <= 365);\n', '    // this is where we eventualy set the total supply\n', '        require (_amount + _totalSupply <= 10000000000000000);\n', '        _totalSupply += _amount;\n', '        stage = Stages(uint(stage)+1);\n', '        lockAfterMinting(_amount, _days);\n', '        return true;\n', '    }\n', '// Only one stage at a time can be minted\n', '// Because of the internal call to lockAfterMinting\n', '\n', '    function lockAfterMinting( uint _amount, uint _days) internal onlyOwner returns(bool) {\n', '     // only one token lock (per stage) is possible\n', '        require(_amount > 0);\n', '        require(_days > 30 && _days <= 365);\n', '        require(_Locked[msg.sender].Locked != true);\n', '        _Locked[msg.sender].amount = _amount;\n', '        _Locked[msg.sender].lockedDate = now;\n', '        _Locked[msg.sender].daysLocked = _days;\n', '        _Locked[msg.sender].Locked = true;\n', '        emit Locked(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function lockOwnerBalance( uint _amount, uint _days) public onlyOwner returns(bool) {\n', '   // max 1 year lock only\n', '        require(_amount > 0);\n', '        require(_days > 30 && _days <= 365);\n', '        require(_balanceOf[msg.sender] >= _amount);\n', '   // only one token lock (per stage) is possible\n', '        require(_Locked[msg.sender].Locked != true);\n', '  // extract tokens from the owner balance\n', '        _balanceOf[msg.sender] -= _amount;\n', '\n', '        _Locked[msg.sender].amount = _amount;\n', '        _Locked[msg.sender].lockedDate = now;\n', '        _Locked[msg.sender].daysLocked = _days;\n', '        _Locked[msg.sender].Locked = true;\n', '        emit Locked(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function lockedBalance() public view returns(uint,uint,uint){\n', '        \n', '        return (_Locked[owner].amount,_Locked[owner].lockedDate,_Locked[owner].daysLocked) ;\n', '    }\n', '\n', '// This functions adds te locked tokens to the owner balance\n', '    function unlockOwnerBalance() public onlyOwner returns(bool){\n', '\n', '        require(_Locked[msg.sender].Locked == true);\n', '// require statement regarding the date time require for unlock\n', '// for testing purposes only in seconds\n', '        require(now > _Locked[msg.sender].lockedDate + _Locked[msg.sender].daysLocked * 1 days);\n', '        _balanceOf[msg.sender] += _Locked[msg.sender].amount;\n', '        delete _Locked[msg.sender];\n', '\n', '        emit Unlock(msg.sender, _Locked[msg.sender].amount);\n', '        return true;\n', '    }\n', '\n', '    function getStage() public view returns(string){\n', '\n', '        if (uint(stage)==0) {\n', '            return "FirstLoyalty";\n', '        } else if(uint(stage)==1){\n', '            return "Stage1";\n', '         } else if (uint(stage)==2){\n', '            return "Stage2";\n', '        }  else if(uint(stage)==3){\n', '            return "Stage3" ;\n', '        } else if(uint(stage)==4){\n', '            return "Stage4" ;\n', '        }else if(uint(stage)==5){\n', '            return "Stage5" ;\n', '        }\n', '    }\n', '\n', '}']
