['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract FUT5 {\n', '\n', '    uint256 constant MAX_UINT256 = 2**256 - 1;\n', '    \n', '    uint256 MAX_SUBMITTED = 5000671576194550000;\n', '\n', '    // (no premine)\n', '    uint256 _totalSupply = 0;\n', '    \n', '    // The following 2 variables are essentially a lookup table.\n', '    // They are not constant because they are memory.\n', '    // I came up with this because calculating it was expensive,\n', '    // especially so when crossing tiers.\n', '    \n', '    // Sum of each tier by ether submitted.\n', '   uint256[] levels = [ \n', '      87719298245614000,\n', '     198955253301794000,\n', '     373500707847248000,\n', '     641147766670778000,\n', '     984004909527921000,\n', '    1484004909527920000,\n', '    2184004909527920000,\n', '    3084004909527920000,\n', '    4150671576194590000,\n', '    5000671576194550000\n', '    ];\n', '    \n', '    // Token amounts for each tier.\n', '    uint256[] ratios = [\n', '      114,\n', '      89,\n', '      55,\n', '      34,\n', '      21,\n', '      13,\n', '       8,\n', '       5,\n', '       3,\n', '       2 ];\n', '     \n', '    // total ether submitted before fees.\n', '    uint256 _submitted = 0;\n', '    \n', '    uint256 public tier = 0;\n', '    \n', '    // ERC20 events.\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    \n', '    // FUT5 events.\n', '    event Mined(address indexed _miner, uint _value);\n', '    event WaitStarted(uint256 endTime);\n', '    event SwapStarted(uint256 endTime);\n', '    event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time);\n', '    event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time);\n', '\n', ' \n', '    // Optional ERC20 values.\n', '    string public name = "Futereum 5";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "FUT5";\n', '    \n', '    // Public variables so the curious can check the state.\n', '    bool public swap = false;\n', '    bool public wait = false;\n', '    bool public extended = false;\n', '    \n', '    // Public end time for the current state.\n', '    uint256 public endTime;\n', '    \n', '    // These are calculated at mining start.\n', '    uint256 swapTime;\n', '    uint256 swapEndTime;\n', '    uint256 endTimeExtended;\n', '    uint256 swapTimeExtended;\n', '    uint256 swapEndTimeExtended;\n', '    \n', '    // Pay rate calculated from balance later.\n', '    uint256 public payRate = 0;\n', '    \n', '    // Fee variables.  Fees are reserved and then withdrawn  later.\n', '    uint256 submittedFeesPaid = 0;\n', '    uint256 penalty = 0;\n', '    uint256 reservedFees = 0;\n', '    \n', '    // Storage.\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '   // Fallback function mines the tokens.\n', '   // Send from a wallet you control.\n', '   // DON&#39;T send from an exchange wallet!\n', '   // We recommend sending using a method that calculates gas for you.\n', '   // Here are some estimates (not guaranteed to be accurate):\n', '   // It usually costs around 90k gas.  It cost more if you cross a tier.\n', '   // Maximum around 190k gas.\n', '   function () external payable {\n', '   \n', '       require(msg.sender != address(0) &&\n', '                tier != 10 &&\n', '                swap == false &&\n', '                wait == false);\n', '    \n', '        uint256 issued = mint(msg.sender, msg.value);\n', '        \n', '        Mined(msg.sender, issued);\n', '        Transfer(this, msg.sender, issued);\n', '    }\n', '    \n', '    // Constructor.\n', '    function FUT5() public {\n', '        _start();\n', '    }\n', '    \n', '    // This gets called by constructor AND after the swap to restart evertying.\n', '    function _start() internal \n', '    {\n', '        swap = false;\n', '        wait = false;\n', '        extended = false;\n', '    \n', '        endTime = now + 4 hours;\n', '        swapTime = endTime + 2 hours;\n', '        swapEndTime = swapTime + 2 hours;\n', '        endTimeExtended = now + 8 hours;\n', '        swapTimeExtended = endTimeExtended + 2 hours;\n', '        swapEndTimeExtended = swapTimeExtended + 2 hours;\n', '        \n', '        submittedFeesPaid = 0;\n', '        _submitted = 0;\n', '        \n', '        reservedFees = 0;\n', '        \n', '        payRate = 0;\n', '        \n', '        tier = 0;\n', '                \n', '        MiningStart(endTime, swapTime, swapEndTime);\n', '    }\n', '    \n', '    // Restarts everything after swap.\n', '    // This is expensive, so we make someone call it and pay for the gas.\n', '    // Any holders that miss the swap get to keep their tokens.\n', '    // Ether stays in contract, minus 20% penalty fee.\n', '    function restart() public {\n', '        require(swap && now >= endTime);\n', '        \n', '        penalty = this.balance * 2000 / 10000;\n', '        \n', '        payFees();\n', '        \n', '        _start();\n', '    }\n', '    \n', '    // ERC20 standard supply function.\n', '    function totalSupply() public constant returns (uint)\n', '    {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    // Mints new tokens when they are mined.\n', '    function mint(address _to, uint256 _value) internal returns (uint256) \n', '    {\n', '        uint256 total = _submitted + _value;\n', '        \n', '        if (total > MAX_SUBMITTED)\n', '        {\n', '            uint256 refund = total - MAX_SUBMITTED - 1;\n', '            _value = _value - refund;\n', '            \n', '            // refund money and continue.\n', '            _to.transfer(refund);\n', '        }\n', '        \n', '        _submitted += _value;\n', '        \n', '        total -= refund;\n', '        \n', '        uint256 tokens = calculateTokens(total, _value);\n', '        \n', '        balances[_to] += tokens;\n', '       \n', '        _totalSupply += tokens;\n', '        \n', '        return tokens;\n', '    }\n', '    \n', '    // Calculates the tokens mined based on the tier.\n', '    function calculateTokens(uint256 total, uint256 _value) internal returns (uint256)\n', '    {\n', '        if (tier == 10) \n', '        {\n', '            // This just rounds it off to an even number.\n', '            return 74000;\n', '        }\n', '        \n', '        uint256 tokens = 0;\n', '        \n', '        if (total > levels[tier])\n', '        {\n', '            uint256 remaining = total - levels[tier];\n', '            _value -= remaining;\n', '            tokens = (_value) * ratios[tier];\n', '           \n', '            tier += 1;\n', '            \n', '            tokens += calculateTokens(total, remaining);\n', '        }\n', '        else\n', '        {\n', '            tokens = _value * ratios[tier];\n', '        }\n', '        \n', '        return tokens;\n', '    }\n', '    \n', '    // This is basically so you don&#39;t have to add 1 to the last completed tier.\n', '    //  You&#39;re welcome.\n', '    function currentTier() public view returns (uint256) {\n', '        if (tier == 10)\n', '        {\n', '            return 10;\n', '        }\n', '        else\n', '        {\n', '            return tier + 1;\n', '        }\n', '    }\n', '    \n', '    // Ether remaining for tier.\n', '    function leftInTier() public view returns (uint256) {\n', '        if (tier == 10) {\n', '            return 0;\n', '        }\n', '        else\n', '        {\n', '            return levels[tier] - _submitted;\n', '        }\n', '    }\n', '    \n', '    // Total sumbitted for mining.\n', '    function submitted() public view returns (uint256) {\n', '        return _submitted;\n', '    }\n', '    \n', '    // Balance minus oustanding fees.\n', '    function balanceMinusFeesOutstanding() public view returns (uint256) {\n', '        return this.balance - (penalty + (_submitted - submittedFeesPaid) * 1530 / 10000);  // fees are 15.3 % total.\n', '    }\n', '    \n', '    // Calculates the amount of ether per token from the balance.\n', '    // This is calculated once by the first account to swap.\n', '    function calulateRate() internal {\n', '        reservedFees = penalty + (_submitted - submittedFeesPaid) * 1530 / 10000;  // fees are 15.3 % total.\n', '        \n', '        uint256 tokens = _totalSupply / 1 ether;\n', '        payRate = (this.balance - reservedFees);\n', '\n', '        payRate = payRate / tokens;\n', '    }\n', '    \n', '    // This function is called on token transfer and fee payment.\n', '    // It checks the next deadline and then updates the deadline and state.\n', '    // \n', '    // It uses the block time, but the time periods are days and months,\n', '    // so it should be pretty safe  &#175;\\_(ãƒ„)_/&#175; \n', '    function _updateState() internal {\n', '        // Most of the time, this will just be skipped.\n', '        if (now >= endTime)\n', '        {\n', '            // We are not currently swapping or waiting to swap\n', '            if(!swap && !wait)\n', '            {\n', '                if (extended)\n', '                {\n', '                    // It&#39;s been 36 months.\n', '                    wait = true;\n', '                    endTime = swapTimeExtended;\n', '                    WaitStarted(endTime);\n', '                }\n', '                else if (tier == 10)\n', '                {\n', '                    // Tiers filled\n', '                    wait = true;\n', '                    endTime = swapTime;\n', '                    WaitStarted(endTime);\n', '                } \n', '                else\n', '                {\n', '                    // Extended to 36 months\n', '                    endTime = endTimeExtended;\n', '                    extended = true;\n', '                    \n', '                    MiningExtended(endTime, swapTime, swapEndTime);\n', '                }\n', '            } \n', '            else if (wait)\n', '            {\n', '                // It&#39;s time to swap.\n', '                swap = true;\n', '                wait = false;\n', '                \n', '                if (extended) \n', '                {\n', '                    endTime = swapEndTimeExtended;\n', '                }\n', '                else\n', '                {\n', '                    endTime = swapEndTime;\n', '                }\n', '                \n', '                SwapStarted(endTime);\n', '            }\n', '        }\n', '    }\n', '   \n', '    // Standard ERC20 transfer plus state check and token swap logic.\n', '    //\n', '    // We recommend sending using a method that calculates gas for you.\n', '    //\n', '    // Here are some estimates (not guaranteed to be accurate):\n', '    // It usually costs around 37k gas.  It cost more if the state changes.\n', '    // State change means around 55k - 65k gas.\n', '    // Swapping tokens for ether costs around 46k gas. (around 93k for the first account to swap)\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        require(balances[msg.sender] >= _value);\n', '        \n', '         // Normal transfers check if time is expired.  \n', '        _updateState();\n', '\n', '        // Check if sending in for swap.\n', '        if (_to == address(this)) \n', '        {\n', '            // throw if they can&#39;t swap yet.\n', '            require(swap);\n', '            \n', '            if (payRate == 0)\n', '            {\n', '                calulateRate(); // Gas to calc the rate paid by first unlucky soul.\n', '            }\n', '            \n', '            uint256 amount = _value * payRate;\n', '            // Adjust for decimals\n', '            amount /= 1 ether;\n', '            \n', '            // Burn tokens.\n', '            balances[msg.sender] -= _value;\n', '             _totalSupply -= _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            \n', '            //send ether\n', '            msg.sender.transfer(amount);\n', '        } else\n', '        {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // Standard ERC20.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '       \n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Standard ERC20.\n', '    function balanceOf(address _owner) view public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Standard ERC20.\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '    \n', '    // ********************\n', '    // Fee stuff.\n', '\n', '    // Addresses for fees. Tops own&#39;s all of these now\n', '    address public foundation = 0xE252765E4A71e3170b2215cf63C16E7553ec26bD;\n', '    address public owner = 0xa4cdd9c17d87EcceF6a02AC43F677501cAb05d04;\n', '    address public dev = 0xE063FC19c38ceDb8d543a563452096c2D94C84B4;\n', '    \n', '    // Pays fees to the foundation, the owner, and the dev.\n', '    // It also updates the state.  Anyone can call this.\n', '    function payFees() public {\n', '         // Check state to see if swap needs to happen.\n', '         _updateState();\n', '         \n', '        uint256 fees = penalty + (_submitted - submittedFeesPaid) * 1530 / 10000;  // fees are 15.3 % total.\n', '        submittedFeesPaid = _submitted;\n', '        \n', '        reservedFees = 0;\n', '        penalty = 0;\n', '        \n', '        if (fees > 0) \n', '        {\n', '            foundation.transfer(fees / 2);\n', '            owner.transfer(fees / 4);\n', '            dev.transfer(fees / 4);\n', '        }\n', '    }\n', '    \n', '    function changeFoundation (address _receiver) public\n', '    {\n', '        require(msg.sender == foundation);\n', '        foundation = _receiver;\n', '    }\n', '    \n', '    \n', '    function changeOwner (address _receiver) public\n', '    {\n', '        require(msg.sender == owner);\n', '        owner = _receiver;\n', '    }\n', '    \n', '    function changeDev (address _receiver) public\n', '    {\n', '        require(msg.sender == dev);\n', '        dev = _receiver;\n', '    }    \n', '\n', '}']