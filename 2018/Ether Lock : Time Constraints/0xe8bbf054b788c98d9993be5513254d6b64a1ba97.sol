['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Beneficiary is Ownable {\n', '\n', '    address public beneficiary;\n', '\n', '    function Beneficiary() public {\n', '        beneficiary = msg.sender;\n', '    }\n', '\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract ChestsStore is Beneficiary {\n', '\n', '\n', '    struct chestProduct {\n', '        uint256 price; // Price in wei\n', '        bool isLimited; // is limited sale chest\n', '        uint32 limit; // Sell limit\n', '        uint16 boosters; // count of boosters\n', '        uint24 raiseChance;// in 1/10 of percent\n', '        uint24 raiseStrength;// in 1/10 of percent for params or minutes for timebased boosters\n', '        uint8 onlyBoosterType;//If set chest will produce only this type\n', '        uint8 onlyBoosterStrength;\n', '    }\n', '\n', '\n', '    chestProduct[255] public chestProducts;\n', '    FishbankChests chests;\n', '\n', '\n', '    function ChestsStore(address _chests) public {\n', '        chests = FishbankChests(_chests);\n', '        //set chests to this address\n', '    }\n', '\n', '    function initChestsStore() public onlyOwner {\n', '        // Create basic chests types\n', '        setChestProduct(1, 0, 1, false, 0, 0, 0, 0, 0);\n', '        setChestProduct(2, 15 finney, 3, false, 0, 0, 0, 0, 0);\n', '        setChestProduct(3, 20 finney, 5, false, 0, 0, 0, 0, 0);\n', '    }\n', '\n', '    function setChestProduct(uint16 chestId, uint256 price, uint16 boosters, bool isLimited, uint32 limit, uint24 raiseChance, uint24 raiseStrength, uint8 onlyBoosterType, uint8 onlyBoosterStrength) onlyOwner public {\n', '        chestProduct storage newProduct = chestProducts[chestId];\n', '        newProduct.price = price;\n', '        newProduct.boosters = boosters;\n', '        newProduct.isLimited = isLimited;\n', '        newProduct.limit = limit;\n', '        newProduct.raiseChance = raiseChance;\n', '        newProduct.raiseStrength = raiseStrength;\n', '        newProduct.onlyBoosterType = onlyBoosterType;\n', '        newProduct.onlyBoosterStrength = onlyBoosterStrength;\n', '    }\n', '\n', '    function setChestPrice(uint16 chestId, uint256 price) onlyOwner public {\n', '        chestProducts[chestId].price = price;\n', '    }\n', '\n', '    function buyChest(uint16 _chestId) payable public {\n', '        chestProduct memory tmpChestProduct = chestProducts[_chestId];\n', '\n', '        require(tmpChestProduct.price > 0);\n', '        // only chests with price\n', '        require(msg.value >= tmpChestProduct.price);\n', '        //check if enough ether is send\n', '        require(!tmpChestProduct.isLimited || tmpChestProduct.limit > 0);\n', '        //check limits if they exists\n', '\n', '        chests.mintChest(msg.sender, tmpChestProduct.boosters, tmpChestProduct.raiseStrength, tmpChestProduct.raiseChance, tmpChestProduct.onlyBoosterType, tmpChestProduct.onlyBoosterStrength);\n', '\n', '        if (msg.value > chestProducts[_chestId].price) {//send to much ether send some back\n', '            msg.sender.transfer(msg.value - chestProducts[_chestId].price);\n', '        }\n', '\n', '        beneficiary.transfer(chestProducts[_chestId].price);\n', '        //send paid eth to beneficiary\n', '\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankBoosters is Ownable {\n', '\n', '    struct Booster {\n', '        address owner;\n', '        uint32 duration;\n', '        uint8 boosterType;\n', '        uint24 raiseValue;\n', '        uint8 strength;\n', '        uint32 amount;\n', '    }\n', '\n', '    Booster[] public boosters;\n', '    bool public implementsERC721 = true;\n', '    string public name = "Fishbank Boosters";\n', '    string public symbol = "FISHB";\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    address public fishbank;\n', '    address public chests;\n', '    address public auction;\n', '\n', '    modifier onlyBoosterOwner(uint256 _tokenId) {\n', '        require(boosters[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyChest() {\n', '        require(chests == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function FishbankBoosters() public {\n', '        //nothing yet\n', '    }\n', '\n', '    //mints the boosters can only be called by owner. could be a smart contract\n', '    function mintBooster(address _owner, uint32 _duration, uint8 _type, uint8 _strength, uint32 _amount, uint24 _raiseValue) onlyChest public {\n', '        boosters.length ++;\n', '\n', '        Booster storage tempBooster = boosters[boosters.length - 1];\n', '\n', '        tempBooster.owner = _owner;\n', '        tempBooster.duration = _duration;\n', '        tempBooster.boosterType = _type;\n', '        tempBooster.strength = _strength;\n', '        tempBooster.amount = _amount;\n', '        tempBooster.raiseValue = _raiseValue;\n', '\n', '        Transfer(address(0), _owner, boosters.length - 1);\n', '    }\n', '\n', '    function setFishbank(address _fishbank) onlyOwner public {\n', '        fishbank = _fishbank;\n', '    }\n', '\n', '    function setChests(address _chests) onlyOwner public {\n', '        if (chests != address(0)) {\n', '            revert();\n', '        }\n', '        chests = _chests;\n', '    }\n', '\n', '    function setAuction(address _auction) onlyOwner public {\n', '        auction = _auction;\n', '    }\n', '\n', '    function getBoosterType(uint256 _tokenId) view public returns (uint8 boosterType) {\n', '        boosterType = boosters[_tokenId].boosterType;\n', '    }\n', '\n', '    function getBoosterAmount(uint256 _tokenId) view public returns (uint32 boosterAmount) {\n', '        boosterAmount = boosters[_tokenId].amount;\n', '    }\n', '\n', '    function getBoosterDuration(uint256 _tokenId) view public returns (uint32) {\n', '        if (boosters[_tokenId].boosterType == 4 || boosters[_tokenId].boosterType == 2) {\n', '            return boosters[_tokenId].duration + boosters[_tokenId].raiseValue * 60;\n', '        }\n', '        return boosters[_tokenId].duration;\n', '    }\n', '\n', '    function getBoosterStrength(uint256 _tokenId) view public returns (uint8 strength) {\n', '        strength = boosters[_tokenId].strength;\n', '    }\n', '\n', '    function getBoosterRaiseValue(uint256 _tokenId) view public returns (uint24 raiseValue) {\n', '        raiseValue = boosters[_tokenId].raiseValue;\n', '    }\n', '\n', '    //ERC721 functionality\n', '    //could split this to a different contract but doesn&#39;t make it easier to read\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = boosters.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = boosters[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(boosters[_tokenId].owner == _from);\n', '        //can only transfer if previous owner equals from\n', '        boosters[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0);\n', '        //reset approved of fish on every transfer\n', '        balances[_from] -= 1;\n', '        //underflow can only happen on 0x\n', '        balances[_to] += 1;\n', '        //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyBoosterOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyBoosterOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender || msg.sender == fishbank || msg.sender == auction);\n', '        //require msg.sender to be approved for this token or to be the fishbank contract\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(approved[_tokenId] == msg.sender);\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankChests is Ownable {\n', '\n', '    struct Chest {\n', '        address owner;\n', '        uint16 boosters;\n', '        uint16 chestType;\n', '        uint24 raiseChance;//Increace chance to catch bigger chest (1 = 1:10000)\n', '        uint8 onlySpecificType;\n', '        uint8 onlySpecificStrength;\n', '        uint24 raiseStrength;\n', '    }\n', '\n', '    Chest[] public chests;\n', '    FishbankBoosters public boosterContract;\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => bool) public minters;\n', '\n', '    modifier onlyChestOwner(uint256 _tokenId) {\n', '        require(chests[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyMinters() {\n', '        require(minters[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function FishbankChests(address _boosterAddress) public {\n', '        boosterContract = FishbankBoosters(_boosterAddress);\n', '    }\n', '\n', '    function addMinter(address _minter) onlyOwner public {\n', '        minters[_minter] = true;\n', '    }\n', '\n', '    function removeMinter(address _minter) onlyOwner public {\n', '        minters[_minter] = false;\n', '    }\n', '\n', '    //create a chest\n', '\n', '    function mintChest(address _owner, uint16 _boosters, uint24 _raiseStrength, uint24 _raiseChance, uint8 _onlySpecificType, uint8 _onlySpecificStrength) onlyMinters public {\n', '\n', '        chests.length++;\n', '        chests[chests.length - 1].owner = _owner;\n', '        chests[chests.length - 1].boosters = _boosters;\n', '        chests[chests.length - 1].raiseStrength = _raiseStrength;\n', '        chests[chests.length - 1].raiseChance = _raiseChance;\n', '        chests[chests.length - 1].onlySpecificType = _onlySpecificType;\n', '        chests[chests.length - 1].onlySpecificStrength = _onlySpecificStrength;\n', '        Transfer(address(0), _owner, chests.length - 1);\n', '    }\n', '\n', '    function convertChest(uint256 _tokenId) onlyChestOwner(_tokenId) public {\n', '\n', '        Chest memory chest = chests[_tokenId];\n', '        uint16 numberOfBoosters = chest.boosters;\n', '\n', '        if (chest.onlySpecificType != 0) {//Specific boosters\n', '            if (chest.onlySpecificType == 1 || chest.onlySpecificType == 3) {\n', '                boosterContract.mintBooster(msg.sender, 2 days, chest.onlySpecificType, chest.onlySpecificStrength, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 5) {//Instant attack\n', '                boosterContract.mintBooster(msg.sender, 0, 5, 1, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 2) {//Freeze\n', '                uint32 freezeTime = 7 days;\n', '                if (chest.onlySpecificStrength == 2) {\n', '                    freezeTime = 14 days;\n', '                } else if (chest.onlySpecificStrength == 3) {\n', '                    freezeTime = 30 days;\n', '                }\n', '                boosterContract.mintBooster(msg.sender, freezeTime, 5, chest.onlySpecificType, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 4) {//Watch\n', '                uint32 watchTime = 12 hours;\n', '                if (chest.onlySpecificStrength == 2) {\n', '                    watchTime = 48 hours;\n', '                } else if (chest.onlySpecificStrength == 3) {\n', '                    watchTime = 3 days;\n', '                }\n', '                boosterContract.mintBooster(msg.sender, watchTime, 4, chest.onlySpecificStrength, chest.boosters, chest.raiseStrength);\n', '            }\n', '\n', '        } else {//Regular chest\n', '\n', '            for (uint8 i = 0; i < numberOfBoosters; i ++) {\n', '                uint24 random = uint16(keccak256(block.coinbase, block.blockhash(block.number - 1), i, chests.length)) % 1000\n', '                - chest.raiseChance;\n', '                //get random 0 - 9999 minus raiseChance\n', '\n', '                if (random > 850) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 1, 1, chest.raiseStrength); //Small Agility Booster\n', '                } else if (random > 700) {\n', '                    boosterContract.mintBooster(msg.sender, 7 days, 2, 1, 1, chest.raiseStrength); //Small Freezer\n', '                } else if (random > 550) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 1, 1, chest.raiseStrength); //Small Power Booster\n', '                } else if (random > 400) {\n', '                    boosterContract.mintBooster(msg.sender, 12 hours, 4, 1, 1, chest.raiseStrength); //Tiny Watch\n', '                } else if (random > 325) {\n', '                    boosterContract.mintBooster(msg.sender, 48 hours, 4, 2, 1, chest.raiseStrength); //Small Watch\n', '                } else if (random > 250) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 2, 1, chest.raiseStrength); //Mid Agility Booster\n', '                } else if (random > 175) {\n', '                    boosterContract.mintBooster(msg.sender, 14 days, 2, 2, 1, chest.raiseStrength); //Mid Freezer\n', '                } else if (random > 100) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 2, 1, chest.raiseStrength); //Mid Power Booster\n', '                } else if (random > 80) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 3, 1, chest.raiseStrength); //Big Agility Booster\n', '                } else if (random > 60) {\n', '                    boosterContract.mintBooster(msg.sender, 30 days, 2, 3, 1, chest.raiseStrength); //Big Freezer\n', '                } else if (random > 40) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 3, 1, chest.raiseStrength); //Big Power Booster\n', '                } else if (random > 20) {\n', '                    boosterContract.mintBooster(msg.sender, 0, 5, 1, 1, 0); //Instant Attack\n', '                } else {\n', '                    boosterContract.mintBooster(msg.sender, 3 days, 4, 3, 1, 0); //Gold Watch\n', '                }\n', '            }\n', '        }\n', '\n', '        _transfer(msg.sender, address(0), _tokenId); //burn chest\n', '    }\n', '\n', '    //ERC721 functionality\n', '    //could split this to a different contract but doesn&#39;t make it easier to read\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = chests.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = chests[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(chests[_tokenId].owner == _from); //can only transfer if previous owner equals from\n', '        chests[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0); //reset approved of fish on every transfer\n', '        balances[_from] -= 1; //underflow can only happen on 0x\n', '        balances[_to] += 1; //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyChestOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyChestOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender);\n', '        //require msg.sender to be approved for this token\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankUtils is Ownable {\n', '\n', '    uint32[100] cooldowns = [\n', '        720 minutes, 720 minutes, 720 minutes, 720 minutes, 720 minutes, //1-5\n', '        660 minutes, 660 minutes, 660 minutes, 660 minutes, 660 minutes, //6-10\n', '        600 minutes, 600 minutes, 600 minutes, 600 minutes, 600 minutes, //11-15\n', '        540 minutes, 540 minutes, 540 minutes, 540 minutes, 540 minutes, //16-20\n', '        480 minutes, 480 minutes, 480 minutes, 480 minutes, 480 minutes, //21-25\n', '        420 minutes, 420 minutes, 420 minutes, 420 minutes, 420 minutes, //26-30\n', '        360 minutes, 360 minutes, 360 minutes, 360 minutes, 360 minutes, //31-35\n', '        300 minutes, 300 minutes, 300 minutes, 300 minutes, 300 minutes, //36-40\n', '        240 minutes, 240 minutes, 240 minutes, 240 minutes, 240 minutes, //41-45\n', '        180 minutes, 180 minutes, 180 minutes, 180 minutes, 180 minutes, //46-50\n', '        120 minutes, 120 minutes, 120 minutes, 120 minutes, 120 minutes, //51-55\n', '        90 minutes,  90 minutes,  90 minutes,  90 minutes,  90 minutes,  //56-60\n', '        75 minutes,  75 minutes,  75 minutes,  75 minutes,  75 minutes,  //61-65\n', '        60 minutes,  60 minutes,  60 minutes,  60 minutes,  60 minutes,  //66-70\n', '        50 minutes,  50 minutes,  50 minutes,  50 minutes,  50 minutes,  //71-75\n', '        40 minutes,  40 minutes,  40 minutes,  40 minutes,  40 minutes,  //76-80\n', '        30 minutes,  30 minutes,  30 minutes,  30 minutes,  30 minutes,  //81-85\n', '        20 minutes,  20 minutes,  20 minutes,  20 minutes,  20 minutes,  //86-90\n', '        10 minutes,  10 minutes,  10 minutes,  10 minutes,  10 minutes,  //91-95\n', '        5 minutes,   5 minutes,   5 minutes,   5 minutes,   5 minutes    //96-100\n', '    ];\n', '\n', '\n', '    function setCooldowns(uint32[100] _cooldowns) onlyOwner public {\n', '        cooldowns = _cooldowns;\n', '    }\n', '\n', '    function getFishParams(uint256 hashSeed1, uint256 hashSeed2, uint256 fishesLength, address coinbase) external pure returns (uint32[4]) {\n', '\n', '        bytes32[5] memory hashSeeds;\n', '        hashSeeds[0] = keccak256(hashSeed1 ^ hashSeed2); //xor both seed from owner and user so no one can cheat\n', '        hashSeeds[1] = keccak256(hashSeeds[0], fishesLength);\n', '        hashSeeds[2] = keccak256(hashSeeds[1], coinbase);\n', '        hashSeeds[3] = keccak256(hashSeeds[2], coinbase, fishesLength);\n', '        hashSeeds[4] = keccak256(hashSeeds[1], hashSeeds[2], hashSeeds[0]);\n', '\n', '        uint24[6] memory seeds = [\n', '            uint24(uint(hashSeeds[3]) % 10e6 + 1), //whale chance\n', '            uint24(uint(hashSeeds[0]) % 420 + 1), //power\n', '            uint24(uint(hashSeeds[1]) % 420 + 1), //agility\n', '            uint24(uint(hashSeeds[2]) % 150 + 1), //speed\n', '            uint24(uint(hashSeeds[4]) % 16 + 1), //whale type\n', '            uint24(uint(hashSeeds[4]) % 5000 + 1) //rarity\n', '        ];\n', '\n', '        uint32[4] memory fishParams;\n', '\n', '        if (seeds[0] == 1000000) {//This is a whale 1:1 000 000 chance\n', '\n', '            if (seeds[4] == 1) {//Orca\n', '                fishParams = [140 + uint8(seeds[1] / 42), 140 + uint8(seeds[2] / 42), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 140) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 140) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            } else if (seeds[4] < 4) {//Blue whale\n', '                fishParams = [130 + uint8(seeds[1] / 42), 130 + uint8(seeds[2] / 42), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 130) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 130) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            } else {//Cachalot\n', '                fishParams = [115 + uint8(seeds[1] / 28), 115 + uint8(seeds[2] / 28), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 115) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 115) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            }\n', '        } else {\n', '            if (seeds[5] == 5000) {//Legendary\n', '                fishParams = [85 + uint8(seeds[1] / 14), 85 + uint8(seeds[2] / 14), uint8(50 + seeds[3] / 3), uint32(1000)];\n', '                if(fishParams[0] == 85) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 85) {\n', '                    fishParams[1]++;\n', '                }\n', '            } else if (seeds[5] > 4899) {//Epic\n', '                fishParams = [50 + uint8(seeds[1] / 12), 50 + uint8(seeds[2] / 12), uint8(25 + seeds[3] / 2), uint32(300)];\n', '                if(fishParams[0] == 50) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 50) {\n', '                    fishParams[1]++;\n', '                }\n', '\n', '            } else if (seeds[5] > 4000) {//Rare\n', '                fishParams = [20 + uint8(seeds[1] / 14), 20 + uint8(seeds[2] / 14), uint8(25 + seeds[3] / 3), uint32(100)];\n', '                if(fishParams[0] == 20) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 20) {\n', '                    fishParams[1]++;\n', '                }\n', '            } else {//Common\n', '                fishParams = [uint8(seeds[1] / 21), uint8(seeds[2] / 21), uint8(seeds[3] / 3), uint32(36)];\n', '                if (fishParams[0] == 0) {\n', '                    fishParams[0] = 1;\n', '                }\n', '                if (fishParams[1] == 0) {\n', '                    fishParams[1] = 1;\n', '                }\n', '                if (fishParams[2] == 0) {\n', '                    fishParams[2] = 1;\n', '                }\n', '            }\n', '        }\n', '\n', '        return fishParams;\n', '    }\n', '\n', '    function getCooldown(uint16 speed) external view returns (uint64){\n', '        return uint64(now + cooldowns[speed - 1]);\n', '    }\n', '\n', '    //Ceiling function for fish generator\n', '    function ceil(uint base, uint divider) internal pure returns (uint) {\n', '        return base / divider + ((base % divider > 0) ? 1 : 0);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Auction contract for any type of erc721 token\n', '/// @author Fishbank\n', '\n', 'contract ERC721 {\n', '\n', '    function implementsERC721() public pure returns (bool);\n', '\n', '    function totalSupply() public view returns (uint256 total);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '\n', '    function approve(address _to, uint256 _tokenId) public;\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool);\n', '\n', '    function transfer(address _to, uint256 _tokenId) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '\n', 'contract ERC721Auction is Beneficiary {\n', '\n', '    struct Auction {\n', '        address seller;\n', '        uint256 tokenId;\n', '        uint64 auctionBegin;\n', '        uint64 auctionEnd;\n', '        uint256 startPrice;\n', '        uint256 endPrice;\n', '    }\n', '\n', '    uint32 public auctionDuration = 7 days;\n', '\n', '    ERC721 public ERC721Contract;\n', '    uint256 public fee = 45000; //in 1 10000th of a percent so 4.5% at the start\n', '    uint256 constant FEE_DIVIDER = 1000000;\n', '    mapping(uint256 => Auction) public auctions;\n', '\n', '    event AuctionWon(uint256 indexed tokenId, address indexed winner, address indexed seller, uint256 price);\n', '\n', '    event AuctionStarted(uint256 indexed tokenId, address indexed seller);\n', '\n', '    event AuctionFinalized(uint256 indexed tokenId, address indexed seller);\n', '\n', '\n', '    function startAuction(uint256 _tokenId, uint256 _startPrice, uint256 _endPrice) external {\n', '        require(ERC721Contract.transferFrom(msg.sender, address(this), _tokenId));\n', '        //Prices must be in range from 0.01 Eth and 10 000 Eth\n', '        require(_startPrice <= 10000 ether && _endPrice <= 10000 ether);\n', '        require(_startPrice >= (1 ether / 100) && _endPrice >= (1 ether / 100));\n', '\n', '        Auction memory auction;\n', '\n', '        auction.seller = msg.sender;\n', '        auction.tokenId = _tokenId;\n', '        auction.auctionBegin = uint64(now);\n', '        auction.auctionEnd = uint64(now + auctionDuration);\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.startPrice = _startPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_tokenId] = auction;\n', '\n', '        AuctionStarted(_tokenId, msg.sender);\n', '    }\n', '\n', '\n', '    function buyAuction(uint256 _tokenId) payable external {\n', '        Auction storage auction = auctions[_tokenId];\n', '\n', '        uint256 price = calculateBid(_tokenId);\n', '        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\n', '\n', '        require(price <= msg.value); //revert if not enough ether send\n', '\n', '        if (price != msg.value) {//send back to much eth\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '\n', '        beneficiary.transfer(totalFee);\n', '\n', '        auction.seller.transfer(price - totalFee);\n', '\n', '        if (!ERC721Contract.transfer(msg.sender, _tokenId)) {\n', '            revert();\n', '            //can&#39;t complete transfer if this fails\n', '        }\n', '\n', '        AuctionWon(_tokenId, msg.sender, auction.seller, price);\n', '\n', '        delete auctions[_tokenId];\n', '        //deletes auction\n', '    }\n', '\n', '    function saveToken(uint256 _tokenId) external {\n', '        require(auctions[_tokenId].auctionEnd < now);\n', '        //auction must have ended\n', '        require(ERC721Contract.transfer(auctions[_tokenId].seller, _tokenId));\n', '        //transfer fish back to seller\n', '\n', '        AuctionFinalized(_tokenId, auctions[_tokenId].seller);\n', '\n', '        delete auctions[_tokenId];\n', '        //delete auction\n', '    }\n', '\n', '    function ERC721Auction(address _ERC721Contract) public {\n', '        ERC721Contract = ERC721(_ERC721Contract);\n', '    }\n', '\n', '    function setFee(uint256 _fee) onlyOwner public {\n', '        if (_fee > fee) {\n', '            revert(); //fee can only be set to lower value to prevent attacks by owner\n', '        }\n', '        fee = _fee; // all is well set fee\n', '    }\n', '\n', '    function calculateBid(uint256 _tokenId) public view returns (uint256) {\n', '        Auction storage auction = auctions[_tokenId];\n', '\n', '        if (now >= auction.auctionEnd) {//if auction ended return auction end price\n', '            return auction.endPrice;\n', '        }\n', '        //get hours passed\n', '        uint256 hoursPassed = (now - auction.auctionBegin) / 1 hours;\n', '        uint256 currentPrice;\n', '        //get total hours\n', '        uint16 totalHours = uint16(auctionDuration /1 hours) - 1;\n', '\n', '        if (auction.endPrice > auction.startPrice) {\n', '            currentPrice = auction.startPrice + (hoursPassed * (auction.endPrice - auction.startPrice))/ totalHours;\n', '        } else if(auction.endPrice < auction.startPrice) {\n', '            currentPrice = auction.startPrice - (hoursPassed * (auction.startPrice - auction.endPrice))/ totalHours;\n', '        } else {//start and end are the same\n', '            currentPrice = auction.endPrice;\n', '        }\n', '\n', '        return uint256(currentPrice);\n', '        //return the price at this very moment\n', '    }\n', '\n', '    /// return token if case when need to redeploy auction contract\n', '    function returnToken(uint256 _tokenId) onlyOwner public {\n', '        require(ERC721Contract.transfer(auctions[_tokenId].seller, _tokenId));\n', '        //transfer fish back to seller\n', '\n', '        AuctionFinalized(_tokenId, auctions[_tokenId].seller);\n', '\n', '        delete auctions[_tokenId];\n', '    }\n', '}\n', '\n', '\n', '/// @title Core contract of fishbank\n', '/// @author Fishbank\n', '\n', 'contract Fishbank is ChestsStore {\n', '\n', '    struct Fish {\n', '        address owner;\n', '        uint8 activeBooster;\n', '        uint64 boostedTill;\n', '        uint8 boosterStrength;\n', '        uint24 boosterRaiseValue;\n', '        uint64 weight;\n', '        uint16 power;\n', '        uint16 agility;\n', '        uint16 speed;\n', '        bytes16 color;\n', '        uint64 canFightAgain;\n', '        uint64 canBeAttackedAgain;\n', '    }\n', '\n', '    struct FishingAttempt {\n', '        address fisher;\n', '        uint256 feePaid;\n', '        address affiliate;\n', '        uint256 seed;\n', '        uint64 deadline;//till when does the contract owner have time to resolve;\n', '    }\n', '\n', '    modifier onlyFishOwner(uint256 _tokenId) {\n', '        require(fishes[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyResolver() {\n', '        require(msg.sender == resolver);\n', '        _;\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(msg.sender == minter);\n', '        _;\n', '    }\n', '\n', '    Fish[] public fishes;\n', '    address public resolver;\n', '    address public auction;\n', '    address public minter;\n', '    bool public implementsERC721 = true;\n', '    string public name = "Fishbank";\n', '    string public symbol = "FISH";\n', '    bytes32[] public randomHashes;\n', '    uint256 public hashesUsed;\n', '    uint256 public aquariumCost = 1 ether / 100 * 3;//fee for fishing starts at 0.03 ether\n', '    uint256 public resolveTime = 30 minutes;//how long does the contract owner have to resolve hashes\n', '    uint16 public weightLostPartLimit = 5;\n', '    FishbankBoosters public boosters;\n', '    FishbankChests public chests;\n', '    FishbankUtils private utils;\n', '\n', '\n', '    mapping(bytes32 => FishingAttempt) public pendingFishing;//attempts that need solving;\n', '\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => bool) public affiliated;\n', '\n', '    event AquariumFished(\n', '        bytes32 hash,\n', '        address fisher,\n', '        uint256 feePaid\n', '    ); //event broadcated when someone fishes in aqaurium\n', '\n', '    event AquariumResolved(bytes32 hash, address fisher);\n', '\n', '    event Attack(\n', '        uint256 attacker,\n', '        uint256 victim,\n', '        uint256 winner,\n', '        uint64 weight,\n', '        uint256 ap, uint256 vp, uint256 random\n', '    );\n', '\n', '    event BoosterApplied(uint256 tokenId, uint256 boosterId);\n', '\n', '    /// @notice Constructor of the contract. Sets resolver, beneficiary, boosters and chests\n', '    /// @param _boosters the address of the boosters smart contract\n', '    /// @param _chests the address of the chests smart contract\n', '\n', '    function Fishbank(address _boosters, address _chests, address _utils) ChestsStore(_chests) public {\n', '\n', '        resolver = msg.sender;\n', '        beneficiary = msg.sender;\n', '        boosters = FishbankBoosters(_boosters);\n', '        chests = FishbankChests(_chests);\n', '        utils = FishbankUtils(_utils);\n', '    }\n', '\n', '    /// @notice Mints fishes according to params can only be called by the owner\n', '    /// @param _owner array of addresses the fishes should be owned by\n', '    /// @param _weight array of weights for the fishes\n', '    /// @param _power array of power levels for the fishes\n', '    /// @param _agility array of agility levels for the fishes\n', '    /// @param _speed array of speed levels for the fishes\n', '    /// @param _color array of color params for the fishes\n', '\n', '    function mintFish(address[] _owner, uint32[] _weight, uint8[] _power, uint8[] _agility, uint8[] _speed, bytes16[] _color) onlyMinter public {\n', '\n', '        for (uint i = 0; i < _owner.length; i ++) {\n', '            _mintFish(_owner[i], _weight[i], _power[i], _agility[i], _speed[i], _color[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Internal method for minting a fish\n', '    /// @param _owner address of owner for the fish\n', '    /// @param _weight weight param for fish\n', '    /// @param _power power param for fish\n', '    /// @param _agility agility param for the fish\n', '    /// @param _speed speed param for the fish\n', '    /// @param _color color param for the fish\n', '\n', '    function _mintFish(address _owner, uint32 _weight, uint8 _power, uint8 _agility, uint8 _speed, bytes16 _color) internal {\n', '\n', '        fishes.length += 1;\n', '        uint256 newFishId = fishes.length - 1;\n', '\n', '        Fish storage newFish = fishes[newFishId];\n', '\n', '        newFish.owner = _owner;\n', '        newFish.weight = _weight;\n', '        newFish.power = _power;\n', '        newFish.agility = _agility;\n', '        newFish.speed = _speed;\n', '        newFish.color = _color;\n', '\n', '        balances[_owner] ++;\n', '\n', '        Transfer(address(0), _owner, newFishId);\n', '    }\n', '\n', '    function setWeightLostPartLimit(uint8 _weightPart) onlyOwner public {\n', '        weightLostPartLimit = _weightPart;\n', '    }\n', '\n', '    /// @notice Sets the cost for fishing in the aquarium\n', '    /// @param _fee new fee for fishing in wei\n', '    function setAquariumCost(uint256 _fee) onlyOwner public {\n', '        aquariumCost = _fee;\n', '    }\n', '\n', '    /// @notice Sets address that resolves hashes for fishing can only be called by the owner\n', '    /// @param _resolver address of the resolver\n', '    function setResolver(address _resolver) onlyOwner public {\n', '        resolver = _resolver;\n', '    }\n', '\n', '\n', '    /// @notice Sets the address getting the proceedings from fishing in the aquarium\n', '    /// @param _beneficiary address of the new beneficiary\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function setAuction(address _auction) onlyOwner public {\n', '        auction = _auction;\n', '    }\n', '\n', '    function setBoosters(address _boosters) onlyOwner public {\n', '        boosters = FishbankBoosters(_boosters);\n', '    }\n', '\n', '    function setMinter(address _minter) onlyOwner public {\n', '        minter = _minter;\n', '    }\n', '\n', '    function setUtils(address _utils) onlyOwner public {\n', '        utils = FishbankUtils(_utils);\n', '    }\n', '\n', '    function batchFishAquarium(uint256[] _seeds, address _affiliate) payable public {\n', '        require(_seeds.length > 0);\n', '        require(msg.value >= aquariumCost);\n', '        //must send enough ether to cover costs\n', '        require(randomHashes.length > hashesUsed + _seeds.length);\n', '        //there needs to be a hash left\n', '\n', '\n', '\n', '        if (msg.value > aquariumCost * _seeds.length) {\n', '            msg.sender.transfer(msg.value - aquariumCost * _seeds.length);\n', '            //send to much ether back\n', '        }\n', '\n', '        for (uint256 i = 0; i < _seeds.length; i ++) {\n', '            _fishAquarium(_seeds[i]);\n', '        }\n', '\n', '        if(_affiliate != address(0)) {\n', '            pendingFishing[randomHashes[hashesUsed - 1]].affiliate = _affiliate;\n', '        }\n', '    }\n', '\n', '    function _fishAquarium(uint256 _seed) internal {\n', '        //this loop prevents from using the same hash as another fishing attempt if the owner submits the same hash multiple times\n', '        while (pendingFishing[randomHashes[hashesUsed]].fisher != address(0)) {\n', '            hashesUsed++;\n', '            //increase hashesUsed and try next one\n', '        }\n', '\n', '        FishingAttempt storage newAttempt = pendingFishing[randomHashes[hashesUsed]];\n', '\n', '        newAttempt.fisher = msg.sender;\n', '        newAttempt.feePaid = aquariumCost;\n', '        //set the fee paid so it can be returned if the hash doesn&#39;t get resolved fast enough\n', '        newAttempt.seed = _seed;\n', '        //sets the seed that gets combined with the random seed of the owner\n', '        newAttempt.deadline = uint64(now + resolveTime);\n', '        //saves deadline after which the fisher can redeem his fishing fee\n', '\n', '        hashesUsed++;\n', '        //increase hashes used so it cannot be used again\n', '\n', '        AquariumFished(randomHashes[hashesUsed - 1], msg.sender, aquariumCost);\n', '        //broadcast event\n', '    }\n', '\n', '    /// @notice Call this to resolve hashes and generate fish/chests\n', '    /// @param _seed seed that corresponds to the hash\n', '    function _resolveAquarium(uint256 _seed) internal {\n', '        bytes32 tempHash = keccak256(_seed);\n', '        FishingAttempt storage tempAttempt = pendingFishing[tempHash];\n', '\n', '        require(tempAttempt.fisher != address(0));\n', '        //attempt must be set so we look if fisher is set\n', '\n', '        if (tempAttempt.affiliate != address(0) && !affiliated[tempAttempt.fisher]) {//if affiliate is set\n', '            chests.mintChest(tempAttempt.affiliate, 1, 0, 0, 0, 0);\n', '            //Chest with one random booster\n', '            affiliated[tempAttempt.fisher] = true;\n', '        }\n', '\n', '        uint32[4] memory fishParams = utils.getFishParams(_seed, tempAttempt.seed, fishes.length, block.coinbase);\n', '\n', '        _mintFish(tempAttempt.fisher, fishParams[3], uint8(fishParams[0]), uint8(fishParams[1]), uint8(fishParams[2]), bytes16(keccak256(_seed ^ tempAttempt.seed)));\n', '\n', '        beneficiary.transfer(tempAttempt.feePaid);\n', '        AquariumResolved(tempHash, tempAttempt.fisher);\n', '        //broadcast event\n', '\n', '        delete pendingFishing[tempHash];\n', '        //delete fishing attempt\n', '    }\n', '\n', '    /// @notice Batch resolve fishing attempts\n', '    /// @param _seeds array of seeds that correspond to hashes that need resolving\n', '    function batchResolveAquarium(uint256[] _seeds) onlyResolver public {\n', '        for (uint256 i = 0; i < _seeds.length; i ++) {\n', '            _resolveAquarium(_seeds[i]);\n', '        }\n', '    }\n', '\n', '\n', '    /// @notice Adds an array of hashes to be used for resolving\n', '    /// @param _hashes array of hashes to add\n', '    function addHash(bytes32[] _hashes) onlyResolver public {\n', '        for (uint i = 0; i < _hashes.length; i ++) {\n', '            randomHashes.push(_hashes[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Call this function to attack another fish\n', '    /// @param _attacker ID of fish that is attacking\n', '    /// @param _victim ID of fish to attack\n', '    function attack(uint256 _attacker, uint256 _victim) onlyFishOwner(_attacker) public {\n', '\n', '        Fish memory attacker = fishes[_attacker];\n', '        Fish memory victim = fishes[_victim];\n', '\n', '        //check if attacker is sleeping\n', '        if (attacker.activeBooster == 2 && attacker.boostedTill > now) {//if your fish is sleeping auto awake it\n', '            fishes[_attacker].activeBooster = 0;\n', '            attacker.boostedTill = uint64(now);\n', '            //set booster to invalid one so it has no effect\n', '        }\n', '\n', '        //check if victim has active sleeping booster\n', '        require(!((victim.activeBooster == 2) && victim.boostedTill >= now));\n', '        //cannot attack a sleeping fish\n', '        require(now >= attacker.canFightAgain);\n', '        //check if attacking fish is cooled down\n', '        require(now >= victim.canBeAttackedAgain);\n', '        //check if victim fish can be attacked again\n', '\n', '\n', '        if (msg.sender == victim.owner) {\n', '            uint64 weight = attacker.weight < victim.weight ? attacker.weight : victim.weight;\n', '            fishes[_attacker].weight += weight;\n', '            fishes[_victim].weight -= weight;\n', '            fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed));\n', '\n', '            if (fishes[_victim].weight == 0) {\n', '                _transfer(msg.sender, address(0), _victim);\n', '                balances[fishes[_victim].owner] --;\n', '                //burn token\n', '            } else {\n', '                fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours);\n', '                //set victim cooldown 1 hour\n', '            }\n', '\n', '            Attack(_attacker, _victim, _attacker, weight, 0, 0, 0);\n', '            return;\n', '        }\n', '\n', '        if (victim.weight < 2 || attacker.weight < 2) {\n', '            revert();\n', '            //revert if one of the fish is below fighting weight\n', '        }\n', '\n', '        uint256 AP = getFightingAmounts(attacker, true);\n', '        // get attacker power\n', '        uint256 VP = getFightingAmounts(victim, false);\n', '        // get victim power\n', '\n', '        bytes32 randomHash = keccak256(block.coinbase, block.blockhash(block.number - 1), fishes.length);\n', '\n', '        uint256 max = AP > VP ? AP : VP;\n', '        uint256 attackRange = max * 2;\n', '        uint256 random = uint256(randomHash) % attackRange + 1;\n', '\n', '        uint64 weightLost;\n', '\n', '        if (random <= (max + AP - VP)) {\n', '            weightLost = _handleWin(_attacker, _victim);\n', '            Attack(_attacker, _victim, _attacker, weightLost, AP, VP, random);\n', '        } else {\n', '            weightLost = _handleWin(_victim, _attacker);\n', '            Attack(_attacker, _victim, _victim, weightLost, AP, VP, random);\n', '            //broadcast event\n', '        }\n', '\n', '        fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed));\n', '        fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours);\n', '        //set victim cooldown 1 hour\n', '    }\n', '\n', '    /// @notice Handles lost gained weight after fight\n', '    /// @param _winner the winner of the fight\n', '    /// @param _loser the loser of the fight\n', '    function _handleWin(uint256 _winner, uint256 _loser) internal returns (uint64) {\n', '        Fish storage winner = fishes[_winner];\n', '        Fish storage loser = fishes[_loser];\n', '\n', '        uint64 fullWeightLost = loser.weight / sqrt(winner.weight);\n', '        uint64 maxWeightLost = loser.weight / weightLostPartLimit;\n', '\n', '        uint64 weightLost = maxWeightLost < fullWeightLost ? maxWeightLost : fullWeightLost;\n', '\n', '        if (weightLost < 1) {\n', '            weightLost = 1;\n', '            // Minimum 1\n', '        }\n', '\n', '        winner.weight += weightLost;\n', '        loser.weight -= weightLost;\n', '\n', '        return weightLost;\n', '    }\n', '\n', '    /// @notice get attack and defence from fish\n', '    /// @param _fish is Fish token\n', '    /// @param _is_attacker true if fish is attacker otherwise false\n', '    function getFightingAmounts(Fish _fish, bool _is_attacker) internal view returns (uint256){\n', '        return (getFishPower(_fish) * (_is_attacker ? 60 : 40) + getFishAgility(_fish) * (_is_attacker ? 40 : 60)) * _fish.weight;\n', '    }\n', '\n', '    /// @notice Apply a booster to a fish\n', '    /// @param _tokenId the fish the booster should be applied to\n', '    /// @param _booster the Id of the booster the token should be applied to\n', '    function applyBooster(uint256 _tokenId, uint256 _booster) onlyFishOwner(_tokenId) public {\n', '        require(msg.sender == boosters.ownerOf(_booster));\n', '        //only owner can do this\n', '        require(boosters.getBoosterAmount(_booster) >= 1);\n', '        Fish storage tempFish = fishes[_tokenId];\n', '        uint8 boosterType = uint8(boosters.getBoosterType(_booster));\n', '\n', '        if (boosterType == 1 || boosterType == 2 || boosterType == 3) {//if booster is attack or agility or sleep\n', '            tempFish.boosterStrength = boosters.getBoosterStrength(_booster);\n', '            tempFish.activeBooster = boosterType;\n', '            tempFish.boostedTill = boosters.getBoosterDuration(_booster) * boosters.getBoosterAmount(_booster) + uint64(now);\n', '            tempFish.boosterRaiseValue = boosters.getBoosterRaiseValue(_booster);\n', '        }\n', '        else if (boosterType == 4) {//watch booster\n', '            require(tempFish.boostedTill > uint64(now));\n', '            //revert on using watch on booster that has passed;\n', '            tempFish.boosterStrength = boosters.getBoosterStrength(_booster);\n', '            tempFish.boostedTill += boosters.getBoosterDuration(_booster) * boosters.getBoosterAmount(_booster);\n', '            //add time to booster\n', '        }\n', '        else if (boosterType == 5) {//Instant attack\n', '            require(boosters.getBoosterAmount(_booster) == 1);\n', '            //Can apply only one instant attack booster\n', '            tempFish.canFightAgain = 0;\n', '        }\n', '\n', '        require(boosters.transferFrom(msg.sender, address(0), _booster));\n', '        //burn booster\n', '\n', '        BoosterApplied(_tokenId, _booster);\n', '    }\n', '\n', '    /// @notice square root function used for weight gain/loss\n', '    /// @param x uint64 to get square root from\n', '    function sqrt(uint64 x) pure internal returns (uint64 y) {\n', '        uint64 z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    //utlitiy function for easy testing can be removed later\n', '    function doKeccak256(uint256 _input) pure public returns (bytes32) {\n', '        return keccak256(_input);\n', '    }\n', '\n', '    function getFishPower(Fish _fish) internal view returns (uint24 power) {\n', '        power = _fish.power;\n', '        if (_fish.activeBooster == 1 && _fish.boostedTill > now) {// check if booster active\n', '            uint24 boosterPower = (10 * _fish.boosterStrength + _fish.boosterRaiseValue + 100) * power / 100 - power;\n', '            if (boosterPower < 1 && _fish.boosterStrength == 1) {\n', '                power += 1;\n', '            } else if (boosterPower < 3 && _fish.boosterStrength == 2) {\n', '                power += 3;\n', '            } else if (boosterPower < 5 && _fish.boosterStrength == 3) {\n', '                power += 5;\n', '            } else {\n', '                power = boosterPower + power;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getFishAgility(Fish _fish) internal view returns (uint24 agility) {\n', '        agility = _fish.agility;\n', '        if (_fish.activeBooster == 3 && _fish.boostedTill > now) {// check if booster active\n', '            uint24 boosterPower = (10 * _fish.boosterStrength + _fish.boosterRaiseValue + 100) * agility / 100 - agility;\n', '            if (boosterPower < 1 && _fish.boosterStrength == 1) {\n', '                agility += 1;\n', '            } else if (boosterPower < 3 && _fish.boosterStrength == 2) {\n', '                agility += 3;\n', '            } else if (boosterPower < 5 && _fish.boosterStrength == 3) {\n', '                agility += 5;\n', '            } else {\n', '                agility = boosterPower + agility;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    //ERC721 functionality\n', '    //could split this to a different contract but doesn&#39;t make it easier to read\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = fishes.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = fishes[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(fishes[_tokenId].owner == _from);\n', '        //can only transfer if previous owner equals from\n', '        fishes[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0);\n', '        //reset approved of fish on every transfer\n', '        balances[_from] -= 1;\n', '        //underflow can only happen on 0x\n', '        balances[_to] += 1;\n', '        //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyFishOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyFishOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender || msg.sender == auction);\n', '        Fish storage fish = fishes[_tokenId];\n', '\n', '        if (msg.sender == auction) {\n', '            fish.activeBooster = 2;\n', '            //Freeze for auction\n', '            fish.boostedTill = uint64(now + 7 days);\n', '            fish.boosterStrength = 1;\n', '        }\n', '        //require msg.sender to be approved for this token\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(approved[_tokenId] == msg.sender);\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Beneficiary is Ownable {\n', '\n', '    address public beneficiary;\n', '\n', '    function Beneficiary() public {\n', '        beneficiary = msg.sender;\n', '    }\n', '\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract ChestsStore is Beneficiary {\n', '\n', '\n', '    struct chestProduct {\n', '        uint256 price; // Price in wei\n', '        bool isLimited; // is limited sale chest\n', '        uint32 limit; // Sell limit\n', '        uint16 boosters; // count of boosters\n', '        uint24 raiseChance;// in 1/10 of percent\n', '        uint24 raiseStrength;// in 1/10 of percent for params or minutes for timebased boosters\n', '        uint8 onlyBoosterType;//If set chest will produce only this type\n', '        uint8 onlyBoosterStrength;\n', '    }\n', '\n', '\n', '    chestProduct[255] public chestProducts;\n', '    FishbankChests chests;\n', '\n', '\n', '    function ChestsStore(address _chests) public {\n', '        chests = FishbankChests(_chests);\n', '        //set chests to this address\n', '    }\n', '\n', '    function initChestsStore() public onlyOwner {\n', '        // Create basic chests types\n', '        setChestProduct(1, 0, 1, false, 0, 0, 0, 0, 0);\n', '        setChestProduct(2, 15 finney, 3, false, 0, 0, 0, 0, 0);\n', '        setChestProduct(3, 20 finney, 5, false, 0, 0, 0, 0, 0);\n', '    }\n', '\n', '    function setChestProduct(uint16 chestId, uint256 price, uint16 boosters, bool isLimited, uint32 limit, uint24 raiseChance, uint24 raiseStrength, uint8 onlyBoosterType, uint8 onlyBoosterStrength) onlyOwner public {\n', '        chestProduct storage newProduct = chestProducts[chestId];\n', '        newProduct.price = price;\n', '        newProduct.boosters = boosters;\n', '        newProduct.isLimited = isLimited;\n', '        newProduct.limit = limit;\n', '        newProduct.raiseChance = raiseChance;\n', '        newProduct.raiseStrength = raiseStrength;\n', '        newProduct.onlyBoosterType = onlyBoosterType;\n', '        newProduct.onlyBoosterStrength = onlyBoosterStrength;\n', '    }\n', '\n', '    function setChestPrice(uint16 chestId, uint256 price) onlyOwner public {\n', '        chestProducts[chestId].price = price;\n', '    }\n', '\n', '    function buyChest(uint16 _chestId) payable public {\n', '        chestProduct memory tmpChestProduct = chestProducts[_chestId];\n', '\n', '        require(tmpChestProduct.price > 0);\n', '        // only chests with price\n', '        require(msg.value >= tmpChestProduct.price);\n', '        //check if enough ether is send\n', '        require(!tmpChestProduct.isLimited || tmpChestProduct.limit > 0);\n', '        //check limits if they exists\n', '\n', '        chests.mintChest(msg.sender, tmpChestProduct.boosters, tmpChestProduct.raiseStrength, tmpChestProduct.raiseChance, tmpChestProduct.onlyBoosterType, tmpChestProduct.onlyBoosterStrength);\n', '\n', '        if (msg.value > chestProducts[_chestId].price) {//send to much ether send some back\n', '            msg.sender.transfer(msg.value - chestProducts[_chestId].price);\n', '        }\n', '\n', '        beneficiary.transfer(chestProducts[_chestId].price);\n', '        //send paid eth to beneficiary\n', '\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankBoosters is Ownable {\n', '\n', '    struct Booster {\n', '        address owner;\n', '        uint32 duration;\n', '        uint8 boosterType;\n', '        uint24 raiseValue;\n', '        uint8 strength;\n', '        uint32 amount;\n', '    }\n', '\n', '    Booster[] public boosters;\n', '    bool public implementsERC721 = true;\n', '    string public name = "Fishbank Boosters";\n', '    string public symbol = "FISHB";\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    address public fishbank;\n', '    address public chests;\n', '    address public auction;\n', '\n', '    modifier onlyBoosterOwner(uint256 _tokenId) {\n', '        require(boosters[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyChest() {\n', '        require(chests == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function FishbankBoosters() public {\n', '        //nothing yet\n', '    }\n', '\n', '    //mints the boosters can only be called by owner. could be a smart contract\n', '    function mintBooster(address _owner, uint32 _duration, uint8 _type, uint8 _strength, uint32 _amount, uint24 _raiseValue) onlyChest public {\n', '        boosters.length ++;\n', '\n', '        Booster storage tempBooster = boosters[boosters.length - 1];\n', '\n', '        tempBooster.owner = _owner;\n', '        tempBooster.duration = _duration;\n', '        tempBooster.boosterType = _type;\n', '        tempBooster.strength = _strength;\n', '        tempBooster.amount = _amount;\n', '        tempBooster.raiseValue = _raiseValue;\n', '\n', '        Transfer(address(0), _owner, boosters.length - 1);\n', '    }\n', '\n', '    function setFishbank(address _fishbank) onlyOwner public {\n', '        fishbank = _fishbank;\n', '    }\n', '\n', '    function setChests(address _chests) onlyOwner public {\n', '        if (chests != address(0)) {\n', '            revert();\n', '        }\n', '        chests = _chests;\n', '    }\n', '\n', '    function setAuction(address _auction) onlyOwner public {\n', '        auction = _auction;\n', '    }\n', '\n', '    function getBoosterType(uint256 _tokenId) view public returns (uint8 boosterType) {\n', '        boosterType = boosters[_tokenId].boosterType;\n', '    }\n', '\n', '    function getBoosterAmount(uint256 _tokenId) view public returns (uint32 boosterAmount) {\n', '        boosterAmount = boosters[_tokenId].amount;\n', '    }\n', '\n', '    function getBoosterDuration(uint256 _tokenId) view public returns (uint32) {\n', '        if (boosters[_tokenId].boosterType == 4 || boosters[_tokenId].boosterType == 2) {\n', '            return boosters[_tokenId].duration + boosters[_tokenId].raiseValue * 60;\n', '        }\n', '        return boosters[_tokenId].duration;\n', '    }\n', '\n', '    function getBoosterStrength(uint256 _tokenId) view public returns (uint8 strength) {\n', '        strength = boosters[_tokenId].strength;\n', '    }\n', '\n', '    function getBoosterRaiseValue(uint256 _tokenId) view public returns (uint24 raiseValue) {\n', '        raiseValue = boosters[_tokenId].raiseValue;\n', '    }\n', '\n', '    //ERC721 functionality\n', "    //could split this to a different contract but doesn't make it easier to read\n", '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = boosters.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = boosters[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(boosters[_tokenId].owner == _from);\n', '        //can only transfer if previous owner equals from\n', '        boosters[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0);\n', '        //reset approved of fish on every transfer\n', '        balances[_from] -= 1;\n', '        //underflow can only happen on 0x\n', '        balances[_to] += 1;\n', '        //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyBoosterOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyBoosterOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender || msg.sender == fishbank || msg.sender == auction);\n', '        //require msg.sender to be approved for this token or to be the fishbank contract\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(approved[_tokenId] == msg.sender);\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankChests is Ownable {\n', '\n', '    struct Chest {\n', '        address owner;\n', '        uint16 boosters;\n', '        uint16 chestType;\n', '        uint24 raiseChance;//Increace chance to catch bigger chest (1 = 1:10000)\n', '        uint8 onlySpecificType;\n', '        uint8 onlySpecificStrength;\n', '        uint24 raiseStrength;\n', '    }\n', '\n', '    Chest[] public chests;\n', '    FishbankBoosters public boosterContract;\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => bool) public minters;\n', '\n', '    modifier onlyChestOwner(uint256 _tokenId) {\n', '        require(chests[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyMinters() {\n', '        require(minters[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function FishbankChests(address _boosterAddress) public {\n', '        boosterContract = FishbankBoosters(_boosterAddress);\n', '    }\n', '\n', '    function addMinter(address _minter) onlyOwner public {\n', '        minters[_minter] = true;\n', '    }\n', '\n', '    function removeMinter(address _minter) onlyOwner public {\n', '        minters[_minter] = false;\n', '    }\n', '\n', '    //create a chest\n', '\n', '    function mintChest(address _owner, uint16 _boosters, uint24 _raiseStrength, uint24 _raiseChance, uint8 _onlySpecificType, uint8 _onlySpecificStrength) onlyMinters public {\n', '\n', '        chests.length++;\n', '        chests[chests.length - 1].owner = _owner;\n', '        chests[chests.length - 1].boosters = _boosters;\n', '        chests[chests.length - 1].raiseStrength = _raiseStrength;\n', '        chests[chests.length - 1].raiseChance = _raiseChance;\n', '        chests[chests.length - 1].onlySpecificType = _onlySpecificType;\n', '        chests[chests.length - 1].onlySpecificStrength = _onlySpecificStrength;\n', '        Transfer(address(0), _owner, chests.length - 1);\n', '    }\n', '\n', '    function convertChest(uint256 _tokenId) onlyChestOwner(_tokenId) public {\n', '\n', '        Chest memory chest = chests[_tokenId];\n', '        uint16 numberOfBoosters = chest.boosters;\n', '\n', '        if (chest.onlySpecificType != 0) {//Specific boosters\n', '            if (chest.onlySpecificType == 1 || chest.onlySpecificType == 3) {\n', '                boosterContract.mintBooster(msg.sender, 2 days, chest.onlySpecificType, chest.onlySpecificStrength, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 5) {//Instant attack\n', '                boosterContract.mintBooster(msg.sender, 0, 5, 1, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 2) {//Freeze\n', '                uint32 freezeTime = 7 days;\n', '                if (chest.onlySpecificStrength == 2) {\n', '                    freezeTime = 14 days;\n', '                } else if (chest.onlySpecificStrength == 3) {\n', '                    freezeTime = 30 days;\n', '                }\n', '                boosterContract.mintBooster(msg.sender, freezeTime, 5, chest.onlySpecificType, chest.boosters, chest.raiseStrength);\n', '            } else if (chest.onlySpecificType == 4) {//Watch\n', '                uint32 watchTime = 12 hours;\n', '                if (chest.onlySpecificStrength == 2) {\n', '                    watchTime = 48 hours;\n', '                } else if (chest.onlySpecificStrength == 3) {\n', '                    watchTime = 3 days;\n', '                }\n', '                boosterContract.mintBooster(msg.sender, watchTime, 4, chest.onlySpecificStrength, chest.boosters, chest.raiseStrength);\n', '            }\n', '\n', '        } else {//Regular chest\n', '\n', '            for (uint8 i = 0; i < numberOfBoosters; i ++) {\n', '                uint24 random = uint16(keccak256(block.coinbase, block.blockhash(block.number - 1), i, chests.length)) % 1000\n', '                - chest.raiseChance;\n', '                //get random 0 - 9999 minus raiseChance\n', '\n', '                if (random > 850) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 1, 1, chest.raiseStrength); //Small Agility Booster\n', '                } else if (random > 700) {\n', '                    boosterContract.mintBooster(msg.sender, 7 days, 2, 1, 1, chest.raiseStrength); //Small Freezer\n', '                } else if (random > 550) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 1, 1, chest.raiseStrength); //Small Power Booster\n', '                } else if (random > 400) {\n', '                    boosterContract.mintBooster(msg.sender, 12 hours, 4, 1, 1, chest.raiseStrength); //Tiny Watch\n', '                } else if (random > 325) {\n', '                    boosterContract.mintBooster(msg.sender, 48 hours, 4, 2, 1, chest.raiseStrength); //Small Watch\n', '                } else if (random > 250) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 2, 1, chest.raiseStrength); //Mid Agility Booster\n', '                } else if (random > 175) {\n', '                    boosterContract.mintBooster(msg.sender, 14 days, 2, 2, 1, chest.raiseStrength); //Mid Freezer\n', '                } else if (random > 100) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 2, 1, chest.raiseStrength); //Mid Power Booster\n', '                } else if (random > 80) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 1, 3, 1, chest.raiseStrength); //Big Agility Booster\n', '                } else if (random > 60) {\n', '                    boosterContract.mintBooster(msg.sender, 30 days, 2, 3, 1, chest.raiseStrength); //Big Freezer\n', '                } else if (random > 40) {\n', '                    boosterContract.mintBooster(msg.sender, 2 days, 3, 3, 1, chest.raiseStrength); //Big Power Booster\n', '                } else if (random > 20) {\n', '                    boosterContract.mintBooster(msg.sender, 0, 5, 1, 1, 0); //Instant Attack\n', '                } else {\n', '                    boosterContract.mintBooster(msg.sender, 3 days, 4, 3, 1, 0); //Gold Watch\n', '                }\n', '            }\n', '        }\n', '\n', '        _transfer(msg.sender, address(0), _tokenId); //burn chest\n', '    }\n', '\n', '    //ERC721 functionality\n', "    //could split this to a different contract but doesn't make it easier to read\n", '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = chests.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = chests[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(chests[_tokenId].owner == _from); //can only transfer if previous owner equals from\n', '        chests[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0); //reset approved of fish on every transfer\n', '        balances[_from] -= 1; //underflow can only happen on 0x\n', '        balances[_to] += 1; //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyChestOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyChestOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender);\n', '        //require msg.sender to be approved for this token\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract FishbankUtils is Ownable {\n', '\n', '    uint32[100] cooldowns = [\n', '        720 minutes, 720 minutes, 720 minutes, 720 minutes, 720 minutes, //1-5\n', '        660 minutes, 660 minutes, 660 minutes, 660 minutes, 660 minutes, //6-10\n', '        600 minutes, 600 minutes, 600 minutes, 600 minutes, 600 minutes, //11-15\n', '        540 minutes, 540 minutes, 540 minutes, 540 minutes, 540 minutes, //16-20\n', '        480 minutes, 480 minutes, 480 minutes, 480 minutes, 480 minutes, //21-25\n', '        420 minutes, 420 minutes, 420 minutes, 420 minutes, 420 minutes, //26-30\n', '        360 minutes, 360 minutes, 360 minutes, 360 minutes, 360 minutes, //31-35\n', '        300 minutes, 300 minutes, 300 minutes, 300 minutes, 300 minutes, //36-40\n', '        240 minutes, 240 minutes, 240 minutes, 240 minutes, 240 minutes, //41-45\n', '        180 minutes, 180 minutes, 180 minutes, 180 minutes, 180 minutes, //46-50\n', '        120 minutes, 120 minutes, 120 minutes, 120 minutes, 120 minutes, //51-55\n', '        90 minutes,  90 minutes,  90 minutes,  90 minutes,  90 minutes,  //56-60\n', '        75 minutes,  75 minutes,  75 minutes,  75 minutes,  75 minutes,  //61-65\n', '        60 minutes,  60 minutes,  60 minutes,  60 minutes,  60 minutes,  //66-70\n', '        50 minutes,  50 minutes,  50 minutes,  50 minutes,  50 minutes,  //71-75\n', '        40 minutes,  40 minutes,  40 minutes,  40 minutes,  40 minutes,  //76-80\n', '        30 minutes,  30 minutes,  30 minutes,  30 minutes,  30 minutes,  //81-85\n', '        20 minutes,  20 minutes,  20 minutes,  20 minutes,  20 minutes,  //86-90\n', '        10 minutes,  10 minutes,  10 minutes,  10 minutes,  10 minutes,  //91-95\n', '        5 minutes,   5 minutes,   5 minutes,   5 minutes,   5 minutes    //96-100\n', '    ];\n', '\n', '\n', '    function setCooldowns(uint32[100] _cooldowns) onlyOwner public {\n', '        cooldowns = _cooldowns;\n', '    }\n', '\n', '    function getFishParams(uint256 hashSeed1, uint256 hashSeed2, uint256 fishesLength, address coinbase) external pure returns (uint32[4]) {\n', '\n', '        bytes32[5] memory hashSeeds;\n', '        hashSeeds[0] = keccak256(hashSeed1 ^ hashSeed2); //xor both seed from owner and user so no one can cheat\n', '        hashSeeds[1] = keccak256(hashSeeds[0], fishesLength);\n', '        hashSeeds[2] = keccak256(hashSeeds[1], coinbase);\n', '        hashSeeds[3] = keccak256(hashSeeds[2], coinbase, fishesLength);\n', '        hashSeeds[4] = keccak256(hashSeeds[1], hashSeeds[2], hashSeeds[0]);\n', '\n', '        uint24[6] memory seeds = [\n', '            uint24(uint(hashSeeds[3]) % 10e6 + 1), //whale chance\n', '            uint24(uint(hashSeeds[0]) % 420 + 1), //power\n', '            uint24(uint(hashSeeds[1]) % 420 + 1), //agility\n', '            uint24(uint(hashSeeds[2]) % 150 + 1), //speed\n', '            uint24(uint(hashSeeds[4]) % 16 + 1), //whale type\n', '            uint24(uint(hashSeeds[4]) % 5000 + 1) //rarity\n', '        ];\n', '\n', '        uint32[4] memory fishParams;\n', '\n', '        if (seeds[0] == 1000000) {//This is a whale 1:1 000 000 chance\n', '\n', '            if (seeds[4] == 1) {//Orca\n', '                fishParams = [140 + uint8(seeds[1] / 42), 140 + uint8(seeds[2] / 42), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 140) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 140) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            } else if (seeds[4] < 4) {//Blue whale\n', '                fishParams = [130 + uint8(seeds[1] / 42), 130 + uint8(seeds[2] / 42), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 130) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 130) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            } else {//Cachalot\n', '                fishParams = [115 + uint8(seeds[1] / 28), 115 + uint8(seeds[2] / 28), 75 + uint8(seeds[3] / 6), uint32(500000)];\n', '                if(fishParams[0] == 115) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 115) {\n', '                    fishParams[1]++;\n', '                }\n', '                if(fishParams[2] == 75) {\n', '                    fishParams[2]++;\n', '                }\n', '            }\n', '        } else {\n', '            if (seeds[5] == 5000) {//Legendary\n', '                fishParams = [85 + uint8(seeds[1] / 14), 85 + uint8(seeds[2] / 14), uint8(50 + seeds[3] / 3), uint32(1000)];\n', '                if(fishParams[0] == 85) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 85) {\n', '                    fishParams[1]++;\n', '                }\n', '            } else if (seeds[5] > 4899) {//Epic\n', '                fishParams = [50 + uint8(seeds[1] / 12), 50 + uint8(seeds[2] / 12), uint8(25 + seeds[3] / 2), uint32(300)];\n', '                if(fishParams[0] == 50) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 50) {\n', '                    fishParams[1]++;\n', '                }\n', '\n', '            } else if (seeds[5] > 4000) {//Rare\n', '                fishParams = [20 + uint8(seeds[1] / 14), 20 + uint8(seeds[2] / 14), uint8(25 + seeds[3] / 3), uint32(100)];\n', '                if(fishParams[0] == 20) {\n', '                    fishParams[0]++;\n', '                }\n', '                if(fishParams[1] == 20) {\n', '                    fishParams[1]++;\n', '                }\n', '            } else {//Common\n', '                fishParams = [uint8(seeds[1] / 21), uint8(seeds[2] / 21), uint8(seeds[3] / 3), uint32(36)];\n', '                if (fishParams[0] == 0) {\n', '                    fishParams[0] = 1;\n', '                }\n', '                if (fishParams[1] == 0) {\n', '                    fishParams[1] = 1;\n', '                }\n', '                if (fishParams[2] == 0) {\n', '                    fishParams[2] = 1;\n', '                }\n', '            }\n', '        }\n', '\n', '        return fishParams;\n', '    }\n', '\n', '    function getCooldown(uint16 speed) external view returns (uint64){\n', '        return uint64(now + cooldowns[speed - 1]);\n', '    }\n', '\n', '    //Ceiling function for fish generator\n', '    function ceil(uint base, uint divider) internal pure returns (uint) {\n', '        return base / divider + ((base % divider > 0) ? 1 : 0);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Auction contract for any type of erc721 token\n', '/// @author Fishbank\n', '\n', 'contract ERC721 {\n', '\n', '    function implementsERC721() public pure returns (bool);\n', '\n', '    function totalSupply() public view returns (uint256 total);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '\n', '    function approve(address _to, uint256 _tokenId) public;\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool);\n', '\n', '    function transfer(address _to, uint256 _tokenId) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '\n', 'contract ERC721Auction is Beneficiary {\n', '\n', '    struct Auction {\n', '        address seller;\n', '        uint256 tokenId;\n', '        uint64 auctionBegin;\n', '        uint64 auctionEnd;\n', '        uint256 startPrice;\n', '        uint256 endPrice;\n', '    }\n', '\n', '    uint32 public auctionDuration = 7 days;\n', '\n', '    ERC721 public ERC721Contract;\n', '    uint256 public fee = 45000; //in 1 10000th of a percent so 4.5% at the start\n', '    uint256 constant FEE_DIVIDER = 1000000;\n', '    mapping(uint256 => Auction) public auctions;\n', '\n', '    event AuctionWon(uint256 indexed tokenId, address indexed winner, address indexed seller, uint256 price);\n', '\n', '    event AuctionStarted(uint256 indexed tokenId, address indexed seller);\n', '\n', '    event AuctionFinalized(uint256 indexed tokenId, address indexed seller);\n', '\n', '\n', '    function startAuction(uint256 _tokenId, uint256 _startPrice, uint256 _endPrice) external {\n', '        require(ERC721Contract.transferFrom(msg.sender, address(this), _tokenId));\n', '        //Prices must be in range from 0.01 Eth and 10 000 Eth\n', '        require(_startPrice <= 10000 ether && _endPrice <= 10000 ether);\n', '        require(_startPrice >= (1 ether / 100) && _endPrice >= (1 ether / 100));\n', '\n', '        Auction memory auction;\n', '\n', '        auction.seller = msg.sender;\n', '        auction.tokenId = _tokenId;\n', '        auction.auctionBegin = uint64(now);\n', '        auction.auctionEnd = uint64(now + auctionDuration);\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.startPrice = _startPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_tokenId] = auction;\n', '\n', '        AuctionStarted(_tokenId, msg.sender);\n', '    }\n', '\n', '\n', '    function buyAuction(uint256 _tokenId) payable external {\n', '        Auction storage auction = auctions[_tokenId];\n', '\n', '        uint256 price = calculateBid(_tokenId);\n', '        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\n', '\n', '        require(price <= msg.value); //revert if not enough ether send\n', '\n', '        if (price != msg.value) {//send back to much eth\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '\n', '        beneficiary.transfer(totalFee);\n', '\n', '        auction.seller.transfer(price - totalFee);\n', '\n', '        if (!ERC721Contract.transfer(msg.sender, _tokenId)) {\n', '            revert();\n', "            //can't complete transfer if this fails\n", '        }\n', '\n', '        AuctionWon(_tokenId, msg.sender, auction.seller, price);\n', '\n', '        delete auctions[_tokenId];\n', '        //deletes auction\n', '    }\n', '\n', '    function saveToken(uint256 _tokenId) external {\n', '        require(auctions[_tokenId].auctionEnd < now);\n', '        //auction must have ended\n', '        require(ERC721Contract.transfer(auctions[_tokenId].seller, _tokenId));\n', '        //transfer fish back to seller\n', '\n', '        AuctionFinalized(_tokenId, auctions[_tokenId].seller);\n', '\n', '        delete auctions[_tokenId];\n', '        //delete auction\n', '    }\n', '\n', '    function ERC721Auction(address _ERC721Contract) public {\n', '        ERC721Contract = ERC721(_ERC721Contract);\n', '    }\n', '\n', '    function setFee(uint256 _fee) onlyOwner public {\n', '        if (_fee > fee) {\n', '            revert(); //fee can only be set to lower value to prevent attacks by owner\n', '        }\n', '        fee = _fee; // all is well set fee\n', '    }\n', '\n', '    function calculateBid(uint256 _tokenId) public view returns (uint256) {\n', '        Auction storage auction = auctions[_tokenId];\n', '\n', '        if (now >= auction.auctionEnd) {//if auction ended return auction end price\n', '            return auction.endPrice;\n', '        }\n', '        //get hours passed\n', '        uint256 hoursPassed = (now - auction.auctionBegin) / 1 hours;\n', '        uint256 currentPrice;\n', '        //get total hours\n', '        uint16 totalHours = uint16(auctionDuration /1 hours) - 1;\n', '\n', '        if (auction.endPrice > auction.startPrice) {\n', '            currentPrice = auction.startPrice + (hoursPassed * (auction.endPrice - auction.startPrice))/ totalHours;\n', '        } else if(auction.endPrice < auction.startPrice) {\n', '            currentPrice = auction.startPrice - (hoursPassed * (auction.startPrice - auction.endPrice))/ totalHours;\n', '        } else {//start and end are the same\n', '            currentPrice = auction.endPrice;\n', '        }\n', '\n', '        return uint256(currentPrice);\n', '        //return the price at this very moment\n', '    }\n', '\n', '    /// return token if case when need to redeploy auction contract\n', '    function returnToken(uint256 _tokenId) onlyOwner public {\n', '        require(ERC721Contract.transfer(auctions[_tokenId].seller, _tokenId));\n', '        //transfer fish back to seller\n', '\n', '        AuctionFinalized(_tokenId, auctions[_tokenId].seller);\n', '\n', '        delete auctions[_tokenId];\n', '    }\n', '}\n', '\n', '\n', '/// @title Core contract of fishbank\n', '/// @author Fishbank\n', '\n', 'contract Fishbank is ChestsStore {\n', '\n', '    struct Fish {\n', '        address owner;\n', '        uint8 activeBooster;\n', '        uint64 boostedTill;\n', '        uint8 boosterStrength;\n', '        uint24 boosterRaiseValue;\n', '        uint64 weight;\n', '        uint16 power;\n', '        uint16 agility;\n', '        uint16 speed;\n', '        bytes16 color;\n', '        uint64 canFightAgain;\n', '        uint64 canBeAttackedAgain;\n', '    }\n', '\n', '    struct FishingAttempt {\n', '        address fisher;\n', '        uint256 feePaid;\n', '        address affiliate;\n', '        uint256 seed;\n', '        uint64 deadline;//till when does the contract owner have time to resolve;\n', '    }\n', '\n', '    modifier onlyFishOwner(uint256 _tokenId) {\n', '        require(fishes[_tokenId].owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyResolver() {\n', '        require(msg.sender == resolver);\n', '        _;\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(msg.sender == minter);\n', '        _;\n', '    }\n', '\n', '    Fish[] public fishes;\n', '    address public resolver;\n', '    address public auction;\n', '    address public minter;\n', '    bool public implementsERC721 = true;\n', '    string public name = "Fishbank";\n', '    string public symbol = "FISH";\n', '    bytes32[] public randomHashes;\n', '    uint256 public hashesUsed;\n', '    uint256 public aquariumCost = 1 ether / 100 * 3;//fee for fishing starts at 0.03 ether\n', '    uint256 public resolveTime = 30 minutes;//how long does the contract owner have to resolve hashes\n', '    uint16 public weightLostPartLimit = 5;\n', '    FishbankBoosters public boosters;\n', '    FishbankChests public chests;\n', '    FishbankUtils private utils;\n', '\n', '\n', '    mapping(bytes32 => FishingAttempt) public pendingFishing;//attempts that need solving;\n', '\n', '    mapping(uint256 => address) public approved;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => bool) public affiliated;\n', '\n', '    event AquariumFished(\n', '        bytes32 hash,\n', '        address fisher,\n', '        uint256 feePaid\n', '    ); //event broadcated when someone fishes in aqaurium\n', '\n', '    event AquariumResolved(bytes32 hash, address fisher);\n', '\n', '    event Attack(\n', '        uint256 attacker,\n', '        uint256 victim,\n', '        uint256 winner,\n', '        uint64 weight,\n', '        uint256 ap, uint256 vp, uint256 random\n', '    );\n', '\n', '    event BoosterApplied(uint256 tokenId, uint256 boosterId);\n', '\n', '    /// @notice Constructor of the contract. Sets resolver, beneficiary, boosters and chests\n', '    /// @param _boosters the address of the boosters smart contract\n', '    /// @param _chests the address of the chests smart contract\n', '\n', '    function Fishbank(address _boosters, address _chests, address _utils) ChestsStore(_chests) public {\n', '\n', '        resolver = msg.sender;\n', '        beneficiary = msg.sender;\n', '        boosters = FishbankBoosters(_boosters);\n', '        chests = FishbankChests(_chests);\n', '        utils = FishbankUtils(_utils);\n', '    }\n', '\n', '    /// @notice Mints fishes according to params can only be called by the owner\n', '    /// @param _owner array of addresses the fishes should be owned by\n', '    /// @param _weight array of weights for the fishes\n', '    /// @param _power array of power levels for the fishes\n', '    /// @param _agility array of agility levels for the fishes\n', '    /// @param _speed array of speed levels for the fishes\n', '    /// @param _color array of color params for the fishes\n', '\n', '    function mintFish(address[] _owner, uint32[] _weight, uint8[] _power, uint8[] _agility, uint8[] _speed, bytes16[] _color) onlyMinter public {\n', '\n', '        for (uint i = 0; i < _owner.length; i ++) {\n', '            _mintFish(_owner[i], _weight[i], _power[i], _agility[i], _speed[i], _color[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Internal method for minting a fish\n', '    /// @param _owner address of owner for the fish\n', '    /// @param _weight weight param for fish\n', '    /// @param _power power param for fish\n', '    /// @param _agility agility param for the fish\n', '    /// @param _speed speed param for the fish\n', '    /// @param _color color param for the fish\n', '\n', '    function _mintFish(address _owner, uint32 _weight, uint8 _power, uint8 _agility, uint8 _speed, bytes16 _color) internal {\n', '\n', '        fishes.length += 1;\n', '        uint256 newFishId = fishes.length - 1;\n', '\n', '        Fish storage newFish = fishes[newFishId];\n', '\n', '        newFish.owner = _owner;\n', '        newFish.weight = _weight;\n', '        newFish.power = _power;\n', '        newFish.agility = _agility;\n', '        newFish.speed = _speed;\n', '        newFish.color = _color;\n', '\n', '        balances[_owner] ++;\n', '\n', '        Transfer(address(0), _owner, newFishId);\n', '    }\n', '\n', '    function setWeightLostPartLimit(uint8 _weightPart) onlyOwner public {\n', '        weightLostPartLimit = _weightPart;\n', '    }\n', '\n', '    /// @notice Sets the cost for fishing in the aquarium\n', '    /// @param _fee new fee for fishing in wei\n', '    function setAquariumCost(uint256 _fee) onlyOwner public {\n', '        aquariumCost = _fee;\n', '    }\n', '\n', '    /// @notice Sets address that resolves hashes for fishing can only be called by the owner\n', '    /// @param _resolver address of the resolver\n', '    function setResolver(address _resolver) onlyOwner public {\n', '        resolver = _resolver;\n', '    }\n', '\n', '\n', '    /// @notice Sets the address getting the proceedings from fishing in the aquarium\n', '    /// @param _beneficiary address of the new beneficiary\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function setAuction(address _auction) onlyOwner public {\n', '        auction = _auction;\n', '    }\n', '\n', '    function setBoosters(address _boosters) onlyOwner public {\n', '        boosters = FishbankBoosters(_boosters);\n', '    }\n', '\n', '    function setMinter(address _minter) onlyOwner public {\n', '        minter = _minter;\n', '    }\n', '\n', '    function setUtils(address _utils) onlyOwner public {\n', '        utils = FishbankUtils(_utils);\n', '    }\n', '\n', '    function batchFishAquarium(uint256[] _seeds, address _affiliate) payable public {\n', '        require(_seeds.length > 0);\n', '        require(msg.value >= aquariumCost);\n', '        //must send enough ether to cover costs\n', '        require(randomHashes.length > hashesUsed + _seeds.length);\n', '        //there needs to be a hash left\n', '\n', '\n', '\n', '        if (msg.value > aquariumCost * _seeds.length) {\n', '            msg.sender.transfer(msg.value - aquariumCost * _seeds.length);\n', '            //send to much ether back\n', '        }\n', '\n', '        for (uint256 i = 0; i < _seeds.length; i ++) {\n', '            _fishAquarium(_seeds[i]);\n', '        }\n', '\n', '        if(_affiliate != address(0)) {\n', '            pendingFishing[randomHashes[hashesUsed - 1]].affiliate = _affiliate;\n', '        }\n', '    }\n', '\n', '    function _fishAquarium(uint256 _seed) internal {\n', '        //this loop prevents from using the same hash as another fishing attempt if the owner submits the same hash multiple times\n', '        while (pendingFishing[randomHashes[hashesUsed]].fisher != address(0)) {\n', '            hashesUsed++;\n', '            //increase hashesUsed and try next one\n', '        }\n', '\n', '        FishingAttempt storage newAttempt = pendingFishing[randomHashes[hashesUsed]];\n', '\n', '        newAttempt.fisher = msg.sender;\n', '        newAttempt.feePaid = aquariumCost;\n', "        //set the fee paid so it can be returned if the hash doesn't get resolved fast enough\n", '        newAttempt.seed = _seed;\n', '        //sets the seed that gets combined with the random seed of the owner\n', '        newAttempt.deadline = uint64(now + resolveTime);\n', '        //saves deadline after which the fisher can redeem his fishing fee\n', '\n', '        hashesUsed++;\n', '        //increase hashes used so it cannot be used again\n', '\n', '        AquariumFished(randomHashes[hashesUsed - 1], msg.sender, aquariumCost);\n', '        //broadcast event\n', '    }\n', '\n', '    /// @notice Call this to resolve hashes and generate fish/chests\n', '    /// @param _seed seed that corresponds to the hash\n', '    function _resolveAquarium(uint256 _seed) internal {\n', '        bytes32 tempHash = keccak256(_seed);\n', '        FishingAttempt storage tempAttempt = pendingFishing[tempHash];\n', '\n', '        require(tempAttempt.fisher != address(0));\n', '        //attempt must be set so we look if fisher is set\n', '\n', '        if (tempAttempt.affiliate != address(0) && !affiliated[tempAttempt.fisher]) {//if affiliate is set\n', '            chests.mintChest(tempAttempt.affiliate, 1, 0, 0, 0, 0);\n', '            //Chest with one random booster\n', '            affiliated[tempAttempt.fisher] = true;\n', '        }\n', '\n', '        uint32[4] memory fishParams = utils.getFishParams(_seed, tempAttempt.seed, fishes.length, block.coinbase);\n', '\n', '        _mintFish(tempAttempt.fisher, fishParams[3], uint8(fishParams[0]), uint8(fishParams[1]), uint8(fishParams[2]), bytes16(keccak256(_seed ^ tempAttempt.seed)));\n', '\n', '        beneficiary.transfer(tempAttempt.feePaid);\n', '        AquariumResolved(tempHash, tempAttempt.fisher);\n', '        //broadcast event\n', '\n', '        delete pendingFishing[tempHash];\n', '        //delete fishing attempt\n', '    }\n', '\n', '    /// @notice Batch resolve fishing attempts\n', '    /// @param _seeds array of seeds that correspond to hashes that need resolving\n', '    function batchResolveAquarium(uint256[] _seeds) onlyResolver public {\n', '        for (uint256 i = 0; i < _seeds.length; i ++) {\n', '            _resolveAquarium(_seeds[i]);\n', '        }\n', '    }\n', '\n', '\n', '    /// @notice Adds an array of hashes to be used for resolving\n', '    /// @param _hashes array of hashes to add\n', '    function addHash(bytes32[] _hashes) onlyResolver public {\n', '        for (uint i = 0; i < _hashes.length; i ++) {\n', '            randomHashes.push(_hashes[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Call this function to attack another fish\n', '    /// @param _attacker ID of fish that is attacking\n', '    /// @param _victim ID of fish to attack\n', '    function attack(uint256 _attacker, uint256 _victim) onlyFishOwner(_attacker) public {\n', '\n', '        Fish memory attacker = fishes[_attacker];\n', '        Fish memory victim = fishes[_victim];\n', '\n', '        //check if attacker is sleeping\n', '        if (attacker.activeBooster == 2 && attacker.boostedTill > now) {//if your fish is sleeping auto awake it\n', '            fishes[_attacker].activeBooster = 0;\n', '            attacker.boostedTill = uint64(now);\n', '            //set booster to invalid one so it has no effect\n', '        }\n', '\n', '        //check if victim has active sleeping booster\n', '        require(!((victim.activeBooster == 2) && victim.boostedTill >= now));\n', '        //cannot attack a sleeping fish\n', '        require(now >= attacker.canFightAgain);\n', '        //check if attacking fish is cooled down\n', '        require(now >= victim.canBeAttackedAgain);\n', '        //check if victim fish can be attacked again\n', '\n', '\n', '        if (msg.sender == victim.owner) {\n', '            uint64 weight = attacker.weight < victim.weight ? attacker.weight : victim.weight;\n', '            fishes[_attacker].weight += weight;\n', '            fishes[_victim].weight -= weight;\n', '            fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed));\n', '\n', '            if (fishes[_victim].weight == 0) {\n', '                _transfer(msg.sender, address(0), _victim);\n', '                balances[fishes[_victim].owner] --;\n', '                //burn token\n', '            } else {\n', '                fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours);\n', '                //set victim cooldown 1 hour\n', '            }\n', '\n', '            Attack(_attacker, _victim, _attacker, weight, 0, 0, 0);\n', '            return;\n', '        }\n', '\n', '        if (victim.weight < 2 || attacker.weight < 2) {\n', '            revert();\n', '            //revert if one of the fish is below fighting weight\n', '        }\n', '\n', '        uint256 AP = getFightingAmounts(attacker, true);\n', '        // get attacker power\n', '        uint256 VP = getFightingAmounts(victim, false);\n', '        // get victim power\n', '\n', '        bytes32 randomHash = keccak256(block.coinbase, block.blockhash(block.number - 1), fishes.length);\n', '\n', '        uint256 max = AP > VP ? AP : VP;\n', '        uint256 attackRange = max * 2;\n', '        uint256 random = uint256(randomHash) % attackRange + 1;\n', '\n', '        uint64 weightLost;\n', '\n', '        if (random <= (max + AP - VP)) {\n', '            weightLost = _handleWin(_attacker, _victim);\n', '            Attack(_attacker, _victim, _attacker, weightLost, AP, VP, random);\n', '        } else {\n', '            weightLost = _handleWin(_victim, _attacker);\n', '            Attack(_attacker, _victim, _victim, weightLost, AP, VP, random);\n', '            //broadcast event\n', '        }\n', '\n', '        fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed));\n', '        fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours);\n', '        //set victim cooldown 1 hour\n', '    }\n', '\n', '    /// @notice Handles lost gained weight after fight\n', '    /// @param _winner the winner of the fight\n', '    /// @param _loser the loser of the fight\n', '    function _handleWin(uint256 _winner, uint256 _loser) internal returns (uint64) {\n', '        Fish storage winner = fishes[_winner];\n', '        Fish storage loser = fishes[_loser];\n', '\n', '        uint64 fullWeightLost = loser.weight / sqrt(winner.weight);\n', '        uint64 maxWeightLost = loser.weight / weightLostPartLimit;\n', '\n', '        uint64 weightLost = maxWeightLost < fullWeightLost ? maxWeightLost : fullWeightLost;\n', '\n', '        if (weightLost < 1) {\n', '            weightLost = 1;\n', '            // Minimum 1\n', '        }\n', '\n', '        winner.weight += weightLost;\n', '        loser.weight -= weightLost;\n', '\n', '        return weightLost;\n', '    }\n', '\n', '    /// @notice get attack and defence from fish\n', '    /// @param _fish is Fish token\n', '    /// @param _is_attacker true if fish is attacker otherwise false\n', '    function getFightingAmounts(Fish _fish, bool _is_attacker) internal view returns (uint256){\n', '        return (getFishPower(_fish) * (_is_attacker ? 60 : 40) + getFishAgility(_fish) * (_is_attacker ? 40 : 60)) * _fish.weight;\n', '    }\n', '\n', '    /// @notice Apply a booster to a fish\n', '    /// @param _tokenId the fish the booster should be applied to\n', '    /// @param _booster the Id of the booster the token should be applied to\n', '    function applyBooster(uint256 _tokenId, uint256 _booster) onlyFishOwner(_tokenId) public {\n', '        require(msg.sender == boosters.ownerOf(_booster));\n', '        //only owner can do this\n', '        require(boosters.getBoosterAmount(_booster) >= 1);\n', '        Fish storage tempFish = fishes[_tokenId];\n', '        uint8 boosterType = uint8(boosters.getBoosterType(_booster));\n', '\n', '        if (boosterType == 1 || boosterType == 2 || boosterType == 3) {//if booster is attack or agility or sleep\n', '            tempFish.boosterStrength = boosters.getBoosterStrength(_booster);\n', '            tempFish.activeBooster = boosterType;\n', '            tempFish.boostedTill = boosters.getBoosterDuration(_booster) * boosters.getBoosterAmount(_booster) + uint64(now);\n', '            tempFish.boosterRaiseValue = boosters.getBoosterRaiseValue(_booster);\n', '        }\n', '        else if (boosterType == 4) {//watch booster\n', '            require(tempFish.boostedTill > uint64(now));\n', '            //revert on using watch on booster that has passed;\n', '            tempFish.boosterStrength = boosters.getBoosterStrength(_booster);\n', '            tempFish.boostedTill += boosters.getBoosterDuration(_booster) * boosters.getBoosterAmount(_booster);\n', '            //add time to booster\n', '        }\n', '        else if (boosterType == 5) {//Instant attack\n', '            require(boosters.getBoosterAmount(_booster) == 1);\n', '            //Can apply only one instant attack booster\n', '            tempFish.canFightAgain = 0;\n', '        }\n', '\n', '        require(boosters.transferFrom(msg.sender, address(0), _booster));\n', '        //burn booster\n', '\n', '        BoosterApplied(_tokenId, _booster);\n', '    }\n', '\n', '    /// @notice square root function used for weight gain/loss\n', '    /// @param x uint64 to get square root from\n', '    function sqrt(uint64 x) pure internal returns (uint64 y) {\n', '        uint64 z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    //utlitiy function for easy testing can be removed later\n', '    function doKeccak256(uint256 _input) pure public returns (bytes32) {\n', '        return keccak256(_input);\n', '    }\n', '\n', '    function getFishPower(Fish _fish) internal view returns (uint24 power) {\n', '        power = _fish.power;\n', '        if (_fish.activeBooster == 1 && _fish.boostedTill > now) {// check if booster active\n', '            uint24 boosterPower = (10 * _fish.boosterStrength + _fish.boosterRaiseValue + 100) * power / 100 - power;\n', '            if (boosterPower < 1 && _fish.boosterStrength == 1) {\n', '                power += 1;\n', '            } else if (boosterPower < 3 && _fish.boosterStrength == 2) {\n', '                power += 3;\n', '            } else if (boosterPower < 5 && _fish.boosterStrength == 3) {\n', '                power += 5;\n', '            } else {\n', '                power = boosterPower + power;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getFishAgility(Fish _fish) internal view returns (uint24 agility) {\n', '        agility = _fish.agility;\n', '        if (_fish.activeBooster == 3 && _fish.boostedTill > now) {// check if booster active\n', '            uint24 boosterPower = (10 * _fish.boosterStrength + _fish.boosterRaiseValue + 100) * agility / 100 - agility;\n', '            if (boosterPower < 1 && _fish.boosterStrength == 1) {\n', '                agility += 1;\n', '            } else if (boosterPower < 3 && _fish.boosterStrength == 2) {\n', '                agility += 3;\n', '            } else if (boosterPower < 5 && _fish.boosterStrength == 3) {\n', '                agility += 5;\n', '            } else {\n', '                agility = boosterPower + agility;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    //ERC721 functionality\n', "    //could split this to a different contract but doesn't make it easier to read\n", '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        total = fishes.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner){\n', '        owner = fishes[_tokenId].owner;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        require(fishes[_tokenId].owner == _from);\n', '        //can only transfer if previous owner equals from\n', '        fishes[_tokenId].owner = _to;\n', '        approved[_tokenId] = address(0);\n', '        //reset approved of fish on every transfer\n', '        balances[_from] -= 1;\n', '        //underflow can only happen on 0x\n', '        balances[_to] += 1;\n', '        //overflows only with very very large amounts of fish\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public\n', '    onlyFishOwner(_tokenId) //check if msg.sender is the owner of this fish\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '        //after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    onlyFishOwner(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) {\n', '        require(approved[_tokenId] == msg.sender || msg.sender == auction);\n', '        Fish storage fish = fishes[_tokenId];\n', '\n', '        if (msg.sender == auction) {\n', '            fish.activeBooster = 2;\n', '            //Freeze for auction\n', '            fish.boostedTill = uint64(now + 7 days);\n', '            fish.boosterStrength = 1;\n', '        }\n', '        //require msg.sender to be approved for this token\n', '        _transfer(_from, _to, _tokenId);\n', '        //handles event, balances and approval reset\n', '        return true;\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(approved[_tokenId] == msg.sender);\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '}']
