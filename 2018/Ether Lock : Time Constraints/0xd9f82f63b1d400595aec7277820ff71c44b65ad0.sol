['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function getOwner() returns(address){\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' * Базовый контракт, который поддерживает остановку продаж\n', ' */\n', '\n', 'contract Haltable is Ownable {\n', '    bool public halted;\n', '\n', '    modifier stopInEmergency {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    /* Модификатор, который вызывается в потомках */\n', '    modifier onlyInEmergency {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '    /* Вызов функции прервет продажи, вызывать может только владелец */\n', '    function halt() external onlyOwner {\n', '        halted = true;\n', '    }\n', '\n', '    /* Вызов возвращает режим продаж */\n', '    function unhalt() external onlyOwner onlyInEmergency {\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * Различные валидаторы\n', ' */\n', '\n', 'contract ValidationUtil {\n', '    function requireNotEmptyAddress(address value) internal{\n', '        require(isAddressValid(value));\n', '    }\n', '\n', '    function isAddressValid(address value) internal constant returns (bool result){\n', '        return value != 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  \n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until \n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue) \n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue) \n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Шаблон для токена, который можно сжечь\n', '*/\n', 'contract BurnableToken is StandardToken, Ownable, ValidationUtil {\n', '    using SafeMath for uint;\n', '\n', '    address public tokenOwnerBurner;\n', '\n', '    /** Событие, сколько токенов мы сожгли */\n', '    event Burned(address burner, uint burnedAmount);\n', '\n', '    function setOwnerBurner(address _tokenOwnerBurner) public onlyOwner invalidOwnerBurner{\n', '        // Проверка, что адрес не пустой\n', '        requireNotEmptyAddress(_tokenOwnerBurner);\n', '\n', '        tokenOwnerBurner = _tokenOwnerBurner;\n', '    }\n', '\n', '    /**\n', '     * Сжигаем токены на балансе владельца токенов, вызвать может только tokenOwnerBurner\n', '     */\n', '    function burnOwnerTokens(uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\n', '        burnTokens(tokenOwnerBurner, burnAmount);\n', '    }\n', '\n', '    /**\n', '     * Сжигаем токены на балансе адреса токенов, вызвать может только tokenOwnerBurner\n', '     */\n', '    function burnTokens(address _address, uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\n', '        balances[_address] = balances[_address].sub(burnAmount);\n', '\n', '        // Вызываем событие\n', '        Burned(_address, burnAmount);\n', '    }\n', '\n', '    /**\n', '     * Сжигаем все токены на балансе владельца\n', '     */\n', '    function burnAllOwnerTokens() public onlyTokenOwnerBurner validOwnerBurner{\n', '        uint burnAmount = balances[tokenOwnerBurner];\n', '        burnTokens(tokenOwnerBurner, burnAmount);\n', '    }\n', '\n', '    /** Модификаторы\n', '     */\n', '    modifier onlyTokenOwnerBurner() {\n', '        require(msg.sender == tokenOwnerBurner);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier validOwnerBurner() {\n', '        // Проверка, что адрес не пустой\n', '        requireNotEmptyAddress(tokenOwnerBurner);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier invalidOwnerBurner() {\n', '        // Проверка, что адрес не пустой\n', '        require(!isAddressValid(tokenOwnerBurner));\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * Токен продаж\n', ' *\n', ' * ERC-20 токен, для ICO\n', ' *\n', ' */\n', '\n', 'contract CrowdsaleToken is StandardToken, Ownable {\n', '\n', '    /* Описание см. в конструкторе */\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint public decimals;\n', '\n', '    address public mintAgent;\n', '\n', '    /** Событие обновления токена (имя и символ) */\n', '    event UpdatedTokenInformation(string newName, string newSymbol);\n', '\n', '    /** Событие выпуска токенов */\n', '    event TokenMinted(uint amount, address toAddress);\n', '\n', '    /**\n', '     * Конструктор\n', '     *\n', '     * Токен должен быть создан только владельцем через кошелек (либо с мультиподписью, либо без нее)\n', '     *\n', '     * @param _name - имя токена\n', '     * @param _symbol - символ токена\n', '     * @param _decimals - кол-во знаков после запятой\n', '     */\n', '    function CrowdsaleToken(string _name, string _symbol, uint _decimals) {\n', '        owner = msg.sender;\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '     * Владелец должен вызвать эту функцию, чтобы выпустить токены на адрес\n', '     */\n', '    function mintToAddress(uint amount, address toAddress) onlyMintAgent{\n', '        // перевод токенов на аккаунт\n', '        balances[toAddress] = amount;\n', '\n', '        // вызываем событие\n', '        TokenMinted(amount, toAddress);\n', '    }\n', '\n', '    /**\n', '     * Владелец может обновить инфу по токену\n', '     */\n', '    function setTokenInformation(string _name, string _symbol) onlyOwner {\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        // Вызываем событие\n', '        UpdatedTokenInformation(name, symbol);\n', '    }\n', '\n', '    /**\n', '     * Только владелец может обновить агента для создания токенов\n', '     */\n', '    function setMintAgent(address _address) onlyOwner {\n', '        mintAgent =  _address;\n', '    }\n', '\n', '    modifier onlyMintAgent(){\n', '        require(msg.sender == mintAgent);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * Шаблон для продаж токена, который можно сжечь\n', ' *\n', ' */\n', 'contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken {\n', '\n', '    function BurnableCrowdsaleToken(string _name, string _symbol, uint _decimals) CrowdsaleToken(_name, _symbol, _decimals) BurnableToken(){\n', '\n', '    }\n', '}\n', '\n', '/**\n', ' * Базовый контракт для продаж\n', ' *\n', ' * Содержит\n', ' * - Дата начала и конца\n', ' */\n', '\n', '/* Продажи могут быть остановлены в любой момент по вызову halt() */\n', '\n', 'contract AllocatedCappedCrowdsale is Haltable, ValidationUtil {\n', '    using SafeMath for uint;\n', '\n', '    // Кол-во токенов для распределения\n', '    uint public advisorsTokenAmount = 8040817;\n', '    uint public supportTokenAmount = 3446064;\n', '    uint public marketingTokenAmount = 3446064;\n', '    uint public teamTokenAmount = 45947521;\n', '\n', '    uint public teamTokensIssueDate;\n', '\n', '    /* Токен, который продаем */\n', '    BurnableCrowdsaleToken public token;\n', '\n', '    /* Адрес, куда будут переведена собранная сумма, в случае успеха */\n', '    address public destinationMultisigWallet;\n', '\n', '    /* Первая стадия в формате UNIX timestamp */\n', '    uint public firstStageStartsAt;\n', '    /* Конец продаж в формате UNIX timestamp */\n', '    uint public firstStageEndsAt;\n', '\n', '    /* Вторая стадия в формате UNIX timestamp */\n', '    uint public secondStageStartsAt;\n', '    /* Конец продаж в формате UNIX timestamp */\n', '    uint public secondStageEndsAt;\n', '\n', '    /* Минимальная кепка для первой стадии в центах */\n', '    uint public softCapFundingGoalInCents = 392000000;\n', '\n', '    /* Минимальная кепка для второй стадии в центах */\n', '    uint public hardCapFundingGoalInCents = 985000000;\n', '\n', '    /* Сколько всего в wei мы получили 10^18 wei = 1 ether */\n', '    uint public weiRaised;\n', '\n', '    /* Сколько всего собрали в ценах на первой стадии */\n', '    uint public firstStageRaisedInWei;\n', '\n', '    /* Сколько всего собрали в ценах на второй стадии */\n', '    uint public secondStageRaisedInWei;\n', '\n', '    /* Кол-во уникальных адресов, которые у наc получили токены */\n', '    uint public investorCount;\n', '\n', '    /*  Сколько wei отдали инвесторам на refund&#39;е в wei */\n', '    uint public weiRefunded;\n', '\n', '    /*  Сколько токенов продали всего */\n', '    uint public tokensSold;\n', '\n', '    /* Флаг того, что сработал финализатор первой стадии */\n', '    bool public isFirstStageFinalized;\n', '\n', '    /* Флаг того, что сработал финализатор второй стадии */\n', '    bool public isSecondStageFinalized;\n', '\n', '    /* Флаг нормального завершнения продаж */\n', '    bool public isSuccessOver;\n', '\n', '    /* Флаг того, что начался процесс возврата */\n', '    bool public isRefundingEnabled;\n', '\n', '    /*  Сколько сейчас стоит 1 eth в центах, округленная до целых */\n', '    uint public currentEtherRateInCents;\n', '\n', '    /* Текущая стоимость токена в центах */\n', '    uint public oneTokenInCents = 7;\n', '\n', '    /* Выпущены ли токены для первой стадии */\n', '    bool public isFirstStageTokensMinted;\n', '\n', '    /* Выпущены ли токены для второй стадии */\n', '    bool public isSecondStageTokensMinted;\n', '\n', '    /* Кол-во токенов для первой стадии */\n', '    uint public firstStageTotalSupply = 112000000;\n', '\n', '    /* Кол-во токенов проданных на первой стадии*/\n', '    uint public firstStageTokensSold;\n', '\n', '    /* Кол-во токенов для второй стадии */\n', '    uint public secondStageTotalSupply = 229737610;\n', '\n', '    /* Кол-во токенов проданных на второй стадии*/\n', '    uint public secondStageTokensSold;\n', '\n', '    /* Кол-во токенов, которые находятся в резерве и не продаются, после успеха, они распределяются в соотвествии с Token Policy на второй стадии*/\n', '    uint public secondStageReserve = 60880466;\n', '\n', '    /* Кол-во токенов предназначенных для продажи, на второй стадии*/\n', '    uint public secondStageTokensForSale;\n', '\n', '    /* Мапа адрес инвестора - кол-во выданных токенов */\n', '    mapping (address => uint) public tokenAmountOf;\n', '\n', '    /* Мапа, адрес инвестора - кол-во эфира */\n', '    mapping (address => uint) public investedAmountOf;\n', '\n', '    /* Адреса, куда будут распределены токены */\n', '    address public advisorsAccount;\n', '    address public marketingAccount;\n', '    address public supportAccount;\n', '    address public teamAccount;\n', '\n', '    /** Возможные состояния\n', '     *\n', '     * - Prefunding: подготовка, залили контракт, но текущая дата меньше даты первой стадии\n', '     * - FirstStageFunding: Продажи первой стадии\n', '     * - FirstStageEnd: Окончены продажи первой стадии, но еще не вызван финализатор первой стадии\n', '     * - SecondStageFunding: Продажи второго этапа\n', '     * - SecondStageEnd: Окончены продажи второй стадии, но не вызван финализатор второй сдадии\n', '     * - Success: Успешно закрыли ICO\n', '     * - Failure: Не собрали Soft Cap\n', '     * - Refunding: Возвращаем собранный эфир\n', '     */\n', '    enum State{PreFunding, FirstStageFunding, FirstStageEnd, SecondStageFunding, SecondStageEnd, Success, Failure, Refunding}\n', '\n', '    // Событие покупки токена\n', '    event Invested(address indexed investor, uint weiAmount, uint tokenAmount, uint centAmount, uint txId);\n', '\n', '    // Событие изменения курса eth\n', '    event ExchangeRateChanged(uint oldExchangeRate, uint newExchangeRate);\n', '\n', '    // Событие изменения даты окончания первой стадии\n', '    event FirstStageStartsAtChanged(uint newFirstStageStartsAt);\n', '    event FirstStageEndsAtChanged(uint newFirstStageEndsAt);\n', '\n', '    // Событие изменения даты окончания второй стадии\n', '    event SecondStageStartsAtChanged(uint newSecondStageStartsAt);\n', '    event SecondStageEndsAtChanged(uint newSecondStageEndsAt);\n', '\n', '    // Событие изменения Soft Cap&#39;а\n', '    event SoftCapChanged(uint newGoal);\n', '\n', '    // Событие изменения Hard Cap&#39;а\n', '    event HardCapChanged(uint newGoal);\n', '\n', '    // Конструктор\n', '    function AllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) {\n', '        requireNotEmptyAddress(_destinationMultisigWallet);\n', '        // Проверка, что даты установлены\n', '        require(_firstStageStartsAt != 0);\n', '        require(_firstStageEndsAt != 0);\n', '\n', '        require(_firstStageStartsAt < _firstStageEndsAt);\n', '\n', '        require(_secondStageStartsAt != 0);\n', '        require(_secondStageEndsAt != 0);\n', '\n', '        require(_secondStageStartsAt < _secondStageEndsAt);\n', '        require(_teamTokensIssueDate != 0);\n', '\n', '        // Токен, который поддерживает сжигание\n', '        token = BurnableCrowdsaleToken(_token);\n', '\n', '        destinationMultisigWallet = _destinationMultisigWallet;\n', '\n', '        firstStageStartsAt = _firstStageStartsAt;\n', '        firstStageEndsAt = _firstStageEndsAt;\n', '        secondStageStartsAt = _secondStageStartsAt;\n', '        secondStageEndsAt = _secondStageEndsAt;\n', '\n', '        // Адреса кошельков для адвизоров, маркетинга, команды\n', '        advisorsAccount = _advisorsAccount;\n', '        marketingAccount = _marketingAccount;\n', '        supportAccount = _supportAccount;\n', '        teamAccount = _teamAccount;\n', '\n', '        teamTokensIssueDate = _teamTokensIssueDate;\n', '\n', '        currentEtherRateInCents = _currentEtherRateInCents;\n', '\n', '        secondStageTokensForSale = secondStageTotalSupply.sub(secondStageReserve);\n', '    }\n', '\n', '    /**\n', '     * Функция, инициирующая нужное кол-во токенов для первого этапа продаж, вызвать можно только 1 раз\n', '     */\n', '    function mintTokensForFirstStage() public onlyOwner {\n', '        // Если уже создали токены для первой стадии, делаем откат\n', '        require(!isFirstStageTokensMinted);\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        token.mintToAddress(firstStageTotalSupply.mul(tokenMultiplier), address(this));\n', '\n', '        isFirstStageTokensMinted = true;\n', '    }\n', '\n', '    /**\n', '     * Функция, инициирующая нужное кол-во токенов для второго этапа продаж, только в случае, если это еще не сделано и были созданы токены для первой стадии\n', '     */\n', '    function mintTokensForSecondStage() private {\n', '        // Если уже создали токены для второй стадии, делаем откат\n', '        require(!isSecondStageTokensMinted);\n', '\n', '        require(isFirstStageTokensMinted);\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        token.mintToAddress(secondStageTotalSupply.mul(tokenMultiplier), address(this));\n', '\n', '        isSecondStageTokensMinted = true;\n', '    }\n', '\n', '    /**\n', '     * Функция возвращающая текущую стоимость 1 токена в wei\n', '     */\n', '    function getOneTokenInWei() external constant returns(uint){\n', '        return oneTokenInCents.mul(10 ** 18).div(currentEtherRateInCents);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая переводит wei в центы по текущему курсу\n', '     */\n', '    function getWeiInCents(uint value) public constant returns(uint){\n', '        return currentEtherRateInCents.mul(value).div(10 ** 18);\n', '    }\n', '\n', '    /**\n', '     * Перевод токенов покупателю\n', '     */\n', '    function assignTokens(address receiver, uint tokenAmount) private {\n', '        // Если перевод не удался, откатываем транзакцию\n', '        if (!token.transfer(receiver, tokenAmount)) revert();\n', '    }\n', '\n', '    /**\n', '     * Fallback функция вызывающаяся при переводе эфира\n', '     */\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция перевода эфира и выдачи токенов\n', '     */\n', '    function internalAssignTokens(address receiver, uint tokenAmount, uint weiAmount, uint centAmount, uint txId) internal {\n', '        // Переводим токены инвестору\n', '        assignTokens(receiver, tokenAmount);\n', '\n', '        // Вызываем событие\n', '        Invested(receiver, weiAmount, tokenAmount, centAmount, txId);\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Инвестиции\n', '     * Должен быть включен режим продаж первой или второй стадии и не собран Hard Cap\n', '     * @param receiver - эфирный адрес получателя\n', '     * @param txId - id внешней транзакции\n', '     */\n', '    function internalInvest(address receiver, uint weiAmount, uint txId) stopInEmergency inFirstOrSecondFundingState notHardCapReached internal {\n', '        State currentState = getState();\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        uint amountInCents = getWeiInCents(weiAmount);\n', '\n', '        // Очень внимательно нужно менять значения, т.к. для второй стадии 1000%, чтобы учесть дробные значения\n', '        uint bonusPercentage = 0;\n', '        uint bonusStateMultiplier = 1;\n', '\n', '        // если запущена первая стадия, в конструкторе уже выпустили нужное кол-во токенов для первой стадии\n', '        if (currentState == State.FirstStageFunding){\n', '            // меньше 25000$ не принимаем\n', '            require(amountInCents >= 2500000);\n', '\n', '            // [25000$ - 50000$) - 50% бонуса\n', '            if (amountInCents >= 2500000 && amountInCents < 5000000){\n', '                bonusPercentage = 50;\n', '            // [50000$ - 100000$) - 75% бонуса\n', '            }else if(amountInCents >= 5000000 && amountInCents < 10000000){\n', '                bonusPercentage = 75;\n', '            // >= 100000$ - 100% бонуса\n', '            }else if(amountInCents >= 10000000){\n', '                bonusPercentage = 100;\n', '            }else{\n', '                revert();\n', '            }\n', '\n', '        // если запущена вторая стадия\n', '        } else if(currentState == State.SecondStageFunding){\n', '            // Процент проданных токенов, будем считать с множителем 10, т.к. есть дробные значения\n', '            bonusStateMultiplier = 10;\n', '\n', '            // Кол-во проданных токенов нужно считать от значения тех токенов, которые предназначены для продаж, т.е. secondStageTokensForSale\n', '            uint tokensSoldPercentage = secondStageTokensSold.mul(100).div(secondStageTokensForSale.mul(tokenMultiplier));\n', '\n', '            // меньше 7$ не принимаем\n', '            require(amountInCents >= 700);\n', '\n', '            // (0% - 10%) - 20% бонуса\n', '            if (tokensSoldPercentage >= 0 && tokensSoldPercentage < 10){\n', '                bonusPercentage = 200;\n', '            // [10% - 20%) - 17.5% бонуса\n', '            }else if (tokensSoldPercentage >= 10 && tokensSoldPercentage < 20){\n', '                bonusPercentage = 175;\n', '            // [20% - 30%) - 15% бонуса\n', '            }else if (tokensSoldPercentage >= 20 && tokensSoldPercentage < 30){\n', '                bonusPercentage = 150;\n', '            // [30% - 40%) - 12.5% бонуса\n', '            }else if (tokensSoldPercentage >= 30 && tokensSoldPercentage < 40){\n', '                bonusPercentage = 125;\n', '            // [40% - 50%) - 10% бонуса\n', '            }else if (tokensSoldPercentage >= 40 && tokensSoldPercentage < 50){\n', '                bonusPercentage = 100;\n', '            // [50% - 60%) - 8% бонуса\n', '            }else if (tokensSoldPercentage >= 50 && tokensSoldPercentage < 60){\n', '                bonusPercentage = 80;\n', '            // [60% - 70%) - 6% бонуса\n', '            }else if (tokensSoldPercentage >= 60 && tokensSoldPercentage < 70){\n', '                bonusPercentage = 60;\n', '            // [70% - 80%) - 4% бонуса\n', '            }else if (tokensSoldPercentage >= 70 && tokensSoldPercentage < 80){\n', '                bonusPercentage = 40;\n', '            // [80% - 90%) - 2% бонуса\n', '            }else if (tokensSoldPercentage >= 80 && tokensSoldPercentage < 90){\n', '                bonusPercentage = 20;\n', '            // >= 90% - 0% бонуса\n', '            }else if (tokensSoldPercentage >= 90){\n', '                bonusPercentage = 0;\n', '            }else{\n', '                revert();\n', '            }\n', '        } else revert();\n', '\n', '        // сколько токенов нужно выдать без бонуса\n', '        uint resultValue = amountInCents.mul(tokenMultiplier).div(oneTokenInCents);\n', '\n', '        // с учетом бонуса\n', '        uint tokenAmount = resultValue.mul(bonusStateMultiplier.mul(100).add(bonusPercentage)).div(bonusStateMultiplier.mul(100));\n', '\n', '        // краевой случай, когда запросили больше, чем можем выдать\n', '        uint tokensLeft = getTokensLeftForSale(currentState);\n', '        if (tokenAmount > tokensLeft){\n', '            tokenAmount = tokensLeft;\n', '        }\n', '\n', '        // Кол-во 0?, делаем откат\n', '        require(tokenAmount != 0);\n', '\n', '        // Новый инвестор?\n', '        if (investedAmountOf[receiver] == 0) {\n', '            investorCount++;\n', '        }\n', '\n', '        // Кидаем токены инвестору\n', '        internalAssignTokens(receiver, tokenAmount, weiAmount, amountInCents, txId);\n', '\n', '        // Обновляем статистику\n', '        updateStat(currentState, receiver, tokenAmount, weiAmount);\n', '\n', '        // Шлем на кошелёк эфир\n', '        // Функция - прослойка для возможности переопределения в дочерних классах\n', '        // Если это внешний вызов, то депозит не кладем\n', '        if (txId == 0){\n', '            internalDeposit(destinationMultisigWallet, weiAmount);\n', '        }\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция перевода эфира на контракт, функция доступна для переопределения в дочерних классах, но не публична\n', '     */\n', '    function internalDeposit(address receiver, uint weiAmount) internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для возврата средств, функция доступна для переопределения в дочерних классах, но не публична\n', '     */\n', '    function internalRefund(address receiver, uint weiAmount) internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для включения режима возврата средств\n', '     */\n', '    function internalEnableRefunds() internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Спец. функция, которая позволяет продавать токены вне ценовой политики, доступка только владельцу\n', '     * Результаты пишутся в общую статистику, без разделения на стадии\n', '     * @param receiver - получатель\n', '     * @param tokenAmount - общее кол-во токенов c decimals!!!\n', '     * @param weiAmount - цена в wei\n', '     */\n', '    function internalPreallocate(State currentState, address receiver, uint tokenAmount, uint weiAmount) internal {\n', '        // Cколько токенов осталось для продажи? Больше этого значения выдать не можем!\n', '        require(getTokensLeftForSale(currentState) >= tokenAmount);\n', '\n', '        // Может быть 0, выдаем токены бесплатно\n', '        internalAssignTokens(receiver, tokenAmount, weiAmount, getWeiInCents(weiAmount), 0);\n', '\n', '        // Обновляем статистику\n', '        updateStat(currentState, receiver, tokenAmount, weiAmount);\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для действий, в случае успеха\n', '     */\n', '    function internalSuccessOver() internal {\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Функция, которая переопределяется в надледниках и выполняется после установки адреса аккаунта для перевода средств\n', '     */\n', '    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\n', '    }\n', '\n', '    /**\n', '     * Обновляем статистику для первой или второй стадии\n', '     */\n', '    function updateStat(State currentState, address receiver, uint tokenAmount, uint weiAmount) private{\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokenAmount);\n', '\n', '        // Если это первая стадия\n', '        if (currentState == State.FirstStageFunding){\n', '            // Увеличиваем стату\n', '            firstStageRaisedInWei = firstStageRaisedInWei.add(weiAmount);\n', '            firstStageTokensSold = firstStageTokensSold.add(tokenAmount);\n', '        }\n', '\n', '        // Если это вторая стадия\n', '        if (currentState == State.SecondStageFunding){\n', '            // Увеличиваем стату\n', '            secondStageRaisedInWei = secondStageRaisedInWei.add(weiAmount);\n', '            secondStageTokensSold = secondStageTokensSold.add(tokenAmount);\n', '        }\n', '\n', '        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая позволяет менять адрес аккаунта, куда будут переведены средства, в случае успеха,\n', '     * менять может только владелец и только в случае если продажи еще не завершены успехом\n', '     */\n', '    function setDestinationMultisigWallet(address destinationAddress) public onlyOwner canSetDestinationMultisigWallet{\n', '        destinationMultisigWallet = destinationAddress;\n', '\n', '        internalSetDestinationMultisigWallet(destinationAddress);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая задает текущий курс eth в центах\n', '     */\n', '    function changeCurrentEtherRateInCents(uint value) public onlyOwner {\n', '        // Если случайно задали 0, не откатываем транзакцию\n', '        require(value > 0);\n', '\n', '        currentEtherRateInCents = value;\n', '\n', '        ExchangeRateChanged(currentEtherRateInCents, value);\n', '    }\n', '\n', '    /**\n', '    * Разделил на 2 метода, чтобы не запутаться при вызове\n', '    * Эти функции нужны в 2-х случаях: немного не собрали до Cap&#39;а, сами докидываем необходимую сумму, есть приватные инвесторы, для которых существуют особые условия\n', '    */\n', '\n', '    /* Для первой стадии */\n', '    function preallocateFirstStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isFirstStageFundingOrEnd {\n', '        internalPreallocate(State.FirstStageFunding, receiver, tokenAmount, weiAmount);\n', '    }\n', '\n', '    /* Для второй стадии, выдать можем не больше остатка для продажи */\n', '    function preallocateSecondStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isSecondStageFundingOrEnd {\n', '        internalPreallocate(State.SecondStageFunding, receiver, tokenAmount, weiAmount);\n', '    }\n', '\n', '    /* В случае успеха, заблокированные токены для команды могут быть востребованы только если наступила определенная дата */\n', '    function issueTeamTokens() public onlyOwner inState(State.Success) {\n', '        require(block.timestamp >= teamTokensIssueDate);\n', '\n', '        uint teamTokenTransferAmount = teamTokenAmount.mul(10 ** token.decimals());\n', '\n', '        if (!token.transfer(teamAccount, teamTokenTransferAmount)) revert();\n', '    }\n', '\n', '    /**\n', '    * Включает режим возвратов, только в случае если режим возврата еще не установлен и продажи не завершены успехом\n', '    * Вызвать можно только 1 раз\n', '    */\n', '    function enableRefunds() public onlyOwner canEnableRefunds{\n', '        isRefundingEnabled = true;\n', '\n', '        // Сжигаем остатки на балансе текущего контракта\n', '        token.burnAllOwnerTokens();\n', '\n', '        internalEnableRefunds();\n', '    }\n', '\n', '    /**\n', '     * Покупка токенов, кидаем токены на адрес отправителя\n', '     */\n', '    function buy() public payable {\n', '        internalInvest(msg.sender, msg.value, 0);\n', '    }\n', '\n', '    /**\n', '     * Покупка токенов через внешние системы\n', '     */\n', '    function externalBuy(address buyerAddress, uint weiAmount, uint txId) external onlyOwner {\n', '        require(txId != 0);\n', '\n', '        internalInvest(buyerAddress, weiAmount, txId);\n', '    }\n', '\n', '    /**\n', '     * Инвесторы могут затребовать возврат средств, только в случае, если текущее состояние - Refunding\n', '     */\n', '    function refund() public inState(State.Refunding) {\n', '        // Получаем значение, которое нам было переведено в эфире\n', '        uint weiValue = investedAmountOf[msg.sender];\n', '\n', '        require(weiValue != 0);\n', '\n', '        // Кол-во токенов на балансе, берем 2 значения: контракт продаж и контракт токена.\n', '        // Вернуть wei можем только тогда, когда эти значения совпадают, если не совпадают, значит были какие-то\n', '        // манипуляции с токенами и такие ситуации будут решаться в индивидуальном порядке, по запросу\n', '        uint saleContractTokenCount = tokenAmountOf[msg.sender];\n', '        uint tokenContractTokenCount = token.balanceOf(msg.sender);\n', '\n', '        require(saleContractTokenCount <= tokenContractTokenCount);\n', '\n', '        investedAmountOf[msg.sender] = 0;\n', '        weiRefunded = weiRefunded.add(weiValue);\n', '\n', '        // Событие генерируется в наследниках\n', '        internalRefund(msg.sender, weiValue);\n', '    }\n', '\n', '    /**\n', '     * Финализатор первой стадии, вызвать может только владелец при условии еще незавершившейся продажи\n', '     * Если вызван halt, то финализатор вызвать не можем\n', '     * Вызвать можно только 1 раз\n', '     */\n', '    function finalizeFirstStage() public onlyOwner isNotSuccessOver {\n', '        require(!isFirstStageFinalized);\n', '\n', '        // Сжигаем остатки\n', '        // Всего можем продать firstStageTotalSupply\n', '        // Продали - firstStageTokensSold\n', '        // Все токены на балансе контракта сжигаем - это будет остаток\n', '\n', '        token.burnAllOwnerTokens();\n', '\n', '        // Переходим ко второй стадии\n', '        // Если повторно вызвать финализатор, то еще раз токены не создадутся, условие внутри\n', '        mintTokensForSecondStage();\n', '\n', '        isFirstStageFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * Финализатор второй стадии, вызвать может только владелец, и только в случае финилизированной первой стадии\n', '     * и только в случае, если сборы еще не завершились успехом. Если вызван halt, то финализатор вызвать не можем.\n', '     * Вызвать можно только 1 раз\n', '     */\n', '    function finalizeSecondStage() public onlyOwner isNotSuccessOver {\n', '        require(isFirstStageFinalized && !isSecondStageFinalized);\n', '\n', '        // Сжигаем остатки\n', '        // Всего можем продать secondStageTokensForSale\n', '        // Продали - secondStageTokensSold\n', '        // Разницу нужно сжечь, в любом случае\n', '\n', '        // Если достигнут Soft Cap, то считаем вторую стадию успешной\n', '        if (isSoftCapGoalReached()){\n', '            uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '            uint remainingTokens = secondStageTokensForSale.mul(tokenMultiplier).sub(secondStageTokensSold);\n', '\n', '            // Если кол-во оставшихся токенов > 0, то сжигаем их\n', '            if (remainingTokens > 0){\n', '                token.burnOwnerTokens(remainingTokens);\n', '            }\n', '\n', '            // Переводим на подготовленные аккаунты: advisorsWalletAddress, marketingWalletAddress, teamWalletAddress\n', '            uint advisorsTokenTransferAmount = advisorsTokenAmount.mul(tokenMultiplier);\n', '            uint marketingTokenTransferAmount = marketingTokenAmount.mul(tokenMultiplier);\n', '            uint supportTokenTransferAmount = supportTokenAmount.mul(tokenMultiplier);\n', '\n', '            // Токены для команды заблокированы до даты teamTokensIssueDate и могут быть востребованы, только при вызове спец. функции\n', '            // issueTeamTokens\n', '\n', '            if (!token.transfer(advisorsAccount, advisorsTokenTransferAmount)) revert();\n', '            if (!token.transfer(marketingAccount, marketingTokenTransferAmount)) revert();\n', '            if (!token.transfer(supportAccount, supportTokenTransferAmount)) revert();\n', '\n', '            // Контракт выполнен!\n', '            isSuccessOver = true;\n', '\n', '            // Вызываем метод успеха\n', '            internalSuccessOver();\n', '        }else{\n', '            // Если не собрали Soft Cap, то сжигаем все токены на балансе контракта\n', '            token.burnAllOwnerTokens();\n', '        }\n', '\n', '        isSecondStageFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * Позволяет менять владельцу даты стадий\n', '     */\n', '    function setFirstStageStartsAt(uint time) public onlyOwner {\n', '        firstStageStartsAt = time;\n', '\n', '        // Вызываем событие\n', '        FirstStageStartsAtChanged(firstStageStartsAt);\n', '    }\n', '\n', '    function setFirstStageEndsAt(uint time) public onlyOwner {\n', '        firstStageEndsAt = time;\n', '\n', '        // Вызываем событие\n', '        FirstStageEndsAtChanged(firstStageEndsAt);\n', '    }\n', '\n', '    function setSecondStageStartsAt(uint time) public onlyOwner {\n', '        secondStageStartsAt = time;\n', '\n', '        // Вызываем событие\n', '        SecondStageStartsAtChanged(secondStageStartsAt);\n', '    }\n', '\n', '    function setSecondStageEndsAt(uint time) public onlyOwner {\n', '        secondStageEndsAt = time;\n', '\n', '        // Вызываем событие\n', '        SecondStageEndsAtChanged(secondStageEndsAt);\n', '    }\n', '\n', '    /**\n', '     * Позволяет менять владельцу Cap&#39;ы\n', '     */\n', '    function setSoftCapInCents(uint value) public onlyOwner {\n', '        require(value > 0);\n', '\n', '        softCapFundingGoalInCents = value;\n', '\n', '        // Вызываем событие\n', '        SoftCapChanged(softCapFundingGoalInCents);\n', '    }\n', '\n', '    function setHardCapInCents(uint value) public onlyOwner {\n', '        require(value > 0);\n', '\n', '        hardCapFundingGoalInCents = value;\n', '\n', '        // Вызываем событие\n', '        HardCapChanged(hardCapFundingGoalInCents);\n', '    }\n', '\n', '    /**\n', '     * Проверка сбора Soft Cap&#39;а\n', '     */\n', '    function isSoftCapGoalReached() public constant returns (bool) {\n', '        // Проверка по текущему курсу в центах, считает от общих продаж\n', '        return getWeiInCents(weiRaised) >= softCapFundingGoalInCents;\n', '    }\n', '\n', '    /**\n', '     * Проверка сбора Hard Cap&#39;а\n', '     */\n', '    function isHardCapGoalReached() public constant returns (bool) {\n', '        // Проверка по текущему курсу в центах, считает от общих продаж\n', '        return getWeiInCents(weiRaised) >= hardCapFundingGoalInCents;\n', '    }\n', '\n', '    /**\n', '     * Возвращает кол-во нераспроданных токенов, которые можно продать, в зависимости от стадии\n', '     */\n', '    function getTokensLeftForSale(State forState) public constant returns (uint) {\n', '        // Кол-во токенов, которое адрес контракта можеть снять у owner&#39;а и есть кол-во оставшихся токенов, из этой суммы нужно вычесть кол-во которое не участвует в продаже\n', '        uint tokenBalance = token.balanceOf(address(this));\n', '        uint tokensReserve = 0;\n', '        if (forState == State.SecondStageFunding) tokensReserve = secondStageReserve.mul(10 ** token.decimals());\n', '\n', '        if (tokenBalance <= tokensReserve){\n', '            return 0;\n', '        }\n', '\n', '        return tokenBalance.sub(tokensReserve);\n', '    }\n', '\n', '    /**\n', '     * Получаем стейт\n', '     *\n', '     * Не пишем в переменную, чтобы не было возможности поменять извне, только вызов функции может отразить текущее состояние\n', '     * См. граф состояний\n', '     */\n', '    function getState() public constant returns (State) {\n', '        // Контракт выполнен\n', '        if (isSuccessOver) return State.Success;\n', '\n', '        // Контракт находится в режиме возврата\n', '        if (isRefundingEnabled) return State.Refunding;\n', '\n', '        // Контракт еще не начал действовать\n', '        if (block.timestamp < firstStageStartsAt) return State.PreFunding;\n', '\n', '        //Если первая стадия - не финализирована\n', '        if (!isFirstStageFinalized){\n', '            // Флаг того, что текущая дата находится в интервале первой стадии\n', '            bool isFirstStageTime = block.timestamp >= firstStageStartsAt && block.timestamp <= firstStageEndsAt;\n', '\n', '            // Если идет первая стадия\n', '            if (isFirstStageTime) return State.FirstStageFunding;\n', '            // Иначе первый этап - закончен\n', '            else return State.FirstStageEnd;\n', '\n', '        } else {\n', '\n', '            // Если первая стадия финализирована и текущее время блок чейна меньше начала второй стадии, то это означает, что первая стадия - окончена\n', '            if(block.timestamp < secondStageStartsAt)return State.FirstStageEnd;\n', '\n', '            // Флаг того, что текущая дата находится в интервале второй стадии\n', '            bool isSecondStageTime = block.timestamp >= secondStageStartsAt && block.timestamp <= secondStageEndsAt;\n', '\n', '            // Первая стадия финализирована, вторая - финализирована\n', '            if (isSecondStageFinalized){\n', '\n', '                // Если набрали Soft Cap при условии финализации второй сдадии - это успешное закрытие продаж\n', '                if (isSoftCapGoalReached())return State.Success;\n', '                // Собрать Soft Cap не удалось, текущее состояние - провал\n', '                else return State.Failure;\n', '\n', '            }else{\n', '\n', '                // Вторая стадия - не финализирована\n', '                if (isSecondStageTime)return State.SecondStageFunding;\n', '                // Вторая стадия - закончилась\n', '                else return State.SecondStageEnd;\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '   /**\n', '    * Модификаторы\n', '    */\n', '\n', '    /** Только, если текущее состояние соответсвует состоянию  */\n', '    modifier inState(State state) {\n', '        require(getState() == state);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если текущее состояние - продажи: первая или вторая стадия */\n', '    modifier inFirstOrSecondFundingState() {\n', '        State curState = getState();\n', '        require(curState == State.FirstStageFunding || curState == State.SecondStageFunding);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если не достигнут Hard Cap */\n', '    modifier notHardCapReached(){\n', '        require(!isHardCapGoalReached());\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если текущее состояние - продажи первой стадии или первая стадия закончилась */\n', '    modifier isFirstStageFundingOrEnd() {\n', '        State curState = getState();\n', '        require(curState == State.FirstStageFunding || curState == State.FirstStageEnd);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если контракт не финализирован */\n', '    modifier isNotSuccessOver() {\n', '        require(!isSuccessOver);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если идет вторая стадия или вторая стадия завершилась */\n', '    modifier isSecondStageFundingOrEnd() {\n', '        State curState = getState();\n', '        require(curState == State.SecondStageFunding || curState == State.SecondStageEnd);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если еще не включен режим возврата и продажи не завершены успехом */\n', '    modifier canEnableRefunds(){\n', '        require(!isRefundingEnabled && getState() != State.Success);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если продажи не завершены успехом */\n', '    modifier canSetDestinationMultisigWallet(){\n', '        require(getState() != State.Success);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * Шаблон класса хранилища средств, которое используется в контракте продаж\n', ' * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\n', ' */\n', 'contract FundsVault is Ownable, ValidationUtil {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '\n', '    enum State {Active, Refunding, Closed}\n', '\n', '    mapping (address => uint256) public deposited;\n', '\n', '    address public wallet;\n', '\n', '    State public state;\n', '\n', '    event Closed();\n', '\n', '    event RefundsEnabled();\n', '\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    /**\n', '     * Указываем на какой кошелек будут потом переведены собранные средства, в случае, если будет вызвана функция close()\n', '     * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\n', '     */\n', '    function FundsVault(address _wallet) {\n', '        requireNotEmptyAddress(_wallet);\n', '\n', '        wallet = _wallet;\n', '\n', '        state = State.Active;\n', '    }\n', '\n', '    /**\n', '     * Положить депозит в хранилище\n', '     */\n', '    function deposit(address investor) public payable onlyOwner inState(State.Active) {\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    /**\n', '     * Перевод собранных средств на указанный кошелек\n', '     */\n', '    function close() public onlyOwner inState(State.Active) {\n', '        state = State.Closed;\n', '\n', '        Closed();\n', '\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * Установливаем кошелек\n', '     */\n', '    function setWallet(address newWalletAddress) public onlyOwner inState(State.Active) {\n', '        wallet = newWalletAddress;\n', '    }\n', '\n', '    /**\n', '     * Установить режим возврата денег\n', '     */\n', '    function enableRefunds() public onlyOwner inState(State.Active) {\n', '        state = State.Refunding;\n', '\n', '        RefundsEnabled();\n', '    }\n', '\n', '    /**\n', '     * Функция возврата средств\n', '     */\n', '    function refund(address investor, uint weiAmount) public onlyOwner inState(State.Refunding){\n', '        uint256 depositedValue = weiAmount.min256(deposited[investor]);\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '\n', '        Refunded(investor, depositedValue);\n', '    }\n', '\n', '    /** Только, если текущее состояние соответсвует состоянию  */\n', '    modifier inState(State _state) {\n', '        require(state == _state);\n', '\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* Контракт продажи\n', '* Возврат средств поддержмвается только тем, кто купил токены через функцию internalInvest\n', '* Таким образом, если инвесторы будут обмениваться токенами, то вернуть можно будет только тем, у кого в контракте продаж\n', '* такая же сумма токенов, как и в контракте токена, в противном случае переведенный эфир остается навсегда в системе и не может быть выведен\n', '*/\n', 'contract RefundableAllocatedCappedCrowdsale is AllocatedCappedCrowdsale {\n', '\n', '    /**\n', '    * Хранилище, куда будут собираться средства, делается для того, чтобы гарантировать возвраты\n', '    */\n', '    FundsVault public fundsVault;\n', '\n', '    /** Мапа адрес инвестора - был ли совершен возврат среств */\n', '    mapping (address => bool) public refundedInvestors;\n', '\n', '    function RefundableAllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) AllocatedCappedCrowdsale(_currentEtherRateInCents, _token, _destinationMultisigWallet, _firstStageStartsAt, _firstStageEndsAt, _secondStageStartsAt, _secondStageEndsAt, _advisorsAccount, _marketingAccount, _supportAccount, _teamAccount, _teamTokensIssueDate) {\n', '        // Создаем от контракта продаж новое хранилище, доступ к нему имеет только контракт продаж\n', '        // При успешном завершении продаж, все собранные средства поступят на _destinationMultisigWallet\n', '        // В противном случае могут быть переведены обратно инвесторам\n', '        fundsVault = new FundsVault(_destinationMultisigWallet);\n', '\n', '    }\n', '\n', '    /** Устанавливаем новый кошелек для финального перевода\n', '    */\n', '    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\n', '        fundsVault.setWallet(destinationAddress);\n', '\n', '        super.internalSetDestinationMultisigWallet(destinationAddress);\n', '    }\n', '\n', '    /** Финализация второго этапа\n', '    */\n', '    function internalSuccessOver() internal {\n', '        // Успешно закрываем хранилище средств и переводим эфир на указанный кошелек\n', '        fundsVault.close();\n', '\n', '        super.internalSuccessOver();\n', '    }\n', '\n', '    /** Переопределение функции принятия допозита на счет, в данном случае, идти будет через vault\n', '    */\n', '    function internalDeposit(address receiver, uint weiAmount) internal{\n', '        // Шлем на кошелёк эфир\n', '        fundsVault.deposit.value(weiAmount)(msg.sender);\n', '    }\n', '\n', '    /** Переопределение функции включения состояния возврата\n', '    */\n', '    function internalEnableRefunds() internal{\n', '        super.internalEnableRefunds();\n', '\n', '        fundsVault.enableRefunds();\n', '    }\n', '\n', '    /** Переопределение функции возврата, возврат можно сделать только раз\n', '    */\n', '    function internalRefund(address receiver, uint weiAmount) internal{\n', '        // Делаем возврат\n', '        // Поддерживаем только 1 возврат\n', '\n', '        if (refundedInvestors[receiver]) revert();\n', '\n', '        fundsVault.refund(receiver, weiAmount);\n', '\n', '        refundedInvestors[receiver] = true;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function getOwner() returns(address){\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' * Базовый контракт, который поддерживает остановку продаж\n', ' */\n', '\n', 'contract Haltable is Ownable {\n', '    bool public halted;\n', '\n', '    modifier stopInEmergency {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    /* Модификатор, который вызывается в потомках */\n', '    modifier onlyInEmergency {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '    /* Вызов функции прервет продажи, вызывать может только владелец */\n', '    function halt() external onlyOwner {\n', '        halted = true;\n', '    }\n', '\n', '    /* Вызов возвращает режим продаж */\n', '    function unhalt() external onlyOwner onlyInEmergency {\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * Различные валидаторы\n', ' */\n', '\n', 'contract ValidationUtil {\n', '    function requireNotEmptyAddress(address value) internal{\n', '        require(isAddressValid(value));\n', '    }\n', '\n', '    function isAddressValid(address value) internal constant returns (bool result){\n', '        return value != 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  \n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until \n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue) \n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue) \n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Шаблон для токена, который можно сжечь\n', '*/\n', 'contract BurnableToken is StandardToken, Ownable, ValidationUtil {\n', '    using SafeMath for uint;\n', '\n', '    address public tokenOwnerBurner;\n', '\n', '    /** Событие, сколько токенов мы сожгли */\n', '    event Burned(address burner, uint burnedAmount);\n', '\n', '    function setOwnerBurner(address _tokenOwnerBurner) public onlyOwner invalidOwnerBurner{\n', '        // Проверка, что адрес не пустой\n', '        requireNotEmptyAddress(_tokenOwnerBurner);\n', '\n', '        tokenOwnerBurner = _tokenOwnerBurner;\n', '    }\n', '\n', '    /**\n', '     * Сжигаем токены на балансе владельца токенов, вызвать может только tokenOwnerBurner\n', '     */\n', '    function burnOwnerTokens(uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\n', '        burnTokens(tokenOwnerBurner, burnAmount);\n', '    }\n', '\n', '    /**\n', '     * Сжигаем токены на балансе адреса токенов, вызвать может только tokenOwnerBurner\n', '     */\n', '    function burnTokens(address _address, uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\n', '        balances[_address] = balances[_address].sub(burnAmount);\n', '\n', '        // Вызываем событие\n', '        Burned(_address, burnAmount);\n', '    }\n', '\n', '    /**\n', '     * Сжигаем все токены на балансе владельца\n', '     */\n', '    function burnAllOwnerTokens() public onlyTokenOwnerBurner validOwnerBurner{\n', '        uint burnAmount = balances[tokenOwnerBurner];\n', '        burnTokens(tokenOwnerBurner, burnAmount);\n', '    }\n', '\n', '    /** Модификаторы\n', '     */\n', '    modifier onlyTokenOwnerBurner() {\n', '        require(msg.sender == tokenOwnerBurner);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier validOwnerBurner() {\n', '        // Проверка, что адрес не пустой\n', '        requireNotEmptyAddress(tokenOwnerBurner);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier invalidOwnerBurner() {\n', '        // Проверка, что адрес не пустой\n', '        require(!isAddressValid(tokenOwnerBurner));\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * Токен продаж\n', ' *\n', ' * ERC-20 токен, для ICO\n', ' *\n', ' */\n', '\n', 'contract CrowdsaleToken is StandardToken, Ownable {\n', '\n', '    /* Описание см. в конструкторе */\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint public decimals;\n', '\n', '    address public mintAgent;\n', '\n', '    /** Событие обновления токена (имя и символ) */\n', '    event UpdatedTokenInformation(string newName, string newSymbol);\n', '\n', '    /** Событие выпуска токенов */\n', '    event TokenMinted(uint amount, address toAddress);\n', '\n', '    /**\n', '     * Конструктор\n', '     *\n', '     * Токен должен быть создан только владельцем через кошелек (либо с мультиподписью, либо без нее)\n', '     *\n', '     * @param _name - имя токена\n', '     * @param _symbol - символ токена\n', '     * @param _decimals - кол-во знаков после запятой\n', '     */\n', '    function CrowdsaleToken(string _name, string _symbol, uint _decimals) {\n', '        owner = msg.sender;\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '     * Владелец должен вызвать эту функцию, чтобы выпустить токены на адрес\n', '     */\n', '    function mintToAddress(uint amount, address toAddress) onlyMintAgent{\n', '        // перевод токенов на аккаунт\n', '        balances[toAddress] = amount;\n', '\n', '        // вызываем событие\n', '        TokenMinted(amount, toAddress);\n', '    }\n', '\n', '    /**\n', '     * Владелец может обновить инфу по токену\n', '     */\n', '    function setTokenInformation(string _name, string _symbol) onlyOwner {\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        // Вызываем событие\n', '        UpdatedTokenInformation(name, symbol);\n', '    }\n', '\n', '    /**\n', '     * Только владелец может обновить агента для создания токенов\n', '     */\n', '    function setMintAgent(address _address) onlyOwner {\n', '        mintAgent =  _address;\n', '    }\n', '\n', '    modifier onlyMintAgent(){\n', '        require(msg.sender == mintAgent);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * Шаблон для продаж токена, который можно сжечь\n', ' *\n', ' */\n', 'contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken {\n', '\n', '    function BurnableCrowdsaleToken(string _name, string _symbol, uint _decimals) CrowdsaleToken(_name, _symbol, _decimals) BurnableToken(){\n', '\n', '    }\n', '}\n', '\n', '/**\n', ' * Базовый контракт для продаж\n', ' *\n', ' * Содержит\n', ' * - Дата начала и конца\n', ' */\n', '\n', '/* Продажи могут быть остановлены в любой момент по вызову halt() */\n', '\n', 'contract AllocatedCappedCrowdsale is Haltable, ValidationUtil {\n', '    using SafeMath for uint;\n', '\n', '    // Кол-во токенов для распределения\n', '    uint public advisorsTokenAmount = 8040817;\n', '    uint public supportTokenAmount = 3446064;\n', '    uint public marketingTokenAmount = 3446064;\n', '    uint public teamTokenAmount = 45947521;\n', '\n', '    uint public teamTokensIssueDate;\n', '\n', '    /* Токен, который продаем */\n', '    BurnableCrowdsaleToken public token;\n', '\n', '    /* Адрес, куда будут переведена собранная сумма, в случае успеха */\n', '    address public destinationMultisigWallet;\n', '\n', '    /* Первая стадия в формате UNIX timestamp */\n', '    uint public firstStageStartsAt;\n', '    /* Конец продаж в формате UNIX timestamp */\n', '    uint public firstStageEndsAt;\n', '\n', '    /* Вторая стадия в формате UNIX timestamp */\n', '    uint public secondStageStartsAt;\n', '    /* Конец продаж в формате UNIX timestamp */\n', '    uint public secondStageEndsAt;\n', '\n', '    /* Минимальная кепка для первой стадии в центах */\n', '    uint public softCapFundingGoalInCents = 392000000;\n', '\n', '    /* Минимальная кепка для второй стадии в центах */\n', '    uint public hardCapFundingGoalInCents = 985000000;\n', '\n', '    /* Сколько всего в wei мы получили 10^18 wei = 1 ether */\n', '    uint public weiRaised;\n', '\n', '    /* Сколько всего собрали в ценах на первой стадии */\n', '    uint public firstStageRaisedInWei;\n', '\n', '    /* Сколько всего собрали в ценах на второй стадии */\n', '    uint public secondStageRaisedInWei;\n', '\n', '    /* Кол-во уникальных адресов, которые у наc получили токены */\n', '    uint public investorCount;\n', '\n', "    /*  Сколько wei отдали инвесторам на refund'е в wei */\n", '    uint public weiRefunded;\n', '\n', '    /*  Сколько токенов продали всего */\n', '    uint public tokensSold;\n', '\n', '    /* Флаг того, что сработал финализатор первой стадии */\n', '    bool public isFirstStageFinalized;\n', '\n', '    /* Флаг того, что сработал финализатор второй стадии */\n', '    bool public isSecondStageFinalized;\n', '\n', '    /* Флаг нормального завершнения продаж */\n', '    bool public isSuccessOver;\n', '\n', '    /* Флаг того, что начался процесс возврата */\n', '    bool public isRefundingEnabled;\n', '\n', '    /*  Сколько сейчас стоит 1 eth в центах, округленная до целых */\n', '    uint public currentEtherRateInCents;\n', '\n', '    /* Текущая стоимость токена в центах */\n', '    uint public oneTokenInCents = 7;\n', '\n', '    /* Выпущены ли токены для первой стадии */\n', '    bool public isFirstStageTokensMinted;\n', '\n', '    /* Выпущены ли токены для второй стадии */\n', '    bool public isSecondStageTokensMinted;\n', '\n', '    /* Кол-во токенов для первой стадии */\n', '    uint public firstStageTotalSupply = 112000000;\n', '\n', '    /* Кол-во токенов проданных на первой стадии*/\n', '    uint public firstStageTokensSold;\n', '\n', '    /* Кол-во токенов для второй стадии */\n', '    uint public secondStageTotalSupply = 229737610;\n', '\n', '    /* Кол-во токенов проданных на второй стадии*/\n', '    uint public secondStageTokensSold;\n', '\n', '    /* Кол-во токенов, которые находятся в резерве и не продаются, после успеха, они распределяются в соотвествии с Token Policy на второй стадии*/\n', '    uint public secondStageReserve = 60880466;\n', '\n', '    /* Кол-во токенов предназначенных для продажи, на второй стадии*/\n', '    uint public secondStageTokensForSale;\n', '\n', '    /* Мапа адрес инвестора - кол-во выданных токенов */\n', '    mapping (address => uint) public tokenAmountOf;\n', '\n', '    /* Мапа, адрес инвестора - кол-во эфира */\n', '    mapping (address => uint) public investedAmountOf;\n', '\n', '    /* Адреса, куда будут распределены токены */\n', '    address public advisorsAccount;\n', '    address public marketingAccount;\n', '    address public supportAccount;\n', '    address public teamAccount;\n', '\n', '    /** Возможные состояния\n', '     *\n', '     * - Prefunding: подготовка, залили контракт, но текущая дата меньше даты первой стадии\n', '     * - FirstStageFunding: Продажи первой стадии\n', '     * - FirstStageEnd: Окончены продажи первой стадии, но еще не вызван финализатор первой стадии\n', '     * - SecondStageFunding: Продажи второго этапа\n', '     * - SecondStageEnd: Окончены продажи второй стадии, но не вызван финализатор второй сдадии\n', '     * - Success: Успешно закрыли ICO\n', '     * - Failure: Не собрали Soft Cap\n', '     * - Refunding: Возвращаем собранный эфир\n', '     */\n', '    enum State{PreFunding, FirstStageFunding, FirstStageEnd, SecondStageFunding, SecondStageEnd, Success, Failure, Refunding}\n', '\n', '    // Событие покупки токена\n', '    event Invested(address indexed investor, uint weiAmount, uint tokenAmount, uint centAmount, uint txId);\n', '\n', '    // Событие изменения курса eth\n', '    event ExchangeRateChanged(uint oldExchangeRate, uint newExchangeRate);\n', '\n', '    // Событие изменения даты окончания первой стадии\n', '    event FirstStageStartsAtChanged(uint newFirstStageStartsAt);\n', '    event FirstStageEndsAtChanged(uint newFirstStageEndsAt);\n', '\n', '    // Событие изменения даты окончания второй стадии\n', '    event SecondStageStartsAtChanged(uint newSecondStageStartsAt);\n', '    event SecondStageEndsAtChanged(uint newSecondStageEndsAt);\n', '\n', "    // Событие изменения Soft Cap'а\n", '    event SoftCapChanged(uint newGoal);\n', '\n', "    // Событие изменения Hard Cap'а\n", '    event HardCapChanged(uint newGoal);\n', '\n', '    // Конструктор\n', '    function AllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) {\n', '        requireNotEmptyAddress(_destinationMultisigWallet);\n', '        // Проверка, что даты установлены\n', '        require(_firstStageStartsAt != 0);\n', '        require(_firstStageEndsAt != 0);\n', '\n', '        require(_firstStageStartsAt < _firstStageEndsAt);\n', '\n', '        require(_secondStageStartsAt != 0);\n', '        require(_secondStageEndsAt != 0);\n', '\n', '        require(_secondStageStartsAt < _secondStageEndsAt);\n', '        require(_teamTokensIssueDate != 0);\n', '\n', '        // Токен, который поддерживает сжигание\n', '        token = BurnableCrowdsaleToken(_token);\n', '\n', '        destinationMultisigWallet = _destinationMultisigWallet;\n', '\n', '        firstStageStartsAt = _firstStageStartsAt;\n', '        firstStageEndsAt = _firstStageEndsAt;\n', '        secondStageStartsAt = _secondStageStartsAt;\n', '        secondStageEndsAt = _secondStageEndsAt;\n', '\n', '        // Адреса кошельков для адвизоров, маркетинга, команды\n', '        advisorsAccount = _advisorsAccount;\n', '        marketingAccount = _marketingAccount;\n', '        supportAccount = _supportAccount;\n', '        teamAccount = _teamAccount;\n', '\n', '        teamTokensIssueDate = _teamTokensIssueDate;\n', '\n', '        currentEtherRateInCents = _currentEtherRateInCents;\n', '\n', '        secondStageTokensForSale = secondStageTotalSupply.sub(secondStageReserve);\n', '    }\n', '\n', '    /**\n', '     * Функция, инициирующая нужное кол-во токенов для первого этапа продаж, вызвать можно только 1 раз\n', '     */\n', '    function mintTokensForFirstStage() public onlyOwner {\n', '        // Если уже создали токены для первой стадии, делаем откат\n', '        require(!isFirstStageTokensMinted);\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        token.mintToAddress(firstStageTotalSupply.mul(tokenMultiplier), address(this));\n', '\n', '        isFirstStageTokensMinted = true;\n', '    }\n', '\n', '    /**\n', '     * Функция, инициирующая нужное кол-во токенов для второго этапа продаж, только в случае, если это еще не сделано и были созданы токены для первой стадии\n', '     */\n', '    function mintTokensForSecondStage() private {\n', '        // Если уже создали токены для второй стадии, делаем откат\n', '        require(!isSecondStageTokensMinted);\n', '\n', '        require(isFirstStageTokensMinted);\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        token.mintToAddress(secondStageTotalSupply.mul(tokenMultiplier), address(this));\n', '\n', '        isSecondStageTokensMinted = true;\n', '    }\n', '\n', '    /**\n', '     * Функция возвращающая текущую стоимость 1 токена в wei\n', '     */\n', '    function getOneTokenInWei() external constant returns(uint){\n', '        return oneTokenInCents.mul(10 ** 18).div(currentEtherRateInCents);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая переводит wei в центы по текущему курсу\n', '     */\n', '    function getWeiInCents(uint value) public constant returns(uint){\n', '        return currentEtherRateInCents.mul(value).div(10 ** 18);\n', '    }\n', '\n', '    /**\n', '     * Перевод токенов покупателю\n', '     */\n', '    function assignTokens(address receiver, uint tokenAmount) private {\n', '        // Если перевод не удался, откатываем транзакцию\n', '        if (!token.transfer(receiver, tokenAmount)) revert();\n', '    }\n', '\n', '    /**\n', '     * Fallback функция вызывающаяся при переводе эфира\n', '     */\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция перевода эфира и выдачи токенов\n', '     */\n', '    function internalAssignTokens(address receiver, uint tokenAmount, uint weiAmount, uint centAmount, uint txId) internal {\n', '        // Переводим токены инвестору\n', '        assignTokens(receiver, tokenAmount);\n', '\n', '        // Вызываем событие\n', '        Invested(receiver, weiAmount, tokenAmount, centAmount, txId);\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Инвестиции\n', '     * Должен быть включен режим продаж первой или второй стадии и не собран Hard Cap\n', '     * @param receiver - эфирный адрес получателя\n', '     * @param txId - id внешней транзакции\n', '     */\n', '    function internalInvest(address receiver, uint weiAmount, uint txId) stopInEmergency inFirstOrSecondFundingState notHardCapReached internal {\n', '        State currentState = getState();\n', '\n', '        uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '        uint amountInCents = getWeiInCents(weiAmount);\n', '\n', '        // Очень внимательно нужно менять значения, т.к. для второй стадии 1000%, чтобы учесть дробные значения\n', '        uint bonusPercentage = 0;\n', '        uint bonusStateMultiplier = 1;\n', '\n', '        // если запущена первая стадия, в конструкторе уже выпустили нужное кол-во токенов для первой стадии\n', '        if (currentState == State.FirstStageFunding){\n', '            // меньше 25000$ не принимаем\n', '            require(amountInCents >= 2500000);\n', '\n', '            // [25000$ - 50000$) - 50% бонуса\n', '            if (amountInCents >= 2500000 && amountInCents < 5000000){\n', '                bonusPercentage = 50;\n', '            // [50000$ - 100000$) - 75% бонуса\n', '            }else if(amountInCents >= 5000000 && amountInCents < 10000000){\n', '                bonusPercentage = 75;\n', '            // >= 100000$ - 100% бонуса\n', '            }else if(amountInCents >= 10000000){\n', '                bonusPercentage = 100;\n', '            }else{\n', '                revert();\n', '            }\n', '\n', '        // если запущена вторая стадия\n', '        } else if(currentState == State.SecondStageFunding){\n', '            // Процент проданных токенов, будем считать с множителем 10, т.к. есть дробные значения\n', '            bonusStateMultiplier = 10;\n', '\n', '            // Кол-во проданных токенов нужно считать от значения тех токенов, которые предназначены для продаж, т.е. secondStageTokensForSale\n', '            uint tokensSoldPercentage = secondStageTokensSold.mul(100).div(secondStageTokensForSale.mul(tokenMultiplier));\n', '\n', '            // меньше 7$ не принимаем\n', '            require(amountInCents >= 700);\n', '\n', '            // (0% - 10%) - 20% бонуса\n', '            if (tokensSoldPercentage >= 0 && tokensSoldPercentage < 10){\n', '                bonusPercentage = 200;\n', '            // [10% - 20%) - 17.5% бонуса\n', '            }else if (tokensSoldPercentage >= 10 && tokensSoldPercentage < 20){\n', '                bonusPercentage = 175;\n', '            // [20% - 30%) - 15% бонуса\n', '            }else if (tokensSoldPercentage >= 20 && tokensSoldPercentage < 30){\n', '                bonusPercentage = 150;\n', '            // [30% - 40%) - 12.5% бонуса\n', '            }else if (tokensSoldPercentage >= 30 && tokensSoldPercentage < 40){\n', '                bonusPercentage = 125;\n', '            // [40% - 50%) - 10% бонуса\n', '            }else if (tokensSoldPercentage >= 40 && tokensSoldPercentage < 50){\n', '                bonusPercentage = 100;\n', '            // [50% - 60%) - 8% бонуса\n', '            }else if (tokensSoldPercentage >= 50 && tokensSoldPercentage < 60){\n', '                bonusPercentage = 80;\n', '            // [60% - 70%) - 6% бонуса\n', '            }else if (tokensSoldPercentage >= 60 && tokensSoldPercentage < 70){\n', '                bonusPercentage = 60;\n', '            // [70% - 80%) - 4% бонуса\n', '            }else if (tokensSoldPercentage >= 70 && tokensSoldPercentage < 80){\n', '                bonusPercentage = 40;\n', '            // [80% - 90%) - 2% бонуса\n', '            }else if (tokensSoldPercentage >= 80 && tokensSoldPercentage < 90){\n', '                bonusPercentage = 20;\n', '            // >= 90% - 0% бонуса\n', '            }else if (tokensSoldPercentage >= 90){\n', '                bonusPercentage = 0;\n', '            }else{\n', '                revert();\n', '            }\n', '        } else revert();\n', '\n', '        // сколько токенов нужно выдать без бонуса\n', '        uint resultValue = amountInCents.mul(tokenMultiplier).div(oneTokenInCents);\n', '\n', '        // с учетом бонуса\n', '        uint tokenAmount = resultValue.mul(bonusStateMultiplier.mul(100).add(bonusPercentage)).div(bonusStateMultiplier.mul(100));\n', '\n', '        // краевой случай, когда запросили больше, чем можем выдать\n', '        uint tokensLeft = getTokensLeftForSale(currentState);\n', '        if (tokenAmount > tokensLeft){\n', '            tokenAmount = tokensLeft;\n', '        }\n', '\n', '        // Кол-во 0?, делаем откат\n', '        require(tokenAmount != 0);\n', '\n', '        // Новый инвестор?\n', '        if (investedAmountOf[receiver] == 0) {\n', '            investorCount++;\n', '        }\n', '\n', '        // Кидаем токены инвестору\n', '        internalAssignTokens(receiver, tokenAmount, weiAmount, amountInCents, txId);\n', '\n', '        // Обновляем статистику\n', '        updateStat(currentState, receiver, tokenAmount, weiAmount);\n', '\n', '        // Шлем на кошелёк эфир\n', '        // Функция - прослойка для возможности переопределения в дочерних классах\n', '        // Если это внешний вызов, то депозит не кладем\n', '        if (txId == 0){\n', '            internalDeposit(destinationMultisigWallet, weiAmount);\n', '        }\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция перевода эфира на контракт, функция доступна для переопределения в дочерних классах, но не публична\n', '     */\n', '    function internalDeposit(address receiver, uint weiAmount) internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для возврата средств, функция доступна для переопределения в дочерних классах, но не публична\n', '     */\n', '    function internalRefund(address receiver, uint weiAmount) internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для включения режима возврата средств\n', '     */\n', '    function internalEnableRefunds() internal{\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Спец. функция, которая позволяет продавать токены вне ценовой политики, доступка только владельцу\n', '     * Результаты пишутся в общую статистику, без разделения на стадии\n', '     * @param receiver - получатель\n', '     * @param tokenAmount - общее кол-во токенов c decimals!!!\n', '     * @param weiAmount - цена в wei\n', '     */\n', '    function internalPreallocate(State currentState, address receiver, uint tokenAmount, uint weiAmount) internal {\n', '        // Cколько токенов осталось для продажи? Больше этого значения выдать не можем!\n', '        require(getTokensLeftForSale(currentState) >= tokenAmount);\n', '\n', '        // Может быть 0, выдаем токены бесплатно\n', '        internalAssignTokens(receiver, tokenAmount, weiAmount, getWeiInCents(weiAmount), 0);\n', '\n', '        // Обновляем статистику\n', '        updateStat(currentState, receiver, tokenAmount, weiAmount);\n', '\n', '        // Может переопределяеться в наследниках\n', '    }\n', '\n', '    /**\n', '     * Низкоуровневая функция для действий, в случае успеха\n', '     */\n', '    function internalSuccessOver() internal {\n', '        // Переопределяется в наследниках\n', '    }\n', '\n', '    /**\n', '     * Функция, которая переопределяется в надледниках и выполняется после установки адреса аккаунта для перевода средств\n', '     */\n', '    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\n', '    }\n', '\n', '    /**\n', '     * Обновляем статистику для первой или второй стадии\n', '     */\n', '    function updateStat(State currentState, address receiver, uint tokenAmount, uint weiAmount) private{\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokenAmount);\n', '\n', '        // Если это первая стадия\n', '        if (currentState == State.FirstStageFunding){\n', '            // Увеличиваем стату\n', '            firstStageRaisedInWei = firstStageRaisedInWei.add(weiAmount);\n', '            firstStageTokensSold = firstStageTokensSold.add(tokenAmount);\n', '        }\n', '\n', '        // Если это вторая стадия\n', '        if (currentState == State.SecondStageFunding){\n', '            // Увеличиваем стату\n', '            secondStageRaisedInWei = secondStageRaisedInWei.add(weiAmount);\n', '            secondStageTokensSold = secondStageTokensSold.add(tokenAmount);\n', '        }\n', '\n', '        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая позволяет менять адрес аккаунта, куда будут переведены средства, в случае успеха,\n', '     * менять может только владелец и только в случае если продажи еще не завершены успехом\n', '     */\n', '    function setDestinationMultisigWallet(address destinationAddress) public onlyOwner canSetDestinationMultisigWallet{\n', '        destinationMultisigWallet = destinationAddress;\n', '\n', '        internalSetDestinationMultisigWallet(destinationAddress);\n', '    }\n', '\n', '    /**\n', '     * Функция, которая задает текущий курс eth в центах\n', '     */\n', '    function changeCurrentEtherRateInCents(uint value) public onlyOwner {\n', '        // Если случайно задали 0, не откатываем транзакцию\n', '        require(value > 0);\n', '\n', '        currentEtherRateInCents = value;\n', '\n', '        ExchangeRateChanged(currentEtherRateInCents, value);\n', '    }\n', '\n', '    /**\n', '    * Разделил на 2 метода, чтобы не запутаться при вызове\n', "    * Эти функции нужны в 2-х случаях: немного не собрали до Cap'а, сами докидываем необходимую сумму, есть приватные инвесторы, для которых существуют особые условия\n", '    */\n', '\n', '    /* Для первой стадии */\n', '    function preallocateFirstStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isFirstStageFundingOrEnd {\n', '        internalPreallocate(State.FirstStageFunding, receiver, tokenAmount, weiAmount);\n', '    }\n', '\n', '    /* Для второй стадии, выдать можем не больше остатка для продажи */\n', '    function preallocateSecondStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isSecondStageFundingOrEnd {\n', '        internalPreallocate(State.SecondStageFunding, receiver, tokenAmount, weiAmount);\n', '    }\n', '\n', '    /* В случае успеха, заблокированные токены для команды могут быть востребованы только если наступила определенная дата */\n', '    function issueTeamTokens() public onlyOwner inState(State.Success) {\n', '        require(block.timestamp >= teamTokensIssueDate);\n', '\n', '        uint teamTokenTransferAmount = teamTokenAmount.mul(10 ** token.decimals());\n', '\n', '        if (!token.transfer(teamAccount, teamTokenTransferAmount)) revert();\n', '    }\n', '\n', '    /**\n', '    * Включает режим возвратов, только в случае если режим возврата еще не установлен и продажи не завершены успехом\n', '    * Вызвать можно только 1 раз\n', '    */\n', '    function enableRefunds() public onlyOwner canEnableRefunds{\n', '        isRefundingEnabled = true;\n', '\n', '        // Сжигаем остатки на балансе текущего контракта\n', '        token.burnAllOwnerTokens();\n', '\n', '        internalEnableRefunds();\n', '    }\n', '\n', '    /**\n', '     * Покупка токенов, кидаем токены на адрес отправителя\n', '     */\n', '    function buy() public payable {\n', '        internalInvest(msg.sender, msg.value, 0);\n', '    }\n', '\n', '    /**\n', '     * Покупка токенов через внешние системы\n', '     */\n', '    function externalBuy(address buyerAddress, uint weiAmount, uint txId) external onlyOwner {\n', '        require(txId != 0);\n', '\n', '        internalInvest(buyerAddress, weiAmount, txId);\n', '    }\n', '\n', '    /**\n', '     * Инвесторы могут затребовать возврат средств, только в случае, если текущее состояние - Refunding\n', '     */\n', '    function refund() public inState(State.Refunding) {\n', '        // Получаем значение, которое нам было переведено в эфире\n', '        uint weiValue = investedAmountOf[msg.sender];\n', '\n', '        require(weiValue != 0);\n', '\n', '        // Кол-во токенов на балансе, берем 2 значения: контракт продаж и контракт токена.\n', '        // Вернуть wei можем только тогда, когда эти значения совпадают, если не совпадают, значит были какие-то\n', '        // манипуляции с токенами и такие ситуации будут решаться в индивидуальном порядке, по запросу\n', '        uint saleContractTokenCount = tokenAmountOf[msg.sender];\n', '        uint tokenContractTokenCount = token.balanceOf(msg.sender);\n', '\n', '        require(saleContractTokenCount <= tokenContractTokenCount);\n', '\n', '        investedAmountOf[msg.sender] = 0;\n', '        weiRefunded = weiRefunded.add(weiValue);\n', '\n', '        // Событие генерируется в наследниках\n', '        internalRefund(msg.sender, weiValue);\n', '    }\n', '\n', '    /**\n', '     * Финализатор первой стадии, вызвать может только владелец при условии еще незавершившейся продажи\n', '     * Если вызван halt, то финализатор вызвать не можем\n', '     * Вызвать можно только 1 раз\n', '     */\n', '    function finalizeFirstStage() public onlyOwner isNotSuccessOver {\n', '        require(!isFirstStageFinalized);\n', '\n', '        // Сжигаем остатки\n', '        // Всего можем продать firstStageTotalSupply\n', '        // Продали - firstStageTokensSold\n', '        // Все токены на балансе контракта сжигаем - это будет остаток\n', '\n', '        token.burnAllOwnerTokens();\n', '\n', '        // Переходим ко второй стадии\n', '        // Если повторно вызвать финализатор, то еще раз токены не создадутся, условие внутри\n', '        mintTokensForSecondStage();\n', '\n', '        isFirstStageFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * Финализатор второй стадии, вызвать может только владелец, и только в случае финилизированной первой стадии\n', '     * и только в случае, если сборы еще не завершились успехом. Если вызван halt, то финализатор вызвать не можем.\n', '     * Вызвать можно только 1 раз\n', '     */\n', '    function finalizeSecondStage() public onlyOwner isNotSuccessOver {\n', '        require(isFirstStageFinalized && !isSecondStageFinalized);\n', '\n', '        // Сжигаем остатки\n', '        // Всего можем продать secondStageTokensForSale\n', '        // Продали - secondStageTokensSold\n', '        // Разницу нужно сжечь, в любом случае\n', '\n', '        // Если достигнут Soft Cap, то считаем вторую стадию успешной\n', '        if (isSoftCapGoalReached()){\n', '            uint tokenMultiplier = 10 ** token.decimals();\n', '\n', '            uint remainingTokens = secondStageTokensForSale.mul(tokenMultiplier).sub(secondStageTokensSold);\n', '\n', '            // Если кол-во оставшихся токенов > 0, то сжигаем их\n', '            if (remainingTokens > 0){\n', '                token.burnOwnerTokens(remainingTokens);\n', '            }\n', '\n', '            // Переводим на подготовленные аккаунты: advisorsWalletAddress, marketingWalletAddress, teamWalletAddress\n', '            uint advisorsTokenTransferAmount = advisorsTokenAmount.mul(tokenMultiplier);\n', '            uint marketingTokenTransferAmount = marketingTokenAmount.mul(tokenMultiplier);\n', '            uint supportTokenTransferAmount = supportTokenAmount.mul(tokenMultiplier);\n', '\n', '            // Токены для команды заблокированы до даты teamTokensIssueDate и могут быть востребованы, только при вызове спец. функции\n', '            // issueTeamTokens\n', '\n', '            if (!token.transfer(advisorsAccount, advisorsTokenTransferAmount)) revert();\n', '            if (!token.transfer(marketingAccount, marketingTokenTransferAmount)) revert();\n', '            if (!token.transfer(supportAccount, supportTokenTransferAmount)) revert();\n', '\n', '            // Контракт выполнен!\n', '            isSuccessOver = true;\n', '\n', '            // Вызываем метод успеха\n', '            internalSuccessOver();\n', '        }else{\n', '            // Если не собрали Soft Cap, то сжигаем все токены на балансе контракта\n', '            token.burnAllOwnerTokens();\n', '        }\n', '\n', '        isSecondStageFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * Позволяет менять владельцу даты стадий\n', '     */\n', '    function setFirstStageStartsAt(uint time) public onlyOwner {\n', '        firstStageStartsAt = time;\n', '\n', '        // Вызываем событие\n', '        FirstStageStartsAtChanged(firstStageStartsAt);\n', '    }\n', '\n', '    function setFirstStageEndsAt(uint time) public onlyOwner {\n', '        firstStageEndsAt = time;\n', '\n', '        // Вызываем событие\n', '        FirstStageEndsAtChanged(firstStageEndsAt);\n', '    }\n', '\n', '    function setSecondStageStartsAt(uint time) public onlyOwner {\n', '        secondStageStartsAt = time;\n', '\n', '        // Вызываем событие\n', '        SecondStageStartsAtChanged(secondStageStartsAt);\n', '    }\n', '\n', '    function setSecondStageEndsAt(uint time) public onlyOwner {\n', '        secondStageEndsAt = time;\n', '\n', '        // Вызываем событие\n', '        SecondStageEndsAtChanged(secondStageEndsAt);\n', '    }\n', '\n', '    /**\n', "     * Позволяет менять владельцу Cap'ы\n", '     */\n', '    function setSoftCapInCents(uint value) public onlyOwner {\n', '        require(value > 0);\n', '\n', '        softCapFundingGoalInCents = value;\n', '\n', '        // Вызываем событие\n', '        SoftCapChanged(softCapFundingGoalInCents);\n', '    }\n', '\n', '    function setHardCapInCents(uint value) public onlyOwner {\n', '        require(value > 0);\n', '\n', '        hardCapFundingGoalInCents = value;\n', '\n', '        // Вызываем событие\n', '        HardCapChanged(hardCapFundingGoalInCents);\n', '    }\n', '\n', '    /**\n', "     * Проверка сбора Soft Cap'а\n", '     */\n', '    function isSoftCapGoalReached() public constant returns (bool) {\n', '        // Проверка по текущему курсу в центах, считает от общих продаж\n', '        return getWeiInCents(weiRaised) >= softCapFundingGoalInCents;\n', '    }\n', '\n', '    /**\n', "     * Проверка сбора Hard Cap'а\n", '     */\n', '    function isHardCapGoalReached() public constant returns (bool) {\n', '        // Проверка по текущему курсу в центах, считает от общих продаж\n', '        return getWeiInCents(weiRaised) >= hardCapFundingGoalInCents;\n', '    }\n', '\n', '    /**\n', '     * Возвращает кол-во нераспроданных токенов, которые можно продать, в зависимости от стадии\n', '     */\n', '    function getTokensLeftForSale(State forState) public constant returns (uint) {\n', "        // Кол-во токенов, которое адрес контракта можеть снять у owner'а и есть кол-во оставшихся токенов, из этой суммы нужно вычесть кол-во которое не участвует в продаже\n", '        uint tokenBalance = token.balanceOf(address(this));\n', '        uint tokensReserve = 0;\n', '        if (forState == State.SecondStageFunding) tokensReserve = secondStageReserve.mul(10 ** token.decimals());\n', '\n', '        if (tokenBalance <= tokensReserve){\n', '            return 0;\n', '        }\n', '\n', '        return tokenBalance.sub(tokensReserve);\n', '    }\n', '\n', '    /**\n', '     * Получаем стейт\n', '     *\n', '     * Не пишем в переменную, чтобы не было возможности поменять извне, только вызов функции может отразить текущее состояние\n', '     * См. граф состояний\n', '     */\n', '    function getState() public constant returns (State) {\n', '        // Контракт выполнен\n', '        if (isSuccessOver) return State.Success;\n', '\n', '        // Контракт находится в режиме возврата\n', '        if (isRefundingEnabled) return State.Refunding;\n', '\n', '        // Контракт еще не начал действовать\n', '        if (block.timestamp < firstStageStartsAt) return State.PreFunding;\n', '\n', '        //Если первая стадия - не финализирована\n', '        if (!isFirstStageFinalized){\n', '            // Флаг того, что текущая дата находится в интервале первой стадии\n', '            bool isFirstStageTime = block.timestamp >= firstStageStartsAt && block.timestamp <= firstStageEndsAt;\n', '\n', '            // Если идет первая стадия\n', '            if (isFirstStageTime) return State.FirstStageFunding;\n', '            // Иначе первый этап - закончен\n', '            else return State.FirstStageEnd;\n', '\n', '        } else {\n', '\n', '            // Если первая стадия финализирована и текущее время блок чейна меньше начала второй стадии, то это означает, что первая стадия - окончена\n', '            if(block.timestamp < secondStageStartsAt)return State.FirstStageEnd;\n', '\n', '            // Флаг того, что текущая дата находится в интервале второй стадии\n', '            bool isSecondStageTime = block.timestamp >= secondStageStartsAt && block.timestamp <= secondStageEndsAt;\n', '\n', '            // Первая стадия финализирована, вторая - финализирована\n', '            if (isSecondStageFinalized){\n', '\n', '                // Если набрали Soft Cap при условии финализации второй сдадии - это успешное закрытие продаж\n', '                if (isSoftCapGoalReached())return State.Success;\n', '                // Собрать Soft Cap не удалось, текущее состояние - провал\n', '                else return State.Failure;\n', '\n', '            }else{\n', '\n', '                // Вторая стадия - не финализирована\n', '                if (isSecondStageTime)return State.SecondStageFunding;\n', '                // Вторая стадия - закончилась\n', '                else return State.SecondStageEnd;\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '   /**\n', '    * Модификаторы\n', '    */\n', '\n', '    /** Только, если текущее состояние соответсвует состоянию  */\n', '    modifier inState(State state) {\n', '        require(getState() == state);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если текущее состояние - продажи: первая или вторая стадия */\n', '    modifier inFirstOrSecondFundingState() {\n', '        State curState = getState();\n', '        require(curState == State.FirstStageFunding || curState == State.SecondStageFunding);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если не достигнут Hard Cap */\n', '    modifier notHardCapReached(){\n', '        require(!isHardCapGoalReached());\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если текущее состояние - продажи первой стадии или первая стадия закончилась */\n', '    modifier isFirstStageFundingOrEnd() {\n', '        State curState = getState();\n', '        require(curState == State.FirstStageFunding || curState == State.FirstStageEnd);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если контракт не финализирован */\n', '    modifier isNotSuccessOver() {\n', '        require(!isSuccessOver);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если идет вторая стадия или вторая стадия завершилась */\n', '    modifier isSecondStageFundingOrEnd() {\n', '        State curState = getState();\n', '        require(curState == State.SecondStageFunding || curState == State.SecondStageEnd);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если еще не включен режим возврата и продажи не завершены успехом */\n', '    modifier canEnableRefunds(){\n', '        require(!isRefundingEnabled && getState() != State.Success);\n', '\n', '        _;\n', '    }\n', '\n', '    /** Только, если продажи не завершены успехом */\n', '    modifier canSetDestinationMultisigWallet(){\n', '        require(getState() != State.Success);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * Шаблон класса хранилища средств, которое используется в контракте продаж\n', ' * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\n', ' */\n', 'contract FundsVault is Ownable, ValidationUtil {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '\n', '    enum State {Active, Refunding, Closed}\n', '\n', '    mapping (address => uint256) public deposited;\n', '\n', '    address public wallet;\n', '\n', '    State public state;\n', '\n', '    event Closed();\n', '\n', '    event RefundsEnabled();\n', '\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    /**\n', '     * Указываем на какой кошелек будут потом переведены собранные средства, в случае, если будет вызвана функция close()\n', '     * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\n', '     */\n', '    function FundsVault(address _wallet) {\n', '        requireNotEmptyAddress(_wallet);\n', '\n', '        wallet = _wallet;\n', '\n', '        state = State.Active;\n', '    }\n', '\n', '    /**\n', '     * Положить депозит в хранилище\n', '     */\n', '    function deposit(address investor) public payable onlyOwner inState(State.Active) {\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    /**\n', '     * Перевод собранных средств на указанный кошелек\n', '     */\n', '    function close() public onlyOwner inState(State.Active) {\n', '        state = State.Closed;\n', '\n', '        Closed();\n', '\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * Установливаем кошелек\n', '     */\n', '    function setWallet(address newWalletAddress) public onlyOwner inState(State.Active) {\n', '        wallet = newWalletAddress;\n', '    }\n', '\n', '    /**\n', '     * Установить режим возврата денег\n', '     */\n', '    function enableRefunds() public onlyOwner inState(State.Active) {\n', '        state = State.Refunding;\n', '\n', '        RefundsEnabled();\n', '    }\n', '\n', '    /**\n', '     * Функция возврата средств\n', '     */\n', '    function refund(address investor, uint weiAmount) public onlyOwner inState(State.Refunding){\n', '        uint256 depositedValue = weiAmount.min256(deposited[investor]);\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '\n', '        Refunded(investor, depositedValue);\n', '    }\n', '\n', '    /** Только, если текущее состояние соответсвует состоянию  */\n', '    modifier inState(State _state) {\n', '        require(state == _state);\n', '\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* Контракт продажи\n', '* Возврат средств поддержмвается только тем, кто купил токены через функцию internalInvest\n', '* Таким образом, если инвесторы будут обмениваться токенами, то вернуть можно будет только тем, у кого в контракте продаж\n', '* такая же сумма токенов, как и в контракте токена, в противном случае переведенный эфир остается навсегда в системе и не может быть выведен\n', '*/\n', 'contract RefundableAllocatedCappedCrowdsale is AllocatedCappedCrowdsale {\n', '\n', '    /**\n', '    * Хранилище, куда будут собираться средства, делается для того, чтобы гарантировать возвраты\n', '    */\n', '    FundsVault public fundsVault;\n', '\n', '    /** Мапа адрес инвестора - был ли совершен возврат среств */\n', '    mapping (address => bool) public refundedInvestors;\n', '\n', '    function RefundableAllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) AllocatedCappedCrowdsale(_currentEtherRateInCents, _token, _destinationMultisigWallet, _firstStageStartsAt, _firstStageEndsAt, _secondStageStartsAt, _secondStageEndsAt, _advisorsAccount, _marketingAccount, _supportAccount, _teamAccount, _teamTokensIssueDate) {\n', '        // Создаем от контракта продаж новое хранилище, доступ к нему имеет только контракт продаж\n', '        // При успешном завершении продаж, все собранные средства поступят на _destinationMultisigWallet\n', '        // В противном случае могут быть переведены обратно инвесторам\n', '        fundsVault = new FundsVault(_destinationMultisigWallet);\n', '\n', '    }\n', '\n', '    /** Устанавливаем новый кошелек для финального перевода\n', '    */\n', '    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\n', '        fundsVault.setWallet(destinationAddress);\n', '\n', '        super.internalSetDestinationMultisigWallet(destinationAddress);\n', '    }\n', '\n', '    /** Финализация второго этапа\n', '    */\n', '    function internalSuccessOver() internal {\n', '        // Успешно закрываем хранилище средств и переводим эфир на указанный кошелек\n', '        fundsVault.close();\n', '\n', '        super.internalSuccessOver();\n', '    }\n', '\n', '    /** Переопределение функции принятия допозита на счет, в данном случае, идти будет через vault\n', '    */\n', '    function internalDeposit(address receiver, uint weiAmount) internal{\n', '        // Шлем на кошелёк эфир\n', '        fundsVault.deposit.value(weiAmount)(msg.sender);\n', '    }\n', '\n', '    /** Переопределение функции включения состояния возврата\n', '    */\n', '    function internalEnableRefunds() internal{\n', '        super.internalEnableRefunds();\n', '\n', '        fundsVault.enableRefunds();\n', '    }\n', '\n', '    /** Переопределение функции возврата, возврат можно сделать только раз\n', '    */\n', '    function internalRefund(address receiver, uint weiAmount) internal{\n', '        // Делаем возврат\n', '        // Поддерживаем только 1 возврат\n', '\n', '        if (refundedInvestors[receiver]) revert();\n', '\n', '        fundsVault.refund(receiver, weiAmount);\n', '\n', '        refundedInvestors[receiver] = true;\n', '    }\n', '\n', '}']
