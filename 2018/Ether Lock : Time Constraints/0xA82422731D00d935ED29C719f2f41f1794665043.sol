['/// @title Contract that supports the receival of ERC223 tokens.\n', 'contract ERC223ReceivingContract {\n', '\n', '    /// @dev Standard ERC223 function that will handle incoming token transfers.\n', '    /// @param _from  Token sender address.\n', '    /// @param _value Amount of tokens.\n', '    /// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '\n', '}\n', '\n', '\n', 'contract SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC223Basic is ERC20Basic {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Now with a new parameter _data.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '\n', '    /**\n', '      * @dev triggered when transfer is successfully called.\n', '      *\n', '      * @param _from  Sender address.\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '}\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', "            // of the array. (We don't need to use the offset into the slot\n", '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', "            // if length < 32 bytes so let's prepare for that\n", '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function toBytes16(bytes _bytes, uint _start) internal  pure returns (bytes16) {\n', '        require(_bytes.length >= (_start + 16));\n', '        bytes16 tempBytes16;\n', '\n', '        assembly {\n', '            tempBytes16 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes16;\n', '    }\n', '\n', '    function toBytes2(bytes _bytes, uint _start) internal  pure returns (bytes2) {\n', '        require(_bytes.length >= (_start + 2));\n', '        bytes2 tempBytes2;\n', '\n', '        assembly {\n', '            tempBytes2 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes2;\n', '    }\n', '\n', '    function toBytes4(bytes _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes1(bytes _bytes, uint _start) internal  pure returns (bytes1) {\n', '        require(_bytes.length >= (_start + 1));\n', '        bytes1 tempBytes1;\n', '\n', '        assembly {\n', '            tempBytes1 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes1;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', "            // if lengths don't match the arrays are not equal\n", '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', "                // cb is a circuit breaker in the for loop since there's\n", '                //  no said feature for inline assembly loops\n', "                // cb = 1 - don't breaker\n", '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', "            // if lengths don't match the arrays are not equal\n", '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', "                // if length < 32 bytes so let's prepare for that\n", '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', "                        // cb is a circuit breaker in the for loop since there's\n", '                        //  no said feature for inline assembly loops\n', "                        // cb = 1 - don't breaker\n", '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', '\n', 'contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath, DateTime {\n', '  using BytesLib for bytes;\n', '\n', '  /*\n', '   * Event\n', '   */\n', '  event receiveDth(address _from, uint amount);\n', '  event receiveEth(address _from, uint amount);\n', '  event sendDth(address _from, uint amount);\n', '  event sendEth(address _from, uint amount);\n', '\n', '  mapping(address => uint) public dthShopBalance;\n', '  mapping(address => uint) public dthTellerBalance;\n', '  mapping(address => uint) public ethShopBalance;\n', '  mapping(address => uint) public ethTellerBalance;\n', '\n', '\n', '  // store a mapping with per day/month/year a uint256 containing the wei sold amount on that date\n', '  //\n', '  //      user               day               month             year      weiSold\n', '  mapping(address => mapping(uint16 => mapping(uint16 => mapping(uint16 => uint256)))) ethSellsUserToday;\n', '\n', '  ERC223Basic public dth;\n', '  bool public isInit = false;\n', '\n', '  /**\n', '   * INIT\n', '   */\n', '  function setDth (address _dth) external onlyOwner {\n', '    require(!isInit);\n', '    dth = ERC223Basic(_dth);\n', '    isInit = true;\n', '  }\n', '\n', '  /**\n', '   * Core fonction\n', '   */\n', '  // withdraw DTH when teller delete\n', '  function withdrawDthTeller(address _receiver) external onlyOwner {\n', '    require(dthTellerBalance[_receiver] > 0);\n', '    uint tosend = dthTellerBalance[_receiver];\n', '    dthTellerBalance[_receiver] = 0;\n', '    require(dth.transfer(_receiver, tosend));\n', '  }\n', '  // withdraw DTH when shop delete\n', '  function withdrawDthShop(address _receiver) external onlyOwner  {\n', '    require(dthShopBalance[_receiver] > 0);\n', '    uint tosend = dthShopBalance[_receiver];\n', '    dthShopBalance[_receiver] = 0;\n', '    require(dth.transfer(_receiver, tosend));\n', '  }\n', '  // withdraw DTH when a shop add by admin is delete\n', '  function withdrawDthShopAdmin(address _from, address _receiver) external onlyOwner  {\n', '    require(dthShopBalance[_from]  > 0);\n', '    uint tosend = dthShopBalance[_from];\n', '    dthShopBalance[_from] = 0;\n', '    require(dth.transfer(_receiver, tosend));\n', '  }\n', '\n', '  // add DTH when shop register\n', '  function addTokenShop(address _from, uint _value) external onlyOwner {\n', '    dthShopBalance[_from] = SafeMath.add(dthShopBalance[_from], _value);\n', '  }\n', '  // add DTH when token register\n', '  function addTokenTeller(address _from, uint _value) external onlyOwner{\n', '    dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value);\n', '  }\n', '  // add ETH for escrow teller\n', '  function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) {\n', '    ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value);\n', '    return true;\n', '  }\n', '  // helper function to extra date info from block.timestamp\n', '  function getDateInfo(uint timestamp) internal view returns(_DateTime) {\n', '    // use DateTime.sol to extract date info from the timestamp\n', '    _DateTime memory date = parseTimestamp(timestamp);\n', '    return date;\n', '  }\n', '  // withdraw ETH for teller escrow + save amount sold today for the _from user\n', '  function withdrawEth(address _from, address _to, uint _amount) external onlyOwner {\n', '    require(ethTellerBalance[_from] >= _amount);\n', '    ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount);\n', '\n', '    uint256 weiSoldToday = getWeiSoldToday(_from);\n', '\n', '    _DateTime memory date = getDateInfo(block.timestamp);\n', '\n', '    // add the sold amount, should not exceed daily limit (checked in DetherCore)\n', '    ethSellsUserToday[_from][date.day][date.month][date.year] = SafeMath.add(weiSoldToday, _amount);\n', '\n', '    _to.transfer(_amount);\n', '  }\n', '  // refund all ETH from teller contract\n', '  function refundEth(address _from) external onlyOwner {\n', '    uint toSend = ethTellerBalance[_from];\n', '    if (toSend > 0) {\n', '      ethTellerBalance[_from] = 0;\n', '      _from.transfer(toSend);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * GETTER\n', '   */\n', '  function getDthTeller(address _user) public view returns (uint) {\n', '    return dthTellerBalance[_user];\n', '  }\n', '  function getDthShop(address _user) public view returns (uint) {\n', '    return dthShopBalance[_user];\n', '  }\n', '\n', '  function getEthBalTeller(address _user) public view returns (uint) {\n', '    return ethTellerBalance[_user];\n', '  }\n', '\n', '  // get amount wei sold today for this user\n', '  function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday) {\n', '    // use DateTime.sol to extract date info from the timestamp\n', '    _DateTime memory date = getDateInfo(block.timestamp);\n', '    weiSoldToday = ethSellsUserToday[_user][date.day][date.month][date.year];\n', '  }\n', '\n', '  /// @dev Standard ERC223 function that will handle incoming token transfers.\n', '  // DO NOTHING but allow to receive token when addToken* function are called\n', '  // by the dethercore contract\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '    require(msg.sender == address(dth));\n', '  }\n', '\n', '}']