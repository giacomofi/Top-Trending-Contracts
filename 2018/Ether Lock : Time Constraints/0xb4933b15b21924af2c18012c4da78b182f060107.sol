['pragma solidity ^0.4.18;\n', '\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', 'contract ERC20xVariables {\n', '    address public creator;\n', '    address public lib;\n', '\n', '    uint256 constant public MAX_UINT256 = 2**256 - 1;\n', '    mapping(address => uint) public balances;\n', '    mapping(address => mapping(address => uint)) public allowed;\n', '\n', '    uint8 public constant decimals = 18;\n', '    string public name;\n', '    string public symbol;\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Created(address creator, uint supply);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract ERC20x is ERC20xVariables {\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transferBalance(msg.sender, _to, _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(allowance >= _value);\n', '        _transferBalance(_from, _to, _value);\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferToContract(address _to, uint256 _value, bytes data) public returns (bool) {\n', '        _transferBalance(msg.sender, _to, _value);\n', '        bytes4 sig = bytes4(keccak256("receiveTokens(address,uint256,bytes)"));\n', '        require(_to.call(sig, msg.sender, _value, data));\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function _transferBalance(address _from, address _to, uint _value) internal {\n', '        require(balances[_from] >= _value);\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '    }\n', '}\n', '\n', 'contract VariableSupplyToken is ERC20x {\n', '    function grant(address to, uint256 amount) public {\n', '        require(msg.sender == creator);\n', '        require(balances[to] + amount >= amount);\n', '        balances[to] += amount;\n', '        totalSupply += amount;\n', '    }\n', '\n', '    function burn(address from, uint amount) public {\n', '        require(msg.sender == creator);\n', '        require(balances[from] >= amount);\n', '        balances[from] -= amount;\n', '        totalSupply -= amount;\n', '    }\n', '}\n', '\n', 'contract OptionToken is ERC20xVariables {\n', '\n', '    constructor(string _name, string _symbol, address _lib) public {\n', '        creator = msg.sender;\n', '        lib = _lib;\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    function() public {\n', '        require(\n', '            lib.delegatecall(msg.data)\n', '        );\n', '    }\n', '}\n', '\n', "// we don't store much state here either\n", 'contract Token is VariableSupplyToken {\n', '    constructor() public {\n', '        creator = msg.sender;\n', '        name = "Decentralized Settlement Facility Token";\n', '        symbol = "DSF";\n', '\n', '        // this needs to be here to avoid zero initialization of token rights.\n', '        totalSupply = 1;\n', '        balances[0x0] = 1;\n', '    }\n', '}\n', '\n', 'contract Protocol is DateTime {\n', '    \n', '    address public lib;\n', '    ERC20x public usdERC20;\n', '    Token public protocolToken;\n', '\n', '    // We use "flavor" because type is a reserved word in many programming languages\n', '    enum Flavor {\n', '        Call,\n', '        Put\n', '    }\n', '\n', '    struct OptionSeries {\n', '        uint expiration;\n', '        Flavor flavor;\n', '        uint strike;\n', '    }\n', '\n', '    uint public constant DURATION = 12 hours;\n', '    uint public constant HALF_DURATION = DURATION / 2;\n', '\n', '    mapping(bytes32 => address) public seriesToken;\n', '    mapping(address => uint) public openInterest;\n', '    mapping(address => uint) public earlyExercised;\n', '    mapping(address => uint) public totalInterest;\n', '    mapping(address => mapping(address => uint)) public writers;\n', '    mapping(address => OptionSeries) public seriesInfo;\n', '    mapping(address => uint) public holdersSettlement;\n', '\n', '    bytes4 public constant GRANT = bytes4(keccak256("grant(address,uint256)"));\n', '    bytes4 public constant BURN = bytes4(keccak256("burn(address,uint256)"));\n', '\n', '    bytes4 public constant RECEIVE_ETH = bytes4(keccak256("receiveETH(address,uint256)"));\n', '    bytes4 public constant RECEIVE_USD = bytes4(keccak256("receiveUSD(address,uint256)"));\n', '\n', '    uint public deployed;\n', '\n', '    mapping(address => uint) public expectValue;\n', '    bool isAuction;\n', '\n', '    uint public constant ONE_MILLION = 1000000;\n', '\n', '    // maximum token holder rights capped at 3.7% of total supply?\n', '    // Why 3.7%?\n', '    // I could make up some fancy explanation\n', '    // and use the phrase "byzantine fault tolerance" somehow\n', '    // Or I could just say that 3.7% allows for a total of 27 independent actors\n', '    // that are all receiving the maximum benefit, and it solves all the other\n', '    // issues of disincentivizing centralization and "rich get richer" mechanics, so I chose 27 \'cause it just has a nice "decentralized" feel to it.\n', "    // 21 would have been fine, as few as ten probably would have been ok 'cause people can just pool anyways\n", "    // up to a thousand or so probably wouldn't have hurt either.\n", "    // In the end it really doesn't matter as long as the game ends up being played fairly.\n", '\n', "    // I'm sure someone will take my system and parameterize it differently at some point and bill it as a totally new product.\n", '    uint public constant PREFERENCE_MAX = 0.037 ether;\n', '\n', '    constructor(address _usd) public {\n', '        lib = new VariableSupplyToken();\n', '        protocolToken = new Token();\n', '        usdERC20 = ERC20x(_usd);\n', '        deployed = now;\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    event SeriesIssued(address series);\n', '\n', '    function issue(uint expiration, Flavor flavor, uint strike) public returns (address) {\n', '        require(strike >= 20 ether);\n', '        require(strike % 20 ether == 0);\n', '        require(strike <= 10000 ether);\n', '\n', '        // require expiration to be at noon UTC\n', '        require(expiration % 86400 == 43200);\n', '\n', '        // valid expirations: 7n + 1 where n = (unix timestamp / 86400)\n', '        require(((expiration / 86400) + 2) % 7 == 0);\n', '        require(expiration > now + 12 hours);\n', '        require(expiration < now + 365 days);\n', '\n', '        // compute the symbol based on datetime library\n', '        _DateTime memory exp = parseTimestamp(expiration);\n', '\n', '        uint strikeCode = strike / 1 ether;\n', '\n', '        string memory name = _name(exp, flavor, strikeCode);\n', '\n', '        string memory symbol = _symbol(exp, flavor, strikeCode);\n', '\n', '        bytes32 id = _seriesHash(expiration, flavor, strike);\n', '        require(seriesToken[id] == address(0));\n', '        address series = new OptionToken(name, symbol, lib);\n', '        seriesToken[id] = series;\n', '        seriesInfo[series] = OptionSeries(expiration, flavor, strike);\n', '        emit SeriesIssued(series);\n', '        return series;\n', '    }\n', '\n', '    function _name(_DateTime exp, Flavor flavor, uint strikeCode) private pure returns (string) {\n', '        return string(\n', '            abi.encodePacked(\n', '                _monthName(exp.month),\n', '                " ",\n', '                uint2str(exp.day),\n', '                " ",\n', '                uint2str(strikeCode),\n', '                "-",\n', '                flavor == Flavor.Put ? "PUT" : "CALL"\n', '            )\n', '        );\n', '    }\n', '\n', '    function _symbol(_DateTime exp, Flavor flavor, uint strikeCode) private pure returns (string) {\n', '        uint monthChar = 64 + exp.month;\n', '        if (flavor == Flavor.Put) {\n', '            monthChar += 12;\n', '        }\n', '\n', '        uint dayChar = 65 + (exp.day - 1) / 7;\n', '\n', '        return string(\n', '            abi.encodePacked(\n', '                "∆",\n', '                byte(monthChar),\n', '                byte(dayChar),\n', '                uint2str(strikeCode)\n', '            )\n', '        );\n', '    }\n', '\n', '    function open(address _series, uint amount) public payable returns (bool) {\n', '        OptionSeries memory series = seriesInfo[_series];\n', '\n', '        bytes32 id = _seriesHash(series.expiration, series.flavor, series.strike);\n', '        require(seriesToken[id] == _series);\n', '        require(_series.call(GRANT, msg.sender, amount));\n', '\n', '        require(now < series.expiration);\n', '\n', '        if (series.flavor == Flavor.Call) {\n', '            require(msg.value == amount);\n', '        } else {\n', '            require(msg.value == 0);\n', '            uint escrow = amount * series.strike;\n', '            require(escrow / amount == series.strike);\n', '            escrow /= 1 ether;\n', '            require(usdERC20.transferFrom(msg.sender, this, escrow));\n', '        }\n', '        \n', '        openInterest[_series] += amount;\n', '        totalInterest[_series] += amount;\n', '        writers[_series][msg.sender] += amount;\n', '\n', '        return true;\n', '    }\n', '\n', '    function close(address _series, uint amount) public {\n', '        OptionSeries memory series = seriesInfo[_series];\n', '\n', '        require(now < series.expiration);\n', '        require(openInterest[_series] >= amount);\n', '        require(_series.call(BURN, msg.sender, amount));\n', '\n', '        require(writers[_series][msg.sender] >= amount);\n', '        writers[_series][msg.sender] -= amount;\n', '        openInterest[_series] -= amount;\n', '        totalInterest[_series] -= amount;\n', '        \n', '        if (series.flavor == Flavor.Call) {\n', '            msg.sender.transfer(amount);\n', '        } else {\n', '            require(\n', '                usdERC20.transfer(msg.sender, amount * series.strike / 1 ether));\n', '        }\n', '    }\n', '    \n', '    function exercise(address _series, uint amount) public payable {\n', '        OptionSeries memory series = seriesInfo[_series];\n', '\n', '        require(now < series.expiration);\n', '        require(openInterest[_series] >= amount);\n', '        require(_series.call(BURN, msg.sender, amount));\n', '\n', '        uint usd = amount * series.strike;\n', '        require(usd / amount == series.strike);\n', '        usd /= 1 ether;\n', '\n', '        openInterest[_series] -= amount;\n', '        earlyExercised[_series] += amount;\n', '\n', '        if (series.flavor == Flavor.Call) {\n', '            msg.sender.transfer(amount);\n', '            require(msg.value == 0);\n', '            require(usdERC20.transferFrom(msg.sender, this, usd));\n', '        } else {\n', '            require(msg.value == amount);\n', '            require(usdERC20.transfer(msg.sender, usd));\n', '        }\n', '    }\n', '    \n', '    function receive() public payable {\n', '        require(expectValue[msg.sender] == msg.value);\n', '        expectValue[msg.sender] = 0;\n', '    }\n', '\n', '    function bid(address _series, uint amount) public payable {\n', '\n', '        require(isAuction == false);\n', '        isAuction = true;\n', '\n', '        OptionSeries memory series = seriesInfo[_series];\n', '\n', '        uint start = series.expiration;\n', '        uint time = now + _timePreference(msg.sender);\n', '\n', '        require(time > start);\n', '        require(time < start + DURATION);\n', '\n', '        uint elapsed = time - start;\n', '\n', '        amount = _min(amount, openInterest[_series]);\n', '\n', '        if ((now - deployed) / 1 weeks < 8) {\n', '            _grantReward(msg.sender, amount);\n', '        }\n', '\n', '        openInterest[_series] -= amount;\n', '\n', '        uint offer;\n', '        uint givGet;\n', '        bool result;\n', '\n', '        if (series.flavor == Flavor.Call) {\n', '            require(msg.value == 0);\n', '\n', '            offer = (series.strike * DURATION) / elapsed;\n', '            givGet = offer * amount / 1 ether;\n', '            holdersSettlement[_series] += givGet - amount * series.strike / 1 ether;\n', '\n', '            bool hasFunds = usdERC20.balanceOf(msg.sender) >= givGet && usdERC20.allowance(msg.sender, this) >= givGet;\n', '\n', '            if (hasFunds) {\n', '                msg.sender.transfer(amount);\n', '            } else {\n', '                result = msg.sender.call.value(amount)(RECEIVE_ETH, _series, amount);\n', '                require(result);\n', '            }\n', '\n', '            require(usdERC20.transferFrom(msg.sender, this, givGet));\n', '        } else {\n', '            offer = (DURATION * 1 ether * 1 ether) / (series.strike * elapsed);\n', '            givGet = (amount * 1 ether) / offer;\n', '\n', '            holdersSettlement[_series] += amount * series.strike / 1 ether - givGet;\n', '            require(usdERC20.transfer(msg.sender, givGet));\n', '\n', '            if (msg.value == 0) {\n', '                require(expectValue[msg.sender] == 0);\n', '                expectValue[msg.sender] = amount;\n', '\n', '                result = msg.sender.call(RECEIVE_USD, _series, givGet);\n', '                require(result);\n', '                require(expectValue[msg.sender] == 0);\n', '            } else {\n', '                require(msg.value >= amount);\n', '                msg.sender.transfer(msg.value - amount);\n', '            }\n', '        }\n', '\n', '        isAuction = false;\n', '    }\n', '\n', '    function redeem(address _series) public {\n', '        OptionSeries memory series = seriesInfo[_series];\n', '\n', '        require(now > series.expiration + DURATION);\n', '\n', '        uint unsettledPercent = openInterest[_series] * 1 ether / totalInterest[_series];\n', '        uint exercisedPercent = (totalInterest[_series] - openInterest[_series]) * 1 ether / totalInterest[_series];\n', '        uint owed;\n', '\n', '        if (series.flavor == Flavor.Call) {\n', '            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\n', '            if (owed > 0) {\n', '                msg.sender.transfer(owed);\n', '            }\n', '\n', '            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\n', '            owed = owed * series.strike / 1 ether;\n', '            if (owed > 0) {\n', '                require(usdERC20.transfer(msg.sender, owed));\n', '            }\n', '        } else {\n', '            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\n', '            owed = owed * series.strike / 1 ether;\n', '            if (owed > 0) {\n', '                require(usdERC20.transfer(msg.sender, owed));\n', '            }\n', '\n', '            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\n', '            if (owed > 0) {\n', '                msg.sender.transfer(owed);\n', '            }\n', '        }\n', '\n', '        writers[_series][msg.sender] = 0;\n', '    }\n', '\n', '    function settle(address _series) public {\n', '        OptionSeries memory series = seriesInfo[_series];\n', '        require(now > series.expiration + DURATION);\n', '\n', '        uint bal = ERC20x(_series).balanceOf(msg.sender);\n', '        require(_series.call(BURN, msg.sender, bal));\n', '\n', '        uint percent = bal * 1 ether / (totalInterest[_series] - earlyExercised[_series]);\n', '        uint owed = holdersSettlement[_series] * percent / 1 ether;\n', '        require(usdERC20.transfer(msg.sender, owed));\n', '    }\n', '\n', '    function _timePreference(address from) public view returns (uint) {\n', '        return (_unsLn(_preference(from) * 1000000 + 1 ether) * 171) / 1 ether;\n', '    }\n', '\n', '    function _grantReward(address to, uint amount) private {\n', '        uint percentOfMax = _preference(to) * 1 ether / PREFERENCE_MAX;\n', '        require(percentOfMax <= 1 ether);\n', '        uint percentGrant = 1 ether - percentOfMax;\n', '\n', '\n', '        uint elapsed = (now - deployed) / 1 weeks;\n', '        elapsed = _min(elapsed, 7);\n', '        uint div = 10**elapsed;\n', '        uint reward = percentGrant * (amount * (ONE_MILLION / div)) / 1 ether;\n', '\n', '        require(address(protocolToken).call(GRANT, to, reward));\n', '    }\n', '\n', '    function _preference(address from) public view returns (uint) {\n', '        return _min(\n', '            protocolToken.balanceOf(from) * 1 ether / protocolToken.totalSupply(),\n', '            PREFERENCE_MAX\n', '        );\n', '    }\n', '\n', '    function _min(uint a, uint b) pure public returns (uint) {\n', '        if (a > b)\n', '            return b;\n', '        return a;\n', '    }\n', '\n', '    function _max(uint a, uint b) pure public returns (uint) {\n', '        if (a > b)\n', '            return a;\n', '        return b;\n', '    }\n', '    \n', '    function _seriesHash(uint expiration, Flavor flavor, uint strike) public pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(expiration, flavor, strike));\n', '    }\n', '\n', '    function _monthName(uint month) public pure returns (string) {\n', '        string[12] memory names = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];\n', '        return names[month-1];\n', '    }\n', '\n', '    function _unsLn(uint x) pure public returns (uint log) {\n', '        log = 0;\n', '        \n', "        // not a true ln function, we can't represent the negatives\n", '        if (x < 1 ether)\n', '            return 0;\n', '\n', '        while (x >= 1.5 ether) {\n', '            log += 0.405465 ether;\n', '            x = x * 2 / 3;\n', '        }\n', '        \n', '        x = x - 1 ether;\n', '        uint y = x;\n', '        uint i = 1;\n', '\n', '        while (i < 10) {\n', '            log += (y / i);\n', '            i = i + 1;\n', '            y = y * x / 1 ether;\n', '            log -= (y / i);\n', '            i = i + 1;\n', '            y = y * x / 1 ether;\n', '        }\n', '         \n', '        return(log);\n', '    }\n', '\n', '    function uint2str(uint i) internal pure returns (string){\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}']