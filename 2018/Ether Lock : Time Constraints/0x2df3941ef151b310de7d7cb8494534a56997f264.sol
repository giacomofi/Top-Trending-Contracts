['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Wallet is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    LotteryData public lotteryData;\n', '\n', '    uint256 public minPaymnent = 10**16;\n', '\n', '    function setMinPayment(uint256 value) public onlyOwner {\n', '        minPaymnent = value;\n', '    }\n', '\n', '    constructor() public {\n', '        lotteryData = LotteryData(msg.sender);\n', '    }\n', '\n', '    function() payable external {\n', '        require(msg.value >= minPaymnent);\n', '        lotteryData.participate(msg.sender, msg.value);\n', '    }\n', '\n', '    function finishDay() external returns(uint256) {\n', '        require(msg.sender == address(lotteryData));\n', '        uint256 balance = address(this).balance;\n', '        if (balance >= minPaymnent) {\n', '            lotteryData.getFunds.value(balance)();\n', '            return balance;\n', '        }\n', '        else {\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', 'contract LotteryData is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    event Withdrawn(address indexed payee, uint256 weiAmount);\n', '    event Deposited(address indexed payee, uint256 weiAmount);\n', '    event WinnerWallet(address indexed wallet, uint256 bank);\n', '\n', '    Wallet public wallet_0 = new Wallet();\n', '    Wallet public wallet_1 = new Wallet();\n', '    Wallet public wallet_2 = new Wallet();\n', '\n', '    uint256 public finishTime;\n', '    uint256 constant roundTime = 86400;\n', '\n', '    uint internal dilemma;\n', '    uint internal max_participators = 100;\n', '    uint internal participators;\n', '    uint internal randNonce = 19;\n', '    uint internal winner;\n', '    uint internal winner_1;\n', '    uint internal winner_2;\n', '    uint256 internal fund;\n', '    uint256 internal commission;\n', '    uint256 internal totalBetsWithoutCommission;\n', '\n', '    mapping(uint => address) public wallets;\n', '    mapping(address => mapping (address => uint256)) public playersBets;\n', '    mapping(address => mapping (uint => address)) public players;\n', '    mapping(address => uint256) public totalBets;\n', '    mapping(address => uint) public totalPlayers;\n', '    mapping(address => uint256) private _deposits;\n', '\n', '    //monitoring part\n', '    uint public games;\n', '\n', '    struct wins{\n', '        address winner;\n', '        uint256 time;\n', '    }\n', '\n', '    mapping(uint => wins) public gamesLog;\n', '\n', '    constructor() public {\n', '        wallets[0] = address(wallet_0);\n', '        wallets[1] = address(wallet_1);\n', '        wallets[2] = address(wallet_2);\n', '        finishTime = now.add(roundTime);\n', '    }\n', '\n', '    modifier validWallets() {\n', '        require(\n', '            msg.sender == address(wallet_0) ||\n', '            msg.sender == address(wallet_1) ||\n', '            msg.sender == address(wallet_2)\n', '        );\n', '        _;\n', '    }\n', '\n', '    function depositsOf(address payee) public view returns (uint256) {\n', '        return _deposits[payee];\n', '    }\n', '\n', '    function deposit(address payee, uint256 amount) internal {\n', '        _deposits[payee] = _deposits[payee].add(amount);\n', '        emit Deposited(payee, amount);\n', '    }\n', '\n', '    function getFunds() public payable validWallets {}\n', '\n', '    function lastWinner() public view returns(address) {\n', '        return gamesLog[games].winner;\n', '    }\n', '\n', '    function getRandomWallet() internal returns(uint) {\n', '        uint result = uint(keccak256(abi.encodePacked(now, randNonce, blockhash(block.number - 1)))) % 3;\n', '        randNonce = randNonce.add(result.add(2));\n', '        return result;\n', '    }\n', '\n', '    function _fundriser() internal returns(uint256) {\n', '        fund = fund.add(wallet_0.finishDay());\n', '        fund = fund.add(wallet_1.finishDay());\n', '        return fund.add(wallet_2.finishDay());\n', '    }\n', '\n', '    function _randomizer() internal returns(uint) {\n', '        // random choose one of three wallets\n', '        winner = getRandomWallet();\n', '        // check if this address had payments, if no solving it\n', '        if(totalPlayers[wallets[winner]] == 0) {\n', '            dilemma = uint(keccak256(abi.encodePacked(now, winner, blockhash(block.number - 1)))) % 2;\n', '            if(winner == 0) {\n', '                if(dilemma == 1) {\n', '                    winner_1 = 2;\n', '                    winner_2 = 1;\n', '                } else {\n', '                    winner_1 = 1;\n', '                    winner_2 = 2;\n', '                }\n', '            }\n', '            if(winner == 1) {\n', '                if(dilemma == 1) {\n', '                    winner_1 = 2;\n', '                    winner_2 = 0;\n', '                } else {\n', '                    winner_1 = 0;\n', '                    winner_2 = 2;\n', '                }\n', '            }\n', '            if(winner == 2) {\n', '                if(dilemma == 1) {\n', '                    winner_1 = 1;\n', '                    winner_2 = 0;\n', '                } else {\n', '                    winner_1 = 0;\n', '                    winner_2 = 1;\n', '                }\n', '            }\n', '            winner = (totalPlayers[wallets[winner_1]] == 0) ? winner_2 : winner_1;\n', '        }\n', '\n', '        return winner;\n', '    }\n', '\n', '    function _distribute() internal {\n', '        // calculate commission\n', '        commission = fund.mul(15).div(100);\n', '        totalBetsWithoutCommission = fund.sub(commission);\n', '        deposit(owner, commission);\n', '        // calculate and make deposits\n', '        for (uint i = 0; i < totalPlayers[wallets[winner]]; i++) {\n', '            uint percents = playersBets[wallets[winner]][players[wallets[winner]][i]].mul(10000).div(totalBets[wallets[winner]]);\n', '            deposit(players[wallets[winner]][i], totalBetsWithoutCommission.mul(percents).div(10000));\n', '        }\n', '    }\n', '\n', '    function _collector() internal {\n', '        fund = 0;\n', '        participators = 0;\n', '        totalBets[wallets[0]] = 0;\n', '        for (uint j = 0; j < 3; j++) {\n', '            for (uint k = 0; k < totalPlayers[wallets[j]]; k++) {\n', '                playersBets[wallets[j]][players[wallets[j]][k]] = 0;\n', '                players[wallets[j]][k] = address(0x0);\n', '            }\n', '            totalBets[wallets[j]] = 0;\n', '            totalPlayers[wallets[j]] = 0;\n', '        }\n', '    }\n', '\n', '    function _logger(address _winner, uint256 _fund) internal {\n', '        games = games + 1;\n', '        gamesLog[games].winner =_winner;\n', '        gamesLog[games].time = now;\n', '        emit WinnerWallet(_winner, _fund);\n', '    }\n', '\n', '    function participate(address player, uint256 amount) external validWallets {\n', '        if (now >= finishTime || participators >= max_participators) {\n', '            // send all funds to this wallet\n', '            fund = _fundriser();\n', '            // if it has participators\n', '            if(fund > 0) {\n', '                // get winner\n', '                winner = _randomizer();\n', '                // _distribute\n', '                _distribute();\n', '                // clear state\n', '                _collector();\n', '                // log data\n', '                _logger(wallets[winner], fund);\n', '            }\n', '            // update round\n', '            finishTime = finishTime.add(roundTime);\n', '        }\n', '\n', '        if (playersBets[msg.sender][player] == 0) {\n', '            players[msg.sender][totalPlayers[msg.sender]] = player;\n', '            totalPlayers[msg.sender] = totalPlayers[msg.sender].add(1);\n', '            participators = participators.add(1);\n', '        }\n', '        playersBets[msg.sender][player] = playersBets[msg.sender][player].add(amount);\n', '        totalBets[msg.sender] = totalBets[msg.sender].add(amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw accumulated balance for a payee.\n', '    */\n', '    function withdraw() public {\n', '        uint256 payment = _deposits[msg.sender];\n', '        _deposits[msg.sender] = 0;\n', '        msg.sender.transfer(payment);\n', '        emit Withdrawn(msg.sender, payment);\n', '    }\n', '\n', '    function paymentValidator(address _payee, uint256 _amount) internal {\n', '        if(_payee != address(wallet_0) &&\n', '           _payee != address(wallet_1) &&\n', '           _payee != address(wallet_2))\n', '        {\n', '            if(_amount == uint(0)) {\n', '                if(depositsOf(_payee) != uint(0)) {\n', '                    withdraw();\n', '                } else {\n', '                    revert("You have zero balance");\n', '                }\n', '            } else {\n', '                revert("You can\'t do nonzero transaction");\n', '            }\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        paymentValidator(msg.sender, msg.value);\n', '    }\n', '}']