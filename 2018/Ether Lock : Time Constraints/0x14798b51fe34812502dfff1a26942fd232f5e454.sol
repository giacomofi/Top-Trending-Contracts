['pragma solidity ^0.4.21;\n', '\n', 'contract EIP20Interface {\n', '    function name() public view returns (string);\n', '    \n', '    function symbol() public view returns (string);\n', '    \n', '    function decimals() public view returns (uint8);\n', '    \n', '    function totalSupply() public view returns (uint256);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract EIP20 is EIP20Interface {\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    /*\n', '    NOTE:\n', '    The following variables are OPTIONAL vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public tokenName;                   //fancy name: eg Simon Bucks\n', '    uint8 public tokenDecimals;                //How many decimals to show.\n', '    string public tokenSymbol;                 //An identifier: eg SBX\n', '    uint256 public tokenTotalSupply;\n', '\n', '    constructor(\n', '        uint256 _initialAmount,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol\n', '    ) public {\n', '        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n', '        tokenTotalSupply = _initialAmount;                        // Update total supply\n', '        tokenName = _tokenName;                                   // Set the name for display purposes\n', '        tokenDecimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        tokenSymbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '    }\n', '    \n', '    function name() public view returns (string) {\n', '        return tokenName;\n', '    }\n', '    \n', '    function symbol() public view returns (string) {\n', '        return tokenSymbol;\n', '    }\n', '    \n', '    function decimals() public view returns (uint8) {\n', '        return tokenDecimals;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenTotalSupply;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TimeBankToken is EIP20 {\n', '  using SafeMath for uint;\n', '\n', '  struct Vesting {\n', '    uint256 startTime; // vesting start time\n', '    uint256 initReleaseAmount;\n', '    uint256 amount;\n', '    uint256 interval; // release N% of amount each interval.\n', '    uint256 periods; // count of periods\n', '    uint256 withdrawed; // already used amount of released part\n', '  }\n', '\n', '  mapping (address => Vesting[]) vestings;\n', '  \n', '  address[] managerList;\n', '  mapping (address => bool) managers;\n', '  mapping (bytes32 => mapping (address => bool)) confirms;\n', '  \n', '  /*\n', '  at least <threshold> confirmations\n', '  */\n', '  uint majorityThreshold;\n', '  uint managementThreshold;\n', '\n', '  address coinbase;\n', '  address master;\n', '  bool public paused;\n', '\n', '  function checkAddress(address _addr) internal pure returns (bool) {\n', '    return _addr != address(0);\n', '  }\n', '\n', '  // 1 with 28 zeros\n', '  constructor(address _master, address[] _managers, uint _majorityThreshold, uint _managementThreshold) EIP20(10000000000000000000000000000, "Time Bank Token", 18, "TBT") public {\n', '    require(checkAddress(_master));\n', '    require(_managers.length >= _majorityThreshold);\n', '    require(_managers.length >= _managementThreshold);\n', '    \n', '    paused = false;\n', '    master = _master;\n', '    coinbase = msg.sender;\n', '    majorityThreshold = _majorityThreshold;\n', '    managementThreshold = _managementThreshold;\n', '\n', '    for (uint i=0; i<_managers.length; i++) {\n', '      require(checkAddress(_managers[i]));\n', '      managers[_managers[i]] = true;\n', '    }\n', '    managerList = _managers;\n', '\n', '    // initial batch operations\n', '    // internalPresaleVesting(0x0095F9DffeE386B650230eD3eC28891c1053aBE0, 10000, 60, 120, 240);\n', '    // internalPresaleVesting(0x00D4fC2CC18B96c44D9755afB6D4e6804cF827ee, 20000, 60, 120, 240);\n', '    // internalPresale(0x0092E41D42E834705fd07c9136Fd0b1028226bE3, 30000);\n', '  }\n', '\n', '  function pause() public isMaster isNotPaused {\n', '    require(isEnoughConfirmed(msg.data, 1));\n', '    paused = true;\n', '  }\n', '\n', '  function resume() public isMaster isPaused {\n', '    require(isEnoughConfirmed(msg.data, 1));\n', '    paused = false;\n', '  }\n', '\n', '  modifier isPaused {\n', '    require(paused == true);\n', '    _;\n', '  }\n', '\n', '  modifier isNotPaused {\n', '    require(paused == false);\n', '    _;\n', '  }\n', '\n', '  modifier isManager {\n', '    require(managers[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier isMaster {\n', '    require(msg.sender == master);\n', '    _;\n', '  }\n', '\n', '  modifier isNotCoinbase {\n', '    require(msg.sender != coinbase);\n', '    _;\n', '  }\n', '\n', '  function managersCount() public view returns (uint) {\n', '    return managerList.length;\n', '  }\n', '\n', '  function isAddressManager(address _to) public view returns (bool) {\n', '    return managers[_to];\n', '  }\n', '\n', '  function getMajorityThreshold() public view  returns (uint) {\n', '    return majorityThreshold;\n', '  }\n', '\n', '  event MajorityThresholdChanged(uint oldThreshold, uint newThreshold);\n', '  event ReplaceManager(address oldAddr, address newAddr);\n', '  event RemoveManager(address manager);\n', '  event AddManager(address manager);\n', '\n', '  function setMajorityThreshold(uint _threshold) public isMaster isNotPaused {\n', '    require(_threshold > 0);\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    uint oldThreshold = majorityThreshold;\n', '    majorityThreshold = _threshold;\n', '    removeConfirm(msg.data);\n', '    emit MajorityThresholdChanged(oldThreshold, majorityThreshold);\n', '  }\n', '\n', '  function replaceManager(address _old, address _new) public isMaster isNotPaused {\n', '    require(checkAddress(_old));\n', '    require(checkAddress(_new));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    internalRemoveManager(_old);\n', '    internalAddManager(_new);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit ReplaceManager(_old, _new);\n', '  }\n', '\n', '  function removeManager(address _manager) public isMaster isNotPaused {\n', '    require(checkAddress(_manager));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    require(managerList.length > managementThreshold);\n', '    internalRemoveManager(_manager);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit RemoveManager(_manager);\n', '  }\n', '\n', '  function internalRemoveManager(address _manager) internal {\n', '    require(checkAddress(_manager));\n', '    managers[_manager] = false;\n', '  }\n', '\n', '  function addManager(address _manager) public isMaster isNotPaused {\n', '    require(checkAddress(_manager));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    internalAddManager(_manager);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit AddManager(_manager);\n', '  }\n', '\n', '  function internalAddManager(address _manager) internal {\n', '    require(checkAddress(_manager));\n', '    managers[_manager] = true;\n', '    managerList.push(_manager);\n', '  }\n', '\n', '  mapping (address => bool) checked;\n', '\n', '  function rebuildManagerList() internal {\n', '    address[] memory res = new address[](managerList.length);\n', '    for (uint k=0; k<managerList.length; k++) {\n', '      checked[managerList[k]] = false;\n', '    }\n', '    uint j=0;\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      address manager = managerList[i];\n', '      if (managers[manager] && checked[manager] == false) {\n', '        res[j] = manager;\n', '        checked[manager] = true;\n', '        j++;\n', '      }\n', '    }\n', '    managerList = res;\n', '    managerList.length = j;\n', '  }\n', '\n', '  function checkData(bytes data) internal pure returns (bool) {\n', '    return data.length != 0;\n', '  }\n', '\n', '  event Confirm(address manager, bytes data);\n', '  event Revoke(address manager, bytes data);\n', '\n', '  /*\n', '  manager use this function to confirm a operation\n', '  confirm will not be call inside other functions, so it can be external to save some gas\n', '  @param {bytes} data is the transaction&#39;s raw input\n', '  */\n', '  function confirm(bytes data) external isManager {\n', '    checkData(data);\n', '    bytes32 op = keccak256(data);\n', '    if (confirms[op][msg.sender] == false) {\n', '      confirms[op][msg.sender] = true;\n', '    }\n', '    emit Confirm(msg.sender, data);\n', '  }\n', '\n', '  /*\n', '  manager use this function to revoke a confirm of the operation\n', '  revoke will not be call inside other functions, so it can be external to save some gas\n', '  @param {bytes} data is the transaction&#39;s raw input\n', '  */\n', '  function revoke(bytes data) external isManager {\n', '    checkData(data);\n', '    bytes32 op = keccak256(data);\n', '    if (confirms[op][msg.sender] == true) {\n', '      confirms[op][msg.sender] = false;\n', '    }\n', '    emit Revoke(msg.sender, data);\n', '  }\n', '\n', '  /*\n', '  check a operation is confirmed or not\n', '  */\n', '  function isConfirmed(bytes data) public view isManager returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    return confirms[op][msg.sender];\n', '  }\n', '\n', '  function isConfirmedBy(bytes data, address manager) public view returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    return confirms[op][manager];\n', '  } \n', '\n', '  function isMajorityConfirmed(bytes data) public view returns (bool) {\n', '    return isEnoughConfirmed(data, majorityThreshold);\n', '  }\n', '\n', '  function isEnoughConfirmed(bytes data, uint count) internal view returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    uint confirmsCount = 0;\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      if (confirms[op][managerList[i]] == true) {\n', '        confirmsCount = confirmsCount.add(1);\n', '      }\n', '    }\n', '    return confirmsCount >= count;\n', '  }\n', '\n', '  /*\n', '  once the operation is executed, the confirm of the operation should be removed\n', '  */\n', '  function removeConfirm(bytes data) internal {\n', '    bytes32 op = keccak256(data);\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      confirms[op][managerList[i]] = false;\n', '    }\n', '  }\n', '\n', '  /*\n', '  sale coin with time locking\n', '  only the manager can call this function\n', '  and this operation should be confirmed\n', '  */\n', '  function presaleVesting(address _to, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) public isManager isNotPaused {\n', '    checkAddress(_to);\n', '    require(isMajorityConfirmed(msg.data));\n', '    internalPresaleVesting(_to, _startTime, _initReleaseAmount, _amount, _interval, _periods);\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function batchPresaleVesting(address[] _to, uint256[] _startTime, uint256[] _initReleaseAmount, uint256[] _amount, uint256[] _interval, uint256[] _periods) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    for (uint i=0; i<_to.length; i++) {\n', '      internalPresaleVesting(_to[i], _startTime[i], _initReleaseAmount[i], _amount[i], _interval[i], _periods[i]);\n', '    }\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function internalPresaleVesting(address _to, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) internal {\n', '    require(balances[coinbase] >= _amount);\n', '    require(_initReleaseAmount <= _amount);\n', '    require(checkAddress(_to));\n', '    vestings[_to].push(Vesting(\n', '      _startTime, _initReleaseAmount, _amount, _interval, _periods, 0\n', '    ));\n', '    balances[coinbase] = balances[coinbase].sub(_amount);\n', '    emit PresaleVesting(_to, _startTime, _amount, _interval, _periods);\n', '  }\n', '\n', '  /*\n', '  sale coin without time locking\n', '  only the manager can call this function\n', '  and this operation should be confirmed\n', '  */\n', '  function presale(address _to, uint256 _value) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    internalPresale(_to, _value);\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function batchPresale(address[] _to, uint256[] _amount) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    for (uint i=0; i<_to.length; i++) {\n', '      internalPresale(_to[i], _amount[i]);\n', '    }\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function internalPresale(address _to, uint256 _value) internal {\n', '    require(balances[coinbase] >= _value);\n', '    require(checkAddress(_to));\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[coinbase] = balances[coinbase].sub(_value);\n', '    emit Presale(_to, _value);\n', '  }\n', '\n', '  /*\n', '  events\n', '  */\n', '  event Presale(address indexed to, uint256 value);\n', '  event PresaleVesting(address indexed to, uint256 startTime, uint256 amount, uint256 interval, uint256 periods);\n', '\n', '  /*\n', '  math function used to calculate vesting curve\n', '  */\n', '  function vestingFunc(uint256 _currentTime, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) public pure returns (uint256) {\n', '    if (_currentTime < _startTime) {\n', '      return 0;\n', '    }\n', '    uint256 t = _currentTime.sub(_startTime);\n', '    uint256 end = _periods.mul(_interval);\n', '    if (t >= end) {\n', '      return _amount;\n', '    }\n', '    uint256 i_amount = _amount.sub(_initReleaseAmount).div(_periods);\n', '    uint256 i = t.div(_interval);\n', '    return i_amount.mul(i).add(_initReleaseAmount);\n', '  }\n', '\n', '  function queryWithdrawed(uint _idx) public view returns (uint256) {\n', '    return vestings[msg.sender][_idx].withdrawed;\n', '  }\n', '\n', '  function queryVestingRemain(uint256 _currentTime, uint _idx) public view returns (uint256) {\n', '    uint256 released = vestingFunc(\n', '      _currentTime,\n', '      vestings[msg.sender][_idx].startTime, vestings[msg.sender][_idx].initReleaseAmount, vestings[msg.sender][_idx].amount,\n', '      vestings[msg.sender][_idx].interval, vestings[msg.sender][_idx].periods\n', '    );\n', '    return released.sub(vestings[msg.sender][_idx].withdrawed);\n', '  }\n', '\n', '  /*\n', '  calculate the released amount of vesting coin\n', '  it cannot be view, because this function relays on &#39;now&#39;\n', '  */\n', '  function vestingReleased(uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) internal view returns (uint256) {\n', '    return vestingFunc(now, _startTime, _initReleaseAmount, _amount, _interval, _periods);\n', '  }\n', '\n', '  /*\n', '  withdraw all released vesting coin to balance\n', '  */\n', '  function withdrawVestings(address _to) internal {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      if (vestings[_to][i].amount == vestings[_to][i].withdrawed) {\n', '        continue;\n', '      }\n', '\n', '      uint256 released = vestingReleased(\n', '        vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount,\n', '        vestings[_to][i].interval, vestings[_to][i].periods\n', '      );\n', '      uint256 remain = released.sub(vestings[_to][i].withdrawed);\n', '      if (remain >= 0) {\n', '        vestings[_to][i].withdrawed = released;\n', '        sum = sum.add(remain);\n', '      }\n', '    }\n', '    balances[_to] = balances[_to].add(sum);\n', '  }\n', '\n', '  /*\n', '  sum of all vestings balance (regardless of released or not)\n', '  each vesting is amount - withdrawed\n', '  */\n', '  function vestingsBalance(address _to) public view returns (uint256) {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      sum = sum.add(vestings[_to][i].amount.sub(vestings[_to][i].withdrawed));\n', '    }\n', '    return sum;\n', '  }\n', '\n', '  /*\n', '  sum of all remaining vestings balance (only the released part)\n', '  released - withdrawed\n', '  */\n', '  function vestingsReleasedRemain(address _to) internal view returns (uint256) {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      uint256 released = vestingReleased(\n', '        vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount,\n', '        vestings[_to][i].interval, vestings[_to][i].periods\n', '      );\n', '      sum = sum.add(released.sub(vestings[_to][i].withdrawed));\n', '    }\n', '    return sum;\n', '  }\n', '\n', '  /*\n', '  total balance\n', '  sum of vestings balance (includes not released part) and unlocking coin balance\n', '  */\n', '  function balanceOf(address _to) public view returns (uint256) {\n', '    uint256 vbalance = vestingsBalance(_to);\n', '    return vbalance.add(super.balanceOf(_to));\n', '  }\n', '\n', '  /*\n', '  sum of vestings balance and unlocking coin balance\n', '  */\n', '  function vestingsRemainBalance(address _to) internal view returns (uint256) {\n', '    return vestingsReleasedRemain(_to).add(super.balanceOf(_to));\n', '  }\n', '\n', '  /*\n', '  transfer <_value> coin from <msg.sender> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function transfer(address _to, uint256 _value) public isNotCoinbase isNotPaused returns (bool) {\n', '    checkAddress(_to);\n', '    uint256 remain = vestingsRemainBalance(msg.sender);\n', '    require(remain >= _value);\n', '    withdrawVestings(msg.sender);\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /*\n', '  transferFrom <_value> coin from <_from> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _value) public isNotPaused returns (bool) {\n', '    checkAddress(_from);\n', '    checkAddress(_to);\n', '    uint256 remain = vestingsRemainBalance(_from);\n', '    require(remain >= _value);\n', '    withdrawVestings(_from);\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /*\n', '  approve <_value> coin from <_from> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function approve(address _spender, uint256 _value) public isNotCoinbase isNotPaused returns (bool) {\n', '    checkAddress(_spender);\n', '    uint256 remain = vestingsRemainBalance(msg.sender);\n', '    require(remain >= _value);\n', '    withdrawVestings(msg.sender);\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return super.allowance(_owner, _spender);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract EIP20Interface {\n', '    function name() public view returns (string);\n', '    \n', '    function symbol() public view returns (string);\n', '    \n', '    function decimals() public view returns (uint8);\n', '    \n', '    function totalSupply() public view returns (uint256);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract EIP20 is EIP20Interface {\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    /*\n', '    NOTE:\n', '    The following variables are OPTIONAL vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public tokenName;                   //fancy name: eg Simon Bucks\n', '    uint8 public tokenDecimals;                //How many decimals to show.\n', '    string public tokenSymbol;                 //An identifier: eg SBX\n', '    uint256 public tokenTotalSupply;\n', '\n', '    constructor(\n', '        uint256 _initialAmount,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol\n', '    ) public {\n', '        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n', '        tokenTotalSupply = _initialAmount;                        // Update total supply\n', '        tokenName = _tokenName;                                   // Set the name for display purposes\n', '        tokenDecimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        tokenSymbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '    }\n', '    \n', '    function name() public view returns (string) {\n', '        return tokenName;\n', '    }\n', '    \n', '    function symbol() public view returns (string) {\n', '        return tokenSymbol;\n', '    }\n', '    \n', '    function decimals() public view returns (uint8) {\n', '        return tokenDecimals;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenTotalSupply;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TimeBankToken is EIP20 {\n', '  using SafeMath for uint;\n', '\n', '  struct Vesting {\n', '    uint256 startTime; // vesting start time\n', '    uint256 initReleaseAmount;\n', '    uint256 amount;\n', '    uint256 interval; // release N% of amount each interval.\n', '    uint256 periods; // count of periods\n', '    uint256 withdrawed; // already used amount of released part\n', '  }\n', '\n', '  mapping (address => Vesting[]) vestings;\n', '  \n', '  address[] managerList;\n', '  mapping (address => bool) managers;\n', '  mapping (bytes32 => mapping (address => bool)) confirms;\n', '  \n', '  /*\n', '  at least <threshold> confirmations\n', '  */\n', '  uint majorityThreshold;\n', '  uint managementThreshold;\n', '\n', '  address coinbase;\n', '  address master;\n', '  bool public paused;\n', '\n', '  function checkAddress(address _addr) internal pure returns (bool) {\n', '    return _addr != address(0);\n', '  }\n', '\n', '  // 1 with 28 zeros\n', '  constructor(address _master, address[] _managers, uint _majorityThreshold, uint _managementThreshold) EIP20(10000000000000000000000000000, "Time Bank Token", 18, "TBT") public {\n', '    require(checkAddress(_master));\n', '    require(_managers.length >= _majorityThreshold);\n', '    require(_managers.length >= _managementThreshold);\n', '    \n', '    paused = false;\n', '    master = _master;\n', '    coinbase = msg.sender;\n', '    majorityThreshold = _majorityThreshold;\n', '    managementThreshold = _managementThreshold;\n', '\n', '    for (uint i=0; i<_managers.length; i++) {\n', '      require(checkAddress(_managers[i]));\n', '      managers[_managers[i]] = true;\n', '    }\n', '    managerList = _managers;\n', '\n', '    // initial batch operations\n', '    // internalPresaleVesting(0x0095F9DffeE386B650230eD3eC28891c1053aBE0, 10000, 60, 120, 240);\n', '    // internalPresaleVesting(0x00D4fC2CC18B96c44D9755afB6D4e6804cF827ee, 20000, 60, 120, 240);\n', '    // internalPresale(0x0092E41D42E834705fd07c9136Fd0b1028226bE3, 30000);\n', '  }\n', '\n', '  function pause() public isMaster isNotPaused {\n', '    require(isEnoughConfirmed(msg.data, 1));\n', '    paused = true;\n', '  }\n', '\n', '  function resume() public isMaster isPaused {\n', '    require(isEnoughConfirmed(msg.data, 1));\n', '    paused = false;\n', '  }\n', '\n', '  modifier isPaused {\n', '    require(paused == true);\n', '    _;\n', '  }\n', '\n', '  modifier isNotPaused {\n', '    require(paused == false);\n', '    _;\n', '  }\n', '\n', '  modifier isManager {\n', '    require(managers[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier isMaster {\n', '    require(msg.sender == master);\n', '    _;\n', '  }\n', '\n', '  modifier isNotCoinbase {\n', '    require(msg.sender != coinbase);\n', '    _;\n', '  }\n', '\n', '  function managersCount() public view returns (uint) {\n', '    return managerList.length;\n', '  }\n', '\n', '  function isAddressManager(address _to) public view returns (bool) {\n', '    return managers[_to];\n', '  }\n', '\n', '  function getMajorityThreshold() public view  returns (uint) {\n', '    return majorityThreshold;\n', '  }\n', '\n', '  event MajorityThresholdChanged(uint oldThreshold, uint newThreshold);\n', '  event ReplaceManager(address oldAddr, address newAddr);\n', '  event RemoveManager(address manager);\n', '  event AddManager(address manager);\n', '\n', '  function setMajorityThreshold(uint _threshold) public isMaster isNotPaused {\n', '    require(_threshold > 0);\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    uint oldThreshold = majorityThreshold;\n', '    majorityThreshold = _threshold;\n', '    removeConfirm(msg.data);\n', '    emit MajorityThresholdChanged(oldThreshold, majorityThreshold);\n', '  }\n', '\n', '  function replaceManager(address _old, address _new) public isMaster isNotPaused {\n', '    require(checkAddress(_old));\n', '    require(checkAddress(_new));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    internalRemoveManager(_old);\n', '    internalAddManager(_new);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit ReplaceManager(_old, _new);\n', '  }\n', '\n', '  function removeManager(address _manager) public isMaster isNotPaused {\n', '    require(checkAddress(_manager));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    require(managerList.length > managementThreshold);\n', '    internalRemoveManager(_manager);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit RemoveManager(_manager);\n', '  }\n', '\n', '  function internalRemoveManager(address _manager) internal {\n', '    require(checkAddress(_manager));\n', '    managers[_manager] = false;\n', '  }\n', '\n', '  function addManager(address _manager) public isMaster isNotPaused {\n', '    require(checkAddress(_manager));\n', '    require(isEnoughConfirmed(msg.data, managementThreshold));\n', '    internalAddManager(_manager);\n', '    rebuildManagerList();\n', '    removeConfirm(msg.data);\n', '    emit AddManager(_manager);\n', '  }\n', '\n', '  function internalAddManager(address _manager) internal {\n', '    require(checkAddress(_manager));\n', '    managers[_manager] = true;\n', '    managerList.push(_manager);\n', '  }\n', '\n', '  mapping (address => bool) checked;\n', '\n', '  function rebuildManagerList() internal {\n', '    address[] memory res = new address[](managerList.length);\n', '    for (uint k=0; k<managerList.length; k++) {\n', '      checked[managerList[k]] = false;\n', '    }\n', '    uint j=0;\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      address manager = managerList[i];\n', '      if (managers[manager] && checked[manager] == false) {\n', '        res[j] = manager;\n', '        checked[manager] = true;\n', '        j++;\n', '      }\n', '    }\n', '    managerList = res;\n', '    managerList.length = j;\n', '  }\n', '\n', '  function checkData(bytes data) internal pure returns (bool) {\n', '    return data.length != 0;\n', '  }\n', '\n', '  event Confirm(address manager, bytes data);\n', '  event Revoke(address manager, bytes data);\n', '\n', '  /*\n', '  manager use this function to confirm a operation\n', '  confirm will not be call inside other functions, so it can be external to save some gas\n', "  @param {bytes} data is the transaction's raw input\n", '  */\n', '  function confirm(bytes data) external isManager {\n', '    checkData(data);\n', '    bytes32 op = keccak256(data);\n', '    if (confirms[op][msg.sender] == false) {\n', '      confirms[op][msg.sender] = true;\n', '    }\n', '    emit Confirm(msg.sender, data);\n', '  }\n', '\n', '  /*\n', '  manager use this function to revoke a confirm of the operation\n', '  revoke will not be call inside other functions, so it can be external to save some gas\n', "  @param {bytes} data is the transaction's raw input\n", '  */\n', '  function revoke(bytes data) external isManager {\n', '    checkData(data);\n', '    bytes32 op = keccak256(data);\n', '    if (confirms[op][msg.sender] == true) {\n', '      confirms[op][msg.sender] = false;\n', '    }\n', '    emit Revoke(msg.sender, data);\n', '  }\n', '\n', '  /*\n', '  check a operation is confirmed or not\n', '  */\n', '  function isConfirmed(bytes data) public view isManager returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    return confirms[op][msg.sender];\n', '  }\n', '\n', '  function isConfirmedBy(bytes data, address manager) public view returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    return confirms[op][manager];\n', '  } \n', '\n', '  function isMajorityConfirmed(bytes data) public view returns (bool) {\n', '    return isEnoughConfirmed(data, majorityThreshold);\n', '  }\n', '\n', '  function isEnoughConfirmed(bytes data, uint count) internal view returns (bool) {\n', '    bytes32 op = keccak256(data);\n', '    uint confirmsCount = 0;\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      if (confirms[op][managerList[i]] == true) {\n', '        confirmsCount = confirmsCount.add(1);\n', '      }\n', '    }\n', '    return confirmsCount >= count;\n', '  }\n', '\n', '  /*\n', '  once the operation is executed, the confirm of the operation should be removed\n', '  */\n', '  function removeConfirm(bytes data) internal {\n', '    bytes32 op = keccak256(data);\n', '    for (uint i=0; i<managerList.length; i++) {\n', '      confirms[op][managerList[i]] = false;\n', '    }\n', '  }\n', '\n', '  /*\n', '  sale coin with time locking\n', '  only the manager can call this function\n', '  and this operation should be confirmed\n', '  */\n', '  function presaleVesting(address _to, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) public isManager isNotPaused {\n', '    checkAddress(_to);\n', '    require(isMajorityConfirmed(msg.data));\n', '    internalPresaleVesting(_to, _startTime, _initReleaseAmount, _amount, _interval, _periods);\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function batchPresaleVesting(address[] _to, uint256[] _startTime, uint256[] _initReleaseAmount, uint256[] _amount, uint256[] _interval, uint256[] _periods) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    for (uint i=0; i<_to.length; i++) {\n', '      internalPresaleVesting(_to[i], _startTime[i], _initReleaseAmount[i], _amount[i], _interval[i], _periods[i]);\n', '    }\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function internalPresaleVesting(address _to, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) internal {\n', '    require(balances[coinbase] >= _amount);\n', '    require(_initReleaseAmount <= _amount);\n', '    require(checkAddress(_to));\n', '    vestings[_to].push(Vesting(\n', '      _startTime, _initReleaseAmount, _amount, _interval, _periods, 0\n', '    ));\n', '    balances[coinbase] = balances[coinbase].sub(_amount);\n', '    emit PresaleVesting(_to, _startTime, _amount, _interval, _periods);\n', '  }\n', '\n', '  /*\n', '  sale coin without time locking\n', '  only the manager can call this function\n', '  and this operation should be confirmed\n', '  */\n', '  function presale(address _to, uint256 _value) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    internalPresale(_to, _value);\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function batchPresale(address[] _to, uint256[] _amount) public isManager isNotPaused {\n', '    require(isMajorityConfirmed(msg.data));\n', '    for (uint i=0; i<_to.length; i++) {\n', '      internalPresale(_to[i], _amount[i]);\n', '    }\n', '    removeConfirm(msg.data);\n', '  }\n', '\n', '  function internalPresale(address _to, uint256 _value) internal {\n', '    require(balances[coinbase] >= _value);\n', '    require(checkAddress(_to));\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[coinbase] = balances[coinbase].sub(_value);\n', '    emit Presale(_to, _value);\n', '  }\n', '\n', '  /*\n', '  events\n', '  */\n', '  event Presale(address indexed to, uint256 value);\n', '  event PresaleVesting(address indexed to, uint256 startTime, uint256 amount, uint256 interval, uint256 periods);\n', '\n', '  /*\n', '  math function used to calculate vesting curve\n', '  */\n', '  function vestingFunc(uint256 _currentTime, uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) public pure returns (uint256) {\n', '    if (_currentTime < _startTime) {\n', '      return 0;\n', '    }\n', '    uint256 t = _currentTime.sub(_startTime);\n', '    uint256 end = _periods.mul(_interval);\n', '    if (t >= end) {\n', '      return _amount;\n', '    }\n', '    uint256 i_amount = _amount.sub(_initReleaseAmount).div(_periods);\n', '    uint256 i = t.div(_interval);\n', '    return i_amount.mul(i).add(_initReleaseAmount);\n', '  }\n', '\n', '  function queryWithdrawed(uint _idx) public view returns (uint256) {\n', '    return vestings[msg.sender][_idx].withdrawed;\n', '  }\n', '\n', '  function queryVestingRemain(uint256 _currentTime, uint _idx) public view returns (uint256) {\n', '    uint256 released = vestingFunc(\n', '      _currentTime,\n', '      vestings[msg.sender][_idx].startTime, vestings[msg.sender][_idx].initReleaseAmount, vestings[msg.sender][_idx].amount,\n', '      vestings[msg.sender][_idx].interval, vestings[msg.sender][_idx].periods\n', '    );\n', '    return released.sub(vestings[msg.sender][_idx].withdrawed);\n', '  }\n', '\n', '  /*\n', '  calculate the released amount of vesting coin\n', "  it cannot be view, because this function relays on 'now'\n", '  */\n', '  function vestingReleased(uint256 _startTime, uint256 _initReleaseAmount, uint256 _amount, uint256 _interval, uint256 _periods) internal view returns (uint256) {\n', '    return vestingFunc(now, _startTime, _initReleaseAmount, _amount, _interval, _periods);\n', '  }\n', '\n', '  /*\n', '  withdraw all released vesting coin to balance\n', '  */\n', '  function withdrawVestings(address _to) internal {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      if (vestings[_to][i].amount == vestings[_to][i].withdrawed) {\n', '        continue;\n', '      }\n', '\n', '      uint256 released = vestingReleased(\n', '        vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount,\n', '        vestings[_to][i].interval, vestings[_to][i].periods\n', '      );\n', '      uint256 remain = released.sub(vestings[_to][i].withdrawed);\n', '      if (remain >= 0) {\n', '        vestings[_to][i].withdrawed = released;\n', '        sum = sum.add(remain);\n', '      }\n', '    }\n', '    balances[_to] = balances[_to].add(sum);\n', '  }\n', '\n', '  /*\n', '  sum of all vestings balance (regardless of released or not)\n', '  each vesting is amount - withdrawed\n', '  */\n', '  function vestingsBalance(address _to) public view returns (uint256) {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      sum = sum.add(vestings[_to][i].amount.sub(vestings[_to][i].withdrawed));\n', '    }\n', '    return sum;\n', '  }\n', '\n', '  /*\n', '  sum of all remaining vestings balance (only the released part)\n', '  released - withdrawed\n', '  */\n', '  function vestingsReleasedRemain(address _to) internal view returns (uint256) {\n', '    uint256 sum = 0;\n', '    for (uint i=0; i<vestings[_to].length; i++) {\n', '      uint256 released = vestingReleased(\n', '        vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount,\n', '        vestings[_to][i].interval, vestings[_to][i].periods\n', '      );\n', '      sum = sum.add(released.sub(vestings[_to][i].withdrawed));\n', '    }\n', '    return sum;\n', '  }\n', '\n', '  /*\n', '  total balance\n', '  sum of vestings balance (includes not released part) and unlocking coin balance\n', '  */\n', '  function balanceOf(address _to) public view returns (uint256) {\n', '    uint256 vbalance = vestingsBalance(_to);\n', '    return vbalance.add(super.balanceOf(_to));\n', '  }\n', '\n', '  /*\n', '  sum of vestings balance and unlocking coin balance\n', '  */\n', '  function vestingsRemainBalance(address _to) internal view returns (uint256) {\n', '    return vestingsReleasedRemain(_to).add(super.balanceOf(_to));\n', '  }\n', '\n', '  /*\n', '  transfer <_value> coin from <msg.sender> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function transfer(address _to, uint256 _value) public isNotCoinbase isNotPaused returns (bool) {\n', '    checkAddress(_to);\n', '    uint256 remain = vestingsRemainBalance(msg.sender);\n', '    require(remain >= _value);\n', '    withdrawVestings(msg.sender);\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /*\n', '  transferFrom <_value> coin from <_from> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _value) public isNotPaused returns (bool) {\n', '    checkAddress(_from);\n', '    checkAddress(_to);\n', '    uint256 remain = vestingsRemainBalance(_from);\n', '    require(remain >= _value);\n', '    withdrawVestings(_from);\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /*\n', '  approve <_value> coin from <_from> to <_to> address\n', '  1. check remain balance\n', '  2. withdraw all vesting coin to balance\n', '  3. call original ERC20 transafer function\n', '  */\n', '  function approve(address _spender, uint256 _value) public isNotCoinbase isNotPaused returns (bool) {\n', '    checkAddress(_spender);\n', '    uint256 remain = vestingsRemainBalance(msg.sender);\n', '    require(remain >= _value);\n', '    withdrawVestings(msg.sender);\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return super.allowance(_owner, _spender);\n', '  }\n', '}']
