['pragma solidity ^0.4.24;\n', '\n', '// * Digital Game - Version 1.\n', '// * The user selects three digits, the platform generates trusted random \n', '//   number to lottery and distributes the reward.\n', '\n', 'contract DigitalGame {\n', '  /// *** Constants\n', '\n', '  uint constant MIN_BET_MONEY = 1 finney;\n', '  uint constant MAX_BET_MONEY = 10 ether;\n', '  uint constant MIN_BET_NUMBER = 2;\n', '  uint constant MAX_STAGE = 5;\n', '\n', '  // Calculate invitation dividends based on bet amount\n', '  // - first generation reward: 0.5%\n', '  // - second generation reward: 0.3%\n', '  // - third generation reward: 0.2%\n', '  uint constant FIRST_GENERATION_REWARD = 5;\n', '  uint constant SECOND_GENERATION_REWARD = 3;\n', '  uint constant THIRD_GENERATION_REWARD = 2;\n', '\n', '  address public OWNER_ADDR;\n', '  address public RECOMM_ADDR;\n', '  address public SPARE_RECOMM_ADDR;\n', '\n', '  uint public lastStage;\n', '  uint public lastRound;\n', '\n', '  /// *** Struct\n', '\n', '  struct UserRecomm {\n', '    address addr;\n', '  }\n', '\n', '  struct StageInfo {\n', '    uint round;\n', '    bytes32 seedHash;\n', '    uint userNumber;\n', '    uint amount;\n', '    uint lastTime;\n', '  }\n', '\n', '  struct UserBet {\n', '    address addr;\n', '    uint amount;\n', '    uint[] content;\n', '    uint count;\n', '    uint createAt;\n', '  }\n', '  \n', '  address[] private userRecomms;\n', '  UserBet[] private WaitAwardBets;\n', '\n', '  /// *** Mapping\n', '\n', '  mapping(uint => StageInfo) public stages;\n', '  mapping(address => address) public users;\n', '  mapping(uint => UserBet[]) public userBets;\n', '  mapping(uint => mapping(uint => mapping(address => bool))) private userBetAddrs;\n', '\n', '  /// *** Event\n', '\n', '  event eventUserBet(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint createAt\n', '  );\n', '\n', '  event eventLottery(\n', '    string eventType,\n', '    uint stage,\n', '    uint round,\n', '    uint[] lotteryContent,\n', '    uint createAt\n', '  );\n', '\n', '  event eventDividend(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint level,\n', '    address recommAddr,\n', '    uint recommReward,\n', '    uint createAt\n', '  );\n', '\n', '  event eventReward(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint[] lotteryContent,\n', '    uint reward,\n', '    uint createAt\n', '  );\n', '\n', '  /// *** Modifier\n', '\n', '  modifier checkBetTime(uint lastTime) {\n', '    require(now <= lastTime + 5 minutes, &#39;Current time is not allowed to bet&#39;);\n', '    _;\n', '  }\n', '\n', '  modifier checkRewardTime(uint lastTime) {\n', '    require(\n', '      now >= lastTime + 10 minutes,\n', '      &#39;Current time is not allowed to reward&#39;\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier isSecretNumber(uint stage, string seed) {\n', '    require(\n', '      keccak256(abi.encodePacked(seed)) == stages[stage].seedHash,\n', '      &#39;Encrypted numbers are illegal&#39;\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier verifyStage(uint stage) {\n', '    require(\n', '      stage >= 1 && stage <= MAX_STAGE,\n', '      &#39;Stage no greater than 5 (MAX_STAGE)&#39;\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier verifySeedHash(uint stage, bytes32 seedHash) {\n', '    require(\n', '      stages[stage].seedHash == seedHash && seedHash != 0,\n', '      &#39;The hash of the stage is illegal&#39;\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(OWNER_ADDR == msg.sender, &#39;Permission denied&#39;);\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    for (uint i = 1; i <= MAX_STAGE; i++) {\n', '      stages[i].round = 1;\n', '      stages[i].seedHash = 0x0;\n', '      stages[i].userNumber = 0;\n', '      stages[i].amount = 0;\n', '      stages[i].lastTime = now;\n', '    }\n', '\n', '    OWNER_ADDR = msg.sender;\n', '    RECOMM_ADDR = msg.sender;\n', '    SPARE_RECOMM_ADDR = msg.sender;\n', '\n', '    lastStage = 1;\n', '    lastRound = 1;\n', '  }\n', '\n', '  function bet(\n', '    uint stage,\n', '    uint round,\n', '    uint[] content,\n', '    uint count,\n', '    address recommAddr,\n', '    bytes32 seedHash\n', '  ) public\n', '  payable\n', '  verifyStage(stage)\n', '  verifySeedHash(stage, seedHash)\n', '  checkBetTime(stages[stage].lastTime) {\n', '    require(stages[stage].round == round, &#39;Round illegal&#39;);\n', '    require(content.length == 3, &#39;The bet is 3 digits&#39;);\n', '\n', '    require((\n', '        msg.value >= MIN_BET_MONEY\n', '            && msg.value <= MAX_BET_MONEY\n', '            && msg.value == MIN_BET_MONEY * (10 ** (stage - 1)) * count\n', '      ),\n', '      &#39;The amount of the bet is illegal&#39;\n', '    );\n', '    \n', '    require(msg.sender != recommAddr, &#39;The recommender cannot be himself&#39;);\n', '    \n', '    \n', '    if (users[msg.sender] == 0) {\n', '      if (recommAddr != RECOMM_ADDR) {\n', '        require(\n', '            users[recommAddr] != 0,\n', '            &#39;Referrer is not legal&#39;\n', '        );\n', '      }\n', '      users[msg.sender] = recommAddr;\n', '    }\n', '\n', '    generateUserRelation(msg.sender, 3);\n', '    require(userRecomms.length <= 3, &#39;User relationship error&#39;);\n', '\n', '    sendInviteDividends(stage, round, count, content);\n', '\n', '    if (!userBetAddrs[stage][stages[stage].round][msg.sender]) {\n', '      stages[stage].userNumber++;\n', '      userBetAddrs[stage][stages[stage].round][msg.sender] = true;\n', '    }\n', '\n', '    userBets[stage].push(UserBet(\n', '      msg.sender,\n', '      msg.value,\n', '      content,\n', '      count,\n', '      now\n', '    ));\n', '\n', '    emit eventUserBet(\n', '      &#39;userBet&#39;,\n', '      msg.sender,\n', '      msg.value,\n', '      stage,\n', '      round,\n', '      count,\n', '      content,\n', '      now\n', '    );\n', '  }\n', '\n', '  function generateUserRelation(\n', '    address addr,\n', '    uint generation\n', '  ) private returns(bool) {\n', '    userRecomms.push(users[addr]);\n', '    if (users[addr] != RECOMM_ADDR && users[addr] != 0 && generation > 1) {\n', '        generateUserRelation(users[addr], generation - 1);\n', '    }\n', '  }\n', '\n', '  function sendInviteDividends(\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content\n', '  ) private {\n', '    uint[3] memory GENERATION_REWARD = [\n', '      FIRST_GENERATION_REWARD,\n', '      SECOND_GENERATION_REWARD,\n', '      THIRD_GENERATION_REWARD\n', '    ];\n', '    uint recomms = 0;\n', '    for (uint j = 0; j < userRecomms.length; j++) {\n', '      recomms += msg.value * GENERATION_REWARD[j] / 1000;\n', '      userRecomms[j].transfer(msg.value * GENERATION_REWARD[j] / 1000);\n', '\n', '      emit eventDividend(\n', '        &#39;dividend&#39;,\n', '        msg.sender,\n', '        msg.value,\n', '        stage,\n', '        round,\n', '        count,\n', '        content,\n', '        j,\n', '        userRecomms[j],\n', '        msg.value * GENERATION_REWARD[j] / 1000,\n', '        now\n', '      );\n', '    }\n', '\n', '    stages[stage].amount += (msg.value - recomms);\n', '    delete userRecomms;\n', '  }\n', '\n', '  function distributionReward(\n', '    uint stage,\n', '    string seed,\n', '    bytes32 seedHash\n', '  ) public\n', '  checkRewardTime(stages[stage].lastTime)\n', '  isSecretNumber(stage, seed)\n', '  verifyStage(stage)\n', '  onlyOwner {\n', '    if (stages[stage].userNumber >= MIN_BET_NUMBER) {\n', '      uint[] memory randoms = generateRandom(\n', '        seed,\n', '        stage,\n', '        userBets[stage].length\n', '      );\n', '      require(randoms.length == 3, &#39;Random number is illegal&#39;);\n', '\n', '      bool isReward = CalcWinnersAndReward(randoms, stage);\n', '\n', '      emit eventLottery(\n', '        &#39;lottery&#39;,\n', '        stage,\n', '        stages[stage].round,\n', '        randoms,\n', '        now\n', '      );\n', '\n', '      if (isReward) {\n', '        stages[stage].amount = 0;\n', '        \n', '        lastStage = stage;\n', '        lastRound = stages[stage].round;\n', '      }\n', '      \n', '      delete userBets[stage];\n', '      \n', '      stages[stage].round += 1;\n', '      stages[stage].userNumber = 0;\n', '      stages[stage].seedHash = seedHash;\n', '      \n', '      stages[stage].lastTime = now + 5 minutes;\n', '    } else {\n', '      stages[stage].lastTime = now;\n', '    }\n', '  }\n', '\n', '  function CalcWinnersAndReward(\n', '    uint[] randoms,\n', '    uint stage\n', '  ) private onlyOwner returns(bool) {\n', '    uint counts = 0;\n', '    for (uint i = 0; i < userBets[stage].length; i++) {\n', '      if (randoms[0] == userBets[stage][i].content[0]\n', '        && randoms[1] == userBets[stage][i].content[1]\n', '        && randoms[2] == userBets[stage][i].content[2]) {\n', '        counts = counts + userBets[stage][i].count;\n', '        WaitAwardBets.push(UserBet(\n', '          userBets[stage][i].addr,\n', '          userBets[stage][i].amount,\n', '          userBets[stage][i].content,\n', '          userBets[stage][i].count,\n', '          userBets[stage][i].createAt\n', '        ));\n', '      }\n', '    }\n', '    if (WaitAwardBets.length == 0) {\n', '      for (uint j = 0; j < userBets[stage].length; j++) {\n', '        if ((randoms[0] == userBets[stage][j].content[0]\n', '            && randoms[1] == userBets[stage][j].content[1])\n', '              || (randoms[1] == userBets[stage][j].content[1]\n', '            && randoms[2] == userBets[stage][j].content[2])\n', '              || (randoms[0] == userBets[stage][j].content[0]\n', '            && randoms[2] == userBets[stage][j].content[2])) {\n', '          counts += userBets[stage][j].count;\n', '          WaitAwardBets.push(UserBet(\n', '            userBets[stage][j].addr,\n', '            userBets[stage][j].amount,\n', '            userBets[stage][j].content,\n', '            userBets[stage][j].count,\n', '            userBets[stage][j].createAt\n', '          ));\n', '        }\n', '      }\n', '    }\n', '    if (WaitAwardBets.length == 0) {\n', '      for (uint k = 0; k < userBets[stage].length; k++) {\n', '        if (randoms[0] == userBets[stage][k].content[0]\n', '            || randoms[1] == userBets[stage][k].content[1]\n', '            || randoms[2] == userBets[stage][k].content[2]) {\n', '          counts += userBets[stage][k].count;\n', '          WaitAwardBets.push(UserBet(\n', '            userBets[stage][k].addr,\n', '            userBets[stage][k].amount,\n', '            userBets[stage][k].content,\n', '            userBets[stage][k].count,\n', '            userBets[stage][k].createAt\n', '          ));\n', '        }\n', '      }\n', '    }\n', '\n', '    uint extractReward = stages[stage].amount / 100;\n', '    RECOMM_ADDR.transfer(extractReward);\n', '    SPARE_RECOMM_ADDR.transfer(extractReward);\n', '    OWNER_ADDR.transfer(extractReward);\n', '\n', '    if (WaitAwardBets.length != 0) {\n', '      issueReward(stage, extractReward, randoms, counts);\n', '      delete WaitAwardBets;\n', '      return true;\n', '    }\n', '    stages[stage].amount = stages[stage].amount - extractReward - extractReward - extractReward;\n', '    return false;\n', '  }\n', '  \n', '  function issueReward(\n', '    uint stage,\n', '    uint extractReward,\n', '    uint[] randoms,\n', '    uint counts\n', '  ) private onlyOwner {\n', '    uint userAward = stages[stage].amount - extractReward - extractReward - extractReward;\n', '    for (uint m = 0; m < WaitAwardBets.length; m++) {\n', '      uint reward = userAward * WaitAwardBets[m].count / counts;\n', '      WaitAwardBets[m].addr.transfer(reward);\n', '\n', '      emit eventReward(\n', '        &#39;reward&#39;,\n', '        WaitAwardBets[m].addr,\n', '        WaitAwardBets[m].amount,\n', '        stage,\n', '        stages[stage].round,\n', '        WaitAwardBets[m].count,\n', '        WaitAwardBets[m].content,\n', '        randoms,\n', '        reward,\n', '        now\n', '      );\n', '    }\n', '  }\n', '\n', '  function generateRandom(\n', '    string seed,\n', '    uint stage,\n', '    uint betNum\n', '  ) private view onlyOwner\n', '  isSecretNumber(stage, seed) returns(uint[]) {\n', '    uint[] memory randoms = new uint[](3);\n', '    for (uint i = 0; i < 3; i++) {\n', '      randoms[i] = uint(\n', '        keccak256(abi.encodePacked(betNum, block.difficulty, seed, now, i))\n', '      ) % 9 + 1;\n', '    }\n', '    return randoms;\n', '  }\n', '\n', '  function setSeedHash(uint stage, bytes32 seedHash) public onlyOwner {\n', '    require(\n', '      stages[stage].seedHash == 0,\n', '      &#39;No need to set seed hash&#39;\n', '    );\n', '    stages[stage].seedHash = seedHash;\n', '  }\n', '\n', '  function setDefaultRecommAddr(address _RECOMM_ADDR) public onlyOwner {\n', '    RECOMM_ADDR = _RECOMM_ADDR;\n', '  }\n', '\n', '  function setSpareRecommAddr(address _SPARE_RECOMM_ADDR) public onlyOwner {\n', '    SPARE_RECOMM_ADDR = _SPARE_RECOMM_ADDR;\n', '  }\n', '\n', '  function getDefaultRecommAddr() public view returns(address) {\n', '    return RECOMM_ADDR;\n', '  }\n', '\n', '  function getSpareRecommAddr() public view returns(address) {\n', '    return SPARE_RECOMM_ADDR;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// * Digital Game - Version 1.\n', '// * The user selects three digits, the platform generates trusted random \n', '//   number to lottery and distributes the reward.\n', '\n', 'contract DigitalGame {\n', '  /// *** Constants\n', '\n', '  uint constant MIN_BET_MONEY = 1 finney;\n', '  uint constant MAX_BET_MONEY = 10 ether;\n', '  uint constant MIN_BET_NUMBER = 2;\n', '  uint constant MAX_STAGE = 5;\n', '\n', '  // Calculate invitation dividends based on bet amount\n', '  // - first generation reward: 0.5%\n', '  // - second generation reward: 0.3%\n', '  // - third generation reward: 0.2%\n', '  uint constant FIRST_GENERATION_REWARD = 5;\n', '  uint constant SECOND_GENERATION_REWARD = 3;\n', '  uint constant THIRD_GENERATION_REWARD = 2;\n', '\n', '  address public OWNER_ADDR;\n', '  address public RECOMM_ADDR;\n', '  address public SPARE_RECOMM_ADDR;\n', '\n', '  uint public lastStage;\n', '  uint public lastRound;\n', '\n', '  /// *** Struct\n', '\n', '  struct UserRecomm {\n', '    address addr;\n', '  }\n', '\n', '  struct StageInfo {\n', '    uint round;\n', '    bytes32 seedHash;\n', '    uint userNumber;\n', '    uint amount;\n', '    uint lastTime;\n', '  }\n', '\n', '  struct UserBet {\n', '    address addr;\n', '    uint amount;\n', '    uint[] content;\n', '    uint count;\n', '    uint createAt;\n', '  }\n', '  \n', '  address[] private userRecomms;\n', '  UserBet[] private WaitAwardBets;\n', '\n', '  /// *** Mapping\n', '\n', '  mapping(uint => StageInfo) public stages;\n', '  mapping(address => address) public users;\n', '  mapping(uint => UserBet[]) public userBets;\n', '  mapping(uint => mapping(uint => mapping(address => bool))) private userBetAddrs;\n', '\n', '  /// *** Event\n', '\n', '  event eventUserBet(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint createAt\n', '  );\n', '\n', '  event eventLottery(\n', '    string eventType,\n', '    uint stage,\n', '    uint round,\n', '    uint[] lotteryContent,\n', '    uint createAt\n', '  );\n', '\n', '  event eventDividend(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint level,\n', '    address recommAddr,\n', '    uint recommReward,\n', '    uint createAt\n', '  );\n', '\n', '  event eventReward(\n', '    string eventType,\n', '    address addr,\n', '    uint amount,\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content,\n', '    uint[] lotteryContent,\n', '    uint reward,\n', '    uint createAt\n', '  );\n', '\n', '  /// *** Modifier\n', '\n', '  modifier checkBetTime(uint lastTime) {\n', "    require(now <= lastTime + 5 minutes, 'Current time is not allowed to bet');\n", '    _;\n', '  }\n', '\n', '  modifier checkRewardTime(uint lastTime) {\n', '    require(\n', '      now >= lastTime + 10 minutes,\n', "      'Current time is not allowed to reward'\n", '    );\n', '    _;\n', '  }\n', '\n', '  modifier isSecretNumber(uint stage, string seed) {\n', '    require(\n', '      keccak256(abi.encodePacked(seed)) == stages[stage].seedHash,\n', "      'Encrypted numbers are illegal'\n", '    );\n', '    _;\n', '  }\n', '\n', '  modifier verifyStage(uint stage) {\n', '    require(\n', '      stage >= 1 && stage <= MAX_STAGE,\n', "      'Stage no greater than 5 (MAX_STAGE)'\n", '    );\n', '    _;\n', '  }\n', '\n', '  modifier verifySeedHash(uint stage, bytes32 seedHash) {\n', '    require(\n', '      stages[stage].seedHash == seedHash && seedHash != 0,\n', "      'The hash of the stage is illegal'\n", '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', "    require(OWNER_ADDR == msg.sender, 'Permission denied');\n", '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    for (uint i = 1; i <= MAX_STAGE; i++) {\n', '      stages[i].round = 1;\n', '      stages[i].seedHash = 0x0;\n', '      stages[i].userNumber = 0;\n', '      stages[i].amount = 0;\n', '      stages[i].lastTime = now;\n', '    }\n', '\n', '    OWNER_ADDR = msg.sender;\n', '    RECOMM_ADDR = msg.sender;\n', '    SPARE_RECOMM_ADDR = msg.sender;\n', '\n', '    lastStage = 1;\n', '    lastRound = 1;\n', '  }\n', '\n', '  function bet(\n', '    uint stage,\n', '    uint round,\n', '    uint[] content,\n', '    uint count,\n', '    address recommAddr,\n', '    bytes32 seedHash\n', '  ) public\n', '  payable\n', '  verifyStage(stage)\n', '  verifySeedHash(stage, seedHash)\n', '  checkBetTime(stages[stage].lastTime) {\n', "    require(stages[stage].round == round, 'Round illegal');\n", "    require(content.length == 3, 'The bet is 3 digits');\n", '\n', '    require((\n', '        msg.value >= MIN_BET_MONEY\n', '            && msg.value <= MAX_BET_MONEY\n', '            && msg.value == MIN_BET_MONEY * (10 ** (stage - 1)) * count\n', '      ),\n', "      'The amount of the bet is illegal'\n", '    );\n', '    \n', "    require(msg.sender != recommAddr, 'The recommender cannot be himself');\n", '    \n', '    \n', '    if (users[msg.sender] == 0) {\n', '      if (recommAddr != RECOMM_ADDR) {\n', '        require(\n', '            users[recommAddr] != 0,\n', "            'Referrer is not legal'\n", '        );\n', '      }\n', '      users[msg.sender] = recommAddr;\n', '    }\n', '\n', '    generateUserRelation(msg.sender, 3);\n', "    require(userRecomms.length <= 3, 'User relationship error');\n", '\n', '    sendInviteDividends(stage, round, count, content);\n', '\n', '    if (!userBetAddrs[stage][stages[stage].round][msg.sender]) {\n', '      stages[stage].userNumber++;\n', '      userBetAddrs[stage][stages[stage].round][msg.sender] = true;\n', '    }\n', '\n', '    userBets[stage].push(UserBet(\n', '      msg.sender,\n', '      msg.value,\n', '      content,\n', '      count,\n', '      now\n', '    ));\n', '\n', '    emit eventUserBet(\n', "      'userBet',\n", '      msg.sender,\n', '      msg.value,\n', '      stage,\n', '      round,\n', '      count,\n', '      content,\n', '      now\n', '    );\n', '  }\n', '\n', '  function generateUserRelation(\n', '    address addr,\n', '    uint generation\n', '  ) private returns(bool) {\n', '    userRecomms.push(users[addr]);\n', '    if (users[addr] != RECOMM_ADDR && users[addr] != 0 && generation > 1) {\n', '        generateUserRelation(users[addr], generation - 1);\n', '    }\n', '  }\n', '\n', '  function sendInviteDividends(\n', '    uint stage,\n', '    uint round,\n', '    uint count,\n', '    uint[] content\n', '  ) private {\n', '    uint[3] memory GENERATION_REWARD = [\n', '      FIRST_GENERATION_REWARD,\n', '      SECOND_GENERATION_REWARD,\n', '      THIRD_GENERATION_REWARD\n', '    ];\n', '    uint recomms = 0;\n', '    for (uint j = 0; j < userRecomms.length; j++) {\n', '      recomms += msg.value * GENERATION_REWARD[j] / 1000;\n', '      userRecomms[j].transfer(msg.value * GENERATION_REWARD[j] / 1000);\n', '\n', '      emit eventDividend(\n', "        'dividend',\n", '        msg.sender,\n', '        msg.value,\n', '        stage,\n', '        round,\n', '        count,\n', '        content,\n', '        j,\n', '        userRecomms[j],\n', '        msg.value * GENERATION_REWARD[j] / 1000,\n', '        now\n', '      );\n', '    }\n', '\n', '    stages[stage].amount += (msg.value - recomms);\n', '    delete userRecomms;\n', '  }\n', '\n', '  function distributionReward(\n', '    uint stage,\n', '    string seed,\n', '    bytes32 seedHash\n', '  ) public\n', '  checkRewardTime(stages[stage].lastTime)\n', '  isSecretNumber(stage, seed)\n', '  verifyStage(stage)\n', '  onlyOwner {\n', '    if (stages[stage].userNumber >= MIN_BET_NUMBER) {\n', '      uint[] memory randoms = generateRandom(\n', '        seed,\n', '        stage,\n', '        userBets[stage].length\n', '      );\n', "      require(randoms.length == 3, 'Random number is illegal');\n", '\n', '      bool isReward = CalcWinnersAndReward(randoms, stage);\n', '\n', '      emit eventLottery(\n', "        'lottery',\n", '        stage,\n', '        stages[stage].round,\n', '        randoms,\n', '        now\n', '      );\n', '\n', '      if (isReward) {\n', '        stages[stage].amount = 0;\n', '        \n', '        lastStage = stage;\n', '        lastRound = stages[stage].round;\n', '      }\n', '      \n', '      delete userBets[stage];\n', '      \n', '      stages[stage].round += 1;\n', '      stages[stage].userNumber = 0;\n', '      stages[stage].seedHash = seedHash;\n', '      \n', '      stages[stage].lastTime = now + 5 minutes;\n', '    } else {\n', '      stages[stage].lastTime = now;\n', '    }\n', '  }\n', '\n', '  function CalcWinnersAndReward(\n', '    uint[] randoms,\n', '    uint stage\n', '  ) private onlyOwner returns(bool) {\n', '    uint counts = 0;\n', '    for (uint i = 0; i < userBets[stage].length; i++) {\n', '      if (randoms[0] == userBets[stage][i].content[0]\n', '        && randoms[1] == userBets[stage][i].content[1]\n', '        && randoms[2] == userBets[stage][i].content[2]) {\n', '        counts = counts + userBets[stage][i].count;\n', '        WaitAwardBets.push(UserBet(\n', '          userBets[stage][i].addr,\n', '          userBets[stage][i].amount,\n', '          userBets[stage][i].content,\n', '          userBets[stage][i].count,\n', '          userBets[stage][i].createAt\n', '        ));\n', '      }\n', '    }\n', '    if (WaitAwardBets.length == 0) {\n', '      for (uint j = 0; j < userBets[stage].length; j++) {\n', '        if ((randoms[0] == userBets[stage][j].content[0]\n', '            && randoms[1] == userBets[stage][j].content[1])\n', '              || (randoms[1] == userBets[stage][j].content[1]\n', '            && randoms[2] == userBets[stage][j].content[2])\n', '              || (randoms[0] == userBets[stage][j].content[0]\n', '            && randoms[2] == userBets[stage][j].content[2])) {\n', '          counts += userBets[stage][j].count;\n', '          WaitAwardBets.push(UserBet(\n', '            userBets[stage][j].addr,\n', '            userBets[stage][j].amount,\n', '            userBets[stage][j].content,\n', '            userBets[stage][j].count,\n', '            userBets[stage][j].createAt\n', '          ));\n', '        }\n', '      }\n', '    }\n', '    if (WaitAwardBets.length == 0) {\n', '      for (uint k = 0; k < userBets[stage].length; k++) {\n', '        if (randoms[0] == userBets[stage][k].content[0]\n', '            || randoms[1] == userBets[stage][k].content[1]\n', '            || randoms[2] == userBets[stage][k].content[2]) {\n', '          counts += userBets[stage][k].count;\n', '          WaitAwardBets.push(UserBet(\n', '            userBets[stage][k].addr,\n', '            userBets[stage][k].amount,\n', '            userBets[stage][k].content,\n', '            userBets[stage][k].count,\n', '            userBets[stage][k].createAt\n', '          ));\n', '        }\n', '      }\n', '    }\n', '\n', '    uint extractReward = stages[stage].amount / 100;\n', '    RECOMM_ADDR.transfer(extractReward);\n', '    SPARE_RECOMM_ADDR.transfer(extractReward);\n', '    OWNER_ADDR.transfer(extractReward);\n', '\n', '    if (WaitAwardBets.length != 0) {\n', '      issueReward(stage, extractReward, randoms, counts);\n', '      delete WaitAwardBets;\n', '      return true;\n', '    }\n', '    stages[stage].amount = stages[stage].amount - extractReward - extractReward - extractReward;\n', '    return false;\n', '  }\n', '  \n', '  function issueReward(\n', '    uint stage,\n', '    uint extractReward,\n', '    uint[] randoms,\n', '    uint counts\n', '  ) private onlyOwner {\n', '    uint userAward = stages[stage].amount - extractReward - extractReward - extractReward;\n', '    for (uint m = 0; m < WaitAwardBets.length; m++) {\n', '      uint reward = userAward * WaitAwardBets[m].count / counts;\n', '      WaitAwardBets[m].addr.transfer(reward);\n', '\n', '      emit eventReward(\n', "        'reward',\n", '        WaitAwardBets[m].addr,\n', '        WaitAwardBets[m].amount,\n', '        stage,\n', '        stages[stage].round,\n', '        WaitAwardBets[m].count,\n', '        WaitAwardBets[m].content,\n', '        randoms,\n', '        reward,\n', '        now\n', '      );\n', '    }\n', '  }\n', '\n', '  function generateRandom(\n', '    string seed,\n', '    uint stage,\n', '    uint betNum\n', '  ) private view onlyOwner\n', '  isSecretNumber(stage, seed) returns(uint[]) {\n', '    uint[] memory randoms = new uint[](3);\n', '    for (uint i = 0; i < 3; i++) {\n', '      randoms[i] = uint(\n', '        keccak256(abi.encodePacked(betNum, block.difficulty, seed, now, i))\n', '      ) % 9 + 1;\n', '    }\n', '    return randoms;\n', '  }\n', '\n', '  function setSeedHash(uint stage, bytes32 seedHash) public onlyOwner {\n', '    require(\n', '      stages[stage].seedHash == 0,\n', "      'No need to set seed hash'\n", '    );\n', '    stages[stage].seedHash = seedHash;\n', '  }\n', '\n', '  function setDefaultRecommAddr(address _RECOMM_ADDR) public onlyOwner {\n', '    RECOMM_ADDR = _RECOMM_ADDR;\n', '  }\n', '\n', '  function setSpareRecommAddr(address _SPARE_RECOMM_ADDR) public onlyOwner {\n', '    SPARE_RECOMM_ADDR = _SPARE_RECOMM_ADDR;\n', '  }\n', '\n', '  function getDefaultRecommAddr() public view returns(address) {\n', '    return RECOMM_ADDR;\n', '  }\n', '\n', '  function getSpareRecommAddr() public view returns(address) {\n', '    return SPARE_RECOMM_ADDR;\n', '  }\n', '}']
