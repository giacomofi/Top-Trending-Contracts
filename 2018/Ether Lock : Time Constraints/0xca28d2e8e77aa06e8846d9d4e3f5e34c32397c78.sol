['pragma solidity ^0.4.13;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ContractReceiver {\n', '\n', '    struct TKN {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint _value, bytes _data) public pure {\n', '        TKN memory tkn;\n', '        tkn.sender = _from;\n', '        tkn.value = _value;\n', '        tkn.data = _data;\n', '        uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '        tkn.sig = bytes4(u);\n', '\n', '        /* tkn variable is analogue of msg variable of Ether transaction\n', '        *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\n', '        *  tkn.value the number of tokens that were sent   (analogue of msg.value)\n', '        *  tkn.data is data of token transaction   (analogue of msg.data)\n', '        *  tkn.sig is 4 bytes signature of function\n', '        *  if data of token transaction is a function execution\n', '        */\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract CrowdsaleFront is Ownable{\n', '    //Crowdsale public provider;\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) internal userAmounts;\n', '    mapping (address => uint256) internal rewardPayed;\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyOwner {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    // fallback function can be used to buy tokens\n', '    function () public payable {\n', '        buyTokens(msg.sender, 0, 999);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary, address _parent, uint256 _top) public payable returns(bool){\n', '      bool ret;\n', '      uint256 tokens;\n', '      (ret, tokens) = Crowdsale(commons.get("Crowdsale")).buyTokens.value(msg.value)(beneficiary, beneficiary, _parent, _top);\n', '      userAmounts[beneficiary] = userAmounts[beneficiary].add(tokens);\n', '      require(ret);\n', '    }\n', '\n', '    function getTokensFromBuy(address _addr) public view returns (uint256){\n', '      return userAmounts[_addr];\n', '    }\n', '    function rewardPayedOf(address _user) public view returns (uint256) {\n', '      return rewardPayed[_user];\n', '    }\n', '    function rewardPay(address _user, uint256 amount) public {\n', '      require(msg.sender == commons.get("Crowdsale"));\n', '      rewardPayed[_user] = rewardPayed[_user].add(amount);\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool){\n', '        return Crowdsale(commons.get("Crowdsale")).hasEnded();\n', '    }\n', '\n', '}\n', '\n', 'contract InterestHolder is Ownable{\n', '  using SafeMath for uint256;\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  bool public locked = true;\n', '  event ReceiveBalanceUpdate(address _addr,address _user);\n', '  event ReceiveBalanceUpdateUserType(address _addr,address _user,uint256 _type);\n', '  function receiveBalanceUpdate(address _user) external returns (bool) {\n', '    emit ReceiveBalanceUpdate(msg.sender, _user);\n', '    Token token = Token(commons.get("Token"));\n', '    User user = User(commons.get("User"));\n', '    if (msg.sender == address(token)){\n', '      uint256 _type;\n', '      (,,_type) = user.getUserInfo(_user);\n', '      emit ReceiveBalanceUpdateUserType(msg.sender, _user, _type);\n', '      if (_type == 0){\n', '          return true;\n', '      }\n', '      process(_user,_type);\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '  event ProcessLx(address _addr,address _user, uint256 _type,uint256 lastBalance, uint256 iAmount, uint256 lastTime);\n', '  function process(address _user, uint256 _type) internal{\n', '    Token token = Token(commons.get("Token"));\n', '    User user = User(commons.get("User"));\n', '    uint256 _value = compute(_user, _type);\n', '    uint256 balance = token.balanceOf(_user);\n', '    user.setInterestor(_user,balance.add(_value),now);\n', '    if(_value > 0){\n', '      token.mintForWorker(_user,_value);\n', '      emit ProcessLx(msg.sender, _user, _type, balance, _value, now);\n', '    }\n', '  }\n', '  event GetLx(address _addr,address _user,uint256 _type);\n', '\n', '  function compute(address _user, uint256 _type) internal view returns (uint256) {\n', '    User user = User(commons.get("User"));\n', '    uint256 lastBalance = 0;\n', '    uint256 lastTime = 0;\n', '    bool exist;\n', '    (lastBalance,lastTime,exist) = user.getInterestor(_user);\n', '    uint256 _value = 0;\n', '    if (exist && lastTime > 0){\n', '        uint256 times = now.sub(lastTime);\n', '        if (_type == 1){\n', '            _value = lastBalance.div(10000).mul(5).div(86400).mul(times);\n', '        }else if(_type == 2){\n', '            _value = lastBalance.div(10000).mul(8).div(86400).mul(times);\n', '        }\n', '    }\n', '    return _value;\n', '  }\n', '  function getLx() external returns (uint256) {\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    emit GetLx(msg.sender, msg.sender, _type);\n', '    if (_type == 0){\n', '        return 0;\n', '    }\n', '    return compute(msg.sender, _type);\n', '  }\n', '}\n', '\n', 'contract TokenHolder is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  bool locked = true;\n', '  mapping (address => uint256) lockedAmount;\n', '  event ReceiveLockedAmount(address _addr, address _user, uint256 _amount);\n', '  function receiveLockedAmount(address _user, uint256 _amount) external returns (bool) {\n', '    address cds = commons.get("Crowdsale");\n', '    if (msg.sender == address(cds)){\n', '      lockedAmount[_user] = lockedAmount[_user].add(_amount);\n', '      emit ReceiveLockedAmount(msg.sender, _user, _amount);\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function balanceOf(address _user) public view returns (uint256) {\n', '    return lockedAmount[_user];\n', '  }\n', '  function balance() public view returns (uint256) {\n', '    return lockedAmount[msg.sender];\n', '  }\n', '\n', '  function setLock(bool _locked) public onlyOwner{\n', '    locked = _locked;\n', '  }\n', '\n', '  function withDrawlocked() public view returns (bool) {\n', '      return locked;\n', '  }\n', '\n', '  function withDrawable() public view returns (bool) {\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    return !locked && (_type > 0) && lockedAmount[msg.sender] > 0;\n', '  }\n', '\n', '  function withDraw() external {\n', '    assert(!locked);//用户必须是种子钱包\n', '    BwinToken token = BwinToken(commons.get("BwinToken"));\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    assert(_type > 0);\n', '    uint _value = lockedAmount[msg.sender];\n', '    lockedAmount[msg.sender] = 0;\n', '    token.transfer(msg.sender,_value);\n', '  }\n', '\n', '}\n', '\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', 'contract EtherHolder is Destructible{\n', '  using SafeMath for uint256;\n', '  bool locked = false;\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  struct Account {\n', '    address wallet;\n', '    address parent;\n', '    uint256 radio;\n', '    bool exist;\n', '  }\n', '  mapping (address => uint256) private userAmounts;\n', '  uint256 internal _balance;\n', '  event ProcessFunds(address _topWallet, uint256 _value ,bool isContract);\n', '\n', '  event ReceiveFunds(address _addr, address _user, uint256 _value, uint256 _amount);\n', '  function receiveFunds(address _user, uint256 _amount) external payable returns (bool) {\n', '    emit ReceiveFunds(msg.sender, _user, msg.value, _amount);\n', '    Crowdsale cds = Crowdsale(commons.get("Crowdsale"));\n', '    User user = User(commons.get("User"));\n', '    assert(msg.value == _amount);\n', '    if (msg.sender == address(cds)){\n', '        address _topWallet;\n', '        uint _percent=0;\n', '        bool _contract;\n', '        uint256 _topValue = 0;\n', '        bool _topOk;\n', '        uint256 _totalShares = 0;\n', '        uint256 _totalSharePercent = 0;\n', '        bool _shareRet;\n', '        if(user.hasUser(_user)){\n', '          (_topWallet,_percent,_contract) = user.getTopInfoDetail(_user);\n', '          assert(_percent <= 1000);\n', '          (_topValue,_topOk) = processFunds(_topWallet,_amount,_percent,_contract);\n', '        }else{\n', '          _topOk = true;\n', '        }\n', '        (_totalShares,_totalSharePercent,_shareRet) = processShares(_amount.sub(_topValue));\n', '        assert(_topOk && _shareRet);\n', '        assert(_topValue.add(_totalShares) <= _amount);\n', '        assert(_totalSharePercent <= 1000);\n', '        _balance = _balance.add(_amount);\n', '        return true;\n', '    }\n', '    return false;\n', '  }\n', '  event ProcessShares(uint256 _amount, uint i, uint256 _percent, bool _contract,address _wallet);\n', '  function processShares(uint256 _amount) internal returns(uint256,uint256,bool){\n', '      uint256 _sended = 0;\n', '      uint256 _sharePercent = 0;\n', '      User user = User(commons.get("User"));\n', '      for(uint i=0;i<user.getShareHolderCount();i++){\n', '        address _wallet;\n', '        uint256 _percent;\n', '        bool _contract;\n', '        emit ProcessShares(_amount, i, _percent, _contract,_wallet);\n', '        assert(_percent <= 1000);\n', '        (_wallet,_percent,_contract) = user.getShareHolder(i);\n', '        uint256 _value;\n', '        bool _valueOk;\n', '        (_value,_valueOk) = processFunds(_wallet,_amount,_percent,_contract);\n', '        _sharePercent = _sharePercent.add(_percent);\n', '        _sended = _sended.add(_value);\n', '      }\n', '      return (_sended,_sharePercent,true);\n', '  }\n', '  function getAmount(uint256 _amount, uint256 _percent) internal pure returns(uint256){\n', '      uint256 _value = _amount.div(1000).mul(_percent);\n', '      return _value;\n', '  }\n', '  function processFunds(address _topWallet, uint256 _amount ,uint256 _percent, bool isContract) internal returns(uint,bool) {\n', '      uint256 _value = getAmount(_amount, _percent);\n', '      userAmounts[_topWallet] = userAmounts[_topWallet].add(_value);\n', '      emit ProcessFunds(_topWallet,_value,isContract);\n', '      return (_value,true);\n', '  }\n', '\n', '  function balanceOf(address _user) public view returns (uint256) {\n', '    return userAmounts[_user];\n', '  }\n', '\n', '  function balanceOfme() public view returns (uint256) {\n', '    return userAmounts[msg.sender];\n', '  }\n', '\n', '  function withDrawlocked() public view returns (bool) {\n', '      return locked;\n', '  }\n', '  function getBalance() public view returns (uint256, uint256) {\n', '    return (address(this).balance,_balance);\n', '  }\n', '  function lock(bool _locked) public onlyOwner{\n', '    locked = _locked;\n', '  }\n', '  event WithDraw(address caller, uint256 _amount);\n', '\n', '  function withDraw(uint256 _amount) external {\n', '    assert(!locked);\n', '    assert(userAmounts[msg.sender] >= _amount);\n', '    userAmounts[msg.sender] = userAmounts[msg.sender].sub(_amount);\n', '    _balance = _balance.sub(_amount);\n', '    msg.sender.transfer(_amount);\n', '    emit WithDraw(msg.sender, _amount);\n', '  }\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBAC()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract BwinCommons is RBAC, Destructible {\n', '    mapping (string => address) internal addresses;\n', '    mapping (address => string) internal names;\n', '\n', '    event UpdateRegistration(string key, address old, address n);\n', '\n', '    function register(string key, address ad) public onlyAdmin {\n', '        emit UpdateRegistration(key, addresses[key], ad);\n', '        addresses[key] = ad;\n', '        names[ad] = key;\n', '    }\n', '\n', '    function get(string key) public view returns(address) {\n', '        return addresses[key];\n', '    }\n', '\n', '    function remove() public {\n', '      string memory key = names[msg.sender];\n', '      delete addresses[key];\n', '      delete names[msg.sender];\n', '    }\n', '}\n', '\n', 'contract User is RBAC ,Destructible{\n', '    struct UserInfo {\n', '        //推荐人\n', '        address parent;\n', '        uint256 top;\n', '        bool exist;\n', '        uint256 userType;\n', '    }\n', '\n', '    struct Partner {\n', '      address addr;\n', '      uint256 percent;\n', '      bool exist;\n', '      bool iscontract;\n', '    }\n', '\n', '    struct UserBalance{\n', '        address user;\n', '        uint256 balance;\n', '        uint256 lastTime;\n', '        bool exist;\n', '    }\n', '    mapping (address => UserBalance) internal balanceForInterests;\n', '    uint256[] internal tops;\n', '    mapping (uint256 => Partner) internal topDefine;\n', '\n', '    uint256[] internal shareHolders;\n', '    mapping (uint256 => Partner) internal shareHolderInfos;\n', '    mapping (address => UserInfo) internal tree;\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyAdmin {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '\n', '\n', '    address[] internal users;\n', '    event SetInterestor(address caller, address _user, uint256 _balance, uint256 _lastTime);\n', '    event SetShareHolders(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\n', '    event SetTop(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\n', '    event AddUser(address caller, address _parent, uint256 _top);\n', '    event SetUser(address caller, address _user, address _parent, uint256 _top, uint256 _type);\n', '    event SetUserType(address caller, address _user, uint _type);\n', '    event RemoveUser(address caller, uint _index);\n', '\n', '    function setInterestor(address _user, uint256 _balance, uint256 _lastTime) public onlyRole("INTEREST_HOLDER"){\n', '        balanceForInterests[_user] = UserBalance(_user,_balance,_lastTime,true);\n', '        emit SetInterestor(msg.sender,_user,_balance,_lastTime);\n', '    }\n', '\n', '    function getInterestor(address _user) public view returns(uint256,uint256,bool){\n', '        return (balanceForInterests[_user].balance,balanceForInterests[_user].lastTime,balanceForInterests[_user].exist);\n', '    }\n', '    function setShareHolders(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\n', '        if (!shareHolderInfos[topId].exist){\n', '          shareHolders.push(topId);\n', '        }\n', '        shareHolderInfos[topId] = Partner(_topAddr, _percent, true, iscontract);\n', '        emit SetShareHolders(msg.sender,topId,_topAddr,_percent,iscontract);\n', '    }\n', '    function getShareHolder(uint256 _index) public view returns(address, uint256, bool){\n', '        uint256 shareHolderId = shareHolders[_index];\n', '        return getShareHoldersInfo(shareHolderId);\n', '    }\n', '    function getShareHolderCount() public view returns(uint256){\n', '        return shareHolders.length;\n', '    }\n', '    function getShareHoldersInfo(uint256 shareHolderId) public view returns(address, uint256, bool){\n', '      return (shareHolderInfos[shareHolderId].addr, shareHolderInfos[shareHolderId].percent, shareHolderInfos[shareHolderId].iscontract);\n', '    }\n', '\n', '    function setTop(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\n', '        if (!topDefine[topId].exist){\n', '          tops.push(topId);\n', '        }\n', '        topDefine[topId] = Partner(_topAddr, _percent, true, iscontract);\n', '        emit SetTop(msg.sender, topId, _topAddr, _percent, iscontract);\n', '    }\n', '    function getTopInfoDetail(address _user) public view returns(address, uint256, bool){\n', '        uint256 _topId;\n', '        address _wallet;\n', '        uint256 _percent;\n', '        bool _contract;\n', '        (,_topId,) = getUserInfo(_user);\n', '        (_wallet,_percent,_contract) = getTopInfo(_topId);\n', '        return (_wallet,_percent,_contract);\n', '    }\n', '    function getTopInfo(uint256 topId) public view returns(address, uint256, bool){\n', '      return (topDefine[topId].addr, topDefine[topId].percent, topDefine[topId].iscontract);\n', '    }\n', '    function addUser(address _parent, uint256 _top) public {\n', '        require(msg.sender != _parent);\n', '        if (_parent != address(0)) {\n', '            require(tree[_parent].exist);\n', '        }\n', '        require(!hasUser(msg.sender));\n', '        tree[msg.sender] = UserInfo(_parent, _top, true, 0);\n', '        users.push(msg.sender);\n', '        emit AddUser(msg.sender, _parent, _top);\n', '    }\n', '\n', '    function getUsersCount() public view returns(uint) {\n', '        return users.length;\n', '    }\n', '\n', '    function getUserInfo(address _user) public view returns(address, uint256, uint256) {\n', '        return (tree[_user].parent, tree[_user].top, tree[_user].userType);\n', '    }\n', '\n', '    function hasUser(address _user) public view returns(bool) {\n', '        return tree[_user].exist;\n', '    }\n', '\n', '    function setUser(address _user, address _parent, uint256 _top, uint256 _type) public onlyAdmin {\n', '      if(!tree[_user].exist){\n', '        users.push(_user);\n', '      }\n', '      tree[_user] = UserInfo(_parent, _top, true, _type);\n', '      emit SetUser(msg.sender, _user, _parent, _top, _type);\n', '    }\n', '\n', '    function setUserType(address _user, uint _type) public onlyAdmin {\n', '        require(hasUser(_user));\n', '        tree[_user].userType = _type;\n', '        emit SetUserType(msg.sender, _user, _type);\n', '    }\n', '    function indexOfUserInfo(uint _index) public view returns (address) {\n', '        return users[_index];\n', '    }\n', '\n', '    function removeUser(uint _index) public onlyAdmin {\n', '        address _user = indexOfUserInfo(_index);\n', '        delete users[_index];\n', '        delete tree[_user];\n', '        emit RemoveUser(msg.sender, _index);\n', '    }\n', '}\n', '\n', 'contract Pausable is RBAC {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyAdmin whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyAdmin whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract BwinToken is ERC20, Pausable, Destructible{\n', '    //Token t;\n', '\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyOwner {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    string public constant name = "FFgame Coin";\n', '    string public constant symbol = "FFC";\n', '    uint8 public constant decimals = 18;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function BwinToken() public {\n', '      addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '    function totalSupply() public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.totalSupply();\n', '    }\n', '    function balanceOf(address who) public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.balanceOf(who);\n', '    }\n', '    function transfer(address to, uint256 value) public returns (bool){\n', '      bytes memory empty;\n', '      Token t = Token(commons.get("Token"));\n', '      if(t.transfer(msg.sender, to, value,empty)){\n', '          emit Transfer(msg.sender, to, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.allowance(owner, spender);\n', '    }\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool){\n', '      Token t = Token(commons.get("Token"));\n', '      if(t._transferFrom(msg.sender, from, to, value)){\n', '          emit Transfer(from, to, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    function approve(address spender, uint256 value) public returns (bool){\n', '      Token t = Token(commons.get("Token"));\n', '      if (t._approve(msg.sender, spender, value)){\n', '          emit Approval(msg.sender, spender, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '      Token t = Token(commons.get("Token"));\n', '      if(t._increaseApproval(msg.sender, _spender, _addedValue)){\n', '          emit Approval(msg.sender, _spender, _addedValue);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '      Token t = Token(commons.get("Token"));\n', '      if (t._decreaseApproval(msg.sender,_spender, _subtractedValue)){\n', '          emit Approval(msg.sender, _spender, _subtractedValue);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '}\n', '\n', 'contract Token is RBAC, Pausable{\n', '    using SafeMath for uint256;\n', '\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyAdmin {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    event TokenApproval(address indexed owner, address indexed spender, uint256 value);\n', '    event TokenTransfer(address indexed from, address indexed to, uint256 value);\n', '    event MintForSale(address indexed to, uint256 amount);\n', '    event MintForWorker(address indexed to, uint256 amount);\n', '    event MintForUnlock(address indexed to, uint256 amount);\n', '\n', '    function Token() public {\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.totalSupply();\n', '    }\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.balanceOf(_owner);\n', '    }\n', '    function _transferFrom(address _sender, address _from, address _to, uint256 _value) external whenNotPaused onlyRole("FRONT_TOKEN_USER") returns (bool) {\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      uint256 _balanceFrom = balanceOf(_from);\n', '      uint256 _balanceTo = balanceOf(_to);\n', '      uint256 _allow = allowance(_from, _sender);\n', '      require(_from != address(0));\n', '      require(_sender != address(0));\n', '      require(_to != address(0));\n', '      require(_value <= _balanceFrom);\n', '      require(_value <= _allow);\n', '      td.setBalance(_from,_balanceFrom.sub(_value));\n', '      td.setBalance(_to,_balanceTo.add(_value));\n', '      td.setAllowance(_from, _sender, _allow.sub(_value));\n', '      if(ih != address(0)){\n', '        ih.receiveBalanceUpdate(_from);\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      emit TokenTransfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.allowance(_owner,_spender);\n', '    }\n', '    function _approve(address _sender, address _spender, uint256 _value) public onlyRole("FRONT_TOKEN_USER")  whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.setAllowance(_sender, _spender, _value);\n', '    }\n', '    function _increaseApproval(address _sender, address _spender, uint _addedValue) public onlyRole("FRONT_TOKEN_USER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      td.setAllowance(_sender, _spender, allowance(_sender, _spender).add(_addedValue));\n', '      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\n', '      return true;\n', '    }\n', '    function _decreaseApproval(address _sender, address _spender, uint _subtractedValue) public onlyRole("FRONT_TOKEN_USER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      uint oldValue = allowance(_sender, _spender);\n', '      if (_subtractedValue > oldValue) {\n', '          td.setAllowance(_sender, _spender, 0);\n', '          //allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '          td.setAllowance(_sender, _spender, oldValue.sub(_subtractedValue));\n', '          //allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '      }\n', '      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\n', '      return true;\n', '    }\n', '\n', '    function unlockAmount(address _to, uint256 _amount) external onlyAdmin returns (bool){\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 unlockedAmount = td.valueOf("unlockedAmount");\n', '      if(_mint(_to, _amount)){\n', '          td.setValue("unlockedAmount",unlockedAmount.add(_amount));\n', '          emit MintForUnlock(_to, _amount);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      require(_to != address(0));\n', '      require(_amount > 0);\n', '      uint256 totalMinted = td.valueOf("totalMinted");\n', '      td.setTotal(td.totalSupply().add(_amount));\n', '      td.setBalance(_to,balanceOf(_to).add(_amount));\n', '      td.setValue("totalMinted",totalMinted.add(_amount));\n', '      if(address(ih) != address(0)){\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      return true;\n', '    }\n', '\n', '    function mintForSale(address _to, uint256 _amount) external onlyRole("TOKEN_SALE") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 saledAmount = td.valueOf("saledAmount");\n', '      if(_mint(_to, _amount)){\n', '          td.setValue("saledAmount",saledAmount.add(_amount));\n', '          emit MintForSale(_to, _amount);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    function mintForWorker(address _to, uint256 _amount) external onlyRole("TOKEN_WORKER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 minedAmount = td.valueOf("minedAmount");\n', '      if(_mint(_to, _amount)){\n', '        td.setValue("minedAmount",minedAmount.add(_amount));\n', '        emit MintForWorker(_to, _amount);\n', '        return true;\n', '      }\n', '      return false;\n', '    }\n', '    function transfer(address _from, address _to, uint _value, bytes _data) external whenNotPaused onlyRole("FRONT_TOKEN_USER")  returns (bool success) {\n', '\n', '        if (isContract(_to)) {\n', '            return transferToContract(_from, _to, _value, _data);\n', '        }else {\n', '            return transferToAddress(_from, _to, _value);\n', '        }\n', '    }\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length > 0);\n', '    }\n', '    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      require(_to != address(0));\n', '      require(_value <= balanceOf(_from));\n', '      td.setBalance(_from,balanceOf(_from).sub(_value));\n', '      td.setBalance(_to,balanceOf(_to).add(_value));\n', '      if(ih != address(0)){\n', '        ih.receiveBalanceUpdate(_from);\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      emit TokenTransfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _from, address _to, uint _value) internal returns (bool success) {\n', '        require(balanceOf(_from) >= _value);\n', '        require(_transfer(_from, _to, _value));\n', '        emit TokenTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _from, address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        require(balanceOf(_from) >= _value);\n', '        require(_transfer(_from, _to, _value));\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        emit TokenTransfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', 'contract TokenData is RBAC, Pausable{\n', '  //using SafeMath for uint256;\n', '  event TokenDataBalance(address sender, address indexed addr, uint256 value);\n', '  event TokenDataAllowance(address sender, address indexed from, address indexed to, uint256 value);\n', '  event SetTotalSupply(address _addr, uint256 _total);\n', '  mapping(address => uint256) internal balances;\n', '  mapping(string => uint256) internal values;\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  address[] internal users;\n', '\n', '  uint256 internal totalSupply_;\n', '  uint256 internal totalCapacity_;\n', '\n', '  string internal  name_;\n', '  string internal  symbol_;\n', '  uint8 internal  decimals_;\n', '  function TokenData(uint256 _totalSupply, uint256 _totalCapacity) public {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '    totalSupply_ = _totalSupply;\n', '    totalCapacity_ = _totalCapacity;\n', '  }\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyAdmin {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  function setTotal(uint256 _total) public onlyRole("TOKEN_DATA_USER") {\n', '      totalSupply_ = _total;\n', '      emit SetTotalSupply(msg.sender, _total);\n', '  }\n', '  event SetValue(address _addr, string name, uint256 _value);\n', '\n', '  function setValue(string name, uint256 _value) external onlyRole("TOKEN_DATA_USER") {\n', '      values[name] = _value;\n', '      emit SetValue(msg.sender, name, _value);\n', '  }\n', '\n', '  event SetTotalCapacity(address _addr, uint256 _total);\n', '\n', '  function setTotalCapacity(uint256 _total) external onlyRole("TOKEN_DATA_USER") {\n', '      totalCapacity_ = _total;\n', '      emit SetTotalCapacity(msg.sender, _total);\n', '  }\n', '\n', '  function valueOf(string _name) public view returns(uint256){\n', '      return values[_name];\n', '  }\n', '\n', '\n', '  function TotalCapacity() public view returns (uint256) {\n', '    return totalCapacity_;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '\n', '  function setBalance(address _addr, uint256 _value) external whenNotPaused onlyRole("TOKEN_DATA_USER") returns (bool) {\n', '    return _setBalance(_addr, _value);\n', '  }\n', '  function setAllowance(address _from, address _to, uint256 _value) external whenNotPaused onlyRole("TOKEN_DATA_USER") returns (bool) {\n', '    return _setAllowance(_from, _to, _value);\n', '  }\n', '\n', '  function setBalanceAdmin(address _addr, uint256 _value) external onlyAdmin returns (bool) {\n', '    return _setBalance(_addr, _value);\n', '  }\n', '  function setAllowanceAdmin(address _from, address _to, uint256 _value) external onlyAdmin returns (bool) {\n', '    return _setAllowance(_from, _to, _value);\n', '  }\n', '\n', '  function _setBalance(address _addr, uint256 _value) internal returns (bool) {\n', '    require(_addr != address(0));\n', '    require(_value >= 0);\n', '    balances[_addr] = _value;\n', '    emit TokenDataBalance(msg.sender, _addr, _value);\n', '    return true;\n', '  }\n', '  function _setAllowance(address _from, address _to, uint256 _value) internal returns (bool) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '    require(_value >= 0);\n', '    allowed[_from][_to] = _value;\n', '    emit TokenDataAllowance(msg.sender, _from, _to, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract Crowdsale is Ownable, Pausable{\n', '  using SafeMath for uint256;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public saleCapacity;\n', '  uint256 public saledAmount;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  event TokenPurchase(address payor, address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  function buyTokens(address payor, address beneficiary, address _parent, uint256 _top) public  payable returns(bool, uint256);\n', '  function hasEnded() public view returns (bool){\n', '      return (now > endTime || saledAmount >= saleCapacity);\n', '  }\n', '  modifier onlyFront() {\n', '      require(msg.sender == address(commons.get("CrowdsaleFront")));\n', '      _;\n', '  }\n', '  function validPurchase() internal view returns (bool) {\n', '      bool withinPeriod = now >= startTime && now <= endTime;\n', '      bool withinCapacity = saledAmount <= saleCapacity;\n', '      return withinPeriod && withinCapacity;\n', '  }\n', '\n', '  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\n', '      return weiAmount.mul(rate);\n', '  }\n', '}\n', '\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ContractReceiver {\n', '\n', '    struct TKN {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint _value, bytes _data) public pure {\n', '        TKN memory tkn;\n', '        tkn.sender = _from;\n', '        tkn.value = _value;\n', '        tkn.data = _data;\n', '        uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '        tkn.sig = bytes4(u);\n', '\n', '        /* tkn variable is analogue of msg variable of Ether transaction\n', '        *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\n', '        *  tkn.value the number of tokens that were sent   (analogue of msg.value)\n', '        *  tkn.data is data of token transaction   (analogue of msg.data)\n', '        *  tkn.sig is 4 bytes signature of function\n', '        *  if data of token transaction is a function execution\n', '        */\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract CrowdsaleFront is Ownable{\n', '    //Crowdsale public provider;\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) internal userAmounts;\n', '    mapping (address => uint256) internal rewardPayed;\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyOwner {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    // fallback function can be used to buy tokens\n', '    function () public payable {\n', '        buyTokens(msg.sender, 0, 999);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary, address _parent, uint256 _top) public payable returns(bool){\n', '      bool ret;\n', '      uint256 tokens;\n', '      (ret, tokens) = Crowdsale(commons.get("Crowdsale")).buyTokens.value(msg.value)(beneficiary, beneficiary, _parent, _top);\n', '      userAmounts[beneficiary] = userAmounts[beneficiary].add(tokens);\n', '      require(ret);\n', '    }\n', '\n', '    function getTokensFromBuy(address _addr) public view returns (uint256){\n', '      return userAmounts[_addr];\n', '    }\n', '    function rewardPayedOf(address _user) public view returns (uint256) {\n', '      return rewardPayed[_user];\n', '    }\n', '    function rewardPay(address _user, uint256 amount) public {\n', '      require(msg.sender == commons.get("Crowdsale"));\n', '      rewardPayed[_user] = rewardPayed[_user].add(amount);\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool){\n', '        return Crowdsale(commons.get("Crowdsale")).hasEnded();\n', '    }\n', '\n', '}\n', '\n', 'contract InterestHolder is Ownable{\n', '  using SafeMath for uint256;\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  bool public locked = true;\n', '  event ReceiveBalanceUpdate(address _addr,address _user);\n', '  event ReceiveBalanceUpdateUserType(address _addr,address _user,uint256 _type);\n', '  function receiveBalanceUpdate(address _user) external returns (bool) {\n', '    emit ReceiveBalanceUpdate(msg.sender, _user);\n', '    Token token = Token(commons.get("Token"));\n', '    User user = User(commons.get("User"));\n', '    if (msg.sender == address(token)){\n', '      uint256 _type;\n', '      (,,_type) = user.getUserInfo(_user);\n', '      emit ReceiveBalanceUpdateUserType(msg.sender, _user, _type);\n', '      if (_type == 0){\n', '          return true;\n', '      }\n', '      process(_user,_type);\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '  event ProcessLx(address _addr,address _user, uint256 _type,uint256 lastBalance, uint256 iAmount, uint256 lastTime);\n', '  function process(address _user, uint256 _type) internal{\n', '    Token token = Token(commons.get("Token"));\n', '    User user = User(commons.get("User"));\n', '    uint256 _value = compute(_user, _type);\n', '    uint256 balance = token.balanceOf(_user);\n', '    user.setInterestor(_user,balance.add(_value),now);\n', '    if(_value > 0){\n', '      token.mintForWorker(_user,_value);\n', '      emit ProcessLx(msg.sender, _user, _type, balance, _value, now);\n', '    }\n', '  }\n', '  event GetLx(address _addr,address _user,uint256 _type);\n', '\n', '  function compute(address _user, uint256 _type) internal view returns (uint256) {\n', '    User user = User(commons.get("User"));\n', '    uint256 lastBalance = 0;\n', '    uint256 lastTime = 0;\n', '    bool exist;\n', '    (lastBalance,lastTime,exist) = user.getInterestor(_user);\n', '    uint256 _value = 0;\n', '    if (exist && lastTime > 0){\n', '        uint256 times = now.sub(lastTime);\n', '        if (_type == 1){\n', '            _value = lastBalance.div(10000).mul(5).div(86400).mul(times);\n', '        }else if(_type == 2){\n', '            _value = lastBalance.div(10000).mul(8).div(86400).mul(times);\n', '        }\n', '    }\n', '    return _value;\n', '  }\n', '  function getLx() external returns (uint256) {\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    emit GetLx(msg.sender, msg.sender, _type);\n', '    if (_type == 0){\n', '        return 0;\n', '    }\n', '    return compute(msg.sender, _type);\n', '  }\n', '}\n', '\n', 'contract TokenHolder is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  bool locked = true;\n', '  mapping (address => uint256) lockedAmount;\n', '  event ReceiveLockedAmount(address _addr, address _user, uint256 _amount);\n', '  function receiveLockedAmount(address _user, uint256 _amount) external returns (bool) {\n', '    address cds = commons.get("Crowdsale");\n', '    if (msg.sender == address(cds)){\n', '      lockedAmount[_user] = lockedAmount[_user].add(_amount);\n', '      emit ReceiveLockedAmount(msg.sender, _user, _amount);\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function balanceOf(address _user) public view returns (uint256) {\n', '    return lockedAmount[_user];\n', '  }\n', '  function balance() public view returns (uint256) {\n', '    return lockedAmount[msg.sender];\n', '  }\n', '\n', '  function setLock(bool _locked) public onlyOwner{\n', '    locked = _locked;\n', '  }\n', '\n', '  function withDrawlocked() public view returns (bool) {\n', '      return locked;\n', '  }\n', '\n', '  function withDrawable() public view returns (bool) {\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    return !locked && (_type > 0) && lockedAmount[msg.sender] > 0;\n', '  }\n', '\n', '  function withDraw() external {\n', '    assert(!locked);//用户必须是种子钱包\n', '    BwinToken token = BwinToken(commons.get("BwinToken"));\n', '    User user = User(commons.get("User"));\n', '    uint256 _type;\n', '    (,,_type) = user.getUserInfo(msg.sender);\n', '    assert(_type > 0);\n', '    uint _value = lockedAmount[msg.sender];\n', '    lockedAmount[msg.sender] = 0;\n', '    token.transfer(msg.sender,_value);\n', '  }\n', '\n', '}\n', '\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', 'contract EtherHolder is Destructible{\n', '  using SafeMath for uint256;\n', '  bool locked = false;\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  struct Account {\n', '    address wallet;\n', '    address parent;\n', '    uint256 radio;\n', '    bool exist;\n', '  }\n', '  mapping (address => uint256) private userAmounts;\n', '  uint256 internal _balance;\n', '  event ProcessFunds(address _topWallet, uint256 _value ,bool isContract);\n', '\n', '  event ReceiveFunds(address _addr, address _user, uint256 _value, uint256 _amount);\n', '  function receiveFunds(address _user, uint256 _amount) external payable returns (bool) {\n', '    emit ReceiveFunds(msg.sender, _user, msg.value, _amount);\n', '    Crowdsale cds = Crowdsale(commons.get("Crowdsale"));\n', '    User user = User(commons.get("User"));\n', '    assert(msg.value == _amount);\n', '    if (msg.sender == address(cds)){\n', '        address _topWallet;\n', '        uint _percent=0;\n', '        bool _contract;\n', '        uint256 _topValue = 0;\n', '        bool _topOk;\n', '        uint256 _totalShares = 0;\n', '        uint256 _totalSharePercent = 0;\n', '        bool _shareRet;\n', '        if(user.hasUser(_user)){\n', '          (_topWallet,_percent,_contract) = user.getTopInfoDetail(_user);\n', '          assert(_percent <= 1000);\n', '          (_topValue,_topOk) = processFunds(_topWallet,_amount,_percent,_contract);\n', '        }else{\n', '          _topOk = true;\n', '        }\n', '        (_totalShares,_totalSharePercent,_shareRet) = processShares(_amount.sub(_topValue));\n', '        assert(_topOk && _shareRet);\n', '        assert(_topValue.add(_totalShares) <= _amount);\n', '        assert(_totalSharePercent <= 1000);\n', '        _balance = _balance.add(_amount);\n', '        return true;\n', '    }\n', '    return false;\n', '  }\n', '  event ProcessShares(uint256 _amount, uint i, uint256 _percent, bool _contract,address _wallet);\n', '  function processShares(uint256 _amount) internal returns(uint256,uint256,bool){\n', '      uint256 _sended = 0;\n', '      uint256 _sharePercent = 0;\n', '      User user = User(commons.get("User"));\n', '      for(uint i=0;i<user.getShareHolderCount();i++){\n', '        address _wallet;\n', '        uint256 _percent;\n', '        bool _contract;\n', '        emit ProcessShares(_amount, i, _percent, _contract,_wallet);\n', '        assert(_percent <= 1000);\n', '        (_wallet,_percent,_contract) = user.getShareHolder(i);\n', '        uint256 _value;\n', '        bool _valueOk;\n', '        (_value,_valueOk) = processFunds(_wallet,_amount,_percent,_contract);\n', '        _sharePercent = _sharePercent.add(_percent);\n', '        _sended = _sended.add(_value);\n', '      }\n', '      return (_sended,_sharePercent,true);\n', '  }\n', '  function getAmount(uint256 _amount, uint256 _percent) internal pure returns(uint256){\n', '      uint256 _value = _amount.div(1000).mul(_percent);\n', '      return _value;\n', '  }\n', '  function processFunds(address _topWallet, uint256 _amount ,uint256 _percent, bool isContract) internal returns(uint,bool) {\n', '      uint256 _value = getAmount(_amount, _percent);\n', '      userAmounts[_topWallet] = userAmounts[_topWallet].add(_value);\n', '      emit ProcessFunds(_topWallet,_value,isContract);\n', '      return (_value,true);\n', '  }\n', '\n', '  function balanceOf(address _user) public view returns (uint256) {\n', '    return userAmounts[_user];\n', '  }\n', '\n', '  function balanceOfme() public view returns (uint256) {\n', '    return userAmounts[msg.sender];\n', '  }\n', '\n', '  function withDrawlocked() public view returns (bool) {\n', '      return locked;\n', '  }\n', '  function getBalance() public view returns (uint256, uint256) {\n', '    return (address(this).balance,_balance);\n', '  }\n', '  function lock(bool _locked) public onlyOwner{\n', '    locked = _locked;\n', '  }\n', '  event WithDraw(address caller, uint256 _amount);\n', '\n', '  function withDraw(uint256 _amount) external {\n', '    assert(!locked);\n', '    assert(userAmounts[msg.sender] >= _amount);\n', '    userAmounts[msg.sender] = userAmounts[msg.sender].sub(_amount);\n', '    _balance = _balance.sub(_amount);\n', '    msg.sender.transfer(_amount);\n', '    emit WithDraw(msg.sender, _amount);\n', '  }\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBAC()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract BwinCommons is RBAC, Destructible {\n', '    mapping (string => address) internal addresses;\n', '    mapping (address => string) internal names;\n', '\n', '    event UpdateRegistration(string key, address old, address n);\n', '\n', '    function register(string key, address ad) public onlyAdmin {\n', '        emit UpdateRegistration(key, addresses[key], ad);\n', '        addresses[key] = ad;\n', '        names[ad] = key;\n', '    }\n', '\n', '    function get(string key) public view returns(address) {\n', '        return addresses[key];\n', '    }\n', '\n', '    function remove() public {\n', '      string memory key = names[msg.sender];\n', '      delete addresses[key];\n', '      delete names[msg.sender];\n', '    }\n', '}\n', '\n', 'contract User is RBAC ,Destructible{\n', '    struct UserInfo {\n', '        //推荐人\n', '        address parent;\n', '        uint256 top;\n', '        bool exist;\n', '        uint256 userType;\n', '    }\n', '\n', '    struct Partner {\n', '      address addr;\n', '      uint256 percent;\n', '      bool exist;\n', '      bool iscontract;\n', '    }\n', '\n', '    struct UserBalance{\n', '        address user;\n', '        uint256 balance;\n', '        uint256 lastTime;\n', '        bool exist;\n', '    }\n', '    mapping (address => UserBalance) internal balanceForInterests;\n', '    uint256[] internal tops;\n', '    mapping (uint256 => Partner) internal topDefine;\n', '\n', '    uint256[] internal shareHolders;\n', '    mapping (uint256 => Partner) internal shareHolderInfos;\n', '    mapping (address => UserInfo) internal tree;\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyAdmin {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '\n', '\n', '    address[] internal users;\n', '    event SetInterestor(address caller, address _user, uint256 _balance, uint256 _lastTime);\n', '    event SetShareHolders(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\n', '    event SetTop(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\n', '    event AddUser(address caller, address _parent, uint256 _top);\n', '    event SetUser(address caller, address _user, address _parent, uint256 _top, uint256 _type);\n', '    event SetUserType(address caller, address _user, uint _type);\n', '    event RemoveUser(address caller, uint _index);\n', '\n', '    function setInterestor(address _user, uint256 _balance, uint256 _lastTime) public onlyRole("INTEREST_HOLDER"){\n', '        balanceForInterests[_user] = UserBalance(_user,_balance,_lastTime,true);\n', '        emit SetInterestor(msg.sender,_user,_balance,_lastTime);\n', '    }\n', '\n', '    function getInterestor(address _user) public view returns(uint256,uint256,bool){\n', '        return (balanceForInterests[_user].balance,balanceForInterests[_user].lastTime,balanceForInterests[_user].exist);\n', '    }\n', '    function setShareHolders(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\n', '        if (!shareHolderInfos[topId].exist){\n', '          shareHolders.push(topId);\n', '        }\n', '        shareHolderInfos[topId] = Partner(_topAddr, _percent, true, iscontract);\n', '        emit SetShareHolders(msg.sender,topId,_topAddr,_percent,iscontract);\n', '    }\n', '    function getShareHolder(uint256 _index) public view returns(address, uint256, bool){\n', '        uint256 shareHolderId = shareHolders[_index];\n', '        return getShareHoldersInfo(shareHolderId);\n', '    }\n', '    function getShareHolderCount() public view returns(uint256){\n', '        return shareHolders.length;\n', '    }\n', '    function getShareHoldersInfo(uint256 shareHolderId) public view returns(address, uint256, bool){\n', '      return (shareHolderInfos[shareHolderId].addr, shareHolderInfos[shareHolderId].percent, shareHolderInfos[shareHolderId].iscontract);\n', '    }\n', '\n', '    function setTop(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\n', '        if (!topDefine[topId].exist){\n', '          tops.push(topId);\n', '        }\n', '        topDefine[topId] = Partner(_topAddr, _percent, true, iscontract);\n', '        emit SetTop(msg.sender, topId, _topAddr, _percent, iscontract);\n', '    }\n', '    function getTopInfoDetail(address _user) public view returns(address, uint256, bool){\n', '        uint256 _topId;\n', '        address _wallet;\n', '        uint256 _percent;\n', '        bool _contract;\n', '        (,_topId,) = getUserInfo(_user);\n', '        (_wallet,_percent,_contract) = getTopInfo(_topId);\n', '        return (_wallet,_percent,_contract);\n', '    }\n', '    function getTopInfo(uint256 topId) public view returns(address, uint256, bool){\n', '      return (topDefine[topId].addr, topDefine[topId].percent, topDefine[topId].iscontract);\n', '    }\n', '    function addUser(address _parent, uint256 _top) public {\n', '        require(msg.sender != _parent);\n', '        if (_parent != address(0)) {\n', '            require(tree[_parent].exist);\n', '        }\n', '        require(!hasUser(msg.sender));\n', '        tree[msg.sender] = UserInfo(_parent, _top, true, 0);\n', '        users.push(msg.sender);\n', '        emit AddUser(msg.sender, _parent, _top);\n', '    }\n', '\n', '    function getUsersCount() public view returns(uint) {\n', '        return users.length;\n', '    }\n', '\n', '    function getUserInfo(address _user) public view returns(address, uint256, uint256) {\n', '        return (tree[_user].parent, tree[_user].top, tree[_user].userType);\n', '    }\n', '\n', '    function hasUser(address _user) public view returns(bool) {\n', '        return tree[_user].exist;\n', '    }\n', '\n', '    function setUser(address _user, address _parent, uint256 _top, uint256 _type) public onlyAdmin {\n', '      if(!tree[_user].exist){\n', '        users.push(_user);\n', '      }\n', '      tree[_user] = UserInfo(_parent, _top, true, _type);\n', '      emit SetUser(msg.sender, _user, _parent, _top, _type);\n', '    }\n', '\n', '    function setUserType(address _user, uint _type) public onlyAdmin {\n', '        require(hasUser(_user));\n', '        tree[_user].userType = _type;\n', '        emit SetUserType(msg.sender, _user, _type);\n', '    }\n', '    function indexOfUserInfo(uint _index) public view returns (address) {\n', '        return users[_index];\n', '    }\n', '\n', '    function removeUser(uint _index) public onlyAdmin {\n', '        address _user = indexOfUserInfo(_index);\n', '        delete users[_index];\n', '        delete tree[_user];\n', '        emit RemoveUser(msg.sender, _index);\n', '    }\n', '}\n', '\n', 'contract Pausable is RBAC {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyAdmin whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyAdmin whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract BwinToken is ERC20, Pausable, Destructible{\n', '    //Token t;\n', '\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyOwner {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    string public constant name = "FFgame Coin";\n', '    string public constant symbol = "FFC";\n', '    uint8 public constant decimals = 18;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function BwinToken() public {\n', '      addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '    function totalSupply() public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.totalSupply();\n', '    }\n', '    function balanceOf(address who) public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.balanceOf(who);\n', '    }\n', '    function transfer(address to, uint256 value) public returns (bool){\n', '      bytes memory empty;\n', '      Token t = Token(commons.get("Token"));\n', '      if(t.transfer(msg.sender, to, value,empty)){\n', '          emit Transfer(msg.sender, to, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256){\n', '      Token t = Token(commons.get("Token"));\n', '      return t.allowance(owner, spender);\n', '    }\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool){\n', '      Token t = Token(commons.get("Token"));\n', '      if(t._transferFrom(msg.sender, from, to, value)){\n', '          emit Transfer(from, to, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    function approve(address spender, uint256 value) public returns (bool){\n', '      Token t = Token(commons.get("Token"));\n', '      if (t._approve(msg.sender, spender, value)){\n', '          emit Approval(msg.sender, spender, value);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '      Token t = Token(commons.get("Token"));\n', '      if(t._increaseApproval(msg.sender, _spender, _addedValue)){\n', '          emit Approval(msg.sender, _spender, _addedValue);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '      Token t = Token(commons.get("Token"));\n', '      if (t._decreaseApproval(msg.sender,_spender, _subtractedValue)){\n', '          emit Approval(msg.sender, _spender, _subtractedValue);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '}\n', '\n', 'contract Token is RBAC, Pausable{\n', '    using SafeMath for uint256;\n', '\n', '    BwinCommons internal commons;\n', '    function setCommons(address _addr) public onlyAdmin {\n', '        commons = BwinCommons(_addr);\n', '    }\n', '    event TokenApproval(address indexed owner, address indexed spender, uint256 value);\n', '    event TokenTransfer(address indexed from, address indexed to, uint256 value);\n', '    event MintForSale(address indexed to, uint256 amount);\n', '    event MintForWorker(address indexed to, uint256 amount);\n', '    event MintForUnlock(address indexed to, uint256 amount);\n', '\n', '    function Token() public {\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.totalSupply();\n', '    }\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.balanceOf(_owner);\n', '    }\n', '    function _transferFrom(address _sender, address _from, address _to, uint256 _value) external whenNotPaused onlyRole("FRONT_TOKEN_USER") returns (bool) {\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      uint256 _balanceFrom = balanceOf(_from);\n', '      uint256 _balanceTo = balanceOf(_to);\n', '      uint256 _allow = allowance(_from, _sender);\n', '      require(_from != address(0));\n', '      require(_sender != address(0));\n', '      require(_to != address(0));\n', '      require(_value <= _balanceFrom);\n', '      require(_value <= _allow);\n', '      td.setBalance(_from,_balanceFrom.sub(_value));\n', '      td.setBalance(_to,_balanceTo.add(_value));\n', '      td.setAllowance(_from, _sender, _allow.sub(_value));\n', '      if(ih != address(0)){\n', '        ih.receiveBalanceUpdate(_from);\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      emit TokenTransfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.allowance(_owner,_spender);\n', '    }\n', '    function _approve(address _sender, address _spender, uint256 _value) public onlyRole("FRONT_TOKEN_USER")  whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      return td.setAllowance(_sender, _spender, _value);\n', '    }\n', '    function _increaseApproval(address _sender, address _spender, uint _addedValue) public onlyRole("FRONT_TOKEN_USER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      td.setAllowance(_sender, _spender, allowance(_sender, _spender).add(_addedValue));\n', '      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\n', '      return true;\n', '    }\n', '    function _decreaseApproval(address _sender, address _spender, uint _subtractedValue) public onlyRole("FRONT_TOKEN_USER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      uint oldValue = allowance(_sender, _spender);\n', '      if (_subtractedValue > oldValue) {\n', '          td.setAllowance(_sender, _spender, 0);\n', '          //allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '          td.setAllowance(_sender, _spender, oldValue.sub(_subtractedValue));\n', '          //allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '      }\n', '      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\n', '      return true;\n', '    }\n', '\n', '    function unlockAmount(address _to, uint256 _amount) external onlyAdmin returns (bool){\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 unlockedAmount = td.valueOf("unlockedAmount");\n', '      if(_mint(_to, _amount)){\n', '          td.setValue("unlockedAmount",unlockedAmount.add(_amount));\n', '          emit MintForUnlock(_to, _amount);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      require(_to != address(0));\n', '      require(_amount > 0);\n', '      uint256 totalMinted = td.valueOf("totalMinted");\n', '      td.setTotal(td.totalSupply().add(_amount));\n', '      td.setBalance(_to,balanceOf(_to).add(_amount));\n', '      td.setValue("totalMinted",totalMinted.add(_amount));\n', '      if(address(ih) != address(0)){\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      return true;\n', '    }\n', '\n', '    function mintForSale(address _to, uint256 _amount) external onlyRole("TOKEN_SALE") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 saledAmount = td.valueOf("saledAmount");\n', '      if(_mint(_to, _amount)){\n', '          td.setValue("saledAmount",saledAmount.add(_amount));\n', '          emit MintForSale(_to, _amount);\n', '          return true;\n', '      }\n', '      return false;\n', '    }\n', '    function mintForWorker(address _to, uint256 _amount) external onlyRole("TOKEN_WORKER") whenNotPaused returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\n', '      uint256 minedAmount = td.valueOf("minedAmount");\n', '      if(_mint(_to, _amount)){\n', '        td.setValue("minedAmount",minedAmount.add(_amount));\n', '        emit MintForWorker(_to, _amount);\n', '        return true;\n', '      }\n', '      return false;\n', '    }\n', '    function transfer(address _from, address _to, uint _value, bytes _data) external whenNotPaused onlyRole("FRONT_TOKEN_USER")  returns (bool success) {\n', '\n', '        if (isContract(_to)) {\n', '            return transferToContract(_from, _to, _value, _data);\n', '        }else {\n', '            return transferToAddress(_from, _to, _value);\n', '        }\n', '    }\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length > 0);\n', '    }\n', '    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '      TokenData td = TokenData(commons.get("TokenData"));\n', '      InterestHolder ih = InterestHolder(commons.get("InterestHolder"));\n', '      require(_to != address(0));\n', '      require(_value <= balanceOf(_from));\n', '      td.setBalance(_from,balanceOf(_from).sub(_value));\n', '      td.setBalance(_to,balanceOf(_to).add(_value));\n', '      if(ih != address(0)){\n', '        ih.receiveBalanceUpdate(_from);\n', '        ih.receiveBalanceUpdate(_to);\n', '      }\n', '      emit TokenTransfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _from, address _to, uint _value) internal returns (bool success) {\n', '        require(balanceOf(_from) >= _value);\n', '        require(_transfer(_from, _to, _value));\n', '        emit TokenTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _from, address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        require(balanceOf(_from) >= _value);\n', '        require(_transfer(_from, _to, _value));\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        emit TokenTransfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', 'contract TokenData is RBAC, Pausable{\n', '  //using SafeMath for uint256;\n', '  event TokenDataBalance(address sender, address indexed addr, uint256 value);\n', '  event TokenDataAllowance(address sender, address indexed from, address indexed to, uint256 value);\n', '  event SetTotalSupply(address _addr, uint256 _total);\n', '  mapping(address => uint256) internal balances;\n', '  mapping(string => uint256) internal values;\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  address[] internal users;\n', '\n', '  uint256 internal totalSupply_;\n', '  uint256 internal totalCapacity_;\n', '\n', '  string internal  name_;\n', '  string internal  symbol_;\n', '  uint8 internal  decimals_;\n', '  function TokenData(uint256 _totalSupply, uint256 _totalCapacity) public {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '    totalSupply_ = _totalSupply;\n', '    totalCapacity_ = _totalCapacity;\n', '  }\n', '\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyAdmin {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  function setTotal(uint256 _total) public onlyRole("TOKEN_DATA_USER") {\n', '      totalSupply_ = _total;\n', '      emit SetTotalSupply(msg.sender, _total);\n', '  }\n', '  event SetValue(address _addr, string name, uint256 _value);\n', '\n', '  function setValue(string name, uint256 _value) external onlyRole("TOKEN_DATA_USER") {\n', '      values[name] = _value;\n', '      emit SetValue(msg.sender, name, _value);\n', '  }\n', '\n', '  event SetTotalCapacity(address _addr, uint256 _total);\n', '\n', '  function setTotalCapacity(uint256 _total) external onlyRole("TOKEN_DATA_USER") {\n', '      totalCapacity_ = _total;\n', '      emit SetTotalCapacity(msg.sender, _total);\n', '  }\n', '\n', '  function valueOf(string _name) public view returns(uint256){\n', '      return values[_name];\n', '  }\n', '\n', '\n', '  function TotalCapacity() public view returns (uint256) {\n', '    return totalCapacity_;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '\n', '  function setBalance(address _addr, uint256 _value) external whenNotPaused onlyRole("TOKEN_DATA_USER") returns (bool) {\n', '    return _setBalance(_addr, _value);\n', '  }\n', '  function setAllowance(address _from, address _to, uint256 _value) external whenNotPaused onlyRole("TOKEN_DATA_USER") returns (bool) {\n', '    return _setAllowance(_from, _to, _value);\n', '  }\n', '\n', '  function setBalanceAdmin(address _addr, uint256 _value) external onlyAdmin returns (bool) {\n', '    return _setBalance(_addr, _value);\n', '  }\n', '  function setAllowanceAdmin(address _from, address _to, uint256 _value) external onlyAdmin returns (bool) {\n', '    return _setAllowance(_from, _to, _value);\n', '  }\n', '\n', '  function _setBalance(address _addr, uint256 _value) internal returns (bool) {\n', '    require(_addr != address(0));\n', '    require(_value >= 0);\n', '    balances[_addr] = _value;\n', '    emit TokenDataBalance(msg.sender, _addr, _value);\n', '    return true;\n', '  }\n', '  function _setAllowance(address _from, address _to, uint256 _value) internal returns (bool) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '    require(_value >= 0);\n', '    allowed[_from][_to] = _value;\n', '    emit TokenDataAllowance(msg.sender, _from, _to, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract Crowdsale is Ownable, Pausable{\n', '  using SafeMath for uint256;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public saleCapacity;\n', '  uint256 public saledAmount;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  event TokenPurchase(address payor, address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  BwinCommons internal commons;\n', '  function setCommons(address _addr) public onlyOwner {\n', '      commons = BwinCommons(_addr);\n', '  }\n', '  function buyTokens(address payor, address beneficiary, address _parent, uint256 _top) public  payable returns(bool, uint256);\n', '  function hasEnded() public view returns (bool){\n', '      return (now > endTime || saledAmount >= saleCapacity);\n', '  }\n', '  modifier onlyFront() {\n', '      require(msg.sender == address(commons.get("CrowdsaleFront")));\n', '      _;\n', '  }\n', '  function validPurchase() internal view returns (bool) {\n', '      bool withinPeriod = now >= startTime && now <= endTime;\n', '      bool withinCapacity = saledAmount <= saleCapacity;\n', '      return withinPeriod && withinCapacity;\n', '  }\n', '\n', '  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\n', '      return weiAmount.mul(rate);\n', '  }\n', '}\n', '\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}']
