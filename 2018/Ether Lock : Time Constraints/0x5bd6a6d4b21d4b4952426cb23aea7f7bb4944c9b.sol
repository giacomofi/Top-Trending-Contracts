['pragma solidity ^ 0.4.25;\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '//                 Recon&#174; Token Teleportation Service v1.10\n', '//\n', '//                           of BlockReconChain&#174;\n', '//                             for ReconBank&#174;\n', '//\n', '//                     ERC Token Standard #20 Interface\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//.\n', '//"\n', '//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\n', '//.           ;;;;``;;;; ;;;;&#39;&#39;&#39;&#39; ,;;;&#39;````&#39;  .;;;;;;;.`;;;;,  `;;;\n', '//.            [[[,/[[[&#39;  [[cccc  [[[        ,[[     \\[[,[[[[[. &#39;[[\n', '//.            $$$$$$c    $$""""  $$$        $$$,     $$$$$$ "Y$c$$\n', '//.            888b "88bo,888oo,__`88bo,__,o,"888,_ _,88P888    Y88\n', '//.            MMMM   "W" """"YUMMM "YUMMMMMP" "YMMMMMP" MMM     YM\n', '//.\n', '//.\n', '//" -----------------------------------------------------------------------------------------------------------------\n', '//             &#184;.•*&#180;&#168;)\n', '//        &#184;.•&#180;   &#184;.•&#180;&#184;.•*&#180;&#168;) &#184;.•*&#168;)\n', '//  &#184;.•*&#180;       (&#184;.•&#180; (&#184;.•` &#164; ReconBank.eth / ReconBank.com*&#180;&#168;)\n', '//                                                        &#184;.•&#180;&#184;.•*&#180;&#168;)\n', '//                                                      (&#184;.•&#180;   &#184;.•`\n', '//                                                          &#184;.•&#180;•.&#184;\n', '//   (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// Common ownership of :\n', '//  ____  _            _    _____                       _____ _           _\n', '// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\n', '// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\n', '// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| &#39;_ \\| |    | &#39;_ \\ / _` | | &#39;_ \\\n', '// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\n', '// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|&#174;\n', '//&#39;\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// This contract is an order from :\n', '//&#39;\n', '// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗&#174;\n', '// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\n', '// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\n', '// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\n', '// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n', '// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝&#39;\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '//\n', '//                                 Copyright MIT :\n', '//                      GNU Lesser General Public License 3.0\n', '//                  https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '//\n', '//              Permission is hereby granted, free of charge, to\n', '//              any person obtaining a copy of this software and\n', '//              associated documentation files ReconCoin&#174; Token\n', '//              Teleportation Service, to deal in the Software without\n', '//              restriction, including without limitation the rights to\n', '//              use, copy, modify, merge, publish, distribute,\n', '//              sublicense, and/or sell copies of the Software, and\n', '//              to permit persons to whom the Software is furnished\n', '//              to do so, subject to the following conditions:\n', '//              The above copyright notice and this permission\n', '//              notice shall be included in all copies or substantial\n', '//              portions of the Software.\n', '//\n', '//                 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT\n', '//                 WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', '//                 INCLUDING BUT NOT LIMITED TO THE\n', '//                 WARRANTIES OF MERCHANTABILITY, FITNESS FOR\n', '//                 A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', '//                 IN NO EVENT SHALL THE AUTHORS OR\n', '//                 COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n', '//                 DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n', '//                 ACTION OF CONTRACT, TORT OR\n', '//                 OTHERWISE, ARISING FROM, OUT OF OR IN\n', '//                 CONNECTION WITH THE SOFTWARE OR THE USE\n', '//                 OR OTHER DEALINGS IN THE SOFTWARE.\n', '//\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '// The new assembly support in Solidity makes writing helpers easy.\n', '// Many have complained how complex it is to use `ecrecover`, especially in conjunction\n', '// with the `eth_sign` RPC call. Here is a helper, which makes that a matter of a single call.\n', '//\n', '// Sample input parameters:\n', '// (with v=0)\n', '// "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad",\n', '// "0xaca7da997ad177f040240cdccf6905b71ab16b74434388c3a72f34fd25d6439346b2bac274ff29b48b3ea6e2d04c1336eaceafda3c53ab483fc3ff12fac3ebf200",\n', '// "0x0e5cb767cce09a7f3ca594df118aa519be5e2b5a"\n', '//\n', '// (with v=1)\n', '// "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad",\n', '// "0xdebaaa0cddb321b2dcaaf846d39605de7b97e77ba6106587855b9106cb10421561a22d94fa8b8a687ff9c911c844d1c016d1a685a9166858f9c7c1bc85128aca01",\n', '// "0x8743523d96a1b2cbe0c6909653a56da18ed484af"\n', '//\n', '// (The hash is a hash of "hello world".)\n', '//\n', '// Written by Alex Beregszaszi (@axic), use it under the terms of the MIT license.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'library ReconVerify {\n', '    // Duplicate Soliditys ecrecover, but catching the CALL return value\n', '    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n', '        // We do our own memory management here. Solidity uses memory offset\n', '        // 0x40 to store the current end of memory. We write past it (as\n', '        // writes are memory extensions), but dont update the offset so\n', '        // Solidity will reuse it. The memory used here is only needed for\n', '        // this context.\n', '\n', '        // FIXME: inline assembly cant access return values\n', '        bool ret;\n', '        address addr;\n', '\n', '        assembly {\n', '            let size := mload(0x40)\n', '            mstore(size, hash)\n', '            mstore(add(size, 32), v)\n', '            mstore(add(size, 64), r)\n', '            mstore(add(size, 96), s)\n', '\n', '            // NOTE: we can reuse the request memory because we deal with\n', '            //       the return code\n', '            ret := call(3000, 1, 0, size, 128, size, 32)\n', '            addr := mload(size)\n', '        }\n', '\n', '        return (ret, addr);\n', '    }\n', '\n', '    function ecrecovery(bytes32 hash, bytes sig) public returns (bool, address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (sig.length != 65)\n', '          return (false, 0);\n', '\n', '        // The signature format is a compact form of:\n', '        //   {bytes32 r}{bytes32 s}{uint8 v}\n', '        // Compact means, uint8 is not padded to 32 bytes.\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '\n', '            // Here we are loading the last 32 bytes. We exploit the fact that\n', '            // &#39;mload&#39; will pad with zeroes if we overread.\n', '            // There is no &#39;mload8&#39; to do this, but that would be nicer.\n', '            v := byte(0, mload(add(sig, 96)))\n', '\n', '            // Alternative solution:\n', '            // &#39;byte&#39; is not working due to the Solidity parser, so lets\n', '            // use the second best option, &#39;and&#39;\n', '            // v := and(mload(add(sig, 65)), 255)\n', '        }\n', '\n', '        // albeit non-transactional signatures are not specified by the YP, one would expect it\n', '        // to match the YP range of [27, 28]\n', '        //\n', '        // geth uses [0, 1] and some clients have followed. This might change, see:\n', '        //  https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27)\n', '          v += 27;\n', '\n', '        if (v != 27 && v != 28)\n', '            return (false, 0);\n', '\n', '        return safer_ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    function verify(bytes32 hash, bytes sig, address signer) public returns (bool) {\n', '        bool ret;\n', '        address addr;\n', '        (ret, addr) = ecrecovery(hash, sig);\n', '        return ret == true && addr == signer;\n', '    }\n', '\n', '    function recover(bytes32 hash, bytes sig) internal returns (address addr) {\n', '        bool ret;\n', '        (ret, addr) = ecrecovery(hash, sig);\n', '    }\n', '}\n', '\n', 'contract ReconVerifyTest {\n', '    function test_v0() public returns (bool) {\n', '        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\n', '        bytes memory sig = "\\xac\\xa7\\xda\\x99\\x7a\\xd1\\x77\\xf0\\x40\\x24\\x0c\\xdc\\xcf\\x69\\x05\\xb7\\x1a\\xb1\\x6b\\x74\\x43\\x43\\x88\\xc3\\xa7\\x2f\\x34\\xfd\\x25\\xd6\\x43\\x93\\x46\\xb2\\xba\\xc2\\x74\\xff\\x29\\xb4\\x8b\\x3e\\xa6\\xe2\\xd0\\x4c\\x13\\x36\\xea\\xce\\xaf\\xda\\x3c\\x53\\xab\\x48\\x3f\\xc3\\xff\\x12\\xfa\\xc3\\xeb\\xf2\\x00";\n', '        return ReconVerify.verify(hash, sig, 0x0A5f85C3d41892C934ae82BDbF17027A20717088);\n', '    }\n', '\n', '    function test_v1() public returns (bool) {\n', '        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\n', '        bytes memory sig = "\\xde\\xba\\xaa\\x0c\\xdd\\xb3\\x21\\xb2\\xdc\\xaa\\xf8\\x46\\xd3\\x96\\x05\\xde\\x7b\\x97\\xe7\\x7b\\xa6\\x10\\x65\\x87\\x85\\x5b\\x91\\x06\\xcb\\x10\\x42\\x15\\x61\\xa2\\x2d\\x94\\xfa\\x8b\\x8a\\x68\\x7f\\xf9\\xc9\\x11\\xc8\\x44\\xd1\\xc0\\x16\\xd1\\xa6\\x85\\xa9\\x16\\x68\\x58\\xf9\\xc7\\xc1\\xbc\\x85\\x12\\x8a\\xca\\x01";\n', '        return ReconVerify.verify(hash, sig, 0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function ReconOwned()  public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner  public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract tokenRecipient {\n', '    event receivedEther(address sender, uint amount);\n', '    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '        Token t = Token(_token);\n', '        require(t.transferFrom(_from, this, _value));\n', '        emit receivedTokens(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    function () payable  public {\n', '        emit receivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', '\n', 'interface Token {\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '}\n', '\n', '\n', 'contract Congress is owned, tokenRecipient {\n', '    // Contract Variables and events\n', '    uint public minimumQuorum;\n', '    uint public debatingPeriodInMinutes;\n', '    int public majorityMargin;\n', '    Proposal[] public proposals;\n', '    uint public numProposals;\n', '    mapping (address => uint) public memberId;\n', '    Member[] public members;\n', '\n', '    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n', '    event Voted(uint proposalID, bool position, address voter, string justification);\n', '    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n', '    event MembershipChanged(address member, bool isMember);\n', '    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);\n', '\n', '    struct Proposal {\n', '        address recipient;\n', '        uint amount;\n', '        string description;\n', '        uint minExecutionDate;\n', '        bool executed;\n', '        bool proposalPassed;\n', '        uint numberOfVotes;\n', '        int currentResult;\n', '        bytes32 proposalHash;\n', '        Vote[] votes;\n', '        mapping (address => bool) voted;\n', '    }\n', '\n', '    struct Member {\n', '        address member;\n', '        string name;\n', '        uint memberSince;\n', '    }\n', '\n', '    struct Vote {\n', '        bool inSupport;\n', '        address voter;\n', '        string justification;\n', '    }\n', '\n', '    // Modifier that allows only shareholders to vote and create new proposals\n', '    modifier onlyMembers {\n', '        require(memberId[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    function ReconCongress (\n', '        uint minimumQuorumForProposals,\n', '        uint minutesForDebate,\n', '        int marginOfVotesForMajority\n', '    )  payable public {\n', '        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);\n', '        // It’s necessary to add an empty first member\n', '        addMember(0, "");\n', '        // and lets add the founder, to save a step later\n', '        addMember(owner, &#39;founder&#39;);\n', '    }\n', '\n', '    /**\n', '     * Add member\n', '     *\n', '     * Make `targetMember` a member named `memberName`\n', '     *\n', '     * @param targetMember ethereum address to be added\n', '     * @param memberName public name for that member\n', '     */\n', '    function addMember(address targetMember, string memberName) onlyOwner public {\n', '        uint id = memberId[targetMember];\n', '        if (id == 0) {\n', '            memberId[targetMember] = members.length;\n', '            id = members.length++;\n', '        }\n', '\n', '        members[id] = Member({member: targetMember, memberSince: now, name: memberName});\n', '        emit MembershipChanged(targetMember, true);\n', '    }\n', '\n', '    /**\n', '     * Remove member\n', '     *\n', '     * @notice Remove membership from `targetMember`\n', '     *\n', '     * @param targetMember ethereum address to be removed\n', '     */\n', '    function removeMember(address targetMember) onlyOwner public {\n', '        require(memberId[targetMember] != 0);\n', '\n', '        for (uint i = memberId[targetMember]; i<members.length-1; i++){\n', '            members[i] = members[i+1];\n', '        }\n', '        delete members[members.length-1];\n', '        members.length--;\n', '    }\n', '\n', '    /**\n', '     * Change voting rules\n', '     *\n', '     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n', '     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n', '     *\n', '     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n', '     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n', '     * @param marginOfVotesForMajority the proposal needs to have 50% plus this number\n', '     */\n', '    function changeVotingRules(\n', '        uint minimumQuorumForProposals,\n', '        uint minutesForDebate,\n', '        int marginOfVotesForMajority\n', '    ) onlyOwner public {\n', '        minimumQuorum = minimumQuorumForProposals;\n', '        debatingPeriodInMinutes = minutesForDebate;\n', '        majorityMargin = marginOfVotesForMajority;\n', '\n', '        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\n', '    }\n', '\n', '    /**\n', '     * Add Proposal\n', '     *\n', '     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send, in wei\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposal(\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyMembers public\n', '        returns (uint proposalID)\n', '    {\n', '        proposalID = proposals.length++;\n', '        Proposal storage p = proposals[proposalID];\n', '        p.recipient = beneficiary;\n', '        p.amount = weiAmount;\n', '        p.description = jobDescription;\n', '        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n', '        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\n', '        p.executed = false;\n', '        p.proposalPassed = false;\n', '        p.numberOfVotes = 0;\n', '        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n', '        numProposals = proposalID+1;\n', '\n', '        return proposalID;\n', '    }\n', '\n', '    /**\n', '     * Add proposal in Ether\n', '     *\n', '     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     * This is a convenience function to use if the amount to be given is in round number of ether units.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param etherAmount amount of ether to send\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposalInEther(\n', '        address beneficiary,\n', '        uint etherAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyMembers public\n', '        returns (uint proposalID)\n', '    {\n', '        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n', '    }\n', '\n', '    /**\n', '     * Check if a proposal code matches\n', '     *\n', '     * @param proposalNumber ID number of the proposal to query\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function checkProposalCode(\n', '        uint proposalNumber,\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        bytes transactionBytecode\n', '    )\n', '        constant public\n', '        returns (bool codeChecksOut)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber];\n', '        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n', '    }\n', '\n', '    /**\n', '     * Log a vote for a proposal\n', '     *\n', '     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n', '     *\n', '     * @param proposalNumber number of proposal\n', '     * @param supportsProposal either in favor or against it\n', '     * @param justificationText optional justification text\n', '     */\n', '    function vote(\n', '        uint proposalNumber,\n', '        bool supportsProposal,\n', '        string justificationText\n', '    )\n', '        onlyMembers public\n', '        returns (uint voteID)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n', '        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n', '        p.voted[msg.sender] = true;                     // Set this voter as having voted\n', '        p.numberOfVotes++;                              // Increase the number of votes\n', '        if (supportsProposal) {                         // If they support the proposal\n', '            p.currentResult++;                          // Increase score\n', '        } else {                                        // If they dont\n', '            p.currentResult--;                          // Decrease the score\n', '        }\n', '\n', '        // Create a log of this event\n', '        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n', '        return p.numberOfVotes;\n', '    }\n', '\n', '    /**\n', '     * Finish vote\n', '     *\n', '     * Count the votes proposal #`proposalNumber` and execute it if approved\n', '     *\n', '     * @param proposalNumber proposal number\n', '     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n', '     */\n', '    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\n', '        Proposal storage p = proposals[proposalNumber];\n', '\n', '        require(now > p.minExecutionDate                                            // If it is past the voting deadline\n', '            && !p.executed                                                         // and it has not already been executed\n', '            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n', '            && p.numberOfVotes >= minimumQuorum);                                  // and a minimum quorum has been reached...\n', '\n', '        // ...then execute result\n', '\n', '        if (p.currentResult > majorityMargin) {\n', '            // Proposal passed; execute the transaction\n', '\n', '            p.executed = true; // Avoid recursive calling\n', '            require(p.recipient.call.value(p.amount)(transactionBytecode));\n', '\n', '            p.proposalPassed = true;\n', '        } else {\n', '            // Proposal failed\n', '            p.proposalPassed = false;\n', '        }\n', '\n', '        // Fire Events\n', '        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Recon DateTime Library v1.00\n', '//\n', '// A energy-efficient Solidity date and time library\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit      | Range         | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year      | 1970 ... 2345 |\n', '// month     | 1 ... 12      |\n', '// day       | 1 ... 31      |\n', '// hour      | 0 ... 23      |\n', '// minute    | 0 ... 59      |\n', '// second    | 0 ... 59      |\n', '// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// GNU Lesser General Public License 3.0\n', '// https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'library ReconDateTimeLibrary {\n', '\n', '    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n', '    uint constant SECONDS_PER_HOUR = 60 * 60;\n', '    uint constant SECONDS_PER_MINUTE = 60;\n', '    int constant OFFSET19700101 = 2440588;\n', '\n', '    uint constant DOW_MON = 1;\n', '    uint constant DOW_TUE = 2;\n', '    uint constant DOW_WED = 3;\n', '    uint constant DOW_THU = 4;\n', '    uint constant DOW_FRI = 5;\n', '    uint constant DOW_SAT = 6;\n', '    uint constant DOW_SUN = 7;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate the number of days from 1970/01/01 to year/month/day using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // days = day\n', '    //      - 32075\n', '    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n', '    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n', '    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n', '    //      - offset\n', '    // ------------------------------------------------------------------------\n', '    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n', '        int _year = int(year);\n', '        int _month = int(month);\n', '        int _day = int(day);\n', '\n', '        int __days = _day\n', '          - 32075\n', '          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n', '          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n', '          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n', '          - OFFSET19700101;\n', '\n', '        _days = uint(__days);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate year/month/day from the number of days since 1970/01/01 using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and adding the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // int L = days + 68569 + offset\n', '    // int N = 4 * L / 146097\n', '    // L = L - (146097 * N + 3) / 4\n', '    // year = 4000 * (L + 1) / 1461001\n', '    // L = L - 1461 * year / 4 + 31\n', '    // month = 80 * L / 2447\n', '    // dd = L - 2447 * month / 80\n', '    // L = month / 11\n', '    // month = month + 2 - 12 * L\n', '    // year = 100 * (N - 49) + year + L\n', '    // ------------------------------------------------------------------------\n', '    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n', '        int __days = int(_days);\n', '\n', '        int L = __days + 68569 + OFFSET19700101;\n', '        int N = 4 * L / 146097;\n', '        L = L - (146097 * N + 3) / 4;\n', '        int _year = 4000 * (L + 1) / 1461001;\n', '        L = L - 1461 * _year / 4 + 31;\n', '        int _month = 80 * L / 2447;\n', '        int _day = L - 2447 * _month / 80;\n', '        L = _month / 11;\n', '        _month = _month + 2 - 12 * L;\n', '        _year = 100 * (N - 49) + _year + L;\n', '\n', '        year = uint(_year);\n', '        month = uint(_month);\n', '        day = uint(_day);\n', '    }\n', '\n', '    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n', '    }\n', '\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n', '    }\n', '\n', '    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '        secs = secs % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '        second = secs % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        leapYear = _isLeapYear(year);\n', '    }\n', '\n', '    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n', '        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n', '    }\n', '\n', '    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n', '        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n', '    }\n', '\n', '    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n', '        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n', '    }\n', '\n', '    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        daysInMonth = _getDaysInMonth(year, month);\n', '    }\n', '\n', '    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            daysInMonth = 31;\n', '        } else if (month != 2) {\n', '            daysInMonth = 30;\n', '        } else {\n', '            daysInMonth = _isLeapYear(year) ? 29 : 28;\n', '        }\n', '    }\n', '    // 1 = Monday, 7 = Sunday\n', '    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n', '        uint _days = timestamp / SECONDS_PER_DAY;\n', '        dayOfWeek = (_days + 3) % 7 + 1;\n', '    }\n', '\n', '    function getYear(uint timestamp) internal pure returns (uint year) {\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getMonth(uint timestamp) internal pure returns (uint month) {\n', '        uint year;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getDay(uint timestamp) internal pure returns (uint day) {\n', '        uint year;\n', '        uint month;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getHour(uint timestamp) internal pure returns (uint hour) {\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '    }\n', '\n', '    function getMinute(uint timestamp) internal pure returns (uint minute) {\n', '        uint secs = timestamp % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function getSecond(uint timestamp) internal pure returns (uint second) {\n', '        second = timestamp % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year += _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        month += _months;\n', '        year += (month - 1) / 12;\n', '        month = (month - 1) % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _seconds;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year -= _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint yearMonth = year * 12 + (month - 1) - _months;\n', '        year = yearMonth / 12;\n', '        month = yearMonth % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _seconds;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        uint fromYear;\n', '        uint fromMonth;\n', '        uint fromDay;\n', '        uint toYear;\n', '        uint toMonth;\n', '        uint toDay;\n', '        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _years = toYear - fromYear;\n', '    }\n', '\n', '    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        uint fromYear;\n', '        uint fromMonth;\n', '        uint fromDay;\n', '        uint toYear;\n', '        uint toMonth;\n', '        uint toDay;\n', '        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n', '    }\n', '\n', '    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n', '    }\n', '\n', '    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n', '    }\n', '\n', '    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _seconds = toTimestamp - fromTimestamp;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Recon DateTime Library v1.00 - Contract Instance\n', '//\n', '// A energy-efficient Solidity date and time library\n', '//\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit      | Range         | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year      | 1970 ... 2345 |\n', '// month     | 1 ... 12      |\n', '// day       | 1 ... 31      |\n', '// hour      | 0 ... 23      |\n', '// minute    | 0 ... 59      |\n', '// second    | 0 ... 59      |\n', '// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// GNU Lesser General Public License 3.0\n', '// https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ReconDateTimeContract {\n', '    uint public constant SECONDS_PER_DAY = 24 * 60 * 60;\n', '    uint public constant SECONDS_PER_HOUR = 60 * 60;\n', '    uint public constant SECONDS_PER_MINUTE = 60;\n', '    int public constant OFFSET19700101 = 2440588;\n', '\n', '    uint public constant DOW_MON = 1;\n', '    uint public constant DOW_TUE = 2;\n', '    uint public constant DOW_WED = 3;\n', '    uint public constant DOW_THU = 4;\n', '    uint public constant DOW_FRI = 5;\n', '    uint public constant DOW_SAT = 6;\n', '    uint public constant DOW_SUN = 7;\n', '\n', '    function _now() public view returns (uint timestamp) {\n', '        timestamp = now;\n', '    }\n', '\n', '    function _nowDateTime() public view returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(now);\n', '    }\n', '\n', '    function _daysFromDate(uint year, uint month, uint day) public pure returns (uint _days) {\n', '        return ReconDateTimeLibrary._daysFromDate(year, month, day);\n', '    }\n', '\n', '    function _daysToDate(uint _days) public pure returns (uint year, uint month, uint day) {\n', '        return ReconDateTimeLibrary._daysToDate(_days);\n', '    }\n', '\n', '    function timestampFromDate(uint year, uint month, uint day) public pure returns (uint timestamp) {\n', '        return ReconDateTimeLibrary.timestampFromDate(year, month, day);\n', '    }\n', '\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) public pure returns (uint timestamp) {\n', '        return ReconDateTimeLibrary.timestampFromDateTime(year, month, day, hour, minute, second);\n', '    }\n', '\n', '    function timestampToDate(uint timestamp) public pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = ReconDateTimeLibrary.timestampToDate(timestamp);\n', '    }\n', '\n', '    function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(timestamp);\n', '    }\n', '\n', '    function isLeapYear(uint timestamp) public pure returns (bool leapYear) {\n', '        leapYear = ReconDateTimeLibrary.isLeapYear(timestamp);\n', '    }\n', '\n', '    function _isLeapYear(uint year) public pure returns (bool leapYear) {\n', '        leapYear = ReconDateTimeLibrary._isLeapYear(year);\n', '    }\n', '\n', '    function isWeekDay(uint timestamp) public pure returns (bool weekDay) {\n', '        weekDay = ReconDateTimeLibrary.isWeekDay(timestamp);\n', '    }\n', '\n', '    function isWeekEnd(uint timestamp) public pure returns (bool weekEnd) {\n', '        weekEnd = ReconDateTimeLibrary.isWeekEnd(timestamp);\n', '    }\n', '\n', '    function getDaysInMonth(uint timestamp) public pure returns (uint daysInMonth) {\n', '        daysInMonth = ReconDateTimeLibrary.getDaysInMonth(timestamp);\n', '    }\n', '\n', '    function _getDaysInMonth(uint year, uint month) public pure returns (uint daysInMonth) {\n', '        daysInMonth = ReconDateTimeLibrary._getDaysInMonth(year, month);\n', '    }\n', '\n', '    function getDayOfWeek(uint timestamp) public pure returns (uint dayOfWeek) {\n', '        dayOfWeek = ReconDateTimeLibrary.getDayOfWeek(timestamp);\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint year) {\n', '        year = ReconDateTimeLibrary.getYear(timestamp);\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint month) {\n', '        month = ReconDateTimeLibrary.getMonth(timestamp);\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint day) {\n', '        day = ReconDateTimeLibrary.getDay(timestamp);\n', '    }\n', '\n', '    function getHour(uint timestamp) public pure returns (uint hour) {\n', '        hour = ReconDateTimeLibrary.getHour(timestamp);\n', '    }\n', '\n', '    function getMinute(uint timestamp) public pure returns (uint minute) {\n', '        minute = ReconDateTimeLibrary.getMinute(timestamp);\n', '    }\n', '\n', '    function getSecond(uint timestamp) public pure returns (uint second) {\n', '        second = ReconDateTimeLibrary.getSecond(timestamp);\n', '    }\n', '\n', '    function addYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addYears(timestamp, _years);\n', '    }\n', '\n', '    function addMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addMonths(timestamp, _months);\n', '    }\n', '\n', '    function addDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addDays(timestamp, _days);\n', '    }\n', '\n', '    function addHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addHours(timestamp, _hours);\n', '    }\n', '\n', '    function addMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addMinutes(timestamp, _minutes);\n', '    }\n', '\n', '    function addSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addSeconds(timestamp, _seconds);\n', '    }\n', '\n', '    function subYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subYears(timestamp, _years);\n', '    }\n', '\n', '    function subMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subMonths(timestamp, _months);\n', '    }\n', '\n', '    function subDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subDays(timestamp, _days);\n', '    }\n', '\n', '    function subHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subHours(timestamp, _hours);\n', '    }\n', '\n', '    function subMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subMinutes(timestamp, _minutes);\n', '    }\n', '\n', '    function subSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subSeconds(timestamp, _seconds);\n', '    }\n', '\n', '    function diffYears(uint fromTimestamp, uint toTimestamp) public pure returns (uint _years) {\n', '        _years = ReconDateTimeLibrary.diffYears(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffMonths(uint fromTimestamp, uint toTimestamp) public pure returns (uint _months) {\n', '        _months = ReconDateTimeLibrary.diffMonths(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffDays(uint fromTimestamp, uint toTimestamp) public pure returns (uint _days) {\n', '        _days = ReconDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffHours(uint fromTimestamp, uint toTimestamp) public pure returns (uint _hours) {\n', '        _hours = ReconDateTimeLibrary.diffHours(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffMinutes(uint fromTimestamp, uint toTimestamp) public pure returns (uint _minutes) {\n', '        _minutes = ReconDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffSeconds(uint fromTimestamp, uint toTimestamp) public pure returns (uint _seconds) {\n', '        _seconds = ReconDateTimeLibrary.diffSeconds(fromTimestamp, toTimestamp);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes32 hash) public;\n', '}\n', '\n', '\n', 'contract ReconTokenInterface is ERC20Interface {\n', '    uint public constant reconVersion = 110;\n', '\n', '    bytes public constant signingPrefix = "\\x19Ethereum Signed Message:\\n32";\n', '    bytes4 public constant signedTransferSig = "\\x75\\x32\\xea\\xac";\n', '    bytes4 public constant signedApproveSig = "\\xe9\\xaf\\xa7\\xa1";\n', '    bytes4 public constant signedTransferFromSig = "\\x34\\x4b\\xcc\\x7d";\n', '    bytes4 public constant signedApproveAndCallSig = "\\xf1\\x6f\\x9b\\x53";\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event MinterUpdated(address from, address to);\n', '    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\n', '    event MintingDisabled();\n', '    event TransfersEnabled();\n', '    event AccountUnlocked(address indexed tokenOwner);\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes32 hash) public returns (bool success);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // signed{X} functions\n', '    // ------------------------------------------------------------------------\n', '    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\n', '    function unlockAccount(address tokenOwner) public;\n', '    function disableMinting() public;\n', '    function enableTransfers() public;\n', '\n', '\n', '    enum CheckResult {\n', '        Success,                           // 0 Success\n', '        NotTransferable,                   // 1 Tokens not transferable yet\n', '        AccountLocked,                     // 2 Account locked\n', '        SignerMismatch,                    // 3 Mismatch in signing account\n', '        InvalidNonce,                      // 4 Invalid nonce\n', '        InsufficientApprovedTokens,        // 5 Insufficient approved tokens\n', '        InsufficientApprovedTokensForFees, // 6 Insufficient approved tokens for fees\n', '        InsufficientTokens,                // 7 Insufficient tokens\n', '        InsufficientTokensForFees,         // 8 Insufficient tokens for fees\n', '        OverflowError                      // 9 Overflow error\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'library ReconLib {\n', '    struct Data {\n', '        bool initialised;\n', '\n', '        // Ownership\n', '        address owner;\n', '        address newOwner;\n', '\n', '        // Minting and management\n', '        address minter;\n', '        bool mintable;\n', '        bool transferable;\n', '        mapping(address => bool) accountLocked;\n', '\n', '        // Token\n', '        string symbol;\n', '        string name;\n', '        uint8 decimals;\n', '        uint totalSupply;\n', '        mapping(address => uint) balances;\n', '        mapping(address => mapping(address => uint)) allowed;\n', '        mapping(address => uint) nextNonce;\n', '    }\n', '\n', '\n', '    uint public constant reconVersion = 110;\n', '    bytes public constant signingPrefix = "\\x19Ethereum Signed Message:\\n32";\n', '    bytes4 public constant signedTransferSig = "\\x75\\x32\\xea\\xac";\n', '    bytes4 public constant signedApproveSig = "\\xe9\\xaf\\xa7\\xa1";\n', '    bytes4 public constant signedTransferFromSig = "\\x34\\x4b\\xcc\\x7d";\n', '    bytes4 public constant signedApproveAndCallSig = "\\xf1\\x6f\\x9b\\x53";\n', '\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event MinterUpdated(address from, address to);\n', '    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\n', '    event MintingDisabled();\n', '    event TransfersEnabled();\n', '    event AccountUnlocked(address indexed tokenOwner);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '\n', '    function init(Data storage self, address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\n', '        require(!self.initialised);\n', '        self.initialised = true;\n', '        self.owner = owner;\n', '        self.symbol = symbol;\n', '        self.name = name;\n', '        self.decimals = decimals;\n', '        if (initialSupply > 0) {\n', '            self.balances[owner] = initialSupply;\n', '            self.totalSupply = initialSupply;\n', '            emit Mint(self.owner, initialSupply, false);\n', '            emit Transfer(address(0), self.owner, initialSupply);\n', '        }\n', '        self.mintable = mintable;\n', '        self.transferable = transferable;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '\n', '    function transferOwnership(Data storage self, address newOwner) public {\n', '        require(msg.sender == self.owner);\n', '        self.newOwner = newOwner;\n', '    }\n', '\n', '    function acceptOwnership(Data storage self) public {\n', '        require(msg.sender == self.newOwner);\n', '        emit OwnershipTransferred(self.owner, self.newOwner);\n', '        self.owner = self.newOwner;\n', '        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    function transferOwnershipImmediately(Data storage self, address newOwner) public {\n', '        require(msg.sender == self.owner);\n', '        emit OwnershipTransferred(self.owner, newOwner);\n', '        self.owner = newOwner;\n', '        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Minting and management\n', '    // ------------------------------------------------------------------------\n', '    function setMinter(Data storage self, address minter) public {\n', '        require(msg.sender == self.owner);\n', '        require(self.mintable);\n', '        emit MinterUpdated(self.minter, minter);\n', '        self.minter = minter;\n', '    }\n', '\n', '    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\n', '        require(self.mintable);\n', '        require(msg.sender == self.minter || msg.sender == self.owner);\n', '        if (lockAccount) {\n', '            self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = true;\n', '        }\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeAdd(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\n', '        self.totalSupply = safeAdd(self.totalSupply, tokens);\n', '        emit Mint(tokenOwner, tokens, lockAccount);\n', '        emit Transfer(address(0x0A5f85C3d41892C934ae82BDbF17027A20717088), tokenOwner, tokens);\n', '        return true;\n', '    }\n', '\n', '    function unlockAccount(Data storage self, address tokenOwner) public {\n', '        require(msg.sender == self.owner);\n', '        require(self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = false;\n', '        emit AccountUnlocked(tokenOwner);\n', '    }\n', '\n', '    function disableMinting(Data storage self) public {\n', '        require(self.mintable);\n', '        require(msg.sender == self.minter || msg.sender == self.owner);\n', '        self.mintable = false;\n', '        if (self.minter != address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840)) {\n', '            emit MinterUpdated(self.minter, address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840));\n', '            self.minter = address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840);\n', '        }\n', '        emit MintingDisabled();\n', '    }\n', '\n', '    function enableTransfers(Data storage self) public {\n', '        require(msg.sender == self.owner);\n', '        require(!self.transferable);\n', '        self.transferable = true;\n', '        emit TransfersEnabled();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Other functions\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {\n', '        require(msg.sender == self.owner);\n', '        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);\n', '    }\n', '\n', '    function ecrecoverFromSig(bytes32 hash, bytes32 sig) public pure returns (address recoveredAddress) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        if (sig.length != 65) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            // Here we are loading the last 32 bytes. We exploit the fact that &#39;mload&#39; will pad with zeroes if we overread.\n', '            // There is no &#39;mload8&#39; to do this, but that would be nicer.\n', '            v := byte(32, mload(add(sig, 96)))\n', '        }\n', '        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\n', '        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27) {\n', '          v += 27;\n', '        }\n', '        if (v != 27 && v != 28) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '\n', '    function getCheckResultMessage(Data storage /*self*/, ReconTokenInterface.CheckResult result) public pure returns (string) {\n', '        if (result == ReconTokenInterface.CheckResult.Success) {\n', '            return "Success";\n', '        } else if (result == ReconTokenInterface.CheckResult.NotTransferable) {\n', '            return "Tokens not transferable yet";\n', '        } else if (result == ReconTokenInterface.CheckResult.AccountLocked) {\n', '            return "Account locked";\n', '        } else if (result == ReconTokenInterface.CheckResult.SignerMismatch) {\n', '            return "Mismatch in signing account";\n', '        } else if (result == ReconTokenInterface.CheckResult.InvalidNonce) {\n', '            return "Invalid nonce";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokens) {\n', '            return "Insufficient approved tokens";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees) {\n', '            return "Insufficient approved tokens for fees";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokens) {\n', '            return "Insufficient tokens";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokensForFees) {\n', '            return "Insufficient tokens for fees";\n', '        } else if (result == ReconTokenInterface.CheckResult.OverflowError) {\n', '            return "Overflow error";\n', '        } else {\n', '            return "Unknown error";\n', '        }\n', '    }\n', '\n', '\n', '    function transfer(Data storage self, address to, uint tokens) public returns (bool success) {\n', '        // Owner and minter can move tokens before the tokens are transferable\n', '        require(self.transferable || (self.mintable && (msg.sender == self.owner  || msg.sender == self.minter)));\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.balances[msg.sender] = safeSub(self.balances[msg.sender], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(Data storage self, address spender, uint tokens) public returns (bool success) {\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(Data storage self, address from, address to, uint tokens) public returns (bool success) {\n', '        require(self.transferable);\n', '        require(!self.accountLocked[from]);\n', '        self.balances[from] = safeSub(self.balances[from], tokens);\n', '        self.allowed[from][msg.sender] = safeSub(self.allowed[from][msg.sender], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(Data storage self, address spender, uint tokens, bytes32 data) public returns (bool success) {\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '        return true;\n', '    }\n', '\n', '\n', '    function signedTransferHash(Data storage /*self*/, address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedTransferSig, address(this), tokenOwner, to, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedTransferCheck(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        uint total = safeAdd(tokens, fee);\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '    function signedTransfer(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(tokenOwner, to, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedApproveHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedApproveSig, address(this), tokenOwner, spender, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedApproveCheck(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig))\n', '            return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '    function signedApprove(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(0x0A5f85C3d41892C934ae82BDbF17027A20717088, spender, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedTransferFromHash(Data storage /*self*/, address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedTransferFromSig, address(this), spender, from, to, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedTransferFromCheck(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\n', '        if (spender == address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) || spender != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[from]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[spender] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        uint total = safeAdd(tokens, fee);\n', '        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < tokens) return ReconTokenInterface.CheckResult.InsufficientApprovedTokens;\n', '        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < total) return ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees;\n', '        if (self.balances[from] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\n', '        if (self.balances[from] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '\n', '    function signedTransferFrom(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\n', '        require(spender != address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) && spender == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[from]);\n', '        require(self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] == nonce);\n', '        self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = nonce + 1;\n', '        self.balances[from] = safeSub(self.balances[from], tokens);\n', '        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        self.balances[from] = safeSub(self.balances[from], fee);\n', '        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(from, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedApproveAndCallHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedApproveAndCallSig, address(this), tokenOwner, spender, tokens, data, fee, nonce));\n', '    }\n', '\n', '    function signedApproveAndCallCheck(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '\n', '    function signedApproveAndCall(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][spender] = tokens;\n', '        emit Approval(tokenOwner, spender, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        ApproveAndCallFallBack(spender).receiveApproval(tokenOwner, tokens, address(this), data);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ReconToken is ReconTokenInterface{\n', '    using ReconLib for ReconLib.Data;\n', '\n', '    ReconLib.Data data;\n', '\n', '\n', '    function constructorReconToken(address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\n', '        data.init(owner, symbol, name, decimals, initialSupply, mintable, transferable);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return data.owner;\n', '    }\n', '\n', '    function newOwner() public view returns (address) {\n', '        return data.newOwner;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public {\n', '        data.transferOwnership(_newOwner);\n', '    }\n', '    function acceptOwnership() public {\n', '        data.acceptOwnership();\n', '    }\n', '    function transferOwnershipImmediately(address _newOwner) public {\n', '        data.transferOwnershipImmediately(_newOwner);\n', '    }\n', '\n', '    function symbol() public view returns (string) {\n', '        return data.symbol;\n', '    }\n', '\n', '    function name() public view returns (string) {\n', '        return data.name;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return data.decimals;\n', '    }\n', '\n', '    function minter() public view returns (address) {\n', '        return data.minter;\n', '    }\n', '\n', '    function setMinter(address _minter) public {\n', '        data.setMinter(_minter);\n', '    }\n', '\n', '    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\n', '        return data.mint(tokenOwner, tokens, lockAccount);\n', '    }\n', '\n', '    function accountLocked(address tokenOwner) public view returns (bool) {\n', '        return data.accountLocked[tokenOwner];\n', '    }\n', '    function unlockAccount(address tokenOwner) public {\n', '        data.unlockAccount(tokenOwner);\n', '    }\n', '\n', '    function mintable() public view returns (bool) {\n', '        return data.mintable;\n', '    }\n', '\n', '    function transferable() public view returns (bool) {\n', '        return data.transferable;\n', '    }\n', '\n', '    function disableMinting() public {\n', '        data.disableMinting();\n', '    }\n', '\n', '    function enableTransfers() public {\n', '        data.enableTransfers();\n', '    }\n', '\n', '    function nextNonce(address spender) public view returns (uint) {\n', '        return data.nextNonce[spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Other functions\n', '    // ------------------------------------------------------------------------\n', '\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        return data.transferAnyERC20Token(tokenAddress, tokens);\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return data.totalSupply - data.balances[address(0x0A5f85C3d41892C934ae82BDbF17027A20717088)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return data.balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return data.allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        return data.transfer(to, tokens);\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        return data.approve(spender, tokens);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        return data.transferFrom(from, to, tokens);\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes32 _data) public returns (bool success) {\n', '        return data.approveAndCall(spender, tokens, _data);\n', '    }\n', '\n', '    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedTransferHash(tokenOwner, to, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedTransferCheck(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedTransfer(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedApproveHash(tokenOwner, spender, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedApproveCheck(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedApprove(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedTransferFromHash(spender, from, to, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedTransferFrom(spender, from, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedApproveAndCallHash(tokenOwner, spender, tokens, _data, fee, nonce);\n', '    }\n', '\n', '    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedApproveAndCall(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Owned1() public {\n', '        owner = msg.sender;\n', '    }\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(newOwner != address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    function transferOwnershipImmediately(address _newOwner) public onlyOwner {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ReconTokenFactory is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant name = "RECON";\n', '    string public constant symbol = "RECON";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint constant public ReconToMicro = uint(1000000000000000000);\n', '\n', '    // This constants reflects RECON token distribution\n', '\n', '    uint constant public investorSupply                   =  25000000000 * ReconToMicro;\n', '    uint constant public adviserSupply                    =     25000000 * ReconToMicro;\n', '    uint constant public bountySupply                     =     25000000 * ReconToMicro;\n', '\n', '    uint constant public _totalSupply                     = 100000000000 * ReconToMicro;\n', '    uint constant public preICOSupply                     =   5000000000 * ReconToMicro;\n', '    uint constant public presaleSupply                    =   5000000000 * ReconToMicro;\n', '    uint constant public crowdsaleSupply                  =  10000000000 * ReconToMicro;\n', '    uint constant public preICOprivate                    =     99000000 * ReconToMicro;\n', '\n', '    uint constant public Reconowner                       =    101000000 * ReconToMicro;\n', '    uint constant public ReconnewOwner                    =    100000000 * ReconToMicro;\n', '    uint constant public Reconminter                      =     50000000 * ReconToMicro;\n', '    uint constant public ReconfeeAccount                  =     50000000 * ReconToMicro;\n', '    uint constant public Reconspender                     =     50000000 * ReconToMicro;\n', '    uint constant public ReconrecoveredAddress            =     50000000 * ReconToMicro;\n', '    uint constant public ProprityfromReconBank            =    200000000 * ReconToMicro;\n', '    uint constant public ReconManager                     =    200000000 * ReconToMicro;\n', '\n', '    uint constant public ReconCashinB2B                   =   5000000000 * ReconToMicro;\n', '    uint constant public ReconSwitchC2C                   =   5000000000 * ReconToMicro;\n', '    uint constant public ReconCashoutB2C                  =   5000000000 * ReconToMicro;\n', '    uint constant public ReconInvestment                  =   2000000000 * ReconToMicro;\n', '    uint constant public ReconMomentum                    =   2000000000 * ReconToMicro;\n', '    uint constant public ReconReward                      =   2000000000 * ReconToMicro;\n', '    uint constant public ReconDonate                      =   1000000000 * ReconToMicro;\n', '    uint constant public ReconTokens                      =   4000000000 * ReconToMicro;\n', '    uint constant public ReconCash                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconGold                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconCard                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconHardriveWallet              =   2000000000 * ReconToMicro;\n', '    uint constant public RecoinOption                     =   1000000000 * ReconToMicro;\n', '    uint constant public ReconPromo                       =    100000000 * ReconToMicro;\n', '    uint constant public Reconpatents                     =   1000000000 * ReconToMicro;\n', '    uint constant public ReconSecurityandLegalFees        =   1000000000 * ReconToMicro;\n', '    uint constant public PeerToPeerNetworkingService      =   1000000000 * ReconToMicro;\n', '    uint constant public Reconia                          =   2000000000 * ReconToMicro;\n', '\n', '    uint constant public ReconVaultXtraStock              =   7000000000 * ReconToMicro;\n', '    uint constant public ReconVaultSecurityStock          =   5000000000 * ReconToMicro;\n', '    uint constant public ReconVaultAdvancePaymentStock    =   5000000000 * ReconToMicro;\n', '    uint constant public ReconVaultPrivatStock            =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultCurrencyInsurancestock =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultNextStock              =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultFuturStock             =   4000000000 * ReconToMicro;\n', '\n', '\n', '\n', '    // This variables accumulate amount of sold RECON during\n', '    // presale, crowdsale, or given to investors as bonus.\n', '    uint public presaleSold = 0;\n', '    uint public crowdsaleSold = 0;\n', '    uint public investorGiven = 0;\n', '\n', '    // Amount of ETH received during ICO\n', '    uint public ethSold = 0;\n', '\n', '    uint constant public softcapUSD = 20000000000;\n', '    uint constant public preicoUSD  = 5000000000;\n', '\n', '    // Presale lower bound in dollars.\n', '    uint constant public crowdsaleMinUSD = ReconToMicro * 10 * 100 / 12;\n', '    uint constant public bonusLevel0 = ReconToMicro * 10000 * 100 / 12; // 10000$\n', '    uint constant public bonusLevel100 = ReconToMicro * 100000 * 100 / 12; // 100000$\n', '\n', '    // The tokens made available to the public will be in 13 steps\n', '    // for a maximum of 20% of the total supply (see doc for checkTransfer).\n', '    // All dates are stored as timestamps.\n', '    uint constant public unlockDate1  = 1541890800; // 11-11-2018 00:00:00  [1%]  Recon Manager\n', '    uint constant public unlockDate2  = 1545346800; // 21-12-2018 00:00:00  [2%]  Recon Cash-in (B2B)\n', '    uint constant public unlockDate3  = 1549062000; // 02-02-2019 00:00:00  [2%]  Recon Switch (C2C)\n', '    uint constant public unlockDate4  = 1554328800; // 04-04-2019 00:00:00  [2%]  Recon Cash-out (B2C)\n', '    uint constant public unlockDate5  = 1565215200; // 08-08-2019 00:00:00  [2%]  Recon Investment & Recon Momentum\n', '    uint constant public unlockDate6  = 1570658400; // 10-10-2019 00:00:00  [2%]  Recon Reward\n', '    uint constant public unlockDate7  = 1576105200; // 12-12-2019 00:00:00  [1%]  Recon Donate\n', '    uint constant public unlockDate8  = 1580598000; // 02-02-2020 00:00:00  [1%]  Recon Token\n', '    uint constant public unlockDate9  = 1585951200; // 04-04-2020 00:00:00  [2%]  Recon Cash\n', '    uint constant public unlockDate10 = 1591394400; // 06-06-2020 00:00:00  [1%]  Recon Gold\n', '    uint constant public unlockDate11 = 1596837600; // 08-08-2020 00:00:00  [2%]  Recon Card\n', '    uint constant public unlockDate12 = 1602280800; // 10-10-2020 00:00:00  [1%]  Recon Hardrive Wallet\n', '    uint constant public unlockDate13 = 1606863600; // 02-12-2020 00:00:00  [1%]  Recoin Option\n', '\n', '    // The tokens made available to the teams will be made in 4 steps\n', '    // for a maximum of 80% of the total supply (see doc for checkTransfer).\n', '    uint constant public teamUnlock1 = 1544569200; // 12-12-2018 00:00:00  [25%]\n', '    uint constant public teamUnlock2 = 1576105200; // 12-12-2019 00:00:00  [25%]\n', '    uint constant public teamUnlock3 = 1594072800; // 07-07-2020 00:00:00  [25%]\n', '    uint constant public teamUnlock4 = 1608505200; // 21-12-2020 00:00:00  [25%]\n', '\n', '    uint constant public teamETHUnlock1 = 1544569200; // 12-12-2018 00:00:00\n', '    uint constant public teamETHUnlock2 = 1576105200; // 12-12-2019 00:00:00\n', '    uint constant public teamETHUnlock3 = 1594072800; // 07-07-2020 00:00:00\n', '\n', '    //https://casperproject.atlassian.net/wiki/spaces/PROD/pages/277839878/Smart+contract+ICO\n', '    // Presale 10.06.2018 - 22.07.2018\n', '    // Crowd-sale 23.07.2018 - 2.08.2018 (16.08.2018)\n', '    uint constant public presaleStartTime     = 1541890800; // 11-11-2018 00:00:00\n', '    uint constant public crowdsaleStartTime   = 1545346800; // 21-12-2018 00:00:00\n', '    uint          public crowdsaleEndTime     = 1609455599; // 31-12-2020 23:59:59\n', '    uint constant public crowdsaleHardEndTime = 1609455599; // 31-12-2020 23:59:59\n', '    //address constant ReconrWallet = 0x0A5f85C3d41892C934ae82BDbF17027A20717088;\n', '    constructor() public {\n', '        admin = owner;\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndDirector {\n', '        require(msg.sender == owner || msg.sender == director);\n', '        _;\n', '    }\n', '\n', '    address admin;\n', '    function setAdmin(address _newAdmin) public onlyOwnerAndDirector {\n', '        admin = _newAdmin;\n', '    }\n', '\n', '    address director;\n', '    function setDirector(address _newDirector) public onlyOwner {\n', '        director = _newDirector;\n', '    }\n', '\n', '    bool assignedPreico = false;\n', '    // @notice assignPreicoTokens transfers 3x tokens to pre-ICO participants (99,000,000)\n', '    function assignPreicoTokens() public onlyOwnerAndDirector {\n', '        require(!assignedPreico);\n', '        assignedPreico = true;\n', '\n', '        _freezeTransfer(0x4Bdff2Cc40996C71a1F16b72490d1a8E7Dfb7E56, 3 * 1000000000000000000000000); // Account_34\n', '        _freezeTransfer(0x9189AC4FA7AdBC587fF76DD43248520F8Cb897f3, 3 * 1000000000000000000000000); // Account_35\n', '        _freezeTransfer(0xc1D3DAd07A0dB42a7d34453C7d09eFeA793784e7, 3 * 1000000000000000000000000); // Account_36\n', '        _freezeTransfer(0xA0BC1BAAa5318E39BfB66F8Cd0496d6b09CaE6C1, 3 * 1000000000000000000000000); // Account_37\n', '        _freezeTransfer(0x9a2912F145Ab0d5b4aE6917A8b8ddd222539F424, 3 * 1000000000000000000000000); // Account_38\n', '        _freezeTransfer(0x0bB0ded1d868F1c0a50bD31c1ab5ab7b53c6BC20, 3 * 1000000000000000000000000); // Account_39\n', '        _freezeTransfer(0x65ec9f30249065A1BD23a9c68c0Ee9Ead63b4A4d, 3 * 1000000000000000000000000); // Account_40\n', '        _freezeTransfer(0x87Bdc03582deEeB84E00d3fcFd083B64DA77F471, 3 * 1000000000000000000000000); // Account_41\n', '        _freezeTransfer(0x81382A0998191E2Dd8a7bB2B8875D4Ff6CAA31ff, 3 * 1000000000000000000000000); // Account_42\n', '        _freezeTransfer(0x790069C894ebf518fB213F35b48C8ec5AAF81E62, 3 * 1000000000000000000000000); // Account_43\n', '        _freezeTransfer(0xa3f1404851E8156DFb425eC0EB3D3d5ADF6c8Fc0, 3 * 1000000000000000000000000); // Account_44\n', '        _freezeTransfer(0x11bA01dc4d93234D24681e1B19839D4560D17165, 3 * 1000000000000000000000000); // Account_45\n', '        _freezeTransfer(0x211D495291534009B8D3fa491400aB66F1d6131b, 3 * 1000000000000000000000000); // Account_46\n', '        _freezeTransfer(0x8c481AaF9a735F9a44Ac2ACFCFc3dE2e9B2f88f8, 3 * 1000000000000000000000000); // Account_47\n', '        _freezeTransfer(0xd0BEF2Fb95193f429f0075e442938F5d829a33c8, 3 * 1000000000000000000000000); // Account_48\n', '        _freezeTransfer(0x424cbEb619974ee79CaeBf6E9081347e64766705, 3 * 1000000000000000000000000); // Account_49\n', '        _freezeTransfer(0x9e395cd98089F6589b90643Dde4a304cAe4dA61C, 3 * 1000000000000000000000000); // Account_50\n', '        _freezeTransfer(0x3cDE6Df0906157107491ED17C79fF9218A50D7Dc, 3 * 1000000000000000000000000); // Account_51\n', '        _freezeTransfer(0x419a98D46a368A1704278349803683abB2A9D78E, 3 * 1000000000000000000000000); // Account_52\n', '        _freezeTransfer(0x106Db742344FBB96B46989417C151B781D1a4069, 3 * 1000000000000000000000000); // Account_53\n', '        _freezeTransfer(0xE16b9E9De165DbecA18B657414136cF007458aF5, 3 * 1000000000000000000000000); // Account_54\n', '        _freezeTransfer(0xee32C325A3E11759b290df213E83a257ff249936, 3 * 1000000000000000000000000); // Account_55\n', '        _freezeTransfer(0x7d6F916b0E5BF7Ba7f11E60ed9c30fB71C4A5fE0, 3 * 1000000000000000000000000); // Account_56\n', '        _freezeTransfer(0xCC684085585419100AE5010770557d5ad3F3CE58, 3 * 1000000000000000000000000); // Account_57\n', '        _freezeTransfer(0xB47BE6d74C5bC66b53230D07fA62Fb888594418d, 3 * 1000000000000000000000000); // Account_58\n', '        _freezeTransfer(0xf891555a1BF2525f6EBaC9b922b6118ca4215fdD, 3 * 1000000000000000000000000); // Account_59\n', '        _freezeTransfer(0xE3124478A5ed8550eA85733a4543Dd128461b668, 3 * 1000000000000000000000000); // Account_60\n', '        _freezeTransfer(0xc5836df630225112493fa04fa32B586f072d6298, 3 * 1000000000000000000000000); // Account_61\n', '        _freezeTransfer(0x144a0543C93ce8Fb26c13EB619D7E934FA3eA734, 3 * 1000000000000000000000000); // Account_62\n', '        _freezeTransfer(0x43731e24108E928984DcC63DE7affdF3a805FFb0, 3 * 1000000000000000000000000); // Account_63\n', '        _freezeTransfer(0x49f7744Aa8B706Faf336a3ff4De37078714065BC, 3 * 1000000000000000000000000); // Account_64\n', '        _freezeTransfer(0x1E55C7E97F0b5c162FC9C42Ced92C8e55053e093, 3 * 1000000000000000000000000); // Account_65\n', '        _freezeTransfer(0x40b234009664590997D2F6Fde2f279fE56e8AaBC, 3 * 1000000000000000000000000); // Account_66\n', '    }\n', '\n', '    bool assignedTeam = false;\n', '    // @notice assignTeamTokens assigns tokens to team members (79,901,000,000)\n', '    // @notice tokens for team have their own supply\n', '    function assignTeamTokens() public onlyOwnerAndDirector {\n', '        require(!assignedTeam);\n', '        assignedTeam = true;\n', '\n', '        _teamTransfer(0x0A5f85C3d41892C934ae82BDbF17027A20717088,  101000000 * ReconToMicro); // Recon owner\n', '        _teamTransfer(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060,  100000000 * ReconToMicro); // Recon newOwner\n', '        _teamTransfer(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840,   50000000 * ReconToMicro); // Recon minter\n', '        _teamTransfer(0xc083E68D962c2E062D2735B54804Bb5E1f367c1b,   50000000 * ReconToMicro); // Recon feeAccount\n', '        _teamTransfer(0xF848332f5D902EFD874099458Bc8A53C8b7881B1,   50000000 * ReconToMicro); // Recon spender\n', '        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,   50000000 * ReconToMicro); // Recon recoveredAddress\n', '        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,  200000000 * ReconToMicro); // Proprity from ReconBank\n', '        _teamTransfer(0xD974C2D74f0F352467ae2Da87fCc64491117e7ac,  200000000 * ReconToMicro); // Recon Manager\n', '        _teamTransfer(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF, 5000000000 * ReconToMicro); // Recon Cash-in (B2B)\n', '        _teamTransfer(0xeB479640A6D55374aF36896eCe6db7d92F390015, 5000000000 * ReconToMicro); // Recon Switch (C2C)\n', '        _teamTransfer(0x77167D25Db87dc072399df433e450B00b8Ec105A, 7000000000 * ReconToMicro); // Recon Cash-out (B2C)\n', '        _teamTransfer(0x5C6Fd84b961Cce03e027B0f8aE23c4A6e1195E90, 2000000000 * ReconToMicro); // Recon Investment\n', '        _teamTransfer(0x86F427c5e05C29Fd4124746f6111c1a712C9B5c8, 2000000000 * ReconToMicro); // Recon Momentum\n', '        _teamTransfer(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B, 2000000000 * ReconToMicro); // Recon Reward\n', '        _teamTransfer(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0, 1000000000 * ReconToMicro); // Recon Donate\n', '        _teamTransfer(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2, 4000000000 * ReconToMicro); // Recon Token\n', '        _teamTransfer(0x5a27B07003ce50A80dbBc5512eA5BBd654790673, 4000000000 * ReconToMicro); // Recon Cash\n', '        _teamTransfer(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692, 4000000000 * ReconToMicro); // Recon Gold\n', '        _teamTransfer(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9, 4000000000 * ReconToMicro); // Recon Card\n', '        _teamTransfer(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5, 2000000000 * ReconToMicro); // Recon Hardrive Wallet\n', '        _teamTransfer(0x14bd2Aa04619658F517521adba7E5A17dfD2A3f0, 1000000000 * ReconToMicro); // Recoin Option\n', '        _teamTransfer(0x9C3091a335383566d08cba374157Bdff5b8B034B,  100000000 * ReconToMicro); // Recon Promo\n', '        _teamTransfer(0x3b6F53122903c40ef61441dB807f09D90D6F05c7, 1000000000 * ReconToMicro); // Recon patents\n', '        _teamTransfer(0x7fb5EF151446Adb0B7D39B1902E45f06E11038F6, 1000000000 * ReconToMicro); // Recon Security & Legal Fees\n', '        _teamTransfer(0x47BD87fa63Ce818584F050aFFECca0f1dfFd0564, 1000000000 * ReconToMicro); // \u200bPeer To Peer Networking Service\n', '        _teamTransfer(0x83b3CD589Bd78aE65d7b338fF7DFc835cD9a8edD, 2000000000 * ReconToMicro); // Reconia\n', '        _teamTransfer(0x6299496342fFd22B7191616fcD19CeC6537C2E8D, 8000000000 * ReconToMicro); // \u200bRecon Central Securities Depository (Recon Vault&#160;XtraStock)\n', '        _teamTransfer(0x26aF11607Fad4FacF1fc44271aFA63Dbf2C22a87, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault&#160;SecurityStock)\n', '        _teamTransfer(0x7E21203C5B4A6f98E4986f850dc37eBE9Ca19179, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Advance Payment Stock)\n', '        _teamTransfer(0x0bD212e88522b7F4C673fccBCc38558829337f71, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault PrivatStock)\n', '        _teamTransfer(0x5b44e309408cE6E73B9f5869C9eeaCeeb8084DC8, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Currency Insurance stock)\n', '        _teamTransfer(0x48F2eFDE1c028792EbE7a870c55A860e40eb3573, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault&#160;NextStock)\n', '        _teamTransfer(0x1fF3BE6f711C684F04Cf6adfD665Ce13D54CAC73, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault&#160;FuturStock)\n', '    }\n', '\n', '    // @nptice kycPassed is executed by backend and tells SC\n', '    // that particular client has passed KYC\n', '    mapping(address => bool) public kyc;\n', '    mapping(address => address) public referral;\n', '    function kycPassed(address _mem, address _ref) public onlyAdmin {\n', '        kyc[_mem] = true;\n', '        if (_ref == richardAddr || _ref == wuguAddr) {\n', '            referral[_mem] = _ref;\n', '        }\n', '    }\n', '\n', '    // mappings for implementing ERC20\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // mapping for implementing unlock mechanic\n', '    mapping(address => uint) freezed;\n', '    mapping(address => uint) teamFreezed;\n', '\n', '    // ERC20 standard functions\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _tokens) private {\n', '        balances[_from] = balances[_from].sub(_tokens);\n', '        balances[_to] = balances[_to].add(_tokens);\n', '        emit Transfer(_from, _to, _tokens);\n', '    }\n', '\n', '    function transfer(address _to, uint _tokens) public returns (bool success) {\n', '        checkTransfer(msg.sender, _tokens);\n', '        _transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        checkTransfer(from, tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        _transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // @notice checkTransfer ensures that `from` can send only unlocked tokens\n', '    // @notice this function is called for every transfer\n', '    // We unlock PURCHASED and BONUS tokens in 13 stages:\n', '    function checkTransfer(address from, uint tokens) public view {\n', '        uint newBalance = balances[from].sub(tokens);\n', '        uint total = 0;\n', '        if (now < unlockDate5) {\n', '            require(now >= unlockDate1);\n', '            uint frzdPercent = 0;\n', '            if (now < unlockDate2) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate3) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate4) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate5) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate6) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate7) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate8) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate9) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate10) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate11) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate12) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate13) {\n', '                frzdPercent = 5;\n', '            } else {\n', '                frzdPercent = 5;\n', '            }\n', '            total = freezed[from].mul(frzdPercent).div(100);\n', '            require(newBalance >= total);\n', '        }\n', '\n', '        if (now < teamUnlock4 && teamFreezed[from] > 0) {\n', '            uint p = 0;\n', '            if (now < teamUnlock1) {\n', '                p = 100;\n', '            } else if (now < teamUnlock2) {\n', '                p = 75;\n', '            } else if (now < teamUnlock3) {\n', '                p = 50;\n', '            } else if (now < teamUnlock4) {\n', '                p = 25;\n', '            }\n', '            total = total.add(teamFreezed[from].mul(p).div(100));\n', '            require(newBalance >= total);\n', '        }\n', '    }\n', '\n', '    // @return ($ received, ETH received, RECON sold)\n', '    function ICOStatus() public view returns (uint usd, uint eth, uint recon) {\n', '        usd = presaleSold.mul(12).div(10**20) + crowdsaleSold.mul(16).div(10**20);\n', '        usd = usd.add(preicoUSD); // pre-ico tokens\n', '\n', '        return (usd, ethSold + preicoUSD.mul(10**8).div(ethRate), presaleSold + crowdsaleSold);\n', '    }\n', '\n', '    function checkICOStatus() public view returns(bool) {\n', '        uint eth;\n', '        uint recon;\n', '\n', '        (, eth, recon) = ICOStatus();\n', '\n', '        uint dollarsRecvd = eth.mul(ethRate).div(10**8);\n', '\n', '        // 26 228 800$\n', '        return dollarsRecvd >= 25228966 || (recon == presaleSupply + crowdsaleSupply) || now > crowdsaleEndTime;\n', '    }\n', '\n', '    bool icoClosed = false;\n', '    function closeICO() public onlyOwner {\n', '        require(!icoClosed);\n', '        icoClosed = checkICOStatus();\n', '    }\n', '\n', '    // @notice by agreement, we can transfer $4.8M from bank\n', '    // after softcap is reached.\n', '    // @param _to wallet to send RECON to\n', '    // @param  _usd amount of dollars which is withdrawn\n', '    uint bonusTransferred = 0;\n', '    uint constant maxUSD = 4800000;\n', '    function transferBonus(address _to, uint _usd) public onlyOwner {\n', '        bonusTransferred = bonusTransferred.add(_usd);\n', '        require(bonusTransferred <= maxUSD);\n', '\n', '        uint recon = _usd.mul(100).mul(ReconToMicro).div(12); // presale tariff\n', '        presaleSold = presaleSold.add(recon);\n', '        require(presaleSold <= presaleSupply);\n', '        ethSold = ethSold.add(_usd.mul(10**8).div(ethRate));\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice extend crowdsale for 2 weeks\n', '    function prolongCrowdsale() public onlyOwnerAndDirector {\n', '        require(now < crowdsaleEndTime);\n', '        crowdsaleEndTime = crowdsaleHardEndTime;\n', '    }\n', '\n', '    // 100 000 000 Ether in dollars\n', '    uint public ethRate = 0;\n', '    uint public ethRateMax = 0;\n', '    uint public ethLastUpdate = 0;\n', '    function setETHRate(uint _rate) public onlyAdmin {\n', '        require(ethRateMax == 0 || _rate < ethRateMax);\n', '        ethRate = _rate;\n', '        ethLastUpdate = now;\n', '    }\n', '\n', '    // 100 000 000 BTC in dollars\n', '    uint public btcRate = 0;\n', '    uint public btcRateMax = 0;\n', '    uint public btcLastUpdate;\n', '    function setBTCRate(uint _rate) public onlyAdmin {\n', '        require(btcRateMax == 0 || _rate < btcRateMax);\n', '        btcRate = _rate;\n', '        btcLastUpdate = now;\n', '    }\n', '\n', '    // @notice setMaxRate sets max rate for both BTC/ETH to soften\n', '    // negative consequences in case our backend gots hacked.\n', '    function setMaxRate(uint ethMax, uint btcMax) public onlyOwnerAndDirector {\n', '        ethRateMax = ethMax;\n', '        btcRateMax = btcMax;\n', '    }\n', '\n', '    // @notice _sellPresale checks RECON purchases during crowdsale\n', '    function _sellPresale(uint recon) private {\n', '        require(recon >= bonusLevel0.mul(9950).div(10000));\n', '        presaleSold = presaleSold.add(recon);\n', '        require(presaleSold <= presaleSupply);\n', '    }\n', '\n', '    // @notice _sellCrowd checks RECON purchases during crowdsale\n', '    function _sellCrowd(uint recon, address _to) private {\n', '        require(recon >= crowdsaleMinUSD);\n', '\n', '        if (crowdsaleSold.add(recon) <= crowdsaleSupply) {\n', '            crowdsaleSold = crowdsaleSold.add(recon);\n', '        } else {\n', '            presaleSold = presaleSold.add(crowdsaleSold).add(recon).sub(crowdsaleSupply);\n', '            require(presaleSold <= presaleSupply);\n', '            crowdsaleSold = crowdsaleSupply;\n', '        }\n', '\n', '        if (now < crowdsaleStartTime + 3 days) {\n', '            if (whitemap[_to] >= recon) {\n', '                whitemap[_to] -= recon;\n', '                whitelistTokens -= recon;\n', '            } else {\n', '                require(crowdsaleSupply.add(presaleSupply).sub(presaleSold) >= crowdsaleSold.add(whitelistTokens));\n', '            }\n', '        }\n', '    }\n', '\n', '    // @notice addInvestorBonusInPercent is used for sending bonuses for big investors in %\n', '    function addInvestorBonusInPercent(address _to, uint8 p) public onlyOwner {\n', '        require(p > 0 && p <= 5);\n', '        uint bonus = balances[_to].mul(p).div(100);\n', '\n', '        investorGiven = investorGiven.add(bonus);\n', '        require(investorGiven <= investorSupply);\n', '\n', '        _freezeTransfer(_to, bonus);\n', '    }\n', '\n', '    // @notice addInvestorBonusInTokens is used for sending bonuses for big investors in tokens\n', '    function addInvestorBonusInTokens(address _to, uint tokens) public onlyOwner {\n', '        _freezeTransfer(_to, tokens);\n', '\n', '        investorGiven = investorGiven.add(tokens);\n', '        require(investorGiven <= investorSupply);\n', '    }\n', '\n', '    function () payable public {\n', '        purchaseWithETH(msg.sender);\n', '    }\n', '\n', '    // @notice _freezeTranfer perform actual tokens transfer which\n', '    // will be freezed (see also checkTransfer() )\n', '    function _freezeTransfer(address _to, uint recon) private {\n', '        _transfer(owner, _to, recon);\n', '        freezed[_to] = freezed[_to].add(recon);\n', '    }\n', '\n', '    // @notice _freezeTranfer perform actual tokens transfer which\n', '    // will be freezed (see also checkTransfer() )\n', '    function _teamTransfer(address _to, uint recon) private {\n', '        _transfer(owner, _to, recon);\n', '        teamFreezed[_to] = teamFreezed[_to].add(recon);\n', '    }\n', '\n', '    address public constant wuguAddr = 0x0d340F1344a262c13485e419860cb6c4d8Ec9C6e;\n', '    address public constant richardAddr = 0x49BE16e7FECb14B82b4f661D9a0426F810ED7127;\n', '    mapping(address => address[]) promoterClients;\n', '    mapping(address => mapping(address => uint)) promoterBonus;\n', '\n', '    // @notice withdrawPromoter transfers back to promoter\n', '    // all bonuses accumulated to current moment\n', '    function withdrawPromoter() public {\n', '        address _to = msg.sender;\n', '        require(_to == wuguAddr || _to == richardAddr);\n', '\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // USD received - 5% must be more than softcap\n', '        require(usd.mul(95).div(100) >= softcapUSD);\n', '\n', '        uint bonus = 0;\n', '        address[] memory clients = promoterClients[_to];\n', '        for(uint i = 0; i < clients.length; i++) {\n', '            if (kyc[clients[i]]) {\n', '                uint num = promoterBonus[_to][clients[i]];\n', '                delete promoterBonus[_to][clients[i]];\n', '                bonus += num;\n', '            }\n', '        }\n', '\n', '        _to.transfer(bonus);\n', '    }\n', '\n', '    // @notice cashBack will be used in case of failed ICO\n', '    // All partitipants can receive their ETH back\n', '    function cashBack(address _to) public {\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // ICO fails if crowd-sale is ended and we have not yet reached soft-cap\n', '        require(now > crowdsaleEndTime && usd < softcapUSD);\n', '        require(ethSent[_to] > 0);\n', '\n', '        delete ethSent[_to];\n', '\n', '        _to.transfer(ethSent[_to]);\n', '    }\n', '\n', '    // @notice stores amount of ETH received by SC\n', '    mapping(address => uint) ethSent;\n', '\n', '    function purchaseWithETH(address _to) payable public {\n', '        purchaseWithPromoter(_to, referral[msg.sender]);\n', '    }\n', '\n', '    // @notice purchases tokens, which a send to `_to` with 5% returned to `_ref`\n', '    // @notice 5% return must work only on crowdsale\n', '    function purchaseWithPromoter(address _to, address _ref) payable public {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        uint _wei = msg.value;\n', '        uint recon;\n', '\n', '        ethSent[msg.sender] = ethSent[msg.sender].add(_wei);\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            recon = _wei.mul(ethRate).div(75000000); // 1 RECON = 0.75 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || recon >= bonusLevel100);\n', '\n', '            _sellPresale(recon);\n', '\n', '            // we have only 2 recognized promoters\n', '            if (_ref == wuguAddr || _ref == richardAddr) {\n', '                promoterClients[_ref].push(_to);\n', '                promoterBonus[_ref][_to] = _wei.mul(5).div(100);\n', '            }\n', '        } else {\n', '            recon = _wei.mul(ethRate).div(10000000); // 1 RECON = 1.00 $ on crowd-sale\n', '            _sellCrowd(recon, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice purchaseWithBTC is called from backend, where we convert\n', '    // BTC to ETH, and then assign tokens to purchaser, using BTC / $ exchange rate.\n', '    function purchaseWithBTC(address _to, uint _satoshi, uint _wei) public onlyAdmin {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        uint recon;\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            recon = _satoshi.mul(btcRate.mul(10000)).div(75); // 1 RECON = 0.75 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || recon >= bonusLevel100);\n', '\n', '            _sellPresale(recon);\n', '        } else {\n', '            recon = _satoshi.mul(btcRate.mul(10000)).div(100); // 1 RECON = 1.00 $ on presale\n', '            _sellCrowd(recon, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice withdrawFunds is called to send team bonuses after\n', '    // then end of the ICO\n', '    bool withdrawCalled = false;\n', '    function withdrawFunds() public onlyOwner {\n', '        require(icoClosed && now >= teamETHUnlock1);\n', '\n', '        require(!withdrawCalled);\n', '        withdrawCalled = true;\n', '\n', '        uint eth;\n', '        (,eth,) = ICOStatus();\n', '\n', '        // pre-ico tokens are not in ethSold\n', '        uint minus = bonusTransferred.mul(10**8).div(ethRate);\n', '        uint team = ethSold.sub(minus);\n', '\n', '        team = team.mul(15).div(100);\n', '\n', '        uint ownerETH = 0;\n', '        uint teamETH = 0;\n', '        if (address(this).balance >= team) {\n', '            teamETH = team;\n', '            ownerETH = address(this).balance.sub(teamETH);\n', '        } else {\n', '            teamETH = address(this).balance;\n', '        }\n', '\n', '        teamETH1 = teamETH.div(3);\n', '        teamETH2 = teamETH.div(3);\n', '        teamETH3 = teamETH.sub(teamETH1).sub(teamETH2);\n', '\n', '        // TODO multisig\n', '        address(0xf14B65F1589B8bC085578BcF68f09653D8F6abA8).transfer(ownerETH);\n', '    }\n', '\n', '    uint teamETH1 = 0;\n', '    uint teamETH2 = 0;\n', '    uint teamETH3 = 0;\n', '    function withdrawTeam() public {\n', '        require(now >= teamETHUnlock1);\n', '\n', '        uint amount = 0;\n', '        if (now < teamETHUnlock2) {\n', '            amount = teamETH1;\n', '            teamETH1 = 0;\n', '        } else if (now < teamETHUnlock3) {\n', '            amount = teamETH1 + teamETH2;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '        } else {\n', '            amount = teamETH1 + teamETH2 + teamETH3;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '            teamETH3 = 0;\n', '        }\n', '\n', '        address(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF).transfer(amount.mul(6).div(100)); // Recon Cash-in (B2B)\n', '        address(0xeB479640A6D55374aF36896eCe6db7d92F390015).transfer(amount.mul(6).div(100)); // Recon Switch (C2C)\n', '        address(0x77167D25Db87dc072399df433e450B00b8Ec105A).transfer(amount.mul(6).div(100)); // Recon Cash-out (B2C)\n', '        address(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B).transfer(amount.mul(2).div(100)); // Recon Reward\n', '        address(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0).transfer(amount.mul(2).div(100)); // Recon Donate\n', '\n', '        amount = amount.mul(78).div(100);\n', '\n', '        address(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2).transfer(amount.mul(uint(255).mul(100).div(96)).div(1000)); // Recon Token\n', '        address(0x5a27B07003ce50A80dbBc5512eA5BBd654790673).transfer(amount.mul(uint(185).mul(100).div(96)).div(1000)); // Recon Cash\n', '        address(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692).transfer(amount.mul(uint(25).mul(100).div(96)).div(1000));  // Recon Gold\n', '        address(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9).transfer(amount.mul(uint(250).mul(100).div(96)).div(1000)); // Recon Card\n', '        address(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5).transfer(amount.mul(uint(245).mul(100).div(96)).div(1000)); // Recon Hardrive Wallet\n', '    }\n', '\n', '    // @notice doAirdrop is called when we launch airdrop.\n', '    // @notice airdrop tokens has their own supply.\n', '    uint dropped = 0;\n', '    function doAirdrop(address[] members, uint[] tokens) public onlyOwnerAndDirector {\n', '        require(members.length == tokens.length);\n', '\n', '        for(uint i = 0; i < members.length; i++) {\n', '            _freezeTransfer(members[i], tokens[i]);\n', '            dropped = dropped.add(tokens[i]);\n', '        }\n', '        require(dropped <= bountySupply);\n', '    }\n', '\n', '    mapping(address => uint) public whitemap;\n', '    uint public whitelistTokens = 0;\n', '    // @notice addWhitelistMember is used to whitelist participant.\n', '    // This means, that for the first 3 days of crowd-sale `_tokens` RECON\n', '    // will be reserved for him.\n', '    function addWhitelistMember(address[] _mem, uint[] _tokens) public onlyAdmin {\n', '        require(_mem.length == _tokens.length);\n', '        for(uint i = 0; i < _mem.length; i++) {\n', '            whitelistTokens = whitelistTokens.sub(whitemap[_mem[i]]).add(_tokens[i]);\n', '            whitemap[_mem[i]] = _tokens[i];\n', '        }\n', '    }\n', '\n', '    uint public adviserSold = 0;\n', '    // @notice transferAdviser is called to send tokens to advisers.\n', '    // @notice adviser tokens have their own supply\n', '    function transferAdviser(address[] _adv, uint[] _tokens) public onlyOwnerAndDirector {\n', '        require(_adv.length == _tokens.length);\n', '        for (uint i = 0; i < _adv.length; i++) {\n', '            adviserSold = adviserSold.add(_tokens[i]);\n', '            _freezeTransfer(_adv[i], _tokens[i]);\n', '        }\n', '        require(adviserSold <= adviserSupply);\n', '    }\n', '\n', '    mapping(address => bool) approvedInvestors;\n', '    function approveInvestor(address _addr) public onlyOwner {\n', '        approvedInvestors[_addr] = true;\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ERC20InterfaceTest {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contracts that can have tokens approved, and then a function execute\n', '// ----------------------------------------------------------------------------\n', 'contract TestApproveAndCallFallBack {\n', '    event LogBytes(bytes data);\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public {\n', '        ERC20Interface(token).transferFrom(from, address(this), tokens);\n', '        emit LogBytes(data);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract AccessRestriction {\n', '    // These will be assigned at the construction\n', '    // phase, where `msg.sender` is the account\n', '    // creating this contract.\n', '    address public owner = msg.sender;\n', '    uint public creationTime = now;\n', '\n', '    // Modifiers can be used to change\n', '    // the body of a function.\n', '    // If this modifier is used, it will\n', '    // prepend a check that only passes\n', '    // if the function is called from\n', '    // a certain address.\n', '    modifier onlyBy(address _account)\n', '    {\n', '        require(\n', '            msg.sender == _account,\n', '            "Sender not authorized."\n', '        );\n', '        // Do not forget the "_;"! It will\n', '        // be replaced by the actual function\n', '        // body when the modifier is used.\n', '        _;\n', '    }\n', '\n', '    // Make `_newOwner` the new owner of this\n', '    // contract.\n', '    function changeOwner(address _newOwner)\n', '        public\n', '        onlyBy(owner)\n', '    {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    modifier onlyAfter(uint _time) {\n', '        require(\n', '            now >= _time,\n', '            "Function called too early."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // Erase ownership information.\n', '    // May only be called 6 weeks after\n', '    // the contract has been created.\n', '    function disown()\n', '        public\n', '        onlyBy(owner)\n', '        onlyAfter(creationTime + 6 weeks)\n', '    {\n', '        delete owner;\n', '    }\n', '\n', '    // This modifier requires a certain\n', '    // fee being associated with a function call.\n', '    // If the caller sent too much, he or she is\n', '    // refunded, but only after the function body.\n', '    // This was dangerous before Solidity version 0.4.0,\n', '    // where it was possible to skip the part after `_;`.\n', '    modifier costs(uint _amount) {\n', '        require(\n', '            msg.value >= _amount,\n', '            "Not enough Ether provided."\n', '        );\n', '        _;\n', '        if (msg.value > _amount)\n', '            msg.sender.transfer(msg.value - _amount);\n', '    }\n', '\n', '    function forceOwnerChange(address _newOwner)\n', '        public\n', '        payable\n', '        costs(200 ether)\n', '    {\n', '        owner = _newOwner;\n', '        // just some example condition\n', '        if (uint(owner) & 0 == 1)\n', '            // This did not refund for Solidity\n', '            // before version 0.4.0.\n', '            return;\n', '        // refund overpaid fees\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract WithdrawalContract {\n', '    address public richest;\n', '    uint public mostSent;\n', '\n', '    mapping (address => uint) pendingWithdrawals;\n', '\n', '    constructor() public payable {\n', '        richest = msg.sender;\n', '        mostSent = msg.value;\n', '    }\n', '\n', '    function becomeRichest() public payable returns (bool) {\n', '        if (msg.value > mostSent) {\n', '            pendingWithdrawals[richest] += msg.value;\n', '            richest = msg.sender;\n', '            mostSent = msg.value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint amount = pendingWithdrawals[msg.sender];\n', '        // Remember to zero the pending refund before\n', '        // sending to prevent re-entrancy attacks\n', '        pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//.\n', '//"\n', '//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\n', '//.           ;;;;``;;;; ;;;;&#39;&#39;&#39;&#39; ,;;;&#39;````&#39;  .;;;;;;;.`;;;;,  `;;;\n', '//.            [[[,/[[[&#39;  [[cccc  [[[        ,[[     \\[[,[[[[[. &#39;[[\n', '//.            $$$$$$c    $$""""  $$$        $$$,     $$$$$$ "Y$c$$\n', '//.            888b "88bo,888oo,__`88bo,__,o,"888,_ _,88P888    Y88\n', '//.            MMMM   "W" """"YUMMM "YUMMMMMP" "YMMMMMP" MMM     YM\n', '//.\n', '//.\n', '//" -----------------------------------------------------------------------------------------------------------------\n', '//             &#184;.•*&#180;&#168;)\n', '//        &#184;.•&#180;   &#184;.•&#180;&#184;.•*&#180;&#168;) &#184;.•*&#168;)\n', '//  &#184;.•*&#180;       (&#184;.•&#180; (&#184;.•` &#164; ReconBank.eth / ReconBank.com*&#180;&#168;)\n', '//                                                        &#184;.•&#180;&#184;.•*&#180;&#168;)\n', '//                                                      (&#184;.•&#180;   &#184;.•`\n', '//                                                          &#184;.•&#180;•.&#184;\n', '//   (c) Recon&#174; / Common ownership of BlockReconChain&#174; for ReconBank&#174; / Ltd 2018.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// Common ownership of :\n', '//  ____  _            _    _____                       _____ _           _\n', '// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\n', '// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\n', '// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| &#39;_ \\| |    | &#39;_ \\ / _` | | &#39;_ \\\n', '// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\n', '// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|&#174;\n', '//&#39;\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// This contract is an order from :\n', '//&#39;\n', '// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗&#174;\n', '// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\n', '// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\n', '// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\n', '// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n', '// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝&#39;\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', '// Thank you for making the extra effort that others probably wouldnt have made']
['pragma solidity ^ 0.4.25;\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '//                 Recon® Token Teleportation Service v1.10\n', '//\n', '//                           of BlockReconChain®\n', '//                             for ReconBank®\n', '//\n', '//                     ERC Token Standard #20 Interface\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//.\n', '//"\n', '//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\n', "//.           ;;;;``;;;; ;;;;'''' ,;;;'````'  .;;;;;;;.`;;;;,  `;;;\n", "//.            [[[,/[[['  [[cccc  [[[        ,[[     \\[[,[[[[[. '[[\n", '//.            $$$$$$c    $$""""  $$$        $$$,     $$$$$$ "Y$c$$\n', '//.            888b "88bo,888oo,__`88bo,__,o,"888,_ _,88P888    Y88\n', '//.            MMMM   "W" """"YUMMM "YUMMMMMP" "YMMMMMP" MMM     YM\n', '//.\n', '//.\n', '//" -----------------------------------------------------------------------------------------------------------------\n', '//             ¸.•*´¨)\n', '//        ¸.•´   ¸.•´¸.•*´¨) ¸.•*¨)\n', '//  ¸.•*´       (¸.•´ (¸.•` ¤ ReconBank.eth / ReconBank.com*´¨)\n', '//                                                        ¸.•´¸.•*´¨)\n', '//                                                      (¸.•´   ¸.•`\n', '//                                                          ¸.•´•.¸\n', '//   (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// Common ownership of :\n', '//  ____  _            _    _____                       _____ _           _\n', '// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\n', '// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\n', "// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| '_ \\| |    | '_ \\ / _` | | '_ \\\n", '// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\n', '// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|®\n', "//'\n", '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// This contract is an order from :\n', "//'\n", '// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗®\n', '// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\n', '// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\n', '// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\n', '// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n', "// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝'\n", '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '//\n', '//                                 Copyright MIT :\n', '//                      GNU Lesser General Public License 3.0\n', '//                  https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '//\n', '//              Permission is hereby granted, free of charge, to\n', '//              any person obtaining a copy of this software and\n', '//              associated documentation files ReconCoin® Token\n', '//              Teleportation Service, to deal in the Software without\n', '//              restriction, including without limitation the rights to\n', '//              use, copy, modify, merge, publish, distribute,\n', '//              sublicense, and/or sell copies of the Software, and\n', '//              to permit persons to whom the Software is furnished\n', '//              to do so, subject to the following conditions:\n', '//              The above copyright notice and this permission\n', '//              notice shall be included in all copies or substantial\n', '//              portions of the Software.\n', '//\n', '//                 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT\n', '//                 WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', '//                 INCLUDING BUT NOT LIMITED TO THE\n', '//                 WARRANTIES OF MERCHANTABILITY, FITNESS FOR\n', '//                 A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', '//                 IN NO EVENT SHALL THE AUTHORS OR\n', '//                 COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n', '//                 DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n', '//                 ACTION OF CONTRACT, TORT OR\n', '//                 OTHERWISE, ARISING FROM, OUT OF OR IN\n', '//                 CONNECTION WITH THE SOFTWARE OR THE USE\n', '//                 OR OTHER DEALINGS IN THE SOFTWARE.\n', '//\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '// The new assembly support in Solidity makes writing helpers easy.\n', '// Many have complained how complex it is to use `ecrecover`, especially in conjunction\n', '// with the `eth_sign` RPC call. Here is a helper, which makes that a matter of a single call.\n', '//\n', '// Sample input parameters:\n', '// (with v=0)\n', '// "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad",\n', '// "0xaca7da997ad177f040240cdccf6905b71ab16b74434388c3a72f34fd25d6439346b2bac274ff29b48b3ea6e2d04c1336eaceafda3c53ab483fc3ff12fac3ebf200",\n', '// "0x0e5cb767cce09a7f3ca594df118aa519be5e2b5a"\n', '//\n', '// (with v=1)\n', '// "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad",\n', '// "0xdebaaa0cddb321b2dcaaf846d39605de7b97e77ba6106587855b9106cb10421561a22d94fa8b8a687ff9c911c844d1c016d1a685a9166858f9c7c1bc85128aca01",\n', '// "0x8743523d96a1b2cbe0c6909653a56da18ed484af"\n', '//\n', '// (The hash is a hash of "hello world".)\n', '//\n', '// Written by Alex Beregszaszi (@axic), use it under the terms of the MIT license.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'library ReconVerify {\n', '    // Duplicate Soliditys ecrecover, but catching the CALL return value\n', '    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n', '        // We do our own memory management here. Solidity uses memory offset\n', '        // 0x40 to store the current end of memory. We write past it (as\n', '        // writes are memory extensions), but dont update the offset so\n', '        // Solidity will reuse it. The memory used here is only needed for\n', '        // this context.\n', '\n', '        // FIXME: inline assembly cant access return values\n', '        bool ret;\n', '        address addr;\n', '\n', '        assembly {\n', '            let size := mload(0x40)\n', '            mstore(size, hash)\n', '            mstore(add(size, 32), v)\n', '            mstore(add(size, 64), r)\n', '            mstore(add(size, 96), s)\n', '\n', '            // NOTE: we can reuse the request memory because we deal with\n', '            //       the return code\n', '            ret := call(3000, 1, 0, size, 128, size, 32)\n', '            addr := mload(size)\n', '        }\n', '\n', '        return (ret, addr);\n', '    }\n', '\n', '    function ecrecovery(bytes32 hash, bytes sig) public returns (bool, address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (sig.length != 65)\n', '          return (false, 0);\n', '\n', '        // The signature format is a compact form of:\n', '        //   {bytes32 r}{bytes32 s}{uint8 v}\n', '        // Compact means, uint8 is not padded to 32 bytes.\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '\n', '            // Here we are loading the last 32 bytes. We exploit the fact that\n', "            // 'mload' will pad with zeroes if we overread.\n", "            // There is no 'mload8' to do this, but that would be nicer.\n", '            v := byte(0, mload(add(sig, 96)))\n', '\n', '            // Alternative solution:\n', "            // 'byte' is not working due to the Solidity parser, so lets\n", "            // use the second best option, 'and'\n", '            // v := and(mload(add(sig, 65)), 255)\n', '        }\n', '\n', '        // albeit non-transactional signatures are not specified by the YP, one would expect it\n', '        // to match the YP range of [27, 28]\n', '        //\n', '        // geth uses [0, 1] and some clients have followed. This might change, see:\n', '        //  https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27)\n', '          v += 27;\n', '\n', '        if (v != 27 && v != 28)\n', '            return (false, 0);\n', '\n', '        return safer_ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    function verify(bytes32 hash, bytes sig, address signer) public returns (bool) {\n', '        bool ret;\n', '        address addr;\n', '        (ret, addr) = ecrecovery(hash, sig);\n', '        return ret == true && addr == signer;\n', '    }\n', '\n', '    function recover(bytes32 hash, bytes sig) internal returns (address addr) {\n', '        bool ret;\n', '        (ret, addr) = ecrecovery(hash, sig);\n', '    }\n', '}\n', '\n', 'contract ReconVerifyTest {\n', '    function test_v0() public returns (bool) {\n', '        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\n', '        bytes memory sig = "\\xac\\xa7\\xda\\x99\\x7a\\xd1\\x77\\xf0\\x40\\x24\\x0c\\xdc\\xcf\\x69\\x05\\xb7\\x1a\\xb1\\x6b\\x74\\x43\\x43\\x88\\xc3\\xa7\\x2f\\x34\\xfd\\x25\\xd6\\x43\\x93\\x46\\xb2\\xba\\xc2\\x74\\xff\\x29\\xb4\\x8b\\x3e\\xa6\\xe2\\xd0\\x4c\\x13\\x36\\xea\\xce\\xaf\\xda\\x3c\\x53\\xab\\x48\\x3f\\xc3\\xff\\x12\\xfa\\xc3\\xeb\\xf2\\x00";\n', '        return ReconVerify.verify(hash, sig, 0x0A5f85C3d41892C934ae82BDbF17027A20717088);\n', '    }\n', '\n', '    function test_v1() public returns (bool) {\n', '        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\n', '        bytes memory sig = "\\xde\\xba\\xaa\\x0c\\xdd\\xb3\\x21\\xb2\\xdc\\xaa\\xf8\\x46\\xd3\\x96\\x05\\xde\\x7b\\x97\\xe7\\x7b\\xa6\\x10\\x65\\x87\\x85\\x5b\\x91\\x06\\xcb\\x10\\x42\\x15\\x61\\xa2\\x2d\\x94\\xfa\\x8b\\x8a\\x68\\x7f\\xf9\\xc9\\x11\\xc8\\x44\\xd1\\xc0\\x16\\xd1\\xa6\\x85\\xa9\\x16\\x68\\x58\\xf9\\xc7\\xc1\\xbc\\x85\\x12\\x8a\\xca\\x01";\n', '        return ReconVerify.verify(hash, sig, 0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function ReconOwned()  public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner  public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract tokenRecipient {\n', '    event receivedEther(address sender, uint amount);\n', '    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '        Token t = Token(_token);\n', '        require(t.transferFrom(_from, this, _value));\n', '        emit receivedTokens(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    function () payable  public {\n', '        emit receivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', '\n', 'interface Token {\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '}\n', '\n', '\n', 'contract Congress is owned, tokenRecipient {\n', '    // Contract Variables and events\n', '    uint public minimumQuorum;\n', '    uint public debatingPeriodInMinutes;\n', '    int public majorityMargin;\n', '    Proposal[] public proposals;\n', '    uint public numProposals;\n', '    mapping (address => uint) public memberId;\n', '    Member[] public members;\n', '\n', '    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n', '    event Voted(uint proposalID, bool position, address voter, string justification);\n', '    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n', '    event MembershipChanged(address member, bool isMember);\n', '    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);\n', '\n', '    struct Proposal {\n', '        address recipient;\n', '        uint amount;\n', '        string description;\n', '        uint minExecutionDate;\n', '        bool executed;\n', '        bool proposalPassed;\n', '        uint numberOfVotes;\n', '        int currentResult;\n', '        bytes32 proposalHash;\n', '        Vote[] votes;\n', '        mapping (address => bool) voted;\n', '    }\n', '\n', '    struct Member {\n', '        address member;\n', '        string name;\n', '        uint memberSince;\n', '    }\n', '\n', '    struct Vote {\n', '        bool inSupport;\n', '        address voter;\n', '        string justification;\n', '    }\n', '\n', '    // Modifier that allows only shareholders to vote and create new proposals\n', '    modifier onlyMembers {\n', '        require(memberId[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    function ReconCongress (\n', '        uint minimumQuorumForProposals,\n', '        uint minutesForDebate,\n', '        int marginOfVotesForMajority\n', '    )  payable public {\n', '        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);\n', '        // It’s necessary to add an empty first member\n', '        addMember(0, "");\n', '        // and lets add the founder, to save a step later\n', "        addMember(owner, 'founder');\n", '    }\n', '\n', '    /**\n', '     * Add member\n', '     *\n', '     * Make `targetMember` a member named `memberName`\n', '     *\n', '     * @param targetMember ethereum address to be added\n', '     * @param memberName public name for that member\n', '     */\n', '    function addMember(address targetMember, string memberName) onlyOwner public {\n', '        uint id = memberId[targetMember];\n', '        if (id == 0) {\n', '            memberId[targetMember] = members.length;\n', '            id = members.length++;\n', '        }\n', '\n', '        members[id] = Member({member: targetMember, memberSince: now, name: memberName});\n', '        emit MembershipChanged(targetMember, true);\n', '    }\n', '\n', '    /**\n', '     * Remove member\n', '     *\n', '     * @notice Remove membership from `targetMember`\n', '     *\n', '     * @param targetMember ethereum address to be removed\n', '     */\n', '    function removeMember(address targetMember) onlyOwner public {\n', '        require(memberId[targetMember] != 0);\n', '\n', '        for (uint i = memberId[targetMember]; i<members.length-1; i++){\n', '            members[i] = members[i+1];\n', '        }\n', '        delete members[members.length-1];\n', '        members.length--;\n', '    }\n', '\n', '    /**\n', '     * Change voting rules\n', '     *\n', '     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n', '     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n', '     *\n', '     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n', '     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n', '     * @param marginOfVotesForMajority the proposal needs to have 50% plus this number\n', '     */\n', '    function changeVotingRules(\n', '        uint minimumQuorumForProposals,\n', '        uint minutesForDebate,\n', '        int marginOfVotesForMajority\n', '    ) onlyOwner public {\n', '        minimumQuorum = minimumQuorumForProposals;\n', '        debatingPeriodInMinutes = minutesForDebate;\n', '        majorityMargin = marginOfVotesForMajority;\n', '\n', '        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\n', '    }\n', '\n', '    /**\n', '     * Add Proposal\n', '     *\n', '     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send, in wei\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposal(\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyMembers public\n', '        returns (uint proposalID)\n', '    {\n', '        proposalID = proposals.length++;\n', '        Proposal storage p = proposals[proposalID];\n', '        p.recipient = beneficiary;\n', '        p.amount = weiAmount;\n', '        p.description = jobDescription;\n', '        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n', '        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\n', '        p.executed = false;\n', '        p.proposalPassed = false;\n', '        p.numberOfVotes = 0;\n', '        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n', '        numProposals = proposalID+1;\n', '\n', '        return proposalID;\n', '    }\n', '\n', '    /**\n', '     * Add proposal in Ether\n', '     *\n', '     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     * This is a convenience function to use if the amount to be given is in round number of ether units.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param etherAmount amount of ether to send\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposalInEther(\n', '        address beneficiary,\n', '        uint etherAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyMembers public\n', '        returns (uint proposalID)\n', '    {\n', '        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n', '    }\n', '\n', '    /**\n', '     * Check if a proposal code matches\n', '     *\n', '     * @param proposalNumber ID number of the proposal to query\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function checkProposalCode(\n', '        uint proposalNumber,\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        bytes transactionBytecode\n', '    )\n', '        constant public\n', '        returns (bool codeChecksOut)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber];\n', '        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n', '    }\n', '\n', '    /**\n', '     * Log a vote for a proposal\n', '     *\n', '     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n', '     *\n', '     * @param proposalNumber number of proposal\n', '     * @param supportsProposal either in favor or against it\n', '     * @param justificationText optional justification text\n', '     */\n', '    function vote(\n', '        uint proposalNumber,\n', '        bool supportsProposal,\n', '        string justificationText\n', '    )\n', '        onlyMembers public\n', '        returns (uint voteID)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n', '        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n', '        p.voted[msg.sender] = true;                     // Set this voter as having voted\n', '        p.numberOfVotes++;                              // Increase the number of votes\n', '        if (supportsProposal) {                         // If they support the proposal\n', '            p.currentResult++;                          // Increase score\n', '        } else {                                        // If they dont\n', '            p.currentResult--;                          // Decrease the score\n', '        }\n', '\n', '        // Create a log of this event\n', '        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n', '        return p.numberOfVotes;\n', '    }\n', '\n', '    /**\n', '     * Finish vote\n', '     *\n', '     * Count the votes proposal #`proposalNumber` and execute it if approved\n', '     *\n', '     * @param proposalNumber proposal number\n', '     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n', '     */\n', '    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\n', '        Proposal storage p = proposals[proposalNumber];\n', '\n', '        require(now > p.minExecutionDate                                            // If it is past the voting deadline\n', '            && !p.executed                                                         // and it has not already been executed\n', '            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n', '            && p.numberOfVotes >= minimumQuorum);                                  // and a minimum quorum has been reached...\n', '\n', '        // ...then execute result\n', '\n', '        if (p.currentResult > majorityMargin) {\n', '            // Proposal passed; execute the transaction\n', '\n', '            p.executed = true; // Avoid recursive calling\n', '            require(p.recipient.call.value(p.amount)(transactionBytecode));\n', '\n', '            p.proposalPassed = true;\n', '        } else {\n', '            // Proposal failed\n', '            p.proposalPassed = false;\n', '        }\n', '\n', '        // Fire Events\n', '        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Recon DateTime Library v1.00\n', '//\n', '// A energy-efficient Solidity date and time library\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit      | Range         | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year      | 1970 ... 2345 |\n', '// month     | 1 ... 12      |\n', '// day       | 1 ... 31      |\n', '// hour      | 0 ... 23      |\n', '// minute    | 0 ... 59      |\n', '// second    | 0 ... 59      |\n', '// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// GNU Lesser General Public License 3.0\n', '// https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'library ReconDateTimeLibrary {\n', '\n', '    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n', '    uint constant SECONDS_PER_HOUR = 60 * 60;\n', '    uint constant SECONDS_PER_MINUTE = 60;\n', '    int constant OFFSET19700101 = 2440588;\n', '\n', '    uint constant DOW_MON = 1;\n', '    uint constant DOW_TUE = 2;\n', '    uint constant DOW_WED = 3;\n', '    uint constant DOW_THU = 4;\n', '    uint constant DOW_FRI = 5;\n', '    uint constant DOW_SAT = 6;\n', '    uint constant DOW_SUN = 7;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate the number of days from 1970/01/01 to year/month/day using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // days = day\n', '    //      - 32075\n', '    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n', '    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n', '    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n', '    //      - offset\n', '    // ------------------------------------------------------------------------\n', '    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n', '        int _year = int(year);\n', '        int _month = int(month);\n', '        int _day = int(day);\n', '\n', '        int __days = _day\n', '          - 32075\n', '          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n', '          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n', '          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n', '          - OFFSET19700101;\n', '\n', '        _days = uint(__days);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate year/month/day from the number of days since 1970/01/01 using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and adding the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // int L = days + 68569 + offset\n', '    // int N = 4 * L / 146097\n', '    // L = L - (146097 * N + 3) / 4\n', '    // year = 4000 * (L + 1) / 1461001\n', '    // L = L - 1461 * year / 4 + 31\n', '    // month = 80 * L / 2447\n', '    // dd = L - 2447 * month / 80\n', '    // L = month / 11\n', '    // month = month + 2 - 12 * L\n', '    // year = 100 * (N - 49) + year + L\n', '    // ------------------------------------------------------------------------\n', '    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n', '        int __days = int(_days);\n', '\n', '        int L = __days + 68569 + OFFSET19700101;\n', '        int N = 4 * L / 146097;\n', '        L = L - (146097 * N + 3) / 4;\n', '        int _year = 4000 * (L + 1) / 1461001;\n', '        L = L - 1461 * _year / 4 + 31;\n', '        int _month = 80 * L / 2447;\n', '        int _day = L - 2447 * _month / 80;\n', '        L = _month / 11;\n', '        _month = _month + 2 - 12 * L;\n', '        _year = 100 * (N - 49) + _year + L;\n', '\n', '        year = uint(_year);\n', '        month = uint(_month);\n', '        day = uint(_day);\n', '    }\n', '\n', '    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n', '    }\n', '\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n', '    }\n', '\n', '    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '        secs = secs % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '        second = secs % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        leapYear = _isLeapYear(year);\n', '    }\n', '\n', '    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n', '        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n', '    }\n', '\n', '    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n', '        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n', '    }\n', '\n', '    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n', '        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n', '    }\n', '\n', '    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        daysInMonth = _getDaysInMonth(year, month);\n', '    }\n', '\n', '    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            daysInMonth = 31;\n', '        } else if (month != 2) {\n', '            daysInMonth = 30;\n', '        } else {\n', '            daysInMonth = _isLeapYear(year) ? 29 : 28;\n', '        }\n', '    }\n', '    // 1 = Monday, 7 = Sunday\n', '    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n', '        uint _days = timestamp / SECONDS_PER_DAY;\n', '        dayOfWeek = (_days + 3) % 7 + 1;\n', '    }\n', '\n', '    function getYear(uint timestamp) internal pure returns (uint year) {\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getMonth(uint timestamp) internal pure returns (uint month) {\n', '        uint year;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getDay(uint timestamp) internal pure returns (uint day) {\n', '        uint year;\n', '        uint month;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '\n', '    function getHour(uint timestamp) internal pure returns (uint hour) {\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '    }\n', '\n', '    function getMinute(uint timestamp) internal pure returns (uint minute) {\n', '        uint secs = timestamp % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function getSecond(uint timestamp) internal pure returns (uint second) {\n', '        second = timestamp % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year += _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        month += _months;\n', '        year += (month - 1) / 12;\n', '        month = (month - 1) % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _seconds;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year -= _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        uint year;\n', '        uint month;\n', '        uint day;\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint yearMonth = year * 12 + (month - 1) - _months;\n', '        year = yearMonth / 12;\n', '        month = yearMonth % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _seconds;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        uint fromYear;\n', '        uint fromMonth;\n', '        uint fromDay;\n', '        uint toYear;\n', '        uint toMonth;\n', '        uint toDay;\n', '        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _years = toYear - fromYear;\n', '    }\n', '\n', '    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        uint fromYear;\n', '        uint fromMonth;\n', '        uint fromDay;\n', '        uint toYear;\n', '        uint toMonth;\n', '        uint toDay;\n', '        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n', '    }\n', '\n', '    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n', '    }\n', '\n', '    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n', '    }\n', '\n', '    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _seconds = toTimestamp - fromTimestamp;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Recon DateTime Library v1.00 - Contract Instance\n', '//\n', '// A energy-efficient Solidity date and time library\n', '//\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit      | Range         | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year      | 1970 ... 2345 |\n', '// month     | 1 ... 12      |\n', '// day       | 1 ... 31      |\n', '// hour      | 0 ... 23      |\n', '// minute    | 0 ... 59      |\n', '// second    | 0 ... 59      |\n', '// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// GNU Lesser General Public License 3.0\n', '// https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ReconDateTimeContract {\n', '    uint public constant SECONDS_PER_DAY = 24 * 60 * 60;\n', '    uint public constant SECONDS_PER_HOUR = 60 * 60;\n', '    uint public constant SECONDS_PER_MINUTE = 60;\n', '    int public constant OFFSET19700101 = 2440588;\n', '\n', '    uint public constant DOW_MON = 1;\n', '    uint public constant DOW_TUE = 2;\n', '    uint public constant DOW_WED = 3;\n', '    uint public constant DOW_THU = 4;\n', '    uint public constant DOW_FRI = 5;\n', '    uint public constant DOW_SAT = 6;\n', '    uint public constant DOW_SUN = 7;\n', '\n', '    function _now() public view returns (uint timestamp) {\n', '        timestamp = now;\n', '    }\n', '\n', '    function _nowDateTime() public view returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(now);\n', '    }\n', '\n', '    function _daysFromDate(uint year, uint month, uint day) public pure returns (uint _days) {\n', '        return ReconDateTimeLibrary._daysFromDate(year, month, day);\n', '    }\n', '\n', '    function _daysToDate(uint _days) public pure returns (uint year, uint month, uint day) {\n', '        return ReconDateTimeLibrary._daysToDate(_days);\n', '    }\n', '\n', '    function timestampFromDate(uint year, uint month, uint day) public pure returns (uint timestamp) {\n', '        return ReconDateTimeLibrary.timestampFromDate(year, month, day);\n', '    }\n', '\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) public pure returns (uint timestamp) {\n', '        return ReconDateTimeLibrary.timestampFromDateTime(year, month, day, hour, minute, second);\n', '    }\n', '\n', '    function timestampToDate(uint timestamp) public pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = ReconDateTimeLibrary.timestampToDate(timestamp);\n', '    }\n', '\n', '    function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(timestamp);\n', '    }\n', '\n', '    function isLeapYear(uint timestamp) public pure returns (bool leapYear) {\n', '        leapYear = ReconDateTimeLibrary.isLeapYear(timestamp);\n', '    }\n', '\n', '    function _isLeapYear(uint year) public pure returns (bool leapYear) {\n', '        leapYear = ReconDateTimeLibrary._isLeapYear(year);\n', '    }\n', '\n', '    function isWeekDay(uint timestamp) public pure returns (bool weekDay) {\n', '        weekDay = ReconDateTimeLibrary.isWeekDay(timestamp);\n', '    }\n', '\n', '    function isWeekEnd(uint timestamp) public pure returns (bool weekEnd) {\n', '        weekEnd = ReconDateTimeLibrary.isWeekEnd(timestamp);\n', '    }\n', '\n', '    function getDaysInMonth(uint timestamp) public pure returns (uint daysInMonth) {\n', '        daysInMonth = ReconDateTimeLibrary.getDaysInMonth(timestamp);\n', '    }\n', '\n', '    function _getDaysInMonth(uint year, uint month) public pure returns (uint daysInMonth) {\n', '        daysInMonth = ReconDateTimeLibrary._getDaysInMonth(year, month);\n', '    }\n', '\n', '    function getDayOfWeek(uint timestamp) public pure returns (uint dayOfWeek) {\n', '        dayOfWeek = ReconDateTimeLibrary.getDayOfWeek(timestamp);\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint year) {\n', '        year = ReconDateTimeLibrary.getYear(timestamp);\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint month) {\n', '        month = ReconDateTimeLibrary.getMonth(timestamp);\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint day) {\n', '        day = ReconDateTimeLibrary.getDay(timestamp);\n', '    }\n', '\n', '    function getHour(uint timestamp) public pure returns (uint hour) {\n', '        hour = ReconDateTimeLibrary.getHour(timestamp);\n', '    }\n', '\n', '    function getMinute(uint timestamp) public pure returns (uint minute) {\n', '        minute = ReconDateTimeLibrary.getMinute(timestamp);\n', '    }\n', '\n', '    function getSecond(uint timestamp) public pure returns (uint second) {\n', '        second = ReconDateTimeLibrary.getSecond(timestamp);\n', '    }\n', '\n', '    function addYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addYears(timestamp, _years);\n', '    }\n', '\n', '    function addMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addMonths(timestamp, _months);\n', '    }\n', '\n', '    function addDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addDays(timestamp, _days);\n', '    }\n', '\n', '    function addHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addHours(timestamp, _hours);\n', '    }\n', '\n', '    function addMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addMinutes(timestamp, _minutes);\n', '    }\n', '\n', '    function addSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.addSeconds(timestamp, _seconds);\n', '    }\n', '\n', '    function subYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subYears(timestamp, _years);\n', '    }\n', '\n', '    function subMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subMonths(timestamp, _months);\n', '    }\n', '\n', '    function subDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subDays(timestamp, _days);\n', '    }\n', '\n', '    function subHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subHours(timestamp, _hours);\n', '    }\n', '\n', '    function subMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subMinutes(timestamp, _minutes);\n', '    }\n', '\n', '    function subSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\n', '        newTimestamp = ReconDateTimeLibrary.subSeconds(timestamp, _seconds);\n', '    }\n', '\n', '    function diffYears(uint fromTimestamp, uint toTimestamp) public pure returns (uint _years) {\n', '        _years = ReconDateTimeLibrary.diffYears(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffMonths(uint fromTimestamp, uint toTimestamp) public pure returns (uint _months) {\n', '        _months = ReconDateTimeLibrary.diffMonths(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffDays(uint fromTimestamp, uint toTimestamp) public pure returns (uint _days) {\n', '        _days = ReconDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffHours(uint fromTimestamp, uint toTimestamp) public pure returns (uint _hours) {\n', '        _hours = ReconDateTimeLibrary.diffHours(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffMinutes(uint fromTimestamp, uint toTimestamp) public pure returns (uint _minutes) {\n', '        _minutes = ReconDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\n', '    }\n', '\n', '    function diffSeconds(uint fromTimestamp, uint toTimestamp) public pure returns (uint _seconds) {\n', '        _seconds = ReconDateTimeLibrary.diffSeconds(fromTimestamp, toTimestamp);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes32 hash) public;\n', '}\n', '\n', '\n', 'contract ReconTokenInterface is ERC20Interface {\n', '    uint public constant reconVersion = 110;\n', '\n', '    bytes public constant signingPrefix = "\\x19Ethereum Signed Message:\\n32";\n', '    bytes4 public constant signedTransferSig = "\\x75\\x32\\xea\\xac";\n', '    bytes4 public constant signedApproveSig = "\\xe9\\xaf\\xa7\\xa1";\n', '    bytes4 public constant signedTransferFromSig = "\\x34\\x4b\\xcc\\x7d";\n', '    bytes4 public constant signedApproveAndCallSig = "\\xf1\\x6f\\x9b\\x53";\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event MinterUpdated(address from, address to);\n', '    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\n', '    event MintingDisabled();\n', '    event TransfersEnabled();\n', '    event AccountUnlocked(address indexed tokenOwner);\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes32 hash) public returns (bool success);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // signed{X} functions\n', '    // ------------------------------------------------------------------------\n', '    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\n', '\n', '    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\n', '    function unlockAccount(address tokenOwner) public;\n', '    function disableMinting() public;\n', '    function enableTransfers() public;\n', '\n', '\n', '    enum CheckResult {\n', '        Success,                           // 0 Success\n', '        NotTransferable,                   // 1 Tokens not transferable yet\n', '        AccountLocked,                     // 2 Account locked\n', '        SignerMismatch,                    // 3 Mismatch in signing account\n', '        InvalidNonce,                      // 4 Invalid nonce\n', '        InsufficientApprovedTokens,        // 5 Insufficient approved tokens\n', '        InsufficientApprovedTokensForFees, // 6 Insufficient approved tokens for fees\n', '        InsufficientTokens,                // 7 Insufficient tokens\n', '        InsufficientTokensForFees,         // 8 Insufficient tokens for fees\n', '        OverflowError                      // 9 Overflow error\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'library ReconLib {\n', '    struct Data {\n', '        bool initialised;\n', '\n', '        // Ownership\n', '        address owner;\n', '        address newOwner;\n', '\n', '        // Minting and management\n', '        address minter;\n', '        bool mintable;\n', '        bool transferable;\n', '        mapping(address => bool) accountLocked;\n', '\n', '        // Token\n', '        string symbol;\n', '        string name;\n', '        uint8 decimals;\n', '        uint totalSupply;\n', '        mapping(address => uint) balances;\n', '        mapping(address => mapping(address => uint)) allowed;\n', '        mapping(address => uint) nextNonce;\n', '    }\n', '\n', '\n', '    uint public constant reconVersion = 110;\n', '    bytes public constant signingPrefix = "\\x19Ethereum Signed Message:\\n32";\n', '    bytes4 public constant signedTransferSig = "\\x75\\x32\\xea\\xac";\n', '    bytes4 public constant signedApproveSig = "\\xe9\\xaf\\xa7\\xa1";\n', '    bytes4 public constant signedTransferFromSig = "\\x34\\x4b\\xcc\\x7d";\n', '    bytes4 public constant signedApproveAndCallSig = "\\xf1\\x6f\\x9b\\x53";\n', '\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event MinterUpdated(address from, address to);\n', '    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\n', '    event MintingDisabled();\n', '    event TransfersEnabled();\n', '    event AccountUnlocked(address indexed tokenOwner);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '\n', '    function init(Data storage self, address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\n', '        require(!self.initialised);\n', '        self.initialised = true;\n', '        self.owner = owner;\n', '        self.symbol = symbol;\n', '        self.name = name;\n', '        self.decimals = decimals;\n', '        if (initialSupply > 0) {\n', '            self.balances[owner] = initialSupply;\n', '            self.totalSupply = initialSupply;\n', '            emit Mint(self.owner, initialSupply, false);\n', '            emit Transfer(address(0), self.owner, initialSupply);\n', '        }\n', '        self.mintable = mintable;\n', '        self.transferable = transferable;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '\n', '    function transferOwnership(Data storage self, address newOwner) public {\n', '        require(msg.sender == self.owner);\n', '        self.newOwner = newOwner;\n', '    }\n', '\n', '    function acceptOwnership(Data storage self) public {\n', '        require(msg.sender == self.newOwner);\n', '        emit OwnershipTransferred(self.owner, self.newOwner);\n', '        self.owner = self.newOwner;\n', '        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    function transferOwnershipImmediately(Data storage self, address newOwner) public {\n', '        require(msg.sender == self.owner);\n', '        emit OwnershipTransferred(self.owner, newOwner);\n', '        self.owner = newOwner;\n', '        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Minting and management\n', '    // ------------------------------------------------------------------------\n', '    function setMinter(Data storage self, address minter) public {\n', '        require(msg.sender == self.owner);\n', '        require(self.mintable);\n', '        emit MinterUpdated(self.minter, minter);\n', '        self.minter = minter;\n', '    }\n', '\n', '    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\n', '        require(self.mintable);\n', '        require(msg.sender == self.minter || msg.sender == self.owner);\n', '        if (lockAccount) {\n', '            self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = true;\n', '        }\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeAdd(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\n', '        self.totalSupply = safeAdd(self.totalSupply, tokens);\n', '        emit Mint(tokenOwner, tokens, lockAccount);\n', '        emit Transfer(address(0x0A5f85C3d41892C934ae82BDbF17027A20717088), tokenOwner, tokens);\n', '        return true;\n', '    }\n', '\n', '    function unlockAccount(Data storage self, address tokenOwner) public {\n', '        require(msg.sender == self.owner);\n', '        require(self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = false;\n', '        emit AccountUnlocked(tokenOwner);\n', '    }\n', '\n', '    function disableMinting(Data storage self) public {\n', '        require(self.mintable);\n', '        require(msg.sender == self.minter || msg.sender == self.owner);\n', '        self.mintable = false;\n', '        if (self.minter != address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840)) {\n', '            emit MinterUpdated(self.minter, address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840));\n', '            self.minter = address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840);\n', '        }\n', '        emit MintingDisabled();\n', '    }\n', '\n', '    function enableTransfers(Data storage self) public {\n', '        require(msg.sender == self.owner);\n', '        require(!self.transferable);\n', '        self.transferable = true;\n', '        emit TransfersEnabled();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Other functions\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {\n', '        require(msg.sender == self.owner);\n', '        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);\n', '    }\n', '\n', '    function ecrecoverFromSig(bytes32 hash, bytes32 sig) public pure returns (address recoveredAddress) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        if (sig.length != 65) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', "            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\n", "            // There is no 'mload8' to do this, but that would be nicer.\n", '            v := byte(32, mload(add(sig, 96)))\n', '        }\n', '        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\n', '        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27) {\n', '          v += 27;\n', '        }\n', '        if (v != 27 && v != 28) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '\n', '    function getCheckResultMessage(Data storage /*self*/, ReconTokenInterface.CheckResult result) public pure returns (string) {\n', '        if (result == ReconTokenInterface.CheckResult.Success) {\n', '            return "Success";\n', '        } else if (result == ReconTokenInterface.CheckResult.NotTransferable) {\n', '            return "Tokens not transferable yet";\n', '        } else if (result == ReconTokenInterface.CheckResult.AccountLocked) {\n', '            return "Account locked";\n', '        } else if (result == ReconTokenInterface.CheckResult.SignerMismatch) {\n', '            return "Mismatch in signing account";\n', '        } else if (result == ReconTokenInterface.CheckResult.InvalidNonce) {\n', '            return "Invalid nonce";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokens) {\n', '            return "Insufficient approved tokens";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees) {\n', '            return "Insufficient approved tokens for fees";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokens) {\n', '            return "Insufficient tokens";\n', '        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokensForFees) {\n', '            return "Insufficient tokens for fees";\n', '        } else if (result == ReconTokenInterface.CheckResult.OverflowError) {\n', '            return "Overflow error";\n', '        } else {\n', '            return "Unknown error";\n', '        }\n', '    }\n', '\n', '\n', '    function transfer(Data storage self, address to, uint tokens) public returns (bool success) {\n', '        // Owner and minter can move tokens before the tokens are transferable\n', '        require(self.transferable || (self.mintable && (msg.sender == self.owner  || msg.sender == self.minter)));\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.balances[msg.sender] = safeSub(self.balances[msg.sender], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(Data storage self, address spender, uint tokens) public returns (bool success) {\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(Data storage self, address from, address to, uint tokens) public returns (bool success) {\n', '        require(self.transferable);\n', '        require(!self.accountLocked[from]);\n', '        self.balances[from] = safeSub(self.balances[from], tokens);\n', '        self.allowed[from][msg.sender] = safeSub(self.allowed[from][msg.sender], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(Data storage self, address spender, uint tokens, bytes32 data) public returns (bool success) {\n', '        require(!self.accountLocked[msg.sender]);\n', '        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '        return true;\n', '    }\n', '\n', '\n', '    function signedTransferHash(Data storage /*self*/, address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedTransferSig, address(this), tokenOwner, to, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedTransferCheck(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        uint total = safeAdd(tokens, fee);\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '    function signedTransfer(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(tokenOwner, to, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedApproveHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedApproveSig, address(this), tokenOwner, spender, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedApproveCheck(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig))\n', '            return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '    function signedApprove(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\n', '        emit Approval(0x0A5f85C3d41892C934ae82BDbF17027A20717088, spender, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedTransferFromHash(Data storage /*self*/, address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedTransferFromSig, address(this), spender, from, to, tokens, fee, nonce));\n', '    }\n', '\n', '    function signedTransferFromCheck(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\n', '        if (spender == address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) || spender != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[from]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[spender] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        uint total = safeAdd(tokens, fee);\n', '        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < tokens) return ReconTokenInterface.CheckResult.InsufficientApprovedTokens;\n', '        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < total) return ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees;\n', '        if (self.balances[from] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\n', '        if (self.balances[from] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '\n', '    function signedTransferFrom(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\n', '        require(spender != address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) && spender == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[from]);\n', '        require(self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] == nonce);\n', '        self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = nonce + 1;\n', '        self.balances[from] = safeSub(self.balances[from], tokens);\n', '        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], tokens);\n', '        self.balances[to] = safeAdd(self.balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        self.balances[from] = safeSub(self.balances[from], fee);\n', '        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(from, feeAccount, fee);\n', '        return true;\n', '    }\n', '\n', '    function signedApproveAndCallHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(signedApproveAndCallSig, address(this), tokenOwner, spender, tokens, data, fee, nonce));\n', '    }\n', '\n', '    function signedApproveAndCallCheck(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\n', '        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\n', '        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\n', '        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\n', '        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\n', '        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\n', '        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\n', '        return ReconTokenInterface.CheckResult.Success;\n', '    }\n', '\n', '    function signedApproveAndCall(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        require(self.transferable);\n', '        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\n', '        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\n', '        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\n', '        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\n', '        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\n', '        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][spender] = tokens;\n', '        emit Approval(tokenOwner, spender, tokens);\n', '        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\n', '        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\n', '        emit Transfer(tokenOwner, feeAccount, fee);\n', '        ApproveAndCallFallBack(spender).receiveApproval(tokenOwner, tokens, address(this), data);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ReconToken is ReconTokenInterface{\n', '    using ReconLib for ReconLib.Data;\n', '\n', '    ReconLib.Data data;\n', '\n', '\n', '    function constructorReconToken(address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\n', '        data.init(owner, symbol, name, decimals, initialSupply, mintable, transferable);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return data.owner;\n', '    }\n', '\n', '    function newOwner() public view returns (address) {\n', '        return data.newOwner;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public {\n', '        data.transferOwnership(_newOwner);\n', '    }\n', '    function acceptOwnership() public {\n', '        data.acceptOwnership();\n', '    }\n', '    function transferOwnershipImmediately(address _newOwner) public {\n', '        data.transferOwnershipImmediately(_newOwner);\n', '    }\n', '\n', '    function symbol() public view returns (string) {\n', '        return data.symbol;\n', '    }\n', '\n', '    function name() public view returns (string) {\n', '        return data.name;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return data.decimals;\n', '    }\n', '\n', '    function minter() public view returns (address) {\n', '        return data.minter;\n', '    }\n', '\n', '    function setMinter(address _minter) public {\n', '        data.setMinter(_minter);\n', '    }\n', '\n', '    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\n', '        return data.mint(tokenOwner, tokens, lockAccount);\n', '    }\n', '\n', '    function accountLocked(address tokenOwner) public view returns (bool) {\n', '        return data.accountLocked[tokenOwner];\n', '    }\n', '    function unlockAccount(address tokenOwner) public {\n', '        data.unlockAccount(tokenOwner);\n', '    }\n', '\n', '    function mintable() public view returns (bool) {\n', '        return data.mintable;\n', '    }\n', '\n', '    function transferable() public view returns (bool) {\n', '        return data.transferable;\n', '    }\n', '\n', '    function disableMinting() public {\n', '        data.disableMinting();\n', '    }\n', '\n', '    function enableTransfers() public {\n', '        data.enableTransfers();\n', '    }\n', '\n', '    function nextNonce(address spender) public view returns (uint) {\n', '        return data.nextNonce[spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Other functions\n', '    // ------------------------------------------------------------------------\n', '\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        return data.transferAnyERC20Token(tokenAddress, tokens);\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return data.totalSupply - data.balances[address(0x0A5f85C3d41892C934ae82BDbF17027A20717088)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return data.balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return data.allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        return data.transfer(to, tokens);\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        return data.approve(spender, tokens);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        return data.transferFrom(from, to, tokens);\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes32 _data) public returns (bool success) {\n', '        return data.approveAndCall(spender, tokens, _data);\n', '    }\n', '\n', '    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedTransferHash(tokenOwner, to, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedTransferCheck(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedTransfer(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedApproveHash(tokenOwner, spender, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedApproveCheck(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedApprove(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedTransferFromHash(spender, from, to, tokens, fee, nonce);\n', '    }\n', '\n', '    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedTransferFrom(spender, from, to, tokens, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash) {\n', '        return data.signedApproveAndCallHash(tokenOwner, spender, tokens, _data, fee, nonce);\n', '    }\n', '\n', '    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\n', '        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\n', '    }\n', '\n', '    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\n', '        return data.signedApproveAndCall(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Owned1() public {\n', '        owner = msg.sender;\n', '    }\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(newOwner != address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '\n', '    function transferOwnershipImmediately(address _newOwner) public onlyOwner {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ReconTokenFactory is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant name = "RECON";\n', '    string public constant symbol = "RECON";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint constant public ReconToMicro = uint(1000000000000000000);\n', '\n', '    // This constants reflects RECON token distribution\n', '\n', '    uint constant public investorSupply                   =  25000000000 * ReconToMicro;\n', '    uint constant public adviserSupply                    =     25000000 * ReconToMicro;\n', '    uint constant public bountySupply                     =     25000000 * ReconToMicro;\n', '\n', '    uint constant public _totalSupply                     = 100000000000 * ReconToMicro;\n', '    uint constant public preICOSupply                     =   5000000000 * ReconToMicro;\n', '    uint constant public presaleSupply                    =   5000000000 * ReconToMicro;\n', '    uint constant public crowdsaleSupply                  =  10000000000 * ReconToMicro;\n', '    uint constant public preICOprivate                    =     99000000 * ReconToMicro;\n', '\n', '    uint constant public Reconowner                       =    101000000 * ReconToMicro;\n', '    uint constant public ReconnewOwner                    =    100000000 * ReconToMicro;\n', '    uint constant public Reconminter                      =     50000000 * ReconToMicro;\n', '    uint constant public ReconfeeAccount                  =     50000000 * ReconToMicro;\n', '    uint constant public Reconspender                     =     50000000 * ReconToMicro;\n', '    uint constant public ReconrecoveredAddress            =     50000000 * ReconToMicro;\n', '    uint constant public ProprityfromReconBank            =    200000000 * ReconToMicro;\n', '    uint constant public ReconManager                     =    200000000 * ReconToMicro;\n', '\n', '    uint constant public ReconCashinB2B                   =   5000000000 * ReconToMicro;\n', '    uint constant public ReconSwitchC2C                   =   5000000000 * ReconToMicro;\n', '    uint constant public ReconCashoutB2C                  =   5000000000 * ReconToMicro;\n', '    uint constant public ReconInvestment                  =   2000000000 * ReconToMicro;\n', '    uint constant public ReconMomentum                    =   2000000000 * ReconToMicro;\n', '    uint constant public ReconReward                      =   2000000000 * ReconToMicro;\n', '    uint constant public ReconDonate                      =   1000000000 * ReconToMicro;\n', '    uint constant public ReconTokens                      =   4000000000 * ReconToMicro;\n', '    uint constant public ReconCash                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconGold                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconCard                        =   4000000000 * ReconToMicro;\n', '    uint constant public ReconHardriveWallet              =   2000000000 * ReconToMicro;\n', '    uint constant public RecoinOption                     =   1000000000 * ReconToMicro;\n', '    uint constant public ReconPromo                       =    100000000 * ReconToMicro;\n', '    uint constant public Reconpatents                     =   1000000000 * ReconToMicro;\n', '    uint constant public ReconSecurityandLegalFees        =   1000000000 * ReconToMicro;\n', '    uint constant public PeerToPeerNetworkingService      =   1000000000 * ReconToMicro;\n', '    uint constant public Reconia                          =   2000000000 * ReconToMicro;\n', '\n', '    uint constant public ReconVaultXtraStock              =   7000000000 * ReconToMicro;\n', '    uint constant public ReconVaultSecurityStock          =   5000000000 * ReconToMicro;\n', '    uint constant public ReconVaultAdvancePaymentStock    =   5000000000 * ReconToMicro;\n', '    uint constant public ReconVaultPrivatStock            =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultCurrencyInsurancestock =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultNextStock              =   4000000000 * ReconToMicro;\n', '    uint constant public ReconVaultFuturStock             =   4000000000 * ReconToMicro;\n', '\n', '\n', '\n', '    // This variables accumulate amount of sold RECON during\n', '    // presale, crowdsale, or given to investors as bonus.\n', '    uint public presaleSold = 0;\n', '    uint public crowdsaleSold = 0;\n', '    uint public investorGiven = 0;\n', '\n', '    // Amount of ETH received during ICO\n', '    uint public ethSold = 0;\n', '\n', '    uint constant public softcapUSD = 20000000000;\n', '    uint constant public preicoUSD  = 5000000000;\n', '\n', '    // Presale lower bound in dollars.\n', '    uint constant public crowdsaleMinUSD = ReconToMicro * 10 * 100 / 12;\n', '    uint constant public bonusLevel0 = ReconToMicro * 10000 * 100 / 12; // 10000$\n', '    uint constant public bonusLevel100 = ReconToMicro * 100000 * 100 / 12; // 100000$\n', '\n', '    // The tokens made available to the public will be in 13 steps\n', '    // for a maximum of 20% of the total supply (see doc for checkTransfer).\n', '    // All dates are stored as timestamps.\n', '    uint constant public unlockDate1  = 1541890800; // 11-11-2018 00:00:00  [1%]  Recon Manager\n', '    uint constant public unlockDate2  = 1545346800; // 21-12-2018 00:00:00  [2%]  Recon Cash-in (B2B)\n', '    uint constant public unlockDate3  = 1549062000; // 02-02-2019 00:00:00  [2%]  Recon Switch (C2C)\n', '    uint constant public unlockDate4  = 1554328800; // 04-04-2019 00:00:00  [2%]  Recon Cash-out (B2C)\n', '    uint constant public unlockDate5  = 1565215200; // 08-08-2019 00:00:00  [2%]  Recon Investment & Recon Momentum\n', '    uint constant public unlockDate6  = 1570658400; // 10-10-2019 00:00:00  [2%]  Recon Reward\n', '    uint constant public unlockDate7  = 1576105200; // 12-12-2019 00:00:00  [1%]  Recon Donate\n', '    uint constant public unlockDate8  = 1580598000; // 02-02-2020 00:00:00  [1%]  Recon Token\n', '    uint constant public unlockDate9  = 1585951200; // 04-04-2020 00:00:00  [2%]  Recon Cash\n', '    uint constant public unlockDate10 = 1591394400; // 06-06-2020 00:00:00  [1%]  Recon Gold\n', '    uint constant public unlockDate11 = 1596837600; // 08-08-2020 00:00:00  [2%]  Recon Card\n', '    uint constant public unlockDate12 = 1602280800; // 10-10-2020 00:00:00  [1%]  Recon Hardrive Wallet\n', '    uint constant public unlockDate13 = 1606863600; // 02-12-2020 00:00:00  [1%]  Recoin Option\n', '\n', '    // The tokens made available to the teams will be made in 4 steps\n', '    // for a maximum of 80% of the total supply (see doc for checkTransfer).\n', '    uint constant public teamUnlock1 = 1544569200; // 12-12-2018 00:00:00  [25%]\n', '    uint constant public teamUnlock2 = 1576105200; // 12-12-2019 00:00:00  [25%]\n', '    uint constant public teamUnlock3 = 1594072800; // 07-07-2020 00:00:00  [25%]\n', '    uint constant public teamUnlock4 = 1608505200; // 21-12-2020 00:00:00  [25%]\n', '\n', '    uint constant public teamETHUnlock1 = 1544569200; // 12-12-2018 00:00:00\n', '    uint constant public teamETHUnlock2 = 1576105200; // 12-12-2019 00:00:00\n', '    uint constant public teamETHUnlock3 = 1594072800; // 07-07-2020 00:00:00\n', '\n', '    //https://casperproject.atlassian.net/wiki/spaces/PROD/pages/277839878/Smart+contract+ICO\n', '    // Presale 10.06.2018 - 22.07.2018\n', '    // Crowd-sale 23.07.2018 - 2.08.2018 (16.08.2018)\n', '    uint constant public presaleStartTime     = 1541890800; // 11-11-2018 00:00:00\n', '    uint constant public crowdsaleStartTime   = 1545346800; // 21-12-2018 00:00:00\n', '    uint          public crowdsaleEndTime     = 1609455599; // 31-12-2020 23:59:59\n', '    uint constant public crowdsaleHardEndTime = 1609455599; // 31-12-2020 23:59:59\n', '    //address constant ReconrWallet = 0x0A5f85C3d41892C934ae82BDbF17027A20717088;\n', '    constructor() public {\n', '        admin = owner;\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndDirector {\n', '        require(msg.sender == owner || msg.sender == director);\n', '        _;\n', '    }\n', '\n', '    address admin;\n', '    function setAdmin(address _newAdmin) public onlyOwnerAndDirector {\n', '        admin = _newAdmin;\n', '    }\n', '\n', '    address director;\n', '    function setDirector(address _newDirector) public onlyOwner {\n', '        director = _newDirector;\n', '    }\n', '\n', '    bool assignedPreico = false;\n', '    // @notice assignPreicoTokens transfers 3x tokens to pre-ICO participants (99,000,000)\n', '    function assignPreicoTokens() public onlyOwnerAndDirector {\n', '        require(!assignedPreico);\n', '        assignedPreico = true;\n', '\n', '        _freezeTransfer(0x4Bdff2Cc40996C71a1F16b72490d1a8E7Dfb7E56, 3 * 1000000000000000000000000); // Account_34\n', '        _freezeTransfer(0x9189AC4FA7AdBC587fF76DD43248520F8Cb897f3, 3 * 1000000000000000000000000); // Account_35\n', '        _freezeTransfer(0xc1D3DAd07A0dB42a7d34453C7d09eFeA793784e7, 3 * 1000000000000000000000000); // Account_36\n', '        _freezeTransfer(0xA0BC1BAAa5318E39BfB66F8Cd0496d6b09CaE6C1, 3 * 1000000000000000000000000); // Account_37\n', '        _freezeTransfer(0x9a2912F145Ab0d5b4aE6917A8b8ddd222539F424, 3 * 1000000000000000000000000); // Account_38\n', '        _freezeTransfer(0x0bB0ded1d868F1c0a50bD31c1ab5ab7b53c6BC20, 3 * 1000000000000000000000000); // Account_39\n', '        _freezeTransfer(0x65ec9f30249065A1BD23a9c68c0Ee9Ead63b4A4d, 3 * 1000000000000000000000000); // Account_40\n', '        _freezeTransfer(0x87Bdc03582deEeB84E00d3fcFd083B64DA77F471, 3 * 1000000000000000000000000); // Account_41\n', '        _freezeTransfer(0x81382A0998191E2Dd8a7bB2B8875D4Ff6CAA31ff, 3 * 1000000000000000000000000); // Account_42\n', '        _freezeTransfer(0x790069C894ebf518fB213F35b48C8ec5AAF81E62, 3 * 1000000000000000000000000); // Account_43\n', '        _freezeTransfer(0xa3f1404851E8156DFb425eC0EB3D3d5ADF6c8Fc0, 3 * 1000000000000000000000000); // Account_44\n', '        _freezeTransfer(0x11bA01dc4d93234D24681e1B19839D4560D17165, 3 * 1000000000000000000000000); // Account_45\n', '        _freezeTransfer(0x211D495291534009B8D3fa491400aB66F1d6131b, 3 * 1000000000000000000000000); // Account_46\n', '        _freezeTransfer(0x8c481AaF9a735F9a44Ac2ACFCFc3dE2e9B2f88f8, 3 * 1000000000000000000000000); // Account_47\n', '        _freezeTransfer(0xd0BEF2Fb95193f429f0075e442938F5d829a33c8, 3 * 1000000000000000000000000); // Account_48\n', '        _freezeTransfer(0x424cbEb619974ee79CaeBf6E9081347e64766705, 3 * 1000000000000000000000000); // Account_49\n', '        _freezeTransfer(0x9e395cd98089F6589b90643Dde4a304cAe4dA61C, 3 * 1000000000000000000000000); // Account_50\n', '        _freezeTransfer(0x3cDE6Df0906157107491ED17C79fF9218A50D7Dc, 3 * 1000000000000000000000000); // Account_51\n', '        _freezeTransfer(0x419a98D46a368A1704278349803683abB2A9D78E, 3 * 1000000000000000000000000); // Account_52\n', '        _freezeTransfer(0x106Db742344FBB96B46989417C151B781D1a4069, 3 * 1000000000000000000000000); // Account_53\n', '        _freezeTransfer(0xE16b9E9De165DbecA18B657414136cF007458aF5, 3 * 1000000000000000000000000); // Account_54\n', '        _freezeTransfer(0xee32C325A3E11759b290df213E83a257ff249936, 3 * 1000000000000000000000000); // Account_55\n', '        _freezeTransfer(0x7d6F916b0E5BF7Ba7f11E60ed9c30fB71C4A5fE0, 3 * 1000000000000000000000000); // Account_56\n', '        _freezeTransfer(0xCC684085585419100AE5010770557d5ad3F3CE58, 3 * 1000000000000000000000000); // Account_57\n', '        _freezeTransfer(0xB47BE6d74C5bC66b53230D07fA62Fb888594418d, 3 * 1000000000000000000000000); // Account_58\n', '        _freezeTransfer(0xf891555a1BF2525f6EBaC9b922b6118ca4215fdD, 3 * 1000000000000000000000000); // Account_59\n', '        _freezeTransfer(0xE3124478A5ed8550eA85733a4543Dd128461b668, 3 * 1000000000000000000000000); // Account_60\n', '        _freezeTransfer(0xc5836df630225112493fa04fa32B586f072d6298, 3 * 1000000000000000000000000); // Account_61\n', '        _freezeTransfer(0x144a0543C93ce8Fb26c13EB619D7E934FA3eA734, 3 * 1000000000000000000000000); // Account_62\n', '        _freezeTransfer(0x43731e24108E928984DcC63DE7affdF3a805FFb0, 3 * 1000000000000000000000000); // Account_63\n', '        _freezeTransfer(0x49f7744Aa8B706Faf336a3ff4De37078714065BC, 3 * 1000000000000000000000000); // Account_64\n', '        _freezeTransfer(0x1E55C7E97F0b5c162FC9C42Ced92C8e55053e093, 3 * 1000000000000000000000000); // Account_65\n', '        _freezeTransfer(0x40b234009664590997D2F6Fde2f279fE56e8AaBC, 3 * 1000000000000000000000000); // Account_66\n', '    }\n', '\n', '    bool assignedTeam = false;\n', '    // @notice assignTeamTokens assigns tokens to team members (79,901,000,000)\n', '    // @notice tokens for team have their own supply\n', '    function assignTeamTokens() public onlyOwnerAndDirector {\n', '        require(!assignedTeam);\n', '        assignedTeam = true;\n', '\n', '        _teamTransfer(0x0A5f85C3d41892C934ae82BDbF17027A20717088,  101000000 * ReconToMicro); // Recon owner\n', '        _teamTransfer(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060,  100000000 * ReconToMicro); // Recon newOwner\n', '        _teamTransfer(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840,   50000000 * ReconToMicro); // Recon minter\n', '        _teamTransfer(0xc083E68D962c2E062D2735B54804Bb5E1f367c1b,   50000000 * ReconToMicro); // Recon feeAccount\n', '        _teamTransfer(0xF848332f5D902EFD874099458Bc8A53C8b7881B1,   50000000 * ReconToMicro); // Recon spender\n', '        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,   50000000 * ReconToMicro); // Recon recoveredAddress\n', '        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,  200000000 * ReconToMicro); // Proprity from ReconBank\n', '        _teamTransfer(0xD974C2D74f0F352467ae2Da87fCc64491117e7ac,  200000000 * ReconToMicro); // Recon Manager\n', '        _teamTransfer(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF, 5000000000 * ReconToMicro); // Recon Cash-in (B2B)\n', '        _teamTransfer(0xeB479640A6D55374aF36896eCe6db7d92F390015, 5000000000 * ReconToMicro); // Recon Switch (C2C)\n', '        _teamTransfer(0x77167D25Db87dc072399df433e450B00b8Ec105A, 7000000000 * ReconToMicro); // Recon Cash-out (B2C)\n', '        _teamTransfer(0x5C6Fd84b961Cce03e027B0f8aE23c4A6e1195E90, 2000000000 * ReconToMicro); // Recon Investment\n', '        _teamTransfer(0x86F427c5e05C29Fd4124746f6111c1a712C9B5c8, 2000000000 * ReconToMicro); // Recon Momentum\n', '        _teamTransfer(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B, 2000000000 * ReconToMicro); // Recon Reward\n', '        _teamTransfer(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0, 1000000000 * ReconToMicro); // Recon Donate\n', '        _teamTransfer(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2, 4000000000 * ReconToMicro); // Recon Token\n', '        _teamTransfer(0x5a27B07003ce50A80dbBc5512eA5BBd654790673, 4000000000 * ReconToMicro); // Recon Cash\n', '        _teamTransfer(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692, 4000000000 * ReconToMicro); // Recon Gold\n', '        _teamTransfer(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9, 4000000000 * ReconToMicro); // Recon Card\n', '        _teamTransfer(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5, 2000000000 * ReconToMicro); // Recon Hardrive Wallet\n', '        _teamTransfer(0x14bd2Aa04619658F517521adba7E5A17dfD2A3f0, 1000000000 * ReconToMicro); // Recoin Option\n', '        _teamTransfer(0x9C3091a335383566d08cba374157Bdff5b8B034B,  100000000 * ReconToMicro); // Recon Promo\n', '        _teamTransfer(0x3b6F53122903c40ef61441dB807f09D90D6F05c7, 1000000000 * ReconToMicro); // Recon patents\n', '        _teamTransfer(0x7fb5EF151446Adb0B7D39B1902E45f06E11038F6, 1000000000 * ReconToMicro); // Recon Security & Legal Fees\n', '        _teamTransfer(0x47BD87fa63Ce818584F050aFFECca0f1dfFd0564, 1000000000 * ReconToMicro); // \u200bPeer To Peer Networking Service\n', '        _teamTransfer(0x83b3CD589Bd78aE65d7b338fF7DFc835cD9a8edD, 2000000000 * ReconToMicro); // Reconia\n', '        _teamTransfer(0x6299496342fFd22B7191616fcD19CeC6537C2E8D, 8000000000 * ReconToMicro); // \u200bRecon Central Securities Depository (Recon Vault\xa0XtraStock)\n', '        _teamTransfer(0x26aF11607Fad4FacF1fc44271aFA63Dbf2C22a87, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault\xa0SecurityStock)\n', '        _teamTransfer(0x7E21203C5B4A6f98E4986f850dc37eBE9Ca19179, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Advance Payment Stock)\n', '        _teamTransfer(0x0bD212e88522b7F4C673fccBCc38558829337f71, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault PrivatStock)\n', '        _teamTransfer(0x5b44e309408cE6E73B9f5869C9eeaCeeb8084DC8, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Currency Insurance stock)\n', '        _teamTransfer(0x48F2eFDE1c028792EbE7a870c55A860e40eb3573, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault\xa0NextStock)\n', '        _teamTransfer(0x1fF3BE6f711C684F04Cf6adfD665Ce13D54CAC73, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault\xa0FuturStock)\n', '    }\n', '\n', '    // @nptice kycPassed is executed by backend and tells SC\n', '    // that particular client has passed KYC\n', '    mapping(address => bool) public kyc;\n', '    mapping(address => address) public referral;\n', '    function kycPassed(address _mem, address _ref) public onlyAdmin {\n', '        kyc[_mem] = true;\n', '        if (_ref == richardAddr || _ref == wuguAddr) {\n', '            referral[_mem] = _ref;\n', '        }\n', '    }\n', '\n', '    // mappings for implementing ERC20\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // mapping for implementing unlock mechanic\n', '    mapping(address => uint) freezed;\n', '    mapping(address => uint) teamFreezed;\n', '\n', '    // ERC20 standard functions\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _tokens) private {\n', '        balances[_from] = balances[_from].sub(_tokens);\n', '        balances[_to] = balances[_to].add(_tokens);\n', '        emit Transfer(_from, _to, _tokens);\n', '    }\n', '\n', '    function transfer(address _to, uint _tokens) public returns (bool success) {\n', '        checkTransfer(msg.sender, _tokens);\n', '        _transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        checkTransfer(from, tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        _transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // @notice checkTransfer ensures that `from` can send only unlocked tokens\n', '    // @notice this function is called for every transfer\n', '    // We unlock PURCHASED and BONUS tokens in 13 stages:\n', '    function checkTransfer(address from, uint tokens) public view {\n', '        uint newBalance = balances[from].sub(tokens);\n', '        uint total = 0;\n', '        if (now < unlockDate5) {\n', '            require(now >= unlockDate1);\n', '            uint frzdPercent = 0;\n', '            if (now < unlockDate2) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate3) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate4) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate5) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate6) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate7) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate8) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate9) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate10) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate11) {\n', '                frzdPercent = 5;\n', '            } else if (now < unlockDate12) {\n', '                frzdPercent = 10;\n', '            } else if (now < unlockDate13) {\n', '                frzdPercent = 5;\n', '            } else {\n', '                frzdPercent = 5;\n', '            }\n', '            total = freezed[from].mul(frzdPercent).div(100);\n', '            require(newBalance >= total);\n', '        }\n', '\n', '        if (now < teamUnlock4 && teamFreezed[from] > 0) {\n', '            uint p = 0;\n', '            if (now < teamUnlock1) {\n', '                p = 100;\n', '            } else if (now < teamUnlock2) {\n', '                p = 75;\n', '            } else if (now < teamUnlock3) {\n', '                p = 50;\n', '            } else if (now < teamUnlock4) {\n', '                p = 25;\n', '            }\n', '            total = total.add(teamFreezed[from].mul(p).div(100));\n', '            require(newBalance >= total);\n', '        }\n', '    }\n', '\n', '    // @return ($ received, ETH received, RECON sold)\n', '    function ICOStatus() public view returns (uint usd, uint eth, uint recon) {\n', '        usd = presaleSold.mul(12).div(10**20) + crowdsaleSold.mul(16).div(10**20);\n', '        usd = usd.add(preicoUSD); // pre-ico tokens\n', '\n', '        return (usd, ethSold + preicoUSD.mul(10**8).div(ethRate), presaleSold + crowdsaleSold);\n', '    }\n', '\n', '    function checkICOStatus() public view returns(bool) {\n', '        uint eth;\n', '        uint recon;\n', '\n', '        (, eth, recon) = ICOStatus();\n', '\n', '        uint dollarsRecvd = eth.mul(ethRate).div(10**8);\n', '\n', '        // 26 228 800$\n', '        return dollarsRecvd >= 25228966 || (recon == presaleSupply + crowdsaleSupply) || now > crowdsaleEndTime;\n', '    }\n', '\n', '    bool icoClosed = false;\n', '    function closeICO() public onlyOwner {\n', '        require(!icoClosed);\n', '        icoClosed = checkICOStatus();\n', '    }\n', '\n', '    // @notice by agreement, we can transfer $4.8M from bank\n', '    // after softcap is reached.\n', '    // @param _to wallet to send RECON to\n', '    // @param  _usd amount of dollars which is withdrawn\n', '    uint bonusTransferred = 0;\n', '    uint constant maxUSD = 4800000;\n', '    function transferBonus(address _to, uint _usd) public onlyOwner {\n', '        bonusTransferred = bonusTransferred.add(_usd);\n', '        require(bonusTransferred <= maxUSD);\n', '\n', '        uint recon = _usd.mul(100).mul(ReconToMicro).div(12); // presale tariff\n', '        presaleSold = presaleSold.add(recon);\n', '        require(presaleSold <= presaleSupply);\n', '        ethSold = ethSold.add(_usd.mul(10**8).div(ethRate));\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice extend crowdsale for 2 weeks\n', '    function prolongCrowdsale() public onlyOwnerAndDirector {\n', '        require(now < crowdsaleEndTime);\n', '        crowdsaleEndTime = crowdsaleHardEndTime;\n', '    }\n', '\n', '    // 100 000 000 Ether in dollars\n', '    uint public ethRate = 0;\n', '    uint public ethRateMax = 0;\n', '    uint public ethLastUpdate = 0;\n', '    function setETHRate(uint _rate) public onlyAdmin {\n', '        require(ethRateMax == 0 || _rate < ethRateMax);\n', '        ethRate = _rate;\n', '        ethLastUpdate = now;\n', '    }\n', '\n', '    // 100 000 000 BTC in dollars\n', '    uint public btcRate = 0;\n', '    uint public btcRateMax = 0;\n', '    uint public btcLastUpdate;\n', '    function setBTCRate(uint _rate) public onlyAdmin {\n', '        require(btcRateMax == 0 || _rate < btcRateMax);\n', '        btcRate = _rate;\n', '        btcLastUpdate = now;\n', '    }\n', '\n', '    // @notice setMaxRate sets max rate for both BTC/ETH to soften\n', '    // negative consequences in case our backend gots hacked.\n', '    function setMaxRate(uint ethMax, uint btcMax) public onlyOwnerAndDirector {\n', '        ethRateMax = ethMax;\n', '        btcRateMax = btcMax;\n', '    }\n', '\n', '    // @notice _sellPresale checks RECON purchases during crowdsale\n', '    function _sellPresale(uint recon) private {\n', '        require(recon >= bonusLevel0.mul(9950).div(10000));\n', '        presaleSold = presaleSold.add(recon);\n', '        require(presaleSold <= presaleSupply);\n', '    }\n', '\n', '    // @notice _sellCrowd checks RECON purchases during crowdsale\n', '    function _sellCrowd(uint recon, address _to) private {\n', '        require(recon >= crowdsaleMinUSD);\n', '\n', '        if (crowdsaleSold.add(recon) <= crowdsaleSupply) {\n', '            crowdsaleSold = crowdsaleSold.add(recon);\n', '        } else {\n', '            presaleSold = presaleSold.add(crowdsaleSold).add(recon).sub(crowdsaleSupply);\n', '            require(presaleSold <= presaleSupply);\n', '            crowdsaleSold = crowdsaleSupply;\n', '        }\n', '\n', '        if (now < crowdsaleStartTime + 3 days) {\n', '            if (whitemap[_to] >= recon) {\n', '                whitemap[_to] -= recon;\n', '                whitelistTokens -= recon;\n', '            } else {\n', '                require(crowdsaleSupply.add(presaleSupply).sub(presaleSold) >= crowdsaleSold.add(whitelistTokens));\n', '            }\n', '        }\n', '    }\n', '\n', '    // @notice addInvestorBonusInPercent is used for sending bonuses for big investors in %\n', '    function addInvestorBonusInPercent(address _to, uint8 p) public onlyOwner {\n', '        require(p > 0 && p <= 5);\n', '        uint bonus = balances[_to].mul(p).div(100);\n', '\n', '        investorGiven = investorGiven.add(bonus);\n', '        require(investorGiven <= investorSupply);\n', '\n', '        _freezeTransfer(_to, bonus);\n', '    }\n', '\n', '    // @notice addInvestorBonusInTokens is used for sending bonuses for big investors in tokens\n', '    function addInvestorBonusInTokens(address _to, uint tokens) public onlyOwner {\n', '        _freezeTransfer(_to, tokens);\n', '\n', '        investorGiven = investorGiven.add(tokens);\n', '        require(investorGiven <= investorSupply);\n', '    }\n', '\n', '    function () payable public {\n', '        purchaseWithETH(msg.sender);\n', '    }\n', '\n', '    // @notice _freezeTranfer perform actual tokens transfer which\n', '    // will be freezed (see also checkTransfer() )\n', '    function _freezeTransfer(address _to, uint recon) private {\n', '        _transfer(owner, _to, recon);\n', '        freezed[_to] = freezed[_to].add(recon);\n', '    }\n', '\n', '    // @notice _freezeTranfer perform actual tokens transfer which\n', '    // will be freezed (see also checkTransfer() )\n', '    function _teamTransfer(address _to, uint recon) private {\n', '        _transfer(owner, _to, recon);\n', '        teamFreezed[_to] = teamFreezed[_to].add(recon);\n', '    }\n', '\n', '    address public constant wuguAddr = 0x0d340F1344a262c13485e419860cb6c4d8Ec9C6e;\n', '    address public constant richardAddr = 0x49BE16e7FECb14B82b4f661D9a0426F810ED7127;\n', '    mapping(address => address[]) promoterClients;\n', '    mapping(address => mapping(address => uint)) promoterBonus;\n', '\n', '    // @notice withdrawPromoter transfers back to promoter\n', '    // all bonuses accumulated to current moment\n', '    function withdrawPromoter() public {\n', '        address _to = msg.sender;\n', '        require(_to == wuguAddr || _to == richardAddr);\n', '\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // USD received - 5% must be more than softcap\n', '        require(usd.mul(95).div(100) >= softcapUSD);\n', '\n', '        uint bonus = 0;\n', '        address[] memory clients = promoterClients[_to];\n', '        for(uint i = 0; i < clients.length; i++) {\n', '            if (kyc[clients[i]]) {\n', '                uint num = promoterBonus[_to][clients[i]];\n', '                delete promoterBonus[_to][clients[i]];\n', '                bonus += num;\n', '            }\n', '        }\n', '\n', '        _to.transfer(bonus);\n', '    }\n', '\n', '    // @notice cashBack will be used in case of failed ICO\n', '    // All partitipants can receive their ETH back\n', '    function cashBack(address _to) public {\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // ICO fails if crowd-sale is ended and we have not yet reached soft-cap\n', '        require(now > crowdsaleEndTime && usd < softcapUSD);\n', '        require(ethSent[_to] > 0);\n', '\n', '        delete ethSent[_to];\n', '\n', '        _to.transfer(ethSent[_to]);\n', '    }\n', '\n', '    // @notice stores amount of ETH received by SC\n', '    mapping(address => uint) ethSent;\n', '\n', '    function purchaseWithETH(address _to) payable public {\n', '        purchaseWithPromoter(_to, referral[msg.sender]);\n', '    }\n', '\n', '    // @notice purchases tokens, which a send to `_to` with 5% returned to `_ref`\n', '    // @notice 5% return must work only on crowdsale\n', '    function purchaseWithPromoter(address _to, address _ref) payable public {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        uint _wei = msg.value;\n', '        uint recon;\n', '\n', '        ethSent[msg.sender] = ethSent[msg.sender].add(_wei);\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            recon = _wei.mul(ethRate).div(75000000); // 1 RECON = 0.75 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || recon >= bonusLevel100);\n', '\n', '            _sellPresale(recon);\n', '\n', '            // we have only 2 recognized promoters\n', '            if (_ref == wuguAddr || _ref == richardAddr) {\n', '                promoterClients[_ref].push(_to);\n', '                promoterBonus[_ref][_to] = _wei.mul(5).div(100);\n', '            }\n', '        } else {\n', '            recon = _wei.mul(ethRate).div(10000000); // 1 RECON = 1.00 $ on crowd-sale\n', '            _sellCrowd(recon, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice purchaseWithBTC is called from backend, where we convert\n', '    // BTC to ETH, and then assign tokens to purchaser, using BTC / $ exchange rate.\n', '    function purchaseWithBTC(address _to, uint _satoshi, uint _wei) public onlyAdmin {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        uint recon;\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            recon = _satoshi.mul(btcRate.mul(10000)).div(75); // 1 RECON = 0.75 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || recon >= bonusLevel100);\n', '\n', '            _sellPresale(recon);\n', '        } else {\n', '            recon = _satoshi.mul(btcRate.mul(10000)).div(100); // 1 RECON = 1.00 $ on presale\n', '            _sellCrowd(recon, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, recon);\n', '    }\n', '\n', '    // @notice withdrawFunds is called to send team bonuses after\n', '    // then end of the ICO\n', '    bool withdrawCalled = false;\n', '    function withdrawFunds() public onlyOwner {\n', '        require(icoClosed && now >= teamETHUnlock1);\n', '\n', '        require(!withdrawCalled);\n', '        withdrawCalled = true;\n', '\n', '        uint eth;\n', '        (,eth,) = ICOStatus();\n', '\n', '        // pre-ico tokens are not in ethSold\n', '        uint minus = bonusTransferred.mul(10**8).div(ethRate);\n', '        uint team = ethSold.sub(minus);\n', '\n', '        team = team.mul(15).div(100);\n', '\n', '        uint ownerETH = 0;\n', '        uint teamETH = 0;\n', '        if (address(this).balance >= team) {\n', '            teamETH = team;\n', '            ownerETH = address(this).balance.sub(teamETH);\n', '        } else {\n', '            teamETH = address(this).balance;\n', '        }\n', '\n', '        teamETH1 = teamETH.div(3);\n', '        teamETH2 = teamETH.div(3);\n', '        teamETH3 = teamETH.sub(teamETH1).sub(teamETH2);\n', '\n', '        // TODO multisig\n', '        address(0xf14B65F1589B8bC085578BcF68f09653D8F6abA8).transfer(ownerETH);\n', '    }\n', '\n', '    uint teamETH1 = 0;\n', '    uint teamETH2 = 0;\n', '    uint teamETH3 = 0;\n', '    function withdrawTeam() public {\n', '        require(now >= teamETHUnlock1);\n', '\n', '        uint amount = 0;\n', '        if (now < teamETHUnlock2) {\n', '            amount = teamETH1;\n', '            teamETH1 = 0;\n', '        } else if (now < teamETHUnlock3) {\n', '            amount = teamETH1 + teamETH2;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '        } else {\n', '            amount = teamETH1 + teamETH2 + teamETH3;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '            teamETH3 = 0;\n', '        }\n', '\n', '        address(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF).transfer(amount.mul(6).div(100)); // Recon Cash-in (B2B)\n', '        address(0xeB479640A6D55374aF36896eCe6db7d92F390015).transfer(amount.mul(6).div(100)); // Recon Switch (C2C)\n', '        address(0x77167D25Db87dc072399df433e450B00b8Ec105A).transfer(amount.mul(6).div(100)); // Recon Cash-out (B2C)\n', '        address(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B).transfer(amount.mul(2).div(100)); // Recon Reward\n', '        address(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0).transfer(amount.mul(2).div(100)); // Recon Donate\n', '\n', '        amount = amount.mul(78).div(100);\n', '\n', '        address(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2).transfer(amount.mul(uint(255).mul(100).div(96)).div(1000)); // Recon Token\n', '        address(0x5a27B07003ce50A80dbBc5512eA5BBd654790673).transfer(amount.mul(uint(185).mul(100).div(96)).div(1000)); // Recon Cash\n', '        address(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692).transfer(amount.mul(uint(25).mul(100).div(96)).div(1000));  // Recon Gold\n', '        address(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9).transfer(amount.mul(uint(250).mul(100).div(96)).div(1000)); // Recon Card\n', '        address(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5).transfer(amount.mul(uint(245).mul(100).div(96)).div(1000)); // Recon Hardrive Wallet\n', '    }\n', '\n', '    // @notice doAirdrop is called when we launch airdrop.\n', '    // @notice airdrop tokens has their own supply.\n', '    uint dropped = 0;\n', '    function doAirdrop(address[] members, uint[] tokens) public onlyOwnerAndDirector {\n', '        require(members.length == tokens.length);\n', '\n', '        for(uint i = 0; i < members.length; i++) {\n', '            _freezeTransfer(members[i], tokens[i]);\n', '            dropped = dropped.add(tokens[i]);\n', '        }\n', '        require(dropped <= bountySupply);\n', '    }\n', '\n', '    mapping(address => uint) public whitemap;\n', '    uint public whitelistTokens = 0;\n', '    // @notice addWhitelistMember is used to whitelist participant.\n', '    // This means, that for the first 3 days of crowd-sale `_tokens` RECON\n', '    // will be reserved for him.\n', '    function addWhitelistMember(address[] _mem, uint[] _tokens) public onlyAdmin {\n', '        require(_mem.length == _tokens.length);\n', '        for(uint i = 0; i < _mem.length; i++) {\n', '            whitelistTokens = whitelistTokens.sub(whitemap[_mem[i]]).add(_tokens[i]);\n', '            whitemap[_mem[i]] = _tokens[i];\n', '        }\n', '    }\n', '\n', '    uint public adviserSold = 0;\n', '    // @notice transferAdviser is called to send tokens to advisers.\n', '    // @notice adviser tokens have their own supply\n', '    function transferAdviser(address[] _adv, uint[] _tokens) public onlyOwnerAndDirector {\n', '        require(_adv.length == _tokens.length);\n', '        for (uint i = 0; i < _adv.length; i++) {\n', '            adviserSold = adviserSold.add(_tokens[i]);\n', '            _freezeTransfer(_adv[i], _tokens[i]);\n', '        }\n', '        require(adviserSold <= adviserSupply);\n', '    }\n', '\n', '    mapping(address => bool) approvedInvestors;\n', '    function approveInvestor(address _addr) public onlyOwner {\n', '        approvedInvestors[_addr] = true;\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract ERC20InterfaceTest {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contracts that can have tokens approved, and then a function execute\n', '// ----------------------------------------------------------------------------\n', 'contract TestApproveAndCallFallBack {\n', '    event LogBytes(bytes data);\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public {\n', '        ERC20Interface(token).transferFrom(from, address(this), tokens);\n', '        emit LogBytes(data);\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract AccessRestriction {\n', '    // These will be assigned at the construction\n', '    // phase, where `msg.sender` is the account\n', '    // creating this contract.\n', '    address public owner = msg.sender;\n', '    uint public creationTime = now;\n', '\n', '    // Modifiers can be used to change\n', '    // the body of a function.\n', '    // If this modifier is used, it will\n', '    // prepend a check that only passes\n', '    // if the function is called from\n', '    // a certain address.\n', '    modifier onlyBy(address _account)\n', '    {\n', '        require(\n', '            msg.sender == _account,\n', '            "Sender not authorized."\n', '        );\n', '        // Do not forget the "_;"! It will\n', '        // be replaced by the actual function\n', '        // body when the modifier is used.\n', '        _;\n', '    }\n', '\n', '    // Make `_newOwner` the new owner of this\n', '    // contract.\n', '    function changeOwner(address _newOwner)\n', '        public\n', '        onlyBy(owner)\n', '    {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    modifier onlyAfter(uint _time) {\n', '        require(\n', '            now >= _time,\n', '            "Function called too early."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // Erase ownership information.\n', '    // May only be called 6 weeks after\n', '    // the contract has been created.\n', '    function disown()\n', '        public\n', '        onlyBy(owner)\n', '        onlyAfter(creationTime + 6 weeks)\n', '    {\n', '        delete owner;\n', '    }\n', '\n', '    // This modifier requires a certain\n', '    // fee being associated with a function call.\n', '    // If the caller sent too much, he or she is\n', '    // refunded, but only after the function body.\n', '    // This was dangerous before Solidity version 0.4.0,\n', '    // where it was possible to skip the part after `_;`.\n', '    modifier costs(uint _amount) {\n', '        require(\n', '            msg.value >= _amount,\n', '            "Not enough Ether provided."\n', '        );\n', '        _;\n', '        if (msg.value > _amount)\n', '            msg.sender.transfer(msg.value - _amount);\n', '    }\n', '\n', '    function forceOwnerChange(address _newOwner)\n', '        public\n', '        payable\n', '        costs(200 ether)\n', '    {\n', '        owner = _newOwner;\n', '        // just some example condition\n', '        if (uint(owner) & 0 == 1)\n', '            // This did not refund for Solidity\n', '            // before version 0.4.0.\n', '            return;\n', '        // refund overpaid fees\n', '    }\n', '}\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', 'pragma solidity ^ 0.4.25;\n', '\n', 'contract WithdrawalContract {\n', '    address public richest;\n', '    uint public mostSent;\n', '\n', '    mapping (address => uint) pendingWithdrawals;\n', '\n', '    constructor() public payable {\n', '        richest = msg.sender;\n', '        mostSent = msg.value;\n', '    }\n', '\n', '    function becomeRichest() public payable returns (bool) {\n', '        if (msg.value > mostSent) {\n', '            pendingWithdrawals[richest] += msg.value;\n', '            richest = msg.sender;\n', '            mostSent = msg.value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint amount = pendingWithdrawals[msg.sender];\n', '        // Remember to zero the pending refund before\n', '        // sending to prevent re-entrancy attacks\n', '        pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '}\n', '\n', '\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//.\n', '//"\n', '//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\n', "//.           ;;;;``;;;; ;;;;'''' ,;;;'````'  .;;;;;;;.`;;;;,  `;;;\n", "//.            [[[,/[[['  [[cccc  [[[        ,[[     \\[[,[[[[[. '[[\n", '//.            $$$$$$c    $$""""  $$$        $$$,     $$$$$$ "Y$c$$\n', '//.            888b "88bo,888oo,__`88bo,__,o,"888,_ _,88P888    Y88\n', '//.            MMMM   "W" """"YUMMM "YUMMMMMP" "YMMMMMP" MMM     YM\n', '//.\n', '//.\n', '//" -----------------------------------------------------------------------------------------------------------------\n', '//             ¸.•*´¨)\n', '//        ¸.•´   ¸.•´¸.•*´¨) ¸.•*¨)\n', '//  ¸.•*´       (¸.•´ (¸.•` ¤ ReconBank.eth / ReconBank.com*´¨)\n', '//                                                        ¸.•´¸.•*´¨)\n', '//                                                      (¸.•´   ¸.•`\n', '//                                                          ¸.•´•.¸\n', '//   (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\n', '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// Common ownership of :\n', '//  ____  _            _    _____                       _____ _           _\n', '// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\n', '// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\n', "// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| '_ \\| |    | '_ \\ / _` | | '_ \\\n", '// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\n', '// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|®\n', "//'\n", '// -----------------------------------------------------------------------------------------------------------------\n', '//\n', '// This contract is an order from :\n', "//'\n", '// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗®\n', '// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\n', '// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\n', '// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\n', '// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\n', "// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝'\n", '//\n', '// -----------------------------------------------------------------------------------------------------------------\n', '\n', '\n', '// Thank you for making the extra effort that others probably wouldnt have made']
