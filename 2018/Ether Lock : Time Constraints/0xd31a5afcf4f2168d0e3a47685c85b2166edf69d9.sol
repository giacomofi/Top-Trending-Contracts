['pragma solidity ^0.4.24;\n', '\n', '// written by garry from Team Chibi Fighters\n', '// find us at https://chibifighters.io\n', '// chibifighters@gmail.com\n', '// version 1.0.0\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external;\n', '    function balanceOf(address _owner) external view returns (uint256 _balance);\n', '}\n', '\n', 'interface ERC20InterfaceClassic {\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '}\n', '\n', 'contract DailyRewards is Owned {\n', '\n', '\tevent RewardClaimed(\n', '\t\taddress indexed buyer,\n', '\t\tuint256 day\n', '\t);\n', '\t\n', '\t// what day the player is on in his reward chain\n', '\tmapping (address => uint) private daysInRow;\n', '\n', '\t// timeout after which row is broken\n', '\tmapping (address => uint) private timeout;\n', '\t\n', '\t// how often the reward can be claimed, e.g. every 24h\n', '\tuint waitingTime = 24 hours;\n', '\t// window of claiming, if it expires day streak resets to day 1\n', '\tuint waitingTimeBuffer = 48 hours;\n', '\t\n', '\t\n', '\tconstructor() public {\n', '\t    // Explore Chibis and their universe\n', '\t    // Off chain battles, real Ether fights, true on chain ownership\n', '\t    // Leaderboards, tournaments, roleplay elements, we got it all\n', '\t}\n', '\t\n', '\t\n', '\tfunction requestReward() public returns (uint _days) {\n', '\t    require (msg.sender != address(0));\n', '\t    require (now > timeout[msg.sender]);\n', '\t    \n', '\t    // waited too long, reset\n', '\t    if (now > timeout[msg.sender] + waitingTimeBuffer) {\n', '\t        daysInRow[msg.sender] = 1;    \n', '\t    } else {\n', '\t        // no limit to being logged in, looking forward to the longest streak\n', '\t        daysInRow[msg.sender]++;\n', '\t    }\n', '\t    \n', '\t    timeout[msg.sender] = now + waitingTime;\n', '\t    \n', '\t    emit RewardClaimed(msg.sender, daysInRow[msg.sender]);\n', '\t    \n', '\t    return daysInRow[msg.sender];\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Query stats of next reward, checks for expired time, too\n', '\t **/\n', '\tfunction nextReward() public view returns (uint _day, uint _nextClaimTime, uint _nextClaimExpire) {\n', '\t    uint _dayCheck;\n', '\t    if (now > timeout[msg.sender] + waitingTimeBuffer) _dayCheck = 1; else _dayCheck = daysInRow[msg.sender] + 1;\n', '\t    \n', '\t    return (_dayCheck, timeout[msg.sender], timeout[msg.sender] + waitingTimeBuffer);\n', '\t}\n', '\t\n', '\t\n', '\tfunction queryWaitingTime() public view returns (uint _waitingTime) {\n', '\t    return waitingTime;\n', '\t}\n', '\t\n', '\tfunction queryWaitingTimeBuffer() public view returns (uint _waitingTimeBuffer) {\n', '\t    return waitingTimeBuffer;\n', '\t}\n', '\t\n', '\n', '\t/**\n', '\t * @dev Sets the interval for daily rewards, e.g. 24h = 86400\n', '\t * @param newTime New interval time in seconds\n', '\t **/\n', '\tfunction setWaitingTime(uint newTime) public onlyOwner returns (uint _newWaitingTime) {\n', '\t    waitingTime = newTime;\n', '\t    return waitingTime;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Sets buffer for daily rewards. So user have time to claim it. e.g. 1h = 3600\n', '\t * @param newTime New buffer in seconds\n', '\t **/\n', '\tfunction setWaitingTimeBuffer(uint newTime) public onlyOwner returns (uint _newWaitingTimeBuffer) {\n', '\t    waitingTimeBuffer = newTime;\n', '\t    return waitingTimeBuffer;\n', '\t}\n', '\n', '\n', '    /**\n', '    * @dev Send Ether to owner\n', '    * @param _address Receiving address\n', '    * @param _amountWei Amount in WEI to send\n', '    **/\n', '    function weiToOwner(address _address, uint _amountWei) public onlyOwner returns (bool) {\n', '        require(_amountWei <= address(this).balance);\n', '        _address.transfer(_amountWei);\n', '        return true;\n', '    }\n', '\n', '    function ERC20ToOwner(address _to, uint256 _amount, ERC20Interface _tokenContract) public onlyOwner {\n', '        _tokenContract.transfer(_to, _amount);\n', '    }\n', '\n', '    function ERC20ClassicToOwner(address _to, uint256 _amount, ERC20InterfaceClassic _tokenContract) public onlyOwner {\n', '        _tokenContract.transfer(_to, _amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// written by garry from Team Chibi Fighters\n', '// find us at https://chibifighters.io\n', '// chibifighters@gmail.com\n', '// version 1.0.0\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external;\n', '    function balanceOf(address _owner) external view returns (uint256 _balance);\n', '}\n', '\n', 'interface ERC20InterfaceClassic {\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '}\n', '\n', 'contract DailyRewards is Owned {\n', '\n', '\tevent RewardClaimed(\n', '\t\taddress indexed buyer,\n', '\t\tuint256 day\n', '\t);\n', '\t\n', '\t// what day the player is on in his reward chain\n', '\tmapping (address => uint) private daysInRow;\n', '\n', '\t// timeout after which row is broken\n', '\tmapping (address => uint) private timeout;\n', '\t\n', '\t// how often the reward can be claimed, e.g. every 24h\n', '\tuint waitingTime = 24 hours;\n', '\t// window of claiming, if it expires day streak resets to day 1\n', '\tuint waitingTimeBuffer = 48 hours;\n', '\t\n', '\t\n', '\tconstructor() public {\n', '\t    // Explore Chibis and their universe\n', '\t    // Off chain battles, real Ether fights, true on chain ownership\n', '\t    // Leaderboards, tournaments, roleplay elements, we got it all\n', '\t}\n', '\t\n', '\t\n', '\tfunction requestReward() public returns (uint _days) {\n', '\t    require (msg.sender != address(0));\n', '\t    require (now > timeout[msg.sender]);\n', '\t    \n', '\t    // waited too long, reset\n', '\t    if (now > timeout[msg.sender] + waitingTimeBuffer) {\n', '\t        daysInRow[msg.sender] = 1;    \n', '\t    } else {\n', '\t        // no limit to being logged in, looking forward to the longest streak\n', '\t        daysInRow[msg.sender]++;\n', '\t    }\n', '\t    \n', '\t    timeout[msg.sender] = now + waitingTime;\n', '\t    \n', '\t    emit RewardClaimed(msg.sender, daysInRow[msg.sender]);\n', '\t    \n', '\t    return daysInRow[msg.sender];\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Query stats of next reward, checks for expired time, too\n', '\t **/\n', '\tfunction nextReward() public view returns (uint _day, uint _nextClaimTime, uint _nextClaimExpire) {\n', '\t    uint _dayCheck;\n', '\t    if (now > timeout[msg.sender] + waitingTimeBuffer) _dayCheck = 1; else _dayCheck = daysInRow[msg.sender] + 1;\n', '\t    \n', '\t    return (_dayCheck, timeout[msg.sender], timeout[msg.sender] + waitingTimeBuffer);\n', '\t}\n', '\t\n', '\t\n', '\tfunction queryWaitingTime() public view returns (uint _waitingTime) {\n', '\t    return waitingTime;\n', '\t}\n', '\t\n', '\tfunction queryWaitingTimeBuffer() public view returns (uint _waitingTimeBuffer) {\n', '\t    return waitingTimeBuffer;\n', '\t}\n', '\t\n', '\n', '\t/**\n', '\t * @dev Sets the interval for daily rewards, e.g. 24h = 86400\n', '\t * @param newTime New interval time in seconds\n', '\t **/\n', '\tfunction setWaitingTime(uint newTime) public onlyOwner returns (uint _newWaitingTime) {\n', '\t    waitingTime = newTime;\n', '\t    return waitingTime;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Sets buffer for daily rewards. So user have time to claim it. e.g. 1h = 3600\n', '\t * @param newTime New buffer in seconds\n', '\t **/\n', '\tfunction setWaitingTimeBuffer(uint newTime) public onlyOwner returns (uint _newWaitingTimeBuffer) {\n', '\t    waitingTimeBuffer = newTime;\n', '\t    return waitingTimeBuffer;\n', '\t}\n', '\n', '\n', '    /**\n', '    * @dev Send Ether to owner\n', '    * @param _address Receiving address\n', '    * @param _amountWei Amount in WEI to send\n', '    **/\n', '    function weiToOwner(address _address, uint _amountWei) public onlyOwner returns (bool) {\n', '        require(_amountWei <= address(this).balance);\n', '        _address.transfer(_amountWei);\n', '        return true;\n', '    }\n', '\n', '    function ERC20ToOwner(address _to, uint256 _amount, ERC20Interface _tokenContract) public onlyOwner {\n', '        _tokenContract.transfer(_to, _amount);\n', '    }\n', '\n', '    function ERC20ClassicToOwner(address _to, uint256 _amount, ERC20InterfaceClassic _tokenContract) public onlyOwner {\n', '        _tokenContract.transfer(_to, _amount);\n', '    }\n', '\n', '}']
