['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract UnicornManagementInterface {\n', '\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    function blackBoxAddress() external view returns (address);\n', '    function unicornBreedingAddress() external view returns (address);\n', '    function geneLabAddress() external view returns (address);\n', '    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function candyPowerToken() external view returns (address);\n', '\n', '    function createDividendPercent() external view returns (uint);\n', '    function sellDividendPercent() external view returns (uint);\n', '    function subFreezingPrice() external view returns (uint);\n', '    function subFreezingTime() external view returns (uint64);\n', '    function subTourFreezingPrice() external view returns (uint);\n', '    function subTourFreezingTime() external view returns (uint64);\n', '    function createUnicornPrice() external view returns (uint);\n', '    function createUnicornPriceInCandy() external view returns (uint);\n', '    function oraclizeFee() external view returns (uint);\n', '\n', '    function paused() external view returns (bool);\n', '    function locked() external view returns (bool);\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool);\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint);\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint);\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint);\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint);\n', '\n', '\n', '    //service\n', '    function registerInit(address _contract) external;\n', '\n', '}\n', '\n', 'contract UnicornAccessControl {\n', '\n', '    UnicornManagementInterface public unicornManagement;\n', '\n', '\n', '    function UnicornAccessControl(address _unicornManagementAddress) public {\n', '        unicornManagement = UnicornManagementInterface(_unicornManagementAddress);\n', '        unicornManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == unicornManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == unicornManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == unicornManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyTournament() {\n', '        require(unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '//    modifier whenUnlocked() {\n', '//        require(!unicornManagement.locked());\n', '//        _;\n', '//    }\n', '\n', '    modifier onlyManagement() {\n', '        require(msg.sender == address(unicornManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyBreeding() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornContract() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress() || unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyGeneLab() {\n', '        require(msg.sender == unicornManagement.geneLabAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyBlackBox() {\n', '        require(msg.sender == unicornManagement.blackBoxAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornToken() {\n', '        require(msg.sender == unicornManagement.unicornTokenAddress());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return unicornManagement.paused();\n', '    }\n', '}\n', '\n', 'contract DividendManagerInterface {\n', '    function payDividend() external payable;\n', '}\n', '\n', 'contract UnicornTokenInterface {\n', '\n', '    //ERC721\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _unicornId) public view returns (address _owner);\n', '    function transfer(address _to, uint256 _unicornId) public;\n', '    function approve(address _to, uint256 _unicornId) public;\n', '    function takeOwnership(uint256 _unicornId) public;\n', '    function totalSupply() public constant returns (uint);\n', '    function owns(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function allowance(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _unicornId) public;\n', '    function createUnicorn(address _owner) external returns (uint);\n', '    //    function burnUnicorn(uint256 _unicornId) external;\n', '    function getGen(uint _unicornId) external view returns (bytes);\n', '    function setGene(uint _unicornId, bytes _gene) external;\n', '    function updateGene(uint _unicornId, bytes _gene) external;\n', '    function getUnicornGenByte(uint _unicornId, uint _byteNo) external view returns (uint8);\n', '\n', '    function setName(uint256 _unicornId, string _name ) external returns (bool);\n', '    function plusFreezingTime(uint _unicornId) external;\n', '    function plusTourFreezingTime(uint _unicornId) external;\n', '    function minusFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function minusTourFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function isUnfreezed(uint _unicornId) external view returns (bool);\n', '    function isTourUnfreezed(uint _unicornId) external view returns (bool);\n', '\n', '    function marketTransfer(address _from, address _to, uint256 _unicornId) external;\n', '}\n', '\n', '\n', 'interface UnicornBalancesInterface {\n', '    //    function tokenPlus(address _token, address _user, uint _value) external returns (bool);\n', '    //    function tokenMinus(address _token, address _user, uint _value) external returns (bool);\n', '    function trustedTokens(address _token) external view returns (bool);\n', '    //    function balanceOf(address token, address user) external view returns (uint);\n', '    function transfer(address _token, address _from, address _to, uint _value) external returns (bool);\n', '    function transferWithFee(address _token, address _userFrom, uint _fullPrice, address _feeTaker, address _priceTaker, uint _price) external returns (bool);\n', '}\n', '\n', 'contract ERC20 {\n', '    //    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract TrustedTokenInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', '\n', '// contract UnicornBreedingInterface {\n', '//     function deleteOffer(uint _unicornId) external;\n', '//     function deleteHybridization(uint _unicornId) external;\n', '// }\n', '\n', 'contract BlackBoxInterface {\n', '    function createGen0(uint _unicornId) public payable;\n', '    function geneCore(uint _childUnicornId, uint _parent1UnicornId, uint _parent2UnicornId) public payable;\n', '}\n', '\n', '\n', 'interface BreedingDataBaseInterface {\n', '\n', '    function gen0Limit() external view returns (uint);\n', '    function gen0Count() external view returns (uint);\n', '    function gen0Step() external view returns (uint);\n', '\n', '    function gen0PresaleLimit() external view returns (uint);\n', '    function gen0PresaleCount() external view returns (uint);\n', '\n', '    function incGen0Count() external;\n', '    function incGen0PresaleCount() external;\n', '    function incGen0Limit() external;\n', '\n', '    function createHybridization(uint _unicornId, uint _price) external;\n', '    function hybridizationExists(uint _unicornId) external view returns (bool);\n', '    function hybridizationPrice(uint _unicornId) external view returns (uint);\n', '    function deleteHybridization(uint _unicornId) external returns (bool);\n', '\n', '    function freezeIndex(uint _unicornId) external view returns (uint);\n', '    function freezeHybridizationsCount(uint _unicornId) external view returns (uint);\n', '    function freezeStatsSumHours(uint _unicornId) external view returns (uint);\n', '    function freezeEndTime(uint _unicornId) external view returns (uint);\n', '    function freezeMustCalculate(uint _unicornId) external view returns (bool);\n', '    function freezeExists(uint _unicornId) external view returns (bool);\n', '\n', '    function createFreeze(uint _unicornId, uint _index) external;\n', '    function incFreezeHybridizationsCount(uint _unicornId) external;\n', '    function setFreezeHybridizationsCount(uint _unicornId, uint _count) external;\n', '\n', '    function incFreezeIndex(uint _unicornId) external;\n', '    function setFreezeEndTime(uint _unicornId, uint _time) external;\n', '    function minusFreezeEndTime(uint _unicornId, uint _time) external;\n', '    function setFreezeMustCalculate(uint _unicornId, bool _mustCalculate) external;\n', '    function setStatsSumHours(uint _unicornId, uint _statsSumHours) external;\n', '\n', '\n', '    function offerExists(uint _unicornId) external view returns (bool);\n', '    function offerPriceEth(uint _unicornId) external view returns (uint);\n', '    function offerPriceCandy(uint _unicornId) external view returns (uint);\n', '\n', '    function createOffer(uint _unicornId, uint _priceEth, uint _priceCandy) external;\n', '    function deleteOffer(uint _unicornId) external;\n', '\n', '}\n', '\n', 'contract UnicornBreeding is UnicornAccessControl {\n', '    using SafeMath for uint;\n', '\n', '    BlackBoxInterface public blackBox;\n', '    TrustedTokenInterface public megaCandyToken;\n', '    BreedingDataBaseInterface public breedingDB;\n', '    UnicornTokenInterface public unicornToken; //only on deploy\n', '    UnicornBalancesInterface public balances;\n', '\n', '    address public candyTokenAddress;\n', '\n', '    event HybridizationAdd(uint indexed unicornId, uint price);\n', '    event HybridizationAccept(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId, uint price);\n', '    event SelfHybridization(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId, uint price);\n', '    event HybridizationDelete(uint indexed unicornId);\n', '    event CreateUnicorn(address indexed owner, uint indexed unicornId, uint parent1, uint  parent2);\n', '    event NewGen0Limit(uint limit);\n', '    event NewGen0Step(uint step);\n', '\n', '    event FreeHybridization(uint256 indexed unicornId);\n', '    event NewSelfHybridizationPrice(uint percentCandy);\n', '\n', '    event UnicornFreezingTimeSet(uint indexed unicornId, uint time);\n', '    event MinusFreezingTime(uint indexed unicornId, uint count);\n', '\n', '    uint public selfHybridizationPrice = 0;\n', '\n', '    uint32[8] internal freezing = [\n', '    uint32(1 hours),    //1 hour\n', '    uint32(2 hours),    //2 - 4 hours\n', '    uint32(8 hours),    //8 - 12 hours\n', '    uint32(16 hours),   //16 - 24 hours\n', '    uint32(36 hours),   //36 - 48 hours\n', '    uint32(72 hours),   //72 - 96 hours\n', '    uint32(120 hours),  //120 - 144 hours\n', '    uint32(168 hours)   //168 hours\n', '    ];\n', '\n', '    //count for random plus from 0 to ..\n', '    uint32[8] internal freezingPlusCount = [\n', '    0, 3, 5, 9, 13, 25, 25, 0\n', '    ];\n', '\n', '\n', '    function makeHybridization(uint _unicornId, uint _price) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(isUnfreezed(_unicornId));\n', '        require(!breedingDB.hybridizationExists(_unicornId));\n', '        require(unicornToken.getUnicornGenByte(_unicornId, 10) > 0);\n', '\n', '        checkFreeze(_unicornId);\n', '        breedingDB.createHybridization(_unicornId, _price);\n', '        emit HybridizationAdd(_unicornId, _price);\n', '        //свободная касса)\n', '        if (_price == 0) {\n', '            emit FreeHybridization(_unicornId);\n', '        }\n', '    }\n', '\n', '    function acceptHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(isUnfreezed(_firstUnicornId) && isUnfreezed(_secondUnicornId));\n', '        require(breedingDB.hybridizationExists(_firstUnicornId));\n', '\n', '        require(unicornToken.getUnicornGenByte(_firstUnicornId, 10) > 0 && unicornToken.getUnicornGenByte(_secondUnicornId, 10) > 0);\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '\n', '        uint price = breedingDB.hybridizationPrice(_firstUnicornId);\n', '\n', '        if (price > 0) {\n', '            uint fullPrice = unicornManagement.getHybridizationFullPrice(price);\n', '\n', '            require(balances.transferWithFee(candyTokenAddress, msg.sender, fullPrice, balances, unicornToken.ownerOf(_firstUnicornId), price));\n', '\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '\n', '        emit HybridizationAccept(_firstUnicornId, _secondUnicornId, newUnicornId, price);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        _deleteHybridization(_firstUnicornId);\n', '    }\n', '\n', '    function selfHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _firstUnicornId) && unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(isUnfreezed(_firstUnicornId) && isUnfreezed(_secondUnicornId));\n', '        require(unicornToken.getUnicornGenByte(_firstUnicornId, 10) > 0 && unicornToken.getUnicornGenByte(_secondUnicornId, 10) > 0);\n', '\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '\n', '        if (selfHybridizationPrice > 0) {\n', '            //            require(balances.balanceOf(candyTokenAddress,msg.sender) >= selfHybridizationPrice);\n', '            require(balances.transfer(candyTokenAddress, msg.sender, balances, selfHybridizationPrice));\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        emit SelfHybridization(_firstUnicornId, _secondUnicornId, newUnicornId, selfHybridizationPrice);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '    }\n', '\n', '    function cancelHybridization (uint _unicornId) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender,_unicornId));\n', '        //require(breedingDB.hybridizationExists(_unicornId));\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function deleteHybridization(uint _unicornId) onlyUnicornToken external {\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function _deleteHybridization(uint _unicornId) internal {\n', '        if (breedingDB.deleteHybridization(_unicornId)) {\n', '            emit HybridizationDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '    //Create new 0 gen\n', '    function createUnicorn() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == getCreateUnicornPrice());\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createUnicornForCandy() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        uint price = getCreateUnicornPriceInCandy();\n', '        //        require(balances.balanceOf(candyTokenAddress,msg.sender) >= price);\n', '        require(balances.transfer(candyTokenAddress, msg.sender, balances, price));\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createPresaleUnicorns(uint _count, address _owner) public payable onlyManager whenPaused returns(bool) {\n', '        require(breedingDB.gen0PresaleCount().add(_count) <= breedingDB.gen0PresaleLimit());\n', '        uint256 newUnicornId;\n', '        address owner = _owner == address(0) ? msg.sender : _owner;\n', '        for (uint i = 0; i < _count; i++){\n', '            newUnicornId = unicornToken.createUnicorn(owner);\n', '            blackBox.createGen0(newUnicornId);\n', '            emit CreateUnicorn(owner, newUnicornId, 0, 0);\n', '            breedingDB.incGen0Count();\n', '            breedingDB.incGen0PresaleCount();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _createUnicorn(address _owner) private returns(uint256) {\n', '        require(breedingDB.gen0Count() < breedingDB.gen0Limit());\n', '        uint256 newUnicornId = unicornToken.createUnicorn(_owner);\n', '        blackBox.createGen0.value(unicornManagement.oraclizeFee())(newUnicornId);\n', '        emit CreateUnicorn(_owner, newUnicornId, 0, 0);\n', '        breedingDB.incGen0Count();\n', '        return newUnicornId;\n', '    }\n', '\n', '    function plusFreezingTime(uint _unicornId) private {\n', '        checkFreeze(_unicornId);\n', '        //если меньше 3 спарок увеличиваю просто спарки, если 3 тогда увеличиваю индекс\n', '        if (breedingDB.freezeHybridizationsCount(_unicornId) < 3) {\n', '            breedingDB.incFreezeHybridizationsCount(_unicornId);\n', '        } else {\n', '            if (breedingDB.freezeIndex(_unicornId) < freezing.length - 1) {\n', '                breedingDB.incFreezeIndex(_unicornId);\n', '                breedingDB.setFreezeHybridizationsCount(_unicornId,0);\n', '            }\n', '        }\n', '\n', '        uint _time = _getFreezeTime(breedingDB.freezeIndex(_unicornId)) + now;\n', '        breedingDB.setFreezeEndTime(_unicornId, _time);\n', '        emit UnicornFreezingTimeSet(_unicornId, _time);\n', '    }\n', '\n', '    function checkFreeze(uint _unicornId) internal {\n', '        if (!breedingDB.freezeExists(_unicornId)) {\n', '            breedingDB.createFreeze(_unicornId, unicornToken.getUnicornGenByte(_unicornId, 163));\n', '        }\n', '        if (breedingDB.freezeMustCalculate(_unicornId)) {\n', '            breedingDB.setFreezeMustCalculate(_unicornId, false);\n', '            breedingDB.setStatsSumHours(_unicornId, _getStatsSumHours(_unicornId));\n', '        }\n', '    }\n', '\n', '    function _getRarity(uint8 _b) internal pure returns (uint8) {\n', '        //        [1; 188] common\n', '        //        [189; 223] uncommon\n', '        //        [224; 243] rare\n', '        //        [244; 253] epic\n', '        //        [254; 255] legendary\n', '        return _b < 1 ? 0 : _b < 189 ? 1 : _b < 224 ? 2 : _b < 244 ? 3 : _b < 254 ? 4 : 5;\n', '    }\n', '\n', '    function _getStatsSumHours(uint _unicornId) internal view returns (uint) {\n', '        uint8[5] memory physStatBytes = [\n', '        //physical\n', '        112, //strength\n', '        117, //agility\n', '        122, //speed\n', '        127, //intellect\n', '        132 //charisma\n', '        ];\n', '        uint8[10] memory rarity1Bytes = [\n', '        //rarity old\n', '        13, //body-form\n', '        18, //wings-form\n', '        23, //hoofs-form\n', '        28, //horn-form\n', '        33, //eyes-form\n', '        38, //hair-form\n', '        43, //tail-form\n', '        48, //stone-form\n', '        53, //ears-form\n', '        58 //head-form\n', '        ];\n', '        uint8[10] memory rarity2Bytes = [\n', '        //rarity new\n', '        87, //body-form\n', '        92, //wings-form\n', '        97, //hoofs-form\n', '        102, //horn-form\n', '        107, //eyes-form\n', '        137, //hair-form\n', '        142, //tail-form\n', '        147, //stone-form\n', '        152, //ears-form\n', '        157 //head-form\n', '        ];\n', '\n', '        uint sum = 0;\n', '        uint i;\n', '        for(i = 0; i < 5; i++) {\n', '            sum += unicornToken.getUnicornGenByte(_unicornId, physStatBytes[i]);\n', '        }\n', '\n', '        for(i = 0; i < 10; i++) {\n', '            //get v.2 rarity\n', '            uint rarity = unicornToken.getUnicornGenByte(_unicornId, rarity2Bytes[i]);\n', '            if (rarity == 0) {\n', '                //get v.1 rarity\n', '                rarity = _getRarity(unicornToken.getUnicornGenByte(_unicornId, rarity1Bytes[i]));\n', '            }\n', '            sum += rarity;\n', '        }\n', '        return sum * 1 hours;\n', '    }\n', '\n', '    function isUnfreezed(uint _unicornId) public view returns (bool) {\n', '        return unicornToken.isUnfreezed(_unicornId) && breedingDB.freezeEndTime(_unicornId) <= now;\n', '    }\n', '\n', '    function enableFreezePriceRateRecalc(uint _unicornId) onlyGeneLab external {\n', '        breedingDB.setFreezeMustCalculate(_unicornId, true);\n', '    }\n', '\n', '    /*\n', '       (сумма генов + количество часов заморозки)/количество часов заморозки = стоимость снятия 1го часа заморозки в MegaCandy\n', '    */\n', '    function getUnfreezingPrice(uint _unicornId) public view returns (uint) {\n', '        uint32 freezeHours = freezing[breedingDB.freezeIndex(_unicornId)];\n', '        return unicornManagement.subFreezingPrice()\n', '        .mul(breedingDB.freezeStatsSumHours(_unicornId).add(freezeHours))\n', '        .div(freezeHours);\n', '    }\n', '\n', '    function _getFreezeTime(uint freezingIndex) internal view returns (uint time) {\n', '        time = freezing[freezingIndex];\n', '        if (freezingPlusCount[freezingIndex] != 0) {\n', '            time += (uint(block.blockhash(block.number - 1)) % freezingPlusCount[freezingIndex]) * 1 hours;\n', '        }\n', '    }\n', '\n', '    //change freezing time for megacandy\n', '    function minusFreezingTime(uint _unicornId, uint _count) public {\n', '        uint price = getUnfreezingPrice(_unicornId);\n', '        require(megaCandyToken.burn(msg.sender, price.mul(_count)));\n', '        //не минусуем на уже размороженных конях\n', '        require(breedingDB.freezeEndTime(_unicornId) > now);\n', '        //не используем safeMath, т.к. subFreezingTime в теории не должен быть больше now %)\n', '        breedingDB.minusFreezeEndTime(_unicornId, uint(unicornManagement.subFreezingTime()).mul(_count));\n', '        emit MinusFreezingTime(_unicornId,_count);\n', '    }\n', '\n', '    function getHybridizationPrice(uint _unicornId) public view returns (uint) {\n', '        return unicornManagement.getHybridizationFullPrice(breedingDB.hybridizationPrice(_unicornId));\n', '    }\n', '\n', '    function getEtherFeeForPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.oraclizeFee();\n', '    }\n', '\n', '    function getCreateUnicornPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPriceInCandy();\n', '    }\n', '\n', '    function getCreateUnicornPrice() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPrice();\n', '    }\n', '\n', '    function setGen0Limit() external onlyCommunity {\n', '        require(breedingDB.gen0Count() == breedingDB.gen0Limit());\n', '        breedingDB.incGen0Limit();\n', '        emit NewGen0Limit(breedingDB.gen0Limit());\n', '    }\n', '\n', '    function setSelfHybridizationPrice(uint _percentCandy) public onlyManager {\n', '        selfHybridizationPrice = _percentCandy;\n', '        emit NewSelfHybridizationPrice(_percentCandy);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract UnicornMarket is UnicornBreeding {\n', '    uint public sellDividendPercentCandy = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercentEth = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '\n', '    event NewSellDividendPercent(uint percentCandy, uint percentCandyEth);\n', '    event OfferAdd(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event OfferDelete(uint256 indexed unicornId);\n', '    event UnicornSold(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event FreeOffer(uint256 indexed unicornId);\n', '\n', '\n', '    function sellUnicorn(uint _unicornId, uint _priceEth, uint _priceCandy) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(!breedingDB.offerExists(_unicornId));\n', '\n', '        breedingDB.createOffer(_unicornId, _priceEth, _priceCandy);\n', '\n', '        emit OfferAdd(_unicornId, _priceEth, _priceCandy);\n', '        //налетай)\n', '        if (_priceEth == 0 && _priceCandy == 0) {\n', '            emit FreeOffer(_unicornId);\n', '        }\n', '    }\n', '\n', '    function buyUnicornWithEth(uint _unicornId) whenNotPaused public payable {\n', '        require(breedingDB.offerExists(_unicornId));\n', '        uint price = breedingDB.offerPriceEth(_unicornId);\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(breedingDB.offerPriceCandy(_unicornId) == 0);\n', '        }\n', '        require(msg.value == getOfferPriceEth(_unicornId));\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        emit UnicornSold(_unicornId, price, 0);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '        owner.transfer(price);\n', '    }\n', '\n', '    function buyUnicornWithCandy(uint _unicornId) whenNotPaused public {\n', '        require(breedingDB.offerExists(_unicornId));\n', '        uint price = breedingDB.offerPriceCandy(_unicornId);\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(breedingDB.offerPriceEth(_unicornId) == 0);\n', '        }\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        if (price > 0) {\n', '            uint fullPrice = getOfferPriceCandy(_unicornId);\n', '            require(balances.transferWithFee(candyTokenAddress, msg.sender, fullPrice, balances, owner, price));\n', '        }\n', '\n', '        emit UnicornSold(_unicornId, 0, price);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '    }\n', '\n', '\n', '    function revokeUnicorn(uint _unicornId) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        //require(breedingDB.offerExists(_unicornId));\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function deleteOffer(uint _unicornId) onlyUnicornToken external {\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function _deleteOffer(uint _unicornId) internal {\n', '        if (breedingDB.offerExists(_unicornId)) {\n', '            breedingDB.deleteOffer(_unicornId);\n', '            emit OfferDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '\n', '    function getOfferPriceEth(uint _unicornId) public view returns (uint) {\n', '        uint priceEth = breedingDB.offerPriceEth(_unicornId);\n', '        return priceEth.add(valueFromPercent(priceEth, sellDividendPercentEth));\n', '    }\n', '\n', '\n', '    function getOfferPriceCandy(uint _unicornId) public view returns (uint) {\n', '        uint priceCandy = breedingDB.offerPriceCandy(_unicornId);\n', '        return priceCandy.add(valueFromPercent(priceCandy, sellDividendPercentCandy));\n', '    }\n', '\n', '\n', '    function setSellDividendPercent(uint _percentCandy, uint _percentEth) public onlyManager {\n', '        //no more then 25%\n', '        require(_percentCandy < 2500 && _percentEth < 2500);\n', '\n', '        sellDividendPercentCandy = _percentCandy;\n', '        sellDividendPercentEth = _percentEth;\n', '        emit NewSellDividendPercent(_percentCandy, _percentEth);\n', '    }\n', '\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '}\n', '\n', '\n', 'contract UnicornCoinMarket is UnicornMarket {\n', '    uint public feeTake = 5000000000000000; // 0.5% percentage times (1 ether)\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '    mapping (address => bool) public tokensWithoutFee;\n', '\n', '    /// Logging Events\n', '    event Trade(bytes32 indexed hash, address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '\n', '\n', '    /// Changes the fee on takes.\n', '    function changeFeeTake(uint feeTake_) external onlyOwner {\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '\n', '    function setTokenWithoutFee(address _token, bool _takeFee) external onlyOwner {\n', '        tokensWithoutFee[_token] = _takeFee;\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    // Trading\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    /**\n', '    * Facilitates a trade from one user to another.\n', '    * Requires that the transaction is signed properly, the trade isn&#39;t past its expiration, and all funds are present to fill the trade.\n', '    * Calls tradeBalances().\n', '    * Updates orderFills with the amount traded.\n', '    * Emits a Trade event.\n', '    * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '    * Note: amount is in amountGet / tokenGet terms.\n', '    * @param tokenGet Ethereum contract address of the token to receive\n', '    * @param amountGet uint amount of tokens being received\n', '    * @param tokenGive Ethereum contract address of the token to give\n', '    * @param amountGive uint amount of tokens being given\n', '    * @param expires uint of block number when this order should expire\n', '    * @param nonce arbitrary random number\n', '    * @param user Ethereum address of the user who placed the order\n', '    * @param v part of signature for the order hash as signed by user\n', '    * @param r part of signature for the order hash as signed by user\n', '    * @param s part of signature for the order hash as signed by user\n', '    * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '    */\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) external {\n', '        bytes32 hash = sha256(balances, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require(\n', '            ecrecover(keccak256(keccak256("bytes32 Order hash"), keccak256(hash)), v, r, s) == user &&\n', '            block.number <= expires &&\n', '            orderFills[user][hash].add(amount) <= amountGet\n', '        );\n', '        uint amount2 =  tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = orderFills[user][hash].add(amount);\n', '        emit Trade(hash, tokenGet, amount, tokenGive, amount2, user, msg.sender);\n', '    }\n', '\n', '    /**\n', '    * This is a private function and is only being called from trade().\n', '    * Handles the movement of funds when a trade occurs.\n', '    * Takes fees.\n', '    * Updates token balances for both buyer and seller.\n', '    * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '    * Note: amount is in amountGet / tokenGet terms.\n', '    * @param tokenGet Ethereum contract address of the token to receive\n', '    * @param amountGet uint amount of tokens being received\n', '    * @param tokenGive Ethereum contract address of the token to give\n', '    * @param amountGive uint amount of tokens being given\n', '    * @param user Ethereum address of the user who placed the order\n', '    * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '    */\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private returns(uint amount2){\n', '\n', '        uint _fee = 0;\n', '\n', '        if (!tokensWithoutFee[tokenGet]) {\n', '            _fee = amount.mul(feeTake).div(1 ether);\n', '        }\n', '\n', '\n', '        if (balances.trustedTokens(tokenGet)) {\n', '            TrustedTokenInterface t = TrustedTokenInterface(tokenGet);\n', '            require(t.transferFromSystem(msg.sender, user, amount));\n', '            require(t.transferFromSystem(msg.sender, this, _fee));\n', '        } else {\n', '            require(\n', '                balances.transferWithFee(tokenGet, msg.sender, amount, balances, user, amount.sub(_fee))\n', '            );\n', '            //            balances.tokenMinus(tokenGet, msg.sender, amount);\n', '            //            balances.tokenPlus(tokenGet, user, amount.sub(_fee));\n', '            //            balances.tokenPlus(tokenGet, this, _fee);\n', '        }\n', '\n', '        amount2 = amountGive.mul(amount).div(amountGet);\n', '        if (balances.trustedTokens(tokenGive)) {\n', '            require(TrustedTokenInterface(tokenGive).transferFromSystem(user, msg.sender, amount2));\n', '        } else {\n', '            require(balances.transfer(tokenGive, user, msg.sender, amount2));\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract UnicornContract is UnicornCoinMarket {\n', '    event FundsTransferred(address dividendManager, uint value);\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    function UnicornContract(address _breedingDB, address _balances, address _unicornManagementAddress) UnicornAccessControl(_unicornManagementAddress) public {\n', '        candyTokenAddress = unicornManagement.candyToken();\n', '        breedingDB = BreedingDataBaseInterface(_breedingDB);\n', '        balances = UnicornBalancesInterface(_balances);\n', '    }\n', '\n', '    function init() onlyManagement whenPaused external {\n', '        unicornToken = UnicornTokenInterface(unicornManagement.unicornTokenAddress());\n', '        blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        megaCandyToken = TrustedTokenInterface(unicornManagement.candyPowerToken());\n', '    }\n', '\n', '\n', '    function transferTokensToDividendManager(address _token) onlyManager public {\n', '        require(ERC20(_token).balanceOf(this) > 0);\n', '        ERC20(_token).transfer(unicornManagement.walletAddress(), ERC20(_token).balanceOf(this));\n', '    }\n', '\n', '\n', '    function transferEthersToDividendManager(uint _value) onlyManager public {\n', '        require(address(this).balance >= _value);\n', '        DividendManagerInterface dividendManager = DividendManagerInterface(unicornManagement.dividendManagerAddress());\n', '        dividendManager.payDividend.value(_value)();\n', '        emit FundsTransferred(unicornManagement.dividendManagerAddress(), _value);\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract UnicornManagementInterface {\n', '\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    function blackBoxAddress() external view returns (address);\n', '    function unicornBreedingAddress() external view returns (address);\n', '    function geneLabAddress() external view returns (address);\n', '    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function candyPowerToken() external view returns (address);\n', '\n', '    function createDividendPercent() external view returns (uint);\n', '    function sellDividendPercent() external view returns (uint);\n', '    function subFreezingPrice() external view returns (uint);\n', '    function subFreezingTime() external view returns (uint64);\n', '    function subTourFreezingPrice() external view returns (uint);\n', '    function subTourFreezingTime() external view returns (uint64);\n', '    function createUnicornPrice() external view returns (uint);\n', '    function createUnicornPriceInCandy() external view returns (uint);\n', '    function oraclizeFee() external view returns (uint);\n', '\n', '    function paused() external view returns (bool);\n', '    function locked() external view returns (bool);\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool);\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint);\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint);\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint);\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint);\n', '\n', '\n', '    //service\n', '    function registerInit(address _contract) external;\n', '\n', '}\n', '\n', 'contract UnicornAccessControl {\n', '\n', '    UnicornManagementInterface public unicornManagement;\n', '\n', '\n', '    function UnicornAccessControl(address _unicornManagementAddress) public {\n', '        unicornManagement = UnicornManagementInterface(_unicornManagementAddress);\n', '        unicornManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == unicornManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == unicornManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == unicornManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyTournament() {\n', '        require(unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '//    modifier whenUnlocked() {\n', '//        require(!unicornManagement.locked());\n', '//        _;\n', '//    }\n', '\n', '    modifier onlyManagement() {\n', '        require(msg.sender == address(unicornManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyBreeding() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornContract() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress() || unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyGeneLab() {\n', '        require(msg.sender == unicornManagement.geneLabAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyBlackBox() {\n', '        require(msg.sender == unicornManagement.blackBoxAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornToken() {\n', '        require(msg.sender == unicornManagement.unicornTokenAddress());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return unicornManagement.paused();\n', '    }\n', '}\n', '\n', 'contract DividendManagerInterface {\n', '    function payDividend() external payable;\n', '}\n', '\n', 'contract UnicornTokenInterface {\n', '\n', '    //ERC721\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _unicornId) public view returns (address _owner);\n', '    function transfer(address _to, uint256 _unicornId) public;\n', '    function approve(address _to, uint256 _unicornId) public;\n', '    function takeOwnership(uint256 _unicornId) public;\n', '    function totalSupply() public constant returns (uint);\n', '    function owns(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function allowance(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _unicornId) public;\n', '    function createUnicorn(address _owner) external returns (uint);\n', '    //    function burnUnicorn(uint256 _unicornId) external;\n', '    function getGen(uint _unicornId) external view returns (bytes);\n', '    function setGene(uint _unicornId, bytes _gene) external;\n', '    function updateGene(uint _unicornId, bytes _gene) external;\n', '    function getUnicornGenByte(uint _unicornId, uint _byteNo) external view returns (uint8);\n', '\n', '    function setName(uint256 _unicornId, string _name ) external returns (bool);\n', '    function plusFreezingTime(uint _unicornId) external;\n', '    function plusTourFreezingTime(uint _unicornId) external;\n', '    function minusFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function minusTourFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function isUnfreezed(uint _unicornId) external view returns (bool);\n', '    function isTourUnfreezed(uint _unicornId) external view returns (bool);\n', '\n', '    function marketTransfer(address _from, address _to, uint256 _unicornId) external;\n', '}\n', '\n', '\n', 'interface UnicornBalancesInterface {\n', '    //    function tokenPlus(address _token, address _user, uint _value) external returns (bool);\n', '    //    function tokenMinus(address _token, address _user, uint _value) external returns (bool);\n', '    function trustedTokens(address _token) external view returns (bool);\n', '    //    function balanceOf(address token, address user) external view returns (uint);\n', '    function transfer(address _token, address _from, address _to, uint _value) external returns (bool);\n', '    function transferWithFee(address _token, address _userFrom, uint _fullPrice, address _feeTaker, address _priceTaker, uint _price) external returns (bool);\n', '}\n', '\n', 'contract ERC20 {\n', '    //    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract TrustedTokenInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', '\n', '// contract UnicornBreedingInterface {\n', '//     function deleteOffer(uint _unicornId) external;\n', '//     function deleteHybridization(uint _unicornId) external;\n', '// }\n', '\n', 'contract BlackBoxInterface {\n', '    function createGen0(uint _unicornId) public payable;\n', '    function geneCore(uint _childUnicornId, uint _parent1UnicornId, uint _parent2UnicornId) public payable;\n', '}\n', '\n', '\n', 'interface BreedingDataBaseInterface {\n', '\n', '    function gen0Limit() external view returns (uint);\n', '    function gen0Count() external view returns (uint);\n', '    function gen0Step() external view returns (uint);\n', '\n', '    function gen0PresaleLimit() external view returns (uint);\n', '    function gen0PresaleCount() external view returns (uint);\n', '\n', '    function incGen0Count() external;\n', '    function incGen0PresaleCount() external;\n', '    function incGen0Limit() external;\n', '\n', '    function createHybridization(uint _unicornId, uint _price) external;\n', '    function hybridizationExists(uint _unicornId) external view returns (bool);\n', '    function hybridizationPrice(uint _unicornId) external view returns (uint);\n', '    function deleteHybridization(uint _unicornId) external returns (bool);\n', '\n', '    function freezeIndex(uint _unicornId) external view returns (uint);\n', '    function freezeHybridizationsCount(uint _unicornId) external view returns (uint);\n', '    function freezeStatsSumHours(uint _unicornId) external view returns (uint);\n', '    function freezeEndTime(uint _unicornId) external view returns (uint);\n', '    function freezeMustCalculate(uint _unicornId) external view returns (bool);\n', '    function freezeExists(uint _unicornId) external view returns (bool);\n', '\n', '    function createFreeze(uint _unicornId, uint _index) external;\n', '    function incFreezeHybridizationsCount(uint _unicornId) external;\n', '    function setFreezeHybridizationsCount(uint _unicornId, uint _count) external;\n', '\n', '    function incFreezeIndex(uint _unicornId) external;\n', '    function setFreezeEndTime(uint _unicornId, uint _time) external;\n', '    function minusFreezeEndTime(uint _unicornId, uint _time) external;\n', '    function setFreezeMustCalculate(uint _unicornId, bool _mustCalculate) external;\n', '    function setStatsSumHours(uint _unicornId, uint _statsSumHours) external;\n', '\n', '\n', '    function offerExists(uint _unicornId) external view returns (bool);\n', '    function offerPriceEth(uint _unicornId) external view returns (uint);\n', '    function offerPriceCandy(uint _unicornId) external view returns (uint);\n', '\n', '    function createOffer(uint _unicornId, uint _priceEth, uint _priceCandy) external;\n', '    function deleteOffer(uint _unicornId) external;\n', '\n', '}\n', '\n', 'contract UnicornBreeding is UnicornAccessControl {\n', '    using SafeMath for uint;\n', '\n', '    BlackBoxInterface public blackBox;\n', '    TrustedTokenInterface public megaCandyToken;\n', '    BreedingDataBaseInterface public breedingDB;\n', '    UnicornTokenInterface public unicornToken; //only on deploy\n', '    UnicornBalancesInterface public balances;\n', '\n', '    address public candyTokenAddress;\n', '\n', '    event HybridizationAdd(uint indexed unicornId, uint price);\n', '    event HybridizationAccept(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId, uint price);\n', '    event SelfHybridization(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId, uint price);\n', '    event HybridizationDelete(uint indexed unicornId);\n', '    event CreateUnicorn(address indexed owner, uint indexed unicornId, uint parent1, uint  parent2);\n', '    event NewGen0Limit(uint limit);\n', '    event NewGen0Step(uint step);\n', '\n', '    event FreeHybridization(uint256 indexed unicornId);\n', '    event NewSelfHybridizationPrice(uint percentCandy);\n', '\n', '    event UnicornFreezingTimeSet(uint indexed unicornId, uint time);\n', '    event MinusFreezingTime(uint indexed unicornId, uint count);\n', '\n', '    uint public selfHybridizationPrice = 0;\n', '\n', '    uint32[8] internal freezing = [\n', '    uint32(1 hours),    //1 hour\n', '    uint32(2 hours),    //2 - 4 hours\n', '    uint32(8 hours),    //8 - 12 hours\n', '    uint32(16 hours),   //16 - 24 hours\n', '    uint32(36 hours),   //36 - 48 hours\n', '    uint32(72 hours),   //72 - 96 hours\n', '    uint32(120 hours),  //120 - 144 hours\n', '    uint32(168 hours)   //168 hours\n', '    ];\n', '\n', '    //count for random plus from 0 to ..\n', '    uint32[8] internal freezingPlusCount = [\n', '    0, 3, 5, 9, 13, 25, 25, 0\n', '    ];\n', '\n', '\n', '    function makeHybridization(uint _unicornId, uint _price) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(isUnfreezed(_unicornId));\n', '        require(!breedingDB.hybridizationExists(_unicornId));\n', '        require(unicornToken.getUnicornGenByte(_unicornId, 10) > 0);\n', '\n', '        checkFreeze(_unicornId);\n', '        breedingDB.createHybridization(_unicornId, _price);\n', '        emit HybridizationAdd(_unicornId, _price);\n', '        //свободная касса)\n', '        if (_price == 0) {\n', '            emit FreeHybridization(_unicornId);\n', '        }\n', '    }\n', '\n', '    function acceptHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(isUnfreezed(_firstUnicornId) && isUnfreezed(_secondUnicornId));\n', '        require(breedingDB.hybridizationExists(_firstUnicornId));\n', '\n', '        require(unicornToken.getUnicornGenByte(_firstUnicornId, 10) > 0 && unicornToken.getUnicornGenByte(_secondUnicornId, 10) > 0);\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '\n', '        uint price = breedingDB.hybridizationPrice(_firstUnicornId);\n', '\n', '        if (price > 0) {\n', '            uint fullPrice = unicornManagement.getHybridizationFullPrice(price);\n', '\n', '            require(balances.transferWithFee(candyTokenAddress, msg.sender, fullPrice, balances, unicornToken.ownerOf(_firstUnicornId), price));\n', '\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '\n', '        emit HybridizationAccept(_firstUnicornId, _secondUnicornId, newUnicornId, price);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        _deleteHybridization(_firstUnicornId);\n', '    }\n', '\n', '    function selfHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _firstUnicornId) && unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(isUnfreezed(_firstUnicornId) && isUnfreezed(_secondUnicornId));\n', '        require(unicornToken.getUnicornGenByte(_firstUnicornId, 10) > 0 && unicornToken.getUnicornGenByte(_secondUnicornId, 10) > 0);\n', '\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '\n', '        if (selfHybridizationPrice > 0) {\n', '            //            require(balances.balanceOf(candyTokenAddress,msg.sender) >= selfHybridizationPrice);\n', '            require(balances.transfer(candyTokenAddress, msg.sender, balances, selfHybridizationPrice));\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        emit SelfHybridization(_firstUnicornId, _secondUnicornId, newUnicornId, selfHybridizationPrice);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '    }\n', '\n', '    function cancelHybridization (uint _unicornId) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender,_unicornId));\n', '        //require(breedingDB.hybridizationExists(_unicornId));\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function deleteHybridization(uint _unicornId) onlyUnicornToken external {\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function _deleteHybridization(uint _unicornId) internal {\n', '        if (breedingDB.deleteHybridization(_unicornId)) {\n', '            emit HybridizationDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '    //Create new 0 gen\n', '    function createUnicorn() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == getCreateUnicornPrice());\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createUnicornForCandy() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        uint price = getCreateUnicornPriceInCandy();\n', '        //        require(balances.balanceOf(candyTokenAddress,msg.sender) >= price);\n', '        require(balances.transfer(candyTokenAddress, msg.sender, balances, price));\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createPresaleUnicorns(uint _count, address _owner) public payable onlyManager whenPaused returns(bool) {\n', '        require(breedingDB.gen0PresaleCount().add(_count) <= breedingDB.gen0PresaleLimit());\n', '        uint256 newUnicornId;\n', '        address owner = _owner == address(0) ? msg.sender : _owner;\n', '        for (uint i = 0; i < _count; i++){\n', '            newUnicornId = unicornToken.createUnicorn(owner);\n', '            blackBox.createGen0(newUnicornId);\n', '            emit CreateUnicorn(owner, newUnicornId, 0, 0);\n', '            breedingDB.incGen0Count();\n', '            breedingDB.incGen0PresaleCount();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _createUnicorn(address _owner) private returns(uint256) {\n', '        require(breedingDB.gen0Count() < breedingDB.gen0Limit());\n', '        uint256 newUnicornId = unicornToken.createUnicorn(_owner);\n', '        blackBox.createGen0.value(unicornManagement.oraclizeFee())(newUnicornId);\n', '        emit CreateUnicorn(_owner, newUnicornId, 0, 0);\n', '        breedingDB.incGen0Count();\n', '        return newUnicornId;\n', '    }\n', '\n', '    function plusFreezingTime(uint _unicornId) private {\n', '        checkFreeze(_unicornId);\n', '        //если меньше 3 спарок увеличиваю просто спарки, если 3 тогда увеличиваю индекс\n', '        if (breedingDB.freezeHybridizationsCount(_unicornId) < 3) {\n', '            breedingDB.incFreezeHybridizationsCount(_unicornId);\n', '        } else {\n', '            if (breedingDB.freezeIndex(_unicornId) < freezing.length - 1) {\n', '                breedingDB.incFreezeIndex(_unicornId);\n', '                breedingDB.setFreezeHybridizationsCount(_unicornId,0);\n', '            }\n', '        }\n', '\n', '        uint _time = _getFreezeTime(breedingDB.freezeIndex(_unicornId)) + now;\n', '        breedingDB.setFreezeEndTime(_unicornId, _time);\n', '        emit UnicornFreezingTimeSet(_unicornId, _time);\n', '    }\n', '\n', '    function checkFreeze(uint _unicornId) internal {\n', '        if (!breedingDB.freezeExists(_unicornId)) {\n', '            breedingDB.createFreeze(_unicornId, unicornToken.getUnicornGenByte(_unicornId, 163));\n', '        }\n', '        if (breedingDB.freezeMustCalculate(_unicornId)) {\n', '            breedingDB.setFreezeMustCalculate(_unicornId, false);\n', '            breedingDB.setStatsSumHours(_unicornId, _getStatsSumHours(_unicornId));\n', '        }\n', '    }\n', '\n', '    function _getRarity(uint8 _b) internal pure returns (uint8) {\n', '        //        [1; 188] common\n', '        //        [189; 223] uncommon\n', '        //        [224; 243] rare\n', '        //        [244; 253] epic\n', '        //        [254; 255] legendary\n', '        return _b < 1 ? 0 : _b < 189 ? 1 : _b < 224 ? 2 : _b < 244 ? 3 : _b < 254 ? 4 : 5;\n', '    }\n', '\n', '    function _getStatsSumHours(uint _unicornId) internal view returns (uint) {\n', '        uint8[5] memory physStatBytes = [\n', '        //physical\n', '        112, //strength\n', '        117, //agility\n', '        122, //speed\n', '        127, //intellect\n', '        132 //charisma\n', '        ];\n', '        uint8[10] memory rarity1Bytes = [\n', '        //rarity old\n', '        13, //body-form\n', '        18, //wings-form\n', '        23, //hoofs-form\n', '        28, //horn-form\n', '        33, //eyes-form\n', '        38, //hair-form\n', '        43, //tail-form\n', '        48, //stone-form\n', '        53, //ears-form\n', '        58 //head-form\n', '        ];\n', '        uint8[10] memory rarity2Bytes = [\n', '        //rarity new\n', '        87, //body-form\n', '        92, //wings-form\n', '        97, //hoofs-form\n', '        102, //horn-form\n', '        107, //eyes-form\n', '        137, //hair-form\n', '        142, //tail-form\n', '        147, //stone-form\n', '        152, //ears-form\n', '        157 //head-form\n', '        ];\n', '\n', '        uint sum = 0;\n', '        uint i;\n', '        for(i = 0; i < 5; i++) {\n', '            sum += unicornToken.getUnicornGenByte(_unicornId, physStatBytes[i]);\n', '        }\n', '\n', '        for(i = 0; i < 10; i++) {\n', '            //get v.2 rarity\n', '            uint rarity = unicornToken.getUnicornGenByte(_unicornId, rarity2Bytes[i]);\n', '            if (rarity == 0) {\n', '                //get v.1 rarity\n', '                rarity = _getRarity(unicornToken.getUnicornGenByte(_unicornId, rarity1Bytes[i]));\n', '            }\n', '            sum += rarity;\n', '        }\n', '        return sum * 1 hours;\n', '    }\n', '\n', '    function isUnfreezed(uint _unicornId) public view returns (bool) {\n', '        return unicornToken.isUnfreezed(_unicornId) && breedingDB.freezeEndTime(_unicornId) <= now;\n', '    }\n', '\n', '    function enableFreezePriceRateRecalc(uint _unicornId) onlyGeneLab external {\n', '        breedingDB.setFreezeMustCalculate(_unicornId, true);\n', '    }\n', '\n', '    /*\n', '       (сумма генов + количество часов заморозки)/количество часов заморозки = стоимость снятия 1го часа заморозки в MegaCandy\n', '    */\n', '    function getUnfreezingPrice(uint _unicornId) public view returns (uint) {\n', '        uint32 freezeHours = freezing[breedingDB.freezeIndex(_unicornId)];\n', '        return unicornManagement.subFreezingPrice()\n', '        .mul(breedingDB.freezeStatsSumHours(_unicornId).add(freezeHours))\n', '        .div(freezeHours);\n', '    }\n', '\n', '    function _getFreezeTime(uint freezingIndex) internal view returns (uint time) {\n', '        time = freezing[freezingIndex];\n', '        if (freezingPlusCount[freezingIndex] != 0) {\n', '            time += (uint(block.blockhash(block.number - 1)) % freezingPlusCount[freezingIndex]) * 1 hours;\n', '        }\n', '    }\n', '\n', '    //change freezing time for megacandy\n', '    function minusFreezingTime(uint _unicornId, uint _count) public {\n', '        uint price = getUnfreezingPrice(_unicornId);\n', '        require(megaCandyToken.burn(msg.sender, price.mul(_count)));\n', '        //не минусуем на уже размороженных конях\n', '        require(breedingDB.freezeEndTime(_unicornId) > now);\n', '        //не используем safeMath, т.к. subFreezingTime в теории не должен быть больше now %)\n', '        breedingDB.minusFreezeEndTime(_unicornId, uint(unicornManagement.subFreezingTime()).mul(_count));\n', '        emit MinusFreezingTime(_unicornId,_count);\n', '    }\n', '\n', '    function getHybridizationPrice(uint _unicornId) public view returns (uint) {\n', '        return unicornManagement.getHybridizationFullPrice(breedingDB.hybridizationPrice(_unicornId));\n', '    }\n', '\n', '    function getEtherFeeForPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.oraclizeFee();\n', '    }\n', '\n', '    function getCreateUnicornPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPriceInCandy();\n', '    }\n', '\n', '    function getCreateUnicornPrice() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPrice();\n', '    }\n', '\n', '    function setGen0Limit() external onlyCommunity {\n', '        require(breedingDB.gen0Count() == breedingDB.gen0Limit());\n', '        breedingDB.incGen0Limit();\n', '        emit NewGen0Limit(breedingDB.gen0Limit());\n', '    }\n', '\n', '    function setSelfHybridizationPrice(uint _percentCandy) public onlyManager {\n', '        selfHybridizationPrice = _percentCandy;\n', '        emit NewSelfHybridizationPrice(_percentCandy);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract UnicornMarket is UnicornBreeding {\n', '    uint public sellDividendPercentCandy = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercentEth = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '\n', '    event NewSellDividendPercent(uint percentCandy, uint percentCandyEth);\n', '    event OfferAdd(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event OfferDelete(uint256 indexed unicornId);\n', '    event UnicornSold(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event FreeOffer(uint256 indexed unicornId);\n', '\n', '\n', '    function sellUnicorn(uint _unicornId, uint _priceEth, uint _priceCandy) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(!breedingDB.offerExists(_unicornId));\n', '\n', '        breedingDB.createOffer(_unicornId, _priceEth, _priceCandy);\n', '\n', '        emit OfferAdd(_unicornId, _priceEth, _priceCandy);\n', '        //налетай)\n', '        if (_priceEth == 0 && _priceCandy == 0) {\n', '            emit FreeOffer(_unicornId);\n', '        }\n', '    }\n', '\n', '    function buyUnicornWithEth(uint _unicornId) whenNotPaused public payable {\n', '        require(breedingDB.offerExists(_unicornId));\n', '        uint price = breedingDB.offerPriceEth(_unicornId);\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(breedingDB.offerPriceCandy(_unicornId) == 0);\n', '        }\n', '        require(msg.value == getOfferPriceEth(_unicornId));\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        emit UnicornSold(_unicornId, price, 0);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '        owner.transfer(price);\n', '    }\n', '\n', '    function buyUnicornWithCandy(uint _unicornId) whenNotPaused public {\n', '        require(breedingDB.offerExists(_unicornId));\n', '        uint price = breedingDB.offerPriceCandy(_unicornId);\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(breedingDB.offerPriceEth(_unicornId) == 0);\n', '        }\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        if (price > 0) {\n', '            uint fullPrice = getOfferPriceCandy(_unicornId);\n', '            require(balances.transferWithFee(candyTokenAddress, msg.sender, fullPrice, balances, owner, price));\n', '        }\n', '\n', '        emit UnicornSold(_unicornId, 0, price);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '    }\n', '\n', '\n', '    function revokeUnicorn(uint _unicornId) whenNotPaused public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        //require(breedingDB.offerExists(_unicornId));\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function deleteOffer(uint _unicornId) onlyUnicornToken external {\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function _deleteOffer(uint _unicornId) internal {\n', '        if (breedingDB.offerExists(_unicornId)) {\n', '            breedingDB.deleteOffer(_unicornId);\n', '            emit OfferDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '\n', '    function getOfferPriceEth(uint _unicornId) public view returns (uint) {\n', '        uint priceEth = breedingDB.offerPriceEth(_unicornId);\n', '        return priceEth.add(valueFromPercent(priceEth, sellDividendPercentEth));\n', '    }\n', '\n', '\n', '    function getOfferPriceCandy(uint _unicornId) public view returns (uint) {\n', '        uint priceCandy = breedingDB.offerPriceCandy(_unicornId);\n', '        return priceCandy.add(valueFromPercent(priceCandy, sellDividendPercentCandy));\n', '    }\n', '\n', '\n', '    function setSellDividendPercent(uint _percentCandy, uint _percentEth) public onlyManager {\n', '        //no more then 25%\n', '        require(_percentCandy < 2500 && _percentEth < 2500);\n', '\n', '        sellDividendPercentCandy = _percentCandy;\n', '        sellDividendPercentEth = _percentEth;\n', '        emit NewSellDividendPercent(_percentCandy, _percentEth);\n', '    }\n', '\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '}\n', '\n', '\n', 'contract UnicornCoinMarket is UnicornMarket {\n', '    uint public feeTake = 5000000000000000; // 0.5% percentage times (1 ether)\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '    mapping (address => bool) public tokensWithoutFee;\n', '\n', '    /// Logging Events\n', '    event Trade(bytes32 indexed hash, address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '\n', '\n', '    /// Changes the fee on takes.\n', '    function changeFeeTake(uint feeTake_) external onlyOwner {\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '\n', '    function setTokenWithoutFee(address _token, bool _takeFee) external onlyOwner {\n', '        tokensWithoutFee[_token] = _takeFee;\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    // Trading\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    /**\n', '    * Facilitates a trade from one user to another.\n', "    * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\n", '    * Calls tradeBalances().\n', '    * Updates orderFills with the amount traded.\n', '    * Emits a Trade event.\n', '    * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '    * Note: amount is in amountGet / tokenGet terms.\n', '    * @param tokenGet Ethereum contract address of the token to receive\n', '    * @param amountGet uint amount of tokens being received\n', '    * @param tokenGive Ethereum contract address of the token to give\n', '    * @param amountGive uint amount of tokens being given\n', '    * @param expires uint of block number when this order should expire\n', '    * @param nonce arbitrary random number\n', '    * @param user Ethereum address of the user who placed the order\n', '    * @param v part of signature for the order hash as signed by user\n', '    * @param r part of signature for the order hash as signed by user\n', '    * @param s part of signature for the order hash as signed by user\n', '    * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '    */\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) external {\n', '        bytes32 hash = sha256(balances, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require(\n', '            ecrecover(keccak256(keccak256("bytes32 Order hash"), keccak256(hash)), v, r, s) == user &&\n', '            block.number <= expires &&\n', '            orderFills[user][hash].add(amount) <= amountGet\n', '        );\n', '        uint amount2 =  tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = orderFills[user][hash].add(amount);\n', '        emit Trade(hash, tokenGet, amount, tokenGive, amount2, user, msg.sender);\n', '    }\n', '\n', '    /**\n', '    * This is a private function and is only being called from trade().\n', '    * Handles the movement of funds when a trade occurs.\n', '    * Takes fees.\n', '    * Updates token balances for both buyer and seller.\n', '    * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '    * Note: amount is in amountGet / tokenGet terms.\n', '    * @param tokenGet Ethereum contract address of the token to receive\n', '    * @param amountGet uint amount of tokens being received\n', '    * @param tokenGive Ethereum contract address of the token to give\n', '    * @param amountGive uint amount of tokens being given\n', '    * @param user Ethereum address of the user who placed the order\n', '    * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '    */\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private returns(uint amount2){\n', '\n', '        uint _fee = 0;\n', '\n', '        if (!tokensWithoutFee[tokenGet]) {\n', '            _fee = amount.mul(feeTake).div(1 ether);\n', '        }\n', '\n', '\n', '        if (balances.trustedTokens(tokenGet)) {\n', '            TrustedTokenInterface t = TrustedTokenInterface(tokenGet);\n', '            require(t.transferFromSystem(msg.sender, user, amount));\n', '            require(t.transferFromSystem(msg.sender, this, _fee));\n', '        } else {\n', '            require(\n', '                balances.transferWithFee(tokenGet, msg.sender, amount, balances, user, amount.sub(_fee))\n', '            );\n', '            //            balances.tokenMinus(tokenGet, msg.sender, amount);\n', '            //            balances.tokenPlus(tokenGet, user, amount.sub(_fee));\n', '            //            balances.tokenPlus(tokenGet, this, _fee);\n', '        }\n', '\n', '        amount2 = amountGive.mul(amount).div(amountGet);\n', '        if (balances.trustedTokens(tokenGive)) {\n', '            require(TrustedTokenInterface(tokenGive).transferFromSystem(user, msg.sender, amount2));\n', '        } else {\n', '            require(balances.transfer(tokenGive, user, msg.sender, amount2));\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract UnicornContract is UnicornCoinMarket {\n', '    event FundsTransferred(address dividendManager, uint value);\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    function UnicornContract(address _breedingDB, address _balances, address _unicornManagementAddress) UnicornAccessControl(_unicornManagementAddress) public {\n', '        candyTokenAddress = unicornManagement.candyToken();\n', '        breedingDB = BreedingDataBaseInterface(_breedingDB);\n', '        balances = UnicornBalancesInterface(_balances);\n', '    }\n', '\n', '    function init() onlyManagement whenPaused external {\n', '        unicornToken = UnicornTokenInterface(unicornManagement.unicornTokenAddress());\n', '        blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        megaCandyToken = TrustedTokenInterface(unicornManagement.candyPowerToken());\n', '    }\n', '\n', '\n', '    function transferTokensToDividendManager(address _token) onlyManager public {\n', '        require(ERC20(_token).balanceOf(this) > 0);\n', '        ERC20(_token).transfer(unicornManagement.walletAddress(), ERC20(_token).balanceOf(this));\n', '    }\n', '\n', '\n', '    function transferEthersToDividendManager(uint _value) onlyManager public {\n', '        require(address(this).balance >= _value);\n', '        DividendManagerInterface dividendManager = DividendManagerInterface(unicornManagement.dividendManagerAddress());\n', '        dividendManager.payDividend.value(_value)();\n', '        emit FundsTransferred(unicornManagement.dividendManagerAddress(), _value);\n', '    }\n', '}']
