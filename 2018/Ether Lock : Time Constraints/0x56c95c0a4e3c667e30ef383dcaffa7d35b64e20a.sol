['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface IDonQuixoteToken{                          \n', '    function withhold(address _user,  uint256 _amount) external returns (bool _result);  \n', '    function transfer(address _to, uint256 _value) external;                             \n', '    function sendGameGift(address _player) external returns (bool _result);              \n', '    function logPlaying(address _player) external returns (bool _result);               \n', '    function balanceOf(address _user) constant  external returns (uint256 _balance);\n', '} \n', '\n', 'contract BaseGame {             \n', '    string public gameName="BigOrSmall";         \n', '     uint public constant gameType = 2001;   \n', '    string public officialGameUrl;  \n', '    mapping (address => uint256) public userTokenOf;     \n', '    uint public bankerBeginTime;     \n', '    uint public bankerEndTime;       \n', '    address public currentBanker;      \n', '    \t\n', '    function depositToken(uint256 _amount) public;\n', '    function withdrawToken(uint256 _amount) public;\n', '\tfunction withdrawAllToken() public;\n', '    function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);     \n', '    function canSetBanker() view public returns (bool _result);         \n', '}\n', 'contract Base is BaseGame { \n', '    using SafeMath for uint256;     \n', '    uint public createTime = now;\n', '    address public owner;\n', '\t\n', '    IDonQuixoteToken public DonQuixoteToken;\n', '      function Base() public {\n', '    }\n', '\t\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\t\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '         require(_newOwner!= 0x0);\n', '        owner = _newOwner;\n', '    }\n', '        \n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {             \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }    \n', '  \n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;     \n', '    }\n', '    function tokenOf(address _user) view public returns(uint256 _result){\n', '        _result = DonQuixoteToken.balanceOf(_user);\n', '    }\n', '\t\n', '    function depositToken(uint256 _amount) public {\n', '        lock();\n', '        _depositToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _depositToken(address _to, uint256 _amount) internal {         \n', '        require(_to != 0x0);\n', '        DonQuixoteToken.withhold(_to, _amount);\n', '        userTokenOf[_to] = userTokenOf[_to].add(_amount);\n', '    }\n', '\n', '    function withdrawAllToken() public{    \n', '        uint256 _amount = userTokenOf[msg.sender];\n', '        withdrawToken(_amount);\n', '    }\n', '\t\n', '\tfunction withdrawToken(uint256 _amount) public {    \n', '        lock();  \n', '        _withdrawToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _withdrawToken(address _to, uint256 _amount) internal {      \n', '        require(_to != 0x0);\n', '        userTokenOf[_to] = userTokenOf[_to].sub(_amount);\n', '        DonQuixoteToken.transfer(_to, _amount);\n', '    }\n', '\n', '    uint public currentEventId = 1;            \n', '\n', '    function getEventId() internal returns(uint _result) {  \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '        \n', '}\n', '\n', 'contract SelectOne is Base\n', '{    \n', '    uint public constant minNum = 1;        \n', '    uint public maxNum = 22;               \n', '    uint  public winMultiplePer = 90;     \n', '    \n', '    uint  public constant maxPlayerNum = 100;      \n', '    uint public gameTime; \n', '    uint256 public gameMaxBetAmount;    \n', '    uint256 public gameMinBetAmount;    \n', '\t\n', '\tfunction SelectOne(uint _maxNum, uint  _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,uint _winMultiplePer, string _gameName,address _DonQuixoteToken)  public {\n', '        require(_gameMinBetAmount >= 0);\n', '        require(_gameMaxBetAmount > 0);\n', '        require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '\t\trequire(_maxNum < 10000);              \n', '        require(1 < _maxNum);                   \n', '        require(_winMultiplePer < _maxNum.mul(100));      \n', '        \n', '\t\tgameMinBetAmount = _gameMinBetAmount;\n', '        gameMaxBetAmount = _gameMaxBetAmount;\n', '        gameTime = _gameTime;\n', '        maxNum = _maxNum;                      \n', '        winMultiplePer = _winMultiplePer;       \n', '        owner = msg.sender;             \n', '        gameName = _gameName;           \n', '\n', '        require(_DonQuixoteToken != 0x0);\n', '        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n', '    }\n', '\n', '    uint public lastBlockNumber = 0;            \n', '    bool public betInfoIsLocked = false;       \n', '    address public auction;             \n', '    \n', '\n', '    function setAuction(address _newAuction) public onlyOwner{\n', '        require(_newAuction != 0x0);\n', '        auction = _newAuction;\n', '    }\n', '    modifier onlyAuction {             \n', '        require(msg.sender == auction);\n', '        _;\n', '    }\n', '\n', '    function canSetBanker() public view returns (bool _result){\n', '        _result =  bankerEndTime <= now && gameOver;\n', '    }\n', '\t\n', '    modifier onlyBanker {               \n', '        require(msg.sender == currentBanker);\n', '        require(bankerBeginTime <= now);\n', '        require(now < bankerEndTime);     \n', '        _;\n', '    }\n', '\n', '    event OnSetNewBanker(address _caller, address _banker, uint _beginTime, uint _endTime, uint _code, uint _eventTime, uint eventId);\n', '\n', '    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n', '\t{\n', '        _result = false;\n', '        require(_banker != 0x0);\n', '        if(now < bankerEndTime){        \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n', '            return;\n', '        }\n', '        if(!gameOver){                  \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 2, now, getEventId());\n', '            return;\n', '        }\n', '        if(_beginTime > now){               \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId()); \n', '            return;\n', '        }\n', '        if(_endTime <= now){\n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n', '            return;\n', '        }\n', '\t    if(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(_banker);\n', '        }\n', '        currentBanker = _banker;\n', '        bankerBeginTime = _beginTime;\n', '        bankerEndTime = _endTime;\n', '        emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 0 , now, getEventId());\n', '        _result = true;\n', '    }\n', ' \n', '    uint public playNo = 1;             \n', '    uint public gameID = 0;             \n', '    uint public gameBeginPlayNo;        \n', '    uint public gameEndPlayNo;          \n', '    bytes32 public gameEncryptedText;  \n', '    uint public gameResult;            \n', '    string public gameRandon1;          \n', '    string public constant gameRandon2 = &#39;ChinasNewGovernmentBracesforTrump&#39;;   \n', '    uint  public gameBeginTime;        \n', '    uint  public gameEndTime;           \n', '    bool public gameOver = true;       \n', '    uint public donGameGiftLineTime = now.add(90 days);  \n', '    \n', '\t\n', '    event OnNewGame(uint _gameID, address _banker, bytes32 _gameEncryptedText, uint  _gameBeginTime,  uint  _gameEndTime, uint _eventTime, uint _eventId);\n', '\n', '    function newGame(bytes32 _gameEncryptedText) public onlyBanker returns(bool _result)               \n', '    {\n', '        _result = _newGame( _gameEncryptedText);\n', '    }\n', '\n', '    function _newGame(bytes32 _gameEncryptedText) private  returns(bool _result)       \n', '    {\n', '        _result = false;\n', '        require(gameOver); \n', '        require(bankerBeginTime < now);       \n', '        require(now.add(gameTime) <= bankerEndTime);    \n', '        gameID++;                           \n', '        currentBanker = msg.sender;\n', '        gameEncryptedText = _gameEncryptedText;\n', '        gameRandon1 = &#39;&#39;;          \n', '        gameBeginTime = now;                \n', '        gameEndTime = now.add(gameTime);\n', '        gameBeginPlayNo = playNo;          \n', '        gameEndPlayNo = 0;                 \n', '        gameResult = 0;  \n', '        gameOver = false;\n', '        \n', '        emit OnNewGame(gameID, msg.sender, _gameEncryptedText, now, now.add(gameTime), now, getEventId());\n', '        _result = true;\n', '    }\n', '    \n', '    struct betInfo              \n', '    {\n', '        address Player;\n', '        uint BetNum;            \n', '        uint256 BetAmount;      \n', '        bool IsReturnAward;     \n', '    }\n', '\n', '    mapping (uint => betInfo) public playerBetInfoOf;              \n', '    event OnPlay(uint indexed _gameID, address indexed _player, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint _eventId);\n', '\n', '    function play(uint _betNum, uint256 _betAmount) public  returns(bool _result){      \n', '        _result = _play(_betNum, _betAmount);\n', '    }\n', '\n', '    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){            \n', '        _result = false;\n', '        require(!gameOver);\n', '        require(!betInfoIsLocked);                         \n', '        require(now < gameEndTime);\n', '        require(playNo.sub(gameBeginPlayNo) <= maxPlayerNum); \n', '        require(minNum <= _betNum && _betNum <= maxNum);    \n', '        require(msg.sender != currentBanker);                \n', '                   \n', '        uint256 ba = _betAmount;\n', '        if (ba > gameMaxBetAmount){                       \n', '            ba = gameMaxBetAmount;\n', '        }\n', '        require(ba >= gameMinBetAmount);                   \n', '\n', '        if(userTokenOf[msg.sender] < ba){                                       \n', '            depositToken(ba.sub(userTokenOf[msg.sender]));                    \n', '        }\n', '        require(userTokenOf[msg.sender] >= ba);             \n', '       \n', '        uint256 BankerAmount = ba.mul(winMultiplePer).div(100);                  \n', '      \n', '        require(userTokenOf[currentBanker] >= BankerAmount);\n', '\n', '        betInfo memory bi = betInfo({\n', '                Player :  msg.sender,\n', '                BetNum : _betNum,\n', '                BetAmount : ba,\n', '                IsReturnAward: false                 \n', '        });\n', '\n', '        playerBetInfoOf[playNo] = bi;\n', '        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(ba);                     \n', '        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);      \n', '        userTokenOf[this] = userTokenOf[this].add(ba.add(BankerAmount));                \n', '\n', '        emit OnPlay(gameID,  msg.sender,  _betNum,  ba, playNo, now, getEventId());\n', '\n', '        lastBlockNumber = block.number;    \n', '        playNo++;                          \n', '\n', '        if(now < donGameGiftLineTime){     \n', '            DonQuixoteToken.logPlaying(msg.sender);           \n', '        }\n', '        _result = true;\n', '    }\n', '\n', '   \n', '    \n', '    function lockBetInfo() public onlyBanker returns (bool _result) {                  \n', '        require(!gameOver);\n', '        require(now < gameEndTime);\n', '        require(!betInfoIsLocked);\n', '        betInfoIsLocked = true;\n', '        _result = true;\n', '    }\n', '\n', '    function uint8ToString(uint v) private pure returns (string)    \n', '    {\n', '        uint maxlength = 8;                    \n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v.div(10);\n', '            reversed[i++] = byte(remainder.add(48));\n', '        }\n', '        bytes memory s = new bytes(i);         \n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[(i.sub(j)).sub(1)];         \n', '        }\n', '        string memory str = string(s);          \n', '        return str;                             \n', '    }\n', '\n', '    event OnOpenGameResult(uint indexed _gameID, address _banker, uint _gameResult, string _r1, bool  _result, uint  _code, uint _eventTime, uint eventId);\n', '\n', '    function openGameResult(uint _gameResult, string _r1) public onlyBanker  returns(bool _result){\n', '        _result =  _openGameResult( _gameResult,  _r1);\n', '    }\n', '    \n', '    function _openGameResult(uint _gameResult, string _r1) private  returns(bool _result){            \n', '       \n', '\t   _result = false;\n', '        require(betInfoIsLocked);          \n', '        require(!gameOver);\n', '        require(now <= gameEndTime);       \n', '\n', '        if(lastBlockNumber == block.number){                        \n', '            emit OnOpenGameResult(gameID, msg.sender, _gameResult, _r1,  false, 2, now, getEventId());         \n', '            return;\n', '        }\n', '\n', '        string memory gr = uint8ToString(_gameResult); \n', '        if(keccak256(gr, gameRandon2,  _r1) ==  gameEncryptedText){\n', '            if(_gameResult >= minNum && _gameResult <= maxNum){     \n', '                gameResult = _gameResult;\n', '                gameRandon1 = _r1;\n', '                gameEndPlayNo = playNo.sub(1); \n', '                for(uint i = gameBeginPlayNo; i < playNo; i++){     \n', '                    betInfo storage p = playerBetInfoOf[i];\n', '                    if(!p.IsReturnAward){   \n', '                        p.IsReturnAward = true;\n', '                        uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);    \n', '                        if(p.BetNum == _gameResult){                                           \n', '                            userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);     \n', '                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n', '                        }else{                                                                  \n', '                            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(AllAmount);\n', '                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n', '                            if(now < donGameGiftLineTime){  \n', '                                DonQuixoteToken.sendGameGift(p.Player);                                \n', '                            } \n', '                        }\n', '                    }\n', '                }\n', '                gameOver = true;\n', '                betInfoIsLocked = false;    \n', '                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1, true, 0, now, getEventId());      \n', '                _result = true;\n', '                return;\n', '            }else{       \n', '                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false, 3, now, getEventId()); \n', '                return;                  \n', '            }\n', '        }else{           \n', '            emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false,4, now, getEventId());\n', '            return;\n', '        }        \n', '    }\n', '\n', '    function openGameResultAndNewGame(uint _gameResult, string _r1, bytes32 _gameEncryptedText) public onlyBanker returns(bool _result){\n', '\t\tif(gameOver){\n', '            _result = true ;\n', '        }else{\n', '            _result = _openGameResult( _gameResult,  _r1);\n', '        }\n', '        if (_result){      \n', '            _result = _newGame( _gameEncryptedText);\n', '        }\n', '    }\n', '\n', '    function noOpenGameResult() public  returns(bool _result){         \n', '        _result = false;\n', '        require(!gameOver);       \n', '        require(gameEndTime < now); \n', '        if(lastBlockNumber == block.number){                           \n', '            emit OnOpenGameResult(gameID, msg.sender,0, &#39;&#39;,false, 2, now, getEventId());\n', '            return;\n', '        }\n', '\n', '        lock(); \n', '\t\t\n', '        gameEndPlayNo = playNo - 1;         \n', '        for(uint i = gameBeginPlayNo; i < playNo; i++){                                \n', '            betInfo storage p = playerBetInfoOf[i];\n', '            if(!p.IsReturnAward){           \n', '                p.IsReturnAward = true;\n', '                uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);     \n', '                userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);          \n', '                userTokenOf[this] = userTokenOf[this].sub(AllAmount);                  \n', '            }\n', '        }\n', '\n', '        gameOver = true;\n', '        if(betInfoIsLocked){\n', '            betInfoIsLocked = false;    \n', '        }\n', '        emit OnOpenGameResult(gameID, msg.sender,   0,  &#39;&#39;,  true, 1, now, getEventId());\n', '        _result = true;\n', '\n', '        unLock();  \n', '    }\n', '\n', '    function  failUserRefund(uint _playNo) public returns (bool _result) {      \n', '        _result = false;\n', '        require(!gameOver);\n', '        require(gameEndTime.add(30 days) < now);          \n', '\n', '        betInfo storage p = playerBetInfoOf[_playNo];   \n', '        require(p.Player == msg.sender);               \n', '        \n', '        if(!p.IsReturnAward && p.BetNum > 0){            \n', '            p.IsReturnAward = true;\n', '            uint256 ToUser = p.BetAmount;   \n', '            uint256 ToBanker = p.BetAmount.mul(winMultiplePer).div(100);  \n', '            userTokenOf[this] = userTokenOf[this].sub(ToUser.add(ToBanker));              \n', '            userTokenOf[p.Player] = userTokenOf[p.Player].add(ToUser);         \n', '            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(ToBanker);\n', '            _result = true;                                  \n', '        }\n', '    }\n', '\n', '    function transEther() public onlyOwner()    \n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '    \n', '    function () public payable {        \n', '      \n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface IDonQuixoteToken{                          \n', '    function withhold(address _user,  uint256 _amount) external returns (bool _result);  \n', '    function transfer(address _to, uint256 _value) external;                             \n', '    function sendGameGift(address _player) external returns (bool _result);              \n', '    function logPlaying(address _player) external returns (bool _result);               \n', '    function balanceOf(address _user) constant  external returns (uint256 _balance);\n', '} \n', '\n', 'contract BaseGame {             \n', '    string public gameName="BigOrSmall";         \n', '     uint public constant gameType = 2001;   \n', '    string public officialGameUrl;  \n', '    mapping (address => uint256) public userTokenOf;     \n', '    uint public bankerBeginTime;     \n', '    uint public bankerEndTime;       \n', '    address public currentBanker;      \n', '    \t\n', '    function depositToken(uint256 _amount) public;\n', '    function withdrawToken(uint256 _amount) public;\n', '\tfunction withdrawAllToken() public;\n', '    function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);     \n', '    function canSetBanker() view public returns (bool _result);         \n', '}\n', 'contract Base is BaseGame { \n', '    using SafeMath for uint256;     \n', '    uint public createTime = now;\n', '    address public owner;\n', '\t\n', '    IDonQuixoteToken public DonQuixoteToken;\n', '      function Base() public {\n', '    }\n', '\t\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\t\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '         require(_newOwner!= 0x0);\n', '        owner = _newOwner;\n', '    }\n', '        \n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {             \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }    \n', '  \n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;     \n', '    }\n', '    function tokenOf(address _user) view public returns(uint256 _result){\n', '        _result = DonQuixoteToken.balanceOf(_user);\n', '    }\n', '\t\n', '    function depositToken(uint256 _amount) public {\n', '        lock();\n', '        _depositToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _depositToken(address _to, uint256 _amount) internal {         \n', '        require(_to != 0x0);\n', '        DonQuixoteToken.withhold(_to, _amount);\n', '        userTokenOf[_to] = userTokenOf[_to].add(_amount);\n', '    }\n', '\n', '    function withdrawAllToken() public{    \n', '        uint256 _amount = userTokenOf[msg.sender];\n', '        withdrawToken(_amount);\n', '    }\n', '\t\n', '\tfunction withdrawToken(uint256 _amount) public {    \n', '        lock();  \n', '        _withdrawToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _withdrawToken(address _to, uint256 _amount) internal {      \n', '        require(_to != 0x0);\n', '        userTokenOf[_to] = userTokenOf[_to].sub(_amount);\n', '        DonQuixoteToken.transfer(_to, _amount);\n', '    }\n', '\n', '    uint public currentEventId = 1;            \n', '\n', '    function getEventId() internal returns(uint _result) {  \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '        \n', '}\n', '\n', 'contract SelectOne is Base\n', '{    \n', '    uint public constant minNum = 1;        \n', '    uint public maxNum = 22;               \n', '    uint  public winMultiplePer = 90;     \n', '    \n', '    uint  public constant maxPlayerNum = 100;      \n', '    uint public gameTime; \n', '    uint256 public gameMaxBetAmount;    \n', '    uint256 public gameMinBetAmount;    \n', '\t\n', '\tfunction SelectOne(uint _maxNum, uint  _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,uint _winMultiplePer, string _gameName,address _DonQuixoteToken)  public {\n', '        require(_gameMinBetAmount >= 0);\n', '        require(_gameMaxBetAmount > 0);\n', '        require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '\t\trequire(_maxNum < 10000);              \n', '        require(1 < _maxNum);                   \n', '        require(_winMultiplePer < _maxNum.mul(100));      \n', '        \n', '\t\tgameMinBetAmount = _gameMinBetAmount;\n', '        gameMaxBetAmount = _gameMaxBetAmount;\n', '        gameTime = _gameTime;\n', '        maxNum = _maxNum;                      \n', '        winMultiplePer = _winMultiplePer;       \n', '        owner = msg.sender;             \n', '        gameName = _gameName;           \n', '\n', '        require(_DonQuixoteToken != 0x0);\n', '        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n', '    }\n', '\n', '    uint public lastBlockNumber = 0;            \n', '    bool public betInfoIsLocked = false;       \n', '    address public auction;             \n', '    \n', '\n', '    function setAuction(address _newAuction) public onlyOwner{\n', '        require(_newAuction != 0x0);\n', '        auction = _newAuction;\n', '    }\n', '    modifier onlyAuction {             \n', '        require(msg.sender == auction);\n', '        _;\n', '    }\n', '\n', '    function canSetBanker() public view returns (bool _result){\n', '        _result =  bankerEndTime <= now && gameOver;\n', '    }\n', '\t\n', '    modifier onlyBanker {               \n', '        require(msg.sender == currentBanker);\n', '        require(bankerBeginTime <= now);\n', '        require(now < bankerEndTime);     \n', '        _;\n', '    }\n', '\n', '    event OnSetNewBanker(address _caller, address _banker, uint _beginTime, uint _endTime, uint _code, uint _eventTime, uint eventId);\n', '\n', '    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n', '\t{\n', '        _result = false;\n', '        require(_banker != 0x0);\n', '        if(now < bankerEndTime){        \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n', '            return;\n', '        }\n', '        if(!gameOver){                  \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 2, now, getEventId());\n', '            return;\n', '        }\n', '        if(_beginTime > now){               \n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId()); \n', '            return;\n', '        }\n', '        if(_endTime <= now){\n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n', '            return;\n', '        }\n', '\t    if(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(_banker);\n', '        }\n', '        currentBanker = _banker;\n', '        bankerBeginTime = _beginTime;\n', '        bankerEndTime = _endTime;\n', '        emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 0 , now, getEventId());\n', '        _result = true;\n', '    }\n', ' \n', '    uint public playNo = 1;             \n', '    uint public gameID = 0;             \n', '    uint public gameBeginPlayNo;        \n', '    uint public gameEndPlayNo;          \n', '    bytes32 public gameEncryptedText;  \n', '    uint public gameResult;            \n', '    string public gameRandon1;          \n', "    string public constant gameRandon2 = 'ChinasNewGovernmentBracesforTrump';   \n", '    uint  public gameBeginTime;        \n', '    uint  public gameEndTime;           \n', '    bool public gameOver = true;       \n', '    uint public donGameGiftLineTime = now.add(90 days);  \n', '    \n', '\t\n', '    event OnNewGame(uint _gameID, address _banker, bytes32 _gameEncryptedText, uint  _gameBeginTime,  uint  _gameEndTime, uint _eventTime, uint _eventId);\n', '\n', '    function newGame(bytes32 _gameEncryptedText) public onlyBanker returns(bool _result)               \n', '    {\n', '        _result = _newGame( _gameEncryptedText);\n', '    }\n', '\n', '    function _newGame(bytes32 _gameEncryptedText) private  returns(bool _result)       \n', '    {\n', '        _result = false;\n', '        require(gameOver); \n', '        require(bankerBeginTime < now);       \n', '        require(now.add(gameTime) <= bankerEndTime);    \n', '        gameID++;                           \n', '        currentBanker = msg.sender;\n', '        gameEncryptedText = _gameEncryptedText;\n', "        gameRandon1 = '';          \n", '        gameBeginTime = now;                \n', '        gameEndTime = now.add(gameTime);\n', '        gameBeginPlayNo = playNo;          \n', '        gameEndPlayNo = 0;                 \n', '        gameResult = 0;  \n', '        gameOver = false;\n', '        \n', '        emit OnNewGame(gameID, msg.sender, _gameEncryptedText, now, now.add(gameTime), now, getEventId());\n', '        _result = true;\n', '    }\n', '    \n', '    struct betInfo              \n', '    {\n', '        address Player;\n', '        uint BetNum;            \n', '        uint256 BetAmount;      \n', '        bool IsReturnAward;     \n', '    }\n', '\n', '    mapping (uint => betInfo) public playerBetInfoOf;              \n', '    event OnPlay(uint indexed _gameID, address indexed _player, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint _eventId);\n', '\n', '    function play(uint _betNum, uint256 _betAmount) public  returns(bool _result){      \n', '        _result = _play(_betNum, _betAmount);\n', '    }\n', '\n', '    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){            \n', '        _result = false;\n', '        require(!gameOver);\n', '        require(!betInfoIsLocked);                         \n', '        require(now < gameEndTime);\n', '        require(playNo.sub(gameBeginPlayNo) <= maxPlayerNum); \n', '        require(minNum <= _betNum && _betNum <= maxNum);    \n', '        require(msg.sender != currentBanker);                \n', '                   \n', '        uint256 ba = _betAmount;\n', '        if (ba > gameMaxBetAmount){                       \n', '            ba = gameMaxBetAmount;\n', '        }\n', '        require(ba >= gameMinBetAmount);                   \n', '\n', '        if(userTokenOf[msg.sender] < ba){                                       \n', '            depositToken(ba.sub(userTokenOf[msg.sender]));                    \n', '        }\n', '        require(userTokenOf[msg.sender] >= ba);             \n', '       \n', '        uint256 BankerAmount = ba.mul(winMultiplePer).div(100);                  \n', '      \n', '        require(userTokenOf[currentBanker] >= BankerAmount);\n', '\n', '        betInfo memory bi = betInfo({\n', '                Player :  msg.sender,\n', '                BetNum : _betNum,\n', '                BetAmount : ba,\n', '                IsReturnAward: false                 \n', '        });\n', '\n', '        playerBetInfoOf[playNo] = bi;\n', '        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(ba);                     \n', '        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);      \n', '        userTokenOf[this] = userTokenOf[this].add(ba.add(BankerAmount));                \n', '\n', '        emit OnPlay(gameID,  msg.sender,  _betNum,  ba, playNo, now, getEventId());\n', '\n', '        lastBlockNumber = block.number;    \n', '        playNo++;                          \n', '\n', '        if(now < donGameGiftLineTime){     \n', '            DonQuixoteToken.logPlaying(msg.sender);           \n', '        }\n', '        _result = true;\n', '    }\n', '\n', '   \n', '    \n', '    function lockBetInfo() public onlyBanker returns (bool _result) {                  \n', '        require(!gameOver);\n', '        require(now < gameEndTime);\n', '        require(!betInfoIsLocked);\n', '        betInfoIsLocked = true;\n', '        _result = true;\n', '    }\n', '\n', '    function uint8ToString(uint v) private pure returns (string)    \n', '    {\n', '        uint maxlength = 8;                    \n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v.div(10);\n', '            reversed[i++] = byte(remainder.add(48));\n', '        }\n', '        bytes memory s = new bytes(i);         \n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[(i.sub(j)).sub(1)];         \n', '        }\n', '        string memory str = string(s);          \n', '        return str;                             \n', '    }\n', '\n', '    event OnOpenGameResult(uint indexed _gameID, address _banker, uint _gameResult, string _r1, bool  _result, uint  _code, uint _eventTime, uint eventId);\n', '\n', '    function openGameResult(uint _gameResult, string _r1) public onlyBanker  returns(bool _result){\n', '        _result =  _openGameResult( _gameResult,  _r1);\n', '    }\n', '    \n', '    function _openGameResult(uint _gameResult, string _r1) private  returns(bool _result){            \n', '       \n', '\t   _result = false;\n', '        require(betInfoIsLocked);          \n', '        require(!gameOver);\n', '        require(now <= gameEndTime);       \n', '\n', '        if(lastBlockNumber == block.number){                        \n', '            emit OnOpenGameResult(gameID, msg.sender, _gameResult, _r1,  false, 2, now, getEventId());         \n', '            return;\n', '        }\n', '\n', '        string memory gr = uint8ToString(_gameResult); \n', '        if(keccak256(gr, gameRandon2,  _r1) ==  gameEncryptedText){\n', '            if(_gameResult >= minNum && _gameResult <= maxNum){     \n', '                gameResult = _gameResult;\n', '                gameRandon1 = _r1;\n', '                gameEndPlayNo = playNo.sub(1); \n', '                for(uint i = gameBeginPlayNo; i < playNo; i++){     \n', '                    betInfo storage p = playerBetInfoOf[i];\n', '                    if(!p.IsReturnAward){   \n', '                        p.IsReturnAward = true;\n', '                        uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);    \n', '                        if(p.BetNum == _gameResult){                                           \n', '                            userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);     \n', '                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n', '                        }else{                                                                  \n', '                            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(AllAmount);\n', '                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n', '                            if(now < donGameGiftLineTime){  \n', '                                DonQuixoteToken.sendGameGift(p.Player);                                \n', '                            } \n', '                        }\n', '                    }\n', '                }\n', '                gameOver = true;\n', '                betInfoIsLocked = false;    \n', '                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1, true, 0, now, getEventId());      \n', '                _result = true;\n', '                return;\n', '            }else{       \n', '                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false, 3, now, getEventId()); \n', '                return;                  \n', '            }\n', '        }else{           \n', '            emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false,4, now, getEventId());\n', '            return;\n', '        }        \n', '    }\n', '\n', '    function openGameResultAndNewGame(uint _gameResult, string _r1, bytes32 _gameEncryptedText) public onlyBanker returns(bool _result){\n', '\t\tif(gameOver){\n', '            _result = true ;\n', '        }else{\n', '            _result = _openGameResult( _gameResult,  _r1);\n', '        }\n', '        if (_result){      \n', '            _result = _newGame( _gameEncryptedText);\n', '        }\n', '    }\n', '\n', '    function noOpenGameResult() public  returns(bool _result){         \n', '        _result = false;\n', '        require(!gameOver);       \n', '        require(gameEndTime < now); \n', '        if(lastBlockNumber == block.number){                           \n', "            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n", '            return;\n', '        }\n', '\n', '        lock(); \n', '\t\t\n', '        gameEndPlayNo = playNo - 1;         \n', '        for(uint i = gameBeginPlayNo; i < playNo; i++){                                \n', '            betInfo storage p = playerBetInfoOf[i];\n', '            if(!p.IsReturnAward){           \n', '                p.IsReturnAward = true;\n', '                uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);     \n', '                userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);          \n', '                userTokenOf[this] = userTokenOf[this].sub(AllAmount);                  \n', '            }\n', '        }\n', '\n', '        gameOver = true;\n', '        if(betInfoIsLocked){\n', '            betInfoIsLocked = false;    \n', '        }\n', "        emit OnOpenGameResult(gameID, msg.sender,   0,  '',  true, 1, now, getEventId());\n", '        _result = true;\n', '\n', '        unLock();  \n', '    }\n', '\n', '    function  failUserRefund(uint _playNo) public returns (bool _result) {      \n', '        _result = false;\n', '        require(!gameOver);\n', '        require(gameEndTime.add(30 days) < now);          \n', '\n', '        betInfo storage p = playerBetInfoOf[_playNo];   \n', '        require(p.Player == msg.sender);               \n', '        \n', '        if(!p.IsReturnAward && p.BetNum > 0){            \n', '            p.IsReturnAward = true;\n', '            uint256 ToUser = p.BetAmount;   \n', '            uint256 ToBanker = p.BetAmount.mul(winMultiplePer).div(100);  \n', '            userTokenOf[this] = userTokenOf[this].sub(ToUser.add(ToBanker));              \n', '            userTokenOf[p.Player] = userTokenOf[p.Player].add(ToUser);         \n', '            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(ToBanker);\n', '            _result = true;                                  \n', '        }\n', '    }\n', '\n', '    function transEther() public onlyOwner()    \n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '    \n', '    function () public payable {        \n', '      \n', '    }\n', '\n', '\n', '}']
