['pragma solidity ^0.4.24;\n', '\n', '// &#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;\n', '// &#128512;                            &#128512;\n', '// &#128512; https://emojisan.github.io &#128512;\n', '// &#128512;                            &#128512;\n', '// &#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;&#128512;\n', '\n', '// part of NFT token interface used in this contract\n', '// https://etherscan.io/address/0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6\n', 'interface Emojisan {\n', '\n', '    function ownerOf(uint tokenId) external view returns (address);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function transferFrom(address from, address to, uint tokenId) external;\n', '    function mint(uint tokenId) external;\n', '    function setMinter(address newMinter) external;\n', '}\n', '\n', 'contract EmojisanAuctionHouse {\n', '\n', '    event Bid(uint indexed tokenId);\n', '\n', '    struct Auction {\n', '        address owner;\n', '        uint128 currentPrice;\n', '    }\n', '\n', '    struct User {\n', '        uint128 balance;\n', '        uint32 bidBlock;\n', '    }\n', '\n', '    // NFT token address\n', '    // https://etherscan.io/address/0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6\n', '    Emojisan public constant emojisan = Emojisan(0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6);\n', '\n', '    uint[] public tokenByIndex;\n', '    mapping (uint => Auction) public auction;\n', '    mapping (address => User) public user;\n', '    uint32 private constant auctionTime = 20000;\n', '\n', '    address public whaleAddress;\n', '    uint32 public whaleStartTime;\n', '    uint128 public whaleBalance;\n', '    uint32 private constant whaleWithdrawDelay = 80000;\n', '\n', '    uint128 public ownerBalance;\n', '    uint private constant ownerTokenId = 128512;\n', '\n', '    function tokens() external view returns (uint[]) {\n', '        return tokenByIndex;\n', '    }\n', '\n', '    function tokensCount() external view returns (uint) {\n', '        return tokenByIndex.length;\n', '    }\n', '\n', '    function wantItForFree(uint tokenId) external {\n', '        // user &#128100; can bid only on one 1Ô∏è‚É£ token at a time ‚è±Ô∏è\n', '        require(block.number >= user[msg.sender].bidBlock + auctionTime);\n', '        // check auction has not started &#128683;&#127916;\n', '        require(auction[tokenId].owner == address(this));\n', '        auction[tokenId].owner = msg.sender;\n', '        user[msg.sender].bidBlock = uint32(block.number);\n', '        emojisan.mint(tokenId);\n', '        emit Bid(tokenId);\n', '    }\n', '\n', '    function wantItMoreThanYou(uint tokenId) external payable {\n', '        // user &#128100; can bid only on one 1Ô∏è‚É£ token at a time ‚è±Ô∏è\n', '        require(block.number >= user[msg.sender].bidBlock + auctionTime);\n', '        // check auction has not finished &#128683;&#127937;\n', '        address previousOwner = auction[tokenId].owner;\n', '        require(block.number < user[previousOwner].bidBlock + auctionTime);\n', '        // fancy &#129488; price &#128176; calculation &#128200;\n', '        // 0 ‚û°Ô∏è 0.002 ‚û°Ô∏è 0.004 ‚û°Ô∏è 0.008 ‚û°Ô∏è 0.016 ‚û°Ô∏è 0.032 ‚û°Ô∏è 0.064 ‚û°Ô∏è 0.128\n', '        // ‚û°Ô∏è 0.256 ‚û°Ô∏è 0.512 ‚û°Ô∏è 1 ‚û°Ô∏è 1.5 ‚û°Ô∏è 2 ‚û°Ô∏è 2.5 ‚û°Ô∏è 3 ‚û°Ô∏è 3.5 ‚û°Ô∏è 4 ‚û°Ô∏è ...\n', '        uint128 previousPrice = auction[tokenId].currentPrice;\n', '        uint128 price;\n', '        if (previousPrice == 0) {\n', '            price = 2 finney;\n', '        } else if (previousPrice < 500 finney) {\n', '            price = 2 * previousPrice;\n', '        } else {\n', '            price = (previousPrice + 500 finney) / 500 finney * 500 finney;\n', '        }\n', '        require(msg.value >= price);\n', '        uint128 priceDiff = price - previousPrice;\n', '        // previous &#128100; gets what she &#128582; paid ‚ûï 2Ô∏è‚É£5Ô∏è‚É£%\n', '        user[previousOwner] = User({\n', '            balance: previousPrice + priceDiff / 4,\n', '            bidBlock: 0\n', '        });\n', '        // whale &#128011; gets 5Ô∏è‚É£0Ô∏è‚É£%\n', '        whaleBalance += priceDiff / 2;\n', '        // owner &#128105; of token 128512 &#128512; gets 2Ô∏è‚É£5Ô∏è‚É£%\n', '        ownerBalance += priceDiff / 4;\n', '        auction[tokenId] = Auction({\n', '            owner: msg.sender,\n', '            currentPrice: price\n', '        });\n', '        user[msg.sender].bidBlock = uint32(block.number);\n', '        if (msg.value > price) {\n', '            // send back eth if someone sent too much &#128184;&#128184;&#128184;\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '        emit Bid(tokenId);\n', '    }\n', '\n', '    function wantMyToken(uint tokenId) external {\n', '        Auction memory a = auction[tokenId];\n', '        // check auction has finished &#127937;\n', '        require(block.number >= user[a.owner].bidBlock + auctionTime);\n', '        emojisan.transferFrom(this, a.owner, tokenId);\n', '    }\n', '\n', '    function wantMyEther() external {\n', '        uint amount = user[msg.sender].balance;\n', '        user[msg.sender].balance = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function wantToBeWhale() external {\n', '        // need to have more tokens &#128176; than current &#128011;\n', '        require(emojisan.balanceOf(msg.sender) > emojisan.balanceOf(whaleAddress));\n', '        whaleAddress = msg.sender;\n', '        // whale &#128051; needs to wait some time ‚è±Ô∏è before snatching that sweet &#127852; eth &#129297;\n', '        whaleStartTime = uint32(block.number);\n', '    }\n', '\n', '    function whaleWantMyEther() external {\n', '        require(msg.sender == whaleAddress);\n', '        // check enough time ‚è±Ô∏è passed for whale &#128051; to grab &#128181;&#128183;&#128182;&#128180;\n', '        require(block.number >= whaleStartTime + whaleWithdrawDelay);\n', '        // whale &#128051; needs to wait some time ‚è±Ô∏è before snatching that sweet &#127853; eth &#129297; again\n', '        whaleStartTime = uint32(block.number);\n', '        uint amount = whaleBalance;\n', '        whaleBalance = 0;\n', '        whaleAddress.transfer(amount);\n', '    }\n', '\n', '    function ownerWantMyEther() external {\n', '        uint amount = ownerBalance;\n', '        ownerBalance = 0;\n', '        emojisan.ownerOf(ownerTokenId).transfer(amount);\n', '    }\n', '\n', '    function wantNewTokens(uint[] tokenIds) external {\n', '        // only owner &#128105; of token 128512 &#128512;\n', '        require(msg.sender == emojisan.ownerOf(ownerTokenId));\n', '        for (uint i = 0; i < tokenIds.length; i++) {\n', '            auction[tokenIds[i]].owner = this;\n', '            tokenByIndex.push(tokenIds[i]);\n', '        }\n', '    }\n', '\n', '    function wantNewMinter(address minter) external {\n', '        // only owner &#128105; of token 128512 &#128512;\n', '        require(msg.sender == emojisan.ownerOf(ownerTokenId));\n', '        emojisan.setMinter(minter);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// üòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄ\n', '// üòÄ                            üòÄ\n', '// üòÄ https://emojisan.github.io üòÄ\n', '// üòÄ                            üòÄ\n', '// üòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄüòÄ\n', '\n', '// part of NFT token interface used in this contract\n', '// https://etherscan.io/address/0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6\n', 'interface Emojisan {\n', '\n', '    function ownerOf(uint tokenId) external view returns (address);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function transferFrom(address from, address to, uint tokenId) external;\n', '    function mint(uint tokenId) external;\n', '    function setMinter(address newMinter) external;\n', '}\n', '\n', 'contract EmojisanAuctionHouse {\n', '\n', '    event Bid(uint indexed tokenId);\n', '\n', '    struct Auction {\n', '        address owner;\n', '        uint128 currentPrice;\n', '    }\n', '\n', '    struct User {\n', '        uint128 balance;\n', '        uint32 bidBlock;\n', '    }\n', '\n', '    // NFT token address\n', '    // https://etherscan.io/address/0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6\n', '    Emojisan public constant emojisan = Emojisan(0xE3f2F807ba194ea0221B9109fb14Da600C9e1eb6);\n', '\n', '    uint[] public tokenByIndex;\n', '    mapping (uint => Auction) public auction;\n', '    mapping (address => User) public user;\n', '    uint32 private constant auctionTime = 20000;\n', '\n', '    address public whaleAddress;\n', '    uint32 public whaleStartTime;\n', '    uint128 public whaleBalance;\n', '    uint32 private constant whaleWithdrawDelay = 80000;\n', '\n', '    uint128 public ownerBalance;\n', '    uint private constant ownerTokenId = 128512;\n', '\n', '    function tokens() external view returns (uint[]) {\n', '        return tokenByIndex;\n', '    }\n', '\n', '    function tokensCount() external view returns (uint) {\n', '        return tokenByIndex.length;\n', '    }\n', '\n', '    function wantItForFree(uint tokenId) external {\n', '        // user üë§ can bid only on one 1Ô∏è‚É£ token at a time ‚è±Ô∏è\n', '        require(block.number >= user[msg.sender].bidBlock + auctionTime);\n', '        // check auction has not started üö´üé¨\n', '        require(auction[tokenId].owner == address(this));\n', '        auction[tokenId].owner = msg.sender;\n', '        user[msg.sender].bidBlock = uint32(block.number);\n', '        emojisan.mint(tokenId);\n', '        emit Bid(tokenId);\n', '    }\n', '\n', '    function wantItMoreThanYou(uint tokenId) external payable {\n', '        // user üë§ can bid only on one 1Ô∏è‚É£ token at a time ‚è±Ô∏è\n', '        require(block.number >= user[msg.sender].bidBlock + auctionTime);\n', '        // check auction has not finished üö´üèÅ\n', '        address previousOwner = auction[tokenId].owner;\n', '        require(block.number < user[previousOwner].bidBlock + auctionTime);\n', '        // fancy üßê price üí∞ calculation üìà\n', '        // 0 ‚û°Ô∏è 0.002 ‚û°Ô∏è 0.004 ‚û°Ô∏è 0.008 ‚û°Ô∏è 0.016 ‚û°Ô∏è 0.032 ‚û°Ô∏è 0.064 ‚û°Ô∏è 0.128\n', '        // ‚û°Ô∏è 0.256 ‚û°Ô∏è 0.512 ‚û°Ô∏è 1 ‚û°Ô∏è 1.5 ‚û°Ô∏è 2 ‚û°Ô∏è 2.5 ‚û°Ô∏è 3 ‚û°Ô∏è 3.5 ‚û°Ô∏è 4 ‚û°Ô∏è ...\n', '        uint128 previousPrice = auction[tokenId].currentPrice;\n', '        uint128 price;\n', '        if (previousPrice == 0) {\n', '            price = 2 finney;\n', '        } else if (previousPrice < 500 finney) {\n', '            price = 2 * previousPrice;\n', '        } else {\n', '            price = (previousPrice + 500 finney) / 500 finney * 500 finney;\n', '        }\n', '        require(msg.value >= price);\n', '        uint128 priceDiff = price - previousPrice;\n', '        // previous üë§ gets what she üôÜ paid ‚ûï 2Ô∏è‚É£5Ô∏è‚É£%\n', '        user[previousOwner] = User({\n', '            balance: previousPrice + priceDiff / 4,\n', '            bidBlock: 0\n', '        });\n', '        // whale üêã gets 5Ô∏è‚É£0Ô∏è‚É£%\n', '        whaleBalance += priceDiff / 2;\n', '        // owner üë© of token 128512 üòÄ gets 2Ô∏è‚É£5Ô∏è‚É£%\n', '        ownerBalance += priceDiff / 4;\n', '        auction[tokenId] = Auction({\n', '            owner: msg.sender,\n', '            currentPrice: price\n', '        });\n', '        user[msg.sender].bidBlock = uint32(block.number);\n', '        if (msg.value > price) {\n', '            // send back eth if someone sent too much üí∏üí∏üí∏\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '        emit Bid(tokenId);\n', '    }\n', '\n', '    function wantMyToken(uint tokenId) external {\n', '        Auction memory a = auction[tokenId];\n', '        // check auction has finished üèÅ\n', '        require(block.number >= user[a.owner].bidBlock + auctionTime);\n', '        emojisan.transferFrom(this, a.owner, tokenId);\n', '    }\n', '\n', '    function wantMyEther() external {\n', '        uint amount = user[msg.sender].balance;\n', '        user[msg.sender].balance = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function wantToBeWhale() external {\n', '        // need to have more tokens üí∞ than current üêã\n', '        require(emojisan.balanceOf(msg.sender) > emojisan.balanceOf(whaleAddress));\n', '        whaleAddress = msg.sender;\n', '        // whale üê≥ needs to wait some time ‚è±Ô∏è before snatching that sweet üç¨ eth ü§ë\n', '        whaleStartTime = uint32(block.number);\n', '    }\n', '\n', '    function whaleWantMyEther() external {\n', '        require(msg.sender == whaleAddress);\n', '        // check enough time ‚è±Ô∏è passed for whale üê≥ to grab üíµüí∑üí∂üí¥\n', '        require(block.number >= whaleStartTime + whaleWithdrawDelay);\n', '        // whale üê≥ needs to wait some time ‚è±Ô∏è before snatching that sweet üç≠ eth ü§ë again\n', '        whaleStartTime = uint32(block.number);\n', '        uint amount = whaleBalance;\n', '        whaleBalance = 0;\n', '        whaleAddress.transfer(amount);\n', '    }\n', '\n', '    function ownerWantMyEther() external {\n', '        uint amount = ownerBalance;\n', '        ownerBalance = 0;\n', '        emojisan.ownerOf(ownerTokenId).transfer(amount);\n', '    }\n', '\n', '    function wantNewTokens(uint[] tokenIds) external {\n', '        // only owner üë© of token 128512 üòÄ\n', '        require(msg.sender == emojisan.ownerOf(ownerTokenId));\n', '        for (uint i = 0; i < tokenIds.length; i++) {\n', '            auction[tokenIds[i]].owner = this;\n', '            tokenByIndex.push(tokenIds[i]);\n', '        }\n', '    }\n', '\n', '    function wantNewMinter(address minter) external {\n', '        // only owner üë© of token 128512 üòÄ\n', '        require(msg.sender == emojisan.ownerOf(ownerTokenId));\n', '        emojisan.setMinter(minter);\n', '    }\n', '}']
