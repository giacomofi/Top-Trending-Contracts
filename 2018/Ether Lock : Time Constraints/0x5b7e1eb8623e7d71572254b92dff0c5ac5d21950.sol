['pragma solidity ^0.4.22;\n', '\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() internal {\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public constant returns (address) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract YooStop is Owned{\n', '\n', '    bool public stopped = true;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public ownerOnly{\n', '        stopped = true;\n', '    }\n', '    function start() public ownerOnly{\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract YoobaICO is  Owned,YooStop,Utils {\n', '    IERC20Token public yoobaTokenAddress;\n', '    uint256 public startICOTime = 0;  \n', '    uint256 public endICOTime = 0;  \n', '    uint256 public leftICOTokens = 0;\n', '    uint256 public tatalEthFromBuyer = 0;\n', '    uint256 public daysnumber = 0;\n', '    mapping (address => uint256) public pendingBalanceMap;\n', '    mapping (address => uint256) public totalBuyMap;\n', '    mapping (address => uint256) public totalBuyerETHMap;\n', '    mapping (uint256 => uint256) public daySellMap;\n', '    mapping (address => uint256) public withdrawYOOMap;\n', '    uint256 internal milestone1 = 4000000000000000000000000000;\n', '    uint256 internal milestone2 = 2500000000000000000000000000;\n', '       uint256 internal dayLimit = 300000000000000000000000000;\n', '    bool internal hasInitLeftICOTokens = false;\n', '\n', '\n', '\n', '    /**\n', '        @dev constructor\n', '        \n', '    */\n', '    function YoobaICO(IERC20Token _yoobaTokenAddress) public{\n', '         yoobaTokenAddress = _yoobaTokenAddress;\n', '    }\n', '    \n', '\n', '    function startICO(uint256 _startICOTime,uint256 _endICOTime) public ownerOnly {\n', '        startICOTime = _startICOTime;\n', '        endICOTime = _endICOTime;\n', '    }\n', '    \n', '    function initLeftICOTokens() public ownerOnly{\n', '        require(!hasInitLeftICOTokens);\n', '       leftICOTokens = yoobaTokenAddress.balanceOf(this);\n', '       hasInitLeftICOTokens = true;\n', '    }\n', '    function setLeftICOTokens(uint256 left) public ownerOnly {\n', '        leftICOTokens = left;\n', '    }\n', '    function setDaySellAmount(uint256 _dayNum,uint256 _sellAmount) public ownerOnly {\n', '        daySellMap[_dayNum] = _sellAmount;\n', '    }\n', '    \n', '    function withdrawTo(address _to, uint256 _amount) public ownerOnly notThis(_to)\n', '    {   \n', '        require(_amount <= this.balance);\n', '        _to.transfer(_amount); // send the amount to the target account\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '\n', '    }\n', '    \n', '    function withdrawToBuyer(IERC20Token _token,address[] _to)  public ownerOnly {\n', '        require(_to.length > 0  && _to.length < 10000);\n', '        for(uint16 i = 0; i < _to.length ;i++){\n', '            if(pendingBalanceMap[_to[i]] > 0){\n', '                assert(_token.transfer(_to[i],pendingBalanceMap[_to[i]])); \n', '                withdrawYOOMap[_to[i]] = safeAdd(withdrawYOOMap[_to[i]],pendingBalanceMap[_to[i]]);\n', '                pendingBalanceMap[_to[i]] = 0;\n', '            }\n', '         \n', '        }\n', '    }\n', '    \n', '      function withdrawToBuyer(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '        withdrawYOOMap[_to] = safeAdd(withdrawYOOMap[_to],_amount);\n', '        pendingBalanceMap[_to] = safeSub(pendingBalanceMap[_to],_amount);\n', '\n', '    }\n', '    \n', '    function refund(address[] _to) public ownerOnly{\n', '        require(_to.length > 0  && _to.length < 10000 );\n', '        for(uint16 i = 0; i < _to.length ;i++){\n', '            if(pendingBalanceMap[_to[i]] > 0 && withdrawYOOMap[_to[i]] == 0 && totalBuyerETHMap[_to[i]] > 0 && totalBuyMap[_to[i]] > 0){\n', '                 if(totalBuyerETHMap[_to[i]] <= this.balance){\n', '                _to[i].transfer(totalBuyerETHMap[_to[i]]); \n', '                tatalEthFromBuyer = tatalEthFromBuyer - totalBuyerETHMap[_to[i]];\n', '                leftICOTokens = leftICOTokens + pendingBalanceMap[_to[i]];\n', '                totalBuyerETHMap[_to[i]] = 0;\n', '                pendingBalanceMap[_to[i]] = 0; \n', '                totalBuyMap[_to[i]] = 0;\n', '              \n', '                 }\n', '            }\n', '         \n', '        }\n', '    }\n', '  \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && now >= startICOTime && now <= endICOTime );\n', '        require(msg.value >= 0.1 ether && msg.value <= 100 ether);\n', '        \n', '        uint256  dayNum = ((now - startICOTime) / 1 days) + 1;\n', '        daysnumber = dayNum;\n', '         assert(daySellMap[dayNum] <= dayLimit);\n', '         uint256 amount = 0;\n', '        if(now < (startICOTime + 1 weeks) && leftICOTokens > milestone1){\n', '               \n', '                if(msg.value * 320000 <= (leftICOTokens - milestone1))\n', '                { \n', '                     amount = msg.value * 320000;\n', '                }else{\n', '                   uint256 priceOneEther1 =  (leftICOTokens - milestone1)/320000;\n', '                     amount = (msg.value - priceOneEther1) * 250000 + priceOneEther1 * 320000;\n', '                }\n', '        }else{\n', '           if(leftICOTokens > milestone2){\n', '                if(msg.value * 250000 <= (leftICOTokens - milestone2))\n', '                {\n', '                   amount = msg.value * 250000;\n', '                }else{\n', '                   uint256 priceOneEther2 =  (leftICOTokens - milestone2)/250000;\n', '                   amount = (msg.value - priceOneEther2) * 180000 + priceOneEther2 * 250000;\n', '                }\n', '            }else{\n', '               assert(msg.value * 180000 <= leftICOTokens);\n', '            if((leftICOTokens - msg.value * 180000) < 18000 && msg.value * 180000 <= 100 * 180000 * (10 ** 18)){\n', '                  amount = leftICOTokens;\n', '            }else{\n', '                 amount = msg.value * 180000;\n', '            }\n', '            }\n', '        }\n', '           if(amount >= 18000 * (10 ** 18) && amount <= 320000 * 100 * (10 ** 18)){\n', '              leftICOTokens = safeSub(leftICOTokens,amount);\n', '              pendingBalanceMap[msg.sender] = safeAdd(pendingBalanceMap[msg.sender], amount);\n', '              totalBuyMap[msg.sender] = safeAdd(totalBuyMap[msg.sender], amount);\n', '              daySellMap[dayNum] += amount;\n', '              totalBuyerETHMap[msg.sender] = safeAdd(totalBuyerETHMap[msg.sender],msg.value);\n', '              tatalEthFromBuyer += msg.value;\n', '              return;\n', '          }else{\n', '               revert();\n', '          }\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
['pragma solidity ^0.4.22;\n', '\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() internal {\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public constant returns (address) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract YooStop is Owned{\n', '\n', '    bool public stopped = true;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public ownerOnly{\n', '        stopped = true;\n', '    }\n', '    function start() public ownerOnly{\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract YoobaICO is  Owned,YooStop,Utils {\n', '    IERC20Token public yoobaTokenAddress;\n', '    uint256 public startICOTime = 0;  \n', '    uint256 public endICOTime = 0;  \n', '    uint256 public leftICOTokens = 0;\n', '    uint256 public tatalEthFromBuyer = 0;\n', '    uint256 public daysnumber = 0;\n', '    mapping (address => uint256) public pendingBalanceMap;\n', '    mapping (address => uint256) public totalBuyMap;\n', '    mapping (address => uint256) public totalBuyerETHMap;\n', '    mapping (uint256 => uint256) public daySellMap;\n', '    mapping (address => uint256) public withdrawYOOMap;\n', '    uint256 internal milestone1 = 4000000000000000000000000000;\n', '    uint256 internal milestone2 = 2500000000000000000000000000;\n', '       uint256 internal dayLimit = 300000000000000000000000000;\n', '    bool internal hasInitLeftICOTokens = false;\n', '\n', '\n', '\n', '    /**\n', '        @dev constructor\n', '        \n', '    */\n', '    function YoobaICO(IERC20Token _yoobaTokenAddress) public{\n', '         yoobaTokenAddress = _yoobaTokenAddress;\n', '    }\n', '    \n', '\n', '    function startICO(uint256 _startICOTime,uint256 _endICOTime) public ownerOnly {\n', '        startICOTime = _startICOTime;\n', '        endICOTime = _endICOTime;\n', '    }\n', '    \n', '    function initLeftICOTokens() public ownerOnly{\n', '        require(!hasInitLeftICOTokens);\n', '       leftICOTokens = yoobaTokenAddress.balanceOf(this);\n', '       hasInitLeftICOTokens = true;\n', '    }\n', '    function setLeftICOTokens(uint256 left) public ownerOnly {\n', '        leftICOTokens = left;\n', '    }\n', '    function setDaySellAmount(uint256 _dayNum,uint256 _sellAmount) public ownerOnly {\n', '        daySellMap[_dayNum] = _sellAmount;\n', '    }\n', '    \n', '    function withdrawTo(address _to, uint256 _amount) public ownerOnly notThis(_to)\n', '    {   \n', '        require(_amount <= this.balance);\n', '        _to.transfer(_amount); // send the amount to the target account\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '\n', '    }\n', '    \n', '    function withdrawToBuyer(IERC20Token _token,address[] _to)  public ownerOnly {\n', '        require(_to.length > 0  && _to.length < 10000);\n', '        for(uint16 i = 0; i < _to.length ;i++){\n', '            if(pendingBalanceMap[_to[i]] > 0){\n', '                assert(_token.transfer(_to[i],pendingBalanceMap[_to[i]])); \n', '                withdrawYOOMap[_to[i]] = safeAdd(withdrawYOOMap[_to[i]],pendingBalanceMap[_to[i]]);\n', '                pendingBalanceMap[_to[i]] = 0;\n', '            }\n', '         \n', '        }\n', '    }\n', '    \n', '      function withdrawToBuyer(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '        withdrawYOOMap[_to] = safeAdd(withdrawYOOMap[_to],_amount);\n', '        pendingBalanceMap[_to] = safeSub(pendingBalanceMap[_to],_amount);\n', '\n', '    }\n', '    \n', '    function refund(address[] _to) public ownerOnly{\n', '        require(_to.length > 0  && _to.length < 10000 );\n', '        for(uint16 i = 0; i < _to.length ;i++){\n', '            if(pendingBalanceMap[_to[i]] > 0 && withdrawYOOMap[_to[i]] == 0 && totalBuyerETHMap[_to[i]] > 0 && totalBuyMap[_to[i]] > 0){\n', '                 if(totalBuyerETHMap[_to[i]] <= this.balance){\n', '                _to[i].transfer(totalBuyerETHMap[_to[i]]); \n', '                tatalEthFromBuyer = tatalEthFromBuyer - totalBuyerETHMap[_to[i]];\n', '                leftICOTokens = leftICOTokens + pendingBalanceMap[_to[i]];\n', '                totalBuyerETHMap[_to[i]] = 0;\n', '                pendingBalanceMap[_to[i]] = 0; \n', '                totalBuyMap[_to[i]] = 0;\n', '              \n', '                 }\n', '            }\n', '         \n', '        }\n', '    }\n', '  \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && now >= startICOTime && now <= endICOTime );\n', '        require(msg.value >= 0.1 ether && msg.value <= 100 ether);\n', '        \n', '        uint256  dayNum = ((now - startICOTime) / 1 days) + 1;\n', '        daysnumber = dayNum;\n', '         assert(daySellMap[dayNum] <= dayLimit);\n', '         uint256 amount = 0;\n', '        if(now < (startICOTime + 1 weeks) && leftICOTokens > milestone1){\n', '               \n', '                if(msg.value * 320000 <= (leftICOTokens - milestone1))\n', '                { \n', '                     amount = msg.value * 320000;\n', '                }else{\n', '                   uint256 priceOneEther1 =  (leftICOTokens - milestone1)/320000;\n', '                     amount = (msg.value - priceOneEther1) * 250000 + priceOneEther1 * 320000;\n', '                }\n', '        }else{\n', '           if(leftICOTokens > milestone2){\n', '                if(msg.value * 250000 <= (leftICOTokens - milestone2))\n', '                {\n', '                   amount = msg.value * 250000;\n', '                }else{\n', '                   uint256 priceOneEther2 =  (leftICOTokens - milestone2)/250000;\n', '                   amount = (msg.value - priceOneEther2) * 180000 + priceOneEther2 * 250000;\n', '                }\n', '            }else{\n', '               assert(msg.value * 180000 <= leftICOTokens);\n', '            if((leftICOTokens - msg.value * 180000) < 18000 && msg.value * 180000 <= 100 * 180000 * (10 ** 18)){\n', '                  amount = leftICOTokens;\n', '            }else{\n', '                 amount = msg.value * 180000;\n', '            }\n', '            }\n', '        }\n', '           if(amount >= 18000 * (10 ** 18) && amount <= 320000 * 100 * (10 ** 18)){\n', '              leftICOTokens = safeSub(leftICOTokens,amount);\n', '              pendingBalanceMap[msg.sender] = safeAdd(pendingBalanceMap[msg.sender], amount);\n', '              totalBuyMap[msg.sender] = safeAdd(totalBuyMap[msg.sender], amount);\n', '              daySellMap[dayNum] += amount;\n', '              totalBuyerETHMap[msg.sender] = safeAdd(totalBuyerETHMap[msg.sender],msg.value);\n', '              tatalEthFromBuyer += msg.value;\n', '              return;\n', '          }else{\n', '               revert();\n', '          }\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
