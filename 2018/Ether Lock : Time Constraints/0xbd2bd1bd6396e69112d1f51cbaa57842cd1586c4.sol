['pragma solidity ^0.4.0;\n', '\n', 'contract GameEthContractV1{\n', '\n', 'address owner;\n', 'mapping (address => uint256) deposits;\n', 'mapping (address => uint256) totalPaid;\n', 'mapping (address => uint256) paydates;\n', 'mapping (address => uint256) notToPay;\n', '\n', 'uint minWei = 40000000000000000; // default 0.04 ether\n', 'uint secInDay = 86400; // min payment step 1 day (in seconds)\n', 'uint gasForPayout = 50000; // gas used for payout\n', 'uint lastBlockTime;\n', 'uint inCommission = 3; // deposit commission 3%\n', '\n', 'event DepositIn(\n', '        address indexed _from,\n', '        uint256 _value,\n', '        uint256 _date\n', '    );\n', '    \n', 'event PayOut(\n', '        address indexed _from,\n', '        uint256 _value,\n', '        uint256 _date\n', '    );\n', '    \n', '\n', 'constructor(address _owner) public {\n', '\towner = _owner; \n', '\tlastBlockTime = now;\n', '}\n', '\n', '// Payable method, payouts for message sender\n', 'function () public payable{\n', ' \trequire(now >= lastBlockTime && msg.value >= minWei); // last block time < block.timestamp, check min deposit\n', ' \tlastBlockTime = now; // set last block time to block.timestamp\n', ' \tuint256 com = msg.value/100*inCommission; // 3% commission\n', ' \tuint256 amount = msg.value - com; // deposit amount is amount - commission\n', ' \tif (deposits[msg.sender] > 0){\n', ' \t\t// repeating payment\n', ' \t\tuint256 daysGone = (now - paydates[msg.sender]) / secInDay;\t// days gone before this payment, and not included in next payout\n', ' \t\tnotToPay[msg.sender] += amount/100*daysGone; // keep amount that does not have to be paid \n', ' \t}else{\n', ' \t\t// new payment \n', ' \t\tpaydates[msg.sender] = now; // set paydate to block.timestamp\n', ' \t}\n', '    deposits[msg.sender] += amount; // update deposit amount\n', '    emit DepositIn(msg.sender, msg.value, now); // emit deposit in event\n', '    owner.transfer(com); // transfer commission to contract owner\n', '}\n', '\n', '// Payable method, payout will be paid to specific address\n', 'function  depositForRecipent(address payoutAddress) public  payable{\n', ' \trequire(now >= lastBlockTime && msg.value >= minWei); // last block time < block.timestamp, check min deposit\n', ' \tlastBlockTime = now; // set last block time to block.timestamp\n', ' \tuint256 com = msg.value/100*inCommission; // 3% commission\n', ' \tuint256 amount = msg.value - com; // deposit amount is amount - commission\n', ' \tif (deposits[payoutAddress] > 0){\n', ' \t\t// repeating payment\n', ' \t\tuint256 daysGone = (now - paydates[payoutAddress]) / secInDay;\t// days gone before this payment, and not included in next payout\n', ' \t\tnotToPay[payoutAddress] += amount/100*daysGone; // keep amount that does not have to be paid \n', ' \t}else{\n', ' \t\t// new payment\n', ' \t\tpaydates[payoutAddress] = now; // set paydate to block.timestamp\n', ' \t}\n', '    deposits[payoutAddress] += amount; // update deposit amount\n', '    emit DepositIn(payoutAddress, msg.value, now); // emit deposit in event\n', '    owner.transfer(com); // transfer commission to contract owner\n', '}\n', '\n', '// transfer ownership\n', 'function transferOwnership(address newOwnerAddress) public {\n', '\trequire (msg.sender == owner); // check function called by contract owner\n', '\towner = newOwnerAddress;\n', '}\n', '\n', '\n', '// function used by client direct calls, for direct contract interaction, gas paid by function caller in this case\n', 'function payOut() public {\n', '\t\trequire(deposits[msg.sender] > 0); // check is message sender deposited an funds\n', '\t\trequire(paydates[msg.sender] < now); // check is lastPayDate < block.timestamp \n', '\t\tuint256 payForDays = (now - paydates[msg.sender]) / secInDay; // days from last payment\n', '        require(payForDays >= 30);\n', "\t\tpay(msg.sender,false,payForDays); // don't withdraw tx gass fee, because fee paid by function caller\n", '}\n', '\n', '// function used by contrcat owner for automatic payouts from representative site\n', '// gas price paid by contract owner and because of that gasPrice will be withdrawn from payout amount\n', 'function payOutFor(address _recipient) public {\n', '\t\trequire(msg.sender == owner && deposits[_recipient] > 0); // check is message sender is contract owner and recipients was deposited funds\n', '\t\trequire(paydates[_recipient] < now); // check is lastPayDate < block.timestamp\n', '\t\tuint256 payForDays = (now - paydates[_recipient]) / secInDay; // days from last payment\n', '        require(payForDays >= 30); \n', '\t\tpay(_recipient, true,payForDays); // pay with withdraw tx gas fee because fee paid by contract owner\n', '}\n', '\n', '\n', 'function pay(address _recipient, bool calcGasPrice,uint256 payForDays) private {\n', '        uint256 payAmount = 0;\n', '        payAmount = deposits[_recipient]/100*payForDays - notToPay[_recipient]; // calculate payout one percent per day - amount that does not have to be paid\n', '        if (payAmount >= address(this).balance){\n', '        \tpayAmount = address(this).balance;\n', '        }\n', '        assert(payAmount > 0); // check is pay amount > 0 and payAmount <= contract balance \n', '        if (calcGasPrice){\n', '        \t// if calcGasPrice calculate tx gas price to cover transaction fee\n', '        \tuint256 com = gasForPayout * tx.gasprice; // fixed gas per tx * tx.gasprice\n', '        \tassert(com < payAmount);   // commission must be < pay amount\n', '        \tpayAmount = payAmount - com; // remaining pay amount = pay amount - commission\n', '        \towner.transfer(com); // withdraw tx gas fee to contract owner\n', '        }\n', '        paydates[_recipient] = now; // update last pay date to block.timestamp\n', '        _recipient.transfer(payAmount); // transfer funds to recipient\n', '        totalPaid[_recipient] += payAmount; // update total paid amount\n', '        notToPay[_recipient] = 0; // clear not to pay amount\n', '        emit PayOut(_recipient, payAmount, now);  // emit event\n', '}\n', '\n', '\n', '\n', 'function totalDepositOf(address _sender) public constant returns (uint256 deposit) {\n', '        return deposits[_sender];\n', '}\n', '\n', 'function lastPayDateOf(address _sender) public constant returns (uint256 secFromEpoch) {\n', '        return paydates[_sender];\n', '}\n', '\n', 'function totalPaidOf(address _sender) public constant returns (uint256 paid) {\n', '        return totalPaid[_sender];\n', '}\n', '\n', '}']