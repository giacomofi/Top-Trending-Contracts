['pragma solidity ^0.4.15;\n', '\n', 'contract MembranaDeals {\n', '  address public be = 0x873A2832898b17b5C12355769A7E2DAe6c2f92f7;\n', '  enum state { paid, verified, halted, finished}\n', '  enum currencyType { USDT, BTC, ETH}\n', '  struct Deal {\n', '    state  currentState;\n', '    uint  start;\n', '    uint  deadline;\n', '    uint  maxLoss;\n', '    uint  startBalance;\n', '    uint  targetBalance;\n', '    uint  amount;\n', '    currencyType  currency;\n', '    string  investor;\n', '    address  investorAddress;\n', '    string  trader;\n', '    address  traderAddress;\n', '  }\n', '  Deal[] public deals;\n', '  function MercatusDeals() public payable{\n', '    revert();\n', '  }\n', '  modifier onlyBe() {\n', '   require(msg.sender == be);\n', '   _;\n', ' }\n', '  modifier inState(uint dealId, state s) {\n', '   require(deals[dealId].currentState == s);\n', '   _;\n', ' }\n', ' function getState(uint dealId) public constant returns (uint)  {\n', '   return uint(deals[dealId].currentState);\n', ' }\n', ' function getStart(uint dealId) public constant returns (uint)  {\n', '   return deals[dealId].start;\n', ' }\n', ' function setVerified(uint dealId) public  onlyBe inState(dealId, state.paid) {\n', '     deals[dealId].currentState = state.verified;\n', '}\n', '\n', ' function setHalted(uint dealId) public  onlyBe {\n', '     require(deals[dealId].currentState == state.paid || deals[dealId].currentState == state.verified);\n', '     require(deals[dealId].amount != 0);\n', '     deals[dealId].amount = 0;\n', '     deals[dealId].traderAddress.transfer(deals[dealId].amount);\n', '     deals[dealId].currentState = state.halted;\n', '}\n', 'function getSplit(uint finishAmount, uint startBalance, uint targetBalance, uint amount) public pure returns (uint) {\n', '    return ((finishAmount - startBalance) * amount) / ((targetBalance - startBalance) );\n', '}\n', ' function setFinished(uint dealId, uint finishAmount) public  onlyBe inState(dealId, state.verified) {\n', '     require(deals[dealId].amount != 0);\n', '     deals[dealId].amount = 0;\n', '     if(finishAmount <= deals[dealId].startBalance){\n', '       deals[dealId].investorAddress.transfer(deals[dealId].amount);\n', '     }else if(finishAmount>deals[dealId].targetBalance){\n', '       deals[dealId].traderAddress.transfer(deals[dealId].amount);\n', '     }\n', '     else{\n', '        uint split = getSplit(finishAmount, deals[dealId].startBalance, deals[dealId].targetBalance, deals[dealId].amount);\n', '        deals[dealId].traderAddress.transfer(split);\n', '        deals[dealId].investorAddress.transfer(deals[dealId].amount - split);\n', '     }\n', '     deals[dealId].currentState = state.finished;\n', '}\n', '    function getDealsCount() public constant returns (uint){\n', '        return deals.length;\n', '    }\n', 'function () external payable  {\n', '  revert();\n', '}\n', '    function makeDeal(uint _duration, uint _maxLoss, uint _startBalance, uint _targetBalance, uint _amount,  string _investor, address _investorAddress, string _trader, address _traderAddress, uint offer, uint _currency)\n', '    payable public {\n', '      require( _currency >= 0 &&  _currency < 3  );\n', '      require(msg.value == _amount);\n', '        deals.push(Deal({\n', '            currentState: state.paid,\n', '            start: now,\n', '            deadline: 0,\n', '            maxLoss: _maxLoss,\n', '            startBalance: _startBalance,\n', '            targetBalance: _targetBalance,\n', '            amount: _amount,\n', '            currency: currencyType(_currency),\n', '            investor: _investor,\n', '            investorAddress: _investorAddress,\n', '            trader: _trader,\n', '            traderAddress: _traderAddress\n', '          }));\n', '          deals[deals.length-1].deadline = now +  _duration * 86400;\n', '        spawnInstance(msg.sender,deals.length-1, now, offer);\n', '    }\n', '    event spawnInstance(address indexed from, uint indexed dealId, uint start, uint offer);\n', '}']