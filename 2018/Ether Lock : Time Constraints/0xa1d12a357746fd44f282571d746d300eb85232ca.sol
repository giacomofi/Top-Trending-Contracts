['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' * ETHCutter Contract\n', ' * \n', ' * - 1% per hour for 5 days (120% total)\n', ' * - 6% referral program (1 level)\n', ' * - 0.1-100 ETH per deposit (unlimited deposits count)\n', ' * \n', ' *  1. Set an address of you upline in DATA field (if exists), and send 0.1-100 ETH to contract address. Gas limit: 300000.\n', ' *  2. Send 0 or not more than 0.1 ETH and get your profit. You can get profit at any time (every minute, every hour, every day).\n', ' *\n', ' * EMAIL: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0e6b7a666d7b7a7a6b7c4e69636f6762206d6163">[email&#160;protected]</a>\n', ' * TELEGRAM SUPPORT 24/7: https://t.me/ethcutter_support or tg://resolve?domain=ethcutter_support\n', ' * TELEGRAM CHAT (RU): https://t.me/ethcutter_ru or tg://resolve?domain=ethcutter_ru\n', ' * TELEGRAM CHAT (EN): https://t.me/ethcutter_en or tg://resolve?domain=ethcutter_en\n', ' */\n', '\n', 'library SafeMath {\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        c = _a * _b;\n', '        require(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        require(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library AddressUtils {\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {size := extcodesize(_addr)}\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library Helpers {\n', '    function walletFromData(bytes data) internal pure returns (address wallet) {\n', '        assembly {\n', '            wallet := mload(add(data, 20))\n', '        }\n', '    }\n', '}\n', '\n', 'contract ETHCutter {\n', '    using SafeMath for uint256;\n', '    using AddressUtils for address;\n', '\n', '    address public adminWallet;\n', '\n', '    uint256 constant public DEPOSIT_MIN = 10 finney;\n', '    uint256 constant public DEPOSIT_MAX = 10 ether;\n', '    uint256 constant public DEPOSIT_PERIOD = 5 days;\n', '    uint256 constant public TOTAL_PERCENT = 120;\n', '    uint256 constant public UPLINE_PERCENT = 6;\n', '    uint256 constant public EXPENSES_PERCENT = 15;\n', '\n', '    uint256 public totalDeposited = 0;\n', '    uint256 public totalWithdrawn = 0;\n', '    uint256 public usersCount = 0;\n', '    uint256 public depositsCount = 0;\n', '    uint256 public expenses = 0;\n', '\n', '    mapping(address => User) public users;\n', '    mapping(uint256 => Deposit) public deposits;\n', '\n', '    struct Deposit {\n', '        uint256 createdAt;\n', '        uint256 endAt;\n', '        uint256 amount;\n', '        uint256 accrued;\n', '        uint256 totalForAccrual;\n', '        bool active;\n', '    }\n', '\n', '    struct User {\n', '        uint256 createdAt;\n', '        address upline;\n', '        uint256 totalDeposited;\n', '        uint256 totalWithdrawn;\n', '        uint256 depositsCount;\n', '        uint256[] deposits;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == adminWallet);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        adminWallet = msg.sender;\n', '        createUser(msg.sender, address(0));\n', '    }\n', '\n', '    function createUser(address wallet, address upline) internal {\n', '        users[wallet] = User({\n', '            createdAt : now,\n', '            upline : upline,\n', '            totalDeposited : 0,\n', '            totalWithdrawn : 0,\n', '            depositsCount : 0,\n', '            deposits : new uint256[](0)\n', '            });\n', '        usersCount++;\n', '    }\n', '\n', '    function createDeposit(address wallet, uint256 amount) internal {\n', '        User storage user = users[wallet];\n', '\n', '        Deposit memory deposit = Deposit({\n', '            createdAt : now,\n', '            endAt : now.add(DEPOSIT_PERIOD),\n', '            amount : amount,\n', '            accrued : 0,\n', '            totalForAccrual : amount.div(100).mul(TOTAL_PERCENT),\n', '            active : true\n', '        });\n', '\n', '        deposits[depositsCount] = deposit;\n', '        user.deposits.push(depositsCount);\n', '\n', '        user.totalDeposited = user.totalDeposited.add(amount);\n', '        totalDeposited = amount.add(totalDeposited);\n', '\n', '        user.depositsCount++;\n', '        depositsCount++;\n', '        expenses = expenses.add(amount.div(100).mul(EXPENSES_PERCENT));\n', '\n', '        uint256 referralFee = amount.div(100).mul(UPLINE_PERCENT);\n', '        transferReferralFee(user.upline, referralFee);\n', '    }\n', '\n', '    function transferReferralFee(address to, uint256 amount) internal {\n', '        if (to != address(0)) {\n', '            to.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function getUpline() internal view returns (address){\n', '        address uplineWallet = Helpers.walletFromData(msg.data);\n', '        return users[uplineWallet].createdAt > 0 && msg.sender != uplineWallet\n', '        ? uplineWallet\n', '        : adminWallet;\n', '    }\n', '\n', '    function() payable public {\n', '        address wallet = msg.sender;\n', '        uint256 amount = msg.value;\n', '\n', '        require(wallet != address(0), &#39;Address incorrect&#39;);\n', '        require(!wallet.isContract(), &#39;Address is contract&#39;);\n', '        require(amount <= DEPOSIT_MAX, &#39;Amount too big&#39;);\n', '\n', '        if (users[wallet].createdAt == 0) {\n', '            createUser(wallet, getUpline());\n', '        }\n', '\n', '        if (amount >= DEPOSIT_MIN) {\n', '            createDeposit(wallet, amount);\n', '        } else {\n', '            accrualDeposits();\n', '        }\n', '    }\n', '\n', '    function accrualDeposits() internal {\n', '        address wallet = msg.sender;\n', '        User storage user = users[wallet];\n', '\n', '        for (uint i = 0; i < user.depositsCount; i++) {\n', '            if (deposits[user.deposits[i]].active) {\n', '                accrual(user.deposits[i], wallet);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getAccrualAmount(Deposit deposit) internal view returns (uint256){\n', '        uint256 amount = deposit.totalForAccrual\n', '        .div(DEPOSIT_PERIOD)\n', '        .mul(\n', '            now.sub(deposit.createdAt)\n', '        )\n', '        .sub(deposit.accrued);\n', '\n', '        if (amount.add(deposit.accrued) > deposit.totalForAccrual) {\n', '            amount = deposit.totalForAccrual.sub(deposit.accrued);\n', '        }\n', '\n', '        return amount;\n', '    }\n', '\n', '    function accrual(uint256 depositId, address wallet) internal {\n', '        uint256 amount = getAccrualAmount(deposits[depositId]);\n', '        Deposit storage deposit = deposits[depositId];\n', '\n', '        withdraw(wallet, amount);\n', '\n', '        deposits[depositId].accrued = deposit.accrued.add(amount);\n', '\n', '        if (deposits[depositId].accrued >= deposit.totalForAccrual) {\n', '            deposits[depositId].active = false;\n', '        }\n', '    }\n', '\n', '    function withdraw(address wallet, uint256 amount) internal {\n', '        wallet.transfer(amount);\n', '        totalWithdrawn = totalWithdrawn.add(amount);\n', '        users[wallet].totalWithdrawn = users[wallet].totalWithdrawn.add(amount);\n', '    }\n', '\n', '    function withdrawExpenses() public onlyAdmin {\n', '        adminWallet.transfer(expenses);\n', '        expenses = 0;\n', '    }\n', '\n', '    function getUserDeposits(address _address) public view returns (uint256[]){\n', '        return users[_address].deposits;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' * ETHCutter Contract\n', ' * \n', ' * - 1% per hour for 5 days (120% total)\n', ' * - 6% referral program (1 level)\n', ' * - 0.1-100 ETH per deposit (unlimited deposits count)\n', ' * \n', ' *  1. Set an address of you upline in DATA field (if exists), and send 0.1-100 ETH to contract address. Gas limit: 300000.\n', ' *  2. Send 0 or not more than 0.1 ETH and get your profit. You can get profit at any time (every minute, every hour, every day).\n', ' *\n', ' * EMAIL: ethcutter@gmail.com\n', ' * TELEGRAM SUPPORT 24/7: https://t.me/ethcutter_support or tg://resolve?domain=ethcutter_support\n', ' * TELEGRAM CHAT (RU): https://t.me/ethcutter_ru or tg://resolve?domain=ethcutter_ru\n', ' * TELEGRAM CHAT (EN): https://t.me/ethcutter_en or tg://resolve?domain=ethcutter_en\n', ' */\n', '\n', 'library SafeMath {\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        c = _a * _b;\n', '        require(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        require(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library AddressUtils {\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {size := extcodesize(_addr)}\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library Helpers {\n', '    function walletFromData(bytes data) internal pure returns (address wallet) {\n', '        assembly {\n', '            wallet := mload(add(data, 20))\n', '        }\n', '    }\n', '}\n', '\n', 'contract ETHCutter {\n', '    using SafeMath for uint256;\n', '    using AddressUtils for address;\n', '\n', '    address public adminWallet;\n', '\n', '    uint256 constant public DEPOSIT_MIN = 10 finney;\n', '    uint256 constant public DEPOSIT_MAX = 10 ether;\n', '    uint256 constant public DEPOSIT_PERIOD = 5 days;\n', '    uint256 constant public TOTAL_PERCENT = 120;\n', '    uint256 constant public UPLINE_PERCENT = 6;\n', '    uint256 constant public EXPENSES_PERCENT = 15;\n', '\n', '    uint256 public totalDeposited = 0;\n', '    uint256 public totalWithdrawn = 0;\n', '    uint256 public usersCount = 0;\n', '    uint256 public depositsCount = 0;\n', '    uint256 public expenses = 0;\n', '\n', '    mapping(address => User) public users;\n', '    mapping(uint256 => Deposit) public deposits;\n', '\n', '    struct Deposit {\n', '        uint256 createdAt;\n', '        uint256 endAt;\n', '        uint256 amount;\n', '        uint256 accrued;\n', '        uint256 totalForAccrual;\n', '        bool active;\n', '    }\n', '\n', '    struct User {\n', '        uint256 createdAt;\n', '        address upline;\n', '        uint256 totalDeposited;\n', '        uint256 totalWithdrawn;\n', '        uint256 depositsCount;\n', '        uint256[] deposits;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == adminWallet);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        adminWallet = msg.sender;\n', '        createUser(msg.sender, address(0));\n', '    }\n', '\n', '    function createUser(address wallet, address upline) internal {\n', '        users[wallet] = User({\n', '            createdAt : now,\n', '            upline : upline,\n', '            totalDeposited : 0,\n', '            totalWithdrawn : 0,\n', '            depositsCount : 0,\n', '            deposits : new uint256[](0)\n', '            });\n', '        usersCount++;\n', '    }\n', '\n', '    function createDeposit(address wallet, uint256 amount) internal {\n', '        User storage user = users[wallet];\n', '\n', '        Deposit memory deposit = Deposit({\n', '            createdAt : now,\n', '            endAt : now.add(DEPOSIT_PERIOD),\n', '            amount : amount,\n', '            accrued : 0,\n', '            totalForAccrual : amount.div(100).mul(TOTAL_PERCENT),\n', '            active : true\n', '        });\n', '\n', '        deposits[depositsCount] = deposit;\n', '        user.deposits.push(depositsCount);\n', '\n', '        user.totalDeposited = user.totalDeposited.add(amount);\n', '        totalDeposited = amount.add(totalDeposited);\n', '\n', '        user.depositsCount++;\n', '        depositsCount++;\n', '        expenses = expenses.add(amount.div(100).mul(EXPENSES_PERCENT));\n', '\n', '        uint256 referralFee = amount.div(100).mul(UPLINE_PERCENT);\n', '        transferReferralFee(user.upline, referralFee);\n', '    }\n', '\n', '    function transferReferralFee(address to, uint256 amount) internal {\n', '        if (to != address(0)) {\n', '            to.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function getUpline() internal view returns (address){\n', '        address uplineWallet = Helpers.walletFromData(msg.data);\n', '        return users[uplineWallet].createdAt > 0 && msg.sender != uplineWallet\n', '        ? uplineWallet\n', '        : adminWallet;\n', '    }\n', '\n', '    function() payable public {\n', '        address wallet = msg.sender;\n', '        uint256 amount = msg.value;\n', '\n', "        require(wallet != address(0), 'Address incorrect');\n", "        require(!wallet.isContract(), 'Address is contract');\n", "        require(amount <= DEPOSIT_MAX, 'Amount too big');\n", '\n', '        if (users[wallet].createdAt == 0) {\n', '            createUser(wallet, getUpline());\n', '        }\n', '\n', '        if (amount >= DEPOSIT_MIN) {\n', '            createDeposit(wallet, amount);\n', '        } else {\n', '            accrualDeposits();\n', '        }\n', '    }\n', '\n', '    function accrualDeposits() internal {\n', '        address wallet = msg.sender;\n', '        User storage user = users[wallet];\n', '\n', '        for (uint i = 0; i < user.depositsCount; i++) {\n', '            if (deposits[user.deposits[i]].active) {\n', '                accrual(user.deposits[i], wallet);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getAccrualAmount(Deposit deposit) internal view returns (uint256){\n', '        uint256 amount = deposit.totalForAccrual\n', '        .div(DEPOSIT_PERIOD)\n', '        .mul(\n', '            now.sub(deposit.createdAt)\n', '        )\n', '        .sub(deposit.accrued);\n', '\n', '        if (amount.add(deposit.accrued) > deposit.totalForAccrual) {\n', '            amount = deposit.totalForAccrual.sub(deposit.accrued);\n', '        }\n', '\n', '        return amount;\n', '    }\n', '\n', '    function accrual(uint256 depositId, address wallet) internal {\n', '        uint256 amount = getAccrualAmount(deposits[depositId]);\n', '        Deposit storage deposit = deposits[depositId];\n', '\n', '        withdraw(wallet, amount);\n', '\n', '        deposits[depositId].accrued = deposit.accrued.add(amount);\n', '\n', '        if (deposits[depositId].accrued >= deposit.totalForAccrual) {\n', '            deposits[depositId].active = false;\n', '        }\n', '    }\n', '\n', '    function withdraw(address wallet, uint256 amount) internal {\n', '        wallet.transfer(amount);\n', '        totalWithdrawn = totalWithdrawn.add(amount);\n', '        users[wallet].totalWithdrawn = users[wallet].totalWithdrawn.add(amount);\n', '    }\n', '\n', '    function withdrawExpenses() public onlyAdmin {\n', '        adminWallet.transfer(expenses);\n', '        expenses = 0;\n', '    }\n', '\n', '    function getUserDeposits(address _address) public view returns (uint256[]){\n', '        return users[_address].deposits;\n', '    }\n', '\n', '}']
