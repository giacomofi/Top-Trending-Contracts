['pragma solidity ^0.4.24;\n', '\n', 'contract TokenInfo {\n', '    // Base prices in wei, going off from an Ether value of $500\n', '    uint256 public constant PRIVATESALE_BASE_PRICE_IN_WEI = 200000000000000;\n', '    uint256 public constant PRESALE_BASE_PRICE_IN_WEI = 600000000000000;\n', '    uint256 public constant ICO_BASE_PRICE_IN_WEI = 800000000000000;\n', '    uint256 public constant FIRSTSALE_BASE_PRICE_IN_WEI = 200000000000000;\n', '\n', '    // First sale minimum and maximum contribution, going off from an Ether value of $500\n', '    uint256 public constant MIN_PURCHASE_OTHERSALES = 80000000000000000;\n', '    uint256 public constant MIN_PURCHASE = 1000000000000000000;\n', '    uint256 public constant MAX_PURCHASE = 1000000000000000000000;\n', '\n', '    // Bonus percentages for each respective sale level\n', '\n', '    uint256 public constant PRESALE_PERCENTAGE_1 = 10;\n', '    uint256 public constant PRESALE_PERCENTAGE_2 = 15;\n', '    uint256 public constant PRESALE_PERCENTAGE_3 = 20;\n', '    uint256 public constant PRESALE_PERCENTAGE_4 = 25;\n', '    uint256 public constant PRESALE_PERCENTAGE_5 = 35;\n', '\n', '    uint256 public constant ICO_PERCENTAGE_1 = 5;\n', '    uint256 public constant ICO_PERCENTAGE_2 = 10;\n', '    uint256 public constant ICO_PERCENTAGE_3 = 15;\n', '    uint256 public constant ICO_PERCENTAGE_4 = 20;\n', '    uint256 public constant ICO_PERCENTAGE_5 = 25;\n', '\n', '    // Bonus levels in wei for each respective level\n', '\n', '    uint256 public constant PRESALE_LEVEL_1 = 5000000000000000000;\n', '    uint256 public constant PRESALE_LEVEL_2 = 10000000000000000000;\n', '    uint256 public constant PRESALE_LEVEL_3 = 15000000000000000000;\n', '    uint256 public constant PRESALE_LEVEL_4 = 20000000000000000000;\n', '    uint256 public constant PRESALE_LEVEL_5 = 25000000000000000000;\n', '\n', '    uint256 public constant ICO_LEVEL_1 = 6666666666666666666;\n', '    uint256 public constant ICO_LEVEL_2 = 13333333333333333333;\n', '    uint256 public constant ICO_LEVEL_3 = 20000000000000000000;\n', '    uint256 public constant ICO_LEVEL_4 = 26666666666666666666;\n', '    uint256 public constant ICO_LEVEL_5 = 33333333333333333333;\n', '\n', '    // Caps for the respective sales, the amount of tokens allocated to the team and the total cap\n', '    uint256 public constant PRIVATESALE_TOKENCAP = 18750000;\n', '    uint256 public constant PRESALE_TOKENCAP = 18750000;\n', '    uint256 public constant ICO_TOKENCAP = 22500000;\n', '    uint256 public constant FIRSTSALE_TOKENCAP = 5000000;\n', '    uint256 public constant LEDTEAM_TOKENS = 35000000;\n', '    uint256 public constant TOTAL_TOKENCAP = 100000000;\n', '\n', '    uint256 public constant DECIMALS_MULTIPLIER = 1 ether;\n', '\n', '    address public constant LED_MULTISIG = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  constructor() public {}\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    emit Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    emit Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract ApproveAndCallReceiver {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '/**\n', ' * @title Controllable\n', ' * @dev The Controllable contract has an controller address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Controllable {\n', '  address public controller;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor() public {\n', '    controller = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyController() {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newController The address to transfer ownership to.\n', '   */\n', '  function transferControl(address newController) public onlyController {\n', '    if (newController != address(0)) {\n', '      controller = newController;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract ControllerInterface {\n', '\n', '    function proxyPayment(address _owner) public payable returns(bool);\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '\n', '  uint256 public totalSupply;\n', '\n', '  function balanceOf(address _owner) public constant returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool);\n', '  function approve(address _spender, uint256 _amount) public returns (bool);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '}\n', '\n', 'contract Crowdsale is Pausable, TokenInfo {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  LedTokenInterface public ledToken;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  uint256 public totalWeiRaised;\n', '  uint256 public tokensMinted;\n', '  uint256 public totalSupply;\n', '  uint256 public contributors;\n', '  uint256 public surplusTokens;\n', '\n', '  bool public finalized;\n', '\n', '  bool public ledTokensAllocated;\n', '  address public ledMultiSig = LED_MULTISIG;\n', '\n', '  //uint256 public tokenCap = FIRSTSALE_TOKENCAP;\n', '  //uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n', '  //uint256 public weiCap = tokenCap * FIRSTSALE_BASE_PRICE_IN_WEI;\n', '\n', '  bool public started = false;\n', '\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  event NewClonedToken(address indexed _cloneToken);\n', '  event OnTransfer(address _from, address _to, uint _amount);\n', '  event OnApprove(address _owner, address _spender, uint _amount);\n', '  event LogInt(string _name, uint256 _value);\n', '  event Finalized();\n', '\n', '  // constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    \n', '\n', '  //   startTime = _startTime;\n', '  //   endTime = _endTime;\n', '  //   ledToken = LedTokenInterface(_tokenAddress);\n', '\n', '  //   assert(_tokenAddress != 0x0);\n', '  //   assert(_startTime > 0);\n', '  //   assert(_endTime > _startTime);\n', '  // }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  /*function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount >= MIN_PURCHASE && weiAmount <= MAX_PURCHASE);\n', '    uint256 priceInWei = FIRSTSALE_BASE_PRICE_IN_WEI;\n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < cap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    ledToken.mint(_beneficiary, tokens);\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }*/\n', '\n', '\n', '  /**\n', '  * Forwards funds to the tokensale wallet\n', '  */\n', '  function forwardFunds() internal {\n', '    ledMultiSig.transfer(msg.value);\n', '  }\n', '\n', '\n', '  /**\n', '  * Validates the purchase (period, minimum amount, within cap)\n', '  * @return {bool} valid\n', '  */\n', '  function validPurchase() internal constant returns (bool) {\n', '    uint256 current = now;\n', '    bool presaleStarted = (current >= startTime || started);\n', '    bool presaleNotEnded = current <= endTime;\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    return nonZeroPurchase && presaleStarted && presaleNotEnded;\n', '  }\n', '\n', '  /**\n', '  * Returns the total Led token supply\n', '  * @return totalSupply {uint256} Led Token Total Supply\n', '  */\n', '  function totalSupply() public constant returns (uint256) {\n', '    return ledToken.totalSupply();\n', '  }\n', '\n', '  /**\n', '  * Returns token holder Led Token balance\n', '  * @param _owner {address} Token holder address\n', '  * @return balance {uint256} Corresponding token holder balance\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256) {\n', '    return ledToken.balanceOf(_owner);\n', '  }\n', '\n', '  /**\n', '  * Change the Led Token controller\n', '  * @param _newController {address} New Led Token controller\n', '  */\n', '  function changeController(address _newController) public onlyOwner {\n', '    require(isContract(_newController));\n', '    ledToken.transferControl(_newController);\n', '  }\n', '\n', '  function enableMasterTransfers() public onlyOwner {\n', '    ledToken.enableMasterTransfers(true);\n', '  }\n', '\n', '  function lockMasterTransfers() public onlyOwner {\n', '    ledToken.enableMasterTransfers(false);\n', '  }\n', '\n', '  function forceStart() public onlyOwner {\n', '    started = true;\n', '  }\n', '\n', '  /*function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(!finalized);\n', '    surplusTokens = cap - tokensMinted;\n', '    ledToken.mint(ledMultiSig, surplusTokens);\n', '    ledToken.transferControl(owner);\n', '\n', '    emit Finalized();\n', '\n', '    finalized = true;\n', '  }*/\n', '\n', '  function isContract(address _addr) constant internal returns(bool) {\n', '    uint size;\n', '    if (_addr == 0)\n', '      return false;\n', '    assembly {\n', '        size := extcodesize(_addr)\n', '    }\n', '    return size>0;\n', '  }\n', '\n', '  modifier whenNotFinalized() {\n', '    require(!finalized);\n', '    _;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title FirstSale\n', ' * FirstSale allows investors to make token purchases and assigns them tokens based\n', '\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet as they arrive.\n', ' */\n', 'contract FirstSale is Crowdsale {\n', '\n', '  uint256 public tokenCap = FIRSTSALE_TOKENCAP;\n', '  uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n', '  uint256 public weiCap = tokenCap * FIRSTSALE_BASE_PRICE_IN_WEI;\n', '\n', '  constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    \n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ledToken = LedTokenInterface(_tokenAddress);\n', '\n', '    assert(_tokenAddress != 0x0);\n', '    assert(_startTime > 0);\n', '    assert(_endTime > _startTime);\n', '  }\n', '\n', '    /**\n', '   * High level token purchase function\n', '   */\n', '  function() public payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount >= MIN_PURCHASE && weiAmount <= MAX_PURCHASE);\n', '    uint256 priceInWei = FIRSTSALE_BASE_PRICE_IN_WEI;\n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < cap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    ledToken.mint(_beneficiary, tokens);\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }\n', '\n', '  function getInfo() public view returns(uint256, uint256, string, bool,  uint256, uint256, uint256, \n', '  bool, uint256, uint256){\n', '    uint256 decimals = 18;\n', '    string memory symbol = "LED";\n', '    bool transfersEnabled = ledToken.transfersEnabled();\n', '    return (\n', '      TOTAL_TOKENCAP, // Tokencap with the decimal point in place. should be 100.000.000\n', '      decimals, // Decimals\n', '      symbol,\n', '      transfersEnabled,\n', '      contributors,\n', '      totalWeiRaised,\n', '      tokenCap, // Tokencap for the first sale with the decimal point in place.\n', '      started,\n', '      startTime, // Start time and end time in Unix timestamp format with a length of 10 numbers.\n', '      endTime\n', '    );\n', '  }\n', '\n', '  function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(!finalized);\n', '    surplusTokens = cap - tokensMinted;\n', '    ledToken.mint(ledMultiSig, surplusTokens);\n', '    ledToken.transferControl(owner);\n', '\n', '    emit Finalized();\n', '\n', '    finalized = true;\n', '  }\n', '\n', '}\n', '\n', 'contract LedToken is Controllable {\n', '\n', '  using SafeMath for uint256;\n', '  LedTokenInterface public parentToken;\n', '  TokenFactoryInterface public tokenFactory;\n', '\n', '  string public name;\n', '  string public symbol;\n', '  string public version;\n', '  uint8 public decimals;\n', '\n', '  uint256 public parentSnapShotBlock;\n', '  uint256 public creationBlock;\n', '  bool public transfersEnabled;\n', '\n', '  bool public masterTransfersEnabled;\n', '  address public masterWallet = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n', '\n', '\n', '  struct Checkpoint {\n', '    uint128 fromBlock;\n', '    uint128 value;\n', '  }\n', '\n', '  Checkpoint[] totalSupplyHistory;\n', '  mapping(address => Checkpoint[]) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  bool public mintingFinished = false;\n', '  bool public presaleBalancesLocked = false;\n', '\n', '  uint256 public totalSupplyAtCheckpoint;\n', '\n', '  event MintFinished();\n', '  event NewCloneToken(address indexed cloneToken);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '\n', '\n', '  constructor(\n', '    address _tokenFactory,\n', '    address _parentToken,\n', '    uint256 _parentSnapShotBlock,\n', '    string _tokenName,\n', '    string _tokenSymbol\n', '    ) public {\n', '      tokenFactory = TokenFactoryInterface(_tokenFactory);\n', '      parentToken = LedTokenInterface(_parentToken);\n', '      parentSnapShotBlock = _parentSnapShotBlock;\n', '      name = _tokenName;\n', '      symbol = _tokenSymbol;\n', '      decimals = 18;\n', '      transfersEnabled = false;\n', '      masterTransfersEnabled = false;\n', '      creationBlock = block.number;\n', '      version = &#39;0.1&#39;;\n', '  }\n', '\n', '\n', '  /**\n', '  * Returns the total Led token supply at the current block\n', '  * @return total supply {uint256}\n', '  */\n', '  function totalSupply() public constant returns (uint256) {\n', '    return totalSupplyAt(block.number);\n', '  }\n', '\n', '  /**\n', '  * Returns the total Led token supply at the given block number\n', '  * @param _blockNumber {uint256}\n', '  * @return total supply {uint256}\n', '  */\n', '  function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {\n', '    // These next few lines are used when the totalSupply of the token is\n', '    //  requested before a check point was ever created for this token, it\n', '    //  requires that the `parentToken.totalSupplyAt` be queried at the\n', '    //  genesis block for this token as that contains totalSupply of this\n', '    //  token at this block number.\n', '    if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '        if (address(parentToken) != 0x0) {\n', '            return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '        } else {\n', '            return 0;\n', '        }\n', '\n', '    // This will return the expected totalSupply during normal situations\n', '    } else {\n', '        return getValueAt(totalSupplyHistory, _blockNumber);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * Returns the token holder balance at the current block\n', '  * @param _owner {address}\n', '  * @return balance {uint256}\n', '   */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balanceOfAt(_owner, block.number);\n', '  }\n', '\n', '  /**\n', '  * Returns the token holder balance the the given block number\n', '  * @param _owner {address}\n', '  * @param _blockNumber {uint256}\n', '  * @return balance {uint256}\n', '  */\n', '  function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {\n', '    // These next few lines are used when the balance of the token is\n', '    //  requested before a check point was ever created for this token, it\n', '    //  requires that the `parentToken.balanceOfAt` be queried at the\n', '    //  genesis block for that token as this contains initial balance of\n', '    //  this token\n', '    if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '        if (address(parentToken) != 0x0) {\n', '            return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '        } else {\n', '            // Has no parent\n', '            return 0;\n', '        }\n', '\n', '    // This will return the expected balance during normal situations\n', '    } else {\n', '        return getValueAt(balances[_owner], _blockNumber);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 transfer tokens function\n', '  * @param _to {address}\n', '  * @param _amount {uint}\n', '  * @return success {bool}\n', '  */\n', '  function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '    return doTransfer(msg.sender, _to, _amount);\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 transferFrom function\n', '  * @param _from {address}\n', '  * @param _to {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '    require(allowed[_from][msg.sender] >= _amount);\n', '    allowed[_from][msg.sender] -= _amount;\n', '    return doTransfer(_from, _to, _amount);\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 approve function\n', '  * @param _spender {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '    require(transfersEnabled);\n', '\n', '    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _amount;\n', '    emit Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 approve function\n', '  * @param _spender {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n', '    approve(_spender, _amount);\n', '\n', '    ApproveAndCallReceiver(_spender).receiveApproval(\n', '        msg.sender,\n', '        _amount,\n', '        this,\n', '        _extraData\n', '    );\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 allowance function\n', '  * @param _owner {address}\n', '  * @param _spender {address}\n', '  * @return remaining {uint256}\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '  * Internal Transfer function - Updates the checkpoint ledger\n', '  * @param _from {address}\n', '  * @param _to {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\n', '\n', '    if (msg.sender != masterWallet) {\n', '      require(transfersEnabled);\n', '    } else {\n', '      require(masterTransfersEnabled);\n', '    }\n', '\n', '    require(_amount > 0);\n', '    require(parentSnapShotBlock < block.number);\n', '    require((_to != address(0)) && (_to != address(this)));\n', '\n', '    // If the amount being transfered is more than the balance of the\n', '    // account the transfer returns false\n', '    uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n', '    require(previousBalanceFrom >= _amount);\n', '\n', '    // First update the balance array with the new value for the address\n', '    //  sending the tokens\n', '    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '    // Then update the balance array with the new value for the address\n', '    //  receiving the tokens\n', '    uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n', '    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '    // An event to make the transfer easy to find on the blockchain\n', '    emit Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * Token creation functions - can only be called by the tokensale controller during the tokensale period\n', '  * @param _owner {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function mint(address _owner, uint256 _amount) public onlyController canMint returns (bool) {\n', '    uint256 curTotalSupply = totalSupply();\n', '    uint256 previousBalanceTo = balanceOf(_owner);\n', '\n', '    require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n', '    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '\n', '    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '    emit Transfer(0, _owner, _amount);\n', '    return true;\n', '  }\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Import presale balances before the start of the token sale. After importing\n', '   * balances, lockPresaleBalances() has to be called to prevent further modification\n', '   * of presale balances.\n', '   * @param _addresses {address[]} Array of presale addresses\n', '   * @param _balances {uint256[]} Array of balances corresponding to presale addresses.\n', '   * @return success {bool}\n', '   */\n', '  function importPresaleBalances(address[] _addresses, uint256[] _balances) public onlyController returns (bool) {\n', '    require(presaleBalancesLocked == false);\n', '\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      totalSupplyAtCheckpoint += _balances[i];\n', '      updateValueAtNow(balances[_addresses[i]], _balances[i]);\n', '      updateValueAtNow(totalSupplyHistory, totalSupplyAtCheckpoint);\n', '      emit Transfer(0, _addresses[i], _balances[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Lock presale balances after successful presale balance import\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function lockPresaleBalances() public onlyController returns (bool) {\n', '    presaleBalancesLocked = true;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Lock the minting of Led Tokens - to be called after the presale\n', '   * @return {bool} success\n', '  */\n', '  function finishMinting() public onlyController returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Enable or block transfers - to be called in case of emergency\n', '   * @param _value {bool}\n', '  */\n', '  function enableTransfers(bool _value) public onlyController {\n', '    transfersEnabled = _value;\n', '  }\n', '\n', '  /**\n', '   * Enable or block transfers - to be called in case of emergency\n', '   * @param _value {bool}\n', '  */\n', '  function enableMasterTransfers(bool _value) public onlyController {\n', '    masterTransfersEnabled = _value;\n', '  }\n', '\n', '  /**\n', '   * Internal balance method - gets a certain checkpoint value a a certain _block\n', '   * @param _checkpoints {Checkpoint[]} List of checkpoints - supply history or balance history\n', '   * @return value {uint256} Value of _checkpoints at _block\n', '  */\n', '  function getValueAt(Checkpoint[] storage _checkpoints, uint256 _block) constant internal returns (uint256) {\n', '\n', '      if (_checkpoints.length == 0)\n', '        return 0;\n', '      // Shortcut for the actual value\n', '      if (_block >= _checkpoints[_checkpoints.length-1].fromBlock)\n', '        return _checkpoints[_checkpoints.length-1].value;\n', '      if (_block < _checkpoints[0].fromBlock)\n', '        return 0;\n', '\n', '      // Binary search of the value in the array\n', '      uint256 min = 0;\n', '      uint256 max = _checkpoints.length-1;\n', '      while (max > min) {\n', '          uint256 mid = (max + min + 1) / 2;\n', '          if (_checkpoints[mid].fromBlock<=_block) {\n', '              min = mid;\n', '          } else {\n', '              max = mid-1;\n', '          }\n', '      }\n', '      return _checkpoints[min].value;\n', '  }\n', '\n', '\n', '  /**\n', '  * Internal update method - updates the checkpoint ledger at the current block\n', '  * @param _checkpoints {Checkpoint[]}  List of checkpoints - supply history or balance history\n', '  * @return value {uint256} Value to add to the checkpoints ledger\n', '   */\n', '  function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\n', '      if ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\n', '              Checkpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\n', '              newCheckPoint.fromBlock = uint128(block.number);\n', '              newCheckPoint.value = uint128(_value);\n', '          } else {\n', '              Checkpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\n', '              oldCheckPoint.value = uint128(_value);\n', '          }\n', '  }\n', '\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint) {\n', '      return a < b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * Clones Led Token at the given snapshot block\n', '  * @param _snapshotBlock {uint256}\n', '  * @param _name {string} - The cloned token name\n', '  * @param _symbol {string} - The cloned token symbol\n', '  * @return clonedTokenAddress {address}\n', '   */\n', '  function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\n', '\n', '      if (_snapshotBlock == 0) {\n', '        _snapshotBlock = block.number;\n', '      }\n', '\n', '      if (_snapshotBlock > block.number) {\n', '        _snapshotBlock = block.number;\n', '      }\n', '\n', '      LedToken cloneToken = tokenFactory.createCloneToken(\n', '          this,\n', '          _snapshotBlock,\n', '          _name,\n', '          _symbol\n', '        );\n', '\n', '\n', '      cloneToken.transferControl(msg.sender);\n', '\n', '      // An event to make the token easy to find on the blockchain\n', '      emit NewCloneToken(address(cloneToken));\n', '      return address(cloneToken);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title LedToken (LED)\n', ' * Standard Mintable ERC20 Token\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract LedTokenInterface is Controllable {\n', '\n', '  bool public transfersEnabled;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n', '  function transfer(address _to, uint256 _amount) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n', '  function approve(address _spender, uint256 _amount) public returns (bool success);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  function mint(address _owner, uint _amount) public returns (bool);\n', '  function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool);\n', '  function lockPresaleBalances() public returns (bool);\n', '  function finishMinting() public returns (bool);\n', '  function enableTransfers(bool _value) public;\n', '  function enableMasterTransfers(bool _value) public;\n', '  function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address);\n', '\n', '}\n', '\n', '/**\n', ' * @title Presale\n', ' * Presale allows investors to make token purchases and assigns them tokens based\n', '\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet as they arrive.\n', ' */\n', 'contract Presale is Crowdsale {\n', '\n', '  uint256 public tokenCap = PRESALE_TOKENCAP;\n', '  uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n', '  uint256 public weiCap = tokenCap * PRESALE_BASE_PRICE_IN_WEI;\n', '\n', '  constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    \n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ledToken = LedTokenInterface(_tokenAddress);\n', '\n', '    assert(_tokenAddress != 0x0);\n', '    assert(_startTime > 0);\n', '    assert(_endTime > _startTime);\n', '  }\n', '\n', '    /**\n', '   * High level token purchase function\n', '   */\n', '  function() public payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n', '    uint256 priceInWei = PRESALE_BASE_PRICE_IN_WEI;\n', '    \n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 bonusPercentage = determineBonus(weiAmount);\n', '    uint256 bonusTokens;\n', '\n', '    uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n', '    if(bonusPercentage>0){\n', '      uint256 initialDivided = initialTokens.div(100);\n', '      bonusTokens = initialDivided.mul(bonusPercentage);\n', '    } else {\n', '      bonusTokens = 0;\n', '    }\n', '    uint256 tokens = initialTokens.add(bonusTokens);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < cap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    ledToken.mint(_beneficiary, tokens);\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }\n', '\n', '  function determineBonus(uint256 _wei) public view returns (uint256) {\n', '    if(_wei > PRESALE_LEVEL_1) {\n', '      if(_wei > PRESALE_LEVEL_2) {\n', '        if(_wei > PRESALE_LEVEL_3) {\n', '          if(_wei > PRESALE_LEVEL_4) {\n', '            if(_wei > PRESALE_LEVEL_5) {\n', '              return PRESALE_PERCENTAGE_5;\n', '            } else {\n', '              return PRESALE_PERCENTAGE_4;\n', '            }\n', '          } else {\n', '            return PRESALE_PERCENTAGE_3;\n', '          }\n', '        } else {\n', '          return PRESALE_PERCENTAGE_2;\n', '        }\n', '      } else {\n', '        return PRESALE_PERCENTAGE_1;\n', '      }\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(!finalized);\n', '    surplusTokens = cap - tokensMinted;\n', '    ledToken.mint(ledMultiSig, surplusTokens);\n', '    ledToken.transferControl(owner);\n', '\n', '    emit Finalized();\n', '\n', '    finalized = true;\n', '  }\n', '\n', '  function getInfo() public view returns(uint256, uint256, string, bool,  uint256, uint256, uint256, \n', '  bool, uint256, uint256){\n', '    uint256 decimals = 18;\n', '    string memory symbol = "LED";\n', '    bool transfersEnabled = ledToken.transfersEnabled();\n', '    return (\n', '      TOTAL_TOKENCAP, // Tokencap with the decimal point in place. should be 100.000.000\n', '      decimals, // Decimals\n', '      symbol,\n', '      transfersEnabled,\n', '      contributors,\n', '      totalWeiRaised,\n', '      tokenCap, // Tokencap for the first sale with the decimal point in place.\n', '      started,\n', '      startTime, // Start time and end time in Unix timestamp format with a length of 10 numbers.\n', '      endTime\n', '    );\n', '  }\n', '  \n', '  function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, \n', '  uint256, uint256, uint256, uint256){\n', '    return (\n', '      PRESALE_LEVEL_1, // Amount of ether needed per bonus level\n', '      PRESALE_LEVEL_2,\n', '      PRESALE_LEVEL_3,\n', '      PRESALE_LEVEL_4,\n', '      PRESALE_LEVEL_5,\n', '      PRESALE_PERCENTAGE_1, // Bonus percentage per bonus level\n', '      PRESALE_PERCENTAGE_2,\n', '      PRESALE_PERCENTAGE_3,\n', '      PRESALE_PERCENTAGE_4,\n', '      PRESALE_PERCENTAGE_5\n', '    );\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title PrivateSale\n', ' * PrivateSale allows investors to make token purchases and assigns them tokens based\n', '\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet as they arrive.\n', ' */\n', 'contract PrivateSale is Crowdsale {\n', '\n', '  uint256 public tokenCap = PRIVATESALE_TOKENCAP;\n', '  uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n', '  uint256 public weiCap = tokenCap * PRIVATESALE_BASE_PRICE_IN_WEI;\n', '\n', '  constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    \n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ledToken = LedTokenInterface(_tokenAddress);\n', '\n', '    assert(_tokenAddress != 0x0);\n', '    assert(_startTime > 0);\n', '    assert(_endTime > _startTime);\n', '  }\n', '\n', '    /**\n', '   * High level token purchase function\n', '   */\n', '  function() public payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n', '    uint256 priceInWei = PRIVATESALE_BASE_PRICE_IN_WEI;\n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < cap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    ledToken.mint(_beneficiary, tokens);\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }\n', '\n', '  function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(!finalized);\n', '    surplusTokens = cap - tokensMinted;\n', '    ledToken.mint(ledMultiSig, surplusTokens);\n', '    ledToken.transferControl(owner);\n', '\n', '    emit Finalized();\n', '\n', '    finalized = true;\n', '  }\n', '\n', '  function getInfo() public view returns(uint256, uint256, string, bool,  uint256, uint256, uint256, \n', '  bool, uint256, uint256){\n', '    uint256 decimals = 18;\n', '    string memory symbol = "LED";\n', '    bool transfersEnabled = ledToken.transfersEnabled();\n', '    return (\n', '      TOTAL_TOKENCAP, // Tokencap with the decimal point in place. should be 100.000.000\n', '      decimals, // Decimals\n', '      symbol,\n', '      transfersEnabled,\n', '      contributors,\n', '      totalWeiRaised,\n', '      tokenCap, // Tokencap for the first sale with the decimal point in place.\n', '      started,\n', '      startTime, // Start time and end time in Unix timestamp format with a length of 10 numbers.\n', '      endTime\n', '    );\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TokenFactory {\n', '\n', '    function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        string _tokenSymbol\n', '        ) public returns (LedToken) {\n', '\n', '        LedToken newToken = new LedToken(\n', '            this,\n', '            _parentToken,\n', '            _snapshotBlock,\n', '            _tokenName,\n', '            _tokenSymbol\n', '        );\n', '\n', '        newToken.transferControl(msg.sender);\n', '        return newToken;\n', '    }\n', '}\n', '\n', 'contract TokenFactoryInterface {\n', '\n', '    function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        string _tokenSymbol\n', '      ) public returns (LedToken newToken);\n', '}\n', '\n', '/**\n', ' * @title Tokensale\n', ' * Tokensale allows investors to make token purchases and assigns them tokens based\n', '\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet as they arrive.\n', ' */\n', 'contract TokenSale is Crowdsale {\n', '\n', '  uint256 public tokenCap = ICO_TOKENCAP;\n', '  uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n', '  uint256 public weiCap = tokenCap * ICO_BASE_PRICE_IN_WEI;\n', '\n', '  uint256 public allocatedTokens;\n', '\n', '  constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    \n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ledToken = LedTokenInterface(_tokenAddress);\n', '\n', '    assert(_tokenAddress != 0x0);\n', '    assert(_startTime > 0);\n', '    assert(_endTime > _startTime);\n', '  }\n', '\n', '    /**\n', '   * High level token purchase function\n', '   */\n', '  function() public payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n', '    uint256 priceInWei = ICO_BASE_PRICE_IN_WEI;\n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 bonusPercentage = determineBonus(weiAmount);\n', '    uint256 bonusTokens;\n', '\n', '    uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n', '    if(bonusPercentage>0){\n', '      uint256 initialDivided = initialTokens.div(100);\n', '      bonusTokens = initialDivided.mul(bonusPercentage);\n', '    } else {\n', '      bonusTokens = 0;\n', '    }\n', '    uint256 tokens = initialTokens.add(bonusTokens);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < cap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    ledToken.mint(_beneficiary, tokens);\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }\n', '\n', '  function determineBonus(uint256 _wei) public view returns (uint256) {\n', '    if(_wei > ICO_LEVEL_1) {\n', '      if(_wei > ICO_LEVEL_2) {\n', '        if(_wei > ICO_LEVEL_3) {\n', '          if(_wei > ICO_LEVEL_4) {\n', '            if(_wei > ICO_LEVEL_5) {\n', '              return ICO_PERCENTAGE_5;\n', '            } else {\n', '              return ICO_PERCENTAGE_4;\n', '            }\n', '          } else {\n', '            return ICO_PERCENTAGE_3;\n', '          }\n', '        } else {\n', '          return ICO_PERCENTAGE_2;\n', '        }\n', '      } else {\n', '        return ICO_PERCENTAGE_1;\n', '      }\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function allocateLedTokens() public onlyOwner whenNotFinalized {\n', '    require(!ledTokensAllocated);\n', '    allocatedTokens = LEDTEAM_TOKENS.mul(DECIMALS_MULTIPLIER);\n', '    ledToken.mint(ledMultiSig, allocatedTokens);\n', '    ledTokensAllocated = true;\n', '  }\n', '\n', '  function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(ledTokensAllocated);\n', '\n', '    surplusTokens = cap - tokensMinted;\n', '    ledToken.mint(ledMultiSig, surplusTokens);\n', '\n', '    ledToken.finishMinting();\n', '    ledToken.enableTransfers(true);\n', '    emit Finalized();\n', '\n', '    finalized = true;\n', '  }\n', '\n', '  function getInfo() public view returns(uint256, uint256, string, bool,  uint256, uint256, uint256, \n', '  bool, uint256, uint256){\n', '    uint256 decimals = 18;\n', '    string memory symbol = "LED";\n', '    bool transfersEnabled = ledToken.transfersEnabled();\n', '    return (\n', '      TOTAL_TOKENCAP, // Tokencap with the decimal point in place. should be 100.000.000\n', '      decimals, // Decimals\n', '      symbol,\n', '      transfersEnabled,\n', '      contributors,\n', '      totalWeiRaised,\n', '      tokenCap, // Tokencap for the first sale with the decimal point in place.\n', '      started,\n', '      startTime, // Start time and end time in Unix timestamp format with a length of 10 numbers.\n', '      endTime\n', '    );\n', '  }\n', '  \n', '  function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, \n', '  uint256, uint256, uint256, uint256){\n', '    return (\n', '      ICO_LEVEL_1, // Amount of ether needed per bonus level\n', '      ICO_LEVEL_2,\n', '      ICO_LEVEL_3,\n', '      ICO_LEVEL_4,\n', '      ICO_LEVEL_5,\n', '      ICO_PERCENTAGE_1, // Bonus percentage per bonus level\n', '      ICO_PERCENTAGE_2,\n', '      ICO_PERCENTAGE_3,\n', '      ICO_PERCENTAGE_4,\n', '      ICO_PERCENTAGE_5\n', '    );\n', '  }\n', '\n', '}']