['pragma solidity ^0.4.25;\n', '    contract TMBToken  {\n', '        string public constant name = "TimeBankCoin";\n', '        string public constant symbol = "TMB";\n', '        uint public constant decimals = 18;\n', '        uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); \n', '        uint public baseStartTime;\n', '        uint256 public distributed = 0;\n', '        mapping (address => bool) public freezed;\n', '        mapping(address => uint256) balances;       \n', '        mapping(address => uint256) distBalances;   \n', '        mapping(address => mapping (address => uint256)) allowed;\n', '        address public founder;\n', '        event AllocateFounderTokens(address indexed sender);\n', '        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '        event Burn(address indexed fromAddr, uint256 value);\n', '     \n', '        function TMBToken() {\n', '            founder = msg.sender;\n', '        }\n', '         function totalSupply() constant returns (uint256 supply) {\n', '            return _totalSupply;\n', '        }\n', ' \n', '        function balanceOf(address _owner) constant returns (uint256 balance) {\n', '            return balances[_owner];\n', '        }\n', ' \n', '        function approve(address _spender, uint256 _value) returns (bool success) {\n', '            allowed[msg.sender][_spender] = _value;\n', '            Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', ' \n', '        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '          return allowed[_owner][_spender];\n', '        }\n', '        function setStartTime(uint _startTime) {\n', '            if (msg.sender!=founder) revert();\n', '            baseStartTime = _startTime;\n', '        }\n', ' \n', '       \n', '        function distribute(uint256 _amount, address _to) {\n', '            if (msg.sender!=founder) revert();\n', '            if (distributed + _amount > _totalSupply) revert();\n', '            if (freezed[_to]) revert();\n', '            distributed += _amount;\n', '            balances[_to] += _amount;\n', '            distBalances[_to] += _amount;\n', '        }\n', ' \n', '      \n', '        function transfer(address _to, uint256 _value) returns (bool success) {\n', '            if (now < baseStartTime) revert();\n', '            if (freezed[msg.sender]) revert();\n', '            if (freezed[_to]) revert();\n', '          \n', '            if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '                uint _freeAmount = freeAmount(msg.sender);\n', '                if (_freeAmount < _value) {\n', '                    return false;\n', '                } \n', ' \n', '                balances[msg.sender] -= _value;\n', '                balances[_to] += _value;\n', '                Transfer(msg.sender, _to, _value);\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        }\n', '        \n', '        function addTokenTotal(uint256 _addAmount) public returns (bool success){\n', '    require(msg.sender == founder);                        \n', '    require(_addAmount > 0);                             \n', '        \n', '    _totalSupply += _addAmount * 10 ** decimals;           \n', '    balances[msg.sender] += _addAmount * 10 ** decimals;  \n', '    return true;\n', '}  \n', '    function unFreezenAccount(address _freezen) public returns (bool success) {\n', '        require(msg.sender == founder);       \n', '        \n', '        freezed[_freezen] = false;\n', '        return true;\n', '    }\n', '    \n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(msg.sender == founder);                  \n', '        require(balances[msg.sender] >= _value);      \n', '        balances[msg.sender] -= _value;\n', '        _totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '   \n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(msg.sender == founder);                  \n', '        require(balances[_from] >= _value);            \n', '        require(_value <= allowed[_from][msg.sender]);  \n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        _totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function changeAdmin(address _newAdmin) public returns (bool) {\n', '    require(msg.sender == founder);\n', '    require(_newAdmin != address(0));\n', '    founder = _newAdmin;\n', '    return true;\n', '}\n', '   \n', '    function getFrozenAccount(address _target) public view returns (bool) {\n', '        require(_target != address(0));\n', '        return freezed[_target];\n', '    }\n', '\n', '  function freezenAccount(address _freezen) public returns (bool success) {\n', '        require(msg.sender == founder);      \n', '        require(_freezen != founder);         \n', '    \n', '        freezed[_freezen] = true;\n', '        return true;\n', '    }\n', '\n', '        function freeAmount(address user) returns (uint256 amount) {\n', '           \n', '            if (user == founder) {\n', '                return balances[user];\n', '            }\n', '\n', '            if (now < baseStartTime) {\n', '                return 0;\n', '            }\n', ' \n', '         \n', '            uint monthDiff = (now - baseStartTime) / (30 days);\n', ' \n', '           \n', '            if (monthDiff > 5) {\n', '                return balances[user];\n', '            }\n', ' \n', '           \n', '            uint unrestricted = distBalances[user] / 20 + distBalances[user] * 20 / 100 * monthDiff;\n', '            if (unrestricted > distBalances[user]) {\n', '                unrestricted = distBalances[user];\n', '            }\n', ' \n', '           \n', '            if (unrestricted + balances[user] < distBalances[user]) {\n', '                amount = 0;\n', '            } else {\n', '                amount = unrestricted + (balances[user] - distBalances[user]);\n', '            }\n', ' \n', '            return amount;\n', '        }\n', ' \n', '       \n', '        function changeFounder(address newFounder) {\n', '            if (msg.sender!=founder) revert();\n', '            founder = newFounder;\n', '        }\n', ' \n', '        \n', '        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '            if (msg.sender != founder) revert();\n', '            if (freezed[_from]) revert();\n', '            if (freezed[_to]) revert();\n', '            \n', '            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '                uint _freeAmount = freeAmount(_from);\n', '                if (_freeAmount < _value) {\n', '                    return false;\n', '                } \n', ' \n', '                balances[_to] += _value;\n', '                balances[_from] -= _value;\n', '                allowed[_from][msg.sender] -= _value;\n', '                Transfer(_from, _to, _value);\n', '                return true;\n', '            } else { return false; }\n', '        }\n', '        function kill() public {\n', '        require(msg.sender == founder);\n', '        selfdestruct(founder);\n', '        }\n', '\n', '        function() payable {\n', '            if (!founder.call.value(msg.value)()) revert(); \n', '        }\n', '    }']