['contract RNG{\n', '\n', '    /** @dev Contribute to the reward of a random number.\n', '     *  @param _block Block the random number is linked to.\n', '     */\n', '    function contribute(uint _block) public payable;\n', '\n', '    /** @dev Request a random number.\n', '     *  @param _block Block linked to the request.\n', '     */\n', '    function requestRN(uint _block) public payable {\n', '        contribute(_block);\n', '    }\n', '\n', '    /** @dev Get the random number.\n', '     *  @param _block Block the random number is linked to.\n', '     *  @return RN Random Number. If the number is not ready or has not been required 0 instead.\n', '     */\n', '    function getRN(uint _block) public returns (uint RN);\n', '\n', '    /** @dev Get a uncorrelated random number. Act like getRN but give a different number for each sender.\n', '     *  This is to prevent users from getting correlated numbers.\n', '     *  @param _block Block the random number is linked to.\n', '     *  @return RN Random Number. If the number is not ready or has not been required 0 instead.\n', '     */\n', '    function getUncorrelatedRN(uint _block) public returns (uint RN) {\n', '        uint baseRN=getRN(_block);\n', '        if (baseRN==0)\n', '            return 0;\n', '        else\n', '            return uint(keccak256(msg.sender,baseRN));\n', '    }\n', '\n', ' }\n', '\n', '/** Simple Random Number Generator returning the blockhash.\n', ' *  Allows saving the random number for use in the future.\n', ' *  It allows the contract to still access the blockhash even after 256 blocks.\n', ' *  The first party to call the save function gets the reward.\n', ' */\n', 'contract BlockHashRNG is RNG {\n', '\n', '    mapping (uint => uint) public randomNumber; // randomNumber[block] is the random number for this block, 0 otherwise.\n', '    mapping (uint => uint) public reward; // reward[block] is the amount to be paid to the party w.\n', '\n', '\n', '\n', '    /** @dev Contribute to the reward of a random number.\n', '     *  @param _block Block the random number is linked to.\n', '     */\n', '    function contribute(uint _block) public payable { reward[_block]+=msg.value; }\n', '\n', '\n', '    /** @dev Return the random number. If it has not been saved and is still computable compute it.\n', '     *  @param _block Block the random number is linked to.\n', '     *  @return RN Random Number. If the number is not ready or has not been requested 0 instead.\n', '     */\n', '    function getRN(uint _block) public returns (uint RN) {\n', '        RN=randomNumber[_block];\n', '        if (RN==0){\n', '            saveRN(_block);\n', '            return randomNumber[_block];\n', '        }\n', '        else\n', '            return RN;\n', '    }\n', '\n', '    /** @dev Save the random number for this blockhash and give the reward to the caller.\n', '     *  @param _block Block the random number is linked to.\n', '     */\n', '    function saveRN(uint _block) public {\n', '        if (blockhash(_block) != 0x0)\n', '            randomNumber[_block] = uint(blockhash(_block));\n', '        if (randomNumber[_block] != 0) { // If the number is set.\n', '            uint rewardToSend = reward[_block];\n', '            reward[_block] = 0;\n', '            msg.sender.send(rewardToSend); // Note that the use of send is on purpose as we don&#39;t want to block in case msg.sender has a fallback issue.\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/** Random Number Generator returning the blockhash with a backup behaviour.\n', ' *  Allows saving the random number for use in the future. \n', ' *  It allows the contract to still access the blockhash even after 256 blocks.\n', ' *  The first party to call the save function gets the reward.\n', ' *  If no one calls the contract within 256 blocks, the contract fallback in returning the blockhash of the previous block.\n', ' */\n', 'contract BlockHashRNGFallback is BlockHashRNG {\n', '    \n', '    /** @dev Save the random number for this blockhash and give the reward to the caller.\n', '     *  @param _block Block the random number is linked to.\n', '     */\n', '    function saveRN(uint _block) public {\n', '        if (_block<block.number && randomNumber[_block]==0) {// If the random number is not already set and can be.\n', '            if (blockhash(_block)!=0x0) // Normal case.\n', '                randomNumber[_block]=uint(blockhash(_block));\n', '            else // The contract was not called in time. Fallback to returning previous blockhash.\n', '                randomNumber[_block]=uint(blockhash(block.number-1));\n', '        }\n', '        if (randomNumber[_block] != 0) { // If the random number is set.\n', '            uint rewardToSend=reward[_block];\n', '            reward[_block]=0;\n', '            msg.sender.send(rewardToSend); // Note that the use of send is on purpose as we don&#39;t want to block in case the msg.sender has a fallback issue.\n', '        }\n', '    }\n', '    \n', '}']