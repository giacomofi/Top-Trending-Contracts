['pragma solidity ^0.4.15;\n', '\n', '// Math helper functions\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/// @title DNNToken contract - Main DNN contract\n', '/// @author Dondrey Taylor - <dondrey@dnn.media>\n', 'contract DNNToken {\n', '    enum DNNSupplyAllocations {\n', '        EarlyBackerSupplyAllocation,\n', '        PRETDESupplyAllocation,\n', '        TDESupplyAllocation,\n', '        BountySupplyAllocation,\n', '        WriterAccountSupplyAllocation,\n', '        AdvisorySupplyAllocation,\n', '        PlatformSupplyAllocation\n', '    }\n', '    function balanceOf(address who) constant public returns (uint256);\n', '    function issueTokens(address, uint256, DNNSupplyAllocations) public pure returns (bool) {}\n', '}\n', '\n', '/// @author Dondrey Taylor - <dondrey@dnn.media>\n', 'contract DNNAdvisoryLockBox {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // DNN Token Contract\n', '  DNNToken public dnnToken;\n', '\n', '  // Addresses of the co-founders of DNN\n', '  address public cofounderA;\n', '  address public cofounderB;\n', '\n', '  // Amount of tokens that each advisor is entitled to\n', '  mapping(address => uint256) advisorsWithEntitledSupply;\n', '\n', '  // Amount of tokens that each advisor is entitled to\n', '\tmapping(address => uint256) advisorsTokensIssued;\n', '\n', '  // The last time that tokens were issued to each advisor\n', '\tmapping(address => uint256) advisorsTokensIssuedOn;\n', '\n', '  // Events\n', '\tevent AdvisorTokensSent(address to, uint256 issued, uint256 remaining);\n', '\tevent AdvisorAdded(address advisor);\n', '\tevent AdvisorAddressChanged(address oldaddress, address newaddress);\n', '  event NotWhitelisted(address to);\n', '  event NoTokensRemaining(address advisor);\n', '  event NextRedemption(uint256 nextTime);\n', '\n', '  // Checks to see if sender is a cofounder\n', '  modifier onlyCofounders() {\n', '      require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '      _;\n', '  }\n', '\n', '  // Replace advisor address\n', '  function replaceAdvisorAddress(address oldaddress, address newaddress) public onlyCofounders {\n', "      // Check to see if the advisor's old address exists\n", '      if (advisorsWithEntitledSupply[oldaddress] > 0) {\n', '          advisorsWithEntitledSupply[newaddress] = advisorsWithEntitledSupply[oldaddress];\n', '          advisorsWithEntitledSupply[oldaddress] = 0;\n', '          emit AdvisorAddressChanged(oldaddress, newaddress);\n', '      }\n', '      else {\n', '          emit NotWhitelisted(oldaddress);\n', '      }\n', '  }\n', '\n', '  // Provides the remaining amount tokens to be issued to the advisor\n', '  function nextRedemptionTime(address advisorAddress) public view returns (uint256) {\n', '      return advisorsTokensIssuedOn[advisorAddress] == 0 ? now : (advisorsTokensIssuedOn[advisorAddress] + 30 days);\n', '  }\n', '\n', '  // Provides the remaining amount tokens to be issued to the advisor\n', '  function checkRemainingTokens(address advisorAddress) public view returns (uint256) {\n', '      return advisorsWithEntitledSupply[advisorAddress] - advisorsTokensIssued[advisorAddress];\n', '  }\n', '\n', '  // Checks if the specified address is whitelisted\n', '  function isWhitelisted(address advisorAddress) public view returns (bool) {\n', '     return advisorsWithEntitledSupply[advisorAddress] != 0;\n', '  }\n', '\n', '  // Add advisor address\n', '  function addAdvisor(address advisorAddress, uint256 entitledTokenAmount) public onlyCofounders {\n', '      advisorsWithEntitledSupply[advisorAddress] = entitledTokenAmount;\n', '      emit AdvisorAdded(advisorAddress);\n', '  }\n', '\n', '  // Amount of tokens that the advisor is entitled to\n', '  function advisorEntitlement(address advisorAddress) public view returns (uint256) {\n', '      return advisorsWithEntitledSupply[advisorAddress];\n', '  }\n', '\n', '  constructor() public\n', '  {\n', '      // Set token address\n', '      dnnToken = DNNToken(0x9D9832d1beb29CC949d75D61415FD00279f84Dc2);\n', '\n', '      // Set cofounder addresses\n', '      cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '      cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '  }\n', '\n', '\t// Handles incoming transactions\n', '\tfunction () public payable {\n', '\n', '      // Check to see if the advisor is within\n', '      // our whitelist\n', '      if (advisorsWithEntitledSupply[msg.sender] > 0) {\n', '\n', '          // Check to see if the advisor has any tokens left\n', '          if (advisorsTokensIssued[msg.sender] < advisorsWithEntitledSupply[msg.sender]) {\n', '\n', '              // Check to see if we can issue tokens to them. Advisors can redeem every 30 days for 10 months\n', '              if (advisorsTokensIssuedOn[msg.sender] == 0 || ((now - advisorsTokensIssuedOn[msg.sender]) >= 30 days)) {\n', '\n', '                  // Issue tokens to advisors\n', '                  uint256 tokensToIssue = advisorsWithEntitledSupply[msg.sender].div(10);\n', '\n', '                  // Update amount of tokens issued to this advisor\n', '                  advisorsTokensIssued[msg.sender] = advisorsTokensIssued[msg.sender].add(tokensToIssue);\n', '\n', '                  // Update the time that we last issued tokens to this advisor\n', '                  advisorsTokensIssuedOn[msg.sender] = now;\n', '\n', '                  // Allocation type will be advisory\n', '                  DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.AdvisorySupplyAllocation;\n', '\n', '                  // Attempt to issue tokens\n', '                  if (!dnnToken.issueTokens(msg.sender, tokensToIssue, allocationType)) {\n', '                      revert();\n', '                  }\n', '                  else {\n', '                     emit AdvisorTokensSent(msg.sender, tokensToIssue, checkRemainingTokens(msg.sender));\n', '                  }\n', '              }\n', '              else {\n', '                   emit NextRedemption(advisorsTokensIssuedOn[msg.sender] + 30 days);\n', '              }\n', '          }\n', '          else {\n', '            emit NoTokensRemaining(msg.sender);\n', '          }\n', '      }\n', '      else {\n', '        emit NotWhitelisted(msg.sender);\n', '      }\n', '\t}\n', '\n', '}']