['pragma solidity 0.4.21;\n', '\n', 'contract ERC20Basic {\n', '\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\t\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '\t\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public balances;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\t\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract CerttifyToken is StandardToken {\n', '\n', '    event Burn(address indexed burner, uint256 value, string message);\n', '    event IssueCert(bytes32 indexed id, address certIssuer, uint256 value, bytes cert);\n', '\n', '    string public name = "Certtify Token";\n', '    string public symbol = "CTF";\n', '    uint8 public decimals = 18;\n', '\n', '    address public deployer;\n', '    bool public lockup = true;\n', '\n', '    function CerttifyToken(uint256 maxSupply) public {\n', '        totalSupply = maxSupply.mul(10 ** uint256(decimals));\n', '        balances[msg.sender] = totalSupply;\n', '        deployer = msg.sender;\n', '    }\n', '\n', '    modifier afterLockup() {\n', '        require(!lockup || msg.sender == deployer);\n', '        _;\n', '    }\n', '\n', '    function unlock() public {\n', '        require(msg.sender == deployer);\n', '        lockup = false;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public afterLockup() returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public afterLockup() returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function burn(uint256 _value, string _message) public afterLockup() {\n', '        require(_value > 0);\n', '        require(_value <= balances[msg.sender]);\n', '        address burner = msg.sender;\n', '        totalSupply = totalSupply.sub(_value);\n', '        balances[burner] = balances[burner].sub(_value);\n', '        emit Burn(burner, _value, _message);\n', '    }\n', '\n', '    function issueCert(uint256 _value, bytes _cert) external afterLockup() {\n', '        if (_value > 0) { \n', '            burn(_value, "");\n', '        }\n', '        emit IssueCert(keccak256(block.number, msg.sender, _value, _cert), msg.sender, _value, _cert);\n', '    }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '  \n', '    address public owner;\n', '\n', '    function Ownable(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract Bounty is Ownable {\n', '\n', '    CerttifyToken public token;\n', '    mapping(address => uint256) public bounties;\n', '    bool public withdrawlEnabled = false;\n', '\n', '    event BountySet(address indexed beneficiary, uint256 amount);\n', '    event BountyWithdraw(address indexed beneficiary, uint256 amount);\n', '\n', '    function Bounty(CerttifyToken _token, address _admin) Ownable(_admin) public {\n', '        token = _token;\n', '    }\n', '\n', '    function setBounties(address[] beneficiaries, uint256[] amounts) external onlyOwner {\n', '        require(beneficiaries.length == amounts.length);\n', '        for (uint256 i = 0; i < beneficiaries.length; i++) {\n', '            bounties[beneficiaries[i]] = amounts[i];\n', '            emit BountySet(beneficiaries[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    function enableWithdrawl() external onlyOwner {\n', '        withdrawlEnabled = true;\n', '    }\n', '\n', '    function withdrawBounty() public {\n', '        require(withdrawlEnabled);\n', '        require(bounties[msg.sender] > 0);\n', '        uint256 bountyWithdrawn = bounties[msg.sender];\n', '        bounties[msg.sender] = 0;\n', '        emit BountyWithdraw(msg.sender, bountyWithdrawn);\n', '        token.transfer(msg.sender, bountyWithdrawn);\n', '    }\n', '\n', '    function () external {\n', '        withdrawBounty();\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\t\n', '}\n', '\n', 'contract CerttifyCrowdsale is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    CerttifyToken public token;\n', '    Bounty public bounty;\n', '\n', '    bool public icoSpecConfirmed = false;\n', '\n', '    uint256 public startTimeStage1 = 4102444799;\n', '    uint256 public startTimeStage2;\n', '    uint256 public startTimeStage3;\n', '    uint256 public endTime;\n', '\n', '    address public wallet;\n', '\n', '    uint256 public rateStage1;\n', '    uint256 public rateStage2;\n', '    uint256 public rateStage3;\n', '\n', '    uint256 public constant DECIMALS = 18;\n', '    uint256 public constant MAX_SUPPLY = 550000000;\n', '    uint256 public constant MAX_SUPPLY_DECIMAL = 550000000 * (10 ** DECIMALS);\n', '    uint256 public constant MAX_ALLOWED_BOUNTY = 16500000 * (10 ** DECIMALS);\n', '    uint256 public constant MAX_ALLOWED_PRE_SALE = 192500000 * (10 ** DECIMALS);\n', '    uint256 public constant MAX_ALLOWED_STAGE_1 = 82500000 * (10 ** DECIMALS);\n', '    uint256 public constant MAX_ALLOWED_STAGE_2 = 82500000 * (10 ** DECIMALS);\n', '    uint256 public constant MAX_ALLOWED_STAGE_3 = 55000000 * (10 ** DECIMALS);\n', '    uint256 public MAX_ALLOWED_BY_STAGE_1 = MAX_ALLOWED_PRE_SALE.add(MAX_ALLOWED_STAGE_1);\n', '    uint256 public MAX_ALLOWED_BY_STAGE_2 = MAX_ALLOWED_BY_STAGE_1.add(MAX_ALLOWED_STAGE_2);\n', '    uint256 public MAX_ALLOWED_TOTAL =  MAX_ALLOWED_BY_STAGE_2.add(MAX_ALLOWED_STAGE_3);\n', '\n', '    uint256 public weiRaised;\n', '    uint256 public tokenSold;\n', '\n', '    bool public icoEnded;\n', '    \n', '    uint256 public founderTokenUnlockPhase1;\n', '    uint256 public founderTokenUnlockPhase2;\n', '    uint256 public founderTokenUnlockPhase3;\n', '    uint256 public founderTokenUnlockPhase4;\n', '\n', '    bool public founderTokenWithdrawnPhase1;\n', '    uint256 public founderWithdrawablePhase1;\n', '    bool public founderTokenWithdrawnPhase2;\n', '    uint256 public founderWithdrawablePhase2;\n', '    bool public founderTokenWithdrawnPhase3;\n', '    uint256 public founderWithdrawablePhase3;\n', '    bool public founderTokenWithdrawnPhase4;\n', '    uint256 public founderWithdrawablePhase4;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    modifier onlyBeforeSpecConfirmed() {\n', '        require(!icoSpecConfirmed);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAfterSpecConfirmed() {\n', '        require(icoSpecConfirmed);\n', '        _;\n', '    }\n', '\n', '    function CerttifyCrowdsale(address _wallet, address _owner, address _bountyAdmin) Ownable(_owner) public {\n', '        require(_wallet != address(0));\n', '        require(_owner != address(0));\n', '        require(_bountyAdmin != address(0));\n', '        token = createTokenContract();\n', '        bounty = createBountyContract(_bountyAdmin);\n', '        token.transfer(bounty, MAX_ALLOWED_BOUNTY);\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function createTokenContract() internal returns (CerttifyToken) {\n', '        return new CerttifyToken(MAX_SUPPLY);\n', '    }\n', '\n', '    function createBountyContract(address admin) internal returns (Bounty) {\n', '        return new Bounty(token, admin);\n', '    }\n', '\n', '    function setICOSpec(uint256 _timestampStage1, uint256 _timestampStage2, uint256 _timestampStage3, uint256 _timestampEndTime, uint256 _weiCostOfTokenStage1, uint256 _weiCostOfTokenStage2, uint256 _weiCostOfTokenStage3, uint256 _founderTokenUnlockPhase1, uint256 _founderTokenUnlockPhase2, uint256 _founderTokenUnlockPhase3, uint256 _founderTokenUnlockPhase4) external onlyBeforeSpecConfirmed() onlyOwner {\n', '        require(_timestampStage1 > 0);\n', '        require(_timestampStage2 >= _timestampStage1);\n', '        require(_timestampStage3 >= _timestampStage2);\n', '        require(_timestampEndTime >= _timestampStage3);\n', '        require(_weiCostOfTokenStage1 > 0);\n', '        require(_weiCostOfTokenStage2 >= _weiCostOfTokenStage1);\n', '        require(_weiCostOfTokenStage3 >= _weiCostOfTokenStage2);\n', '        require(_founderTokenUnlockPhase1 > 0);\n', '        require(_founderTokenUnlockPhase2 >= _founderTokenUnlockPhase1);\n', '        require(_founderTokenUnlockPhase3 >= _founderTokenUnlockPhase2);\n', '        require(_founderTokenUnlockPhase4 >= _founderTokenUnlockPhase3);\n', '        startTimeStage1 = _timestampStage1;\n', '        startTimeStage2 = _timestampStage2;\n', '        startTimeStage3 = _timestampStage3;\n', '        endTime = _timestampEndTime;\n', '        rateStage1 = _weiCostOfTokenStage1;\n', '        rateStage2 = _weiCostOfTokenStage2;\n', '        rateStage3 = _weiCostOfTokenStage3;\n', '        founderTokenUnlockPhase1 = _founderTokenUnlockPhase1;\n', '        founderTokenUnlockPhase2 = _founderTokenUnlockPhase2;\n', '        founderTokenUnlockPhase3 = _founderTokenUnlockPhase3;\n', '        founderTokenUnlockPhase4 = _founderTokenUnlockPhase4;\n', '    }\n', '\n', '    function confirmICOSpec() external onlyBeforeSpecConfirmed() onlyOwner {\n', '        icoSpecConfirmed = true;\n', '    }\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address beneficiary) public payable onlyAfterSpecConfirmed() {\n', '        require(beneficiary != address(0));\n', '        require(validPurchase());\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens = weiAmount.div(getCurrentRate()).mul(10 ** uint256(18));\n', '        require(checkCapNotReached(tokens));\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokenSold = tokenSold.add(tokens);\n', '        forwardFunds();\n', '        token.transfer(beneficiary, tokens);\n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '    }\n', '\n', '    function buyTokensPreSale(address beneficiary, uint256 tokens) public onlyOwner {\n', '        require(beneficiary != address(0));\n', '        require(tokens > 0);\n', '        require(tokenSold.add(tokens) <= MAX_ALLOWED_PRE_SALE);\n', '        require(getCurrentStage() == 0);\n', '        tokenSold = tokenSold.add(tokens);\n', '        token.transfer(beneficiary, tokens);\n', '        emit TokenPurchase(beneficiary, beneficiary, 0, tokens);\n', '    }\n', '\n', '    function postICO() public onlyAfterSpecConfirmed() onlyOwner {\n', '        require(hasEnded());\n', '        require(!icoEnded);\n', '        uint256 founderWithdrawableTotal = tokenSold.add(MAX_ALLOWED_BOUNTY).mul(22).div(78);\n', '        founderWithdrawablePhase1 = founderWithdrawableTotal.mul(10).div(22);\n', '        founderWithdrawablePhase2 = founderWithdrawableTotal.mul(4).div(22);\n', '        founderWithdrawablePhase3 = founderWithdrawableTotal.mul(4).div(22);\n', '        founderWithdrawablePhase4 = founderWithdrawableTotal.mul(4).div(22);\n', '        icoEnded = true;\n', '        uint256 tokenLeft = MAX_SUPPLY_DECIMAL.sub(tokenSold).sub(MAX_ALLOWED_BOUNTY).sub(founderWithdrawableTotal);\n', '        if (tokenLeft != 0) {\n', '            token.burn(tokenLeft, "ICO_BURN_TOKEN_UNSOLD");\n', '        }\n', '        token.unlock();\n', '    }\n', '\n', '    function founderWithdraw() public onlyAfterSpecConfirmed() onlyOwner {\n', '        require(icoEnded);\n', '        require(!founderTokenWithdrawnPhase4);\n', '        if (!founderTokenWithdrawnPhase1) {\n', '            require(now >= founderTokenUnlockPhase1);\n', '            founderTokenWithdrawnPhase1 = true;\n', '            token.transfer(owner, founderWithdrawablePhase1);\n', '        } else if (!founderTokenWithdrawnPhase2) {\n', '            require(now >= founderTokenUnlockPhase2);\n', '            founderTokenWithdrawnPhase2 = true;\n', '            token.transfer(owner, founderWithdrawablePhase2);\n', '        } else if (!founderTokenWithdrawnPhase3) {\n', '            require(now >= founderTokenUnlockPhase3);\n', '            founderTokenWithdrawnPhase3 = true;\n', '            token.transfer(owner, founderWithdrawablePhase3);\n', '        } else {\n', '            require(now >= founderTokenUnlockPhase4);\n', '            founderTokenWithdrawnPhase4 = true;\n', '            token.transfer(owner, founderWithdrawablePhase4);\n', '        }\n', '    }\n', '\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTimeStage1 && now < endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    function checkCapNotReached(uint256 tokenBuyReq) internal view returns (bool) {\n', '        return tokenSold.add(tokenBuyReq) <= MAX_ALLOWED_TOTAL;\n', '    }\n', '\n', '    function getCurrentStage() internal view returns (uint8) {\n', '        if (now < startTimeStage1) {\n', '            return 0;\n', '        } else if (now >= startTimeStage1 && now < startTimeStage2) {\n', '            return 1;\n', '        } else if (now >= startTimeStage2 && now < startTimeStage3) {\n', '            return 2;\n', '        } else {\n', '            return 3;\n', '        }\n', '    }\n', '\n', '    function getCurrentRateByStage() internal view returns (uint256) {\n', '        uint8 currentStage = getCurrentStage();\n', '        if (currentStage == 1) {\n', '            return rateStage1;\n', '        } else if (currentStage == 2) {\n', '            return rateStage2;\n', '        } else {\n', '            return rateStage3;\n', '        }\n', '    }\n', '\n', '    function getCurrentRateByTokenSold() internal view returns (uint256) {\n', '        if (tokenSold < MAX_ALLOWED_BY_STAGE_1) {\n', '            return rateStage1;\n', '        } else if (tokenSold < MAX_ALLOWED_BY_STAGE_2) {\n', '            return rateStage2;\n', '        } else {\n', '            return rateStage3;\n', '        }\n', '    }\n', '\n', '    function getCurrentRate() internal view returns (uint256) {\n', '        uint256 rateByStage = getCurrentRateByStage();\n', '        uint256 rateByTokenSold = getCurrentRateByTokenSold();\n', '        if (rateByStage > rateByTokenSold) {\n', '            return rateByStage;\n', '        } else {\n', '            return rateByTokenSold;\n', '        }\n', '    }\n', '\n', '    function hasEnded() public view returns (bool) {\n', '        return now >= endTime || tokenSold >= MAX_ALLOWED_TOTAL;\n', '    }\n', '\n', '}']