['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'interface LandManagementInterface {\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    //    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function megaCandyToken() external view returns (address);\n', '    function userRankAddress() external view returns (address);\n', '    function candyLandAddress() external view returns (address);\n', '    function candyLandSaleAddress() external view returns (address);\n', '\n', '    function isUnicornContract(address _unicornContractAddress) external view returns (bool);\n', '\n', '    function paused() external view returns (bool);\n', '    function presaleOpen() external view returns (bool);\n', '    function firstRankForFree() external view returns (bool);\n', '\n', '    function ethLandSaleOpen() external view returns (bool);\n', '\n', '    function landPriceWei() external view returns (uint);\n', '    function landPriceCandy() external view returns (uint);\n', '\n', '    function registerInit(address _contract) external;\n', '}\n', '\n', 'interface UserRankInterface  {\n', '    function buyNextRank() external;\n', '    function buyRank(uint _index) external;\n', '    function getIndividualPrice(address _user, uint _index) external view returns (uint);\n', '    function getRankPriceEth(uint _index) external view returns (uint);\n', '    function getRankPriceCandy(uint _index) external view returns (uint);\n', '    function getRankLandLimit(uint _index) external view returns (uint);\n', '    function getRankTitle(uint _index) external view returns (string);\n', '    function getUserRank(address _user) external view returns (uint);\n', '    function getUserLandLimit(address _user) external view returns (uint);\n', '    function ranksCount() external view returns (uint);\n', '    function getNextRank(address _user)  external returns (uint);\n', '    function getPreSaleRank(address owner, uint _index) external;\n', '    function getRank(address owner, uint _index) external;\n', '}\n', '\n', 'contract MegaCandyInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract LandAccessControl {\n', '\n', '    LandManagementInterface public landManagement;\n', '\n', '    function LandAccessControl(address _landManagementAddress) public {\n', '        landManagement = LandManagementInterface(_landManagementAddress);\n', '        landManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == landManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == landManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == landManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!landManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(landManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhileEthSaleOpen {\n', '        require(landManagement.ethLandSaleOpen());\n', '        _;\n', '    }\n', '\n', '    modifier onlyLandManagement() {\n', '        require(msg.sender == address(landManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornContract() {\n', '        require(landManagement.isUnicornContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyCandyLand() {\n', '        require(msg.sender == address(landManagement.candyLandAddress()));\n', '        _;\n', '    }\n', '\n', '\n', '    modifier whilePresaleOpen() {\n', '        require(landManagement.presaleOpen());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return landManagement.paused();\n', '    }\n', '}\n', '\n', '\n', 'contract CanReceiveApproval {\n', '    event ReceiveApproval(address from, uint256 value, address token);\n', '\n', '    mapping (bytes4 => bool) allowedFuncs;\n', '\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length >= numwords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    modifier onlySelf(){\n', '        require(msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '\n', '    function bytesToBytes4(bytes b) internal pure returns (bytes4 out) {\n', '        for (uint i = 0; i < 4; i++) {\n', '            out |= bytes4(b[i] & 0xFF) >> (i << 3);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract CandyLand is ERC20, LandAccessControl, CanReceiveApproval {\n', '    using SafeMath for uint256;\n', '\n', '    UserRankInterface public userRank;\n', '    MegaCandyInterface public megaCandy;\n', '    ERC20 public candyToken;\n', '\n', '    struct Gardener {\n', '        uint period;\n', '        uint price;\n', '        bool exists;\n', '    }\n', '\n', '    struct Garden {\n', '        uint count;\n', '        uint startTime;\n', '        address owner;\n', '        uint gardenerId;\n', '        uint lastCropTime;\n', '        uint plantationIndex;\n', '        uint ownerPlantationIndex;\n', '    }\n', '\n', '    string public constant name = "Unicorn Land";\n', '    string public constant symbol = "Land";\n', '    uint8 public constant decimals = 0;\n', '\n', '    uint256 totalSupply_;\n', '    uint256 public MAX_SUPPLY = 30000;\n', '\n', '    uint public constant plantedTime = 1 hours;\n', '    uint public constant plantedRate = 1 ether;\n', '    //uint public constant priceRate = 1 ether;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '    mapping(address => uint256) planted;\n', '\n', '    mapping(uint => Gardener) public gardeners;\n', '    // Mapping from garden ID to Garde struct\n', '    mapping(uint => Garden) public gardens;\n', '\n', '    // garden index => gardenId\n', '    mapping(uint => uint) public plantation;\n', '    uint public plantationSize = 0;\n', '\n', '    //user plantations\n', '    // owner => array (index => gardenId)\n', '    mapping(address => mapping(uint => uint)) public ownerPlantation;\n', '    mapping(address => uint) public ownerPlantationSize;\n', '\n', '\n', '    uint gardenerId = 0;\n', '    uint gardenId = 0;\n', '\n', '\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MakePlant(address indexed owner, uint gardenId, uint count, uint gardenerId);\n', '    event GetCrop(address indexed owner, uint gardenId, uint  megaCandyCount);\n', '    event NewGardenerAdded(uint gardenerId, uint _period, uint _price);\n', '    event GardenerChange(uint gardenerId, uint _period, uint _price);\n', '    event NewLandLimit(uint newLimit);\n', '    event TokensTransferred(address wallet, uint value);\n', '\n', '    function CandyLand(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n', '        allowedFuncs[bytes4(keccak256("_receiveMakePlant(address,uint256,uint256)"))] = true;\n', '\n', '        addGardener(24,   700000000000000000);\n', '        addGardener(120, 3000000000000000000);\n', '        addGardener(240, 5000000000000000000);\n', '        addGardener(720,12000000000000000000);\n', '    }\n', '\n', '\n', '    function init() onlyLandManagement whenPaused external {\n', '        userRank = UserRankInterface(landManagement.userRankAddress());\n', '        megaCandy = MegaCandyInterface(landManagement.megaCandyToken());\n', '        candyToken = ERC20(landManagement.candyToken());\n', '    }\n', '\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender].sub(planted[msg.sender]));\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function plantedOf(address _owner) public view returns (uint256 balance) {\n', '        return planted[_owner];\n', '    }\n', '\n', '    function freeLandsOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner].sub(planted[_owner]);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from].sub(planted[_from]));\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function transferFromSystem(address _from, address _to, uint256 _value) onlyUnicornContract public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from].sub(planted[_from]));\n', '        //    require(_value <= balances[_from]);\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) onlyUnicornContract public returns (bool) {\n', '        require(totalSupply_.add(_amount) <= MAX_SUPPLY);\n', '        require(balances[_to].add(_amount) <= userRank.getUserLandLimit(_to));\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function makePlant(uint _count, uint _gardenerId) public {\n', '        _makePlant(msg.sender, _count, _gardenerId);\n', '    }\n', '\n', '\n', '    function _receiveMakePlant(address _beneficiary, uint _count, uint _gardenerId) onlySelf onlyPayloadSize(3) public {\n', '        _makePlant(_beneficiary, _count, _gardenerId);\n', '    }\n', '\n', '\n', '    function _makePlant(address _owner, uint _count, uint _gardenerId) internal {\n', '        require(_count <= balances[_owner].sub(planted[_owner]) && _count > 0);\n', '\n', '        //require(candyToken.transferFrom(msg.sender, this, _count.mul(priceRate)));\n', '\n', '        if (_gardenerId > 0) {\n', '            require(gardeners[_gardenerId].exists);\n', '            require(candyToken.transferFrom(_owner, this, gardeners[_gardenerId].price.mul(_count)));\n', '        }\n', '\n', '        gardens[++gardenId] = Garden({\n', '            count: _count,\n', '            startTime: now,\n', '            owner: _owner,\n', '            gardenerId: _gardenerId,\n', '            lastCropTime: now,\n', '            plantationIndex: plantationSize,\n', '            ownerPlantationIndex: ownerPlantationSize[_owner]\n', '            });\n', '\n', '        planted[_owner] = planted[_owner].add(_count);\n', '        //update global plantation list\n', '        plantation[plantationSize++] = gardenId;\n', '        //update user plantation list\n', '        ownerPlantation[_owner][ownerPlantationSize[_owner]++] = gardenId;\n', '\n', '        emit MakePlant(_owner, gardenId, _count, gardenerId);\n', '    }\n', '\n', '\n', '    function getCrop(uint _gardenId) public {\n', '        require(msg.sender == gardens[_gardenId].owner);\n', '        require(now >= gardens[_gardenId].lastCropTime.add(plantedTime));\n', '\n', '        uint crop = 0;\n', '        uint cropCount = 1;\n', '        uint remainingCrops = 0;\n', '\n', '        if (gardens[_gardenId].gardenerId > 0) {\n', '            uint finishTime = gardens[_gardenId].startTime.add(gardeners[gardens[_gardenId].gardenerId].period);\n', '            //время текущей сбоки урожая\n', '            uint currentCropTime = now < finishTime ? now : finishTime;\n', '            //количество урожаев которое соберем сейчас\n', '            cropCount = currentCropTime.sub(gardens[_gardenId].lastCropTime).div(plantedTime);\n', '            //время последней сборки урожая + время 1 урожая на количество урожаев которое соберем сейчас\n', '            gardens[_gardenId].lastCropTime = gardens[_gardenId].lastCropTime.add(cropCount.mul(plantedTime));\n', '            //количество оставшихся урожаев\n', '            remainingCrops = finishTime.sub(gardens[_gardenId].lastCropTime).div(plantedTime);\n', '        }\n', '\n', '        crop = gardens[_gardenId].count.mul(plantedRate).mul(cropCount);\n', '        if (remainingCrops == 0) {\n', '            planted[msg.sender] = planted[msg.sender].sub(gardens[_gardenId].count);\n', '\n', '            //delete from global plantation list\n', '            gardens[plantation[--plantationSize]].plantationIndex = gardens[_gardenId].plantationIndex;\n', '            plantation[gardens[_gardenId].plantationIndex] = plantation[plantationSize];\n', '            delete plantation[plantationSize];\n', '\n', '            //delete from user plantation list\n', '            gardens[ownerPlantation[msg.sender][--ownerPlantationSize[msg.sender]]].ownerPlantationIndex = gardens[_gardenId].ownerPlantationIndex;\n', '            ownerPlantation[msg.sender][gardens[_gardenId].ownerPlantationIndex] = ownerPlantation[msg.sender][ownerPlantationSize[msg.sender]];\n', '            delete ownerPlantation[msg.sender][ownerPlantationSize[msg.sender]];\n', '\n', '            delete gardens[_gardenId];\n', '\n', '        }\n', '\n', '        megaCandy.mint(msg.sender, crop);\n', '        emit GetCrop(msg.sender, _gardenId, crop);\n', '    }\n', '\n', '\n', '    function addGardener(uint _period, uint _price) onlyOwner public  {\n', '        gardeners[++gardenerId] = Gardener({\n', '            period: _period * 1 hours,\n', '            price: _price,\n', '            exists: true\n', '            });\n', '        emit NewGardenerAdded(gardenerId, _period, _price);\n', '    }\n', '\n', '\n', '    function editGardener(uint _gardenerId, uint _period, uint _price) onlyOwner public  {\n', '        require(gardeners[_gardenerId].exists);\n', '        Gardener storage g = gardeners[_gardenerId];\n', '        g.period = _period;\n', '        g.price = _price;\n', '        emit GardenerChange(_gardenerId, _period, _price);\n', '    }\n', '\n', '\n', '    function getUserLandLimit(address _user) public view returns(uint) {\n', '        return userRank.getRankLandLimit(userRank.getUserRank(_user)).sub(balances[_user]);\n', '    }\n', '\n', '\n', '    function setLandLimit() external onlyCommunity {\n', '        require(totalSupply_ == MAX_SUPPLY);\n', '        MAX_SUPPLY = MAX_SUPPLY.add(1000);\n', '        emit NewLandLimit(MAX_SUPPLY);\n', '    }\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '        //require(_token == landManagement.candyToken());\n', '        require(msg.sender == address(candyToken));\n', '        require(allowedFuncs[bytesToBytes4(_extraData)]);\n', '        require(address(this).call(_extraData));\n', '        emit ReceiveApproval(_from, _value, _token);\n', '    }\n', '\n', '\n', '    function withdrawTokens() onlyManager public {\n', '        require(candyToken.balanceOf(this) > 0);\n', '        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n', '        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n', '    }\n', '\n', '}']
['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'interface LandManagementInterface {\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    //    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function megaCandyToken() external view returns (address);\n', '    function userRankAddress() external view returns (address);\n', '    function candyLandAddress() external view returns (address);\n', '    function candyLandSaleAddress() external view returns (address);\n', '\n', '    function isUnicornContract(address _unicornContractAddress) external view returns (bool);\n', '\n', '    function paused() external view returns (bool);\n', '    function presaleOpen() external view returns (bool);\n', '    function firstRankForFree() external view returns (bool);\n', '\n', '    function ethLandSaleOpen() external view returns (bool);\n', '\n', '    function landPriceWei() external view returns (uint);\n', '    function landPriceCandy() external view returns (uint);\n', '\n', '    function registerInit(address _contract) external;\n', '}\n', '\n', 'interface UserRankInterface  {\n', '    function buyNextRank() external;\n', '    function buyRank(uint _index) external;\n', '    function getIndividualPrice(address _user, uint _index) external view returns (uint);\n', '    function getRankPriceEth(uint _index) external view returns (uint);\n', '    function getRankPriceCandy(uint _index) external view returns (uint);\n', '    function getRankLandLimit(uint _index) external view returns (uint);\n', '    function getRankTitle(uint _index) external view returns (string);\n', '    function getUserRank(address _user) external view returns (uint);\n', '    function getUserLandLimit(address _user) external view returns (uint);\n', '    function ranksCount() external view returns (uint);\n', '    function getNextRank(address _user)  external returns (uint);\n', '    function getPreSaleRank(address owner, uint _index) external;\n', '    function getRank(address owner, uint _index) external;\n', '}\n', '\n', 'contract MegaCandyInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract LandAccessControl {\n', '\n', '    LandManagementInterface public landManagement;\n', '\n', '    function LandAccessControl(address _landManagementAddress) public {\n', '        landManagement = LandManagementInterface(_landManagementAddress);\n', '        landManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == landManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == landManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == landManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!landManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(landManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhileEthSaleOpen {\n', '        require(landManagement.ethLandSaleOpen());\n', '        _;\n', '    }\n', '\n', '    modifier onlyLandManagement() {\n', '        require(msg.sender == address(landManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornContract() {\n', '        require(landManagement.isUnicornContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyCandyLand() {\n', '        require(msg.sender == address(landManagement.candyLandAddress()));\n', '        _;\n', '    }\n', '\n', '\n', '    modifier whilePresaleOpen() {\n', '        require(landManagement.presaleOpen());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return landManagement.paused();\n', '    }\n', '}\n', '\n', '\n', 'contract CanReceiveApproval {\n', '    event ReceiveApproval(address from, uint256 value, address token);\n', '\n', '    mapping (bytes4 => bool) allowedFuncs;\n', '\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length >= numwords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    modifier onlySelf(){\n', '        require(msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '\n', '    function bytesToBytes4(bytes b) internal pure returns (bytes4 out) {\n', '        for (uint i = 0; i < 4; i++) {\n', '            out |= bytes4(b[i] & 0xFF) >> (i << 3);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract CandyLand is ERC20, LandAccessControl, CanReceiveApproval {\n', '    using SafeMath for uint256;\n', '\n', '    UserRankInterface public userRank;\n', '    MegaCandyInterface public megaCandy;\n', '    ERC20 public candyToken;\n', '\n', '    struct Gardener {\n', '        uint period;\n', '        uint price;\n', '        bool exists;\n', '    }\n', '\n', '    struct Garden {\n', '        uint count;\n', '        uint startTime;\n', '        address owner;\n', '        uint gardenerId;\n', '        uint lastCropTime;\n', '        uint plantationIndex;\n', '        uint ownerPlantationIndex;\n', '    }\n', '\n', '    string public constant name = "Unicorn Land";\n', '    string public constant symbol = "Land";\n', '    uint8 public constant decimals = 0;\n', '\n', '    uint256 totalSupply_;\n', '    uint256 public MAX_SUPPLY = 30000;\n', '\n', '    uint public constant plantedTime = 1 hours;\n', '    uint public constant plantedRate = 1 ether;\n', '    //uint public constant priceRate = 1 ether;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '    mapping(address => uint256) planted;\n', '\n', '    mapping(uint => Gardener) public gardeners;\n', '    // Mapping from garden ID to Garde struct\n', '    mapping(uint => Garden) public gardens;\n', '\n', '    // garden index => gardenId\n', '    mapping(uint => uint) public plantation;\n', '    uint public plantationSize = 0;\n', '\n', '    //user plantations\n', '    // owner => array (index => gardenId)\n', '    mapping(address => mapping(uint => uint)) public ownerPlantation;\n', '    mapping(address => uint) public ownerPlantationSize;\n', '\n', '\n', '    uint gardenerId = 0;\n', '    uint gardenId = 0;\n', '\n', '\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MakePlant(address indexed owner, uint gardenId, uint count, uint gardenerId);\n', '    event GetCrop(address indexed owner, uint gardenId, uint  megaCandyCount);\n', '    event NewGardenerAdded(uint gardenerId, uint _period, uint _price);\n', '    event GardenerChange(uint gardenerId, uint _period, uint _price);\n', '    event NewLandLimit(uint newLimit);\n', '    event TokensTransferred(address wallet, uint value);\n', '\n', '    function CandyLand(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n', '        allowedFuncs[bytes4(keccak256("_receiveMakePlant(address,uint256,uint256)"))] = true;\n', '\n', '        addGardener(24,   700000000000000000);\n', '        addGardener(120, 3000000000000000000);\n', '        addGardener(240, 5000000000000000000);\n', '        addGardener(720,12000000000000000000);\n', '    }\n', '\n', '\n', '    function init() onlyLandManagement whenPaused external {\n', '        userRank = UserRankInterface(landManagement.userRankAddress());\n', '        megaCandy = MegaCandyInterface(landManagement.megaCandyToken());\n', '        candyToken = ERC20(landManagement.candyToken());\n', '    }\n', '\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender].sub(planted[msg.sender]));\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function plantedOf(address _owner) public view returns (uint256 balance) {\n', '        return planted[_owner];\n', '    }\n', '\n', '    function freeLandsOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner].sub(planted[_owner]);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from].sub(planted[_from]));\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function transferFromSystem(address _from, address _to, uint256 _value) onlyUnicornContract public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from].sub(planted[_from]));\n', '        //    require(_value <= balances[_from]);\n', '        require(balances[_to].add(_value) <= userRank.getUserLandLimit(_to));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) onlyUnicornContract public returns (bool) {\n', '        require(totalSupply_.add(_amount) <= MAX_SUPPLY);\n', '        require(balances[_to].add(_amount) <= userRank.getUserLandLimit(_to));\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function makePlant(uint _count, uint _gardenerId) public {\n', '        _makePlant(msg.sender, _count, _gardenerId);\n', '    }\n', '\n', '\n', '    function _receiveMakePlant(address _beneficiary, uint _count, uint _gardenerId) onlySelf onlyPayloadSize(3) public {\n', '        _makePlant(_beneficiary, _count, _gardenerId);\n', '    }\n', '\n', '\n', '    function _makePlant(address _owner, uint _count, uint _gardenerId) internal {\n', '        require(_count <= balances[_owner].sub(planted[_owner]) && _count > 0);\n', '\n', '        //require(candyToken.transferFrom(msg.sender, this, _count.mul(priceRate)));\n', '\n', '        if (_gardenerId > 0) {\n', '            require(gardeners[_gardenerId].exists);\n', '            require(candyToken.transferFrom(_owner, this, gardeners[_gardenerId].price.mul(_count)));\n', '        }\n', '\n', '        gardens[++gardenId] = Garden({\n', '            count: _count,\n', '            startTime: now,\n', '            owner: _owner,\n', '            gardenerId: _gardenerId,\n', '            lastCropTime: now,\n', '            plantationIndex: plantationSize,\n', '            ownerPlantationIndex: ownerPlantationSize[_owner]\n', '            });\n', '\n', '        planted[_owner] = planted[_owner].add(_count);\n', '        //update global plantation list\n', '        plantation[plantationSize++] = gardenId;\n', '        //update user plantation list\n', '        ownerPlantation[_owner][ownerPlantationSize[_owner]++] = gardenId;\n', '\n', '        emit MakePlant(_owner, gardenId, _count, gardenerId);\n', '    }\n', '\n', '\n', '    function getCrop(uint _gardenId) public {\n', '        require(msg.sender == gardens[_gardenId].owner);\n', '        require(now >= gardens[_gardenId].lastCropTime.add(plantedTime));\n', '\n', '        uint crop = 0;\n', '        uint cropCount = 1;\n', '        uint remainingCrops = 0;\n', '\n', '        if (gardens[_gardenId].gardenerId > 0) {\n', '            uint finishTime = gardens[_gardenId].startTime.add(gardeners[gardens[_gardenId].gardenerId].period);\n', '            //время текущей сбоки урожая\n', '            uint currentCropTime = now < finishTime ? now : finishTime;\n', '            //количество урожаев которое соберем сейчас\n', '            cropCount = currentCropTime.sub(gardens[_gardenId].lastCropTime).div(plantedTime);\n', '            //время последней сборки урожая + время 1 урожая на количество урожаев которое соберем сейчас\n', '            gardens[_gardenId].lastCropTime = gardens[_gardenId].lastCropTime.add(cropCount.mul(plantedTime));\n', '            //количество оставшихся урожаев\n', '            remainingCrops = finishTime.sub(gardens[_gardenId].lastCropTime).div(plantedTime);\n', '        }\n', '\n', '        crop = gardens[_gardenId].count.mul(plantedRate).mul(cropCount);\n', '        if (remainingCrops == 0) {\n', '            planted[msg.sender] = planted[msg.sender].sub(gardens[_gardenId].count);\n', '\n', '            //delete from global plantation list\n', '            gardens[plantation[--plantationSize]].plantationIndex = gardens[_gardenId].plantationIndex;\n', '            plantation[gardens[_gardenId].plantationIndex] = plantation[plantationSize];\n', '            delete plantation[plantationSize];\n', '\n', '            //delete from user plantation list\n', '            gardens[ownerPlantation[msg.sender][--ownerPlantationSize[msg.sender]]].ownerPlantationIndex = gardens[_gardenId].ownerPlantationIndex;\n', '            ownerPlantation[msg.sender][gardens[_gardenId].ownerPlantationIndex] = ownerPlantation[msg.sender][ownerPlantationSize[msg.sender]];\n', '            delete ownerPlantation[msg.sender][ownerPlantationSize[msg.sender]];\n', '\n', '            delete gardens[_gardenId];\n', '\n', '        }\n', '\n', '        megaCandy.mint(msg.sender, crop);\n', '        emit GetCrop(msg.sender, _gardenId, crop);\n', '    }\n', '\n', '\n', '    function addGardener(uint _period, uint _price) onlyOwner public  {\n', '        gardeners[++gardenerId] = Gardener({\n', '            period: _period * 1 hours,\n', '            price: _price,\n', '            exists: true\n', '            });\n', '        emit NewGardenerAdded(gardenerId, _period, _price);\n', '    }\n', '\n', '\n', '    function editGardener(uint _gardenerId, uint _period, uint _price) onlyOwner public  {\n', '        require(gardeners[_gardenerId].exists);\n', '        Gardener storage g = gardeners[_gardenerId];\n', '        g.period = _period;\n', '        g.price = _price;\n', '        emit GardenerChange(_gardenerId, _period, _price);\n', '    }\n', '\n', '\n', '    function getUserLandLimit(address _user) public view returns(uint) {\n', '        return userRank.getRankLandLimit(userRank.getUserRank(_user)).sub(balances[_user]);\n', '    }\n', '\n', '\n', '    function setLandLimit() external onlyCommunity {\n', '        require(totalSupply_ == MAX_SUPPLY);\n', '        MAX_SUPPLY = MAX_SUPPLY.add(1000);\n', '        emit NewLandLimit(MAX_SUPPLY);\n', '    }\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '        //require(_token == landManagement.candyToken());\n', '        require(msg.sender == address(candyToken));\n', '        require(allowedFuncs[bytesToBytes4(_extraData)]);\n', '        require(address(this).call(_extraData));\n', '        emit ReceiveApproval(_from, _value, _token);\n', '    }\n', '\n', '\n', '    function withdrawTokens() onlyManager public {\n', '        require(candyToken.balanceOf(this) > 0);\n', '        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n', '        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n', '    }\n', '\n', '}']
