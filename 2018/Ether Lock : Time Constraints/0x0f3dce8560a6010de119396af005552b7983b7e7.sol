['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.19;\n', '/// @title Ethereum Address Register Contract\n', '/// @dev This contract maintains a name service for addresses and miner.\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f19a9e9f969d98909f96b19d9e9e8183989f96df9e8396">[email&#160;protected]</a>>,\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1470757a7d717854787b7b64667d7a733a7b6673">[email&#160;protected]</a>>,\n', 'contract NameRegistry {\n', '    uint public nextId = 0;\n', '    mapping (uint    => Participant) public participantMap;\n', '    mapping (address => NameInfo)    public nameInfoMap;\n', '    mapping (bytes12 => address)     public ownerMap;\n', '    mapping (address => string)      public nameMap;\n', '    struct NameInfo {\n', '        bytes12  name;\n', '        uint[]   participantIds;\n', '    }\n', '    struct Participant {\n', '        address feeRecipient;\n', '        address signer;\n', '        bytes12 name;\n', '        address owner;\n', '    }\n', '    event NameRegistered (\n', '        string            name,\n', '        address   indexed owner\n', '    );\n', '    event NameUnregistered (\n', '        string             name,\n', '        address    indexed owner\n', '    );\n', '    event OwnershipTransfered (\n', '        bytes12            name,\n', '        address            oldOwner,\n', '        address            newOwner\n', '    );\n', '    event ParticipantRegistered (\n', '        bytes12           name,\n', '        address   indexed owner,\n', '        uint      indexed participantId,\n', '        address           singer,\n', '        address           feeRecipient\n', '    );\n', '    event ParticipantUnregistered (\n', '        uint    participantId,\n', '        address owner\n', '    );\n', '    function registerName(string name)\n', '        external\n', '    {\n', '        require(isNameValid(name));\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(ownerMap[nameBytes] == 0x0);\n', '        require(stringToBytes12(nameMap[msg.sender]) == bytes12(0x0));\n', '        nameInfoMap[msg.sender] = NameInfo(nameBytes, new uint[](0));\n', '        ownerMap[nameBytes] = msg.sender;\n', '        nameMap[msg.sender] = name;\n', '        NameRegistered(name, msg.sender);\n', '    }\n', '    function unregisterName(string name)\n', '        external\n', '    {\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(nameInfo.name == nameBytes);\n', '        for (uint i = participantIds.length - 1; i >= 0; i--) {\n', '            delete participantMap[participantIds[i]];\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        delete ownerMap[nameBytes];\n', '        NameUnregistered(name, msg.sender);\n', '    }\n', '    function transferOwnership(address newOwner)\n', '        external\n', '    {\n', '        require(newOwner != 0x0);\n', '        require(nameInfoMap[newOwner].name.length == 0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        string storage name = nameMap[msg.sender];\n', '        uint[] memory participantIds = nameInfo.participantIds;\n', '        for (uint i = 0; i < participantIds.length; i ++) {\n', '            Participant storage p = participantMap[participantIds[i]];\n', '            p.owner = newOwner;\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        nameInfoMap[newOwner] = nameInfo;\n', '        nameMap[newOwner] = name;\n', '        OwnershipTransfered(nameInfo.name, msg.sender, newOwner);\n', '    }\n', '    /* function addParticipant(address feeRecipient) */\n', '    /*     external */\n', '    /*     returns (uint) */\n', '    /* { */\n', '    /*     return addParticipant(feeRecipient, feeRecipient); */\n', '    /* } */\n', '    function addParticipant(\n', '        address feeRecipient,\n', '        address singer\n', '        )\n', '        external\n', '        returns (uint)\n', '    {\n', '        require(feeRecipient != 0x0 && singer != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        bytes12 name = nameInfo.name;\n', '        require(name.length > 0);\n', '        Participant memory participant = Participant(\n', '            feeRecipient,\n', '            singer,\n', '            name,\n', '            msg.sender\n', '        );\n', '        uint participantId = ++nextId;\n', '        participantMap[participantId] = participant;\n', '        nameInfo.participantIds.push(participantId);\n', '        ParticipantRegistered(\n', '            name,\n', '            msg.sender,\n', '            participantId,\n', '            singer,\n', '            feeRecipient\n', '        );\n', '        return participantId;\n', '    }\n', '    function removeParticipant(uint participantId)\n', '        external\n', '    {\n', '        require(msg.sender == participantMap[participantId].owner);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        delete participantMap[participantId];\n', '        uint len = participantIds.length;\n', '        for (uint i = 0; i < len; i ++) {\n', '            if (participantId == participantIds[i]) {\n', '                participantIds[i] = participantIds[len - 1];\n', '                participantIds.length -= 1;\n', '            }\n', '        }\n', '        ParticipantUnregistered(participantId, msg.sender);\n', '    }\n', '    function getParticipantById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient, address signer)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '        signer = addressSet.signer;\n', '    }\n', '    function getParticipantIds(string name, uint start, uint count)\n', '        external\n', '        view\n', '        returns (uint[] idList)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        address owner = ownerMap[nameBytes];\n', '        require(owner != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[owner];\n', '        uint[] storage pIds = nameInfo.participantIds;\n', '        uint len = pIds.length;\n', '        if (start >= len) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > len) {\n', '            end = len;\n', '        }\n', '        if (start == end) {\n', '            return;\n', '        }\n', '        idList = new uint[](end - start);\n', '        for (uint i = start; i < end; i ++) {\n', '            idList[i - start] = pIds[i];\n', '        }\n', '    }\n', '    function getOwner(string name)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        return ownerMap[nameBytes];\n', '    }\n', '    function isNameValid(string name)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory temp = bytes(name);\n', '        return temp.length >= 6 && temp.length <= 12;\n', '    }\n', '    function stringToBytes12(string str)\n', '        internal\n', '        pure\n', '        returns (bytes12 result)\n', '    {\n', '        assembly {\n', '            result := mload(add(str, 12))\n', '        }\n', '    }\n', '}']
['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.19;\n', '/// @title Ethereum Address Register Contract\n', '/// @dev This contract maintains a name service for addresses and miner.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', 'contract NameRegistry {\n', '    uint public nextId = 0;\n', '    mapping (uint    => Participant) public participantMap;\n', '    mapping (address => NameInfo)    public nameInfoMap;\n', '    mapping (bytes12 => address)     public ownerMap;\n', '    mapping (address => string)      public nameMap;\n', '    struct NameInfo {\n', '        bytes12  name;\n', '        uint[]   participantIds;\n', '    }\n', '    struct Participant {\n', '        address feeRecipient;\n', '        address signer;\n', '        bytes12 name;\n', '        address owner;\n', '    }\n', '    event NameRegistered (\n', '        string            name,\n', '        address   indexed owner\n', '    );\n', '    event NameUnregistered (\n', '        string             name,\n', '        address    indexed owner\n', '    );\n', '    event OwnershipTransfered (\n', '        bytes12            name,\n', '        address            oldOwner,\n', '        address            newOwner\n', '    );\n', '    event ParticipantRegistered (\n', '        bytes12           name,\n', '        address   indexed owner,\n', '        uint      indexed participantId,\n', '        address           singer,\n', '        address           feeRecipient\n', '    );\n', '    event ParticipantUnregistered (\n', '        uint    participantId,\n', '        address owner\n', '    );\n', '    function registerName(string name)\n', '        external\n', '    {\n', '        require(isNameValid(name));\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(ownerMap[nameBytes] == 0x0);\n', '        require(stringToBytes12(nameMap[msg.sender]) == bytes12(0x0));\n', '        nameInfoMap[msg.sender] = NameInfo(nameBytes, new uint[](0));\n', '        ownerMap[nameBytes] = msg.sender;\n', '        nameMap[msg.sender] = name;\n', '        NameRegistered(name, msg.sender);\n', '    }\n', '    function unregisterName(string name)\n', '        external\n', '    {\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(nameInfo.name == nameBytes);\n', '        for (uint i = participantIds.length - 1; i >= 0; i--) {\n', '            delete participantMap[participantIds[i]];\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        delete ownerMap[nameBytes];\n', '        NameUnregistered(name, msg.sender);\n', '    }\n', '    function transferOwnership(address newOwner)\n', '        external\n', '    {\n', '        require(newOwner != 0x0);\n', '        require(nameInfoMap[newOwner].name.length == 0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        string storage name = nameMap[msg.sender];\n', '        uint[] memory participantIds = nameInfo.participantIds;\n', '        for (uint i = 0; i < participantIds.length; i ++) {\n', '            Participant storage p = participantMap[participantIds[i]];\n', '            p.owner = newOwner;\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        nameInfoMap[newOwner] = nameInfo;\n', '        nameMap[newOwner] = name;\n', '        OwnershipTransfered(nameInfo.name, msg.sender, newOwner);\n', '    }\n', '    /* function addParticipant(address feeRecipient) */\n', '    /*     external */\n', '    /*     returns (uint) */\n', '    /* { */\n', '    /*     return addParticipant(feeRecipient, feeRecipient); */\n', '    /* } */\n', '    function addParticipant(\n', '        address feeRecipient,\n', '        address singer\n', '        )\n', '        external\n', '        returns (uint)\n', '    {\n', '        require(feeRecipient != 0x0 && singer != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        bytes12 name = nameInfo.name;\n', '        require(name.length > 0);\n', '        Participant memory participant = Participant(\n', '            feeRecipient,\n', '            singer,\n', '            name,\n', '            msg.sender\n', '        );\n', '        uint participantId = ++nextId;\n', '        participantMap[participantId] = participant;\n', '        nameInfo.participantIds.push(participantId);\n', '        ParticipantRegistered(\n', '            name,\n', '            msg.sender,\n', '            participantId,\n', '            singer,\n', '            feeRecipient\n', '        );\n', '        return participantId;\n', '    }\n', '    function removeParticipant(uint participantId)\n', '        external\n', '    {\n', '        require(msg.sender == participantMap[participantId].owner);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        delete participantMap[participantId];\n', '        uint len = participantIds.length;\n', '        for (uint i = 0; i < len; i ++) {\n', '            if (participantId == participantIds[i]) {\n', '                participantIds[i] = participantIds[len - 1];\n', '                participantIds.length -= 1;\n', '            }\n', '        }\n', '        ParticipantUnregistered(participantId, msg.sender);\n', '    }\n', '    function getParticipantById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient, address signer)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '        signer = addressSet.signer;\n', '    }\n', '    function getParticipantIds(string name, uint start, uint count)\n', '        external\n', '        view\n', '        returns (uint[] idList)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        address owner = ownerMap[nameBytes];\n', '        require(owner != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[owner];\n', '        uint[] storage pIds = nameInfo.participantIds;\n', '        uint len = pIds.length;\n', '        if (start >= len) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > len) {\n', '            end = len;\n', '        }\n', '        if (start == end) {\n', '            return;\n', '        }\n', '        idList = new uint[](end - start);\n', '        for (uint i = start; i < end; i ++) {\n', '            idList[i - start] = pIds[i];\n', '        }\n', '    }\n', '    function getOwner(string name)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        return ownerMap[nameBytes];\n', '    }\n', '    function isNameValid(string name)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory temp = bytes(name);\n', '        return temp.length >= 6 && temp.length <= 12;\n', '    }\n', '    function stringToBytes12(string str)\n', '        internal\n', '        pure\n', '        returns (bytes12 result)\n', '    {\n', '        assembly {\n', '            result := mload(add(str, 12))\n', '        }\n', '    }\n', '}']
