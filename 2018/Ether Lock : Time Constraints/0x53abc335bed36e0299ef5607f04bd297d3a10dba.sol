['pragma solidity ^0.4.20;\n', '\n', '/** \n', ' * Created by RigCraft Team\n', ' * If you have any questions please visit the official discord channel\n', ' * https://discord.gg/zJCf7Fh\n', ' * or read The FAQ at \n', ' * https://rigcraft.io/#faq\n', ' **/\n', '\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data ) public;\n', '}\n', '\n', 'contract ERC721Receiver {\n', '\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  function onERC721Received(address _from,uint256 _tokenId,bytes _data) public returns(bytes4);\n', '}\n', '\n', 'contract ERC721Metadata {\n', '   \n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'contract Administration\n', '{\n', '    address owner;\n', '    bool active = true;\n', '    bool open = true;\n', '    \n', '    function Administration() public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() \n', '    {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    modifier isActive()\n', '    {\n', '        require(active == true);\n', '        _;\n', '    }\n', '    \n', '    modifier isOpen()\n', '    {\n', '        require(open == true);\n', '        _;\n', '    }\n', '    \n', '    function setActive(bool _active) external onlyOwner\n', '    {\n', '        active = _active;\n', '    }\n', '    \n', '    function setOpen(bool _open) external onlyOwner\n', '    {\n', '        open = _open;\n', '    }\n', '}\n', '\n', '// core\n', 'contract RigCraftPresalePackageToken is ERC721Basic, Administration, ERC721Metadata {\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '    \n', '    struct PresalePackage\n', '    {\n', '        uint8 packageId;\n', '        uint16 serialNumber;\n', '    }\n', '    \n', '    PresalePackage[] packages;\n', '    \n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) internal tokenOwner;\n', '    mapping (uint256 => address) internal tokenApprovals;\n', '    mapping (address => uint256) internal ownedTokensCount;\n', '    mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '    \n', '    RigCraftPresalePackageManager private presaleHandler;\n', '    string URIBase;\n', '    \n', '    string public constant name = "RigCraftPresalePackage";\n', '    string public constant symbol = "RCPT";\n', '    \n', '    function SetPresaleHandler(address addr) external onlyOwner\n', '    {\n', '        presaleHandler = RigCraftPresalePackageManager(addr);\n', '    }\n', '    \n', '    function setURIBase(string _base) external onlyOwner\n', '    {\n', '        URIBase = _base;\n', '    }\n', '    \n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        require(ownerOf(_tokenId) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(uint256 _tokenId) {\n', '        require(isApprovedOrOwner(msg.sender, _tokenId));\n', '        _;\n', '    }\n', '    \n', '    /**\n', '    * PUBLIC INTERFACE\n', '    **/\n', '    function balanceOf(address _owner) public view isOpen returns (uint256) {\n', '        require(_owner != address(0));\n', '        return ownedTokensCount[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view isOpen returns (address) {\n', '        address owner = tokenOwner[_tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    function exists(uint256 _tokenId) public view isOpen returns (bool) {\n', '        address owner = tokenOwner[_tokenId];\n', '        return owner != address(0);\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return packages.length;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    isOpen\n', '    isActive\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        require(_to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '        \n', '        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '            tokenApprovals[_tokenId] = _to;\n', '            emit Approval(owner, _to, _tokenId);\n', '        }\n', '    }\n', '    \n', '    function getApproved(uint256 _tokenId) public view isOpen returns (address) {\n', '        return tokenApprovals[_tokenId];\n', '    }\n', '    \n', '    function setApprovalForAll(address _to, bool _approved) public\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(_to != msg.sender);\n', '        operatorApprovals[msg.sender][_to] = _approved;\n', '        emit ApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', '\n', '    function isApprovedForAll( address _owner, address _operator) public view\n', '    isOpen\n', '    returns (bool)\n', '    {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        \n', '        clearApproval(_from, _tokenId);\n', '        removeTokenFrom(_from, _tokenId);\n', '        addTokenTo(_to, _tokenId);\n', '        \n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data)\n', '    public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        transferFrom(_from, _to, _tokenId);\n', '        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '    }\n', '\n', '    /**\n', '    * INTERNALS\n', '    **/\n', '    function isApprovedOrOwner(address _spender,uint256 _tokenId) internal view\n', '    returns (bool)\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        return (_spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender));\n', '    }\n', '    \n', '    function clearApproval(address _owner, uint256 _tokenId) internal {\n', '        require(ownerOf(_tokenId) == _owner);\n', '        if (tokenApprovals[_tokenId] != address(0)) {\n', '            tokenApprovals[_tokenId] = address(0);\n', '            emit Approval(_owner, address(0), _tokenId);\n', '        }\n', '    }\n', '\n', '    function addTokenTo(address _to, uint256 _tokenId) internal \n', '    {\n', '        require(tokenOwner[_tokenId] == address(0));\n', '        tokenOwner[_tokenId] = _to;\n', '        ownedTokensCount[_to] += 1;\n', '    }\n', '\n', '    function removeTokenFrom(address _from, uint256 _tokenId) internal \n', '    {\n', '        require(ownerOf(_tokenId) == _from);\n', '        require(ownedTokensCount[_from] > 0);\n', '        ownedTokensCount[_from] -= 1;\n', '        tokenOwner[_tokenId] = address(0);\n', '    }\n', '\n', '    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data)\n', '    internal\n', '    returns (bool)\n', '    {\n', '        uint256 codeSize;\n', '        assembly { codeSize := extcodesize(_to) }\n', '        if (codeSize == 0) {\n', '            return true;\n', '        }\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '    \n', '    function tokenURI(uint256 _tokenId) external view returns (string)\n', '    {\n', '        string memory tokenNumber = uint2str(_tokenId);\n', '        \n', '        uint pos = bytes(URIBase).length;\n', '        bytes memory retVal  = new bytes(bytes(tokenNumber).length + bytes(URIBase).length);\n', '        uint i = 0;\n', '        \n', '        for(i = 0; i < bytes(URIBase).length; ++i)\n', '        {\n', '            retVal[i] = bytes(URIBase)[i];\n', '        }\n', '        for(i = 0; i < bytes(tokenNumber).length; ++i)\n', '        {\n', '            retVal[pos + i] = bytes(tokenNumber)[i];\n', '        }\n', '        \n', '        return string(retVal);\n', '    }\n', '    \n', '    function uint2str(uint256 i) internal pure returns (string)\n', '    {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint length;\n', '        while (j != 0){\n', '            length++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(length);\n', '        uint k = length - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    \n', '    // Get all token IDs of address\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) \n', '    {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        \n', '        if (tokenCount == 0) \n', '        {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else \n', '        {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 resultIndex = 0;\n', '            \n', '            // We count on the fact that all cats have IDs starting at 1 and increasing\n', '            // sequentially up to the totalCat count.\n', '            uint256 tokenId;\n', '            \n', '            for (tokenId = 0; tokenId < packages.length; tokenId++) \n', '            {\n', '                if (tokenOwner[tokenId] == _owner) \n', '                {\n', '                    result[resultIndex] = tokenId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '        \n', '            return result;\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * EXTERNALS\n', '    **/\n', '    function GetTokenData(uint256 _tokenId) external view returns(uint8 presalePackadeId, uint16 serialNO) \n', '    {\n', '        require(_tokenId < packages.length);\n', '        \n', '        presalePackadeId = packages[_tokenId].packageId;\n', '        serialNO = packages[_tokenId].serialNumber;\n', '    }\n', '    \n', '    function CreateToken(address _owner, uint8 _packageId, uint16 _serial) external\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(msg.sender == address(presaleHandler));\n', '        uint256 tokenId = packages.length;\n', '        packages.length += 1;\n', '        \n', '        packages[tokenId].packageId = _packageId;\n', '        packages[tokenId].serialNumber = _serial;\n', '        \n', '        addTokenTo(_owner, tokenId);\n', '    }\n', '}\n', '\n', '// presale\n', 'contract RigCraftPresalePackageManager\n', '{\n', '    address owner;\n', '    \n', '    bool public isActive;\n', '    \n', '    uint16[]    public presalePackSold;\n', '    uint16[]    public presalePackLimit;\n', '    uint256[]   public presalePackagePrice;\n', '    \n', '    mapping(address=>uint256) addressRefferedCount;\n', '    mapping(address=>uint256) addressRefferredSpending;\n', '    address[] referralAddressIndex;\n', '    \n', '    uint256 public totalFundsSoFar;\n', '    \n', '    RigCraftPresalePackageToken private presaleTokenContract;\n', '    \n', '    function RigCraftPresalePackageManager() public\n', '    {\n', '        owner = msg.sender;\n', '        isActive = false;\n', '        presaleTokenContract = RigCraftPresalePackageToken(address(0));\n', '        \n', '        presalePackSold.length     = 5;\n', '        presalePackLimit.length    = 5;\n', '        presalePackagePrice.length = 5;\n', '       \n', '        // starter pack \n', '        presalePackLimit[0]    = 65000;\n', '        presalePackagePrice[0] = 0.1 ether;\n', '        \n', '        // snow white\n', '        presalePackLimit[1]    = 50;\n', '        presalePackagePrice[1] = 0.33 ether;\n', '        \n', '        // 6x66 black\n', '        presalePackLimit[2]    = 66;\n', '        presalePackagePrice[2] = 0.66 ether;\n', '        \n', '        // blue legandary\n', '        presalePackLimit[3]    = 50;\n', '        presalePackagePrice[3] = 0.99 ether;\n', '        \n', '        // lifetime share\n', '        presalePackLimit[4]    = 100;\n', '        presalePackagePrice[4] = 1 ether;\n', '    }\n', '    \n', '    function SetActive(bool _active) external\n', '    {\n', '        require(msg.sender == owner);\n', '        isActive = _active;\n', '    } \n', '    \n', '    function SetPresaleHandler(address addr) external\n', '    {\n', '        require(msg.sender == owner);\n', '        presaleTokenContract = RigCraftPresalePackageToken(addr);\n', '    }\n', '    \n', '    function AddNewPresalePackage(uint16 limit, uint256 price) external \n', '    {\n', '        require(msg.sender == owner);\n', '        require(limit > 0);\n', '        require(isActive);\n', '        \n', '        presalePackLimit.length += 1;\n', '        presalePackLimit[presalePackLimit.length-1] = limit;\n', '        \n', '        presalePackagePrice.length += 1;\n', '        presalePackagePrice[presalePackagePrice.length-1] = price;\n', '        \n', '        presalePackSold.length += 1;\n', '    }\n', '    \n', '    // ETH handler\n', '    function BuyPresalePackage(uint8 packageId, address referral) external payable\n', '    {\n', '        require(isActive);\n', '        require(packageId < presalePackLimit.length);\n', '        require(msg.sender != referral);\n', '        require(presalePackLimit[packageId] > presalePackSold[packageId]);\n', '\n', '        require(presaleTokenContract != RigCraftPresalePackageToken(address(0)));\n', '\n', '        // check money\n', '        require(msg.value >= presalePackagePrice[packageId]);\n', '        \n', '        presalePackSold[packageId]++;\n', '        \n', '        totalFundsSoFar += msg.value;\n', '        \n', '        presaleTokenContract.CreateToken(msg.sender, packageId, presalePackSold[packageId]);\n', '        \n', '        if(referral != address(0))\n', '        {\n', '            if(addressRefferedCount[referral] == 0)\n', '            {\n', '                referralAddressIndex.length += 1;\n', '                referralAddressIndex[referralAddressIndex.length-1] = referral;\n', '            }\n', '            addressRefferedCount[referral] += 1;\n', '            addressRefferredSpending[referral] += msg.value;\n', '        }\n', '    }\n', '\n', '    // referral system \n', '    function GetAllReferralAddresses() external view returns (address[] referred)\n', '    {\n', '        referred = referralAddressIndex;\n', '    }\n', '    \n', '    function GetReferredCount() external view returns (uint256)\n', '    {\n', '        return referralAddressIndex.length;\n', '    }\n', '    \n', '    function GetReferredAt(uint256 idx) external view returns (address)\n', '    {\n', '        require(idx < referralAddressIndex.length);\n', '        return referralAddressIndex[idx];\n', '    }\n', '    \n', '    function GetReferralDataOfAddress(address addr) external view returns (uint256 count, uint256 spending)\n', '    {\n', '        count = addressRefferedCount[addr];\n', '        spending = addressRefferredSpending[addr];\n', '    }\n', '\n', '    // withdraw \n', '    function withdraw() external\n', '    {\n', '        require(msg.sender == owner);\n', '        owner.transfer(address(this).balance);\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/** \n', ' * Created by RigCraft Team\n', ' * If you have any questions please visit the official discord channel\n', ' * https://discord.gg/zJCf7Fh\n', ' * or read The FAQ at \n', ' * https://rigcraft.io/#faq\n', ' **/\n', '\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data ) public;\n', '}\n', '\n', 'contract ERC721Receiver {\n', '\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  function onERC721Received(address _from,uint256 _tokenId,bytes _data) public returns(bytes4);\n', '}\n', '\n', 'contract ERC721Metadata {\n', '   \n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'contract Administration\n', '{\n', '    address owner;\n', '    bool active = true;\n', '    bool open = true;\n', '    \n', '    function Administration() public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() \n', '    {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    modifier isActive()\n', '    {\n', '        require(active == true);\n', '        _;\n', '    }\n', '    \n', '    modifier isOpen()\n', '    {\n', '        require(open == true);\n', '        _;\n', '    }\n', '    \n', '    function setActive(bool _active) external onlyOwner\n', '    {\n', '        active = _active;\n', '    }\n', '    \n', '    function setOpen(bool _open) external onlyOwner\n', '    {\n', '        open = _open;\n', '    }\n', '}\n', '\n', '// core\n', 'contract RigCraftPresalePackageToken is ERC721Basic, Administration, ERC721Metadata {\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '    \n', '    struct PresalePackage\n', '    {\n', '        uint8 packageId;\n', '        uint16 serialNumber;\n', '    }\n', '    \n', '    PresalePackage[] packages;\n', '    \n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) internal tokenOwner;\n', '    mapping (uint256 => address) internal tokenApprovals;\n', '    mapping (address => uint256) internal ownedTokensCount;\n', '    mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '    \n', '    RigCraftPresalePackageManager private presaleHandler;\n', '    string URIBase;\n', '    \n', '    string public constant name = "RigCraftPresalePackage";\n', '    string public constant symbol = "RCPT";\n', '    \n', '    function SetPresaleHandler(address addr) external onlyOwner\n', '    {\n', '        presaleHandler = RigCraftPresalePackageManager(addr);\n', '    }\n', '    \n', '    function setURIBase(string _base) external onlyOwner\n', '    {\n', '        URIBase = _base;\n', '    }\n', '    \n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        require(ownerOf(_tokenId) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(uint256 _tokenId) {\n', '        require(isApprovedOrOwner(msg.sender, _tokenId));\n', '        _;\n', '    }\n', '    \n', '    /**\n', '    * PUBLIC INTERFACE\n', '    **/\n', '    function balanceOf(address _owner) public view isOpen returns (uint256) {\n', '        require(_owner != address(0));\n', '        return ownedTokensCount[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view isOpen returns (address) {\n', '        address owner = tokenOwner[_tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    function exists(uint256 _tokenId) public view isOpen returns (bool) {\n', '        address owner = tokenOwner[_tokenId];\n', '        return owner != address(0);\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return packages.length;\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public\n', '    isOpen\n', '    isActive\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        require(_to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '        \n', '        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '            tokenApprovals[_tokenId] = _to;\n', '            emit Approval(owner, _to, _tokenId);\n', '        }\n', '    }\n', '    \n', '    function getApproved(uint256 _tokenId) public view isOpen returns (address) {\n', '        return tokenApprovals[_tokenId];\n', '    }\n', '    \n', '    function setApprovalForAll(address _to, bool _approved) public\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(_to != msg.sender);\n', '        operatorApprovals[msg.sender][_to] = _approved;\n', '        emit ApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', '\n', '    function isApprovedForAll( address _owner, address _operator) public view\n', '    isOpen\n', '    returns (bool)\n', '    {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        \n', '        clearApproval(_from, _tokenId);\n', '        removeTokenFrom(_from, _tokenId);\n', '        addTokenTo(_to, _tokenId);\n', '        \n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data)\n', '    public\n', '    canTransfer(_tokenId)\n', '    isActive\n', '    isOpen\n', '    {\n', '        transferFrom(_from, _to, _tokenId);\n', '        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '    }\n', '\n', '    /**\n', '    * INTERNALS\n', '    **/\n', '    function isApprovedOrOwner(address _spender,uint256 _tokenId) internal view\n', '    returns (bool)\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        return (_spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender));\n', '    }\n', '    \n', '    function clearApproval(address _owner, uint256 _tokenId) internal {\n', '        require(ownerOf(_tokenId) == _owner);\n', '        if (tokenApprovals[_tokenId] != address(0)) {\n', '            tokenApprovals[_tokenId] = address(0);\n', '            emit Approval(_owner, address(0), _tokenId);\n', '        }\n', '    }\n', '\n', '    function addTokenTo(address _to, uint256 _tokenId) internal \n', '    {\n', '        require(tokenOwner[_tokenId] == address(0));\n', '        tokenOwner[_tokenId] = _to;\n', '        ownedTokensCount[_to] += 1;\n', '    }\n', '\n', '    function removeTokenFrom(address _from, uint256 _tokenId) internal \n', '    {\n', '        require(ownerOf(_tokenId) == _from);\n', '        require(ownedTokensCount[_from] > 0);\n', '        ownedTokensCount[_from] -= 1;\n', '        tokenOwner[_tokenId] = address(0);\n', '    }\n', '\n', '    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data)\n', '    internal\n', '    returns (bool)\n', '    {\n', '        uint256 codeSize;\n', '        assembly { codeSize := extcodesize(_to) }\n', '        if (codeSize == 0) {\n', '            return true;\n', '        }\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '    \n', '    function tokenURI(uint256 _tokenId) external view returns (string)\n', '    {\n', '        string memory tokenNumber = uint2str(_tokenId);\n', '        \n', '        uint pos = bytes(URIBase).length;\n', '        bytes memory retVal  = new bytes(bytes(tokenNumber).length + bytes(URIBase).length);\n', '        uint i = 0;\n', '        \n', '        for(i = 0; i < bytes(URIBase).length; ++i)\n', '        {\n', '            retVal[i] = bytes(URIBase)[i];\n', '        }\n', '        for(i = 0; i < bytes(tokenNumber).length; ++i)\n', '        {\n', '            retVal[pos + i] = bytes(tokenNumber)[i];\n', '        }\n', '        \n', '        return string(retVal);\n', '    }\n', '    \n', '    function uint2str(uint256 i) internal pure returns (string)\n', '    {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint length;\n', '        while (j != 0){\n', '            length++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(length);\n', '        uint k = length - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    \n', '    // Get all token IDs of address\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) \n', '    {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        \n', '        if (tokenCount == 0) \n', '        {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else \n', '        {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 resultIndex = 0;\n', '            \n', '            // We count on the fact that all cats have IDs starting at 1 and increasing\n', '            // sequentially up to the totalCat count.\n', '            uint256 tokenId;\n', '            \n', '            for (tokenId = 0; tokenId < packages.length; tokenId++) \n', '            {\n', '                if (tokenOwner[tokenId] == _owner) \n', '                {\n', '                    result[resultIndex] = tokenId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '        \n', '            return result;\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * EXTERNALS\n', '    **/\n', '    function GetTokenData(uint256 _tokenId) external view returns(uint8 presalePackadeId, uint16 serialNO) \n', '    {\n', '        require(_tokenId < packages.length);\n', '        \n', '        presalePackadeId = packages[_tokenId].packageId;\n', '        serialNO = packages[_tokenId].serialNumber;\n', '    }\n', '    \n', '    function CreateToken(address _owner, uint8 _packageId, uint16 _serial) external\n', '    isActive\n', '    isOpen\n', '    {\n', '        require(msg.sender == address(presaleHandler));\n', '        uint256 tokenId = packages.length;\n', '        packages.length += 1;\n', '        \n', '        packages[tokenId].packageId = _packageId;\n', '        packages[tokenId].serialNumber = _serial;\n', '        \n', '        addTokenTo(_owner, tokenId);\n', '    }\n', '}\n', '\n', '// presale\n', 'contract RigCraftPresalePackageManager\n', '{\n', '    address owner;\n', '    \n', '    bool public isActive;\n', '    \n', '    uint16[]    public presalePackSold;\n', '    uint16[]    public presalePackLimit;\n', '    uint256[]   public presalePackagePrice;\n', '    \n', '    mapping(address=>uint256) addressRefferedCount;\n', '    mapping(address=>uint256) addressRefferredSpending;\n', '    address[] referralAddressIndex;\n', '    \n', '    uint256 public totalFundsSoFar;\n', '    \n', '    RigCraftPresalePackageToken private presaleTokenContract;\n', '    \n', '    function RigCraftPresalePackageManager() public\n', '    {\n', '        owner = msg.sender;\n', '        isActive = false;\n', '        presaleTokenContract = RigCraftPresalePackageToken(address(0));\n', '        \n', '        presalePackSold.length     = 5;\n', '        presalePackLimit.length    = 5;\n', '        presalePackagePrice.length = 5;\n', '       \n', '        // starter pack \n', '        presalePackLimit[0]    = 65000;\n', '        presalePackagePrice[0] = 0.1 ether;\n', '        \n', '        // snow white\n', '        presalePackLimit[1]    = 50;\n', '        presalePackagePrice[1] = 0.33 ether;\n', '        \n', '        // 6x66 black\n', '        presalePackLimit[2]    = 66;\n', '        presalePackagePrice[2] = 0.66 ether;\n', '        \n', '        // blue legandary\n', '        presalePackLimit[3]    = 50;\n', '        presalePackagePrice[3] = 0.99 ether;\n', '        \n', '        // lifetime share\n', '        presalePackLimit[4]    = 100;\n', '        presalePackagePrice[4] = 1 ether;\n', '    }\n', '    \n', '    function SetActive(bool _active) external\n', '    {\n', '        require(msg.sender == owner);\n', '        isActive = _active;\n', '    } \n', '    \n', '    function SetPresaleHandler(address addr) external\n', '    {\n', '        require(msg.sender == owner);\n', '        presaleTokenContract = RigCraftPresalePackageToken(addr);\n', '    }\n', '    \n', '    function AddNewPresalePackage(uint16 limit, uint256 price) external \n', '    {\n', '        require(msg.sender == owner);\n', '        require(limit > 0);\n', '        require(isActive);\n', '        \n', '        presalePackLimit.length += 1;\n', '        presalePackLimit[presalePackLimit.length-1] = limit;\n', '        \n', '        presalePackagePrice.length += 1;\n', '        presalePackagePrice[presalePackagePrice.length-1] = price;\n', '        \n', '        presalePackSold.length += 1;\n', '    }\n', '    \n', '    // ETH handler\n', '    function BuyPresalePackage(uint8 packageId, address referral) external payable\n', '    {\n', '        require(isActive);\n', '        require(packageId < presalePackLimit.length);\n', '        require(msg.sender != referral);\n', '        require(presalePackLimit[packageId] > presalePackSold[packageId]);\n', '\n', '        require(presaleTokenContract != RigCraftPresalePackageToken(address(0)));\n', '\n', '        // check money\n', '        require(msg.value >= presalePackagePrice[packageId]);\n', '        \n', '        presalePackSold[packageId]++;\n', '        \n', '        totalFundsSoFar += msg.value;\n', '        \n', '        presaleTokenContract.CreateToken(msg.sender, packageId, presalePackSold[packageId]);\n', '        \n', '        if(referral != address(0))\n', '        {\n', '            if(addressRefferedCount[referral] == 0)\n', '            {\n', '                referralAddressIndex.length += 1;\n', '                referralAddressIndex[referralAddressIndex.length-1] = referral;\n', '            }\n', '            addressRefferedCount[referral] += 1;\n', '            addressRefferredSpending[referral] += msg.value;\n', '        }\n', '    }\n', '\n', '    // referral system \n', '    function GetAllReferralAddresses() external view returns (address[] referred)\n', '    {\n', '        referred = referralAddressIndex;\n', '    }\n', '    \n', '    function GetReferredCount() external view returns (uint256)\n', '    {\n', '        return referralAddressIndex.length;\n', '    }\n', '    \n', '    function GetReferredAt(uint256 idx) external view returns (address)\n', '    {\n', '        require(idx < referralAddressIndex.length);\n', '        return referralAddressIndex[idx];\n', '    }\n', '    \n', '    function GetReferralDataOfAddress(address addr) external view returns (uint256 count, uint256 spending)\n', '    {\n', '        count = addressRefferedCount[addr];\n', '        spending = addressRefferredSpending[addr];\n', '    }\n', '\n', '    // withdraw \n', '    function withdraw() external\n', '    {\n', '        require(msg.sender == owner);\n', '        owner.transfer(address(this).balance);\n', '    }\n', '}']
