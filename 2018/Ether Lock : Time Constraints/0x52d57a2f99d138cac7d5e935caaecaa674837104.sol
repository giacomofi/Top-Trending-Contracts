['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function add(uint256 _a, uint256 _b) pure internal returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        assert(c >= _a && c >= _b);\n', '        \n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) pure internal returns (uint256) {\n', '        assert(_b <= _a);\n', '\n', '        return _a - _b;\n', '    }\n', '\n', '    function mul(uint256 _a, uint256 _b) pure internal returns (uint256) {\n', '        uint256 c = _a * _b;\n', '        assert(_a == 0 || c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) pure internal returns (uint256) {\n', '        assert(_b != 0);\n', '\n', '        return _a / _b;\n', '    }\n', '}\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract Token {\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool _success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success);\n', '    function approve(address _spender, uint256 _value) public returns (bool _success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TokenSale {\n', '    using SafeMath for uint256;\n', '\n', '    address public token;\n', '    address public owner;\n', '    address public vault;\n', '    mapping (address => uint256) public rate;\n', '\n', '    event RateChange(address indexed token, uint256 rate);\n', '    event VaultChange(address indexed vault);\n', '    event Transfer(address indexed to, address indexed token, uint256 received, uint256 sent);\n', '\n', '    modifier isOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier isValidAddress {\n', '        assert(msg.sender != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier hasPayloadSize(uint256 size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }    \n', '\n', '    constructor(address _token, address _vault) public {\n', '        owner = msg.sender;\n', '        token = _token;\n', '        _setVault(_vault);\n', '    }\n', '\n', '    function setVault(address _vault) isOwner public {\n', '        _setVault(_vault);\n', '    }\n', '\n', '    function _setVault(address _vault) private {\n', '        if (vault != _vault) {\n', '            vault = _vault;\n', '            \n', '            emit VaultChange(_vault);\n', '        }\n', '    }\n', '\n', '    function setRate(address _address, uint256 _rate) isOwner public {\n', '        _setRate(_address, _rate);\n', '    }\n', '\n', '    function setRates(address[] _address, uint256[] _rate) isOwner public {\n', '        for (uint256 i = 0; i < _address.length; i++) {\n', '            _setRate(_address[i], _rate[i]);\n', '        }\n', '    }\n', '\n', '    function _setRate(address _address, uint256 _rate) private {\n', '        if (rate[_address] != _rate) {\n', '            rate[_address] = _rate;\n', '\n', '            emit RateChange(_address, _rate);\n', '        }\n', '    }\n', '\n', '    function() isValidAddress payable public {\n', '        deposit();\n', '    }\n', '\n', '    function deposit() isValidAddress payable public {\n', '        require(msg.value > 0);\n', '        require(rate[0x0] > 0);\n', '        uint256 amount = msg.value.mul(rate[0x0]).div(1 ether);\n', '        require(Token(token).transferFrom(vault, msg.sender, amount));\n', '        require(address(vault).send(msg.value));\n', '\n', '        emit Transfer(msg.sender, 0x0, msg.value, amount);\n', '    }\n', '\n', '    function depositToken(address _token, uint256 _amount) isValidAddress public {\n', '        require(rate[_token] > 0);\n', '        uint256 amount = _amount.mul(rate[_token]).div(1 ether);\n', '        require(Token(token).balanceOf(vault) >= amount);\n', '        require(Token(_token).transferFrom(msg.sender, vault, _amount));\n', '        require(Token(token).transferFrom(vault, msg.sender, amount));\n', '\n', '        emit Transfer(msg.sender, _token, _amount, amount);\n', '    }\n', '}']