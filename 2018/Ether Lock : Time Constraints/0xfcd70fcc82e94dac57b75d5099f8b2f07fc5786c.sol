['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' *\n', ' * LEPRECHAUN - ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', ' * Telegram bot - t.me/LeprechaunContractBot\n', ' *\n', ' *  - GAIN 2% PER 24 HOURS\n', ' *  - Life-long payments\n', ' *  - Contribution allocation schemes:\n', ' *    -- 85% payments\n', ' *    -- 15% marketing\n', ' *\n', ' * HOW TO USE:\n', ' *  1. Send of ether to make an investment\n', ' *  2a. Claim your profit by sending 0 ether transaction (every hour, every day, every week)\n', ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * PARTNER PROGRAM:\n', ' * At the moment of making the first deposit, the referral indicates in the DATA field the ETH address of the referrer&#39;s wallet,\n', ' * and the referrer then receives 5% of the every attachments of the referral,\n', ' * and the referral also immediately gets back 10% of his deposit\n', ' *\n', ' * NOTES:\n', ' * All ETHs that you&#39;ve sent will be added to your deposit.\n', ' * In order to get an extra profit from your deposit, it is enough to send just 1 wei.\n', ' * It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you\n', ' * have private keys.\n', ' *\n', ' * RECOMMENDED GAS LIMIT: 300000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '\n', '        if (_a == 0) { return 0; }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Storage  {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint public constant perDay = 2;\n', '    uint public constant fee = 15;\n', '    uint public constant bonusReferral = 10;\n', '    uint public constant bonusReferrer = 5;\n', '\n', '    uint public constant minimalDepositForBonusReferrer = 0.001 ether;\n', '\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPaid = 0;\n', '\n', '    struct User\n', '    {\n', '        uint balance;\n', '        uint paid;\n', '        uint timestamp;\n', '        uint countReferrals;\n', '        uint earnOnReferrals;\n', '        address referrer;\n', '    }\n', '\n', '    mapping (address => User) internal user;\n', '\n', '    function getAvailableBalance(address addr) internal view returns(uint) {\n', '        uint diffTime = user[addr].timestamp > 0 ? now.sub(user[addr].timestamp) : 0;\n', '        return user[addr].balance.mul(perDay).mul(diffTime).div(100).div(24 hours);\n', '    }\n', '\n', '    function getUser(address addr) public view returns(uint, uint, uint, uint, uint, address) {\n', '\n', '        return (\n', '            user[addr].balance,\n', '            user[addr].paid,\n', '            getAvailableBalance(addr),\n', '            user[addr].countReferrals,\n', '            user[addr].earnOnReferrals,\n', '            user[addr].referrer\n', '        );\n', '\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract Leprechaun is Storage {\n', '\n', '    address public owner = msg.sender;\n', '\n', '    modifier withDeposit() { if (msg.value > 0) { _; } }\n', '\n', '    function() public payable {\n', '\n', '        if (msg.sender == owner) { return; }\n', '\n', '        register();\n', '        sendFee();\n', '        sendReferrer();\n', '        sendPayment();\n', '        updateInvestBalance();\n', '    }\n', '\n', '\n', '    function register() internal withDeposit {\n', '\n', '        if (user[msg.sender].balance == 0) {\n', '\n', '            user[msg.sender].timestamp = now;\n', '            countInvestors++;\n', '\n', '            address referrer = bytesToAddress(msg.data);\n', '\n', '            if (user[referrer].balance > 0 && referrer != msg.sender) {\n', '                user[msg.sender].referrer = referrer;\n', '                user[referrer].countReferrals++;\n', '                transfer(msg.sender, msg.value.mul(bonusReferral).div(100));\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function sendFee() internal withDeposit {\n', '        transfer(owner, msg.value.mul(fee).div(100));\n', '    }\n', '\n', '    function sendReferrer() internal withDeposit {\n', '\n', '        if (msg.value >= minimalDepositForBonusReferrer) {\n', '            address referrer = user[msg.sender].referrer;\n', '            if (user[referrer].balance > 0) {\n', '                uint amountReferrer = msg.value.mul(bonusReferrer).div(100);\n', '                user[referrer].earnOnReferrals = user[referrer].earnOnReferrals.add(amountReferrer);\n', '                transfer(referrer, amountReferrer);\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function sendPayment() internal {\n', '\n', '        if (user[msg.sender].balance > 0) {\n', '            transfer(msg.sender, getAvailableBalance(msg.sender));\n', '            user[msg.sender].timestamp = now;\n', '        }\n', '\n', '    }\n', '\n', '    function updateInvestBalance() internal withDeposit {\n', '        user[msg.sender].balance = user[msg.sender].balance.add(msg.value);\n', '        totalInvest = totalInvest.add(msg.value);\n', '    }\n', '\n', '    function transfer(address receiver, uint amount) internal {\n', '\n', '        if (amount > 0) {\n', '\n', '            if (receiver != owner) { totalPaid = totalPaid.add(amount); }\n', '\n', '            user[receiver].paid = user[receiver].paid.add(amount);\n', '\n', '            if (amount > address(this).balance) {\n', '                selfdestruct(receiver);\n', '            } else {\n', '                receiver.transfer(amount);\n', '            }\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function bytesToAddress(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' *\n', ' * LEPRECHAUN - ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', ' * Telegram bot - t.me/LeprechaunContractBot\n', ' *\n', ' *  - GAIN 2% PER 24 HOURS\n', ' *  - Life-long payments\n', ' *  - Contribution allocation schemes:\n', ' *    -- 85% payments\n', ' *    -- 15% marketing\n', ' *\n', ' * HOW TO USE:\n', ' *  1. Send of ether to make an investment\n', ' *  2a. Claim your profit by sending 0 ether transaction (every hour, every day, every week)\n', ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * PARTNER PROGRAM:\n', " * At the moment of making the first deposit, the referral indicates in the DATA field the ETH address of the referrer's wallet,\n", ' * and the referrer then receives 5% of the every attachments of the referral,\n', ' * and the referral also immediately gets back 10% of his deposit\n', ' *\n', ' * NOTES:\n', " * All ETHs that you've sent will be added to your deposit.\n", ' * In order to get an extra profit from your deposit, it is enough to send just 1 wei.\n', ' * It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you\n', ' * have private keys.\n', ' *\n', ' * RECOMMENDED GAS LIMIT: 300000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '\n', '        if (_a == 0) { return 0; }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Storage  {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint public constant perDay = 2;\n', '    uint public constant fee = 15;\n', '    uint public constant bonusReferral = 10;\n', '    uint public constant bonusReferrer = 5;\n', '\n', '    uint public constant minimalDepositForBonusReferrer = 0.001 ether;\n', '\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPaid = 0;\n', '\n', '    struct User\n', '    {\n', '        uint balance;\n', '        uint paid;\n', '        uint timestamp;\n', '        uint countReferrals;\n', '        uint earnOnReferrals;\n', '        address referrer;\n', '    }\n', '\n', '    mapping (address => User) internal user;\n', '\n', '    function getAvailableBalance(address addr) internal view returns(uint) {\n', '        uint diffTime = user[addr].timestamp > 0 ? now.sub(user[addr].timestamp) : 0;\n', '        return user[addr].balance.mul(perDay).mul(diffTime).div(100).div(24 hours);\n', '    }\n', '\n', '    function getUser(address addr) public view returns(uint, uint, uint, uint, uint, address) {\n', '\n', '        return (\n', '            user[addr].balance,\n', '            user[addr].paid,\n', '            getAvailableBalance(addr),\n', '            user[addr].countReferrals,\n', '            user[addr].earnOnReferrals,\n', '            user[addr].referrer\n', '        );\n', '\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract Leprechaun is Storage {\n', '\n', '    address public owner = msg.sender;\n', '\n', '    modifier withDeposit() { if (msg.value > 0) { _; } }\n', '\n', '    function() public payable {\n', '\n', '        if (msg.sender == owner) { return; }\n', '\n', '        register();\n', '        sendFee();\n', '        sendReferrer();\n', '        sendPayment();\n', '        updateInvestBalance();\n', '    }\n', '\n', '\n', '    function register() internal withDeposit {\n', '\n', '        if (user[msg.sender].balance == 0) {\n', '\n', '            user[msg.sender].timestamp = now;\n', '            countInvestors++;\n', '\n', '            address referrer = bytesToAddress(msg.data);\n', '\n', '            if (user[referrer].balance > 0 && referrer != msg.sender) {\n', '                user[msg.sender].referrer = referrer;\n', '                user[referrer].countReferrals++;\n', '                transfer(msg.sender, msg.value.mul(bonusReferral).div(100));\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function sendFee() internal withDeposit {\n', '        transfer(owner, msg.value.mul(fee).div(100));\n', '    }\n', '\n', '    function sendReferrer() internal withDeposit {\n', '\n', '        if (msg.value >= minimalDepositForBonusReferrer) {\n', '            address referrer = user[msg.sender].referrer;\n', '            if (user[referrer].balance > 0) {\n', '                uint amountReferrer = msg.value.mul(bonusReferrer).div(100);\n', '                user[referrer].earnOnReferrals = user[referrer].earnOnReferrals.add(amountReferrer);\n', '                transfer(referrer, amountReferrer);\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function sendPayment() internal {\n', '\n', '        if (user[msg.sender].balance > 0) {\n', '            transfer(msg.sender, getAvailableBalance(msg.sender));\n', '            user[msg.sender].timestamp = now;\n', '        }\n', '\n', '    }\n', '\n', '    function updateInvestBalance() internal withDeposit {\n', '        user[msg.sender].balance = user[msg.sender].balance.add(msg.value);\n', '        totalInvest = totalInvest.add(msg.value);\n', '    }\n', '\n', '    function transfer(address receiver, uint amount) internal {\n', '\n', '        if (amount > 0) {\n', '\n', '            if (receiver != owner) { totalPaid = totalPaid.add(amount); }\n', '\n', '            user[receiver].paid = user[receiver].paid.add(amount);\n', '\n', '            if (amount > address(this).balance) {\n', '                selfdestruct(receiver);\n', '            } else {\n', '                receiver.transfer(amount);\n', '            }\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function bytesToAddress(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '}']
