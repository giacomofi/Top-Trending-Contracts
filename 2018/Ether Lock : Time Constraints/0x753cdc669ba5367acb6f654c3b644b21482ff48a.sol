['pragma solidity ^0.4.24;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract ERC20RewardToken {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function decimals() public returns (uint8);\n', '}\n', '\n', 'contract Reward is Ownable {\n', '    \n', '    ERC20RewardToken public token;\n', '    address public presaleAddress;\n', '    uint64 public doubleRewardEndTime = 1538006400;\n', '    \n', '    constructor(address _tokenAddr, address _presaleAddr) public {\n', '        token = ERC20RewardToken(_tokenAddr);\n', '        presaleAddress = _presaleAddr;\n', '    }\n', '    \n', '    function get(address _receiver, uint256 _ethValue) external {\n', '\n', '        require(msg.sender == presaleAddress);\n', '        \n', '        uint256 tokensValue = calculateValue(_ethValue, token.decimals());\n', '\n', '        if(token.balanceOf(address(this)) > tokensValue) {\n', '            token.transfer(_receiver, tokensValue);\n', '        }\n', '    }\n', '    \n', '\tfunction setDoubleRewardEndTime(uint64 _time) onlyOwner external {\n', '\t\tdoubleRewardEndTime = _time;\n', '\t}\n', '\t\n', '    function calculateValue(uint256 _ethValue, uint8 decimals) view public returns (uint256 tokensValue) {\n', '        \n', '        uint8 TokensPerEthereum = 10;\n', '        uint8 additionalBonusPercent = 10;\n', '        \n', '        if(_ethValue > 3 * 10**17)\n', '            additionalBonusPercent = 25;\n', '        if(_ethValue > 10**18)\n', '            additionalBonusPercent = 30;\n', '        if(_ethValue > 5 * 10**18)\n', '            additionalBonusPercent = 60;\n', '        \n', '        tokensValue = _ethValue * TokensPerEthereum;\n', '        \n', '        tokensValue+= (tokensValue * additionalBonusPercent ) / 100;\n', '        \n', '        if(decimals < 18)\n', '        {\n', '            uint256 difference = 18 - uint256(decimals);\n', '            tokensValue = tokensValue / 10**difference;\n', '        }\n', '        else if(decimals > 18)\n', '        {\n', '            difference = uint256(decimals) - 18;\n', '            tokensValue = tokensValue * 10**difference;\n', '        }\n', '\t\t\n', '\t\t// an additional small bonus to compensate for the difference in calculating the recommended price of the egg\n', '\t\tif(_ethValue > 10**18)\n', '\t\t\ttokensValue+= 3 * 10**(uint256(decimals) - 2);\n', '        \n', '        if(now <= doubleRewardEndTime)\n', '            tokensValue*=2;\n', '    }\n', '    \n', '    function () public payable {\n', '        revert();\n', '    }\n', '    \n', '    function withdraw() onlyOwner external {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(msg.sender, balance);\n', '    }\n', '}']