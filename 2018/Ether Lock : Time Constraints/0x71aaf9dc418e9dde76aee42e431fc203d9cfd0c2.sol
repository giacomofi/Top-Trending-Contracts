['pragma solidity ^0.4.21;\n', '\n', 'contract WeTestToken \n', '{\n', '  mapping(address => uint256) public balanceOf;\n', '  function transfer(address newTokensHolder, uint256 tokensNumber) \n', '    public \n', '    returns(bool);\n', '}\n', '\n', 'contract VestingContractWTTEST\n', '{\n', '  //structures\n', '  struct AccountData\n', '  {\n', '    uint original_balance;\n', '    uint limit_per_period;\n', '    uint current_balance;\n', '    uint current_limit;\n', '    uint current_transferred;\n', '  }\n', '\n', '  //storage\n', '  address public owner;\n', '  WeTestToken public we_test_token;\n', '  mapping (address => AccountData) public account_data;\n', '  uint public current_period;\n', '  uint[] public periods;\n', '  address[] public accounts;\n', '\n', '  //modifiers\n', '  modifier onlyOwner\n', '  {\n', '    require(owner == msg.sender);\n', '    _;\n', '  }\n', '  \n', '  //Events\n', '  event Transfer(address indexed to, uint indexed value);\n', '  event OwnerTransfer(address indexed to, uint indexed value);\n', '  event OwnerChanged(address indexed owner);\n', '  event CurrentPeriodChanged(uint indexed current_period);\n', '\n', '  //functions\n', '\n', '  //debug functions\n', '  function setPeriod(uint i, uint v)\n', '    public\n', '  {\n', '    periods[i] = v;\n', '  }\n', '\n', '  //constructor\n', '  function VestingContractWTTEST(WeTestToken _we_test_token)\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '    we_test_token = _we_test_token;\n', '    \n', '    periods.push(1527003300);  //Tuesday, 22 May 2018 г., 14:00:00\n', '    periods.push(2**256 - 1);  //very far future\n', '    current_period = 0;\n', '\n', '    initData(0x0e0da823836499790ecbe17ba075a2a7cbe970e2, 1806343 * 10**18);\n', '  }\n', '  \n', '  /// @dev Fallback function: don&#39;t accept ETH\n', '  function()\n', '    public\n', '    payable\n', '  {\n', '    revert();\n', '  }\n', '\n', '  /// @dev Get current balance of the contract\n', '  function getBalance()\n', '    constant\n', '    public\n', '    returns(uint)\n', '  {\n', '    return we_test_token.balanceOf(this);\n', '  }\n', '\n', '  function initData(address a, uint v) \n', '    private\n', '  {\n', '    accounts.push(a);\n', '    account_data[a].original_balance = v;\n', '    account_data[a].current_balance = account_data[a].original_balance;\n', '    account_data[a].limit_per_period = account_data[a].original_balance / 2;\n', '    account_data[a].current_limit = account_data[a].limit_per_period;\n', '    account_data[a].current_transferred = 0;\n', '  }\n', '\n', '  function setOwner(address _owner) \n', '    public \n', '    onlyOwner \n', '  {\n', '    require(_owner != 0);\n', '    \n', '    owner = _owner;\n', '    emit OwnerChanged(owner);\n', '  }\n', '  \n', '  //allow owner to transfer surplus\n', '  function ownerTransfer(address to, uint value)\n', '    public\n', '    onlyOwner\n', '  {\n', '    uint current_balance_all = 0;\n', '    for (uint i = 0; i < accounts.length; i++)\n', '      current_balance_all += account_data[accounts[i]].current_balance;\n', '    require(getBalance() > current_balance_all && value <= getBalance() - current_balance_all);\n', '    if (we_test_token.transfer(to, value))\n', '      emit OwnerTransfer(to, value);\n', '  }\n', '  \n', '  function updateCurrentPeriod()\n', '    public\n', '  {\n', '    require(account_data[msg.sender].original_balance > 0 || msg.sender == owner);\n', '    \n', '    uint new_period = current_period;\n', '    for (uint i = current_period; i < periods.length; i++)\n', '      if (periods[i] > now)\n', '      {\n', '        new_period = i;\n', '        break;\n', '      }\n', '    if (new_period != current_period)\n', '    {\n', '      current_period = new_period;\n', '      for (i = 0; i < accounts.length; i++)\n', '      {\n', '        account_data[accounts[i]].current_transferred = 0;\n', '        account_data[accounts[i]].current_limit = account_data[accounts[i]].limit_per_period;\n', '        if (current_period == periods.length - 1)\n', '          account_data[accounts[i]].current_limit = 2**256 - 1;  //unlimited\n', '      }\n', '      emit CurrentPeriodChanged(current_period);\n', '    }\n', '  }\n', '\n', '  function transfer(address to, uint value) \n', '    public\n', '  {\n', '    updateCurrentPeriod();\n', '    require(value <= we_test_token.balanceOf(this) \n', '      && value <= account_data[msg.sender].current_balance \n', '      && account_data[msg.sender].current_transferred + value <= account_data[msg.sender].current_limit);\n', '\n', '    if (we_test_token.transfer(to, value)) \n', '    {\n', '      account_data[msg.sender].current_transferred += value;\n', '      account_data[msg.sender].current_balance -= value;\n', '      emit Transfer(to, value);\n', '    }\n', '  }\n', '\n', '  // ERC223\n', '  // function in contract &#39;ContractReceiver&#39;\n', '  function tokenFallback(address from, uint value, bytes data) {\n', '    // dummy function\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract WeTestToken \n', '{\n', '  mapping(address => uint256) public balanceOf;\n', '  function transfer(address newTokensHolder, uint256 tokensNumber) \n', '    public \n', '    returns(bool);\n', '}\n', '\n', 'contract VestingContractWTTEST\n', '{\n', '  //structures\n', '  struct AccountData\n', '  {\n', '    uint original_balance;\n', '    uint limit_per_period;\n', '    uint current_balance;\n', '    uint current_limit;\n', '    uint current_transferred;\n', '  }\n', '\n', '  //storage\n', '  address public owner;\n', '  WeTestToken public we_test_token;\n', '  mapping (address => AccountData) public account_data;\n', '  uint public current_period;\n', '  uint[] public periods;\n', '  address[] public accounts;\n', '\n', '  //modifiers\n', '  modifier onlyOwner\n', '  {\n', '    require(owner == msg.sender);\n', '    _;\n', '  }\n', '  \n', '  //Events\n', '  event Transfer(address indexed to, uint indexed value);\n', '  event OwnerTransfer(address indexed to, uint indexed value);\n', '  event OwnerChanged(address indexed owner);\n', '  event CurrentPeriodChanged(uint indexed current_period);\n', '\n', '  //functions\n', '\n', '  //debug functions\n', '  function setPeriod(uint i, uint v)\n', '    public\n', '  {\n', '    periods[i] = v;\n', '  }\n', '\n', '  //constructor\n', '  function VestingContractWTTEST(WeTestToken _we_test_token)\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '    we_test_token = _we_test_token;\n', '    \n', '    periods.push(1527003300);  //Tuesday, 22 May 2018 г., 14:00:00\n', '    periods.push(2**256 - 1);  //very far future\n', '    current_period = 0;\n', '\n', '    initData(0x0e0da823836499790ecbe17ba075a2a7cbe970e2, 1806343 * 10**18);\n', '  }\n', '  \n', "  /// @dev Fallback function: don't accept ETH\n", '  function()\n', '    public\n', '    payable\n', '  {\n', '    revert();\n', '  }\n', '\n', '  /// @dev Get current balance of the contract\n', '  function getBalance()\n', '    constant\n', '    public\n', '    returns(uint)\n', '  {\n', '    return we_test_token.balanceOf(this);\n', '  }\n', '\n', '  function initData(address a, uint v) \n', '    private\n', '  {\n', '    accounts.push(a);\n', '    account_data[a].original_balance = v;\n', '    account_data[a].current_balance = account_data[a].original_balance;\n', '    account_data[a].limit_per_period = account_data[a].original_balance / 2;\n', '    account_data[a].current_limit = account_data[a].limit_per_period;\n', '    account_data[a].current_transferred = 0;\n', '  }\n', '\n', '  function setOwner(address _owner) \n', '    public \n', '    onlyOwner \n', '  {\n', '    require(_owner != 0);\n', '    \n', '    owner = _owner;\n', '    emit OwnerChanged(owner);\n', '  }\n', '  \n', '  //allow owner to transfer surplus\n', '  function ownerTransfer(address to, uint value)\n', '    public\n', '    onlyOwner\n', '  {\n', '    uint current_balance_all = 0;\n', '    for (uint i = 0; i < accounts.length; i++)\n', '      current_balance_all += account_data[accounts[i]].current_balance;\n', '    require(getBalance() > current_balance_all && value <= getBalance() - current_balance_all);\n', '    if (we_test_token.transfer(to, value))\n', '      emit OwnerTransfer(to, value);\n', '  }\n', '  \n', '  function updateCurrentPeriod()\n', '    public\n', '  {\n', '    require(account_data[msg.sender].original_balance > 0 || msg.sender == owner);\n', '    \n', '    uint new_period = current_period;\n', '    for (uint i = current_period; i < periods.length; i++)\n', '      if (periods[i] > now)\n', '      {\n', '        new_period = i;\n', '        break;\n', '      }\n', '    if (new_period != current_period)\n', '    {\n', '      current_period = new_period;\n', '      for (i = 0; i < accounts.length; i++)\n', '      {\n', '        account_data[accounts[i]].current_transferred = 0;\n', '        account_data[accounts[i]].current_limit = account_data[accounts[i]].limit_per_period;\n', '        if (current_period == periods.length - 1)\n', '          account_data[accounts[i]].current_limit = 2**256 - 1;  //unlimited\n', '      }\n', '      emit CurrentPeriodChanged(current_period);\n', '    }\n', '  }\n', '\n', '  function transfer(address to, uint value) \n', '    public\n', '  {\n', '    updateCurrentPeriod();\n', '    require(value <= we_test_token.balanceOf(this) \n', '      && value <= account_data[msg.sender].current_balance \n', '      && account_data[msg.sender].current_transferred + value <= account_data[msg.sender].current_limit);\n', '\n', '    if (we_test_token.transfer(to, value)) \n', '    {\n', '      account_data[msg.sender].current_transferred += value;\n', '      account_data[msg.sender].current_balance -= value;\n', '      emit Transfer(to, value);\n', '    }\n', '  }\n', '\n', '  // ERC223\n', "  // function in contract 'ContractReceiver'\n", '  function tokenFallback(address from, uint value, bytes data) {\n', '    // dummy function\n', '  }\n', '}']
