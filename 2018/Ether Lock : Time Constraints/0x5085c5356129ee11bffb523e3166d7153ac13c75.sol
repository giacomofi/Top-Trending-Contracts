['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title HouseAdmin\n', ' * @dev The HouseAdmin contract has a signer address and a croupier address, and provides basic authorization control\n', ' *      functions, this simplifies the implementation of "user permissions"\n', ' */\n', 'contract HouseAdmin is Ownable {\n', '  address public signer;\n', '  address public croupier;\n', '\n', '  event SignerTransferred(address indexed previousSigner, address indexed newSigner);\n', '  event CroupierTransferred(address indexed previousCroupier, address indexed newCroupier);\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the signer or owner\n', '   */\n', '  modifier onlySigner() {\n', '    require(msg.sender == signer || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the croupier or owner\n', '   */\n', '  modifier onlyCroupier() {\n', '    require(msg.sender == croupier || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev The Signable constructor sets the original `signer` of the contract to the sender\n', '   *      account\n', '   */\n', '  constructor() public {\n', '    signer = msg.sender;\n', '    croupier = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current signer to transfer control of the contract to a newSigner\n', '   * @param _newSigner The address to transfer signership to\n', '   */\n', '  function transferSigner(address _newSigner) public onlySigner {\n', '    _transferSigner(_newSigner);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current croupier to transfer control of the contract to a newCroupier\n', '   * @param _newCroupier The address to transfer croupiership to\n', '   */\n', '  function transferCroupier(address _newCroupier) public onlyCroupier {\n', '    _transferCroupier(_newCroupier);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newSigner.\n', '   * @param _newSigner The address to transfer signership to.\n', '   */\n', '  function _transferSigner(address _newSigner) internal {\n', '    require(_newSigner != address(0));\n', '    emit SignerTransferred(signer, _newSigner);\n', '    signer = _newSigner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newCroupier.\n', '   * @param _newCroupier The address to transfer croupiership to.\n', '   */\n', '  function _transferCroupier(address _newCroupier) internal {\n', '    require(_newCroupier != address(0));\n', '    emit CroupierTransferred(croupier, _newCroupier);\n', '    croupier = _newCroupier;\n', '  }\n', '}\n', '\n', '\n', 'contract Casino is Ownable, HouseAdmin {\n', '  using SafeMath for uint;\n', '\n', '  uint constant HOUSE_EDGE_PERCENT = 1;\n', '  uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\n', '\n', '  uint constant BET_AMOUNT_MIN = 0.01 ether;\n', '  uint constant BET_AMOUNT_MAX = 1000 ether;\n', '\n', '  uint constant BET_EXPIRATION_BLOCKS = 250;\n', '\n', '  uint constant MAX_MASKABLE_MODULO = 40;\n', '  uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO;\n', '\n', '  // population count\n', '  uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\n', '  uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\n', '  uint constant POPCOUNT_MODULO = 0x3F;\n', '\n', '  uint public bankFund;\n', '\n', '  struct Bet {\n', '    uint8 modulo;\n', '    uint64 choice;\n', '    uint amount;\n', '    uint winAmount;\n', '    uint placeBlockNumber;\n', '    bool isActive;\n', '    address player;\n', '  }\n', '\n', '  mapping (uint => Bet) public bets;\n', '\n', '  event LogParticipant(address indexed player, uint indexed modulo, uint choice, uint amount, uint commit);\n', '  event LogClosedBet(address indexed player, uint indexed modulo, uint choice, uint reveal, uint result, uint amount, uint winAmount);\n', '  event LogDistributeReward(address indexed addr, uint reward);\n', '  event LogRecharge(address indexed addr, uint amount);\n', '  event LogRefund(address indexed addr, uint amount);\n', '  event LogDealerWithdraw(address indexed addr, uint amount);\n', '\n', '  constructor() payable public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function placeBet(uint _choice, uint _modulo, uint _expiredBlockNumber, uint _commit, uint8 _v, bytes32 _r, bytes32 _s) payable external {\n', '    Bet storage bet = bets[_commit];\n', '\n', '    uint amount = msg.value;\n', '\n', '    require(bet.player == address(0), "this bet is already exist");\n', "    require(block.number <= _expiredBlockNumber, 'this bet has expired');\n", "    require(amount >= BET_AMOUNT_MIN && amount <= BET_AMOUNT_MAX, 'bet amount out of range');\n", '\n', '    // verify the signer and _expiredBlockNumber\n', '    bytes32 msgHash = keccak256(abi.encodePacked(_expiredBlockNumber, _commit));\n', '    require(ecrecover(msgHash, _v, _r, _s) == signer, "incorrect signer");\n', '\n', '    uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\n', '    if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\n', '      houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\n', '    }\n', '\n', '    uint populationCount;\n', '    if (_modulo < MAX_MASKABLE_MODULO) {\n', '      require(_choice < MAX_BET_MASK, "choice too large");\n', '      populationCount = (_choice * POPCOUNT_MULT & POPCOUNT_MASK) % POPCOUNT_MODULO;\n', '      require(populationCount < _modulo, "winning rate out of range");\n', '    } else {\n', '      require(_choice < _modulo, "choice large than modulo");\n', '      populationCount = _choice;\n', '    }\n', '\n', '    uint winAmount = (amount - houseEdge).mul(_modulo) / populationCount;\n', "    require(bankFund.add(winAmount) <= address(this).balance, 'contract balance is not enough');\n", '    // lock winAmount into this contract. Make sure contract is solvent\n', '    bankFund = bankFund.add(winAmount);\n', '\n', '    bet.choice = uint64(_choice);\n', '    bet.player = msg.sender;\n', '    bet.placeBlockNumber = block.number;\n', '    bet.amount = amount;\n', '    bet.winAmount = winAmount;\n', '    bet.isActive = true;\n', '    bet.modulo = uint8(_modulo);\n', '\n', '    emit LogParticipant(msg.sender, _modulo, _choice, amount, _commit);\n', '  }\n', '\n', '  function closeBet(uint _reveal) external onlyCroupier {\n', '    uint commit = uint(keccak256(abi.encodePacked(_reveal)));\n', '    Bet storage bet = bets[commit];\n', '\n', "    require(bet.isActive, 'this bet is not active');\n", '\n', '    uint amount = bet.amount;\n', '    uint placeBlockNumber = bet.placeBlockNumber;\n', '    uint modulo = bet.modulo;\n', '    uint winAmount = 0;\n', '    uint choice = bet.choice;\n', '    address player = bet.player;\n', '\n', "    require(block.number > placeBlockNumber, 'close bet block number is too low');\n", "    require(block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, 'the block number is too low to query');\n", '\n', '    uint result = uint(keccak256(abi.encodePacked(_reveal, blockhash(placeBlockNumber)))) % modulo;\n', '\n', '    if (modulo <= MAX_MASKABLE_MODULO) {\n', '      if (2 ** result & choice != 0) {\n', '        winAmount = bet.winAmount;\n', '        player.transfer(winAmount);\n', '        emit LogDistributeReward(player, winAmount);\n', '      }\n', '    } else {\n', '      if (result < choice) {\n', '        winAmount = bet.winAmount;\n', '        player.transfer(winAmount);\n', '        emit LogDistributeReward(player, winAmount);\n', '      }\n', '    }\n', '\n', '    // release winAmount deposit\n', '    bankFund = bankFund.sub(bet.winAmount);\n', '    bet.isActive = false;\n', '\n', '    emit LogClosedBet(player, modulo, choice, _reveal, result, amount, winAmount);\n', '  }\n', '\n', '  function refundBet(uint _commit) external onlyCroupier {\n', '    Bet storage bet = bets[_commit];\n', '\n', '    uint amount = bet.amount;\n', '    uint placeBlockNumber = bet.placeBlockNumber;\n', '    address player = bet.player;\n', '\n', "    require(bet.isActive, 'this bet is not active');\n", "    require(block.number > placeBlockNumber + BET_EXPIRATION_BLOCKS, 'this bet has not expired');\n", '\n', '    player.transfer(amount);\n', '    // release winAmount deposit\n', '    bankFund = bankFund.sub(bet.winAmount);\n', '    bet.isActive = false;\n', '\n', '    emit LogRefund(player, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev in order to let more people participant\n', '   */\n', '  function recharge() public payable {\n', '    emit LogRecharge(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev owner can withdraw the remain ether\n', '   */\n', '  function withdraw(uint _amount) external onlyOwner {\n', "    require(_amount <= address(this).balance - bankFund, 'cannot withdraw amount greater than (balance - bankFund)');\n", '    owner.transfer(_amount);\n', '    emit LogDealerWithdraw(owner, _amount);\n', '  }\n', '\n', '  /**\n', '   * @dev get the balance which can be used\n', '   */\n', '  function getAvailableBalance() view public returns (uint) {\n', '    return address(this).balance - bankFund;\n', '  }\n', '}']