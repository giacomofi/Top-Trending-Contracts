['pragma solidity 0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/// @title Intel contract\n', '/// @author Pareto Admin\n', '/// @notice Intel, A contract for creating, rewarding and distributing Intels\n', 'contract Intel{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    struct IntelState {\n', '        address intelProvider;\n', '        uint depositAmount;\n', '        uint desiredReward;\n', '        // total balance of Pareto tokens given for this intel\n', '        // including the intel provider’s deposit\n', '        uint balance;\n', '        uint intelID;\n', '        // timestamp for when rewards can be collected\n', '        uint rewardAfter;\n', '        // flag indicating whether the rewards have been collected\n', '        bool rewarded;\n', '                // stores how many Pareto tokens were given for this intel\n', '        // in case you want to enforce a max amount per contributor\n', '        address[] contributionsList;\n', '        mapping(address => uint) contributions;\n', '\n', '    }\n', '\n', '\n', '    mapping(uint => IntelState) intelDB;\n', '    mapping(address => IntelState[]) public IntelsByProvider;\n', '    uint[] intelIndexes;\n', '    \n', '    uint public intelCount;\n', '    \n', '\n', '    address public owner;    // Storage variable to hold the address of owner\n', '    \n', '    ERC20 public token;   // Storage variable of type ERC20 to hold Pareto token&#39;s address\n', '    address public ParetoAddress;\n', '\n', '    \n', '    constructor(address _owner, address _token) public {\n', '        owner = _owner;  // owner is a Pareto wallet which should be able to perform admin functions\n', '        token = ERC20(_token);\n', '        ParetoAddress = _token;\n', '    }\n', '    \n', '\n', '    // modifier to check of the sender of transaction is the owner\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '\n', '    event Reward( address sender, uint intelIndex, uint rewardAmount);\n', '    event NewIntel(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl);\n', '    event RewardDistributed(uint intelIndex, uint provider_amount, address provider, address distributor, uint distributor_amount);\n', '    event LogProxy(address destination, address account, uint amount, uint gasLimit);\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function creates an Intel\n', '    /// @dev Uses &#39;now&#39; for timestamps.\n', '    /// @param intelProvider is the address of the Intel&#39;s provider\n', '    /// @param depositAmount is the amount of Pareto tokens deposited by provider\n', '    /// @param desiredReward is the amount of Pareto tokens desired by provider as reward\n', '    /// @param intelID is the ID of Intel which is mapped against an Intel in IntelDB as well as the database external to Ethereum\n', '    /// @param ttl is the time in EPOCH format until the Intel remains active and accepts rewards\n', '    /// requires 210769 gas in Rinkeby Network\n', '    function create(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl) public {\n', '\n', '        require(address(intelProvider) != address(0x0));\n', '        require(depositAmount > 0);\n', '        require(desiredReward > 0);\n', '        require(ttl > now);\n', '        \n', '        token.transferFrom(intelProvider, address(this), depositAmount);  // transfer token from caller to Intel contract\n', '        \n', '        address[] memory contributionsList;\n', '        IntelState memory newIntel = IntelState(intelProvider, depositAmount, desiredReward, depositAmount, intelID, ttl, false, contributionsList);\n', '        intelDB[intelID] = newIntel;\n', '        IntelsByProvider[intelProvider].push(newIntel);\n', '\n', '        intelIndexes.push(intelID);\n', '        intelCount++;\n', '        \n', '\n', '        emit NewIntel(intelProvider, depositAmount, desiredReward, intelID, ttl);\n', '        \n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function sends rewards to the Intel\n', '    /// @dev Uses &#39;now&#39; for timestamps.\n', '    /// @param intelIndex is the ID of the Intel to send the rewards to\n', '    /// @param rewardAmount is the amount of Pareto tokens the rewarder wants to reward to the Intel\n', '    /// @return returns true in case of successfull completion\n', '    /// requires 72283 gas on Rinkeby Network\n', '    function sendReward(uint intelIndex, uint rewardAmount) public returns(bool success){\n', '\n', '        IntelState storage intel = intelDB[intelIndex];\n', '        require(intel.intelProvider != address(0x0));  // make sure that Intel exists\n', '        require(msg.sender != intel.intelProvider); // rewarding address should not be an intel address\n', '        require(intel.rewardAfter > now);       //You cannot reward intel if the timestamp of the transaction is greater than rewardAfter\n', '        require(!intel.rewarded);  // You cannot reward intel if the intel’s rewards have already been distributed\n', '        \n', '\n', '        token.transferFrom(msg.sender, address(this), rewardAmount);  // transfer token from caller to Intel contract\n', '        intel.balance = intel.balance.add(rewardAmount);\n', '\n', '        if(intel.contributions[msg.sender] == 0){\n', '            intel.contributionsList.push(msg.sender);\n', '        }\n', '        \n', '        intel.contributions[msg.sender] = intel.contributions[msg.sender].add(rewardAmount);\n', '        \n', '\n', '        emit Reward(msg.sender, intelIndex, rewardAmount);\n', '\n', '\n', '        return true;\n', '\n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function distributes rewards to the Intel provider\n', '    /// @dev Uses &#39;now&#39; for timestamps.\n', '    /// @param intelIndex is the ID of the Intel to distribute tokens to\n', '    /// @return returns true in case of successfull completion\n', '    /// requires 91837 gas on Rinkeby Network\n', '    function distributeReward(uint intelIndex) public returns(bool success){\n', '\n', '        require(intelIndex > 0);\n', '        \n', '\n', '        IntelState storage intel = intelDB[intelIndex];\n', '        \n', '        require(!intel.rewarded);\n', '        require(now >= intel.rewardAfter);\n', '        \n', '\n', '        intel.rewarded = true;\n', '        uint distributed_amount = 0;\n', '\n', '       \n', '\n', '\n', '        if (intel.balance > intel.desiredReward){         // check if the Intel&#39;s balance is greater than the reward desired by Provider\n', '            distributed_amount = intel.desiredReward;    // tarnsfer tokens to the provider&#39;s address equal to the desired reward\n', '\n', '        } else {\n', '            distributed_amount = intel.balance;  // transfer token to the provider&#39;s address equal to Intel&#39;s balance\n', '        }\n', '\n', '        uint fee = distributed_amount.div(10);    // calculate 10% as the fee for distribution\n', '        distributed_amount = distributed_amount.sub(fee);   // calculate final distribution amount\n', '\n', '        token.transfer(intel.intelProvider, distributed_amount); // send Intel tokens to providers\n', '        token.transfer(msg.sender, fee);                     // send Intel tokens to the caller of distribute reward function\n', '        emit RewardDistributed(intelIndex, distributed_amount, intel.intelProvider, msg.sender, fee);\n', '\n', '\n', '        return true;\n', '\n', '    }\n', '    \n', '    /// @author Pareto Admin\n', '    /// @notice this function sets the address of Pareto Token\n', '    /// @dev only owner can call it\n', '    /// @param _token is the Pareto token address\n', '    /// requires 63767 gas on Rinkeby Network\n', '    function setParetoToken(address _token) public onlyOwner{\n', '\n', '        token = ERC20(_token);\n', '        ParetoAddress = _token;\n', '\n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function sends back the mistankenly sent non-Pareto ERC20 tokens\n', '    /// @dev only owner can call it\n', '    /// @param destination is the contract address where the tokens were received from mistakenly\n', '    /// @param account is the external account&#39;s address which sent the wrong tokens\n', '    /// @param amount is the amount of tokens sent\n', '    /// @param gasLimit is the amount of gas to be sent along with external contract&#39;s transfer call\n', '    /// requires 27431 gas on Rinkeby Network\n', '    function proxy(address destination, address account, uint amount, uint gasLimit) public onlyOwner{\n', '\n', '        require(destination != ParetoAddress);    // check that the destination is not the Pareto token contract\n', '\n', '        // make the call to transfer function of the &#39;destination&#39; contract\n', '        // if(!address(destination).call.gas(gasLimit)(bytes4(keccak256("transfer(address,uint256)")),account, amount)){\n', '        //     revert();\n', '        // }\n', '\n', '\n', '        // ERC20(destination).transfer(account,amount);\n', '\n', '\n', '        bytes4  sig = bytes4(keccak256("transfer(address,uint256)"));\n', '\n', '        assembly {\n', '            let x := mload(0x40) //Find empty storage location using "free memory pointer"\n', '        mstore(x,sig) //Place signature at begining of empty storage \n', '        mstore(add(x,0x04),account)\n', '        mstore(add(x,0x24),amount)\n', '\n', '        let success := call(      //This is the critical change (Pop the top stack value)\n', '                            gasLimit, //5k gas\n', '                            destination, //To addr\n', '                            0,    //No value\n', '                            x,    //Inputs are stored at location x\n', '                            0x44, //Inputs are 68 bytes long\n', '                            x,    //Store output over input (saves space)\n', '                            0x0) //Outputs are 32 bytes long\n', '\n', '        // Check return value and jump to bad destination if zero\n', '\t\tjumpi(0x02,iszero(success))\n', '\n', '        }\n', '        emit LogProxy(destination, account, amount, gasLimit);\n', '    }\n', '\n', '    /// @author Pareto Admin\n', '    /// @notice It&#39;s a fallback function supposed to return sent Ethers by reverting the transaction\n', '    function() external{\n', '        revert();\n', '    }\n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function provide the Intel based on its index\n', '    /// @dev it&#39;s a constant function which can be called\n', '    /// @param intelIndex is the ID of Intel that is to be returned from intelDB\n', '    function getIntel(uint intelIndex) public view returns(address intelProvider, uint depositAmount, uint desiredReward, uint balance, uint intelID, uint rewardAfter, bool rewarded) {\n', '        \n', '        IntelState storage intel = intelDB[intelIndex];\n', '        intelProvider = intel.intelProvider;\n', '        depositAmount = intel.depositAmount;\n', '        desiredReward = intel.desiredReward;\n', '        balance = intel.balance;\n', '        rewardAfter = intel.rewardAfter;\n', '        intelID = intel.intelID;\n', '        rewarded = intel.rewarded;\n', '\n', '    }\n', '\n', '    function getAllIntel() public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\n', '        \n', '        uint length = intelIndexes.length;\n', '        intelID = new uint[](length);\n', '        intelProvider = new address[](length);\n', '        depositAmount = new uint[](length);\n', '        desiredReward = new uint[](length);\n', '        balance = new uint[](length);\n', '        rewardAfter = new uint[](length);\n', '        rewarded = new bool[](length);\n', '\n', '        for(uint i = 0; i < intelIndexes.length; i++){\n', '            intelID[i] = intelDB[intelIndexes[i]].intelID;\n', '            intelProvider[i] = intelDB[intelIndexes[i]].intelProvider;\n', '            depositAmount[i] = intelDB[intelIndexes[i]].depositAmount;\n', '            desiredReward[i] = intelDB[intelIndexes[i]].desiredReward;\n', '            balance[i] = intelDB[intelIndexes[i]].balance;\n', '            rewardAfter[i] = intelDB[intelIndexes[i]].rewardAfter;\n', '            rewarded[i] = intelDB[intelIndexes[i]].rewarded;\n', '        }\n', '    }\n', '\n', '\n', '      function getIntelsByProvider(address _provider) public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\n', '        \n', '        uint length = IntelsByProvider[_provider].length;\n', '\n', '        intelID = new uint[](length);\n', '        intelProvider = new address[](length);\n', '        depositAmount = new uint[](length);\n', '        desiredReward = new uint[](length);\n', '        balance = new uint[](length);\n', '        rewardAfter = new uint[](length);\n', '        rewarded = new bool[](length);\n', '\n', '        IntelState[] memory intels = IntelsByProvider[_provider];\n', '\n', '        for(uint i = 0; i < length; i++){\n', '            intelID[i] = intels[i].intelID;\n', '            intelProvider[i] = intels[i].intelProvider;\n', '            depositAmount[i] = intels[i].depositAmount;\n', '            desiredReward[i] = intels[i].desiredReward;\n', '            balance[i] = intels[i].balance;\n', '            rewardAfter[i] = intels[i].rewardAfter;\n', '            rewarded[i] = intels[i].rewarded;\n', '        }\n', '    }\n', '\n', '    function contributionsByIntel(uint intelIndex) public view returns(address[] addresses, uint[] amounts){\n', '        IntelState storage intel = intelDB[intelIndex];\n', '                \n', '        uint length = intel.contributionsList.length;\n', '\n', '        addresses = new address[](length);\n', '        amounts = new uint[](length);\n', '\n', '        for(uint i = 0; i < length; i++){\n', '            addresses[i] = intel.contributionsList[i]; \n', '            amounts[i] = intel.contributions[intel.contributionsList[i]];       \n', '        }\n', '\n', '    }\n', '\n', '}']
['pragma solidity 0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/// @title Intel contract\n', '/// @author Pareto Admin\n', '/// @notice Intel, A contract for creating, rewarding and distributing Intels\n', 'contract Intel{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    struct IntelState {\n', '        address intelProvider;\n', '        uint depositAmount;\n', '        uint desiredReward;\n', '        // total balance of Pareto tokens given for this intel\n', '        // including the intel provider’s deposit\n', '        uint balance;\n', '        uint intelID;\n', '        // timestamp for when rewards can be collected\n', '        uint rewardAfter;\n', '        // flag indicating whether the rewards have been collected\n', '        bool rewarded;\n', '                // stores how many Pareto tokens were given for this intel\n', '        // in case you want to enforce a max amount per contributor\n', '        address[] contributionsList;\n', '        mapping(address => uint) contributions;\n', '\n', '    }\n', '\n', '\n', '    mapping(uint => IntelState) intelDB;\n', '    mapping(address => IntelState[]) public IntelsByProvider;\n', '    uint[] intelIndexes;\n', '    \n', '    uint public intelCount;\n', '    \n', '\n', '    address public owner;    // Storage variable to hold the address of owner\n', '    \n', "    ERC20 public token;   // Storage variable of type ERC20 to hold Pareto token's address\n", '    address public ParetoAddress;\n', '\n', '    \n', '    constructor(address _owner, address _token) public {\n', '        owner = _owner;  // owner is a Pareto wallet which should be able to perform admin functions\n', '        token = ERC20(_token);\n', '        ParetoAddress = _token;\n', '    }\n', '    \n', '\n', '    // modifier to check of the sender of transaction is the owner\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '\n', '    event Reward( address sender, uint intelIndex, uint rewardAmount);\n', '    event NewIntel(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl);\n', '    event RewardDistributed(uint intelIndex, uint provider_amount, address provider, address distributor, uint distributor_amount);\n', '    event LogProxy(address destination, address account, uint amount, uint gasLimit);\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function creates an Intel\n', "    /// @dev Uses 'now' for timestamps.\n", "    /// @param intelProvider is the address of the Intel's provider\n", '    /// @param depositAmount is the amount of Pareto tokens deposited by provider\n', '    /// @param desiredReward is the amount of Pareto tokens desired by provider as reward\n', '    /// @param intelID is the ID of Intel which is mapped against an Intel in IntelDB as well as the database external to Ethereum\n', '    /// @param ttl is the time in EPOCH format until the Intel remains active and accepts rewards\n', '    /// requires 210769 gas in Rinkeby Network\n', '    function create(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl) public {\n', '\n', '        require(address(intelProvider) != address(0x0));\n', '        require(depositAmount > 0);\n', '        require(desiredReward > 0);\n', '        require(ttl > now);\n', '        \n', '        token.transferFrom(intelProvider, address(this), depositAmount);  // transfer token from caller to Intel contract\n', '        \n', '        address[] memory contributionsList;\n', '        IntelState memory newIntel = IntelState(intelProvider, depositAmount, desiredReward, depositAmount, intelID, ttl, false, contributionsList);\n', '        intelDB[intelID] = newIntel;\n', '        IntelsByProvider[intelProvider].push(newIntel);\n', '\n', '        intelIndexes.push(intelID);\n', '        intelCount++;\n', '        \n', '\n', '        emit NewIntel(intelProvider, depositAmount, desiredReward, intelID, ttl);\n', '        \n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function sends rewards to the Intel\n', "    /// @dev Uses 'now' for timestamps.\n", '    /// @param intelIndex is the ID of the Intel to send the rewards to\n', '    /// @param rewardAmount is the amount of Pareto tokens the rewarder wants to reward to the Intel\n', '    /// @return returns true in case of successfull completion\n', '    /// requires 72283 gas on Rinkeby Network\n', '    function sendReward(uint intelIndex, uint rewardAmount) public returns(bool success){\n', '\n', '        IntelState storage intel = intelDB[intelIndex];\n', '        require(intel.intelProvider != address(0x0));  // make sure that Intel exists\n', '        require(msg.sender != intel.intelProvider); // rewarding address should not be an intel address\n', '        require(intel.rewardAfter > now);       //You cannot reward intel if the timestamp of the transaction is greater than rewardAfter\n', '        require(!intel.rewarded);  // You cannot reward intel if the intel’s rewards have already been distributed\n', '        \n', '\n', '        token.transferFrom(msg.sender, address(this), rewardAmount);  // transfer token from caller to Intel contract\n', '        intel.balance = intel.balance.add(rewardAmount);\n', '\n', '        if(intel.contributions[msg.sender] == 0){\n', '            intel.contributionsList.push(msg.sender);\n', '        }\n', '        \n', '        intel.contributions[msg.sender] = intel.contributions[msg.sender].add(rewardAmount);\n', '        \n', '\n', '        emit Reward(msg.sender, intelIndex, rewardAmount);\n', '\n', '\n', '        return true;\n', '\n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function distributes rewards to the Intel provider\n', "    /// @dev Uses 'now' for timestamps.\n", '    /// @param intelIndex is the ID of the Intel to distribute tokens to\n', '    /// @return returns true in case of successfull completion\n', '    /// requires 91837 gas on Rinkeby Network\n', '    function distributeReward(uint intelIndex) public returns(bool success){\n', '\n', '        require(intelIndex > 0);\n', '        \n', '\n', '        IntelState storage intel = intelDB[intelIndex];\n', '        \n', '        require(!intel.rewarded);\n', '        require(now >= intel.rewardAfter);\n', '        \n', '\n', '        intel.rewarded = true;\n', '        uint distributed_amount = 0;\n', '\n', '       \n', '\n', '\n', "        if (intel.balance > intel.desiredReward){         // check if the Intel's balance is greater than the reward desired by Provider\n", "            distributed_amount = intel.desiredReward;    // tarnsfer tokens to the provider's address equal to the desired reward\n", '\n', '        } else {\n', "            distributed_amount = intel.balance;  // transfer token to the provider's address equal to Intel's balance\n", '        }\n', '\n', '        uint fee = distributed_amount.div(10);    // calculate 10% as the fee for distribution\n', '        distributed_amount = distributed_amount.sub(fee);   // calculate final distribution amount\n', '\n', '        token.transfer(intel.intelProvider, distributed_amount); // send Intel tokens to providers\n', '        token.transfer(msg.sender, fee);                     // send Intel tokens to the caller of distribute reward function\n', '        emit RewardDistributed(intelIndex, distributed_amount, intel.intelProvider, msg.sender, fee);\n', '\n', '\n', '        return true;\n', '\n', '    }\n', '    \n', '    /// @author Pareto Admin\n', '    /// @notice this function sets the address of Pareto Token\n', '    /// @dev only owner can call it\n', '    /// @param _token is the Pareto token address\n', '    /// requires 63767 gas on Rinkeby Network\n', '    function setParetoToken(address _token) public onlyOwner{\n', '\n', '        token = ERC20(_token);\n', '        ParetoAddress = _token;\n', '\n', '    }\n', '    \n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function sends back the mistankenly sent non-Pareto ERC20 tokens\n', '    /// @dev only owner can call it\n', '    /// @param destination is the contract address where the tokens were received from mistakenly\n', "    /// @param account is the external account's address which sent the wrong tokens\n", '    /// @param amount is the amount of tokens sent\n', "    /// @param gasLimit is the amount of gas to be sent along with external contract's transfer call\n", '    /// requires 27431 gas on Rinkeby Network\n', '    function proxy(address destination, address account, uint amount, uint gasLimit) public onlyOwner{\n', '\n', '        require(destination != ParetoAddress);    // check that the destination is not the Pareto token contract\n', '\n', "        // make the call to transfer function of the 'destination' contract\n", '        // if(!address(destination).call.gas(gasLimit)(bytes4(keccak256("transfer(address,uint256)")),account, amount)){\n', '        //     revert();\n', '        // }\n', '\n', '\n', '        // ERC20(destination).transfer(account,amount);\n', '\n', '\n', '        bytes4  sig = bytes4(keccak256("transfer(address,uint256)"));\n', '\n', '        assembly {\n', '            let x := mload(0x40) //Find empty storage location using "free memory pointer"\n', '        mstore(x,sig) //Place signature at begining of empty storage \n', '        mstore(add(x,0x04),account)\n', '        mstore(add(x,0x24),amount)\n', '\n', '        let success := call(      //This is the critical change (Pop the top stack value)\n', '                            gasLimit, //5k gas\n', '                            destination, //To addr\n', '                            0,    //No value\n', '                            x,    //Inputs are stored at location x\n', '                            0x44, //Inputs are 68 bytes long\n', '                            x,    //Store output over input (saves space)\n', '                            0x0) //Outputs are 32 bytes long\n', '\n', '        // Check return value and jump to bad destination if zero\n', '\t\tjumpi(0x02,iszero(success))\n', '\n', '        }\n', '        emit LogProxy(destination, account, amount, gasLimit);\n', '    }\n', '\n', '    /// @author Pareto Admin\n', "    /// @notice It's a fallback function supposed to return sent Ethers by reverting the transaction\n", '    function() external{\n', '        revert();\n', '    }\n', '\n', '    /// @author Pareto Admin\n', '    /// @notice this function provide the Intel based on its index\n', "    /// @dev it's a constant function which can be called\n", '    /// @param intelIndex is the ID of Intel that is to be returned from intelDB\n', '    function getIntel(uint intelIndex) public view returns(address intelProvider, uint depositAmount, uint desiredReward, uint balance, uint intelID, uint rewardAfter, bool rewarded) {\n', '        \n', '        IntelState storage intel = intelDB[intelIndex];\n', '        intelProvider = intel.intelProvider;\n', '        depositAmount = intel.depositAmount;\n', '        desiredReward = intel.desiredReward;\n', '        balance = intel.balance;\n', '        rewardAfter = intel.rewardAfter;\n', '        intelID = intel.intelID;\n', '        rewarded = intel.rewarded;\n', '\n', '    }\n', '\n', '    function getAllIntel() public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\n', '        \n', '        uint length = intelIndexes.length;\n', '        intelID = new uint[](length);\n', '        intelProvider = new address[](length);\n', '        depositAmount = new uint[](length);\n', '        desiredReward = new uint[](length);\n', '        balance = new uint[](length);\n', '        rewardAfter = new uint[](length);\n', '        rewarded = new bool[](length);\n', '\n', '        for(uint i = 0; i < intelIndexes.length; i++){\n', '            intelID[i] = intelDB[intelIndexes[i]].intelID;\n', '            intelProvider[i] = intelDB[intelIndexes[i]].intelProvider;\n', '            depositAmount[i] = intelDB[intelIndexes[i]].depositAmount;\n', '            desiredReward[i] = intelDB[intelIndexes[i]].desiredReward;\n', '            balance[i] = intelDB[intelIndexes[i]].balance;\n', '            rewardAfter[i] = intelDB[intelIndexes[i]].rewardAfter;\n', '            rewarded[i] = intelDB[intelIndexes[i]].rewarded;\n', '        }\n', '    }\n', '\n', '\n', '      function getIntelsByProvider(address _provider) public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\n', '        \n', '        uint length = IntelsByProvider[_provider].length;\n', '\n', '        intelID = new uint[](length);\n', '        intelProvider = new address[](length);\n', '        depositAmount = new uint[](length);\n', '        desiredReward = new uint[](length);\n', '        balance = new uint[](length);\n', '        rewardAfter = new uint[](length);\n', '        rewarded = new bool[](length);\n', '\n', '        IntelState[] memory intels = IntelsByProvider[_provider];\n', '\n', '        for(uint i = 0; i < length; i++){\n', '            intelID[i] = intels[i].intelID;\n', '            intelProvider[i] = intels[i].intelProvider;\n', '            depositAmount[i] = intels[i].depositAmount;\n', '            desiredReward[i] = intels[i].desiredReward;\n', '            balance[i] = intels[i].balance;\n', '            rewardAfter[i] = intels[i].rewardAfter;\n', '            rewarded[i] = intels[i].rewarded;\n', '        }\n', '    }\n', '\n', '    function contributionsByIntel(uint intelIndex) public view returns(address[] addresses, uint[] amounts){\n', '        IntelState storage intel = intelDB[intelIndex];\n', '                \n', '        uint length = intel.contributionsList.length;\n', '\n', '        addresses = new address[](length);\n', '        amounts = new uint[](length);\n', '\n', '        for(uint i = 0; i < length; i++){\n', '            addresses[i] = intel.contributionsList[i]; \n', '            amounts[i] = intel.contributions[intel.contributionsList[i]];       \n', '        }\n', '\n', '    }\n', '\n', '}']
