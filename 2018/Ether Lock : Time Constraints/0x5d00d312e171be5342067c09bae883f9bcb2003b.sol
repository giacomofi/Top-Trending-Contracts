['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract SupportsInterface is ERC165 {\n', '    \n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[_interfaceID];\n', '    }\n', '}\n', '\n', 'interface ERC721 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    \n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function approve(address _approved, uint256 _tokenId) external;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    \n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', 'interface ERC721Enumerable {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', 'interface ERC721Metadata {\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'interface ERC721TokenReceiver {\n', '  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function withdrawEther(address _sendTo, uint _amount) external returns(EtheremonEnum.ResultCode);\n', '    function addElementToArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint8 _value) external returns(uint);\n', '    function updateIndexOfArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index, uint8 _value) external returns(uint);\n', '    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) external returns(uint32);\n', '    function addMonsterObj(uint32 _classId, address _trainer, string _name) external returns(uint64);\n', '    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) external;\n', '    function increaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) external;\n', '    function addMonsterIdMapping(address _trainer, uint64 _monsterId) external;\n', '    function clearMonsterReturnBalance(uint64 _monsterId) external returns(uint256 amount);\n', '    function collectAllReturnBalance(address _trainer) external returns(uint256 amount);\n', '    function transferMonster(address _from, address _to, uint64 _monsterId) external returns(EtheremonEnum.ResultCode);\n', '    function addExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\n', '    function deductExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\n', '    function setExtraBalance(address _trainer, uint256 _amount) external;\n', '    \n', '    // read\n', '    function getSizeArrayType(EtheremonEnum.ArrayType _type, uint64 _id) constant external returns(uint);\n', '    function getElementInArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index) constant external returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant external returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant external returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant external returns(string name);\n', '    function getExtraBalance(address _trainer) constant external returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant external returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant external returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant external returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant external returns(uint256 current, uint256 total);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', '\n', 'contract EtheremonMonsterTokenBasic is ERC721, SupportsInterface, BasicAccessControl {\n', '\n', '    using SafeMath for uint256;\n', '    using AddressUtils for address;\n', '    \n', '    struct MonsterClassAcc {\n', '        uint32 classId;\n', '        uint256 price;\n', '        uint256 returnPrice;\n', '        uint32 total;\n', '        bool catchable;\n', '    }\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '\n', '    // data contract\n', '    address public dataContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    \n', '    // Mapping from NFT ID to approved address.\n', '    mapping (uint256 => address) internal idToApprovals;\n', '    \n', '    // Mapping from owner address to mapping of operator addresses.\n', '    mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '    \n', '    /**\n', '    * @dev Magic value of a smart contract that can recieve NFT.\n', '    * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '    */\n', '    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    \n', '    // internal function\n', '    function _canOperate(address _tokenOwner) constant internal {\n', '        require(_tokenOwner == msg.sender || ownerToOperators[_tokenOwner][msg.sender]);\n', '    }\n', '    \n', '    function _canTransfer(uint256 _tokenId, address _tokenOwner) constant internal {\n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        require(!battle.isOnBattle(uint64(_tokenId)) && !trade.isOnTrading(uint64(_tokenId)));\n', '        require(_tokenOwner != address(0));\n', '        require(_tokenOwner == msg.sender || idToApprovals[_tokenId] == msg.sender || ownerToOperators[_tokenOwner][msg.sender]);\n', '    }\n', '    \n', '    function setOperationContracts(address _dataContract, address _battleContract, address _tradeContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '    \n', '    // public function\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '    }\n', '\n', '    function isApprovable(address _owner, uint256 _tokenId) public constant returns(bool) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        if (obj.monsterId != uint64(_tokenId))\n', '            return false;\n', '        if (obj.trainer != _owner)\n', '            return false;\n', '        // check battle & trade contract \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        return (!battle.isOnBattle(obj.monsterId) && !trade.isOnTrading(obj.monsterId));\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.getMonsterDexSize(_owner);\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, _owner, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(_owner != address(0));\n', '    }\n', '\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\n', '        _safeTransferFrom(_from, _to, _tokenId, _data);\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == _from);\n', '        require(_to != address(0));\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == msg.sender);\n', '        require(_to != address(0));\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '    }\n', '\n', '    function approve(address _approved, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canOperate(obj.trainer);\n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\n', '            revert();\n', '        \n', '        require(_approved != obj.trainer);\n', '\n', '        idToApprovals[_tokenId] = _approved;\n', '        emit Approval(obj.trainer, _approved, _tokenId);\n', '    }\n', '\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        require(_operator != address(0));\n', '        ownerToOperators[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    function getApproved(uint256 _tokenId) public view returns (address) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        return idToApprovals[_tokenId];\n', '    }\n', '\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        require(_owner != address(0));\n', '        require(_operator != address(0));\n', '        return ownerToOperators[_owner][_operator];\n', '    }\n', '\n', '    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) internal {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == _from);\n', '        require(_to != address(0));\n', '\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '\n', '        if (_to.isContract()) {\n', '            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n', '            require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '        }\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        _clearApproval(_tokenId);\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        data.removeMonsterIdMapping(_from, uint64(_tokenId));\n', '        data.addMonsterIdMapping(_to, uint64(_tokenId));\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '\n', '    function _burn(uint256 _tokenId) internal { \n', '        _clearApproval(_tokenId);\n', '        \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\n', '            revert();\n', '        \n', '        data.removeMonsterIdMapping(obj.trainer, uint64(_tokenId));\n', '        \n', '        emit Transfer(obj.trainer, address(0), _tokenId);\n', '    }\n', '\n', '    function _clearApproval(uint256 _tokenId) internal {\n', '        if(idToApprovals[_tokenId] != 0) {\n', '            delete idToApprovals[_tokenId];\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract EtheremonMonsterEnumerable is EtheremonMonsterTokenBasic, ERC721Enumerable {\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '    }\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.totalMonster();\n', '    }\n', '\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        return _index;\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.getMonsterObjId(_owner, _index);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract EtheremonMonsterStandard is EtheremonMonsterEnumerable, ERC721Metadata {\n', '    string internal nftName;\n', '    string internal nftSymbol;\n', '    \n', '    mapping (uint256 => string) internal idToUri;\n', '    \n', '    constructor(string _name, string _symbol) public {\n', '        nftName = _name;\n', '        nftSymbol = _symbol;\n', '        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '    }\n', '    \n', '    function _burn(uint256 _tokenId) internal {\n', '        super._burn(_tokenId);\n', '        if (bytes(idToUri[_tokenId]).length != 0) {\n', '            delete idToUri[_tokenId];\n', '        }\n', '    }\n', '    \n', '    function _setTokenUri(uint256 _tokenId, string _uri) internal {\n', '        idToUri[_tokenId] = _uri;\n', '    }\n', '    \n', '    function name() external view returns (string _name) {\n', '        _name = nftName;\n', '    }\n', '    \n', '    function symbol() external view returns (string _symbol) {\n', '        _symbol = nftSymbol;\n', '    }\n', '    \n', '    function tokenURI(uint256 _tokenId) external view returns (string) {\n', '        return idToUri[_tokenId];\n', '    }\n', '}\n', '\n', 'contract EtheremonMonsterToken is EtheremonMonsterStandard("EtheremonMonster", "EMONA") {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '\n', '    uint seed = 0;\n', '    \n', '    mapping(uint8 => uint32) public levelExps;\n', '    mapping(uint32 => bool) classWhitelist;\n', '    mapping(address => bool) addressWhitelist;\n', '    \n', '    uint public gapFactor = 0.001 ether;\n', '    uint16 public priceIncreasingRatio = 1000;\n', '    \n', '    function setPriceIncreasingRatio(uint16 _ratio) onlyModerators external {\n', '        priceIncreasingRatio = _ratio;\n', '    }\n', '    \n', '    function setFactor(uint _gapFactor) onlyModerators public {\n', '        gapFactor = _gapFactor;\n', '    }\n', '    \n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function setClassWhitelist(uint32 _classId, bool _status) onlyModerators external {\n', '        classWhitelist[_classId] = _status;\n', '    }\n', '\n', '    function setAddressWhitelist(address _smartcontract, bool _status) onlyModerators external {\n', '        addressWhitelist[_smartcontract] = _status;\n', '    }\n', '\n', '    function setTokenURI(uint256 _tokenId, string _uri) onlyModerators external {\n', '        _setTokenUri(_tokenId, _uri);\n', '    }\n', '    \n', '    function withdrawEther(address _sendTo, uint _amount) onlyOwner public {\n', '        if (_amount > address(this).balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '    \n', '    function mintMonster(uint32 _classId, address _trainer, string _name) onlyModerators external returns(uint){\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        // add monster\n', '        uint64 objId = data.addMonsterObj(_classId, _trainer, _name);\n', '        uint8 value;\n', '        seed = getRandom(_trainer, block.number-1, seed, objId);\n', '        // generate base stat for the previous one\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        emit Transfer(address(0), _trainer, objId);\n', '        return objId;\n', '    }\n', '    \n', '    function burnMonster(uint64 _tokenId) onlyModerators external {\n', '        _burn(_tokenId);\n', '    }\n', '    \n', '    function clearApproval(uint _tokenId) onlyModerators external {\n', '        _clearApproval(_tokenId);\n', '    }\n', '    \n', '    function triggerTransferEvent(address _from, address _to, uint _tokenId) onlyModerators external {\n', '        _clearApproval(_tokenId);\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    // public api \n', '    function getRandom(address _player, uint _block, uint _seed, uint _count) view public returns(uint) {\n', '        return uint(keccak256(abi.encodePacked(blockhash(_block), _player, _seed, _count)));\n', '    }\n', '    \n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '    \n', '    function getMonsterBaseStats(uint64 _monsterId) constant external returns(uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        uint[6] memory stats;\n', '        for(uint i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        return (stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\n', '    }\n', '    \n', '    function getMonsterCurrentStats(uint64 _monsterId) constant external returns(uint exp, uint level, uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\n', '        \n', '        uint[6] memory stats;\n', '        uint i = 0;\n', '        level = getLevel(obj.exp);\n', '        for(i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        for(i=0; i < STAT_COUNT; i++) {\n', '            stats[i] += uint(data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_STEP, obj.classId, i)) * level * 3;\n', '        }\n', '        \n', '        return (obj.exp, level, stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\n', '    }\n', '    \n', '    function getMonsterCP(uint64 _monsterId) constant external returns(uint cp) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\n', '        \n', '        uint[6] memory stats;\n', '        uint i = 0;\n', '        cp = getLevel(obj.exp);\n', '        for(i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        for(i=0; i < STAT_COUNT; i++) {\n', '            stats[i] += uint(data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_STEP, obj.classId, i)) * cp * 3;\n', '        }\n', '        \n', '        cp = (stats[0] + stats[1] + stats[2] + stats[3] + stats[4] + stats[5]) / 6;\n', '    }\n', '    \n', '    function getPrice(uint32 _classId) constant external returns(bool catchable, uint price) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        \n', '        price = class.price;\n', '        if (class.total > 0)\n', '            price += class.price*(class.total-1)/priceIncreasingRatio;\n', '        \n', '        if (class.catchable == false) {\n', '            if (addressWhitelist[msg.sender] == true && classWhitelist[_classId] == true) {\n', '                return (true, price);\n', '            }\n', '        }\n', '        \n', '        return (class.catchable, price);\n', '    }\n', '    \n', '    function getMonsterClassBasic(uint32 _classId) constant external returns(uint256, uint256, uint256, bool) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        return (class.price, class.returnPrice, class.total, class.catchable);\n', '    }\n', '    \n', '    function renameMonster(uint64 _objId, string name) isActive external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (obj.monsterId != _objId || obj.trainer != msg.sender) {\n', '            revert();\n', '        }\n', '        data.setMonsterObj(_objId, name, obj.exp, obj.createIndex, obj.lastClaimIndex);\n', '    }\n', '    \n', '    function catchMonster(address _player, uint32 _classId, string _name) isActive external payable returns(uint tokenId) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        if (class.classId == 0) {\n', '            revert();\n', '        }\n', '        \n', '        if (class.catchable == false) {\n', '            if (addressWhitelist[msg.sender] == false || classWhitelist[_classId] == false) {\n', '                revert();\n', '            }\n', '        }\n', '        \n', '        uint price = class.price;\n', '        if (class.total > 0)\n', '            price += class.price*(class.total-1)/priceIncreasingRatio;\n', '        if (msg.value + gapFactor < price) {\n', '            revert();\n', '        }\n', '        \n', '        // add new monster \n', '        uint64 objId = data.addMonsterObj(_classId, _player, _name);\n', '        uint8 value;\n', '        seed = getRandom(_player, block.number-1, seed, objId);\n', '        // generate base stat for the previous one\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        \n', '        emit Transfer(address(0), _player, objId);\n', '\n', '        return objId; \n', '    }\n', '    \n', '    \n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract SupportsInterface is ERC165 {\n', '    \n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[_interfaceID];\n', '    }\n', '}\n', '\n', 'interface ERC721 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    \n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function approve(address _approved, uint256 _tokenId) external;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    \n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', 'interface ERC721Enumerable {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', 'interface ERC721Metadata {\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'interface ERC721TokenReceiver {\n', '  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function withdrawEther(address _sendTo, uint _amount) external returns(EtheremonEnum.ResultCode);\n', '    function addElementToArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint8 _value) external returns(uint);\n', '    function updateIndexOfArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index, uint8 _value) external returns(uint);\n', '    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) external returns(uint32);\n', '    function addMonsterObj(uint32 _classId, address _trainer, string _name) external returns(uint64);\n', '    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) external;\n', '    function increaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) external;\n', '    function addMonsterIdMapping(address _trainer, uint64 _monsterId) external;\n', '    function clearMonsterReturnBalance(uint64 _monsterId) external returns(uint256 amount);\n', '    function collectAllReturnBalance(address _trainer) external returns(uint256 amount);\n', '    function transferMonster(address _from, address _to, uint64 _monsterId) external returns(EtheremonEnum.ResultCode);\n', '    function addExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\n', '    function deductExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\n', '    function setExtraBalance(address _trainer, uint256 _amount) external;\n', '    \n', '    // read\n', '    function getSizeArrayType(EtheremonEnum.ArrayType _type, uint64 _id) constant external returns(uint);\n', '    function getElementInArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index) constant external returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant external returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant external returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant external returns(string name);\n', '    function getExtraBalance(address _trainer) constant external returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant external returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant external returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant external returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant external returns(uint256 current, uint256 total);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', '\n', 'contract EtheremonMonsterTokenBasic is ERC721, SupportsInterface, BasicAccessControl {\n', '\n', '    using SafeMath for uint256;\n', '    using AddressUtils for address;\n', '    \n', '    struct MonsterClassAcc {\n', '        uint32 classId;\n', '        uint256 price;\n', '        uint256 returnPrice;\n', '        uint32 total;\n', '        bool catchable;\n', '    }\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '\n', '    // data contract\n', '    address public dataContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    \n', '    // Mapping from NFT ID to approved address.\n', '    mapping (uint256 => address) internal idToApprovals;\n', '    \n', '    // Mapping from owner address to mapping of operator addresses.\n', '    mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '    \n', '    /**\n', '    * @dev Magic value of a smart contract that can recieve NFT.\n', '    * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '    */\n', '    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    \n', '    // internal function\n', '    function _canOperate(address _tokenOwner) constant internal {\n', '        require(_tokenOwner == msg.sender || ownerToOperators[_tokenOwner][msg.sender]);\n', '    }\n', '    \n', '    function _canTransfer(uint256 _tokenId, address _tokenOwner) constant internal {\n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        require(!battle.isOnBattle(uint64(_tokenId)) && !trade.isOnTrading(uint64(_tokenId)));\n', '        require(_tokenOwner != address(0));\n', '        require(_tokenOwner == msg.sender || idToApprovals[_tokenId] == msg.sender || ownerToOperators[_tokenOwner][msg.sender]);\n', '    }\n', '    \n', '    function setOperationContracts(address _dataContract, address _battleContract, address _tradeContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '    \n', '    // public function\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '    }\n', '\n', '    function isApprovable(address _owner, uint256 _tokenId) public constant returns(bool) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        if (obj.monsterId != uint64(_tokenId))\n', '            return false;\n', '        if (obj.trainer != _owner)\n', '            return false;\n', '        // check battle & trade contract \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        return (!battle.isOnBattle(obj.monsterId) && !trade.isOnTrading(obj.monsterId));\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.getMonsterDexSize(_owner);\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, _owner, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(_owner != address(0));\n', '    }\n', '\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\n', '        _safeTransferFrom(_from, _to, _tokenId, _data);\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == _from);\n', '        require(_to != address(0));\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == msg.sender);\n', '        require(_to != address(0));\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '    }\n', '\n', '    function approve(address _approved, uint256 _tokenId) external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canOperate(obj.trainer);\n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\n', '            revert();\n', '        \n', '        require(_approved != obj.trainer);\n', '\n', '        idToApprovals[_tokenId] = _approved;\n', '        emit Approval(obj.trainer, _approved, _tokenId);\n', '    }\n', '\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        require(_operator != address(0));\n', '        ownerToOperators[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    function getApproved(uint256 _tokenId) public view returns (address) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        return idToApprovals[_tokenId];\n', '    }\n', '\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        require(_owner != address(0));\n', '        require(_operator != address(0));\n', '        return ownerToOperators[_owner][_operator];\n', '    }\n', '\n', '    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) internal {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        _canTransfer(_tokenId, obj.trainer);\n', '        \n', '        require(obj.trainer == _from);\n', '        require(_to != address(0));\n', '\n', '        _transfer(obj.trainer, _to, _tokenId);\n', '\n', '        if (_to.isContract()) {\n', '            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n', '            require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '        }\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        _clearApproval(_tokenId);\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        data.removeMonsterIdMapping(_from, uint64(_tokenId));\n', '        data.addMonsterIdMapping(_to, uint64(_tokenId));\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '\n', '    function _burn(uint256 _tokenId) internal { \n', '        _clearApproval(_tokenId);\n', '        \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\n', '        require(obj.trainer != address(0));\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\n', '            revert();\n', '        \n', '        data.removeMonsterIdMapping(obj.trainer, uint64(_tokenId));\n', '        \n', '        emit Transfer(obj.trainer, address(0), _tokenId);\n', '    }\n', '\n', '    function _clearApproval(uint256 _tokenId) internal {\n', '        if(idToApprovals[_tokenId] != 0) {\n', '            delete idToApprovals[_tokenId];\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract EtheremonMonsterEnumerable is EtheremonMonsterTokenBasic, ERC721Enumerable {\n', '\n', '    constructor() public {\n', '        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '    }\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.totalMonster();\n', '    }\n', '\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        return _index;\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        return data.getMonsterObjId(_owner, _index);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract EtheremonMonsterStandard is EtheremonMonsterEnumerable, ERC721Metadata {\n', '    string internal nftName;\n', '    string internal nftSymbol;\n', '    \n', '    mapping (uint256 => string) internal idToUri;\n', '    \n', '    constructor(string _name, string _symbol) public {\n', '        nftName = _name;\n', '        nftSymbol = _symbol;\n', '        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '    }\n', '    \n', '    function _burn(uint256 _tokenId) internal {\n', '        super._burn(_tokenId);\n', '        if (bytes(idToUri[_tokenId]).length != 0) {\n', '            delete idToUri[_tokenId];\n', '        }\n', '    }\n', '    \n', '    function _setTokenUri(uint256 _tokenId, string _uri) internal {\n', '        idToUri[_tokenId] = _uri;\n', '    }\n', '    \n', '    function name() external view returns (string _name) {\n', '        _name = nftName;\n', '    }\n', '    \n', '    function symbol() external view returns (string _symbol) {\n', '        _symbol = nftSymbol;\n', '    }\n', '    \n', '    function tokenURI(uint256 _tokenId) external view returns (string) {\n', '        return idToUri[_tokenId];\n', '    }\n', '}\n', '\n', 'contract EtheremonMonsterToken is EtheremonMonsterStandard("EtheremonMonster", "EMONA") {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '\n', '    uint seed = 0;\n', '    \n', '    mapping(uint8 => uint32) public levelExps;\n', '    mapping(uint32 => bool) classWhitelist;\n', '    mapping(address => bool) addressWhitelist;\n', '    \n', '    uint public gapFactor = 0.001 ether;\n', '    uint16 public priceIncreasingRatio = 1000;\n', '    \n', '    function setPriceIncreasingRatio(uint16 _ratio) onlyModerators external {\n', '        priceIncreasingRatio = _ratio;\n', '    }\n', '    \n', '    function setFactor(uint _gapFactor) onlyModerators public {\n', '        gapFactor = _gapFactor;\n', '    }\n', '    \n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function setClassWhitelist(uint32 _classId, bool _status) onlyModerators external {\n', '        classWhitelist[_classId] = _status;\n', '    }\n', '\n', '    function setAddressWhitelist(address _smartcontract, bool _status) onlyModerators external {\n', '        addressWhitelist[_smartcontract] = _status;\n', '    }\n', '\n', '    function setTokenURI(uint256 _tokenId, string _uri) onlyModerators external {\n', '        _setTokenUri(_tokenId, _uri);\n', '    }\n', '    \n', '    function withdrawEther(address _sendTo, uint _amount) onlyOwner public {\n', '        if (_amount > address(this).balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '    \n', '    function mintMonster(uint32 _classId, address _trainer, string _name) onlyModerators external returns(uint){\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        // add monster\n', '        uint64 objId = data.addMonsterObj(_classId, _trainer, _name);\n', '        uint8 value;\n', '        seed = getRandom(_trainer, block.number-1, seed, objId);\n', '        // generate base stat for the previous one\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        emit Transfer(address(0), _trainer, objId);\n', '        return objId;\n', '    }\n', '    \n', '    function burnMonster(uint64 _tokenId) onlyModerators external {\n', '        _burn(_tokenId);\n', '    }\n', '    \n', '    function clearApproval(uint _tokenId) onlyModerators external {\n', '        _clearApproval(_tokenId);\n', '    }\n', '    \n', '    function triggerTransferEvent(address _from, address _to, uint _tokenId) onlyModerators external {\n', '        _clearApproval(_tokenId);\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    // public api \n', '    function getRandom(address _player, uint _block, uint _seed, uint _count) view public returns(uint) {\n', '        return uint(keccak256(abi.encodePacked(blockhash(_block), _player, _seed, _count)));\n', '    }\n', '    \n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '    \n', '    function getMonsterBaseStats(uint64 _monsterId) constant external returns(uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        uint[6] memory stats;\n', '        for(uint i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        return (stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\n', '    }\n', '    \n', '    function getMonsterCurrentStats(uint64 _monsterId) constant external returns(uint exp, uint level, uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\n', '        \n', '        uint[6] memory stats;\n', '        uint i = 0;\n', '        level = getLevel(obj.exp);\n', '        for(i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        for(i=0; i < STAT_COUNT; i++) {\n', '            stats[i] += uint(data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_STEP, obj.classId, i)) * level * 3;\n', '        }\n', '        \n', '        return (obj.exp, level, stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\n', '    }\n', '    \n', '    function getMonsterCP(uint64 _monsterId) constant external returns(uint cp) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\n', '        \n', '        uint[6] memory stats;\n', '        uint i = 0;\n', '        cp = getLevel(obj.exp);\n', '        for(i=0; i < STAT_COUNT; i+=1) {\n', '            stats[i] = data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_BASE, _monsterId, i);\n', '        }\n', '        for(i=0; i < STAT_COUNT; i++) {\n', '            stats[i] += uint(data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_STEP, obj.classId, i)) * cp * 3;\n', '        }\n', '        \n', '        cp = (stats[0] + stats[1] + stats[2] + stats[3] + stats[4] + stats[5]) / 6;\n', '    }\n', '    \n', '    function getPrice(uint32 _classId) constant external returns(bool catchable, uint price) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        \n', '        price = class.price;\n', '        if (class.total > 0)\n', '            price += class.price*(class.total-1)/priceIncreasingRatio;\n', '        \n', '        if (class.catchable == false) {\n', '            if (addressWhitelist[msg.sender] == true && classWhitelist[_classId] == true) {\n', '                return (true, price);\n', '            }\n', '        }\n', '        \n', '        return (class.catchable, price);\n', '    }\n', '    \n', '    function getMonsterClassBasic(uint32 _classId) constant external returns(uint256, uint256, uint256, bool) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        return (class.price, class.returnPrice, class.total, class.catchable);\n', '    }\n', '    \n', '    function renameMonster(uint64 _objId, string name) isActive external {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (obj.monsterId != _objId || obj.trainer != msg.sender) {\n', '            revert();\n', '        }\n', '        data.setMonsterObj(_objId, name, obj.exp, obj.createIndex, obj.lastClaimIndex);\n', '    }\n', '    \n', '    function catchMonster(address _player, uint32 _classId, string _name) isActive external payable returns(uint tokenId) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterClassAcc memory class;\n', '        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\n', '        if (class.classId == 0) {\n', '            revert();\n', '        }\n', '        \n', '        if (class.catchable == false) {\n', '            if (addressWhitelist[msg.sender] == false || classWhitelist[_classId] == false) {\n', '                revert();\n', '            }\n', '        }\n', '        \n', '        uint price = class.price;\n', '        if (class.total > 0)\n', '            price += class.price*(class.total-1)/priceIncreasingRatio;\n', '        if (msg.value + gapFactor < price) {\n', '            revert();\n', '        }\n', '        \n', '        // add new monster \n', '        uint64 objId = data.addMonsterObj(_classId, _player, _name);\n', '        uint8 value;\n', '        seed = getRandom(_player, block.number-1, seed, objId);\n', '        // generate base stat for the previous one\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        \n', '        emit Transfer(address(0), _player, objId);\n', '\n', '        return objId; \n', '    }\n', '    \n', '    \n', '}']
