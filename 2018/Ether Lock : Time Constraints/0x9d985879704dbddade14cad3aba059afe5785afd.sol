['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Extradecoin is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "EXTRADECOIN";\n', '    string public constant symbol = "ETE";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 250000000 * 10 ** 18; // 250 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public advisorAddress;\n', '    \n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 3 years; // 1st locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod2 = 1 years; // 2nd locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod3 = 90 days; // 3nd locked period for tokens allocation of advisor and ICO partners\n', '   \n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_ICO = 1; // In ICO\n', '    uint constant END_SALE = 2; // End sales\n', '\n', '    uint256 public constant salesAllocation = 125000000 * 10 ** 18; // 125 mil tokens allocated for sales\n', '    uint256 public constant founderAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for founders\n', '    uint256 public constant advisorAllocation = 25000000 * 10 ** 18; // 25 mil tokens allocated for allocated for ICO partners and bonus fund\n', '    uint256 public constant reservedAllocation = 62500000 * 10 ** 18; // 62.5 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant minInvestedCap = 6000 * 10 ** 18; // 2500 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public advisorAllocatedTime = 1;\n', '    \n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalAdvisor; // Total tokens allocated for advisor\n', '    uint256 public totalReservedTokenAllocation; // Total tokens allocated for reserved\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    \n', '    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders&#39; address\n', '    event AllocateTokensForAdvisor(address advisorAddress, uint256 advisorAllocatedTime, uint256 tokenAmount); // Allocate tokens to advisor address\n', '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event AllocateSalesTokens(address salesAllocation, uint256 tokenAmount); // Allocate sales tokens\n', '\n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function Extradecoin(address _walletAddr, address _adminAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalAdvisor = advisorAllocation;\n', '        totalReservedTokenAllocation = reservedAllocation;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        saleState = IN_ICO;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoEndTime == 0);\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(advisorAddress != _newAddress);\n', '        advisorAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 4 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 3;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '\n', '    // Allocate tokens for advisor and angel investors vested gradually for 1 year\n', '    function allocateTokensForAdvisor() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(advisorAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = advisorAllocation * 50/100;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForFounder(advisorAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 4;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 4) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 5;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 5) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 6;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedTokenAllocation = totalReservedTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '\n', '   // Allocate sales tokens\n', '    function allocateSalesTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(_amount);\n', '        emit AllocateSalesTokens(_addr, _amount);\n', '    }\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Extradecoin is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "EXTRADECOIN";\n', '    string public constant symbol = "ETE";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 250000000 * 10 ** 18; // 250 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public advisorAddress;\n', '    \n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 3 years; // 1st locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod2 = 1 years; // 2nd locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod3 = 90 days; // 3nd locked period for tokens allocation of advisor and ICO partners\n', '   \n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_ICO = 1; // In ICO\n', '    uint constant END_SALE = 2; // End sales\n', '\n', '    uint256 public constant salesAllocation = 125000000 * 10 ** 18; // 125 mil tokens allocated for sales\n', '    uint256 public constant founderAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for founders\n', '    uint256 public constant advisorAllocation = 25000000 * 10 ** 18; // 25 mil tokens allocated for allocated for ICO partners and bonus fund\n', '    uint256 public constant reservedAllocation = 62500000 * 10 ** 18; // 62.5 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant minInvestedCap = 6000 * 10 ** 18; // 2500 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public advisorAllocatedTime = 1;\n', '    \n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalAdvisor; // Total tokens allocated for advisor\n', '    uint256 public totalReservedTokenAllocation; // Total tokens allocated for reserved\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    \n', "    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders' address\n", '    event AllocateTokensForAdvisor(address advisorAddress, uint256 advisorAllocatedTime, uint256 tokenAmount); // Allocate tokens to advisor address\n', '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event AllocateSalesTokens(address salesAllocation, uint256 tokenAmount); // Allocate sales tokens\n', '\n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function Extradecoin(address _walletAddr, address _adminAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalAdvisor = advisorAllocation;\n', '        totalReservedTokenAllocation = reservedAllocation;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        saleState = IN_ICO;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoEndTime == 0);\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(advisorAddress != _newAddress);\n', '        advisorAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 4 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 3;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '\n', '    // Allocate tokens for advisor and angel investors vested gradually for 1 year\n', '    function allocateTokensForAdvisor() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(advisorAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = advisorAllocation * 50/100;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForFounder(advisorAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 4;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 4) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 5;\n', '            return;\n', '        }\n', '        if (advisorAllocatedTime == 5) {\n', '            require(now >= icoEndTime + lockPeriod3);\n', '            amount = advisorAllocation * 125/1000;\n', '            balances[advisorAddress] = balances[advisorAddress].add(amount);\n', '            emit AllocateTokensForAdvisor(advisorAddress, advisorAllocatedTime, amount);\n', '            advisorAllocatedTime = 6;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedTokenAllocation = totalReservedTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '\n', '   // Allocate sales tokens\n', '    function allocateSalesTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(_amount);\n', '        emit AllocateSalesTokens(_addr, _amount);\n', '    }\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '}']
