['pragma solidity ^0.4.0;\n', '\n', 'contract ERC20Interface {\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '  function transfer(address to, uint tokens) public returns (bool success);\n', '  function approve(address spender, uint tokens) public returns (bool success);\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract WorkIt is ERC20Interface {\n', '\n', '  // non-fixed supply ERC20 implementation\n', '  string public constant name = "WorkIt Token";\n', '  string public constant symbol = "WIT";\n', '  uint _totalSupply = 0;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowances;\n', '\n', '  function totalSupply() public constant returns (uint) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '    return allowances[tokenOwner][spender];\n', '  }\n', '\n', '  function transfer(address to, uint tokens) public returns (bool success) {\n', '    require(balances[msg.sender] >= tokens);\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    balances[to] = balances[to] + tokens;\n', '    emit Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens) public returns (bool success) {\n', '    allowances[msg.sender][spender] = tokens;\n', '    emit Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '    require(allowances[from][msg.sender] >= tokens);\n', '    require(balances[from] >= tokens);\n', '    allowances[from][msg.sender] = allowances[from][msg.sender] - tokens;\n', '    balances[from] = balances[from] - tokens;\n', '    balances[to] = balances[to] + tokens;\n', '    emit Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  // End ERC-20 implementation\n', '\n', '  struct WeekCommittment {\n', '    uint daysCompleted;\n', '    uint daysCommitted;\n', '    mapping(uint => uint) workoutProofs;\n', '    uint tokensCommitted;\n', '    uint tokensEarned;\n', '    bool tokensPaid;\n', '  }\n', '\n', '  struct WeekData {\n', '    bool initialized;\n', '    uint totalPeopleCompleted;\n', '    uint totalPeople;\n', '    uint totalDaysCommitted;\n', '    uint totalDaysCompleted;\n', '    uint totalTokensCompleted;\n', '    uint totalTokens;\n', '  }\n', '\n', '  uint public weiPerToken = 1000000000000000; // 1000 WITs per eth\n', '  uint secondsPerDay = 86400;\n', '  uint daysPerWeek = 7;\n', '\n', '  mapping(uint => WeekData) public dataPerWeek;\n', '  mapping (address => mapping(uint => WeekCommittment)) public commitments;\n', '\n', '  mapping(uint => string) imageHashes;\n', '  uint imageHashCount;\n', '\n', '  uint public startDate;\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    // Round down to the nearest day at 00:00Z (UTC -6)\n', '    startDate = (block.timestamp / secondsPerDay) * secondsPerDay - 60 * 6;\n', '  }\n', '\n', '  event Log(string message);\n', '\n', '  // Fallback function executed when ethereum is received with no function call\n', '  function () public payable {\n', '    buyTokens(msg.value / weiPerToken);\n', '  }\n', '\n', '  // Buy tokens\n', '  function buyTokens(uint tokens) public payable {\n', '    require(msg.value >= tokens * weiPerToken);\n', '    balances[msg.sender] += tokens;\n', '    _totalSupply += tokens;\n', '  }\n', '\n', '  // Commit to exercising this week\n', '  function commitToWeek(uint tokens, uint _days) public {\n', '    // Need at least 10 tokens to participate\n', '    if (balances[msg.sender] < tokens || tokens < 10) {\n', '      emit Log("You need to bet at least 10 tokens to commit");\n', '      require(false);\n', '    }\n', '    if (_days == 0) {\n', '      emit Log("You cannot register for 0 days of activity");\n', '      require(false);\n', '    }\n', '    if (_days > daysPerWeek) {\n', '      emit Log("You cannot register for more than 7 days per week");\n', '      require(false);\n', '    }\n', '    if (_days > daysPerWeek - currentDayOfWeek()) {\n', '      emit Log("It is too late in the week for you to register");\n', '      require(false);\n', '    }\n', '\n', '    WeekCommittment storage commitment = commitments[msg.sender][currentWeek()];\n', '\n', '    if (commitment.tokensCommitted != 0) {\n', '      emit Log("You have already committed to this week");\n', '      require(false);\n', '    }\n', '    balances[0x0] = balances[0x0] + tokens;\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    emit Transfer(msg.sender, 0x0, tokens);\n', '\n', '    initializeWeekData(currentWeek());\n', '    WeekData storage data = dataPerWeek[currentWeek()];\n', '    data.totalPeople++;\n', '    data.totalTokens += tokens;\n', '    data.totalDaysCommitted += _days;\n', '\n', '    commitment.daysCommitted = _days;\n', '    commitment.daysCompleted = 0;\n', '    commitment.tokensCommitted = tokens;\n', '    commitment.tokensEarned = 0;\n', '    commitment.tokensPaid = false;\n', '  }\n', '\n', '  // Payout your available balance based on your activity in previous weeks\n', '  function payout() public {\n', '    require(currentWeek() > 0);\n', '    for (uint activeWeek = currentWeek() - 1; true; activeWeek--) {\n', '      WeekCommittment storage committment = commitments[msg.sender][activeWeek];\n', '      if (committment.tokensPaid) {\n', '        break;\n', '      }\n', '      if (committment.daysCommitted == 0) {\n', '        committment.tokensPaid = true;\n', '        // Handle edge case and avoid -1\n', '        if (activeWeek == 0) break;\n', '        continue;\n', '      }\n', '      initializeWeekData(activeWeek);\n', '      WeekData storage week = dataPerWeek[activeWeek];\n', '      uint tokensFromPool = 0;\n', '      uint tokens = committment.tokensCommitted * committment.daysCompleted / committment.daysCommitted;\n', '      if (week.totalPeopleCompleted == 0) {\n', '        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeople;\n', '        tokens = 0;\n', '      } else if (committment.daysCompleted == committment.daysCommitted) {\n', '        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeopleCompleted;\n', '      }\n', '      uint totalTokens = tokensFromPool + tokens;\n', '      if (totalTokens == 0) {\n', '        committment.tokensPaid = true;\n', '        // Handle edge case and avoid -1\n', '        if (activeWeek == 0) break;\n', '        continue;\n', '      }\n', '      balances[0x0] = balances[0x0] - totalTokens;\n', '      balances[msg.sender] = balances[msg.sender] + totalTokens;\n', '      emit Transfer(0x0, msg.sender, totalTokens);\n', '      committment.tokensEarned = totalTokens;\n', '      committment.tokensPaid = true;\n', '\n', '      // Handle edge case and avoid -1\n', '      if (activeWeek == 0) break;\n', '    }\n', '  }\n', '\n', '  // Post image data to the blockchain and log completion\n', '  // TODO: If not committed for this week use last weeks tokens and days (if it exists)\n', '  function postProof(string proofHash) public {\n', '    WeekCommittment storage committment = commitments[msg.sender][currentWeek()];\n', '    if (committment.daysCompleted > currentDayOfWeek()) {\n', '      emit Log("You have already uploaded proof for today");\n', '      require(false);\n', '    }\n', '    if (committment.tokensCommitted == 0) {\n', '      emit Log("You have not committed to this week yet");\n', '      require(false);\n', '    }\n', '    if (committment.workoutProofs[currentDayOfWeek()] != 0) {\n', '      emit Log("Proof has already been stored for this day");\n', '      require(false);\n', '    }\n', '    if (committment.daysCompleted >= committment.daysCommitted) {\n', '      // Don&#39;t allow us to go over our committed days\n', '      return;\n', '    }\n', '    committment.workoutProofs[currentDayOfWeek()] = storeImageString(proofHash);\n', '    committment.daysCompleted++;\n', '\n', '    initializeWeekData(currentWeek());\n', '    WeekData storage week = dataPerWeek[currentWeek()];\n', '    week.totalDaysCompleted++;\n', '    week.totalTokensCompleted = week.totalTokens * week.totalDaysCompleted / week.totalDaysCommitted;\n', '    if (committment.daysCompleted >= committment.daysCommitted) {\n', '      week.totalPeopleCompleted++;\n', '    }\n', '  }\n', '\n', '  // Withdraw tokens to eth\n', '  function withdraw(uint tokens) public returns (bool success) {\n', '    require(balances[msg.sender] >= tokens);\n', '    uint weiToSend = tokens * weiPerToken;\n', '    require(address(this).balance >= weiToSend);\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    _totalSupply -= tokens;\n', '    return msg.sender.send(tokens * weiPerToken);\n', '  }\n', '\n', '  // Store an image string and get back a numerical identifier\n', '  function storeImageString(string hash) public returns (uint index) {\n', '    imageHashes[++imageHashCount] = hash;\n', '    return imageHashCount;\n', '  }\n', '\n', '  // Initialize a week data struct\n', '  function initializeWeekData(uint _week) public {\n', '    if (dataPerWeek[_week].initialized) return;\n', '    WeekData storage week = dataPerWeek[_week];\n', '    week.initialized = true;\n', '    week.totalTokensCompleted = 0;\n', '    week.totalPeopleCompleted = 0;\n', '    week.totalTokens = 0;\n', '    week.totalPeople = 0;\n', '    week.totalDaysCommitted = 0;\n', '    week.totalDaysCompleted = 0;\n', '  }\n', '\n', '  // Get the current day (from contract creation)\n', '  function currentDay() public view returns (uint day) {\n', '    return (block.timestamp - startDate) / secondsPerDay;\n', '  }\n', '\n', '  // Get the current week (from contract creation)\n', '  function currentWeek() public view returns (uint week) {\n', '    return currentDay() / daysPerWeek;\n', '  }\n', '\n', '  // Get current relative day of week (0-6)\n', '  function currentDayOfWeek() public view returns (uint dayIndex) {\n', '    // Uses the floor to calculate offset\n', '    return currentDay() - (currentWeek() * daysPerWeek);\n', '  }\n', '}']
['pragma solidity ^0.4.0;\n', '\n', 'contract ERC20Interface {\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '  function transfer(address to, uint tokens) public returns (bool success);\n', '  function approve(address spender, uint tokens) public returns (bool success);\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract WorkIt is ERC20Interface {\n', '\n', '  // non-fixed supply ERC20 implementation\n', '  string public constant name = "WorkIt Token";\n', '  string public constant symbol = "WIT";\n', '  uint _totalSupply = 0;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowances;\n', '\n', '  function totalSupply() public constant returns (uint) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '    return allowances[tokenOwner][spender];\n', '  }\n', '\n', '  function transfer(address to, uint tokens) public returns (bool success) {\n', '    require(balances[msg.sender] >= tokens);\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    balances[to] = balances[to] + tokens;\n', '    emit Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens) public returns (bool success) {\n', '    allowances[msg.sender][spender] = tokens;\n', '    emit Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '    require(allowances[from][msg.sender] >= tokens);\n', '    require(balances[from] >= tokens);\n', '    allowances[from][msg.sender] = allowances[from][msg.sender] - tokens;\n', '    balances[from] = balances[from] - tokens;\n', '    balances[to] = balances[to] + tokens;\n', '    emit Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  // End ERC-20 implementation\n', '\n', '  struct WeekCommittment {\n', '    uint daysCompleted;\n', '    uint daysCommitted;\n', '    mapping(uint => uint) workoutProofs;\n', '    uint tokensCommitted;\n', '    uint tokensEarned;\n', '    bool tokensPaid;\n', '  }\n', '\n', '  struct WeekData {\n', '    bool initialized;\n', '    uint totalPeopleCompleted;\n', '    uint totalPeople;\n', '    uint totalDaysCommitted;\n', '    uint totalDaysCompleted;\n', '    uint totalTokensCompleted;\n', '    uint totalTokens;\n', '  }\n', '\n', '  uint public weiPerToken = 1000000000000000; // 1000 WITs per eth\n', '  uint secondsPerDay = 86400;\n', '  uint daysPerWeek = 7;\n', '\n', '  mapping(uint => WeekData) public dataPerWeek;\n', '  mapping (address => mapping(uint => WeekCommittment)) public commitments;\n', '\n', '  mapping(uint => string) imageHashes;\n', '  uint imageHashCount;\n', '\n', '  uint public startDate;\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    // Round down to the nearest day at 00:00Z (UTC -6)\n', '    startDate = (block.timestamp / secondsPerDay) * secondsPerDay - 60 * 6;\n', '  }\n', '\n', '  event Log(string message);\n', '\n', '  // Fallback function executed when ethereum is received with no function call\n', '  function () public payable {\n', '    buyTokens(msg.value / weiPerToken);\n', '  }\n', '\n', '  // Buy tokens\n', '  function buyTokens(uint tokens) public payable {\n', '    require(msg.value >= tokens * weiPerToken);\n', '    balances[msg.sender] += tokens;\n', '    _totalSupply += tokens;\n', '  }\n', '\n', '  // Commit to exercising this week\n', '  function commitToWeek(uint tokens, uint _days) public {\n', '    // Need at least 10 tokens to participate\n', '    if (balances[msg.sender] < tokens || tokens < 10) {\n', '      emit Log("You need to bet at least 10 tokens to commit");\n', '      require(false);\n', '    }\n', '    if (_days == 0) {\n', '      emit Log("You cannot register for 0 days of activity");\n', '      require(false);\n', '    }\n', '    if (_days > daysPerWeek) {\n', '      emit Log("You cannot register for more than 7 days per week");\n', '      require(false);\n', '    }\n', '    if (_days > daysPerWeek - currentDayOfWeek()) {\n', '      emit Log("It is too late in the week for you to register");\n', '      require(false);\n', '    }\n', '\n', '    WeekCommittment storage commitment = commitments[msg.sender][currentWeek()];\n', '\n', '    if (commitment.tokensCommitted != 0) {\n', '      emit Log("You have already committed to this week");\n', '      require(false);\n', '    }\n', '    balances[0x0] = balances[0x0] + tokens;\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    emit Transfer(msg.sender, 0x0, tokens);\n', '\n', '    initializeWeekData(currentWeek());\n', '    WeekData storage data = dataPerWeek[currentWeek()];\n', '    data.totalPeople++;\n', '    data.totalTokens += tokens;\n', '    data.totalDaysCommitted += _days;\n', '\n', '    commitment.daysCommitted = _days;\n', '    commitment.daysCompleted = 0;\n', '    commitment.tokensCommitted = tokens;\n', '    commitment.tokensEarned = 0;\n', '    commitment.tokensPaid = false;\n', '  }\n', '\n', '  // Payout your available balance based on your activity in previous weeks\n', '  function payout() public {\n', '    require(currentWeek() > 0);\n', '    for (uint activeWeek = currentWeek() - 1; true; activeWeek--) {\n', '      WeekCommittment storage committment = commitments[msg.sender][activeWeek];\n', '      if (committment.tokensPaid) {\n', '        break;\n', '      }\n', '      if (committment.daysCommitted == 0) {\n', '        committment.tokensPaid = true;\n', '        // Handle edge case and avoid -1\n', '        if (activeWeek == 0) break;\n', '        continue;\n', '      }\n', '      initializeWeekData(activeWeek);\n', '      WeekData storage week = dataPerWeek[activeWeek];\n', '      uint tokensFromPool = 0;\n', '      uint tokens = committment.tokensCommitted * committment.daysCompleted / committment.daysCommitted;\n', '      if (week.totalPeopleCompleted == 0) {\n', '        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeople;\n', '        tokens = 0;\n', '      } else if (committment.daysCompleted == committment.daysCommitted) {\n', '        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeopleCompleted;\n', '      }\n', '      uint totalTokens = tokensFromPool + tokens;\n', '      if (totalTokens == 0) {\n', '        committment.tokensPaid = true;\n', '        // Handle edge case and avoid -1\n', '        if (activeWeek == 0) break;\n', '        continue;\n', '      }\n', '      balances[0x0] = balances[0x0] - totalTokens;\n', '      balances[msg.sender] = balances[msg.sender] + totalTokens;\n', '      emit Transfer(0x0, msg.sender, totalTokens);\n', '      committment.tokensEarned = totalTokens;\n', '      committment.tokensPaid = true;\n', '\n', '      // Handle edge case and avoid -1\n', '      if (activeWeek == 0) break;\n', '    }\n', '  }\n', '\n', '  // Post image data to the blockchain and log completion\n', '  // TODO: If not committed for this week use last weeks tokens and days (if it exists)\n', '  function postProof(string proofHash) public {\n', '    WeekCommittment storage committment = commitments[msg.sender][currentWeek()];\n', '    if (committment.daysCompleted > currentDayOfWeek()) {\n', '      emit Log("You have already uploaded proof for today");\n', '      require(false);\n', '    }\n', '    if (committment.tokensCommitted == 0) {\n', '      emit Log("You have not committed to this week yet");\n', '      require(false);\n', '    }\n', '    if (committment.workoutProofs[currentDayOfWeek()] != 0) {\n', '      emit Log("Proof has already been stored for this day");\n', '      require(false);\n', '    }\n', '    if (committment.daysCompleted >= committment.daysCommitted) {\n', "      // Don't allow us to go over our committed days\n", '      return;\n', '    }\n', '    committment.workoutProofs[currentDayOfWeek()] = storeImageString(proofHash);\n', '    committment.daysCompleted++;\n', '\n', '    initializeWeekData(currentWeek());\n', '    WeekData storage week = dataPerWeek[currentWeek()];\n', '    week.totalDaysCompleted++;\n', '    week.totalTokensCompleted = week.totalTokens * week.totalDaysCompleted / week.totalDaysCommitted;\n', '    if (committment.daysCompleted >= committment.daysCommitted) {\n', '      week.totalPeopleCompleted++;\n', '    }\n', '  }\n', '\n', '  // Withdraw tokens to eth\n', '  function withdraw(uint tokens) public returns (bool success) {\n', '    require(balances[msg.sender] >= tokens);\n', '    uint weiToSend = tokens * weiPerToken;\n', '    require(address(this).balance >= weiToSend);\n', '    balances[msg.sender] = balances[msg.sender] - tokens;\n', '    _totalSupply -= tokens;\n', '    return msg.sender.send(tokens * weiPerToken);\n', '  }\n', '\n', '  // Store an image string and get back a numerical identifier\n', '  function storeImageString(string hash) public returns (uint index) {\n', '    imageHashes[++imageHashCount] = hash;\n', '    return imageHashCount;\n', '  }\n', '\n', '  // Initialize a week data struct\n', '  function initializeWeekData(uint _week) public {\n', '    if (dataPerWeek[_week].initialized) return;\n', '    WeekData storage week = dataPerWeek[_week];\n', '    week.initialized = true;\n', '    week.totalTokensCompleted = 0;\n', '    week.totalPeopleCompleted = 0;\n', '    week.totalTokens = 0;\n', '    week.totalPeople = 0;\n', '    week.totalDaysCommitted = 0;\n', '    week.totalDaysCompleted = 0;\n', '  }\n', '\n', '  // Get the current day (from contract creation)\n', '  function currentDay() public view returns (uint day) {\n', '    return (block.timestamp - startDate) / secondsPerDay;\n', '  }\n', '\n', '  // Get the current week (from contract creation)\n', '  function currentWeek() public view returns (uint week) {\n', '    return currentDay() / daysPerWeek;\n', '  }\n', '\n', '  // Get current relative day of week (0-6)\n', '  function currentDayOfWeek() public view returns (uint dayIndex) {\n', '    // Uses the floor to calculate offset\n', '    return currentDay() - (currentWeek() * daysPerWeek);\n', '  }\n', '}']
