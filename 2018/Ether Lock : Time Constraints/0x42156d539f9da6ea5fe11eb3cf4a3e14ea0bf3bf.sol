['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', 'contract ERC20Interface {\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', 'contract Halo3D {\n', '\n', '    function buy(address) public payable returns(uint256);\n', '    function transfer(address, uint256) public returns(bool);\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '    function reinvest() public;\n', '}\n', '\n', '/**\n', ' * Definition of contract accepting Halo3D tokens\n', ' * Games, casinos, anything can reuse this contract to support Halo3D tokens\n', ' */\n', 'contract AcceptsHalo3D {\n', '    Halo3D public tokenContract;\n', '\n', '    function AcceptsHalo3D(address _tokenContract) public {\n', '        tokenContract = Halo3D(_tokenContract);\n', '    }\n', '\n', '    modifier onlyTokenContract {\n', '        require(msg.sender == address(tokenContract));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Standard ERC677 function that will handle incoming token transfers.\n', '    *\n', '    * @param _from  Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data  Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '}\n', '\n', 'contract Halo3DPotPotato is AcceptsHalo3D {\n', '    address public ceoAddress;\n', '    address public hotPotatoHolder;\n', '    address public lastHotPotatoHolder;\n', '    uint256 public lastBidTime;\n', '    uint256 public contestStartTime;\n', '    uint256 public lastPot;\n', '\n', '    Potato[] public potatoes;\n', '\n', '    uint256 public BASE_TIME_TO_COOK=30 minutes;//60 seconds;\n', '    uint256 public TIME_MULTIPLIER=5 minutes;//5 seconds;//time per index of potato\n', '    uint256 public TIME_TO_COOK=BASE_TIME_TO_COOK; //this changes\n', '    uint256 public NUM_POTATOES=12;\n', '    uint256 public START_PRICE=10 ether; // 10 TOKENS\n', '    uint256 public CONTEST_INTERVAL= 1 days;//4 minutes;//1 week\n', '\n', '    /*** DATATYPES ***/\n', '    struct Potato {\n', '        address owner;\n', '        uint256 price;\n', '    }\n', '\n', '    /*** CONSTRUCTOR ***/\n', '    function Halo3DPotPotato(address _baseContract)\n', '      AcceptsHalo3D(_baseContract)\n', '      public{\n', '        ceoAddress=msg.sender;\n', '        hotPotatoHolder=0;\n', '        contestStartTime=now;\n', '        for(uint i = 0; i<NUM_POTATOES; i++){\n', '            Potato memory newpotato=Potato({owner:address(this),price: START_PRICE});\n', '            potatoes.push(newpotato);\n', '        }\n', '    }\n', '    \n', '     /**\n', '     * Fallback function for the contract, protect investors\n', '     * NEED ALWAYS TO HAVE\n', '     */\n', '    function() payable public {\n', '      // Not accepting Ether directly\n', '      /* revert(); */\n', '    }\n', '\n', '    /*** PUBLIC FUNCTIONS ***/\n', '    /**\n', '    * Deposit Halo3D tokens to buy potato\n', '    *\n', '    * @dev Standard ERC677 function that will handle incoming token transfers.\n', '    * @param _from  Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data  Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data)\n', '      external\n', '      onlyTokenContract\n', '      returns (bool) {\n', '        require(now > contestStartTime);\n', '        require(!_isContract(_from));\n', '        if(_endContestIfNeeded(_from, _value)){\n', '\n', '        }\n', '        else{\n', '            // Byte data to index how to transfer?\n', '            uint64 index = uint64(_data[0]);\n', '            Potato storage potato=potatoes[index];\n', '            require(_value >= potato.price);\n', '            //allow calling transfer() on these addresses without risking re-entrancy attacks\n', '            require(_from != potato.owner);\n', '            require(_from != ceoAddress);\n', '            uint256 sellingPrice=potato.price;\n', '            uint256 purchaseExcess = SafeMath.sub(_value, sellingPrice);\n', '            uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 76), 100));\n', '            uint256 devFee= uint256(SafeMath.div(SafeMath.mul(sellingPrice, 4), 100));\n', '            //20 percent remaining in the contract goes to the pot\n', '            //if the owner is the contract, this is the first purchase, and payment should go to the pot\n', '            reinvest();\n', '            if(potato.owner!=address(this)){\n', '                tokenContract.transfer(potato.owner, payment);\n', '            }\n', '            tokenContract.transfer(ceoAddress, devFee);\n', '            potato.price= SafeMath.div(SafeMath.mul(sellingPrice, 150), 76);\n', '            potato.owner=_from;//transfer ownership\n', '            hotPotatoHolder=_from;//becomes holder with potential to win the pot\n', '            lastBidTime=now;\n', '            TIME_TO_COOK=SafeMath.add(BASE_TIME_TO_COOK,SafeMath.mul(index,TIME_MULTIPLIER)); //pots have times to cook varying from 30-85 minutes\n', '\n', '            tokenContract.transfer(_from, purchaseExcess); //returns excess eth\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    // Reinvest Halo3D PotPotato dividends\n', '    // All the dividends this contract makes will be used to grow token fund for players\n', '    // of the Halo3D PotPotato Game\n', '    function reinvest() public {\n', '       if(tokenContract.myDividends(true) > 1) {\n', '         tokenContract.reinvest();\n', '       }\n', '       /*\n', '       uint balance = address(this).balance;\n', '       if (balance > 1) {\n', '         tokenContract.buy.value(balance).gas(1000000)(msg.sender);\n', '       } */ // Not possible because of contract protection\n', '    }\n', '\n', '    // Collect information about Halo3dPotPotato dividents amount\n', '    function getContractDividends() public view returns(uint256) {\n', '      return tokenContract.myDividends(true); // + this.balance;\n', '    }\n', '\n', '    // Get tokens balance of the Halo3D PotPotato\n', '    function getBalance() public view returns(uint256 value){\n', '        return tokenContract.myTokens();\n', '    }\n', '\n', '    function timePassed() public view returns(uint256 time){\n', '        if(lastBidTime==0){\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(block.timestamp,lastBidTime);\n', '    }\n', '\n', '    function timeLeftToContestStart() public view returns(uint256 time){\n', '        if(block.timestamp>contestStartTime){\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(contestStartTime,block.timestamp);\n', '    }\n', '\n', '    function timeLeftToCook() public view returns(uint256 time){\n', '        return SafeMath.sub(TIME_TO_COOK,timePassed());\n', '    }\n', '\n', '    function contestOver() public view returns(bool){\n', '        return timePassed()>=TIME_TO_COOK;\n', '    }\n', '\n', '    /*** PRIVATE FUNCTIONS ***/\n', '    // Check transaction coming from the contract or not\n', '    function _isContract(address _user) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(_user) }\n', '        return size > 0;\n', '    }\n', '\n', '    function _endContestIfNeeded(address _from, uint256 _value) private returns(bool){\n', '        if(timePassed()>=TIME_TO_COOK){\n', '            //contest over, refund anything paid\n', '            reinvest();\n', '            tokenContract.transfer(_from, _value);\n', '            lastPot=getBalance();\n', '            lastHotPotatoHolder=hotPotatoHolder;\n', '            tokenContract.transfer(hotPotatoHolder, tokenContract.myTokens());\n', '            hotPotatoHolder=0;\n', '            lastBidTime=0;\n', '            _resetPotatoes();\n', '            _setNewStartTime();\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _resetPotatoes() private{\n', '        for(uint i = 0; i<NUM_POTATOES; i++){\n', '            Potato memory newpotato=Potato({owner:address(this),price: START_PRICE});\n', '            potatoes[i]=newpotato;\n', '        }\n', '    }\n', '\n', '    function _setNewStartTime() private{\n', '        uint256 start=contestStartTime;\n', '        while(start < now){\n', '            start=SafeMath.add(start,CONTEST_INTERVAL);\n', '        }\n', '        contestStartTime=start;\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']