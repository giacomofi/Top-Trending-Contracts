['pragma solidity ^0.4.25;\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner = 0x0;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '     modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract CryptoSoulPresale is Ownable{\n', '    struct DataBase{\n', '        uint256 deposit;\n', '        uint256 soulValue;\n', '    }\n', '    \n', '    event Deposit(address indexed _from, uint256 _value);\n', '    \n', '    mapping(address => DataBase) walletsData;\n', '    address[] internal wallets;\n', '    \n', '    uint24 public depositsCount = 0;\n', '    \n', '    uint256 public soulCap = 83300000;\n', '    \n', '    uint256 public collectedFunds = 0;\n', '    uint256 public distributedTokens = 0;\n', '    \n', '    uint256 public soulReward0 = 125000;\n', '    uint256 public soulReward1 = 142800;\n', '    uint256 public soulReward2 = 166600;\n', '    \n', '    uint256 public minDeposit = 0.01 ether;\n', '    uint256 public ethPriceLvl0 = 0.99 ether;\n', '    uint256 public ethPriceLvl1 = 6.99 ether;\n', '    \n', '    function() external payable{\n', '        require(msg.value >= minDeposit &&\n', '        distributedTokens < soulCap);\n', '        uint256 ethValue = msg.value;\n', '        uint256 soulValue = getSoulByEth(ethValue);     \n', '        uint256 totalSoulValue = distributedTokens + soulValue;\n', '        if (totalSoulValue > soulCap){\n', '            soulValue = soulCap - distributedTokens;\n', '            ethValue = getResidualEtherAmount(ethValue, soulValue);\n', '            uint256 etherNickel = msg.value - ethValue;\n', '            msg.sender.transfer(etherNickel);\n', '        }\n', '        owner.transfer(ethValue);\n', '        depositsCount++;\n', '        countUser(msg.sender);\n', '        walletsData[msg.sender].deposit += ethValue;\n', '        walletsData[msg.sender].soulValue += soulValue;\n', '        collectedFunds += ethValue;\n', '        distributedTokens += soulValue;\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '  \n', '  function getDepositValue(address _owner) public view returns(uint256){\n', '      return walletsData[_owner].deposit;\n', '  }\n', '  \n', '  function balanceOf(address _owner) public view returns(uint256){\n', '      return walletsData[_owner].soulValue;\n', '  }\n', '   \n', '   function changeSoulReward(uint256 _value0, uint256 _value1, uint256 _value2) public onlyOwner{\n', '      soulReward0 = _value0;\n', '      soulReward1 = _value1;\n', '      soulReward2 = _value2;\n', '      recountUsersBalance();\n', '   }\n', '   \n', '   function changeMinDeposit(uint256 _value) public onlyOwner{\n', '       minDeposit = _value;\n', '   }\n', '   \n', '   function changeSoulCap(uint256 _value) public onlyOwner{\n', '       soulCap = _value;\n', '   }\n', '   \n', '   function addUser(address _wallet, uint256 _depositValue) public onlyOwner{\n', '       require(walletsData[_wallet].deposit == 0);\n', '       saveUserWallet(_wallet);\n', '       walletsData[_wallet].deposit = _depositValue;\n', '       uint256 soulValue = getSoulByEth(_depositValue);\n', '       walletsData[_wallet].soulValue = soulValue;\n', '       distributedTokens += soulValue;\n', '       collectedFunds += _depositValue;\n', '   }\n', '   \n', '   function recountUsersBalance() internal{\n', '       int256 distributeDiff = 0; \n', '       for(uint24 i = 0; i < wallets.length; i++){\n', '           address wallet = wallets[i];\n', '           uint256 originalValue = walletsData[wallet].soulValue;\n', '           walletsData[wallet].soulValue = getSoulByEth(walletsData[wallet].deposit);\n', '           distributeDiff += int256(walletsData[wallet].soulValue - originalValue);\n', '       }\n', '       if(distributeDiff < 0){\n', '           uint256 uDistrributeDiff = uint256(-distributeDiff);\n', '           require(distributedTokens >= uDistrributeDiff);\n', '           distributedTokens -= uDistrributeDiff;\n', '       }else{\n', '            uint256 totalSoul = distributedTokens + uint256(distributeDiff);\n', '            require(totalSoul <= soulCap);\n', '            distributedTokens = totalSoul;\n', '       }\n', '   }\n', '   \n', '   function assignOldUserFunds(address[] _oldUsersWallets, uint256[] _values) public onlyOwner{\n', '       wallets = _oldUsersWallets;\n', '       for(uint24 i = 0; i < wallets.length; i++){\n', '           uint256 depositValue = _values[i];\n', '           uint256 soulValue = getSoulByEth(_values[i]);\n', '           walletsData[wallets[i]].deposit = depositValue;\n', '           walletsData[wallets[i]].soulValue = soulValue;\n', '           collectedFunds += depositValue;\n', '           distributedTokens += soulValue;\n', '       }\n', '   }\n', '   \n', '   function saveUserWallet(address _address) internal{\n', '       wallets.push(_address);\n', '   }\n', '   \n', '   function getResidualEtherAmount(uint256 _ethValue, uint256 _soulResidual) internal view returns(uint256){\n', '      return _soulResidual * 10 ** 18 / getRewardLevel(_ethValue);\n', '  }\n', '  \n', '   function getSoulByEth(uint256 _ethValue) internal view returns(uint256){\n', '       return (_ethValue * getRewardLevel(_ethValue)) / 10 ** 18;\n', '   }\n', '   \n', '   function getRewardLevel(uint256 _ethValue) internal view returns(uint256){\n', '        if (_ethValue <= ethPriceLvl0){\n', '           return soulReward0;\n', '       } else if (_ethValue > ethPriceLvl0 && _ethValue <= ethPriceLvl1){\n', '           return soulReward1;\n', '       } else if (_ethValue > ethPriceLvl1){\n', '           return soulReward2;\n', '       }\n', '   }\n', '   \n', '   function countUser(address _owner) internal{\n', '       if (walletsData[_owner].deposit == 0){\n', '           saveUserWallet(_owner);\n', '       }\n', '   }\n', '   \n', '   function getUsersCount() public view returns(uint256){\n', '       return wallets.length;\n', '   }\n', '}']