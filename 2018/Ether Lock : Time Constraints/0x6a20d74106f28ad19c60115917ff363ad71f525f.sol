['pragma solidity ^0.4.21;\n', '\n', 'library BWUtility {\n', '    \n', '    // -------- UTILITY FUNCTIONS ----------\n', '\n', '\n', '    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\n', '    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\n', '        return ((_amount + _multiple - 1) / _multiple) * _multiple;\n', '    }\n', '\n', '    // Checks if two coordinates are adjacent:\n', '    // xxx\n', '    // xox\n', '    // xxx\n', '    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \n', '    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\n', '    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\n', '        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\n', '               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\n', '               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\n', '               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\n', '    }\n', '\n', '    // Converts (x, y) to tileId xy\n', '    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\n', '        return uint16(_x) << 8 | uint16(_y);\n', '    }\n', '\n', '    // Converts _tileId to (x, y)\n', '    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\n', '        uint8 y = uint8(_tileId);\n', '        uint8 x = uint8(_tileId >> 8);\n', '        return (x, y);\n', '    }\n', '    \n', '    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\n', '        if (_claimer == _attacker) {\n', '            return (_blockValue, 0);\n', '        } else if (_claimer == _defender) {\n', '            return (0, _blockValue);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface ERC20I {\n', '    function transfer(address _recipient, uint256 _amount) external returns (bool);\n', '    function balanceOf(address _holder) external view returns (uint256);\n', '}\n', '\n', '\n', 'contract BWService {\n', '    using SafeMath for uint256;\n', '    address private owner;\n', '    address private bw;\n', '    address private bwMarket;\n', '    BWData private bwData;\n', '    uint private seed = 42;\n', '    uint private WITHDRAW_FEE = 5; // 5%\n', '    uint private ATTACK_FEE = 5; // 5%\n', '    uint private ATTACK_BOOST_CAP = 300; // 300%\n', '    uint private DEFEND_BOOST_CAP = 300; // 300%\n', '    uint private ATTACK_BOOST_MULTIPLIER = 100; // 100%\n', '    uint private DEFEND_BOOST_MULTIPLIER = 100; // 100%\n', '    mapping (uint16 => address) private localGames;\n', '    \n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }  \n', '\n', '    modifier isValidCaller {\n', '        if (msg.sender != bw && msg.sender != bwMarket) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    event TileClaimed(uint16 tileId, address newClaimer, uint priceInWei, uint creationTime);\n', '    event TileFortified(uint16 tileId, address claimer, uint addedValueInWei, uint priceInWei, uint fortifyTime); // Sent when a user fortifies an existing claim by bumping its value.\n', '    event TileAttackedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint attackTime); // Sent when a user successfully attacks a tile.    \n', '    event TileDefendedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint defendTime); // Sent when a user successfully defends a tile when attacked.    \n', '    event BlockValueMoved(uint16 sourceTileId, uint16 destTileId, address owner, uint movedBlockValue, uint postSourceValue, uint postDestValue, uint moveTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n', '    event UserBattleValueUpdated(address userAddress, uint battleValue, bool isWithdraw);\n', '\n', '    // Constructor.\n', '    constructor(address _bwData) public {\n', '        bwData = BWData(_bwData);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Can&#39;t send funds straight to this contract. Avoid people sending by mistake.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '\n', '    // OWNER-ONLY FUNCTIONS\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function setValidBwCaller(address _bw) public isOwner {\n', '        bw = _bw;\n', '    }\n', '    \n', '    function setValidBwMarketCaller(address _bwMarket) public isOwner {\n', '        bwMarket = _bwMarket;\n', '    }\n', '\n', '    function setWithdrawFee(uint _feePercentage) public isOwner {\n', '        WITHDRAW_FEE = _feePercentage;\n', '    }\n', '\n', '    function setAttackFee(uint _feePercentage) public isOwner {\n', '        ATTACK_FEE = _feePercentage;\n', '    }\n', '\n', '    function setAttackBoostMultipler(uint _multiplierPercentage) public isOwner {\n', '        ATTACK_BOOST_MULTIPLIER = _multiplierPercentage;\n', '    }\n', '\n', '    function setDefendBoostMultiplier(uint _multiplierPercentage) public isOwner {\n', '        DEFEND_BOOST_MULTIPLIER = _multiplierPercentage;\n', '    }\n', '\n', '    function setAttackBoostCap(uint _capPercentage) public isOwner {\n', '        ATTACK_BOOST_CAP = _capPercentage;\n', '    }\n', '\n', '    function setDefendBoostCap(uint _capPercentage) public isOwner {\n', '        DEFEND_BOOST_CAP = _capPercentage;\n', '    }\n', '\n', '    // TILE-RELATED FUNCTIONS\n', '    // This function claims multiple previously unclaimed tiles in a single transaction.\n', '    // The value assigned to each tile is the msg.value divided by the number of tiles claimed.\n', '    // The msg.value is required to be an even multiple of the number of tiles claimed.\n', '    function storeInitialClaim(address _msgSender, uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) public isValidCaller {\n', '        uint tileCount = _claimedTileIds.length;\n', '        require(tileCount > 0);\n', '        require(_claimAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n', '        require(_claimAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles claimed\n', '\n', '        uint valuePerBlockInWei = _claimAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n', '        require(valuePerBlockInWei >= 5 finney);\n', '\n', '        if (_useBattleValue) {\n', '            subUserBattleValue(_msgSender, _claimAmount, false);  \n', '        }\n', '\n', '        addGlobalBlockValueBalance(_claimAmount);\n', '\n', '        uint16 tileId;\n', '        bool isNewTile;\n', '        for (uint16 i = 0; i < tileCount; i++) {\n', '            tileId = _claimedTileIds[i];\n', '            isNewTile = bwData.isNewTile(tileId); // Is length 0 if first time purchased\n', '            require(isNewTile); // Can only claim previously unclaimed tiles.\n', '\n', '            // Send claim event\n', '            emit TileClaimed(tileId, _msgSender, valuePerBlockInWei, block.timestamp);\n', '\n', '            // Update contract state with new tile ownership.\n', '            bwData.storeClaim(tileId, _msgSender, valuePerBlockInWei);\n', '        }\n', '    }\n', '\n', '    function fortifyClaims(address _msgSender, uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) public isValidCaller {\n', '        uint tileCount = _claimedTileIds.length;\n', '        require(tileCount > 0);\n', '\n', '        address(this).balance.add(_fortifyAmount); // prevent overflow with SafeMath\n', '        require(_fortifyAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles fortified\n', '        uint addedValuePerTileInWei = _fortifyAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n', '        require(_fortifyAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n', '\n', '        address claimer;\n', '        uint blockValue;\n', '        for (uint16 i = 0; i < tileCount; i++) {\n', '            (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_claimedTileIds[i]);\n', '            require(claimer != 0); // Can&#39;t do this on never-owned tiles\n', '            require(claimer == _msgSender); // Only current claimer can fortify claim\n', '\n', '            if (_useBattleValue) {\n', '                subUserBattleValue(_msgSender, addedValuePerTileInWei, false);\n', '            }\n', '            \n', '            fortifyClaim(_msgSender, _claimedTileIds[i], addedValuePerTileInWei);\n', '        }\n', '    }\n', '\n', '    function fortifyClaim(address _msgSender, uint16 _claimedTileId, uint _fortifyAmount) private {\n', '        uint blockValue;\n', '        uint sellPrice;\n', '        (blockValue, sellPrice) = bwData.getCurrentBlockValueAndSellPriceForTile(_claimedTileId);\n', '        uint updatedBlockValue = blockValue.add(_fortifyAmount);\n', '        // Send fortify event\n', '        emit TileFortified(_claimedTileId, _msgSender, _fortifyAmount, updatedBlockValue, block.timestamp);\n', '        \n', '        // Update tile value. The tile has been fortified by bumping up its value.\n', '        bwData.updateTileBlockValue(_claimedTileId, updatedBlockValue);\n', '\n', '        // Track addition to global block value\n', '        addGlobalBlockValueBalance(_fortifyAmount);\n', '    }\n', '\n', '    // Return a pseudo random number between lower and upper bounds\n', '    // given the number of previous blocks it should hash.\n', '    // Random function copied from https://github.com/axiomzen/eth-random/blob/master/contracts/Random.sol.\n', '    // Changed sha3 to keccak256, then modified.\n', '    // Changed random range from uint64 to uint (=uint256).\n', '    function random(uint _upper) private returns (uint)  {\n', '        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));\n', '        return seed % _upper;\n', '    }\n', '\n', '    // A user tries to claim a tile that&#39;s already owned by another user. A battle ensues.\n', '    // A random roll is done with % based on attacking vs defending amounts.\n', '    function attackTile(address _msgSender, uint16 _tileId, uint _attackAmount, bool _useBattleValue) public isValidCaller {\n', '        require(_attackAmount >= 1 finney);         // Don&#39;t allow attacking with less than one base tile price.\n', '        require(_attackAmount % 1 finney == 0);\n', '\n', '        address claimer;\n', '        uint blockValue;\n', '        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n', '        \n', '        require(claimer != 0); // Can&#39;t do this on never-owned tiles\n', '        require(claimer != _msgSender); // Can&#39;t attack one&#39;s own tiles\n', '        require(claimer != owner); // Can&#39;t attack owner&#39;s tiles because it is used for raffle.\n', '\n', '        // Calculate boosted amounts for attacker and defender\n', '        // The base attack amount is sent in the by the user.\n', '        // The base defend amount is the attacked tile&#39;s current blockValue.\n', '        uint attackBoost;\n', '        uint defendBoost;\n', '        (attackBoost, defendBoost) = bwData.calculateBattleBoost(_tileId, _msgSender, claimer);\n', '\n', '        // Adjust boost to optimize game strategy\n', '        attackBoost = attackBoost.mul(ATTACK_BOOST_MULTIPLIER).div(100);\n', '        defendBoost = defendBoost.mul(DEFEND_BOOST_MULTIPLIER).div(100);\n', '        \n', '        // Cap the boost to minimize its impact (prevents whales somehow)\n', '        if (attackBoost > _attackAmount.mul(ATTACK_BOOST_CAP).div(100)) {\n', '            attackBoost = _attackAmount.mul(ATTACK_BOOST_CAP).div(100);\n', '        }\n', '        if (defendBoost > blockValue.mul(DEFEND_BOOST_CAP).div(100)) {\n', '            defendBoost = blockValue.mul(DEFEND_BOOST_CAP).div(100);\n', '        }\n', '\n', '        uint totalAttackAmount = _attackAmount.add(attackBoost);\n', '        uint totalDefendAmount = blockValue.add(defendBoost);\n', '\n', '        // Verify that attack odds are within allowed range.\n', '        require(totalAttackAmount.div(10) <= totalDefendAmount); // Disallow attacks with more than 1000% of defendAmount\n', '        require(totalAttackAmount >= totalDefendAmount.div(10)); // Disallow attacks with less than 10% of defendAmount\n', '\n', '        uint attackFeeAmount = _attackAmount.mul(ATTACK_FEE).div(100);\n', '        uint attackAmountAfterFee = _attackAmount.sub(attackFeeAmount);\n', '        \n', '        updateFeeBalance(attackFeeAmount);\n', '\n', '        // The battle considers boosts.\n', '        uint attackRoll = random(totalAttackAmount.add(totalDefendAmount)); // This is where the excitement happens!\n', '\n', '        //gas cost of attack branch is higher than denfense branch solving MSB1\n', '        if (attackRoll > totalDefendAmount) {\n', '            // Change block owner but keep same block value (attacker got battlevalue instead)\n', '            bwData.setClaimerForTile(_tileId, _msgSender);\n', '\n', '            // Tile successfully attacked!\n', '            if (_useBattleValue) {\n', '                // Withdraw followed by deposit of same amount to prevent MSB1\n', '                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don&#39;t include boost here!\n', '                subUserBattleValue(_msgSender, attackAmountAfterFee, false);\n', '            } else {\n', '                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don&#39;t include boost here!\n', '            }\n', '            addUserBattleValue(claimer, 0);\n', '\n', '            bwData.updateTileTimeStamp(_tileId);\n', '            // Send update event\n', '            emit TileAttackedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n', '        } else {\n', '            bwData.setClaimerForTile(_tileId, claimer); //should be old owner\n', '            // Tile successfully defended!\n', '            if (_useBattleValue) {\n', '                subUserBattleValue(_msgSender, attackAmountAfterFee, false); // Don&#39;t include boost here!\n', '            }\n', '            addUserBattleValue(claimer, attackAmountAfterFee); // Don&#39;t include boost here!\n', '            \n', '            // Send update event\n', '            emit TileDefendedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n', '        }\n', '    }\n', '\n', '    function updateFeeBalance(uint attackFeeAmount) private {\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(attackFeeAmount);\n', '        bwData.setFeeBalance(feeBalance);\n', '    }\n', '\n', '    function moveBlockValue(address _msgSender, uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isValidCaller {\n', '        uint16 sourceTileId = BWUtility.toTileId(_xSource, _ySource);\n', '        uint16 destTileId = BWUtility.toTileId(_xDest, _yDest);\n', '\n', '        address sourceTileClaimer;\n', '        address destTileClaimer;\n', '        uint sourceTileBlockValue;\n', '        uint destTileBlockValue;\n', '        (sourceTileClaimer, sourceTileBlockValue) = bwData.getTileClaimerAndBlockValue(sourceTileId);\n', '        (destTileClaimer, destTileBlockValue) = bwData.getTileClaimerAndBlockValue(destTileId);\n', '\n', '        uint newBlockValue = sourceTileBlockValue.sub(_moveAmount);\n', '        // Must transfer the entire block value or leave at least 5\n', '        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n', '\n', '        require(sourceTileClaimer == _msgSender);\n', '        require(destTileClaimer == _msgSender);\n', '        require(_moveAmount >= 1 finney); // Can&#39;t be less\n', '        require(_moveAmount % 1 finney == 0); // Move amount must be in multiples of 1 finney\n', '        // require(sourceTile.blockValue - _moveAmount >= BASE_TILE_PRICE_WEI); // Must always leave some at source\n', '        \n', '        require(BWUtility.isAdjacent(_xSource, _ySource, _xDest, _yDest));\n', '\n', '        sourceTileBlockValue = sourceTileBlockValue.sub(_moveAmount);\n', '        destTileBlockValue = destTileBlockValue.add(_moveAmount);\n', '\n', '        // If ALL block value was moved away from the source tile, we lose our claim to it. It becomes ownerless.\n', '        if (sourceTileBlockValue == 0) {\n', '            bwData.deleteTile(sourceTileId);\n', '        } else {\n', '            bwData.updateTileBlockValue(sourceTileId, sourceTileBlockValue);\n', '            bwData.deleteOffer(sourceTileId); // Offer invalid since block value has changed\n', '        }\n', '\n', '        bwData.updateTileBlockValue(destTileId, destTileBlockValue);\n', '        bwData.deleteOffer(destTileId);   // Offer invalid since block value has changed\n', '        emit BlockValueMoved(sourceTileId, destTileId, _msgSender, _moveAmount, sourceTileBlockValue, destTileBlockValue, block.timestamp);        \n', '    }\n', '\n', '    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n', '        if (_useBattleValue) {\n', '            require(_msgValue == 0);\n', '            require(bwData.getUserBattleValue(_msgSender) >= _amount);\n', '        } else {\n', '            require(_amount == _msgValue);\n', '        }\n', '    }\n', '\n', '    function setLocalGame(uint16 _tileId, address localGameAddress) public isOwner {\n', '        localGames[_tileId] = localGameAddress;\n', '    }\n', '\n', '    function getLocalGame(uint16 _tileId) view public isValidCaller returns (address) {\n', '        return localGames[_tileId];\n', '    }\n', '\n', '    // BATTLE VALUE FUNCTIONS\n', '    function withdrawBattleValue(address msgSender, uint _battleValueInWei) public isValidCaller returns (uint) {\n', '        //require(_battleValueInWei % 1 finney == 0); // Must be divisible by 1 finney\n', '        uint fee = _battleValueInWei.mul(WITHDRAW_FEE).div(100); // Since we divide by 20 we can never create infinite fractions, so we&#39;ll always count in whole wei amounts.\n', '        uint amountToWithdraw = _battleValueInWei.sub(fee);\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(fee);\n', '        bwData.setFeeBalance(feeBalance);\n', '        subUserBattleValue(msgSender, _battleValueInWei, true);\n', '        return amountToWithdraw;\n', '    }\n', '\n', '    function addUserBattleValue(address _userId, uint _amount) public isValidCaller {\n', '        uint userBattleValue = bwData.getUserBattleValue(_userId);\n', '        uint newBattleValue = userBattleValue.add(_amount);\n', '        bwData.setUserBattleValue(_userId, newBattleValue); // Don&#39;t include boost here!\n', '        emit UserBattleValueUpdated(_userId, newBattleValue, false);\n', '    }\n', '    \n', '    function subUserBattleValue(address _userId, uint _amount, bool _isWithdraw) public isValidCaller {\n', '        uint userBattleValue = bwData.getUserBattleValue(_userId);\n', '        require(_amount <= userBattleValue); // Must be less than user&#39;s battle value - also implicitly checks that underflow isn&#39;t possible\n', '        uint newBattleValue = userBattleValue.sub(_amount);\n', '        bwData.setUserBattleValue(_userId, newBattleValue); // Don&#39;t include boost here!\n', '        emit UserBattleValueUpdated(_userId, newBattleValue, _isWithdraw);\n', '    }\n', '\n', '    function addGlobalBlockValueBalance(uint _amount) public isValidCaller {\n', '        // Track addition to global block value.\n', '        uint blockValueBalance = bwData.getBlockValueBalance();\n', '        bwData.setBlockValueBalance(blockValueBalance.add(_amount));\n', '    }\n', '\n', '    function subGlobalBlockValueBalance(uint _amount) public isValidCaller {\n', '        // Track addition to global block value.\n', '        uint blockValueBalance = bwData.getBlockValueBalance();\n', '        bwData.setBlockValueBalance(blockValueBalance.sub(_amount));\n', '    }\n', '\n', '    // Allow us to transfer out airdropped tokens if we ever receive any\n', '    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n', '        ERC20I token = ERC20I(_tokenAddress);\n', '        require(token.transfer(_recipient, token.balanceOf(this)));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract BWData {\n', '    address public owner;\n', '    address private bwService;\n', '    address private bw;\n', '    address private bwMarket;\n', '\n', '    uint private blockValueBalance = 0;\n', '    uint private feeBalance = 0;\n', '    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.\n', '    \n', '    mapping (address => User) private users; // user address -> user information\n', '    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile\n', '    \n', '    // Info about the users = those who have purchased tiles.\n', '    struct User {\n', '        uint creationTime;\n', '        bool censored;\n', '        uint battleValue;\n', '    }\n', '\n', '    // Info about a tile ownership\n', '    struct Tile {\n', '        address claimer;\n', '        uint blockValue;\n', '        uint creationTime;\n', '        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.\n', '    }\n', '\n', '    struct Boost {\n', '        uint8 numAttackBoosts;\n', '        uint8 numDefendBoosts;\n', '        uint attackBoost;\n', '        uint defendBoost;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Can&#39;t send funds straight to this contract. Avoid people sending by mistake.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    modifier isValidCaller {\n', '        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function setBwServiceValidCaller(address _bwService) public isOwner {\n', '        bwService = _bwService;\n', '    }\n', '\n', '    function setBwValidCaller(address _bw) public isOwner {\n', '        bw = _bw;\n', '    }\n', '\n', '    function setBwMarketValidCaller(address _bwMarket) public isOwner {\n', '        bwMarket = _bwMarket;\n', '    }    \n', '    \n', '    // ----------USER-RELATED GETTER FUNCTIONS------------\n', '    \n', '    //function getUser(address _user) view public returns (bytes32) {\n', '        //BWUtility.User memory user = users[_user];\n', '        //require(user.creationTime != 0);\n', '        //return (user.creationTime, user.imageUrl, user.tag, user.email, user.homeUrl, user.creationTime, user.censored, user.battleValue);\n', '    //}\n', '    \n', '    function addUser(address _msgSender) public isValidCaller {\n', '        User storage user = users[_msgSender];\n', '        require(user.creationTime == 0);\n', '        user.creationTime = block.timestamp;\n', '    }\n', '\n', '    function hasUser(address _user) view public isValidCaller returns (bool) {\n', '        return users[_user].creationTime != 0;\n', '    }\n', '    \n', '\n', '    // ----------TILE-RELATED GETTER FUNCTIONS------------\n', '\n', '    function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);\n', '    }\n', '    \n', '    function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return (currentTile.claimer, currentTile.blockValue);\n', '    }\n', '    \n', '    function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return currentTile.creationTime == 0;\n', '    }\n', '    \n', '    function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {\n', '        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);\n', '    }\n', '\n', '    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {\n', '        tiles[_tileId].blockValue = _blockValue;\n', '    }\n', '\n', '    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {\n', '        tiles[_tileId].claimer = _claimer;\n', '    }\n', '\n', '    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {\n', '        tiles[_tileId].creationTime = block.timestamp;\n', '    }\n', '    \n', '    function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        if (currentTile.creationTime == 0) {\n', '            return 0;\n', '        }\n', '        return currentTile.claimer;\n', '    }\n', '\n', '    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        if (currentTile.creationTime == 0) {\n', '            return (0, 0);\n', '        }\n', '        return (currentTile.blockValue, currentTile.sellPrice);\n', '    }\n', '    \n', '    function getBlockValueBalance() view public isValidCaller returns (uint){\n', '        return blockValueBalance;\n', '    }\n', '\n', '    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {\n', '        blockValueBalance = _blockValueBalance;\n', '    }\n', '\n', '    function getFeeBalance() view public isValidCaller returns (uint) {\n', '        return feeBalance;\n', '    }\n', '\n', '    function setFeeBalance(uint _feeBalance) public isValidCaller {\n', '        feeBalance = _feeBalance;\n', '    }\n', '    \n', '    function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {\n', '        return users[_userId].battleValue;\n', '    }\n', '    \n', '    function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {\n', '        users[_userId].battleValue = _battleValue;\n', '    }\n', '    \n', '    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n', '        User storage user = users[_msgSender];\n', '        require(user.creationTime != 0);\n', '\n', '        if (_useBattleValue) {\n', '            require(_msgValue == 0);\n', '            require(user.battleValue >= _amount);\n', '        } else {\n', '            require(_amount == _msgValue);\n', '        }\n', '    }\n', '    \n', '    function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {\n', '        if (_tile.claimer == _attacker) {\n', '            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n', '            _boost.attackBoost += _tile.blockValue;\n', '            _boost.numAttackBoosts += 1;\n', '        } else if (_tile.claimer == _defender) {\n', '            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n', '            _boost.defendBoost += _tile.blockValue;\n', '            _boost.numDefendBoosts += 1;\n', '        }\n', '    }\n', '\n', '    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {\n', '        uint8 x;\n', '        uint8 y;\n', '\n', '        (x, y) = BWUtility.fromTileId(_tileId);\n', '\n', '        Boost memory boost = Boost(0, 0, 0, 0);\n', '        // We overflow x, y on purpose here if x or y is 0 or 255 - the map overflows and so should adjacency.\n', '        // Go through all adjacent tiles to (x, y).\n', '        if (y != 255) {\n', '            if (x != 255) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);\n', '            }\n', '            \n', '            addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);\n', '\n', '            if (x != 0) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);\n', '            }\n', '        }\n', '\n', '        if (x != 255) {\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);\n', '        }\n', '\n', '        if (x != 0) {\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);\n', '        }\n', '\n', '        if (y != 0) {\n', '            if(x != 255) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);\n', '            }\n', '\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);\n', '\n', '            if(x != 0) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);\n', '            }\n', '        }\n', '        // The benefit of boosts is multiplicative (quadratic):\n', '        // - More boost tiles gives a higher total blockValue (the sum of the adjacent tiles)\n', '        // - More boost tiles give a higher multiple of that total blockValue that can be used (10% per adjacent tie)\n', '        // Example:\n', '        //   A) I boost attack with 1 single tile worth 10 finney\n', '        //      -> Total boost is 10 * 1 / 10 = 1 finney\n', '        //   B) I boost attack with 3 tiles worth 1 finney each\n', '        //      -> Total boost is (1+1+1) * 3 / 10 = 0.9 finney\n', '        //   C) I boost attack with 8 tiles worth 2 finney each\n', '        //      -> Total boost is (2+2+2+2+2+2+2+2) * 8 / 10 = 14.4 finney\n', '        //   D) I boost attack with 3 tiles of 1, 5 and 10 finney respectively\n', '        //      -> Total boost is (ss1+5+10) * 3 / 10 = 4.8 finney\n', '        // This division by 10 can&#39;t create fractions since our uint is wei, and we can&#39;t have overflow from the multiplication\n', '        // We do allow fractions of finney here since the boosted values aren&#39;t stored anywhere, only used for attack rolls and sent in events\n', '        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);\n', '        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);\n', '\n', '        return (boost.attackBoost, boost.defendBoost);\n', '    }\n', '    \n', '    function censorUser(address _userAddress, bool _censored) public isValidCaller {\n', '        User storage user = users[_userAddress];\n', '        require(user.creationTime != 0);\n', '        user.censored = _censored;\n', '    }\n', '    \n', '    function deleteTile(uint16 _tileId) public isValidCaller {\n', '        delete tiles[_tileId];\n', '    }\n', '    \n', '    function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {\n', '        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.\n', '    }\n', '\n', '    function deleteOffer(uint16 _tileId) public isValidCaller {\n', '        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '* Copyright 2018 Block Wars Team\n', '*\n', '*/\n', '\n', 'interface LocalGameI {\n', '    function getBountyBalance() view external returns (uint);\n', '    function getTimeLeftToNextCollect(address _claimer, uint _latestClaimTime) view external returns (uint);\n', '    function collectBounty(address _msgSender, uint _latestClaimTime, uint _amount) external returns (uint);\n', '}\n', '\n', '/*\n', '* @title ERC721 interface\n', '*/\n', 'contract ERC721 {\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    //event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    //event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    //event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    //function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    //function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    //function approve(address _approved, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all of `msg.sender`&#39;s assets.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    //function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    //function getApproved(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    //function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    //function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract BW { \n', '    using SafeMath for uint256;\n', '    address public owner;\n', '    BWService private bwService;\n', '    BWData private bwData;\n', '    bool public paused = false;\n', '    uint private BV_TO_BP_FEE = 5; // 5%\n', '    mapping (uint16 => Prize[]) private prizes; // Use mapping instead of array (key would be a unique priceId) - NO (we want to loop all prices)\n', '    \n', '    struct Prize {\n', '        address token; // BWT or CryptoKiities (ERC721)\n', '        uint tokenId; \n', '        uint startTime; // To be able to add a price before the game starts\n', '        uint hodlPeriod; // Amount of seconds you have to own the tile before being able to claim this price. One block is ~15 sec.\n', '    }\n', '\n', '    event PrizeCreated(uint16 tileId,  address token, uint tokenId, uint creationTime, uint startTime, uint hodlPeriod);\n', '    event PrizeRemoved(uint16 tileId, address token, uint tokenId, uint removeTime);\n', '    event PrizeClaimed(address token, uint tokenId);\n', '\n', '    // Add price (only BW owner can do this)\n', '    function addPrize(uint16 _tileId, address _token, uint _tokenId, uint _startTime, uint _hodlPeriod) public isOwner {\n', '        //startTime must be same or after block.timestamp\n', '        uint startTime = _startTime;\n', '        if(startTime < block.timestamp) {\n', '            startTime = block.timestamp;\n', '        }\n', '        // we could check if token exists with ownerOf function in interface, \n', '        // but if any erc721 token doesn&#39;t implement the function, this function would revert.\n', '        // also cheaper to not make an interface call\n', '        prizes[_tileId].push(Prize(_token, _tokenId, startTime, _hodlPeriod));\n', '        emit PrizeCreated(_tileId, _token, _tokenId, block.timestamp, startTime, _hodlPeriod);\n', '    }\n', '\n', '    // Remove price (only BW owner can do this)\n', '    function removePrize(uint16 _tileId, address _token, uint _tokenId) public isOwner {\n', '        Prize[] storage prizeArr = prizes[_tileId];\n', '        require(prizeArr.length > 0);\n', '\n', '        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n', '            if(prizeArr[idx].tokenId == _tokenId && prizeArr[idx].token == _token) {\n', '                delete prizeArr[idx];\n', '                emit PrizeRemoved(_tileId, _token, _tokenId, block.timestamp);\n', '            }\n', '        }\n', '    }\n', '\n', '    // Add price (only BW owner can do this)\n', '    function claimPrize(address _tokenAddress, uint16 _tileId) public isNotPaused isNotContractCaller {\n', '        ERC721 token = ERC721(_tokenAddress);\n', '        Prize[] storage prizeArr = prizes[_tileId];\n', '        require(prizeArr.length > 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint lastClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, lastClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        require(lastClaimTime != 0 && claimer == msg.sender);\n', '\n', '        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n', '            if(prizeArr[idx].startTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp\n', '                && lastClaimTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp) {\n', '                uint tokenId = prizeArr[idx].tokenId;\n', '                address tokenOwner = token.ownerOf(tokenId);\n', '                delete prizeArr[idx];\n', '                token.safeTransferFrom(tokenOwner, msg.sender, tokenId); //Will revert if token does not exists\n', '                emit PrizeClaimed(_tokenAddress, tokenId);\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Checks if entire game (except battle value withdraw) is paused or not.\n', '    modifier isNotPaused {\n', '        if (paused) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Only allow wallets to call this function, not contracts.\n', '    modifier isNotContractCaller {\n', '        require(msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    // All contract event types.\n', '    event UserCreated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint creationTime, address invitedBy);\n', '    event UserCensored(address userAddress, bool isCensored);\n', '    event TransferTileFromOwner(uint16 tileId, address seller, address buyer, uint acceptTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n', '    event UserUpdated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint updateTime);\n', '    event TileRetreated(uint16 tileId, address owner, uint amount, uint newBlockValue, uint retreatTime);\n', '    event BountyCollected(uint tile, address userAddress, uint amount, uint amountCollected, uint collectedTime, uint latestClaimTime);\n', '\n', '    // BASIC CONTRACT FUNCTIONS\n', '    constructor(address _bwService, address _bwData) public {\n', '        bwService = BWService(_bwService);\n', '        bwData = BWData(_bwData);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Can&#39;t send funds straight to this contract. Avoid people sending by mistake.\n', '    function () payable public isOwner {\n', '\n', '    }\n', '\n', '    // Allow a new user to claim one or more previously unclaimed tiles by paying Ether.\n', '    function claimTilesForNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, uint16[] _claimedTileIds, address _invitedBy) payable public isNotPaused isNotContractCaller {\n', '        bwData.addUser(msg.sender);\n', '        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n', '        bwService.storeInitialClaim(msg.sender, _claimedTileIds, msg.value, false);\n', '    }\n', '\n', '    // Allow an existing user to claim one or more previously unclaimed tiles by paying Ether.\n', '    function claimTilesForExistingUser(uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _claimAmount, _useBattleValue);\n', '        bwService.storeInitialClaim(msg.sender, _claimedTileIds, _claimAmount, _useBattleValue);\n', '    }\n', '\n', '    // Allow users to change name, image URL, tag and home URL. Not censored status or battle value though.\n', '    function updateUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl) public isNotPaused isNotContractCaller {\n', '        require(bwData.hasUser(msg.sender));\n', '        // All the updated values are stored in events only so there&#39;s no state to update on the contract here.\n', '        emit UserUpdated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp);\n', '    }\n', '    \n', '    // This function fortifies multiple previously claimed tiles in a single transaction.\n', '    // The value assigned to each tile is the msg.value divided by the number of tiles fortified.\n', '    // The msg.value is required to be an even multiple of the number of tiles fortified.\n', '    // Only tiles owned by msg.sender can be fortified.\n', '    function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue);\n', '        bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue);\n', '    }\n', '\n', '    // A new user attacks a tile claimed by someone else, trying to make it theirs through battle.\n', '    function attackTileForNewUser(uint16 _tileId, bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _invitedBy) payable public isNotPaused isNotContractCaller {\n', '        bwData.addUser(msg.sender);\n', '        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n', '        bwService.attackTile(msg.sender, _tileId, msg.value, false);\n', '    }\n', '\n', '    // An existing user attacks a tile claimed by someone else, trying to make it theirs through battle.\n', '    function attackTileForExistingUser(uint16 _tileId, uint _attackAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _attackAmount, _useBattleValue);\n', '        bwService.attackTile(msg.sender, _tileId, _attackAmount, _useBattleValue);\n', '    }\n', '    \n', '    // Move "army" = block value from one block to an adjacent block. Moving ALL value equates giving up ownership of the source tile.\n', '    function moveBlockValue(uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isNotPaused isNotContractCaller {\n', '        require(_moveAmount > 0);\n', '        bwService.moveBlockValue(msg.sender, _xSource, _ySource, _xDest, _yDest, _moveAmount);\n', '    }\n', '\n', '    // Allow users to withdraw battle value in Ether.\n', '    function withdrawBattleValue(uint _battleValueInWei) public isNotContractCaller {\n', '        require(_battleValueInWei > 0);\n', '        uint amountToWithdraw = bwService.withdrawBattleValue(msg.sender, _battleValueInWei);\n', '        msg.sender.transfer(amountToWithdraw);\n', '    }\n', '\n', '    // Transfer block value to battle points for free \n', '    function transferBlockValueToBattleValue(uint16 _tileId, uint _amount) public isNotContractCaller {\n', '        require(_amount > 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n', '        require(claimer == msg.sender);\n', '        uint newBlockValue = blockValue.sub(_amount);\n', '        // Must transfer the entire block value or leave at least 5\n', '        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n', '        if(newBlockValue == 0) {\n', '            bwData.deleteTile(_tileId);\n', '        } else {\n', '            bwData.updateTileBlockValue(_tileId, newBlockValue);\n', '            bwData.deleteOffer(_tileId); // Offer invalid since block value has changed\n', '        }\n', '        \n', '        uint fee = _amount.mul(BV_TO_BP_FEE).div(100);\n', '        uint userAmount = _amount.sub(fee);\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(fee);\n', '        bwData.setFeeBalance(feeBalance);\n', '\n', '        bwService.addUserBattleValue(msg.sender, userAmount);\n', '        bwService.subGlobalBlockValueBalance(_amount);\n', '        emit TileRetreated(_tileId, msg.sender, _amount, newBlockValue, block.timestamp);\n', '    }\n', '\n', '    // -------- LOCAL GAME FUNCTIONS ----------\n', '\n', '    function getLocalBountyBalance(uint16 _tileId) view public isNotContractCaller returns (uint) {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        return localGame.getBountyBalance();\n', '    }\n', '\n', '    function getTimeLeftToNextLocalBountyCollect(uint16 _tileId) view public isNotContractCaller returns (uint) {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint latestClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        return localGame.getTimeLeftToNextCollect(claimer, latestClaimTime);\n', '    }\n', '\n', '    function collectLocalBounty(uint16 _tileId, uint _amount) public isNotContractCaller {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint latestClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        require(latestClaimTime != 0 && claimer == msg.sender);\n', '        \n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        uint amountCollected = localGame.collectBounty(msg.sender, latestClaimTime, _amount);\n', '        emit BountyCollected(_tileId, msg.sender, _amount, amountCollected, block.timestamp, latestClaimTime);\n', '    }\n', '\n', '    // -------- OWNER-ONLY FUNCTIONS ----------\n', '\n', '    // Only used by owner for raffle. Owner need name, address and picture from user.\n', '    // These users can then be given tiles by owner using transferTileFromOwner.\n', '    function createNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _user) public isOwner {\n', '        bwData.addUser(_user);\n', '        emit UserCreated(_user, _name, _imageUrl, _tag, _homeUrl, block.timestamp, msg.sender); //check on client if invitedBy is owner.\n', '    }\n', '\n', '    // Allow updating censored status. Owner only. In case someone uploads offensive content.\n', '    // The contract owners reserve the right to apply censorship. This will mean that the\n', '    // name, tag or URL images might not be displayed for a censored user.\n', '    function censorUser(address _userAddress, bool _censored) public isOwner {\n', '        bwData.censorUser(_userAddress, _censored);\n', '        emit UserCensored(_userAddress, _censored);\n', '    }\n', '\n', '    // Pause the entire game, but let users keep withdrawing battle value\n', '    function setPaused(bool _paused) public isOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function withdrawFee() public isOwner {\n', '        uint balance = address(this).balance;\n', '        uint amountToWithdraw = bwData.getFeeBalance();\n', '\n', '        if (balance < amountToWithdraw) { // Should never happen, but paranoia\n', '            amountToWithdraw = balance;\n', '        }\n', '        bwData.setFeeBalance(0);\n', '\n', '        owner.transfer(amountToWithdraw);\n', '    }\n', '\n', '    function getFee() view public isOwner returns (uint) {\n', '        return bwData.getFeeBalance();\n', '    }\n', '\n', '    function setBvToBpFee(uint _feePercentage) public isOwner {\n', '        BV_TO_BP_FEE = _feePercentage;\n', '    }\n', '\n', '    function depositBattleValue(address _user) payable public isOwner {\n', '        require(msg.value % 1 finney == 0); // Must be divisible by 1 finney\n', '        bwService.addUserBattleValue(_user, msg.value);\n', '    }\n', '\n', '    // The owner can transfer ownership of own tiles to other users, as prizes in competitions.\n', '    function transferTileFromOwner(uint16[] _tileIds, address _newOwner) public isOwner {\n', '        for(uint i = 0; i < _tileIds.length; ++i) {\n', '            uint16 tileId = _tileIds[i];\n', '            address claimer = bwData.getCurrentClaimerForTile(tileId);\n', '            require(claimer == owner);\n', '            bwData.setClaimerForTile(tileId, _newOwner);\n', '            \n', '            emit TransferTileFromOwner(tileId, _newOwner, msg.sender, block.timestamp);\n', '        }\n', '    }\n', '\n', '    // Allow us to transfer out airdropped tokens if we ever receive any\n', '    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n', '        ERC20I token = ERC20I(_tokenAddress);\n', '        require(token.transfer(_recipient, token.balanceOf(this)));\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'library BWUtility {\n', '    \n', '    // -------- UTILITY FUNCTIONS ----------\n', '\n', '\n', '    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\n', '    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\n', '        return ((_amount + _multiple - 1) / _multiple) * _multiple;\n', '    }\n', '\n', '    // Checks if two coordinates are adjacent:\n', '    // xxx\n', '    // xox\n', '    // xxx\n', '    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \n', '    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\n', '    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\n', '        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\n', '               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\n', '               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\n', '               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\n', '    }\n', '\n', '    // Converts (x, y) to tileId xy\n', '    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\n', '        return uint16(_x) << 8 | uint16(_y);\n', '    }\n', '\n', '    // Converts _tileId to (x, y)\n', '    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\n', '        uint8 y = uint8(_tileId);\n', '        uint8 x = uint8(_tileId >> 8);\n', '        return (x, y);\n', '    }\n', '    \n', '    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\n', '        if (_claimer == _attacker) {\n', '            return (_blockValue, 0);\n', '        } else if (_claimer == _defender) {\n', '            return (0, _blockValue);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface ERC20I {\n', '    function transfer(address _recipient, uint256 _amount) external returns (bool);\n', '    function balanceOf(address _holder) external view returns (uint256);\n', '}\n', '\n', '\n', 'contract BWService {\n', '    using SafeMath for uint256;\n', '    address private owner;\n', '    address private bw;\n', '    address private bwMarket;\n', '    BWData private bwData;\n', '    uint private seed = 42;\n', '    uint private WITHDRAW_FEE = 5; // 5%\n', '    uint private ATTACK_FEE = 5; // 5%\n', '    uint private ATTACK_BOOST_CAP = 300; // 300%\n', '    uint private DEFEND_BOOST_CAP = 300; // 300%\n', '    uint private ATTACK_BOOST_MULTIPLIER = 100; // 100%\n', '    uint private DEFEND_BOOST_MULTIPLIER = 100; // 100%\n', '    mapping (uint16 => address) private localGames;\n', '    \n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }  \n', '\n', '    modifier isValidCaller {\n', '        if (msg.sender != bw && msg.sender != bwMarket) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    event TileClaimed(uint16 tileId, address newClaimer, uint priceInWei, uint creationTime);\n', '    event TileFortified(uint16 tileId, address claimer, uint addedValueInWei, uint priceInWei, uint fortifyTime); // Sent when a user fortifies an existing claim by bumping its value.\n', '    event TileAttackedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint attackTime); // Sent when a user successfully attacks a tile.    \n', '    event TileDefendedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint defendTime); // Sent when a user successfully defends a tile when attacked.    \n', '    event BlockValueMoved(uint16 sourceTileId, uint16 destTileId, address owner, uint movedBlockValue, uint postSourceValue, uint postDestValue, uint moveTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n', '    event UserBattleValueUpdated(address userAddress, uint battleValue, bool isWithdraw);\n', '\n', '    // Constructor.\n', '    constructor(address _bwData) public {\n', '        bwData = BWData(_bwData);\n', '        owner = msg.sender;\n', '    }\n', '\n', "    // Can't send funds straight to this contract. Avoid people sending by mistake.\n", '    function () payable public {\n', '        revert();\n', '    }\n', '\n', '    // OWNER-ONLY FUNCTIONS\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function setValidBwCaller(address _bw) public isOwner {\n', '        bw = _bw;\n', '    }\n', '    \n', '    function setValidBwMarketCaller(address _bwMarket) public isOwner {\n', '        bwMarket = _bwMarket;\n', '    }\n', '\n', '    function setWithdrawFee(uint _feePercentage) public isOwner {\n', '        WITHDRAW_FEE = _feePercentage;\n', '    }\n', '\n', '    function setAttackFee(uint _feePercentage) public isOwner {\n', '        ATTACK_FEE = _feePercentage;\n', '    }\n', '\n', '    function setAttackBoostMultipler(uint _multiplierPercentage) public isOwner {\n', '        ATTACK_BOOST_MULTIPLIER = _multiplierPercentage;\n', '    }\n', '\n', '    function setDefendBoostMultiplier(uint _multiplierPercentage) public isOwner {\n', '        DEFEND_BOOST_MULTIPLIER = _multiplierPercentage;\n', '    }\n', '\n', '    function setAttackBoostCap(uint _capPercentage) public isOwner {\n', '        ATTACK_BOOST_CAP = _capPercentage;\n', '    }\n', '\n', '    function setDefendBoostCap(uint _capPercentage) public isOwner {\n', '        DEFEND_BOOST_CAP = _capPercentage;\n', '    }\n', '\n', '    // TILE-RELATED FUNCTIONS\n', '    // This function claims multiple previously unclaimed tiles in a single transaction.\n', '    // The value assigned to each tile is the msg.value divided by the number of tiles claimed.\n', '    // The msg.value is required to be an even multiple of the number of tiles claimed.\n', '    function storeInitialClaim(address _msgSender, uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) public isValidCaller {\n', '        uint tileCount = _claimedTileIds.length;\n', '        require(tileCount > 0);\n', '        require(_claimAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n', '        require(_claimAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles claimed\n', '\n', '        uint valuePerBlockInWei = _claimAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n', '        require(valuePerBlockInWei >= 5 finney);\n', '\n', '        if (_useBattleValue) {\n', '            subUserBattleValue(_msgSender, _claimAmount, false);  \n', '        }\n', '\n', '        addGlobalBlockValueBalance(_claimAmount);\n', '\n', '        uint16 tileId;\n', '        bool isNewTile;\n', '        for (uint16 i = 0; i < tileCount; i++) {\n', '            tileId = _claimedTileIds[i];\n', '            isNewTile = bwData.isNewTile(tileId); // Is length 0 if first time purchased\n', '            require(isNewTile); // Can only claim previously unclaimed tiles.\n', '\n', '            // Send claim event\n', '            emit TileClaimed(tileId, _msgSender, valuePerBlockInWei, block.timestamp);\n', '\n', '            // Update contract state with new tile ownership.\n', '            bwData.storeClaim(tileId, _msgSender, valuePerBlockInWei);\n', '        }\n', '    }\n', '\n', '    function fortifyClaims(address _msgSender, uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) public isValidCaller {\n', '        uint tileCount = _claimedTileIds.length;\n', '        require(tileCount > 0);\n', '\n', '        address(this).balance.add(_fortifyAmount); // prevent overflow with SafeMath\n', '        require(_fortifyAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles fortified\n', '        uint addedValuePerTileInWei = _fortifyAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n', '        require(_fortifyAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n', '\n', '        address claimer;\n', '        uint blockValue;\n', '        for (uint16 i = 0; i < tileCount; i++) {\n', '            (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_claimedTileIds[i]);\n', "            require(claimer != 0); // Can't do this on never-owned tiles\n", '            require(claimer == _msgSender); // Only current claimer can fortify claim\n', '\n', '            if (_useBattleValue) {\n', '                subUserBattleValue(_msgSender, addedValuePerTileInWei, false);\n', '            }\n', '            \n', '            fortifyClaim(_msgSender, _claimedTileIds[i], addedValuePerTileInWei);\n', '        }\n', '    }\n', '\n', '    function fortifyClaim(address _msgSender, uint16 _claimedTileId, uint _fortifyAmount) private {\n', '        uint blockValue;\n', '        uint sellPrice;\n', '        (blockValue, sellPrice) = bwData.getCurrentBlockValueAndSellPriceForTile(_claimedTileId);\n', '        uint updatedBlockValue = blockValue.add(_fortifyAmount);\n', '        // Send fortify event\n', '        emit TileFortified(_claimedTileId, _msgSender, _fortifyAmount, updatedBlockValue, block.timestamp);\n', '        \n', '        // Update tile value. The tile has been fortified by bumping up its value.\n', '        bwData.updateTileBlockValue(_claimedTileId, updatedBlockValue);\n', '\n', '        // Track addition to global block value\n', '        addGlobalBlockValueBalance(_fortifyAmount);\n', '    }\n', '\n', '    // Return a pseudo random number between lower and upper bounds\n', '    // given the number of previous blocks it should hash.\n', '    // Random function copied from https://github.com/axiomzen/eth-random/blob/master/contracts/Random.sol.\n', '    // Changed sha3 to keccak256, then modified.\n', '    // Changed random range from uint64 to uint (=uint256).\n', '    function random(uint _upper) private returns (uint)  {\n', '        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));\n', '        return seed % _upper;\n', '    }\n', '\n', "    // A user tries to claim a tile that's already owned by another user. A battle ensues.\n", '    // A random roll is done with % based on attacking vs defending amounts.\n', '    function attackTile(address _msgSender, uint16 _tileId, uint _attackAmount, bool _useBattleValue) public isValidCaller {\n', "        require(_attackAmount >= 1 finney);         // Don't allow attacking with less than one base tile price.\n", '        require(_attackAmount % 1 finney == 0);\n', '\n', '        address claimer;\n', '        uint blockValue;\n', '        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n', '        \n', "        require(claimer != 0); // Can't do this on never-owned tiles\n", "        require(claimer != _msgSender); // Can't attack one's own tiles\n", "        require(claimer != owner); // Can't attack owner's tiles because it is used for raffle.\n", '\n', '        // Calculate boosted amounts for attacker and defender\n', '        // The base attack amount is sent in the by the user.\n', "        // The base defend amount is the attacked tile's current blockValue.\n", '        uint attackBoost;\n', '        uint defendBoost;\n', '        (attackBoost, defendBoost) = bwData.calculateBattleBoost(_tileId, _msgSender, claimer);\n', '\n', '        // Adjust boost to optimize game strategy\n', '        attackBoost = attackBoost.mul(ATTACK_BOOST_MULTIPLIER).div(100);\n', '        defendBoost = defendBoost.mul(DEFEND_BOOST_MULTIPLIER).div(100);\n', '        \n', '        // Cap the boost to minimize its impact (prevents whales somehow)\n', '        if (attackBoost > _attackAmount.mul(ATTACK_BOOST_CAP).div(100)) {\n', '            attackBoost = _attackAmount.mul(ATTACK_BOOST_CAP).div(100);\n', '        }\n', '        if (defendBoost > blockValue.mul(DEFEND_BOOST_CAP).div(100)) {\n', '            defendBoost = blockValue.mul(DEFEND_BOOST_CAP).div(100);\n', '        }\n', '\n', '        uint totalAttackAmount = _attackAmount.add(attackBoost);\n', '        uint totalDefendAmount = blockValue.add(defendBoost);\n', '\n', '        // Verify that attack odds are within allowed range.\n', '        require(totalAttackAmount.div(10) <= totalDefendAmount); // Disallow attacks with more than 1000% of defendAmount\n', '        require(totalAttackAmount >= totalDefendAmount.div(10)); // Disallow attacks with less than 10% of defendAmount\n', '\n', '        uint attackFeeAmount = _attackAmount.mul(ATTACK_FEE).div(100);\n', '        uint attackAmountAfterFee = _attackAmount.sub(attackFeeAmount);\n', '        \n', '        updateFeeBalance(attackFeeAmount);\n', '\n', '        // The battle considers boosts.\n', '        uint attackRoll = random(totalAttackAmount.add(totalDefendAmount)); // This is where the excitement happens!\n', '\n', '        //gas cost of attack branch is higher than denfense branch solving MSB1\n', '        if (attackRoll > totalDefendAmount) {\n', '            // Change block owner but keep same block value (attacker got battlevalue instead)\n', '            bwData.setClaimerForTile(_tileId, _msgSender);\n', '\n', '            // Tile successfully attacked!\n', '            if (_useBattleValue) {\n', '                // Withdraw followed by deposit of same amount to prevent MSB1\n', "                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\n", '                subUserBattleValue(_msgSender, attackAmountAfterFee, false);\n', '            } else {\n', "                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\n", '            }\n', '            addUserBattleValue(claimer, 0);\n', '\n', '            bwData.updateTileTimeStamp(_tileId);\n', '            // Send update event\n', '            emit TileAttackedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n', '        } else {\n', '            bwData.setClaimerForTile(_tileId, claimer); //should be old owner\n', '            // Tile successfully defended!\n', '            if (_useBattleValue) {\n', "                subUserBattleValue(_msgSender, attackAmountAfterFee, false); // Don't include boost here!\n", '            }\n', "            addUserBattleValue(claimer, attackAmountAfterFee); // Don't include boost here!\n", '            \n', '            // Send update event\n', '            emit TileDefendedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n', '        }\n', '    }\n', '\n', '    function updateFeeBalance(uint attackFeeAmount) private {\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(attackFeeAmount);\n', '        bwData.setFeeBalance(feeBalance);\n', '    }\n', '\n', '    function moveBlockValue(address _msgSender, uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isValidCaller {\n', '        uint16 sourceTileId = BWUtility.toTileId(_xSource, _ySource);\n', '        uint16 destTileId = BWUtility.toTileId(_xDest, _yDest);\n', '\n', '        address sourceTileClaimer;\n', '        address destTileClaimer;\n', '        uint sourceTileBlockValue;\n', '        uint destTileBlockValue;\n', '        (sourceTileClaimer, sourceTileBlockValue) = bwData.getTileClaimerAndBlockValue(sourceTileId);\n', '        (destTileClaimer, destTileBlockValue) = bwData.getTileClaimerAndBlockValue(destTileId);\n', '\n', '        uint newBlockValue = sourceTileBlockValue.sub(_moveAmount);\n', '        // Must transfer the entire block value or leave at least 5\n', '        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n', '\n', '        require(sourceTileClaimer == _msgSender);\n', '        require(destTileClaimer == _msgSender);\n', "        require(_moveAmount >= 1 finney); // Can't be less\n", '        require(_moveAmount % 1 finney == 0); // Move amount must be in multiples of 1 finney\n', '        // require(sourceTile.blockValue - _moveAmount >= BASE_TILE_PRICE_WEI); // Must always leave some at source\n', '        \n', '        require(BWUtility.isAdjacent(_xSource, _ySource, _xDest, _yDest));\n', '\n', '        sourceTileBlockValue = sourceTileBlockValue.sub(_moveAmount);\n', '        destTileBlockValue = destTileBlockValue.add(_moveAmount);\n', '\n', '        // If ALL block value was moved away from the source tile, we lose our claim to it. It becomes ownerless.\n', '        if (sourceTileBlockValue == 0) {\n', '            bwData.deleteTile(sourceTileId);\n', '        } else {\n', '            bwData.updateTileBlockValue(sourceTileId, sourceTileBlockValue);\n', '            bwData.deleteOffer(sourceTileId); // Offer invalid since block value has changed\n', '        }\n', '\n', '        bwData.updateTileBlockValue(destTileId, destTileBlockValue);\n', '        bwData.deleteOffer(destTileId);   // Offer invalid since block value has changed\n', '        emit BlockValueMoved(sourceTileId, destTileId, _msgSender, _moveAmount, sourceTileBlockValue, destTileBlockValue, block.timestamp);        \n', '    }\n', '\n', '    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n', '        if (_useBattleValue) {\n', '            require(_msgValue == 0);\n', '            require(bwData.getUserBattleValue(_msgSender) >= _amount);\n', '        } else {\n', '            require(_amount == _msgValue);\n', '        }\n', '    }\n', '\n', '    function setLocalGame(uint16 _tileId, address localGameAddress) public isOwner {\n', '        localGames[_tileId] = localGameAddress;\n', '    }\n', '\n', '    function getLocalGame(uint16 _tileId) view public isValidCaller returns (address) {\n', '        return localGames[_tileId];\n', '    }\n', '\n', '    // BATTLE VALUE FUNCTIONS\n', '    function withdrawBattleValue(address msgSender, uint _battleValueInWei) public isValidCaller returns (uint) {\n', '        //require(_battleValueInWei % 1 finney == 0); // Must be divisible by 1 finney\n', "        uint fee = _battleValueInWei.mul(WITHDRAW_FEE).div(100); // Since we divide by 20 we can never create infinite fractions, so we'll always count in whole wei amounts.\n", '        uint amountToWithdraw = _battleValueInWei.sub(fee);\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(fee);\n', '        bwData.setFeeBalance(feeBalance);\n', '        subUserBattleValue(msgSender, _battleValueInWei, true);\n', '        return amountToWithdraw;\n', '    }\n', '\n', '    function addUserBattleValue(address _userId, uint _amount) public isValidCaller {\n', '        uint userBattleValue = bwData.getUserBattleValue(_userId);\n', '        uint newBattleValue = userBattleValue.add(_amount);\n', "        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\n", '        emit UserBattleValueUpdated(_userId, newBattleValue, false);\n', '    }\n', '    \n', '    function subUserBattleValue(address _userId, uint _amount, bool _isWithdraw) public isValidCaller {\n', '        uint userBattleValue = bwData.getUserBattleValue(_userId);\n', "        require(_amount <= userBattleValue); // Must be less than user's battle value - also implicitly checks that underflow isn't possible\n", '        uint newBattleValue = userBattleValue.sub(_amount);\n', "        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\n", '        emit UserBattleValueUpdated(_userId, newBattleValue, _isWithdraw);\n', '    }\n', '\n', '    function addGlobalBlockValueBalance(uint _amount) public isValidCaller {\n', '        // Track addition to global block value.\n', '        uint blockValueBalance = bwData.getBlockValueBalance();\n', '        bwData.setBlockValueBalance(blockValueBalance.add(_amount));\n', '    }\n', '\n', '    function subGlobalBlockValueBalance(uint _amount) public isValidCaller {\n', '        // Track addition to global block value.\n', '        uint blockValueBalance = bwData.getBlockValueBalance();\n', '        bwData.setBlockValueBalance(blockValueBalance.sub(_amount));\n', '    }\n', '\n', '    // Allow us to transfer out airdropped tokens if we ever receive any\n', '    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n', '        ERC20I token = ERC20I(_tokenAddress);\n', '        require(token.transfer(_recipient, token.balanceOf(this)));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract BWData {\n', '    address public owner;\n', '    address private bwService;\n', '    address private bw;\n', '    address private bwMarket;\n', '\n', '    uint private blockValueBalance = 0;\n', '    uint private feeBalance = 0;\n', '    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.\n', '    \n', '    mapping (address => User) private users; // user address -> user information\n', '    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile\n', '    \n', '    // Info about the users = those who have purchased tiles.\n', '    struct User {\n', '        uint creationTime;\n', '        bool censored;\n', '        uint battleValue;\n', '    }\n', '\n', '    // Info about a tile ownership\n', '    struct Tile {\n', '        address claimer;\n', '        uint blockValue;\n', '        uint creationTime;\n', '        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.\n', '    }\n', '\n', '    struct Boost {\n', '        uint8 numAttackBoosts;\n', '        uint8 numDefendBoosts;\n', '        uint attackBoost;\n', '        uint defendBoost;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', "    // Can't send funds straight to this contract. Avoid people sending by mistake.\n", '    function () payable public {\n', '        revert();\n', '    }\n', '\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    modifier isValidCaller {\n', '        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function setBwServiceValidCaller(address _bwService) public isOwner {\n', '        bwService = _bwService;\n', '    }\n', '\n', '    function setBwValidCaller(address _bw) public isOwner {\n', '        bw = _bw;\n', '    }\n', '\n', '    function setBwMarketValidCaller(address _bwMarket) public isOwner {\n', '        bwMarket = _bwMarket;\n', '    }    \n', '    \n', '    // ----------USER-RELATED GETTER FUNCTIONS------------\n', '    \n', '    //function getUser(address _user) view public returns (bytes32) {\n', '        //BWUtility.User memory user = users[_user];\n', '        //require(user.creationTime != 0);\n', '        //return (user.creationTime, user.imageUrl, user.tag, user.email, user.homeUrl, user.creationTime, user.censored, user.battleValue);\n', '    //}\n', '    \n', '    function addUser(address _msgSender) public isValidCaller {\n', '        User storage user = users[_msgSender];\n', '        require(user.creationTime == 0);\n', '        user.creationTime = block.timestamp;\n', '    }\n', '\n', '    function hasUser(address _user) view public isValidCaller returns (bool) {\n', '        return users[_user].creationTime != 0;\n', '    }\n', '    \n', '\n', '    // ----------TILE-RELATED GETTER FUNCTIONS------------\n', '\n', '    function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);\n', '    }\n', '    \n', '    function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return (currentTile.claimer, currentTile.blockValue);\n', '    }\n', '    \n', '    function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        return currentTile.creationTime == 0;\n', '    }\n', '    \n', '    function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {\n', '        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);\n', '    }\n', '\n', '    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {\n', '        tiles[_tileId].blockValue = _blockValue;\n', '    }\n', '\n', '    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {\n', '        tiles[_tileId].claimer = _claimer;\n', '    }\n', '\n', '    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {\n', '        tiles[_tileId].creationTime = block.timestamp;\n', '    }\n', '    \n', '    function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        if (currentTile.creationTime == 0) {\n', '            return 0;\n', '        }\n', '        return currentTile.claimer;\n', '    }\n', '\n', '    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {\n', '        Tile storage currentTile = tiles[_tileId];\n', '        if (currentTile.creationTime == 0) {\n', '            return (0, 0);\n', '        }\n', '        return (currentTile.blockValue, currentTile.sellPrice);\n', '    }\n', '    \n', '    function getBlockValueBalance() view public isValidCaller returns (uint){\n', '        return blockValueBalance;\n', '    }\n', '\n', '    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {\n', '        blockValueBalance = _blockValueBalance;\n', '    }\n', '\n', '    function getFeeBalance() view public isValidCaller returns (uint) {\n', '        return feeBalance;\n', '    }\n', '\n', '    function setFeeBalance(uint _feeBalance) public isValidCaller {\n', '        feeBalance = _feeBalance;\n', '    }\n', '    \n', '    function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {\n', '        return users[_userId].battleValue;\n', '    }\n', '    \n', '    function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {\n', '        users[_userId].battleValue = _battleValue;\n', '    }\n', '    \n', '    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n', '        User storage user = users[_msgSender];\n', '        require(user.creationTime != 0);\n', '\n', '        if (_useBattleValue) {\n', '            require(_msgValue == 0);\n', '            require(user.battleValue >= _amount);\n', '        } else {\n', '            require(_amount == _msgValue);\n', '        }\n', '    }\n', '    \n', '    function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {\n', '        if (_tile.claimer == _attacker) {\n', '            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n', '            _boost.attackBoost += _tile.blockValue;\n', '            _boost.numAttackBoosts += 1;\n', '        } else if (_tile.claimer == _defender) {\n', '            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n', '            _boost.defendBoost += _tile.blockValue;\n', '            _boost.numDefendBoosts += 1;\n', '        }\n', '    }\n', '\n', '    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {\n', '        uint8 x;\n', '        uint8 y;\n', '\n', '        (x, y) = BWUtility.fromTileId(_tileId);\n', '\n', '        Boost memory boost = Boost(0, 0, 0, 0);\n', '        // We overflow x, y on purpose here if x or y is 0 or 255 - the map overflows and so should adjacency.\n', '        // Go through all adjacent tiles to (x, y).\n', '        if (y != 255) {\n', '            if (x != 255) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);\n', '            }\n', '            \n', '            addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);\n', '\n', '            if (x != 0) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);\n', '            }\n', '        }\n', '\n', '        if (x != 255) {\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);\n', '        }\n', '\n', '        if (x != 0) {\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);\n', '        }\n', '\n', '        if (y != 0) {\n', '            if(x != 255) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);\n', '            }\n', '\n', '            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);\n', '\n', '            if(x != 0) {\n', '                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);\n', '            }\n', '        }\n', '        // The benefit of boosts is multiplicative (quadratic):\n', '        // - More boost tiles gives a higher total blockValue (the sum of the adjacent tiles)\n', '        // - More boost tiles give a higher multiple of that total blockValue that can be used (10% per adjacent tie)\n', '        // Example:\n', '        //   A) I boost attack with 1 single tile worth 10 finney\n', '        //      -> Total boost is 10 * 1 / 10 = 1 finney\n', '        //   B) I boost attack with 3 tiles worth 1 finney each\n', '        //      -> Total boost is (1+1+1) * 3 / 10 = 0.9 finney\n', '        //   C) I boost attack with 8 tiles worth 2 finney each\n', '        //      -> Total boost is (2+2+2+2+2+2+2+2) * 8 / 10 = 14.4 finney\n', '        //   D) I boost attack with 3 tiles of 1, 5 and 10 finney respectively\n', '        //      -> Total boost is (ss1+5+10) * 3 / 10 = 4.8 finney\n', "        // This division by 10 can't create fractions since our uint is wei, and we can't have overflow from the multiplication\n", "        // We do allow fractions of finney here since the boosted values aren't stored anywhere, only used for attack rolls and sent in events\n", '        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);\n', '        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);\n', '\n', '        return (boost.attackBoost, boost.defendBoost);\n', '    }\n', '    \n', '    function censorUser(address _userAddress, bool _censored) public isValidCaller {\n', '        User storage user = users[_userAddress];\n', '        require(user.creationTime != 0);\n', '        user.censored = _censored;\n', '    }\n', '    \n', '    function deleteTile(uint16 _tileId) public isValidCaller {\n', '        delete tiles[_tileId];\n', '    }\n', '    \n', '    function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {\n', '        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.\n', '    }\n', '\n', '    function deleteOffer(uint16 _tileId) public isValidCaller {\n', '        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '* Copyright 2018 Block Wars Team\n', '*\n', '*/\n', '\n', 'interface LocalGameI {\n', '    function getBountyBalance() view external returns (uint);\n', '    function getTimeLeftToNextCollect(address _claimer, uint _latestClaimTime) view external returns (uint);\n', '    function collectBounty(address _msgSender, uint _latestClaimTime, uint _amount) external returns (uint);\n', '}\n', '\n', '/*\n', '* @title ERC721 interface\n', '*/\n', 'contract ERC721 {\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    //event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    //event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    //event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    //function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    //function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    //function approve(address _approved, uint256 _tokenId) external payable;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', "    ///  all of `msg.sender`'s assets.\n", '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    //function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    //function getApproved(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    //function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    //function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract BW { \n', '    using SafeMath for uint256;\n', '    address public owner;\n', '    BWService private bwService;\n', '    BWData private bwData;\n', '    bool public paused = false;\n', '    uint private BV_TO_BP_FEE = 5; // 5%\n', '    mapping (uint16 => Prize[]) private prizes; // Use mapping instead of array (key would be a unique priceId) - NO (we want to loop all prices)\n', '    \n', '    struct Prize {\n', '        address token; // BWT or CryptoKiities (ERC721)\n', '        uint tokenId; \n', '        uint startTime; // To be able to add a price before the game starts\n', '        uint hodlPeriod; // Amount of seconds you have to own the tile before being able to claim this price. One block is ~15 sec.\n', '    }\n', '\n', '    event PrizeCreated(uint16 tileId,  address token, uint tokenId, uint creationTime, uint startTime, uint hodlPeriod);\n', '    event PrizeRemoved(uint16 tileId, address token, uint tokenId, uint removeTime);\n', '    event PrizeClaimed(address token, uint tokenId);\n', '\n', '    // Add price (only BW owner can do this)\n', '    function addPrize(uint16 _tileId, address _token, uint _tokenId, uint _startTime, uint _hodlPeriod) public isOwner {\n', '        //startTime must be same or after block.timestamp\n', '        uint startTime = _startTime;\n', '        if(startTime < block.timestamp) {\n', '            startTime = block.timestamp;\n', '        }\n', '        // we could check if token exists with ownerOf function in interface, \n', "        // but if any erc721 token doesn't implement the function, this function would revert.\n", '        // also cheaper to not make an interface call\n', '        prizes[_tileId].push(Prize(_token, _tokenId, startTime, _hodlPeriod));\n', '        emit PrizeCreated(_tileId, _token, _tokenId, block.timestamp, startTime, _hodlPeriod);\n', '    }\n', '\n', '    // Remove price (only BW owner can do this)\n', '    function removePrize(uint16 _tileId, address _token, uint _tokenId) public isOwner {\n', '        Prize[] storage prizeArr = prizes[_tileId];\n', '        require(prizeArr.length > 0);\n', '\n', '        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n', '            if(prizeArr[idx].tokenId == _tokenId && prizeArr[idx].token == _token) {\n', '                delete prizeArr[idx];\n', '                emit PrizeRemoved(_tileId, _token, _tokenId, block.timestamp);\n', '            }\n', '        }\n', '    }\n', '\n', '    // Add price (only BW owner can do this)\n', '    function claimPrize(address _tokenAddress, uint16 _tileId) public isNotPaused isNotContractCaller {\n', '        ERC721 token = ERC721(_tokenAddress);\n', '        Prize[] storage prizeArr = prizes[_tileId];\n', '        require(prizeArr.length > 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint lastClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, lastClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        require(lastClaimTime != 0 && claimer == msg.sender);\n', '\n', '        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n', '            if(prizeArr[idx].startTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp\n', '                && lastClaimTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp) {\n', '                uint tokenId = prizeArr[idx].tokenId;\n', '                address tokenOwner = token.ownerOf(tokenId);\n', '                delete prizeArr[idx];\n', '                token.safeTransferFrom(tokenOwner, msg.sender, tokenId); //Will revert if token does not exists\n', '                emit PrizeClaimed(_tokenAddress, tokenId);\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier isOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Checks if entire game (except battle value withdraw) is paused or not.\n', '    modifier isNotPaused {\n', '        if (paused) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Only allow wallets to call this function, not contracts.\n', '    modifier isNotContractCaller {\n', '        require(msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    // All contract event types.\n', '    event UserCreated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint creationTime, address invitedBy);\n', '    event UserCensored(address userAddress, bool isCensored);\n', '    event TransferTileFromOwner(uint16 tileId, address seller, address buyer, uint acceptTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n', '    event UserUpdated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint updateTime);\n', '    event TileRetreated(uint16 tileId, address owner, uint amount, uint newBlockValue, uint retreatTime);\n', '    event BountyCollected(uint tile, address userAddress, uint amount, uint amountCollected, uint collectedTime, uint latestClaimTime);\n', '\n', '    // BASIC CONTRACT FUNCTIONS\n', '    constructor(address _bwService, address _bwData) public {\n', '        bwService = BWService(_bwService);\n', '        bwData = BWData(_bwData);\n', '        owner = msg.sender;\n', '    }\n', '\n', "    // Can't send funds straight to this contract. Avoid people sending by mistake.\n", '    function () payable public isOwner {\n', '\n', '    }\n', '\n', '    // Allow a new user to claim one or more previously unclaimed tiles by paying Ether.\n', '    function claimTilesForNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, uint16[] _claimedTileIds, address _invitedBy) payable public isNotPaused isNotContractCaller {\n', '        bwData.addUser(msg.sender);\n', '        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n', '        bwService.storeInitialClaim(msg.sender, _claimedTileIds, msg.value, false);\n', '    }\n', '\n', '    // Allow an existing user to claim one or more previously unclaimed tiles by paying Ether.\n', '    function claimTilesForExistingUser(uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _claimAmount, _useBattleValue);\n', '        bwService.storeInitialClaim(msg.sender, _claimedTileIds, _claimAmount, _useBattleValue);\n', '    }\n', '\n', '    // Allow users to change name, image URL, tag and home URL. Not censored status or battle value though.\n', '    function updateUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl) public isNotPaused isNotContractCaller {\n', '        require(bwData.hasUser(msg.sender));\n', "        // All the updated values are stored in events only so there's no state to update on the contract here.\n", '        emit UserUpdated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp);\n', '    }\n', '    \n', '    // This function fortifies multiple previously claimed tiles in a single transaction.\n', '    // The value assigned to each tile is the msg.value divided by the number of tiles fortified.\n', '    // The msg.value is required to be an even multiple of the number of tiles fortified.\n', '    // Only tiles owned by msg.sender can be fortified.\n', '    function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue);\n', '        bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue);\n', '    }\n', '\n', '    // A new user attacks a tile claimed by someone else, trying to make it theirs through battle.\n', '    function attackTileForNewUser(uint16 _tileId, bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _invitedBy) payable public isNotPaused isNotContractCaller {\n', '        bwData.addUser(msg.sender);\n', '        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n', '        bwService.attackTile(msg.sender, _tileId, msg.value, false);\n', '    }\n', '\n', '    // An existing user attacks a tile claimed by someone else, trying to make it theirs through battle.\n', '    function attackTileForExistingUser(uint16 _tileId, uint _attackAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n', '        bwService.verifyAmount(msg.sender, msg.value, _attackAmount, _useBattleValue);\n', '        bwService.attackTile(msg.sender, _tileId, _attackAmount, _useBattleValue);\n', '    }\n', '    \n', '    // Move "army" = block value from one block to an adjacent block. Moving ALL value equates giving up ownership of the source tile.\n', '    function moveBlockValue(uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isNotPaused isNotContractCaller {\n', '        require(_moveAmount > 0);\n', '        bwService.moveBlockValue(msg.sender, _xSource, _ySource, _xDest, _yDest, _moveAmount);\n', '    }\n', '\n', '    // Allow users to withdraw battle value in Ether.\n', '    function withdrawBattleValue(uint _battleValueInWei) public isNotContractCaller {\n', '        require(_battleValueInWei > 0);\n', '        uint amountToWithdraw = bwService.withdrawBattleValue(msg.sender, _battleValueInWei);\n', '        msg.sender.transfer(amountToWithdraw);\n', '    }\n', '\n', '    // Transfer block value to battle points for free \n', '    function transferBlockValueToBattleValue(uint16 _tileId, uint _amount) public isNotContractCaller {\n', '        require(_amount > 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n', '        require(claimer == msg.sender);\n', '        uint newBlockValue = blockValue.sub(_amount);\n', '        // Must transfer the entire block value or leave at least 5\n', '        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n', '        if(newBlockValue == 0) {\n', '            bwData.deleteTile(_tileId);\n', '        } else {\n', '            bwData.updateTileBlockValue(_tileId, newBlockValue);\n', '            bwData.deleteOffer(_tileId); // Offer invalid since block value has changed\n', '        }\n', '        \n', '        uint fee = _amount.mul(BV_TO_BP_FEE).div(100);\n', '        uint userAmount = _amount.sub(fee);\n', '        uint feeBalance = bwData.getFeeBalance();\n', '        feeBalance = feeBalance.add(fee);\n', '        bwData.setFeeBalance(feeBalance);\n', '\n', '        bwService.addUserBattleValue(msg.sender, userAmount);\n', '        bwService.subGlobalBlockValueBalance(_amount);\n', '        emit TileRetreated(_tileId, msg.sender, _amount, newBlockValue, block.timestamp);\n', '    }\n', '\n', '    // -------- LOCAL GAME FUNCTIONS ----------\n', '\n', '    function getLocalBountyBalance(uint16 _tileId) view public isNotContractCaller returns (uint) {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        return localGame.getBountyBalance();\n', '    }\n', '\n', '    function getTimeLeftToNextLocalBountyCollect(uint16 _tileId) view public isNotContractCaller returns (uint) {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint latestClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        return localGame.getTimeLeftToNextCollect(claimer, latestClaimTime);\n', '    }\n', '\n', '    function collectLocalBounty(uint16 _tileId, uint _amount) public isNotContractCaller {\n', '        address localGameAddress = bwService.getLocalGame(_tileId);\n', '        require(localGameAddress != 0);\n', '        address claimer;\n', '        uint blockValue;\n', '        uint latestClaimTime;\n', '        uint sellPrice;\n', '        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n', '        require(latestClaimTime != 0 && claimer == msg.sender);\n', '        \n', '        LocalGameI localGame = LocalGameI(localGameAddress);\n', '        uint amountCollected = localGame.collectBounty(msg.sender, latestClaimTime, _amount);\n', '        emit BountyCollected(_tileId, msg.sender, _amount, amountCollected, block.timestamp, latestClaimTime);\n', '    }\n', '\n', '    // -------- OWNER-ONLY FUNCTIONS ----------\n', '\n', '    // Only used by owner for raffle. Owner need name, address and picture from user.\n', '    // These users can then be given tiles by owner using transferTileFromOwner.\n', '    function createNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _user) public isOwner {\n', '        bwData.addUser(_user);\n', '        emit UserCreated(_user, _name, _imageUrl, _tag, _homeUrl, block.timestamp, msg.sender); //check on client if invitedBy is owner.\n', '    }\n', '\n', '    // Allow updating censored status. Owner only. In case someone uploads offensive content.\n', '    // The contract owners reserve the right to apply censorship. This will mean that the\n', '    // name, tag or URL images might not be displayed for a censored user.\n', '    function censorUser(address _userAddress, bool _censored) public isOwner {\n', '        bwData.censorUser(_userAddress, _censored);\n', '        emit UserCensored(_userAddress, _censored);\n', '    }\n', '\n', '    // Pause the entire game, but let users keep withdrawing battle value\n', '    function setPaused(bool _paused) public isOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '    function kill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function withdrawFee() public isOwner {\n', '        uint balance = address(this).balance;\n', '        uint amountToWithdraw = bwData.getFeeBalance();\n', '\n', '        if (balance < amountToWithdraw) { // Should never happen, but paranoia\n', '            amountToWithdraw = balance;\n', '        }\n', '        bwData.setFeeBalance(0);\n', '\n', '        owner.transfer(amountToWithdraw);\n', '    }\n', '\n', '    function getFee() view public isOwner returns (uint) {\n', '        return bwData.getFeeBalance();\n', '    }\n', '\n', '    function setBvToBpFee(uint _feePercentage) public isOwner {\n', '        BV_TO_BP_FEE = _feePercentage;\n', '    }\n', '\n', '    function depositBattleValue(address _user) payable public isOwner {\n', '        require(msg.value % 1 finney == 0); // Must be divisible by 1 finney\n', '        bwService.addUserBattleValue(_user, msg.value);\n', '    }\n', '\n', '    // The owner can transfer ownership of own tiles to other users, as prizes in competitions.\n', '    function transferTileFromOwner(uint16[] _tileIds, address _newOwner) public isOwner {\n', '        for(uint i = 0; i < _tileIds.length; ++i) {\n', '            uint16 tileId = _tileIds[i];\n', '            address claimer = bwData.getCurrentClaimerForTile(tileId);\n', '            require(claimer == owner);\n', '            bwData.setClaimerForTile(tileId, _newOwner);\n', '            \n', '            emit TransferTileFromOwner(tileId, _newOwner, msg.sender, block.timestamp);\n', '        }\n', '    }\n', '\n', '    // Allow us to transfer out airdropped tokens if we ever receive any\n', '    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n', '        ERC20I token = ERC20I(_tokenAddress);\n', '        require(token.transfer(_recipient, token.balanceOf(this)));\n', '    }\n', '}']
