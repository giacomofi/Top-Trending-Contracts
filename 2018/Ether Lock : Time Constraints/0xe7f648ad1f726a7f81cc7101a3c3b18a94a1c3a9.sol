['pragma solidity ^0.4.24;\n', '\n', '\n', '//@Author Kirin\n', 'contract Infinitestars {\n', '    \n', '    using Player for Player.Map;\n', '    using CommUtils for string;\n', '    using InfinitestarsData for InfinitestarsData.Data;\n', '    using Ball for Ball.Data[];\n', '    uint256 public constant WITHDRAWAL_AUTO_BUY_COUNT = 1;\n', '    uint256 public constant BALL_PRICE = 0.5 ether;\n', '    uint256 public constant REGESTER_FEE = 0.02 ether;\n', '    uint256 public constant REGISTER_FREE_COUNT = 100;\n', '    InfinitestarsData.Data private data;\n', '    uint256 private regesterCount =0;\n', '    bool private gameEnabled = false;\n', '\n', '\n', '    function enableGame() public{\n', '        require(Player.isAdmin(msg.sender),"it`s not admin");\n', '        gameEnabled = true;\n', '    }\n', '    \n', '    modifier enabling(){\n', '        require(gameEnabled,"game not start");\n', '        _;\n', '    }\n', '\n', '    function buyBall(uint256 count) enabling public payable  {\n', '        (address picker,uint256 ammount) =data.buyBall(count,msg.sender);\n', '        broadcastBuy(msg.sender,count,ammount,picker);\n', '    }\n', '    \n', '    function broadcastBuy(address adr,uint256 count,uint256 starsPickValue,address picker) private {\n', '        bytes32 b = data.players.getName(adr);\n', '        emit OnBuyed (adr,b,count,starsPickValue,picker);\n', '    }\n', '    \n', '    function buyBallWithReferrer(uint256 count,string referrer) enabling public payable  {\n', '       (address picker,uint256 ammount) =data.buyBallWithReferrer(count,msg.sender,referrer);\n', '        broadcastBuy(msg.sender,count,ammount,picker);\n', '    }    \n', '\n', '    function getInit()  public view returns(\n', '        bytes32, //0 your name\n', '        bytes32, //1  refername\n', '        uint256,  //2 currentIdx\n', '        uint256,    //3 shourt Prize\n', '        uint256,     //4 the player gains\n', '        uint256,     //5 refferSumReward\n', '        bool ,      //6 played\n', '        uint256 ,    //7 blance\n', '        uint256     //8  Your live ball\n', '    \n', '    ){\n', '       // (uint256 count,uint256 firstAt,uint256 lastAt, uint256 payOutCount,uint256 nextPayOutAt) = data.getOutInfoOfSender();\n', '        return (\n', '            data.players.getName(),\n', '            data.players.getReferrerName(msg.sender),\n', '            data.currentIdx,\n', '            data.shortPrize,\n', '            data.players.getAmmount(msg.sender),\n', '            data.referralbonusMap[msg.sender],\n', '            data.playedMap[msg.sender],\n', '            address(this).balance,\n', '            data.balls.countByOwner(msg.sender)\n', '        );\n', '    }\n', '    \n', '    \n', '    function getOutInfo(uint256 startIdx,uint256 pageSize) public view returns(\n', '            uint256 scanCount,\n', '            uint256 selfCount,\n', '            uint256 firstAt,\n', '            uint256 lastAt,\n', '            uint256 payOutCount,\n', '            uint256 nextPayOutAt\n', '        ){\n', '        return data.getOutInfo(startIdx,pageSize);\n', '    }\n', '    \n', '\n', '    function getPayedInfo(uint256 startIdx,uint256 pageSize) public view returns(\n', '            uint256 scanCount,\n', '            uint256 selfCount,\n', '            uint256 firstAt,\n', '            uint256 lastAt,\n', '            uint256 payOutCount,\n', '            uint256 payedCount\n', '        ){\n', '        return data.getPayedInfo(startIdx,pageSize);\n', '    }    \n', '    \n', '    \n', '    function getOutInfoOfSender()  public view returns(\n', '            uint256 , //your out ball\n', '            uint256 , //firstAt\n', '            uint256 ,  //lastAt      \n', '            uint256,   //  payOutCount,\n', '            uint256 ,   //   nextPayOutAt    \n', '            uint256     // payedCount\n', '        ){\n', '        return data.getOutInfoOfSender();\n', '    }      \n', '\n', '    \n', '    function outBall() enabling public {\n', '        data.toPayedBall();\n', '        data.toOutBall();\n', '    }\n', '    \n', '    function listLiveBall() public view returns(\n', '        uint256[] , //index;\n', '        address[] , //owner;\n', '        uint256[] , //outCount;\n', '        uint[]  //createAt;\n', '        ){\n', '        return listBall(data.balls);\n', '    }\n', '    \n', '    function listBall(Ball.Data[] list) private pure returns(\n', '        uint256[] indexs, //index;\n', '        address[] owners, //owner;\n', '        uint256[] outCounts, //outCount;\n', '        uint[] createAts //createAt;\n', '        ){\n', '        indexs = new uint256[](list.length);    \n', '        owners = new address[](list.length);    \n', '        outCounts = new uint256[](list.length);    \n', '        createAts = new uint[](list.length);    \n', '        for(uint256 i=0;i<list.length;i++){\n', '            indexs[i]=list[i].index;\n', '            owners[i]=list[i].owner;\n', '            outCounts[i]=list[i].outCount;\n', '            createAts[i]=list[i].createAt;\n', '        }\n', '    }\n', '  \n', '    \n', '    function registerName(string  name) enabling public payable {\n', '        require(msg.value >= REGESTER_FEE,"fee not enough");\n', '        require(data.playedMap[msg.sender] ,"it`s not play");\n', '        regesterCount++;\n', '        data.registerName(name);\n', '        if(REGISTER_FREE_COUNT>=regesterCount){\n', '            data.players.deposit(msg.sender,REGESTER_FEE);\n', '        }\n', '    }    \n', '    \n', '    function isEmptyName(string _n) public view returns(bool){\n', '        return data.players.isEmptyName(_n.nameFilter());\n', '    }    \n', '    \n', '    \n', '    function withdrawalBuy(uint256 ammount) enabling public payable{\n', '        \n', '        address self = msg.sender;\n', '        uint256 fee = CommUtils.mulRate(ammount,1);\n', '        uint256 gains = data.players.getAmmount(msg.sender);\n', '        uint256 autoPayA = WITHDRAWAL_AUTO_BUY_COUNT*BALL_PRICE;\n', '        ammount-= fee;\n', '        require(ammount<=gains ,"getAmmount is too low ");\n', '        //require(data.balls.countByOwner(self)>0 ,"must has live ball ");\n', '        require(gains >= autoPayA,"gains >= autoPayA");\n', '        require(ammount>= autoPayA,"ammount>= ammount");\n', '        data.players.transferAuthor(fee);\n', '        ammount -= autoPayA;\n', '        data.buyBall(WITHDRAWAL_AUTO_BUY_COUNT,self);\n', '        uint256 contractBlc = address(this).balance;\n', '        bool b =false;\n', '        if(contractBlc >= ammount){\n', '            data.players.minus(self,ammount);\n', '            self.transfer(ammount);\n', '            b= true;\n', '        }else if(ammount>=BALL_PRICE){\n', '            uint256 mod = ammount % BALL_PRICE;\n', '            uint256 count = (ammount - mod) / BALL_PRICE;\n', '            data.buyBall(count,self);\n', '            data.players.deposit(msg.sender,mod);\n', '            b= true;\n', '        }        \n', '        emit OnWithdrawaled (self,ammount,b); \n', '    }\n', '    \n', '\n', '    event OnBuyed(\n', '        address buyer,\n', '        bytes32 buyerName,\n', '        uint256 count,\n', '        uint256 starsPickValue,\n', '        address picker\n', '    );\n', '    \n', '    event OnWithdrawaled(\n', '        address who,\n', '        uint256 ammount,\n', '        bool ok\n', '    );\n', '    \n', '    \n', '\n', '}\n', '\n', 'library Ball {\n', '    \n', '    using CommUtils for CommUtils.QueueIdx;\n', '    \n', '    struct Data{\n', '        uint64  index;\n', '        uint64  createAt;\n', '        address owner;\n', '        uint128  outCount;\n', '    }\n', '    \n', '    struct Queue{\n', '        CommUtils.QueueIdx queueIdx;\n', '        mapping(uint256 => Data) map;\n', '    }\n', '    \n', '    function lifo(Data[] storage ds,Data ind) internal  returns(Data  ans){\n', '        ans = ds[0];\n', '        for(uint256 i=0;i<ds.length-1;i++){\n', '            Data storage nd = ds[i+1];\n', '            ds[i] = nd;\n', '        }\n', '        ds[ds.length-1] = ind;\n', '    }\n', '    \n', '    function getByIndex(Data[] storage ds,uint256 idx) internal view returns(Data storage ) {\n', '        for(uint256 i=0;i<ds.length;i++){\n', '            Data storage d = ds[i];\n', '            if(idx ==d.index){\n', '                return d;\n', '            }\n', '        }       \n', '        revert("not find getByIndex Ball");\n', '    }\n', '    \n', '    function isBrandNew(Data storage d) internal view returns(bool){\n', '        return d.owner == address(0);\n', '    }\n', '    \n', '    function replace(Data storage tar,Data  sor) internal {\n', '        tar.index = sor.index;\n', '        tar.owner = sor.owner;\n', '        tar.outCount = sor.outCount;\n', '        tar.createAt = sor.createAt;\n', '    }\n', '    \n', '    function removeByIndex(Data[] storage array,uint256 index) internal {\n', '        if (index >= array.length) return;\n', '\n', '        for (uint256 i = index; i<array.length-1; i++){\n', '            array[i] = array[i+1];\n', '        }\n', '        delete array[array.length-1];\n', '        array.length--;\n', '    }\n', '    \n', '    \n', '    function removeByOwner(Data[] storage ds,address owner,uint256 count) internal{\n', '        for(uint256 i=0;i<ds.length;i++){\n', '            if( ds[i].owner == owner ) {\n', '                removeByIndex(ds,i);\n', '                i--;\n', '                count--;\n', '            }\n', '            if(count ==0) return;\n', '        }\n', '        revert("removeByOwner count not = 0");\n', '    }\n', '    \n', '    function countByOwner(Data[] storage ds,address owner) internal view returns(uint256 ans){\n', '        for(uint256 i=0;i<ds.length;i++){\n', '            if( ds[i].owner == owner ) {\n', '                ans++;\n', '            }\n', '        }        \n', '    }\n', '    \n', '    \n', '\n', '    function getEnd(Queue storage q)  internal view returns(uint256 ){\n', '            return q.queueIdx.getEnd();\n', '    }        \n', '    \n', '    function getWishEnd(Queue storage q,uint256 wishSize)  internal view returns(uint256 ){\n', '        return q.queueIdx.getWishEnd(wishSize);\n', '    }    \n', '    \n', '    function getRealIdx(Queue storage q,uint256 index) internal view  returns(uint256 ){\n', '        return q.queueIdx.getRealIdx(index);\n', '    }\n', '    \n', '    function get(Queue storage q,uint256 index) internal view returns(Data ){\n', '        return q.map[getRealIdx(q,index)];\n', '    }\n', '    \n', '    function offer(Queue storage q,Data b) internal {\n', '        uint256 lastIdx= q.queueIdx.offer();\n', '        q.map[getRealIdx(q,lastIdx)] = Data({\n', '            index :b.index,\n', '            owner : b.owner,\n', '            outCount : b.outCount,\n', '            createAt : b.createAt\n', '        });\n', '    }\n', '    \n', '    function removeAtStart(Queue storage q,uint256 count)  internal{\n', '        (uint256 start,uint256 end) = q.queueIdx.removeAtStart(count);\n', '        for(uint256 i=start;i<end;i++){\n', '            delete q.map[i];\n', '        }\n', '    }\n', '    \n', '}\n', '\n', '\n', '\n', 'library CommUtils{\n', '\n', ' \n', '    struct QueueIdx{\n', '        uint256 startIdx;\n', '        uint256 size ;\n', '    }\n', '\n', '    \n', '\n', '    function random(uint256 max,uint256 mixed) public view returns(uint256){\n', '        uint256 lastBlockNumber = block.number - 1;\n', '        uint256 hashVal = uint256(blockhash(lastBlockNumber));\n', '        hashVal += 19*uint256(block.coinbase);\n', '        hashVal += 17*mixed;\n', '        hashVal += 13*uint256(block.difficulty);\n', '        hashVal += 11*uint256(block.gaslimit );\n', '        hashVal += 7*uint256(now );\n', '        hashVal += 3*uint256(tx.origin);\n', '        return uint256(hashVal % max);\n', '    } \n', '\n', '    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\n', '        return tar *rate / 100;\n', '    }  \n', '    \n', '    \n', '    /**\n', '     * @dev filters name strings\n', '     * -converts uppercase to lower case.  \n', '     * -makes sure it does not start/end with a space\n', '     * -makes sure it does not contain multiple spaces in a row\n', '     * -cannot be only numbers\n', '     * -cannot start with 0x \n', '     * -restricts characters to A-Z, a-z, 0-9, and space.\n', '     * @return reprocessed string in bytes32 format\n', '     */\n', '    function nameFilter(string _input)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        bytes memory _temp = bytes(_input);\n', '        uint256 _length = _temp.length;\n', '        \n', '        //sorry limited to 32 characters\n', '        require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");\n', '        // make sure it doesnt start with or end with space\n', '        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");\n', '        // make sure first two characters are not 0x\n', '        if (_temp[0] == 0x30)\n', '        {\n', '            require(_temp[1] != 0x78, "string cannot start with 0x");\n', '            require(_temp[1] != 0x58, "string cannot start with 0X");\n', '        }\n', '        \n', '        // create a bool to track if we have a non number character\n', '        bool _hasNonNumber;\n', '        \n', '        // convert & check\n', '        for (uint256 i = 0; i < _length; i++)\n', '        {\n', '            // if its uppercase A-Z\n', '            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n', '            {\n', '                // convert to lower case a-z\n', '                _temp[i] = byte(uint(_temp[i]) + 32);\n', '                \n', '                // we have a non number\n', '                if (_hasNonNumber == false)\n', '                    _hasNonNumber = true;\n', '            } else {\n', '                require\n', '                (\n', '                    // require character is a space\n', '                    _temp[i] == 0x20 || \n', '                    // OR lowercase a-z\n', '                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n', '                    // or 0-9\n', '                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n', '                    "string contains invalid characters"\n', '                );\n', '                // make sure theres not 2x spaces in a row\n', '                if (_temp[i] == 0x20)\n', '                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");\n', '                \n', '                // see if we have a character other than a number\n', '                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n', '                    _hasNonNumber = true;    \n', '            }\n', '        }\n', '        \n', '        require(_hasNonNumber == true, "string cannot be only numbers");\n', '        \n', '        bytes32 _ret;\n', '        assembly {\n', '            _ret := mload(add(_temp, 32))\n', '        }\n', '        return (_ret);\n', '    }    \n', '    \n', '\n', '    \n', '    function getEnd(QueueIdx storage q)  internal view returns(uint256 ){\n', '            return q.startIdx + q.size;\n', '    }        \n', '    \n', '    function getWishEnd(QueueIdx storage q,uint256 wishSize)  internal view returns(uint256 ){\n', '        if(q.size > wishSize){\n', '            return q.startIdx + wishSize;\n', '        }else{\n', '            return q.startIdx + q.size;\n', '        }\n', '    }    \n', '    \n', '    function getRealIdx(QueueIdx storage q,uint256 index) internal view  returns(uint256 ){\n', '        uint256 realIdx = q.startIdx + index;\n', '        require(getEnd(q)>realIdx,"getEnd()>q.startIdx+idx");\n', '        return realIdx;\n', '    }\n', '    \n', '    function offer(QueueIdx storage q) internal returns (uint256 lastIdx) {\n', '        lastIdx= q.size ++;\n', '    }\n', '    \n', '    function removeAtStart(QueueIdx storage q,uint256 count)  internal returns(uint256 start ,  uint256 end) {\n', '        require(q.size >= count ,"getSize(q) >= count");\n', '        start = q.startIdx;\n', '        end = getWishEnd(q,count);\n', '\n', '        q.startIdx += count;\n', '        q.size -= count;\n', '        if(q.size == 0){\n', '            q.startIdx = 0;\n', '        }\n', '        \n', '    }    \n', '    \n', '    \n', '}\n', '\n', '\n', '\n', 'library InfinitestarsData {\n', '    \n', '\n', '    using Ball for Ball.Data[];\n', '    using Ball for Ball.Queue;\n', '    using Ball for Ball.Data;\n', '    using Player for Player.Map;\n', '    using CommUtils for string;\n', '    using CommUtils for CommUtils.QueueIdx;\n', '    \n', '    \n', '    uint256 public constant  LIVE_BALL_COUNT = 3;\n', '    uint256 public constant BALL_PRICE = 0.5 ether;\n', '    uint256 public constant FEE = BALL_PRICE /100;\n', '    uint256 public constant OUT_LIMT = 2;\n', '    uint256 public constant SHORT_PRIZE_PLUS = BALL_PRICE * 3 / 100;\n', '    uint256 public constant LEVEL_1_REWARD = BALL_PRICE * 10 /100;\n', '    uint256 public constant LEVEL_2_REWARD = BALL_PRICE * 3 /100;\n', '    uint256 public constant LEVEL_3_REWARD = BALL_PRICE * 2 /100;\n', '    uint256 public constant MAINTTAIN_FEE =  BALL_PRICE * 1 /100;\n', '    uint256 public constant OUT_TIME = 60*60*24*2;\n', '    uint256 public constant PAY_TIME = 60*60*24*1;\n', '    uint256 public constant AIRDROP_RATE_1000 = 5;\n', '    // uint256 public constant OUT_TIME = 8*60;\n', '    // uint256 public constant PAY_TIME = 4*60;\n', '    \n', '    uint256 public constant QUEUE_BATCH_SIZE = 20;\n', '    //uint256 public constant OUT_TIME = 60;\n', '    uint256 public constant PAY_PROFIT = 0.085 ether;\n', '    //uint256 public constant PAY_AMMOUNT = (BALL_PRICE* 40/100) - FEE;\n', '\n', '    \n', '    struct Data{\n', '        Ball.Data[] balls ;\n', '        Ball.Queue outingBalls ;\n', '        Ball.Queue payedQueue ;\n', '        Player.Map players;\n', '        uint256 shortPrize;\n', '        uint256 currentIdx;\n', '        mapping(address => bool) playedMap;\n', '        mapping(address => uint256) playBallCountMap;\n', '        mapping(address=> uint256 ) referralbonusMap;  \n', '        \n', '        bytes32  ranHash;\n', '        uint256  blockCalled;\n', '        \n', '        \n', '        \n', '        CommUtils.QueueIdx adQueueIdx;\n', '        mapping(uint256=>uint256) adCountMap;\n', '        mapping(uint256=>address) adOwnerMap;\n', '        \n', '    }\n', '    \n', '\n', '    function getOutInfo(Data storage d,uint256 startIdx,uint256 pageSize) internal view returns(\n', '            uint256 scanCount,\n', '            uint256 selfCount,\n', '            uint256 firstAt,\n', '            uint256 lastAt,\n', '            uint256 payOutCount,\n', '            uint256 nextPayOutAt\n', '        ){\n', '        uint256 end = d.outingBalls.getWishEnd(startIdx+pageSize);\n', '            \n', '        for(uint256 i=startIdx;i<end;i++){\n', '            Ball.Data storage ob = d.outingBalls.map[i];  \n', '            if(ob.owner == msg.sender){\n', '                if(firstAt==0  ||  ob.createAt<firstAt){\n', '                    firstAt = ob.createAt;\n', '                }\n', '                if(lastAt == 0 || ob.createAt > lastAt){\n', '                    lastAt = ob.createAt;\n', '                }\n', '                if( (now - ob.createAt) > PAY_TIME ){\n', '                    payOutCount ++;\n', '                }else{\n', '                  if(nextPayOutAt==0) nextPayOutAt = ob.createAt;\n', '                }\n', '                selfCount++;\n', '            }\n', '            scanCount++;\n', '        }  \n', '        \n', '        firstAt = now - firstAt;\n', '        lastAt = now - lastAt;\n', '        nextPayOutAt = now - nextPayOutAt;\n', '    }\n', '    \n', '    function getPayedInfo(Data storage d,uint256 startIdx,uint256 pageSize) internal view returns(\n', '            uint256 scanCount,\n', '            uint256 selfCount,\n', '            uint256 firstAt,\n', '            uint256 lastAt,\n', '            uint256 payOutCount,\n', '            uint256 payedCount\n', '        ){\n', '            \n', '        uint256 end = d.payedQueue.getWishEnd(startIdx+pageSize);\n', '        for(uint256 i=startIdx;i<end;i++){\n', '            Ball.Data storage ob = d.payedQueue.map[i];  \n', '            if(ob.owner == msg.sender){\n', '                if(firstAt==0  ||  ob.createAt<firstAt){\n', '                    firstAt = ob.createAt;\n', '                }\n', '                if(lastAt == 0 || ob.createAt > lastAt){\n', '                    lastAt = ob.createAt;\n', '                }\n', '                payOutCount ++;\n', '                payedCount++;\n', '                selfCount++;\n', '            }\n', '            scanCount++;\n', '        }         \n', '         \n', '        firstAt = now - firstAt;\n', '        lastAt = now - lastAt;\n', '    }    \n', '\n', '    function getOutInfoOfSender(Data storage d) internal view returns(\n', '            uint256 count,\n', '            uint256 firstAt,\n', '            uint256 lastAt,\n', '            uint256 payOutCount,\n', '            uint256 nextPayOutAt,\n', '            uint256 payedCount\n', '        ){\n', '        // (uint256 stI , uint256 endI ) = d.outingBalls.getRange();    \n', '        for(uint256 i=d.outingBalls.queueIdx.startIdx;i<d.outingBalls.getEnd();i++){\n', '            Ball.Data storage ob = d.outingBalls.map[i];  \n', '            if(ob.owner == msg.sender){\n', '                if(firstAt==0  ||  ob.createAt<firstAt){\n', '                    firstAt = ob.createAt;\n', '                }\n', '                if(lastAt == 0 || ob.createAt > lastAt){\n', '                    lastAt = ob.createAt;\n', '                }\n', '                if( (now - ob.createAt) > PAY_TIME ){\n', '                    payOutCount ++;\n', '                }else{\n', '                   if(nextPayOutAt==0) nextPayOutAt = ob.createAt;\n', '                }\n', '                count++;\n', '            }\n', '        }\n', '         for( i=d.payedQueue.queueIdx.startIdx;i<d.payedQueue.getEnd();i++){\n', '            ob = d.payedQueue.map[i];  \n', '            if(ob.owner == msg.sender){\n', '                if(firstAt==0  ||  ob.createAt<firstAt){\n', '                    firstAt = ob.createAt;\n', '                }\n', '                if(lastAt == 0 || ob.createAt > lastAt){\n', '                    lastAt = ob.createAt;\n', '                }\n', '                payOutCount ++;\n', '                payedCount++;\n', '                count++;\n', '            }\n', '        }         \n', '         \n', '        firstAt = now - firstAt;\n', '        lastAt = now - lastAt;\n', '        nextPayOutAt = now - nextPayOutAt;\n', '    }\n', '\n', '    function buyBallWithReferrer(Data storage d,uint256 count,address owner,string referrer) internal returns (address,uint256) {\n', '        require(!d.playedMap[msg.sender] ,"it`s not play game player can apply referrer");\n', '        d.players.applyReferrer(referrer);\n', '        return buyBall(d,count,owner);\n', '    }\n', '    \n', '    function buyBall(Data storage d,uint256 count,address owner) internal returns (address,uint256) {\n', '        d.players.withdrawalFee(count *BALL_PRICE);\n', '        for(uint256 i=0;i<count;i++){\n', '            claimBall(d,owner);            \n', '        }\n', '        d.playedMap[owner] = true;\n', '        d.playBallCountMap[owner] += count;\n', '        d.players.transferAuthorAll();\n', '        toPayedBall(d);\n', '        toOutBall(d);\n', '        return setupAirdrop(d,owner,count);\n', '    }\n', '    \n', '\n', '    \n', '    function setupAirdrop(Data storage d,address owner,uint256 count) private returns(address winner,uint256 ammount)  {\n', '        if(d.blockCalled < block.number && d.adQueueIdx.size > 10){\n', '            winner = drawWinner(d);\n', '            if(winner != address(0)){\n', '                ammount = d.shortPrize;\n', '                d.players.deposit(msg.sender,d.shortPrize);\n', '                d.shortPrize = 0;\n', '            }\n', '            d.blockCalled = block.number + 3 + CommUtils.random(6,1);\n', '        }\n', '        d.ranHash =  blockhash(block.number);\n', '        offerAirdrop(d,owner,count);\n', '        \n', '    }\n', '    \n', '    function offerAirdrop(Data storage d,address owner , uint256 count) internal {\n', '        uint256 lastIdx= d.adQueueIdx.offer();\n', '        d.adOwnerMap[lastIdx] = owner;\n', '        d.adCountMap[lastIdx] = count;\n', '    }    \n', '    \n', '    function drawWinner(Data storage d) private returns(address owner) {\n', '        uint256 end = d.adQueueIdx.getWishEnd(QUEUE_BATCH_SIZE);\n', '        uint256 rmCount = 0;\n', '        uint256 ranV = random(d,1000);\n', '        for(uint256 i=d.adQueueIdx.startIdx;i<end;i++){\n', '            rmCount++;\n', '           uint256 threshold = d.adCountMap[i] * AIRDROP_RATE_1000 ;\n', '           if(threshold>ranV){\n', '               owner = d.adOwnerMap[i];\n', '               break;\n', '           }\n', '        }\n', '        (uint256 start,uint256 endB) = d.adQueueIdx.removeAtStart(rmCount);\n', '        for(uint256 j=start;j<endB;j++){\n', '            delete d.adCountMap[j];\n', '            delete d.adOwnerMap[j];\n', '        }\n', '    }\n', '    \n', '  \n', '    \n', '    function random(Data storage d,uint256 limit) internal view returns(uint256) {\n', '        bytes32 hash2 = blockhash(d.blockCalled);\n', '        bytes32 hash = keccak256(abi.encodePacked(d.ranHash, hash2));\n', '        uint256 ranV = uint256(hash) + CommUtils.random(now,5);\n', '        return ranV % limit;\n', '    }    \n', '    \n', '    function claimBall(Data storage d,address _owner) private{\n', '        Ball.Data memory b = Ball.Data({\n', '            index : uint64( d.currentIdx++),\n', '            owner : _owner,\n', '            outCount : 0,\n', '            createAt :uint64( now)\n', '        });\n', '        require(d.balls.length <= LIVE_BALL_COUNT ,"live ball is over 3");\n', '        if(d.balls.length <LIVE_BALL_COUNT){\n', '            d.balls[d.balls.length++] = b;\n', '        }else{\n', '            Ball.Data memory outb= lifo(d,b);\n', '            revive(d,outb);\n', '        }\n', '        distributeReward(d,_owner);\n', '        \n', '    }\n', '    \n', '    function distributeReward(Data storage d,address _owner) private {\n', '        d.players.depositAuthor(FEE);\n', '        d.players.depositAuthor(MAINTTAIN_FEE);\n', '        d.shortPrize += SHORT_PRIZE_PLUS;\n', '        address l1 = d.players.getReferrer(_owner);\n', '        if(l1 == address(0)){\n', '            d.players.depositAuthor(LEVEL_1_REWARD + LEVEL_2_REWARD + LEVEL_3_REWARD);\n', '            return ;\n', '        }\n', '        depositReferrer(d,l1,LEVEL_1_REWARD);\n', '        address l2 = d.players.getReferrer(l1);\n', '        if(l2 == address(0)){\n', '            d.players.depositAuthor( LEVEL_2_REWARD + LEVEL_3_REWARD);\n', '             return ;\n', '        }\n', '        depositReferrer(d,l2,LEVEL_2_REWARD);\n', '        address l3 = d.players.getReferrer(l2);\n', '        if(l3 == address(0)){\n', '            d.players.depositAuthor(  LEVEL_3_REWARD);\n', '            return;\n', '        }\n', '        depositReferrer(d,l3,LEVEL_3_REWARD);\n', '    }\n', '    \n', '    function depositReferrer(Data storage d,address a,uint256 v) private {\n', '        d.players.deposit(a,v);\n', '        d.referralbonusMap[a]+= v;\n', '    }\n', '    \n', '    function lifo(Data storage d,Ball.Data  inb) private returns(Ball.Data ans){\n', '        ans = d.balls.lifo(inb);\n', '        d.players.depositAuthor(FEE);\n', '        //d.players.deposit(ans.owner,PAY_AMMOUNT);\n', '    }\n', '    \n', '    \n', '    function revive(Data storage d,Ball.Data b) private{\n', '        require(b.outCount<=OUT_LIMT,"outCount>OUT_LIMT");\n', '         if(b.outCount==OUT_LIMT){\n', '            d.players.deposit(b.owner,PAY_PROFIT);\n', '            b.createAt = uint64(now);\n', '            //Ball.Data storage outP= d.outingBalls[d.outingBalls.length ++];\n', '            d.outingBalls.offer(b);\n', '            //outP.replace(b);\n', '        }else{\n', '            b.outCount ++;\n', '            b.index = uint64( d.currentIdx++);\n', '            Ball.Data memory newOut  = lifo(d,b);\n', '            revive(d,newOut);\n', '        }\n', '    }\n', '    \n', '    function registerName(Data storage d,string  name) internal  {\n', '        require(d.playedMap[msg.sender] ,"it`s  play game player can registerName");\n', '        require(msg.value >= 0.02 ether);\n', '        require(d.players.getName()=="");\n', '        d.players.registerName(name.nameFilter());\n', '    }    \n', '    \n', '    \n', '    function toOutBall(Data storage d) internal{\n', '        \n', '        uint256 end  = d.payedQueue.getWishEnd(QUEUE_BATCH_SIZE);\n', '        uint256 rmCount = 0;\n', '        for(uint256 i=d.payedQueue.queueIdx.startIdx;i<end;i++){\n', '            Ball.Data storage b = d.payedQueue.map[i];\n', '\n', '            if(now - b.createAt> OUT_TIME ){\n', '                address owner = b.owner;\n', '                d.playBallCountMap[owner]--;\n', '                rmCount++;\n', '                removePlayerBallEmpty(d,owner);\n', '            }\n', '        }\n', '        d.payedQueue.removeAtStart( rmCount);\n', '    }\n', '    \n', '    function toPayedBall(Data storage d) internal{\n', '        uint256 end = d.outingBalls.getWishEnd(QUEUE_BATCH_SIZE);\n', '        uint256 rmCount = 0;\n', '        for(uint256 i=d.outingBalls.queueIdx.startIdx;i<end;i++){\n', '            Ball.Data storage b = d.outingBalls.map[i];\n', '            if(now - b.createAt >= PAY_TIME ){\n', '                d.players.deposit(b.owner,BALL_PRICE);\n', '                rmCount++;\n', '                d.payedQueue.offer(b);\n', '            }\n', '        }   \n', '        d.outingBalls.removeAtStart(rmCount);\n', '    }\n', '    \n', '    function removePlayerBallEmpty(Data storage d,address addr) private{\n', '        uint256 allBallCount = d.playBallCountMap[addr] ;\n', '        if(allBallCount <= 0){\n', '            d.players.remove(addr);\n', '            delete d.playedMap[addr];\n', '        }\n', '    }\n', '    \n', '}\n', '\n', '\n', 'library Player{\n', '\n', '    using CommUtils for string;\n', '\n', '    address public constant AUTHOR =  0x001C9b3392f473f8f13e9Eaf0619c405AF22FC26a7;\n', '    address public constant DIRECTOR = 0x43beFdf21996f323E3cE6552452F11Efb7Dc1e7D;\n', '    address public constant DEV_BACKUP = 0x00e37c73dbe66e92149092a85be6c32e23251ed0af;\n', '    uint256 public constant AUTHOR_RATE = 8;\n', '    \n', '    struct Map{\n', '        mapping(address=>uint256) map;\n', '        mapping(address=>address) referrerMap;\n', '        mapping(address=>bytes32) addrNameMap;\n', '        mapping(bytes32=>address) nameAddrMap;\n', '    }\n', '    \n', '    function remove(Map storage ps,address adr) internal{\n', '        transferAuthor(ps,ps.map[adr]);\n', '        delete ps.map[adr];\n', '        bytes32 b = ps.addrNameMap[adr];\n', '        delete ps.nameAddrMap[b];\n', '        delete ps.addrNameMap[adr];\n', '    }\n', '    \n', '    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\n', '       ps.map[adr]+=v;\n', '        return v;\n', '    }\n', '\n', '    function isAdmin(address addr) internal pure returns (bool){\n', '        if(addr == AUTHOR) return true;\n', '        if(addr == DIRECTOR) return true;\n', '        if(addr == DEV_BACKUP) return true;\n', '        return false;\n', '    }\n', '\n', '    function depositAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\n', '        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\n', '        uint256 dFee =  v- devFee;\n', '        deposit(ps,AUTHOR,devFee);\n', '        deposit(ps,DIRECTOR,dFee);\n', '        return v;\n', '    }\n', '    \n', '    function transferAuthorAll(Map storage  ps) internal{\n', '        transferSafe(ps,AUTHOR, withdrawalAll(ps,AUTHOR));\n', '        transferSafe(ps,DIRECTOR, withdrawalAll(ps,DIRECTOR));\n', '    }\n', '    \n', '    function transferSafe(Map storage  ps,address addr,uint256 v) internal {\n', '        \n', '        if(address(this).balance>=v){\n', '            addr.transfer(v);\n', '        }else{\n', '            uint256 less = v - address(this).balance;\n', '            addr.transfer( address(this).balance);\n', '            deposit(ps,addr,less);\n', '        }\n', '    }\n', '    \n', '    //depositAuthor\n', '    function transferAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\n', '        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\n', '        uint256 dFee =  v- devFee;\n', '        transferSafe(ps,AUTHOR,devFee);\n', '        transferSafe(ps,DIRECTOR,dFee);\n', '        return v;\n', '    }\n', '\n', '    function minus(Map storage  ps,address adr,uint256 num) internal  {\n', '        uint256 sum = ps.map[adr];\n', '        if(sum==num){\n', '             withdrawalAll(ps,adr);\n', '        }else{\n', '            require(sum > num);\n', '            ps.map[adr] = sum-num;\n', '        }\n', '    }\n', '    \n', '    function minusAndTransfer(Map storage  ps,address adr,uint256 num) internal  {\n', '        minus(ps,adr,num);\n', '        transferSafe(ps,adr,num);\n', '    }    \n', '    \n', '    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\n', '        uint256 sum = ps.map[adr];\n', '        delete ps.map[adr];\n', '        return sum;\n', '    }\n', '    \n', '    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\n', '        return ps.map[adr];\n', '    }\n', '    \n', '    function registerName(Map storage ps,bytes32 _name)internal  {\n', '        require(ps.nameAddrMap[_name] == address(0) );\n', '        ps.nameAddrMap[_name] = msg.sender;\n', '        ps.addrNameMap[msg.sender] = _name;\n', '        depositAuthor(ps,msg.value);\n', '    }\n', '    \n', '    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\n', '        return ps.nameAddrMap[_name] == address(0);\n', '    }\n', '    \n', '    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\n', '        return ps.nameAddrMap[_name] ;\n', '    }\n', '    \n', '    function getName(Map storage ps) public view returns(bytes32){\n', '        return ps.addrNameMap[msg.sender];\n', '    }\n', '    \n', '    function getName(Map storage ps,address adr) public view returns(bytes32){\n', '        return ps.addrNameMap[adr];\n', '    }    \n', '    \n', '    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\n', '        return ps.addrNameMap[adr];\n', '    }    \n', '    \n', '    function getReferrer(Map storage ps,address adr)public view returns(address){\n', '        address refA = ps.referrerMap[adr];\n', '        bytes32 b= ps.addrNameMap[refA];\n', '        return b.length == 0 ? getReferrer(ps,refA) : refA;\n', '    }\n', '    \n', '    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\n', '        return getNameByAddr(ps,getReferrer(ps,adr));\n', '    }\n', '    \n', '    function setReferrer(Map storage ps,address self,address referrer)internal {\n', '         ps.referrerMap[self] = referrer;\n', '    }\n', '    \n', '    function applyReferrer(Map storage ps,string referrer)internal {\n', '        bytes32 rbs = referrer.nameFilter();\n', '        address referrerAdr = getByName(ps,rbs);\n', '        require(referrerAdr != address(0),"referrerAdr is null");\n', '        require(referrerAdr != msg.sender ,"referrerAdr is self ");\n', '        setReferrer(ps,msg.sender,referrerAdr);\n', '    }    \n', '    \n', '    function withdrawalFee(Map storage ps,uint256 fee) public returns (uint256){\n', '        if(msg.value > 0){\n', '            require(msg.value == fee,"msg.value != fee");\n', '            return fee;\n', '        }\n', '        require(getAmmount(ps,msg.sender)>=fee ,"players.getAmmount(msg.sender)<fee");\n', '        minus(ps,msg.sender,fee);\n', '        return fee;\n', '    }   \n', '    \n', '}']