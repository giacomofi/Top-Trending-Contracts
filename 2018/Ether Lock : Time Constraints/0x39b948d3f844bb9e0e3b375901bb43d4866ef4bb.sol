['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address owner) public constant returns (uint256 balance);\n', '  function transfer(address to, uint256 value) public returns (bool success);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', ' \n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256 remaining);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '  function approve(address spender, uint256 value) public returns (bool success);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '  using SafeMath for uint256;\n', ' \n', '  mapping (address => uint256) public balances;\n', ' \n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0)); \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', ' \n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0));\n', '    uint _allowance = allowed[_from][msg.sender];\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '      require (((_value == 0) || (allowed[msg.sender][_spender] == 0)) && _spender != address(this) && _spender != address(0));\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', ' \n', '}\n', '\n', 'contract UNICToken is owned, StandardToken {\n', '    \n', '  string public constant name = &#39;UNIC Token&#39;;\n', '  string public constant symbol = &#39;UNIC&#39;;\n', '  uint8 public constant decimals = 18;\n', '  uint256 public constant initialSupply = 250000000 * 10 ** uint256(decimals);\n', '\n', '  function UNICToken() public onlyOwner {\n', '    totalSupply = initialSupply;\n', '    balances[msg.sender] = initialSupply;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is owned, UNICToken {\n', '    \n', '  using SafeMath for uint;\n', '  \n', '  UNICToken public token = new UNICToken();\n', '\n', '  address constant multisig = 0x867570869f8a46c685A51EE87b5D979A6ef657A9;\n', '  uint constant rate = 3400;\n', '\n', '  uint256 public constant forSale = 55000000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleWhitelistDiscount = 40;\n', '  uint public presaleWhitelistTokensLimit = 750000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleStart = 1520503200;           /** 08.03 */\n', '  uint public constant presaleEnd = 1521453600;             /** 19.03 */\n', '  uint public constant presaleDiscount = 30;\n', '  uint public presaleTokensLimit = 5000000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant firstRoundICOStart = 1522317600;      /** 29.03 */\n', '  uint public constant firstRoundICOEnd = 1523527200;        /** 12.04 */\n', '  uint public constant firstRoundICODiscount = 20;\n', '  uint public firstRoundICOTokensLimit = 6250000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant secondRoundICOStart = 1524736800;     /** 26.04 */\n', '  uint public constant secondRoundICOEnd = 1526551200;       /** 17.05 */\n', '  uint public constant secondRoundICODiscount = 10;\n', '  uint public secondRoundICOTokensLimit = 43750000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleFemaleStart = 1520467200;       /** 08.03 */\n', '  uint public constant presaleFemaleEnd = 1520553600;         /** 09.03 */\n', '  uint public constant presaleFemaleDiscount = 88;\n', '  uint public presaleFemaleTokensLimit = 88888 * 10 ** uint256(decimals);  \n', '\n', '  uint public constant presalePiStart = 1520985600;           /** 14.03 The day of number PI */\n', '  uint public constant presalePiEnd = 1521072000;             /** 15.03 */\n', '  uint public constant presalePiDiscount = 34;\n', '  uint public presalePiTokensLimit = 31415926535897932384626;\n', '\n', '  uint public constant firstRoundWMStart = 1522800000;           /** 04.04 The Day of webmaster 404 */\n', '  uint public constant firstRoundWMEnd = 1522886400;             /** 05.04 */\n', '  uint public constant firstRoundWMDiscount = 25;\n', '  uint public firstRoundWMTokensLimit = 404404 * 10 ** uint256(decimals);\n', '\n', '  uint public constant firstRoundCosmosStart = 1523491200;       /** 12.04 The day of cosmonautics */\n', '  uint public constant firstRoundCosmosEnd = 1523577600;         /** 13.04 */\n', '  uint public constant firstRoundCosmosDiscount = 25;\n', '  uint public firstRoundCosmosTokensLimit = 121961 * 10 ** uint256(decimals);\n', '\n', '  uint public constant secondRoundMayStart = 1525132800;          /** 01.05 International Solidarity Day for Workers */\n', '  uint public constant secondRoundMayEnd = 1525219200;            /** 02.05 */\n', '  uint public constant secondRoundMayDiscount = 15;\n', '  uint public secondRoundMayTokensLimit = 1111111 * 10 ** uint256(decimals);\n', '\n', '  uint public etherRaised = 0;\n', '  uint public tokensSold = 0;\n', '\n', '  address public icoManager;\n', '    \n', '  mapping (address => bool) public WhiteList;\n', '  mapping (address => bool) public Females;\n', '\n', '  mapping (address => bool) public KYC1;\n', '  mapping (address => bool) public KYC2;\n', '  mapping (address => uint256) public KYCLimit;\n', '  uint256 public constant KYCLimitValue = 1.5 ether;\n', '\n', '  modifier onlyManager() {\n', '    require(msg.sender == icoManager);\n', '    _;\n', '  }\n', '\n', '  function setICOManager(address _newIcoManager) public onlyOwner returns (bool) {\n', '    require(_newIcoManager != address(0));\n', '    icoManager = _newIcoManager;\n', '    return true;\n', '  }\n', '\n', '  function massPay(address[] dests, uint256 value) public onlyOwner returns (bool) {\n', '    uint256 i = 0;\n', '    uint256 toSend = value * 10 ** uint256(decimals);\n', '    while (i < dests.length) {\n', '      if(dests[i] != address(0)){\n', '        transfer(dests[i], toSend);\n', '      }\n', '      i++;\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function Crowdsale() public onlyOwner {\n', '    token = UNICToken(this);\n', '    balances[msg.sender] = balances[msg.sender].sub(forSale);\n', '    balances[token] = balances[token].add(forSale);\n', '  }\n', '\n', '  function setParams(address[] dests, uint _type) internal {\n', '    uint256 i = 0;\n', '    while (i < dests.length) {\n', '      if(dests[i] != address(0)){\n', '        if(_type==1){\n', '          WhiteList[dests[i]] = true;\n', '        }else if(_type==2){\n', '          Females[dests[i]] = true;\n', '        }else if(_type==3){\n', '          KYC1[dests[i]] = true;\n', '          KYCLimit[dests[i]] = KYCLimitValue;\n', '        }else if(_type==4){\n', '          KYC2[dests[i]] = true;\n', '        }\n', '      }\n', '      i++;\n', '    }\n', '  } \n', '\n', '  function setWhiteList(address[] dests) onlyManager external {\n', '    setParams(dests, 1);\n', '  }\n', '\n', '  function setFemaleBonus(address[] dests) onlyManager external {\n', '    setParams(dests, 2);\n', '  }\n', '\n', '  function setKYCLimited(address[] dests) onlyManager external {\n', '    setParams(dests, 3);\n', '  }\n', '\n', '  function setKYCFull(address[] dests) onlyManager external {\n', '    setParams(dests, 4);\n', '  }\n', '\n', '  function isPresale() internal view returns (bool) {\n', '    return now >= presaleStart && now <= presaleEnd;\n', '  }\n', '\n', '  function isFirstRound() internal view returns (bool) {\n', '    return now >= firstRoundICOStart && now <= firstRoundICOEnd;\n', '  }\n', '\n', '  function isSecondRound() internal view returns (bool) {\n', '    return now >= secondRoundICOStart && now <= secondRoundICOEnd;\n', '  }\n', '\n', '  modifier saleIsOn() {\n', '    require(isPresale() || isFirstRound() || isSecondRound());\n', '    _;\n', '  }\n', '\n', '  function isFemaleSale() internal view returns (bool) {\n', '    return now >= presaleFemaleStart && now <= presaleFemaleEnd;\n', '  }\n', '\n', '  function isPiSale() internal view returns (bool) {\n', '    return now >= presalePiStart && now <= presalePiEnd;\n', '  }\n', '\n', '  function isWMSale() internal view returns (bool) {\n', '    return now >= firstRoundWMStart && now <= firstRoundWMEnd;\n', '  }\n', '\n', '  function isCosmosSale() internal view returns (bool) {\n', '    return now >= firstRoundCosmosStart && now <= firstRoundCosmosEnd;\n', '  }\n', '\n', '  function isMaySale() internal view returns (bool) {\n', '    return now >= secondRoundMayStart && now <= secondRoundMayEnd;\n', '  }\n', '\n', '  function discount(uint _discount, uint _limit, uint _saleLimit, uint _value, uint _defultDiscount) internal pure returns(uint){\n', '    uint tmpDiscount = _value.mul(_discount).div(100);\n', '    uint newValue = _value.add(tmpDiscount);\n', '    if(_limit >= newValue && _saleLimit >= newValue) {\n', '      return tmpDiscount;\n', '    }else{\n', '      return _defultDiscount;\n', '    }\n', '  }\n', '\n', '  function() external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _buyer) saleIsOn public payable {\n', '    assert((_buyer != address(0) && msg.value > 0 && ((KYC1[_buyer] && msg.value < KYCLimitValue) || KYC2[_buyer])));\n', '    assert((KYC2[_buyer] || (KYC1[_buyer] && msg.value < KYCLimit[_buyer])));\n', '\n', '    uint tokens = rate.mul(msg.value);\n', '    uint discountTokens = 0;\n', '    \n', '    if (isPresale()) {\n', '\n', '      discountTokens = discount(presaleDiscount, presaleTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '\n', '      if(isFemaleSale() && Females[_buyer]) {\n', '        discountTokens = discount(presaleFemaleDiscount, presaleFemaleTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(WhiteList[_buyer]) {\n', '        discountTokens = discount(presaleWhitelistDiscount, presaleWhitelistTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(isPiSale()) {\n', '        discountTokens = discount(presalePiDiscount, presalePiTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '\n', '    } else if (isFirstRound()) {\n', '\n', '      discountTokens = discount(firstRoundICODiscount, firstRoundICOTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '\n', '      if(isCosmosSale()) {\n', '        discountTokens = discount(firstRoundCosmosDiscount, firstRoundCosmosTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(isWMSale()) {\n', '        discountTokens = discount(firstRoundWMDiscount, firstRoundWMTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '      } \n', '\n', '    } else if (isSecondRound()) {\n', '\n', '      discountTokens = discount(secondRoundICODiscount, secondRoundICOTokensLimit, secondRoundICOTokensLimit, tokens, discountTokens);\n', '\n', '      if(isMaySale()) {\n', '        discountTokens = discount(secondRoundMayDiscount, secondRoundMayTokensLimit, secondRoundICOTokensLimit, tokens, discountTokens);\n', '      }\n', '\n', '    }\n', '        \n', '    uint tokensWithBonus = tokens.add(discountTokens);\n', '      \n', '    if((isPresale() && presaleTokensLimit >= tokensWithBonus) ||\n', '      (isFirstRound() && firstRoundICOTokensLimit >=  tokensWithBonus) ||\n', '      (isSecondRound() && secondRoundICOTokensLimit >= tokensWithBonus)){\n', '      \n', '      multisig.transfer(msg.value);\n', '      etherRaised = etherRaised.add(msg.value);\n', '      token.transfer(msg.sender, tokensWithBonus);\n', '      tokensSold = tokensSold.add(tokensWithBonus);\n', '\n', '      if(KYC1[_buyer]){\n', '        KYCLimit[_buyer] = KYCLimit[_buyer].sub(msg.value);\n', '      }\n', '\n', '      if (isPresale()) {\n', '        \n', '        presaleTokensLimit = presaleTokensLimit.sub(tokensWithBonus);\n', '        \n', '        if(WhiteList[_buyer]) {\n', '          presaleWhitelistTokensLimit = presaleWhitelistTokensLimit.sub(tokensWithBonus);\n', '        }\n', '      \n', '        if(isFemaleSale() && Females[_buyer]) {\n', '          presaleFemaleTokensLimit = presaleFemaleTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '        if(isPiSale()) {\n', '          presalePiTokensLimit = presalePiTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      } else if (isFirstRound()) {\n', '\n', '        firstRoundICOTokensLimit = firstRoundICOTokensLimit.sub(tokensWithBonus);\n', '        \n', '        if(isWMSale()) {\n', '          firstRoundWMTokensLimit = firstRoundWMTokensLimit.sub(tokensWithBonus);\n', '        }\n', '      \n', '        if(isCosmosSale()) {\n', '          firstRoundCosmosTokensLimit = firstRoundCosmosTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      } else if (isSecondRound()) {\n', '\n', '        secondRoundICOTokensLimit = secondRoundICOTokensLimit.sub(tokensWithBonus);\n', '\n', '        if(isMaySale()) {\n', '          secondRoundMayTokensLimit = secondRoundMayTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      }\n', '\n', '    }\n', '\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address owner) public constant returns (uint256 balance);\n', '  function transfer(address to, uint256 value) public returns (bool success);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', ' \n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256 remaining);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '  function approve(address spender, uint256 value) public returns (bool success);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '  using SafeMath for uint256;\n', ' \n', '  mapping (address => uint256) public balances;\n', ' \n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0)); \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', ' \n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0));\n', '    uint _allowance = allowed[_from][msg.sender];\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '      require (((_value == 0) || (allowed[msg.sender][_spender] == 0)) && _spender != address(this) && _spender != address(0));\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', ' \n', '}\n', '\n', 'contract UNICToken is owned, StandardToken {\n', '    \n', "  string public constant name = 'UNIC Token';\n", "  string public constant symbol = 'UNIC';\n", '  uint8 public constant decimals = 18;\n', '  uint256 public constant initialSupply = 250000000 * 10 ** uint256(decimals);\n', '\n', '  function UNICToken() public onlyOwner {\n', '    totalSupply = initialSupply;\n', '    balances[msg.sender] = initialSupply;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is owned, UNICToken {\n', '    \n', '  using SafeMath for uint;\n', '  \n', '  UNICToken public token = new UNICToken();\n', '\n', '  address constant multisig = 0x867570869f8a46c685A51EE87b5D979A6ef657A9;\n', '  uint constant rate = 3400;\n', '\n', '  uint256 public constant forSale = 55000000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleWhitelistDiscount = 40;\n', '  uint public presaleWhitelistTokensLimit = 750000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleStart = 1520503200;           /** 08.03 */\n', '  uint public constant presaleEnd = 1521453600;             /** 19.03 */\n', '  uint public constant presaleDiscount = 30;\n', '  uint public presaleTokensLimit = 5000000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant firstRoundICOStart = 1522317600;      /** 29.03 */\n', '  uint public constant firstRoundICOEnd = 1523527200;        /** 12.04 */\n', '  uint public constant firstRoundICODiscount = 20;\n', '  uint public firstRoundICOTokensLimit = 6250000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant secondRoundICOStart = 1524736800;     /** 26.04 */\n', '  uint public constant secondRoundICOEnd = 1526551200;       /** 17.05 */\n', '  uint public constant secondRoundICODiscount = 10;\n', '  uint public secondRoundICOTokensLimit = 43750000 * 10 ** uint256(decimals);\n', '\n', '  uint public constant presaleFemaleStart = 1520467200;       /** 08.03 */\n', '  uint public constant presaleFemaleEnd = 1520553600;         /** 09.03 */\n', '  uint public constant presaleFemaleDiscount = 88;\n', '  uint public presaleFemaleTokensLimit = 88888 * 10 ** uint256(decimals);  \n', '\n', '  uint public constant presalePiStart = 1520985600;           /** 14.03 The day of number PI */\n', '  uint public constant presalePiEnd = 1521072000;             /** 15.03 */\n', '  uint public constant presalePiDiscount = 34;\n', '  uint public presalePiTokensLimit = 31415926535897932384626;\n', '\n', '  uint public constant firstRoundWMStart = 1522800000;           /** 04.04 The Day of webmaster 404 */\n', '  uint public constant firstRoundWMEnd = 1522886400;             /** 05.04 */\n', '  uint public constant firstRoundWMDiscount = 25;\n', '  uint public firstRoundWMTokensLimit = 404404 * 10 ** uint256(decimals);\n', '\n', '  uint public constant firstRoundCosmosStart = 1523491200;       /** 12.04 The day of cosmonautics */\n', '  uint public constant firstRoundCosmosEnd = 1523577600;         /** 13.04 */\n', '  uint public constant firstRoundCosmosDiscount = 25;\n', '  uint public firstRoundCosmosTokensLimit = 121961 * 10 ** uint256(decimals);\n', '\n', '  uint public constant secondRoundMayStart = 1525132800;          /** 01.05 International Solidarity Day for Workers */\n', '  uint public constant secondRoundMayEnd = 1525219200;            /** 02.05 */\n', '  uint public constant secondRoundMayDiscount = 15;\n', '  uint public secondRoundMayTokensLimit = 1111111 * 10 ** uint256(decimals);\n', '\n', '  uint public etherRaised = 0;\n', '  uint public tokensSold = 0;\n', '\n', '  address public icoManager;\n', '    \n', '  mapping (address => bool) public WhiteList;\n', '  mapping (address => bool) public Females;\n', '\n', '  mapping (address => bool) public KYC1;\n', '  mapping (address => bool) public KYC2;\n', '  mapping (address => uint256) public KYCLimit;\n', '  uint256 public constant KYCLimitValue = 1.5 ether;\n', '\n', '  modifier onlyManager() {\n', '    require(msg.sender == icoManager);\n', '    _;\n', '  }\n', '\n', '  function setICOManager(address _newIcoManager) public onlyOwner returns (bool) {\n', '    require(_newIcoManager != address(0));\n', '    icoManager = _newIcoManager;\n', '    return true;\n', '  }\n', '\n', '  function massPay(address[] dests, uint256 value) public onlyOwner returns (bool) {\n', '    uint256 i = 0;\n', '    uint256 toSend = value * 10 ** uint256(decimals);\n', '    while (i < dests.length) {\n', '      if(dests[i] != address(0)){\n', '        transfer(dests[i], toSend);\n', '      }\n', '      i++;\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function Crowdsale() public onlyOwner {\n', '    token = UNICToken(this);\n', '    balances[msg.sender] = balances[msg.sender].sub(forSale);\n', '    balances[token] = balances[token].add(forSale);\n', '  }\n', '\n', '  function setParams(address[] dests, uint _type) internal {\n', '    uint256 i = 0;\n', '    while (i < dests.length) {\n', '      if(dests[i] != address(0)){\n', '        if(_type==1){\n', '          WhiteList[dests[i]] = true;\n', '        }else if(_type==2){\n', '          Females[dests[i]] = true;\n', '        }else if(_type==3){\n', '          KYC1[dests[i]] = true;\n', '          KYCLimit[dests[i]] = KYCLimitValue;\n', '        }else if(_type==4){\n', '          KYC2[dests[i]] = true;\n', '        }\n', '      }\n', '      i++;\n', '    }\n', '  } \n', '\n', '  function setWhiteList(address[] dests) onlyManager external {\n', '    setParams(dests, 1);\n', '  }\n', '\n', '  function setFemaleBonus(address[] dests) onlyManager external {\n', '    setParams(dests, 2);\n', '  }\n', '\n', '  function setKYCLimited(address[] dests) onlyManager external {\n', '    setParams(dests, 3);\n', '  }\n', '\n', '  function setKYCFull(address[] dests) onlyManager external {\n', '    setParams(dests, 4);\n', '  }\n', '\n', '  function isPresale() internal view returns (bool) {\n', '    return now >= presaleStart && now <= presaleEnd;\n', '  }\n', '\n', '  function isFirstRound() internal view returns (bool) {\n', '    return now >= firstRoundICOStart && now <= firstRoundICOEnd;\n', '  }\n', '\n', '  function isSecondRound() internal view returns (bool) {\n', '    return now >= secondRoundICOStart && now <= secondRoundICOEnd;\n', '  }\n', '\n', '  modifier saleIsOn() {\n', '    require(isPresale() || isFirstRound() || isSecondRound());\n', '    _;\n', '  }\n', '\n', '  function isFemaleSale() internal view returns (bool) {\n', '    return now >= presaleFemaleStart && now <= presaleFemaleEnd;\n', '  }\n', '\n', '  function isPiSale() internal view returns (bool) {\n', '    return now >= presalePiStart && now <= presalePiEnd;\n', '  }\n', '\n', '  function isWMSale() internal view returns (bool) {\n', '    return now >= firstRoundWMStart && now <= firstRoundWMEnd;\n', '  }\n', '\n', '  function isCosmosSale() internal view returns (bool) {\n', '    return now >= firstRoundCosmosStart && now <= firstRoundCosmosEnd;\n', '  }\n', '\n', '  function isMaySale() internal view returns (bool) {\n', '    return now >= secondRoundMayStart && now <= secondRoundMayEnd;\n', '  }\n', '\n', '  function discount(uint _discount, uint _limit, uint _saleLimit, uint _value, uint _defultDiscount) internal pure returns(uint){\n', '    uint tmpDiscount = _value.mul(_discount).div(100);\n', '    uint newValue = _value.add(tmpDiscount);\n', '    if(_limit >= newValue && _saleLimit >= newValue) {\n', '      return tmpDiscount;\n', '    }else{\n', '      return _defultDiscount;\n', '    }\n', '  }\n', '\n', '  function() external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _buyer) saleIsOn public payable {\n', '    assert((_buyer != address(0) && msg.value > 0 && ((KYC1[_buyer] && msg.value < KYCLimitValue) || KYC2[_buyer])));\n', '    assert((KYC2[_buyer] || (KYC1[_buyer] && msg.value < KYCLimit[_buyer])));\n', '\n', '    uint tokens = rate.mul(msg.value);\n', '    uint discountTokens = 0;\n', '    \n', '    if (isPresale()) {\n', '\n', '      discountTokens = discount(presaleDiscount, presaleTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '\n', '      if(isFemaleSale() && Females[_buyer]) {\n', '        discountTokens = discount(presaleFemaleDiscount, presaleFemaleTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(WhiteList[_buyer]) {\n', '        discountTokens = discount(presaleWhitelistDiscount, presaleWhitelistTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(isPiSale()) {\n', '        discountTokens = discount(presalePiDiscount, presalePiTokensLimit, presaleTokensLimit, tokens, discountTokens);\n', '      }\n', '\n', '    } else if (isFirstRound()) {\n', '\n', '      discountTokens = discount(firstRoundICODiscount, firstRoundICOTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '\n', '      if(isCosmosSale()) {\n', '        discountTokens = discount(firstRoundCosmosDiscount, firstRoundCosmosTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '      }\n', '      if(isWMSale()) {\n', '        discountTokens = discount(firstRoundWMDiscount, firstRoundWMTokensLimit, firstRoundICOTokensLimit, tokens, discountTokens);\n', '      } \n', '\n', '    } else if (isSecondRound()) {\n', '\n', '      discountTokens = discount(secondRoundICODiscount, secondRoundICOTokensLimit, secondRoundICOTokensLimit, tokens, discountTokens);\n', '\n', '      if(isMaySale()) {\n', '        discountTokens = discount(secondRoundMayDiscount, secondRoundMayTokensLimit, secondRoundICOTokensLimit, tokens, discountTokens);\n', '      }\n', '\n', '    }\n', '        \n', '    uint tokensWithBonus = tokens.add(discountTokens);\n', '      \n', '    if((isPresale() && presaleTokensLimit >= tokensWithBonus) ||\n', '      (isFirstRound() && firstRoundICOTokensLimit >=  tokensWithBonus) ||\n', '      (isSecondRound() && secondRoundICOTokensLimit >= tokensWithBonus)){\n', '      \n', '      multisig.transfer(msg.value);\n', '      etherRaised = etherRaised.add(msg.value);\n', '      token.transfer(msg.sender, tokensWithBonus);\n', '      tokensSold = tokensSold.add(tokensWithBonus);\n', '\n', '      if(KYC1[_buyer]){\n', '        KYCLimit[_buyer] = KYCLimit[_buyer].sub(msg.value);\n', '      }\n', '\n', '      if (isPresale()) {\n', '        \n', '        presaleTokensLimit = presaleTokensLimit.sub(tokensWithBonus);\n', '        \n', '        if(WhiteList[_buyer]) {\n', '          presaleWhitelistTokensLimit = presaleWhitelistTokensLimit.sub(tokensWithBonus);\n', '        }\n', '      \n', '        if(isFemaleSale() && Females[_buyer]) {\n', '          presaleFemaleTokensLimit = presaleFemaleTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '        if(isPiSale()) {\n', '          presalePiTokensLimit = presalePiTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      } else if (isFirstRound()) {\n', '\n', '        firstRoundICOTokensLimit = firstRoundICOTokensLimit.sub(tokensWithBonus);\n', '        \n', '        if(isWMSale()) {\n', '          firstRoundWMTokensLimit = firstRoundWMTokensLimit.sub(tokensWithBonus);\n', '        }\n', '      \n', '        if(isCosmosSale()) {\n', '          firstRoundCosmosTokensLimit = firstRoundCosmosTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      } else if (isSecondRound()) {\n', '\n', '        secondRoundICOTokensLimit = secondRoundICOTokensLimit.sub(tokensWithBonus);\n', '\n', '        if(isMaySale()) {\n', '          secondRoundMayTokensLimit = secondRoundMayTokensLimit.sub(tokensWithBonus);\n', '        }\n', '\n', '      }\n', '\n', '    }\n', '\n', '  }\n', '\n', '}']
