['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Autonomy is Ownable {\n', '    address public congress;\n', '    bool init = false;\n', '\n', '    modifier onlyCongress() {\n', '        require(msg.sender == congress);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev initialize a Congress contract address for this token \n', '     *\n', '     * @param _congress address the congress contract address\n', '     */\n', '    function initialCongress(address _congress) onlyOwner public {\n', '        require(!init);\n', '        require(_congress != address(0));\n', '        congress = _congress;\n', '        init = true;\n', '    }\n', '\n', '    /**\n', '     * @dev set a Congress contract address for this token\n', '     * must change this address by the last congress contract \n', '     *\n', '     * @param _congress address the congress contract address\n', '     */\n', '    function changeCongress(address _congress) onlyCongress public {\n', '        require(_congress != address(0));\n', '        congress = _congress;\n', '    }\n', '}\n', '\n', 'contract withdrawable is Ownable {\n', '    event ReceiveEther(address _from, uint256 _value);\n', '    event WithdrawEther(address _to, uint256 _value);\n', '    event WithdrawToken(address _token, address _to, uint256 _value);\n', '\n', '    /**\n', '\t * @dev recording receiving ether from msn.sender\n', '\t */\n', '    function () payable public {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw,send ether to target\n', '\t * @param _to is where the ether will be sent to\n', '\t *        _amount is the number of the ether\n', '\t */\n', '    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        _to.transfer(_amount);\n', '        emit WithdrawEther(_to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '\t * @param _to is where the tokens will be sent to\n', '\t *        _value is the number of the token\n', '\t */\n', '    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        tk.transfer(_to, _value);\n', '        emit WithdrawToken(_token, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, and then gain the tokens, \n', '     *      then take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '    //     require(_token != address(0));\n', '    //     require(_from != address(0));\n', '        \n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.transferFrom(_from, this, _value));\n', '        \n', '    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    // }\n', '}\n', '\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', 'contract TokenDestructible is Ownable {\n', '\n', '  function TokenDestructible() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\n', '   refund.\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy(address[] tokens) onlyOwner public {\n', '\n', '    // Transfer tokens to owner\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      ERC20Basic token = ERC20Basic(tokens[i]);\n', '      uint256 balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '    }\n', '\n', '    // Transfer Eth to owner and terminate contract\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract OwnerContract is Claimable {\n', '    Claimable public ownedContract;\n', '    address internal origOwner;\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        ownedContract.claimOwnership();\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one. \n', '     *\n', '     */\n', '    function transferOwnershipBack() onlyOwner public {\n', '        ownedContract.transferOwnership(origOwner);\n', '        ownedContract = Claimable(address(0));\n', '        origOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one. \n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnershipto(address _nextOwner)  onlyOwner public {\n', '        ownedContract.transferOwnership(_nextOwner);\n', '        ownedContract = Claimable(address(0));\n', '        origOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract DepositWithdraw is Claimable, withdrawable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * transaction record\n', '     */\n', '    struct TransferRecord {\n', '        uint256 timeStamp;\n', '        address account;\n', '        uint256 value;\n', '    }\n', '    \n', '    /**\n', '     * accumulated transferring amount record\n', '     */\n', '    struct accumulatedRecord {\n', '        uint256 mul;\n', '        uint256 count;\n', '        uint256 value;\n', '    }\n', '\n', '    TransferRecord[] deposRecs; // record all the deposit tx data\n', '    TransferRecord[] withdrRecs; // record all the withdraw tx data\n', '\n', '    accumulatedRecord dayWithdrawRec; // accumulated amount record for one day\n', '    accumulatedRecord monthWithdrawRec; // accumulated amount record for one month\n', '\n', '    address wallet; // the binded withdraw address\n', '\n', '    event ReceiveDeposit(address _from, uint256 _value, address _token, bytes _extraData);\n', '    \n', '    /**\n', '     * @dev constructor of the DepositWithdraw contract\n', '     * @param _wallet the binded wallet address to this depositwithdraw contract\n', '     */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '\t * @dev set the default wallet address\n', '\t * @param _wallet the default wallet address binded to this deposit contract\n', '\t */\n', '    function setWithdrawWallet(address _wallet) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev util function to change bytes data to bytes32 data\n', '\t * @param _data the bytes data to be converted\n', '\t */\n', '    function bytesToBytes32(bytes _data) public pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(_data, 32))\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) onlyOwner public {\n', '        require(_token != address(0));\n', '        require(_from != address(0));\n', '        \n', '        ERC20 tk = ERC20(_token);\n', '        require(tk.transferFrom(_from, this, _value));\n', '        bytes32 timestamp = bytesToBytes32(_extraData);\n', '        deposRecs.push(TransferRecord(uint256(timestamp), _from, _value));\n', '        emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timstamp of the withdraw time\n', '\t * @param _to is where the tokens will be sent to\n', '\t *        _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        _tokenReturn is the address that return back the tokens of the _fee\n', '\t */\n', '    function withdrawToken(address _token, address _params, uint256 _time, address _to, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '        require(_value > _fee);\n', '        // require(_tokenReturn != address(0));\n', '\n', '        DRCWalletMgrParams params = DRCWalletMgrParams(_params);\n', '        require(_value <= params.singleWithdrawMax());\n', '        require(_value >= params.singleWithdrawMin());\n', '\n', '        uint256 daysCount = _time.div(86400); // one day of seconds\n', '        if (daysCount <= dayWithdrawRec.mul) {\n', '            dayWithdrawRec.count = dayWithdrawRec.count.add(1);\n', '            dayWithdrawRec.value = dayWithdrawRec.value.add(_value);\n', '            require(dayWithdrawRec.count <= params.dayWithdrawCount());\n', '            require(dayWithdrawRec.value <= params.dayWithdraw());\n', '        } else {\n', '            dayWithdrawRec.mul = daysCount;\n', '            dayWithdrawRec.count = 1;\n', '            dayWithdrawRec.value = _value;\n', '        }\n', '        \n', '        uint256 monthsCount = _time.div(86400 * 30);\n', '        if (monthsCount <= monthWithdrawRec.mul) {\n', '            monthWithdrawRec.count = monthWithdrawRec.count.add(1);\n', '            monthWithdrawRec.value = monthWithdrawRec.value.add(_value);\n', '            require(monthWithdrawRec.value <= params.monthWithdraw());\n', '        } else {            \n', '            monthWithdrawRec.mul = monthsCount;\n', '            monthWithdrawRec.count = 1;\n', '            monthWithdrawRec.value = _value;\n', '        }\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        uint256 realAmount = _value.sub(_fee);\n', '        require(tk.transfer(_to, realAmount));\n', '        if (_tokenReturn != address(0) && _fee > 0) {\n', '            require(tk.transfer(_tokenReturn, _fee));\n', '        }\n', '\n', '        withdrRecs.push(TransferRecord(_time, _to, realAmount));\n', '        emit WithdrawToken(_token, _to, realAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target default wallet\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timestamp occur the withdraw record\n', '\t * @param _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        —tokenReturn is the address that return back the tokens of the _fee\n', '\t */\n', '    function withdrawTokenToDefault(address _token, address _params, uint256 _time, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        return withdrawToken(_token, _params, _time, wallet, _value, _fee, _tokenReturn);\n', '    }\n', '\n', '    /**\n', '\t * @dev get the Deposit records number\n', '     *\n', '     */\n', '    function getDepositNum() public view returns (uint256) {\n', '        return deposRecs.length;\n', '    }\n', '\n', '    /**\n', '\t * @dev get the one of the Deposit records\n', '     *\n', '     * @param _ind the deposit record index\n', '     */\n', '    function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < deposRecs.length);\n', '\n', '        return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value);\n', '    }\n', '\n', '    /**\n', '\t * @dev get the withdraw records number\n', '     *\n', '     */\n', '    function getWithdrawNum() public view returns (uint256) {\n', '        return withdrRecs.length;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the one of the withdraw records\n', '     *\n', '     * @param _ind the withdraw record index\n', '     */\n', '    function getOneWithdrawRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < withdrRecs.length);\n', '\n', '        return (withdrRecs[_ind].timeStamp, withdrRecs[_ind].account, withdrRecs[_ind].value);\n', '    }\n', '}\n', '\n', 'contract DRCWalletManager is OwnerContract, withdrawable, Destructible, TokenDestructible {\n', '    using SafeMath for uint256;\n', '    \n', '    /**\n', '     * withdraw wallet description\n', '     */\n', '    struct WithdrawWallet {\n', '        bytes32 name;\n', '        address walletAddr;\n', '    }\n', '\n', '    /**\n', '     * Deposit data storage\n', '     */\n', '    struct DepositRepository {\n', '        // uint256 balance;\n', '        uint256 frozen;\n', '        WithdrawWallet[] withdrawWallets;\n', '        // mapping (bytes32 => address) withdrawWallets;\n', '    }\n', '\n', '    mapping (address => DepositRepository) depositRepos;\n', '    mapping (address => address) walletDeposits;\n', '    mapping (address => bool) public frozenDeposits;\n', '\n', '    ERC20 public tk; // the token will be managed\n', '    DRCWalletMgrParams params; // the parameters that the management needs\n', '    \n', '    event CreateDepositAddress(address indexed _wallet, address _deposit);\n', '    event FrozenTokens(address indexed _deposit, uint256 _value);\n', '    event ChangeDefaultWallet(address indexed _oldWallet, address _newWallet);\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target default wallet\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _walletParams the wallet management parameters\n', '\t */\n', '    function bindToken(address _token, address _walletParams) onlyOwner public returns (bool) {\n', '        require(_token != address(0));\n', '        require(_walletParams != address(0));\n', '\n', '        tk = ERC20(_token);\n', '        params = DRCWalletMgrParams(_walletParams);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev create deposit contract address for the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '\t */\n', '    function createDepositContract(address _wallet) onlyOwner public returns (address) {\n', '        require(_wallet != address(0));\n', '\n', '        DepositWithdraw deposWithdr = new DepositWithdraw(_wallet); // new contract for deposit\n', '        address _deposit = address(deposWithdr);\n', '        walletDeposits[_wallet] = _deposit;\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        withdrawWalletList.push(WithdrawWallet("default wallet", _wallet));\n', '        // depositRepos[_deposit].balance = 0;\n', '        depositRepos[_deposit].frozen = 0;\n', '\n', '        emit CreateDepositAddress(_wallet, address(deposWithdr));\n', '        return deposWithdr;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get deposit contract address by using the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '\t */\n', '    function getDepositAddress(address _wallet) onlyOwner public view returns (address) {\n', '        require(_wallet != address(0));\n', '        address deposit = walletDeposits[_wallet];\n', '\n', '        return deposit;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get deposit balance and frozen amount by using the deposit address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '\t */\n', '    function getDepositInfo(address _deposit) onlyOwner public view returns (uint256, uint256) {\n', '        require(_deposit != address(0));\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        uint256 frozenAmount = depositRepos[_deposit].frozen;\n', '        // depositRepos[_deposit].balance = _balance;\n', '\n', '        return (_balance, frozenAmount);\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the number of withdraw wallet addresses bindig to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '\t */\n', '    function getDepositWithdrawCount(address _deposit) onlyOwner public view returns (uint) {\n', '        require(_deposit != address(0));\n', '\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        uint len = withdrawWalletList.length;\n', '\n', '        return len;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the withdraw wallet addresses list binding to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '     * @param _indices the array of indices of the withdraw wallets\n', '\t */\n', '    function getDepositWithdrawList(address _deposit, uint[] _indices) onlyOwner public view returns (bytes32[], address[]) {\n', '        require(_indices.length != 0);\n', '\n', '        bytes32[] memory names = new bytes32[](_indices.length);\n', '        address[] memory wallets = new address[](_indices.length);\n', '        \n', '        for (uint i = 0; i < _indices.length; i = i.add(1)) {\n', '            WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[_indices[i]];\n', '            names[i] = wallet.name;\n', '            wallets[i] = wallet.walletAddr;\n', '        }\n', '        \n', '        return (names, wallets);\n', '    }\n', '    \n', '    /**\n', '\t * @dev change the default withdraw wallet address binding to the deposit contract address\n', '     *\n', '     * @param _oldWallet the previous default withdraw wallet\n', '     * @param _newWallet the new default withdraw wallet\n', '\t */\n', '    function changeDefaultWithdraw(address _oldWallet, address _newWallet) onlyOwner public returns (bool) {\n', '        require(_newWallet != address(0));\n', '        \n', '        address deposit = walletDeposits[_oldWallet];\n', '        DepositWithdraw deposWithdr = DepositWithdraw(deposit);\n', '        require(deposWithdr.setWithdrawWallet(_newWallet));\n', '\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[deposit].withdrawWallets;\n', '        withdrawWalletList[0].walletAddr = _newWallet;\n', '        emit ChangeDefaultWallet(_oldWallet, _newWallet);\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev freeze the tokens in the deposit address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _value the amount of tokens need to be frozen\n', '\t */\n', '    function freezeTokens(address _deposit, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '        \n', '        frozenDeposits[_deposit] = true;\n', '        depositRepos[_deposit].frozen = _value;\n', '\n', '        emit FrozenTokens(_deposit, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev withdraw the tokens from the deposit address with charge fee\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _time the timestamp the withdraw occurs\n', '     * @param _value the amount of tokens need to be frozen\n', '\t */\n', '    function withdrawWithFee(address _deposit, uint256 _time, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        require(_value <= _balance);\n', '\n', '        // depositRepos[_deposit].balance = _balance;\n', '        uint256 frozenAmount = depositRepos[_deposit].frozen;\n', '        require(_value <= _balance.sub(frozenAmount));\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        return (deposWithdr.withdrawTokenToDefault(address(tk), address(params), _time, _value, params.chargeFee(), params.chargeFeePool()));\n', '    }\n', '    \n', '    /**\n', '\t * @dev check if the wallet name is not matching the expected wallet address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _name the withdraw wallet name\n', '     * @param _to the withdraw wallet address\n', '\t */\n', '    function checkWithdrawAddress(address _deposit, bytes32 _name, address _to) public view returns (bool, bool) {\n', '        uint len = depositRepos[_deposit].withdrawWallets.length;\n', '        for (uint i = 0; i < len; i = i.add(1)) {\n', '            WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[i];\n', '            if (_name == wallet.name) {\n', '                return(true, (_to == wallet.walletAddr));\n', '            }\n', '        }\n', '\n', '        return (false, true);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target withdraw wallet\n', '     *\n', '     * @param _deposit the deposit address that will be withdraw from\n', '     * @param _time the timestamp occur the withdraw record\n', '\t * @param _name the withdraw address alias name to verify\n', '     * @param _to the address the token will be transfer to \n', '     * @param _value the token transferred value\n', '     * @param _check if we will check the value is valid or meet the limit condition\n', '\t */\n', '    function withdrawWithFee(address _deposit, \n', '                             uint256 _time, \n', '                             bytes32 _name, \n', '                             address _to, \n', '                             uint256 _value, \n', '                             bool _check) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '        require(_to != address(0));\n', '\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        if (_check) {\n', '            require(_value <= _balance);\n', '        }\n', '\n', '        uint256 available = _balance.sub(depositRepos[_deposit].frozen);\n', '        if (_check) {\n', '            require(_value <= available);\n', '        }\n', '\n', '        bool exist;\n', '        bool correct;\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        (exist, correct) = checkWithdrawAddress(_deposit, _name, _to);\n', '        if(!exist) {\n', '            withdrawWalletList.push(WithdrawWallet(_name, _to));\n', '        } else if(!correct) {\n', '            return false;\n', '        }\n', '\n', '        if (!_check && _value > available) {\n', '            tk.transfer(_deposit, _value.sub(available));\n', '            // _value = _value.sub(available);\n', '        }\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        return (deposWithdr.withdrawToken(address(tk), address(params), _time, _to, _value, params.chargeFee(), params.chargeFeePool()));        \n', '    }\n', '\n', '}\n', '\n', 'contract DRCWalletMgrParams is Claimable, Autonomy, Destructible {\n', '    uint256 public singleWithdrawMin; // min value of single withdraw\n', '    uint256 public singleWithdrawMax; // Max value of single withdraw\n', '    uint256 public dayWithdraw; // Max value of one day of withdraw\n', '    uint256 public monthWithdraw; // Max value of one month of withdraw\n', '    uint256 public dayWithdrawCount; // Max number of withdraw counting\n', '\n', '    uint256 public chargeFee; // the charge fee for withdraw\n', '    address public chargeFeePool; // the address that will get the returned charge fees.\n', '\n', '\n', '    function initialSingleWithdrawMax(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        singleWithdrawMax = _value;\n', '    }\n', '\n', '    function initialSingleWithdrawMin(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        singleWithdrawMin = _value;\n', '    }\n', '\n', '    function initialDayWithdraw(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        dayWithdraw = _value;\n', '    }\n', '\n', '    function initialDayWithdrawCount(uint256 _count) onlyOwner public {\n', '        require(!init);\n', '\n', '        dayWithdrawCount = _count;\n', '    }\n', '\n', '    function initialMonthWithdraw(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        monthWithdraw = _value;\n', '    }\n', '\n', '    function initialChargeFee(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        chargeFee = _value;\n', '    }\n', '\n', '    function initialChargeFeePool(address _pool) onlyOwner public {\n', '        require(!init);\n', '\n', '        chargeFeePool = _pool;\n', '    }    \n', '\n', '    function setSingleWithdrawMax(uint256 _value) onlyCongress public {\n', '        singleWithdrawMax = _value;\n', '    }   \n', '\n', '    function setSingleWithdrawMin(uint256 _value) onlyCongress public {\n', '        singleWithdrawMin = _value;\n', '    }\n', '\n', '    function setDayWithdraw(uint256 _value) onlyCongress public {\n', '        dayWithdraw = _value;\n', '    }\n', '\n', '    function setDayWithdrawCount(uint256 _count) onlyCongress public {\n', '        dayWithdrawCount = _count;\n', '    }\n', '\n', '    function setMonthWithdraw(uint256 _value) onlyCongress public {\n', '        monthWithdraw = _value;\n', '    }\n', '\n', '    function setChargeFee(uint256 _value) onlyCongress public {\n', '        chargeFee = _value;\n', '    }\n', '\n', '    function setChargeFeePool(address _pool) onlyCongress public {\n', '        chargeFeePool = _pool;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Autonomy is Ownable {\n', '    address public congress;\n', '    bool init = false;\n', '\n', '    modifier onlyCongress() {\n', '        require(msg.sender == congress);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev initialize a Congress contract address for this token \n', '     *\n', '     * @param _congress address the congress contract address\n', '     */\n', '    function initialCongress(address _congress) onlyOwner public {\n', '        require(!init);\n', '        require(_congress != address(0));\n', '        congress = _congress;\n', '        init = true;\n', '    }\n', '\n', '    /**\n', '     * @dev set a Congress contract address for this token\n', '     * must change this address by the last congress contract \n', '     *\n', '     * @param _congress address the congress contract address\n', '     */\n', '    function changeCongress(address _congress) onlyCongress public {\n', '        require(_congress != address(0));\n', '        congress = _congress;\n', '    }\n', '}\n', '\n', 'contract withdrawable is Ownable {\n', '    event ReceiveEther(address _from, uint256 _value);\n', '    event WithdrawEther(address _to, uint256 _value);\n', '    event WithdrawToken(address _token, address _to, uint256 _value);\n', '\n', '    /**\n', '\t * @dev recording receiving ether from msn.sender\n', '\t */\n', '    function () payable public {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw,send ether to target\n', '\t * @param _to is where the ether will be sent to\n', '\t *        _amount is the number of the ether\n', '\t */\n', '    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        _to.transfer(_amount);\n', '        emit WithdrawEther(_to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '\t * @param _to is where the tokens will be sent to\n', '\t *        _value is the number of the token\n', '\t */\n', '    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        tk.transfer(_to, _value);\n', '        emit WithdrawToken(_token, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, and then gain the tokens, \n', '     *      then take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '    //     require(_token != address(0));\n', '    //     require(_from != address(0));\n', '        \n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.transferFrom(_from, this, _value));\n', '        \n', '    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    // }\n', '}\n', '\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', 'contract TokenDestructible is Ownable {\n', '\n', '  function TokenDestructible() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\n', '   refund.\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy(address[] tokens) onlyOwner public {\n', '\n', '    // Transfer tokens to owner\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      ERC20Basic token = ERC20Basic(tokens[i]);\n', '      uint256 balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '    }\n', '\n', '    // Transfer Eth to owner and terminate contract\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract OwnerContract is Claimable {\n', '    Claimable public ownedContract;\n', '    address internal origOwner;\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        ownedContract.claimOwnership();\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one. \n', '     *\n', '     */\n', '    function transferOwnershipBack() onlyOwner public {\n', '        ownedContract.transferOwnership(origOwner);\n', '        ownedContract = Claimable(address(0));\n', '        origOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one. \n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnershipto(address _nextOwner)  onlyOwner public {\n', '        ownedContract.transferOwnership(_nextOwner);\n', '        ownedContract = Claimable(address(0));\n', '        origOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract DepositWithdraw is Claimable, withdrawable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * transaction record\n', '     */\n', '    struct TransferRecord {\n', '        uint256 timeStamp;\n', '        address account;\n', '        uint256 value;\n', '    }\n', '    \n', '    /**\n', '     * accumulated transferring amount record\n', '     */\n', '    struct accumulatedRecord {\n', '        uint256 mul;\n', '        uint256 count;\n', '        uint256 value;\n', '    }\n', '\n', '    TransferRecord[] deposRecs; // record all the deposit tx data\n', '    TransferRecord[] withdrRecs; // record all the withdraw tx data\n', '\n', '    accumulatedRecord dayWithdrawRec; // accumulated amount record for one day\n', '    accumulatedRecord monthWithdrawRec; // accumulated amount record for one month\n', '\n', '    address wallet; // the binded withdraw address\n', '\n', '    event ReceiveDeposit(address _from, uint256 _value, address _token, bytes _extraData);\n', '    \n', '    /**\n', '     * @dev constructor of the DepositWithdraw contract\n', '     * @param _wallet the binded wallet address to this depositwithdraw contract\n', '     */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '\t * @dev set the default wallet address\n', '\t * @param _wallet the default wallet address binded to this deposit contract\n', '\t */\n', '    function setWithdrawWallet(address _wallet) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev util function to change bytes data to bytes32 data\n', '\t * @param _data the bytes data to be converted\n', '\t */\n', '    function bytesToBytes32(bytes _data) public pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(_data, 32))\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) onlyOwner public {\n', '        require(_token != address(0));\n', '        require(_from != address(0));\n', '        \n', '        ERC20 tk = ERC20(_token);\n', '        require(tk.transferFrom(_from, this, _value));\n', '        bytes32 timestamp = bytesToBytes32(_extraData);\n', '        deposRecs.push(TransferRecord(uint256(timestamp), _from, _value));\n', '        emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timstamp of the withdraw time\n', '\t * @param _to is where the tokens will be sent to\n', '\t *        _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        _tokenReturn is the address that return back the tokens of the _fee\n', '\t */\n', '    function withdrawToken(address _token, address _params, uint256 _time, address _to, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '        require(_value > _fee);\n', '        // require(_tokenReturn != address(0));\n', '\n', '        DRCWalletMgrParams params = DRCWalletMgrParams(_params);\n', '        require(_value <= params.singleWithdrawMax());\n', '        require(_value >= params.singleWithdrawMin());\n', '\n', '        uint256 daysCount = _time.div(86400); // one day of seconds\n', '        if (daysCount <= dayWithdrawRec.mul) {\n', '            dayWithdrawRec.count = dayWithdrawRec.count.add(1);\n', '            dayWithdrawRec.value = dayWithdrawRec.value.add(_value);\n', '            require(dayWithdrawRec.count <= params.dayWithdrawCount());\n', '            require(dayWithdrawRec.value <= params.dayWithdraw());\n', '        } else {\n', '            dayWithdrawRec.mul = daysCount;\n', '            dayWithdrawRec.count = 1;\n', '            dayWithdrawRec.value = _value;\n', '        }\n', '        \n', '        uint256 monthsCount = _time.div(86400 * 30);\n', '        if (monthsCount <= monthWithdrawRec.mul) {\n', '            monthWithdrawRec.count = monthWithdrawRec.count.add(1);\n', '            monthWithdrawRec.value = monthWithdrawRec.value.add(_value);\n', '            require(monthWithdrawRec.value <= params.monthWithdraw());\n', '        } else {            \n', '            monthWithdrawRec.mul = monthsCount;\n', '            monthWithdrawRec.count = 1;\n', '            monthWithdrawRec.value = _value;\n', '        }\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        uint256 realAmount = _value.sub(_fee);\n', '        require(tk.transfer(_to, realAmount));\n', '        if (_tokenReturn != address(0) && _fee > 0) {\n', '            require(tk.transfer(_tokenReturn, _fee));\n', '        }\n', '\n', '        withdrRecs.push(TransferRecord(_time, _to, realAmount));\n', '        emit WithdrawToken(_token, _to, realAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target default wallet\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timestamp occur the withdraw record\n', '\t * @param _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        —tokenReturn is the address that return back the tokens of the _fee\n', '\t */\n', '    function withdrawTokenToDefault(address _token, address _params, uint256 _time, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        return withdrawToken(_token, _params, _time, wallet, _value, _fee, _tokenReturn);\n', '    }\n', '\n', '    /**\n', '\t * @dev get the Deposit records number\n', '     *\n', '     */\n', '    function getDepositNum() public view returns (uint256) {\n', '        return deposRecs.length;\n', '    }\n', '\n', '    /**\n', '\t * @dev get the one of the Deposit records\n', '     *\n', '     * @param _ind the deposit record index\n', '     */\n', '    function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < deposRecs.length);\n', '\n', '        return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value);\n', '    }\n', '\n', '    /**\n', '\t * @dev get the withdraw records number\n', '     *\n', '     */\n', '    function getWithdrawNum() public view returns (uint256) {\n', '        return withdrRecs.length;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the one of the withdraw records\n', '     *\n', '     * @param _ind the withdraw record index\n', '     */\n', '    function getOneWithdrawRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < withdrRecs.length);\n', '\n', '        return (withdrRecs[_ind].timeStamp, withdrRecs[_ind].account, withdrRecs[_ind].value);\n', '    }\n', '}\n', '\n', 'contract DRCWalletManager is OwnerContract, withdrawable, Destructible, TokenDestructible {\n', '    using SafeMath for uint256;\n', '    \n', '    /**\n', '     * withdraw wallet description\n', '     */\n', '    struct WithdrawWallet {\n', '        bytes32 name;\n', '        address walletAddr;\n', '    }\n', '\n', '    /**\n', '     * Deposit data storage\n', '     */\n', '    struct DepositRepository {\n', '        // uint256 balance;\n', '        uint256 frozen;\n', '        WithdrawWallet[] withdrawWallets;\n', '        // mapping (bytes32 => address) withdrawWallets;\n', '    }\n', '\n', '    mapping (address => DepositRepository) depositRepos;\n', '    mapping (address => address) walletDeposits;\n', '    mapping (address => bool) public frozenDeposits;\n', '\n', '    ERC20 public tk; // the token will be managed\n', '    DRCWalletMgrParams params; // the parameters that the management needs\n', '    \n', '    event CreateDepositAddress(address indexed _wallet, address _deposit);\n', '    event FrozenTokens(address indexed _deposit, uint256 _value);\n', '    event ChangeDefaultWallet(address indexed _oldWallet, address _newWallet);\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target default wallet\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _walletParams the wallet management parameters\n', '\t */\n', '    function bindToken(address _token, address _walletParams) onlyOwner public returns (bool) {\n', '        require(_token != address(0));\n', '        require(_walletParams != address(0));\n', '\n', '        tk = ERC20(_token);\n', '        params = DRCWalletMgrParams(_walletParams);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev create deposit contract address for the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '\t */\n', '    function createDepositContract(address _wallet) onlyOwner public returns (address) {\n', '        require(_wallet != address(0));\n', '\n', '        DepositWithdraw deposWithdr = new DepositWithdraw(_wallet); // new contract for deposit\n', '        address _deposit = address(deposWithdr);\n', '        walletDeposits[_wallet] = _deposit;\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        withdrawWalletList.push(WithdrawWallet("default wallet", _wallet));\n', '        // depositRepos[_deposit].balance = 0;\n', '        depositRepos[_deposit].frozen = 0;\n', '\n', '        emit CreateDepositAddress(_wallet, address(deposWithdr));\n', '        return deposWithdr;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get deposit contract address by using the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '\t */\n', '    function getDepositAddress(address _wallet) onlyOwner public view returns (address) {\n', '        require(_wallet != address(0));\n', '        address deposit = walletDeposits[_wallet];\n', '\n', '        return deposit;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get deposit balance and frozen amount by using the deposit address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '\t */\n', '    function getDepositInfo(address _deposit) onlyOwner public view returns (uint256, uint256) {\n', '        require(_deposit != address(0));\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        uint256 frozenAmount = depositRepos[_deposit].frozen;\n', '        // depositRepos[_deposit].balance = _balance;\n', '\n', '        return (_balance, frozenAmount);\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the number of withdraw wallet addresses bindig to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '\t */\n', '    function getDepositWithdrawCount(address _deposit) onlyOwner public view returns (uint) {\n', '        require(_deposit != address(0));\n', '\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        uint len = withdrawWalletList.length;\n', '\n', '        return len;\n', '    }\n', '    \n', '    /**\n', '\t * @dev get the withdraw wallet addresses list binding to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '     * @param _indices the array of indices of the withdraw wallets\n', '\t */\n', '    function getDepositWithdrawList(address _deposit, uint[] _indices) onlyOwner public view returns (bytes32[], address[]) {\n', '        require(_indices.length != 0);\n', '\n', '        bytes32[] memory names = new bytes32[](_indices.length);\n', '        address[] memory wallets = new address[](_indices.length);\n', '        \n', '        for (uint i = 0; i < _indices.length; i = i.add(1)) {\n', '            WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[_indices[i]];\n', '            names[i] = wallet.name;\n', '            wallets[i] = wallet.walletAddr;\n', '        }\n', '        \n', '        return (names, wallets);\n', '    }\n', '    \n', '    /**\n', '\t * @dev change the default withdraw wallet address binding to the deposit contract address\n', '     *\n', '     * @param _oldWallet the previous default withdraw wallet\n', '     * @param _newWallet the new default withdraw wallet\n', '\t */\n', '    function changeDefaultWithdraw(address _oldWallet, address _newWallet) onlyOwner public returns (bool) {\n', '        require(_newWallet != address(0));\n', '        \n', '        address deposit = walletDeposits[_oldWallet];\n', '        DepositWithdraw deposWithdr = DepositWithdraw(deposit);\n', '        require(deposWithdr.setWithdrawWallet(_newWallet));\n', '\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[deposit].withdrawWallets;\n', '        withdrawWalletList[0].walletAddr = _newWallet;\n', '        emit ChangeDefaultWallet(_oldWallet, _newWallet);\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev freeze the tokens in the deposit address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _value the amount of tokens need to be frozen\n', '\t */\n', '    function freezeTokens(address _deposit, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '        \n', '        frozenDeposits[_deposit] = true;\n', '        depositRepos[_deposit].frozen = _value;\n', '\n', '        emit FrozenTokens(_deposit, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @dev withdraw the tokens from the deposit address with charge fee\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _time the timestamp the withdraw occurs\n', '     * @param _value the amount of tokens need to be frozen\n', '\t */\n', '    function withdrawWithFee(address _deposit, uint256 _time, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        require(_value <= _balance);\n', '\n', '        // depositRepos[_deposit].balance = _balance;\n', '        uint256 frozenAmount = depositRepos[_deposit].frozen;\n', '        require(_value <= _balance.sub(frozenAmount));\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        return (deposWithdr.withdrawTokenToDefault(address(tk), address(params), _time, _value, params.chargeFee(), params.chargeFeePool()));\n', '    }\n', '    \n', '    /**\n', '\t * @dev check if the wallet name is not matching the expected wallet address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _name the withdraw wallet name\n', '     * @param _to the withdraw wallet address\n', '\t */\n', '    function checkWithdrawAddress(address _deposit, bytes32 _name, address _to) public view returns (bool, bool) {\n', '        uint len = depositRepos[_deposit].withdrawWallets.length;\n', '        for (uint i = 0; i < len; i = i.add(1)) {\n', '            WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[i];\n', '            if (_name == wallet.name) {\n', '                return(true, (_to == wallet.walletAddr));\n', '            }\n', '        }\n', '\n', '        return (false, true);\n', '    }\n', '\n', '    /**\n', '\t * @dev withdraw tokens, send tokens to target withdraw wallet\n', '     *\n', '     * @param _deposit the deposit address that will be withdraw from\n', '     * @param _time the timestamp occur the withdraw record\n', '\t * @param _name the withdraw address alias name to verify\n', '     * @param _to the address the token will be transfer to \n', '     * @param _value the token transferred value\n', '     * @param _check if we will check the value is valid or meet the limit condition\n', '\t */\n', '    function withdrawWithFee(address _deposit, \n', '                             uint256 _time, \n', '                             bytes32 _name, \n', '                             address _to, \n', '                             uint256 _value, \n', '                             bool _check) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '        require(_to != address(0));\n', '\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '        if (_check) {\n', '            require(_value <= _balance);\n', '        }\n', '\n', '        uint256 available = _balance.sub(depositRepos[_deposit].frozen);\n', '        if (_check) {\n', '            require(_value <= available);\n', '        }\n', '\n', '        bool exist;\n', '        bool correct;\n', '        WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        (exist, correct) = checkWithdrawAddress(_deposit, _name, _to);\n', '        if(!exist) {\n', '            withdrawWalletList.push(WithdrawWallet(_name, _to));\n', '        } else if(!correct) {\n', '            return false;\n', '        }\n', '\n', '        if (!_check && _value > available) {\n', '            tk.transfer(_deposit, _value.sub(available));\n', '            // _value = _value.sub(available);\n', '        }\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        return (deposWithdr.withdrawToken(address(tk), address(params), _time, _to, _value, params.chargeFee(), params.chargeFeePool()));        \n', '    }\n', '\n', '}\n', '\n', 'contract DRCWalletMgrParams is Claimable, Autonomy, Destructible {\n', '    uint256 public singleWithdrawMin; // min value of single withdraw\n', '    uint256 public singleWithdrawMax; // Max value of single withdraw\n', '    uint256 public dayWithdraw; // Max value of one day of withdraw\n', '    uint256 public monthWithdraw; // Max value of one month of withdraw\n', '    uint256 public dayWithdrawCount; // Max number of withdraw counting\n', '\n', '    uint256 public chargeFee; // the charge fee for withdraw\n', '    address public chargeFeePool; // the address that will get the returned charge fees.\n', '\n', '\n', '    function initialSingleWithdrawMax(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        singleWithdrawMax = _value;\n', '    }\n', '\n', '    function initialSingleWithdrawMin(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        singleWithdrawMin = _value;\n', '    }\n', '\n', '    function initialDayWithdraw(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        dayWithdraw = _value;\n', '    }\n', '\n', '    function initialDayWithdrawCount(uint256 _count) onlyOwner public {\n', '        require(!init);\n', '\n', '        dayWithdrawCount = _count;\n', '    }\n', '\n', '    function initialMonthWithdraw(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        monthWithdraw = _value;\n', '    }\n', '\n', '    function initialChargeFee(uint256 _value) onlyOwner public {\n', '        require(!init);\n', '\n', '        chargeFee = _value;\n', '    }\n', '\n', '    function initialChargeFeePool(address _pool) onlyOwner public {\n', '        require(!init);\n', '\n', '        chargeFeePool = _pool;\n', '    }    \n', '\n', '    function setSingleWithdrawMax(uint256 _value) onlyCongress public {\n', '        singleWithdrawMax = _value;\n', '    }   \n', '\n', '    function setSingleWithdrawMin(uint256 _value) onlyCongress public {\n', '        singleWithdrawMin = _value;\n', '    }\n', '\n', '    function setDayWithdraw(uint256 _value) onlyCongress public {\n', '        dayWithdraw = _value;\n', '    }\n', '\n', '    function setDayWithdrawCount(uint256 _count) onlyCongress public {\n', '        dayWithdrawCount = _count;\n', '    }\n', '\n', '    function setMonthWithdraw(uint256 _value) onlyCongress public {\n', '        monthWithdraw = _value;\n', '    }\n', '\n', '    function setChargeFee(uint256 _value) onlyCongress public {\n', '        chargeFee = _value;\n', '    }\n', '\n', '    function setChargeFeePool(address _pool) onlyCongress public {\n', '        chargeFeePool = _pool;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}']
