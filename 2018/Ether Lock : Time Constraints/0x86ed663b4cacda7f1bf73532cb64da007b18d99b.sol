['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint256 public totalSupply;\n', '\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/TimeLockedWallet.sol\n', '\n', 'contract TimeLockedWallet {\n', '\n', '    address public creator;\n', '    address public owner;\n', '    uint256 public unlockDate;\n', '    uint256 public createdAt;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address _creator,\n', '        address _owner,\n', '        uint256 _unlockDate\n', '    ) public {\n', '        creator = _creator;\n', '        owner = _owner;\n', '        unlockDate = _unlockDate;\n', '        createdAt = now;\n', '    }\n', '\n', '    // Don&#39;t accept ETH.\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // callable by owner only, after specified time, only for Tokens implementing ERC20\n', '    function withdrawTokens(address _tokenContract) onlyOwner public {\n', '       require(now >= unlockDate);\n', '       ERC20 token = ERC20(_tokenContract);\n', '       //now send all the token balance\n', '       uint256 tokenBalance = token.balanceOf(this);\n', '       token.transfer(owner, tokenBalance);\n', '       emit WithdrewTokens(_tokenContract, msg.sender, tokenBalance);\n', '    }\n', '\n', '    function info() public view returns(address, address, uint256, uint256, uint256) {\n', '        return (creator, owner, unlockDate, createdAt, address(this).balance);\n', '    }\n', '\n', '    event Received(address from, uint256 amount);\n', '    event Withdrew(address to, uint256 amount);\n', '    event WithdrewTokens(address tokenContract, address to, uint256 amount);\n', '}\n', '\n', '// File: contracts/TimeLockedWalletFactory.sol\n', '\n', 'contract TimeLockedWalletFactory {\n', ' \n', '    mapping(address => address[]) wallets;\n', '\n', '    function getWallets(address _user) \n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return wallets[_user];\n', '    }\n', '\n', '    function newTimeLockedWallet(address _owner, uint256 _unlockDate)\n', '        payable\n', '        public\n', '        returns(address wallet)\n', '    {\n', '        // Create new wallet.\n', '        wallet = new TimeLockedWallet(msg.sender, _owner, _unlockDate);\n', '        \n', '        // Add wallet to sender&#39;s wallets.\n', '        wallets[msg.sender].push(wallet);\n', '\n', '        // If owner is the same as sender then add wallet to sender&#39;s wallets too.\n', '        if(msg.sender != _owner){\n', '            wallets[_owner].push(wallet);\n', '        }\n', '\n', '        // Send ether from this transaction to the created contract.\n', '        wallet.transfer(msg.value);\n', '\n', '        // Emit event.\n', '        emit Created(wallet, msg.sender, _owner, now, _unlockDate, msg.value);\n', '    }\n', '\n', '    // Prevents accidental sending of ether to the factory\n', '    function () public {\n', '        revert();\n', '    }\n', '\n', '    event Created(address wallet, address from, address to, uint256 createdAt, uint256 unlockDate, uint256 amount);\n', '}']