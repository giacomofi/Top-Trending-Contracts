['pragma solidity ^0.4.21;\n', '\n', 'contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract MNY {\n', '\n', '    string public name = "MNY by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "MNY";\n', '\n', '    address public owner;\n', '    address public exchangeAdmin;\n', '\n', '    // used to store list of contracts MNY holds tokens in\n', '    mapping(uint256 => address) public exchangePartners;\n', '    mapping(address => uint256) public exchangeRates;\n', '\n', '    uint tierLevel = 1;\n', '    uint maxTier = 30;\n', '    uint256 totalSupply = 1.698846726062230000E25;\n', '\n', '    uint256 public mineableTokens = totalSupply;\n', '    uint256 public swappedTokens = 0;\n', '    uint256 circulatingSupply = 0;\n', '    uint contractCount = 0;\n', '\n', '    // flags\n', '    bool swap = false;\n', '    bool distributionCalculated = false;\n', '    bool public initialTiers = false;\n', '    bool addTiers = true;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public tokenBalances;\n', '    mapping (address => uint256) public tokenShare;\n', '\n', '    // erc20 compliance\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // mining schedule\n', '    mapping(uint => uint256) public scheduleTokens;\n', '    mapping(uint => uint256) public scheduleRates;\n', '\n', '    uint256 swapEndTime;\n', '\n', '    // events (ERC20)\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // events (custom)\n', '    event TokensExchanged(address indexed _sendingWallet, address indexed _sendingContract, uint256 _tokensIn);\n', '\n', '    function MNY() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // tier pop\n', '    function populateTierTokens() public {\n', '        require((msg.sender == owner) && (initialTiers == false));\n', '        scheduleTokens[1] = 5.33696E18;\n', '        scheduleTokens[2] = 7.69493333E18;\n', '        scheduleTokens[3] = 4.75684324E18;\n', '        scheduleTokens[4] = 6.30846753E18;\n', '        scheduleTokens[5] = 6.21620513E18;\n', '        scheduleTokens[6] = 5.63157219E18;\n', '        scheduleTokens[7] = 5.80023669E18;\n', '        scheduleTokens[8] = 5.04458667E18;\n', '        scheduleTokens[9] = 4.58042767E18;\n', '        scheduleTokens[10] = 5E18;\n', '        scheduleTokens[11] = 5.59421053E18;\n', '        scheduleTokens[12] = 7.05050888E18;\n', '        scheduleTokens[13] = 1.93149011E19;\n', '        scheduleTokens[14] = 5.71055924E18;\n', '        scheduleTokens[15] = 1.087367665E19;\n', '        scheduleTokens[16] = 5.4685283E18;\n', '        scheduleTokens[17] = 7.58236145E18;\n', '        scheduleTokens[18] = 5.80773184E18;\n', '        scheduleTokens[19] = 4.74868639E18;\n', '        scheduleTokens[20] = 6.74810256E18;\n', '        scheduleTokens[21] = 5.52847682E18;\n', '        scheduleTokens[22] = 4.96611055E18;\n', '        scheduleTokens[23] = 5.45818182E18;\n', '        scheduleTokens[24] = 8.0597095E18;\n', '        scheduleTokens[25] = 1.459911381E19;\n', '        scheduleTokens[26] = 8.32598844E18;\n', '        scheduleTokens[27] = 4.555277509E19;\n', '        scheduleTokens[28] = 1.395674359E19;\n', '        scheduleTokens[29] = 9.78908515E18;\n', '        scheduleTokens[30] = 1.169045087E19;\n', '    }\n', '\n', '    function populateTierRates() public {\n', '        require((msg.sender == owner) && (initialTiers == false));\n', '        scheduleRates[1] = 9E18;\n', '        scheduleRates[2] = 9E18;\n', '        scheduleRates[3] = 8E18;\n', '        scheduleRates[4] = 7E18;\n', '        scheduleRates[5] = 8E18;\n', '        scheduleRates[6] = 5E18;\n', '        scheduleRates[7] = 6E18;\n', '        scheduleRates[8] = 5E18;\n', '        scheduleRates[9] = 5E18;\n', '        scheduleRates[10] = 6E18;\n', '        scheduleRates[11] = 6E18;\n', '        scheduleRates[12] = 6E18;\n', '        scheduleRates[13] = 7E18;\n', '        scheduleRates[14] = 6E18;\n', '        scheduleRates[15] = 7E18;\n', '        scheduleRates[16] = 6E18;\n', '        scheduleRates[17] = 6E18;\n', '        scheduleRates[18] = 6E18;\n', '        scheduleRates[19] = 6E18;\n', '        scheduleRates[20] = 6E18;\n', '        scheduleRates[21] = 6E18;\n', '        scheduleRates[22] = 6E18;\n', '        scheduleRates[23] = 6E18;\n', '        scheduleRates[24] = 7E18;\n', '        scheduleRates[25] = 7E18;\n', '        scheduleRates[26] = 7E18;\n', '        scheduleRates[27] = 7E18;\n', '        scheduleRates[28] = 6E18;\n', '        scheduleRates[29] = 7E18;\n', '        scheduleRates[30] = 7E18;\n', '        initialTiers = true;\n', '    }\n', '    // eof tier pop\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                mineableTokens = add(mineableTokens, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) {\n', '                    swap = true;\n', '                    swapEndTime = now + 90 days;\n', '                }\n', '                scheduleTokens[maxTier] = add(scheduleTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                swappedTokens = add(swappedTokens, _value);\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, _value);\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted, uint256 _tokenCount, address _recipient) internal {\n', '        uint256 _tokensAfforded = 0;\n', '\n', '        if(tierLevel <= maxTier) {\n', '            _tokensAfforded = div(_submitted, scheduleRates[tierLevel]);\n', '        }\n', '\n', '        if(_tokensAfforded >= scheduleTokens[tierLevel]) {\n', '            _submitted = sub(_submitted, mul(scheduleTokens[tierLevel], scheduleRates[tierLevel]));\n', '            _tokenCount = add(_tokenCount, scheduleTokens[tierLevel]);\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '            mineableTokens = sub(mineableTokens, _tokensAfforded);\n', '            scheduleTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            allocateTokens(_submitted, _tokenCount, _recipient);\n', '        }\n', '        else if((scheduleTokens[tierLevel] >= _tokensAfforded) && (_tokensAfforded > 0)) {\n', '            scheduleTokens[tierLevel] = sub(scheduleTokens[tierLevel], _tokensAfforded);\n', '            _tokenCount = add(_tokenCount, _tokensAfforded);\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '            mineableTokens = sub(mineableTokens, _tokensAfforded);\n', '\n', '            _submitted = sub(_submitted, mul(_tokensAfforded, scheduleRates[tierLevel]));\n', '            allocateTokens(_submitted, _tokenCount, _recipient);\n', '        }\n', '        else {\n', '            balances[_recipient] = add(balances[_recipient], _tokenCount);\n', '            Transfer(this, _recipient, _tokenCount);\n', '        }\n', '    }\n', '\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _sentTokens) {\n', '        require(exchangeRates[msg.sender] > 0); // only approved contracts will satisfy this constraint\n', '        allocateTokens(mul(_sentTokens, exchangeRates[_source]), 0, _recipient);\n', '        TokensExchanged(_recipient, _source, _sentTokens);\n', '        maintainExternalContractTokenBalance(_source, _sentTokens);\n', '    }\n', '\n', '    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) public {\n', '        require(msg.sender == owner);\n', '        // check that _partner is a contract address\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_partner)\n', '        }\n', '        require(codeLength > 0);\n', '        exchangeRates[_partner] = _rate;\n', '\n', '        bool isContract = existingContract(_partner);\n', '        if(isContract == false) {\n', '            contractCount++;\n', '            exchangePartners[contractCount] = _partner;\n', '        }\n', '    }\n', '\n', '    function addTierRateAndTokens(uint256 _level, uint256 _tokens, uint256 _rate) public {\n', '        require(((msg.sender == owner) || (msg.sender == exchangeAdmin)) && (addTiers == true));\n', '        scheduleTokens[_level] = _tokens;\n', '        scheduleRates[_level] = _rate;\n', '        maxTier++;\n', '        if(maxTier > 2856) {\n', '            totalSupply = add(totalSupply, _tokens);\n', '        }\n', '    }\n', '\n', '    function closeTierAddition() public {\n', '        require(msg.sender == owner);\n', '        addTiers = false;\n', '    }\n', '\n', '    // public data retrieval funcs\n', '    function getTotalSupply() public constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function getMineableTokens() public constant returns (uint256) {\n', '        return mineableTokens;\n', '    }\n', '\n', '    function getCirculatingSupply() public constant returns (uint256) {\n', '        return circulatingSupply;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return scheduleTokens[tierLevel];\n', '    }\n', '\n', '    function balanceInSpecificTier(uint256 _tier) public constant returns (uint256) {\n', '        return scheduleTokens[_tier];\n', '    }\n', '\n', '    function rateInSpecificTier(uint256 _tier) public constant returns (uint256) {\n', '        return scheduleRates[_tier];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    // NB: we use this to manually process tokens sent in from contracts not able to interact direct with MNY\n', '    function convertTransferredTokensToMny(uint256 _value, address _recipient, address _source, uint256 _originalTokenAmount) public {\n', '        // This allows tokens transferred in for exchange to be converted to MNY and distributed\n', '        // NOTE: COE is able to interact directly with the MNY contract - other exchange partners cannot unless designed ot do so\n', '        // Please contact us at 3@dunaton.com for details on designing a contract that *can* deal directly with MNY\n', '        require((msg.sender == owner) || (msg.sender == exchangeAdmin));\n', '        require(exchangeRates[_source] > 0);\n', '        allocateTokens(_value, 0, _recipient);\n', '        maintainExternalContractTokenBalance(_source, _originalTokenAmount);\n', '        TokensExchanged(_recipient, _source, _originalTokenAmount);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeExchangeAdmin(address _newAdmin) public {\n', '        require(msg.sender == owner);\n', '        exchangeAdmin = _newAdmin;\n', '    }\n', '\n', '    function maintainExternalContractTokenBalance(address _contract, uint256 _tokens) internal {\n', '        tokenBalances[_contract] = add(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function getTokenBalance(address _contract) public constant returns (uint256) {\n', '        return tokenBalances[_contract];\n', '    }\n', '\n', '    function calculateHeldTokenDistribution() public {\n', '        require(swap == true);\n', '        for(uint256 i=0; i<contractCount; i++) {\n', '            tokenShare[exchangePartners[i]] = div(tokenBalances[exchangePartners[i]], totalSupply);\n', '        }\n', '        distributionCalculated = true;\n', '    }\n', '\n', '    function tokenShare(address _contract) public constant returns (uint256) {\n', '        return tokenShare[_contract];\n', '    }\n', '\n', '    function shareStoredTokens(address _recipient, uint256 mny) internal {\n', '        Target t;\n', '        uint256 share = 0;\n', '        for(uint i=0; i<contractCount; i++) {\n', '            share = mul(mny, tokenShare[exchangePartners[i]]);\n', '\n', '            t = Target(exchangePartners[i]);\n', '            t.transfer(_recipient, share);\n', '            tokenBalances[exchangePartners[i]] = sub(tokenBalances[exchangePartners[i]], share);\n', '        }\n', '    }\n', '\n', '    // NOTE: this function is used to redistribute the swapped MNY after swap has ended\n', '    function distributeMnyAfterSwap(address _recipient, uint256 _tokens) public {\n', '        require(msg.sender == owner);\n', '        require(swappedTokens <= _tokens);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '        swappedTokens = sub(totalSupply, _tokens);\n', '        circulatingSupply = add(circulatingSupply, _tokens);\n', '    }\n', '\n', '    // we will use this to distribute tokens owned in other contracts\n', '    // e.g. if we have MNY irretrievably locked in contracts/forgotten wallets etc that cannot be returned.\n', '    // This function WILL ONLY be called fter fair notice and CANNOT be called until 90 days have\n', '    // passed since the swap started\n', '    function distributeOwnedTokensFromOtherContracts(address _contract, address _recipient, uint256 _tokens) {\n', '        require(now >= swapEndTime);\n', '        require(msg.sender == owner);\n', '\n', '        require(tokenBalances[_contract] >= _tokens);\n', '        Target t = Target(_contract);\n', '        t.transfer(_recipient, _tokens);\n', '        tokenBalances[_contract] = sub(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function existingContract(address _contract) internal returns (bool) {\n', '        for(uint i=0; i<=contractCount; i++) {\n', '            if(exchangePartners[i] == _contract) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function contractExchangeRate(address _contract) public constant returns (uint256) {\n', '        return exchangeRates[_contract];\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    // ERC20 compliance addition\n', '    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) {\n', '        require(balances[_from] >= _tokens);\n', '        balances[_from] = sub(balances[_from],_tokens);\n', '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_tokens);\n', '        balances[_to] = add(balances[_to],_tokens);\n', '        Transfer(_from, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _tokens) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _tokens;\n', '        Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _tokenOwner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_tokenOwner][_spender];\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract MNY {\n', '\n', '    string public name = "MNY by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "MNY";\n', '\n', '    address public owner;\n', '    address public exchangeAdmin;\n', '\n', '    // used to store list of contracts MNY holds tokens in\n', '    mapping(uint256 => address) public exchangePartners;\n', '    mapping(address => uint256) public exchangeRates;\n', '\n', '    uint tierLevel = 1;\n', '    uint maxTier = 30;\n', '    uint256 totalSupply = 1.698846726062230000E25;\n', '\n', '    uint256 public mineableTokens = totalSupply;\n', '    uint256 public swappedTokens = 0;\n', '    uint256 circulatingSupply = 0;\n', '    uint contractCount = 0;\n', '\n', '    // flags\n', '    bool swap = false;\n', '    bool distributionCalculated = false;\n', '    bool public initialTiers = false;\n', '    bool addTiers = true;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public tokenBalances;\n', '    mapping (address => uint256) public tokenShare;\n', '\n', '    // erc20 compliance\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // mining schedule\n', '    mapping(uint => uint256) public scheduleTokens;\n', '    mapping(uint => uint256) public scheduleRates;\n', '\n', '    uint256 swapEndTime;\n', '\n', '    // events (ERC20)\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // events (custom)\n', '    event TokensExchanged(address indexed _sendingWallet, address indexed _sendingContract, uint256 _tokensIn);\n', '\n', '    function MNY() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // tier pop\n', '    function populateTierTokens() public {\n', '        require((msg.sender == owner) && (initialTiers == false));\n', '        scheduleTokens[1] = 5.33696E18;\n', '        scheduleTokens[2] = 7.69493333E18;\n', '        scheduleTokens[3] = 4.75684324E18;\n', '        scheduleTokens[4] = 6.30846753E18;\n', '        scheduleTokens[5] = 6.21620513E18;\n', '        scheduleTokens[6] = 5.63157219E18;\n', '        scheduleTokens[7] = 5.80023669E18;\n', '        scheduleTokens[8] = 5.04458667E18;\n', '        scheduleTokens[9] = 4.58042767E18;\n', '        scheduleTokens[10] = 5E18;\n', '        scheduleTokens[11] = 5.59421053E18;\n', '        scheduleTokens[12] = 7.05050888E18;\n', '        scheduleTokens[13] = 1.93149011E19;\n', '        scheduleTokens[14] = 5.71055924E18;\n', '        scheduleTokens[15] = 1.087367665E19;\n', '        scheduleTokens[16] = 5.4685283E18;\n', '        scheduleTokens[17] = 7.58236145E18;\n', '        scheduleTokens[18] = 5.80773184E18;\n', '        scheduleTokens[19] = 4.74868639E18;\n', '        scheduleTokens[20] = 6.74810256E18;\n', '        scheduleTokens[21] = 5.52847682E18;\n', '        scheduleTokens[22] = 4.96611055E18;\n', '        scheduleTokens[23] = 5.45818182E18;\n', '        scheduleTokens[24] = 8.0597095E18;\n', '        scheduleTokens[25] = 1.459911381E19;\n', '        scheduleTokens[26] = 8.32598844E18;\n', '        scheduleTokens[27] = 4.555277509E19;\n', '        scheduleTokens[28] = 1.395674359E19;\n', '        scheduleTokens[29] = 9.78908515E18;\n', '        scheduleTokens[30] = 1.169045087E19;\n', '    }\n', '\n', '    function populateTierRates() public {\n', '        require((msg.sender == owner) && (initialTiers == false));\n', '        scheduleRates[1] = 9E18;\n', '        scheduleRates[2] = 9E18;\n', '        scheduleRates[3] = 8E18;\n', '        scheduleRates[4] = 7E18;\n', '        scheduleRates[5] = 8E18;\n', '        scheduleRates[6] = 5E18;\n', '        scheduleRates[7] = 6E18;\n', '        scheduleRates[8] = 5E18;\n', '        scheduleRates[9] = 5E18;\n', '        scheduleRates[10] = 6E18;\n', '        scheduleRates[11] = 6E18;\n', '        scheduleRates[12] = 6E18;\n', '        scheduleRates[13] = 7E18;\n', '        scheduleRates[14] = 6E18;\n', '        scheduleRates[15] = 7E18;\n', '        scheduleRates[16] = 6E18;\n', '        scheduleRates[17] = 6E18;\n', '        scheduleRates[18] = 6E18;\n', '        scheduleRates[19] = 6E18;\n', '        scheduleRates[20] = 6E18;\n', '        scheduleRates[21] = 6E18;\n', '        scheduleRates[22] = 6E18;\n', '        scheduleRates[23] = 6E18;\n', '        scheduleRates[24] = 7E18;\n', '        scheduleRates[25] = 7E18;\n', '        scheduleRates[26] = 7E18;\n', '        scheduleRates[27] = 7E18;\n', '        scheduleRates[28] = 6E18;\n', '        scheduleRates[29] = 7E18;\n', '        scheduleRates[30] = 7E18;\n', '        initialTiers = true;\n', '    }\n', '    // eof tier pop\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                mineableTokens = add(mineableTokens, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) {\n', '                    swap = true;\n', '                    swapEndTime = now + 90 days;\n', '                }\n', '                scheduleTokens[maxTier] = add(scheduleTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                swappedTokens = add(swappedTokens, _value);\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, _value);\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted, uint256 _tokenCount, address _recipient) internal {\n', '        uint256 _tokensAfforded = 0;\n', '\n', '        if(tierLevel <= maxTier) {\n', '            _tokensAfforded = div(_submitted, scheduleRates[tierLevel]);\n', '        }\n', '\n', '        if(_tokensAfforded >= scheduleTokens[tierLevel]) {\n', '            _submitted = sub(_submitted, mul(scheduleTokens[tierLevel], scheduleRates[tierLevel]));\n', '            _tokenCount = add(_tokenCount, scheduleTokens[tierLevel]);\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '            mineableTokens = sub(mineableTokens, _tokensAfforded);\n', '            scheduleTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            allocateTokens(_submitted, _tokenCount, _recipient);\n', '        }\n', '        else if((scheduleTokens[tierLevel] >= _tokensAfforded) && (_tokensAfforded > 0)) {\n', '            scheduleTokens[tierLevel] = sub(scheduleTokens[tierLevel], _tokensAfforded);\n', '            _tokenCount = add(_tokenCount, _tokensAfforded);\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '            mineableTokens = sub(mineableTokens, _tokensAfforded);\n', '\n', '            _submitted = sub(_submitted, mul(_tokensAfforded, scheduleRates[tierLevel]));\n', '            allocateTokens(_submitted, _tokenCount, _recipient);\n', '        }\n', '        else {\n', '            balances[_recipient] = add(balances[_recipient], _tokenCount);\n', '            Transfer(this, _recipient, _tokenCount);\n', '        }\n', '    }\n', '\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _sentTokens) {\n', '        require(exchangeRates[msg.sender] > 0); // only approved contracts will satisfy this constraint\n', '        allocateTokens(mul(_sentTokens, exchangeRates[_source]), 0, _recipient);\n', '        TokensExchanged(_recipient, _source, _sentTokens);\n', '        maintainExternalContractTokenBalance(_source, _sentTokens);\n', '    }\n', '\n', '    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) public {\n', '        require(msg.sender == owner);\n', '        // check that _partner is a contract address\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_partner)\n', '        }\n', '        require(codeLength > 0);\n', '        exchangeRates[_partner] = _rate;\n', '\n', '        bool isContract = existingContract(_partner);\n', '        if(isContract == false) {\n', '            contractCount++;\n', '            exchangePartners[contractCount] = _partner;\n', '        }\n', '    }\n', '\n', '    function addTierRateAndTokens(uint256 _level, uint256 _tokens, uint256 _rate) public {\n', '        require(((msg.sender == owner) || (msg.sender == exchangeAdmin)) && (addTiers == true));\n', '        scheduleTokens[_level] = _tokens;\n', '        scheduleRates[_level] = _rate;\n', '        maxTier++;\n', '        if(maxTier > 2856) {\n', '            totalSupply = add(totalSupply, _tokens);\n', '        }\n', '    }\n', '\n', '    function closeTierAddition() public {\n', '        require(msg.sender == owner);\n', '        addTiers = false;\n', '    }\n', '\n', '    // public data retrieval funcs\n', '    function getTotalSupply() public constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function getMineableTokens() public constant returns (uint256) {\n', '        return mineableTokens;\n', '    }\n', '\n', '    function getCirculatingSupply() public constant returns (uint256) {\n', '        return circulatingSupply;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return scheduleTokens[tierLevel];\n', '    }\n', '\n', '    function balanceInSpecificTier(uint256 _tier) public constant returns (uint256) {\n', '        return scheduleTokens[_tier];\n', '    }\n', '\n', '    function rateInSpecificTier(uint256 _tier) public constant returns (uint256) {\n', '        return scheduleRates[_tier];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    // NB: we use this to manually process tokens sent in from contracts not able to interact direct with MNY\n', '    function convertTransferredTokensToMny(uint256 _value, address _recipient, address _source, uint256 _originalTokenAmount) public {\n', '        // This allows tokens transferred in for exchange to be converted to MNY and distributed\n', '        // NOTE: COE is able to interact directly with the MNY contract - other exchange partners cannot unless designed ot do so\n', '        // Please contact us at 3@dunaton.com for details on designing a contract that *can* deal directly with MNY\n', '        require((msg.sender == owner) || (msg.sender == exchangeAdmin));\n', '        require(exchangeRates[_source] > 0);\n', '        allocateTokens(_value, 0, _recipient);\n', '        maintainExternalContractTokenBalance(_source, _originalTokenAmount);\n', '        TokensExchanged(_recipient, _source, _originalTokenAmount);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeExchangeAdmin(address _newAdmin) public {\n', '        require(msg.sender == owner);\n', '        exchangeAdmin = _newAdmin;\n', '    }\n', '\n', '    function maintainExternalContractTokenBalance(address _contract, uint256 _tokens) internal {\n', '        tokenBalances[_contract] = add(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function getTokenBalance(address _contract) public constant returns (uint256) {\n', '        return tokenBalances[_contract];\n', '    }\n', '\n', '    function calculateHeldTokenDistribution() public {\n', '        require(swap == true);\n', '        for(uint256 i=0; i<contractCount; i++) {\n', '            tokenShare[exchangePartners[i]] = div(tokenBalances[exchangePartners[i]], totalSupply);\n', '        }\n', '        distributionCalculated = true;\n', '    }\n', '\n', '    function tokenShare(address _contract) public constant returns (uint256) {\n', '        return tokenShare[_contract];\n', '    }\n', '\n', '    function shareStoredTokens(address _recipient, uint256 mny) internal {\n', '        Target t;\n', '        uint256 share = 0;\n', '        for(uint i=0; i<contractCount; i++) {\n', '            share = mul(mny, tokenShare[exchangePartners[i]]);\n', '\n', '            t = Target(exchangePartners[i]);\n', '            t.transfer(_recipient, share);\n', '            tokenBalances[exchangePartners[i]] = sub(tokenBalances[exchangePartners[i]], share);\n', '        }\n', '    }\n', '\n', '    // NOTE: this function is used to redistribute the swapped MNY after swap has ended\n', '    function distributeMnyAfterSwap(address _recipient, uint256 _tokens) public {\n', '        require(msg.sender == owner);\n', '        require(swappedTokens <= _tokens);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '        swappedTokens = sub(totalSupply, _tokens);\n', '        circulatingSupply = add(circulatingSupply, _tokens);\n', '    }\n', '\n', '    // we will use this to distribute tokens owned in other contracts\n', '    // e.g. if we have MNY irretrievably locked in contracts/forgotten wallets etc that cannot be returned.\n', '    // This function WILL ONLY be called fter fair notice and CANNOT be called until 90 days have\n', '    // passed since the swap started\n', '    function distributeOwnedTokensFromOtherContracts(address _contract, address _recipient, uint256 _tokens) {\n', '        require(now >= swapEndTime);\n', '        require(msg.sender == owner);\n', '\n', '        require(tokenBalances[_contract] >= _tokens);\n', '        Target t = Target(_contract);\n', '        t.transfer(_recipient, _tokens);\n', '        tokenBalances[_contract] = sub(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function existingContract(address _contract) internal returns (bool) {\n', '        for(uint i=0; i<=contractCount; i++) {\n', '            if(exchangePartners[i] == _contract) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function contractExchangeRate(address _contract) public constant returns (uint256) {\n', '        return exchangeRates[_contract];\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    // ERC20 compliance addition\n', '    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) {\n', '        require(balances[_from] >= _tokens);\n', '        balances[_from] = sub(balances[_from],_tokens);\n', '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_tokens);\n', '        balances[_to] = add(balances[_to],_tokens);\n', '        Transfer(_from, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _tokens) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _tokens;\n', '        Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _tokenOwner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_tokenOwner][_spender];\n', '    }\n', '}']
