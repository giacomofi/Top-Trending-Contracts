['pragma solidity ^0.4.21;\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction Ownable()public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction transferOwnership(address newOwner)public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title BonusScheme\n', ' * @dev This contract is used for storing and granting tokens calculated \n', ' * according to bonus scheme while a crowdsale is in progress.\n', ' * When crowdsale ends the rest of tokens is transferred to developers.\n', ' */\n', 'contract BonusScheme is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '\t* Defining timestamps for bonuscheme from White Paper. \n', '\t* The start of bonuses is 15 May 2018 and the end is 23 June 2018. \n', '\t* There are 2 seconds in between changing the phases.  */\n', '\tuint256 startOfFirstBonus = 1526021400;\n', '\tuint256 endOfFirstBonus = (startOfFirstBonus - 1) + 5 minutes;\t\n', '\tuint256 startOfSecondBonus = (startOfFirstBonus + 1) + 5 minutes;\n', '\tuint256 endOfSecondBonus = (startOfSecondBonus - 1) + 5 minutes;\n', '\tuint256 startOfThirdBonus = (startOfSecondBonus + 1) + 5 minutes;\n', '\tuint256 endOfThirdBonus = (startOfThirdBonus - 1) + 5 minutes;\n', '\tuint256 startOfFourthBonus = (startOfThirdBonus + 1) + 5 minutes;\n', '\tuint256 endOfFourthBonus = (startOfFourthBonus - 1) + 5 minutes;\n', '\tuint256 startOfFifthBonus = (startOfFourthBonus + 1) + 5 minutes;\n', '\tuint256 endOfFifthBonus = (startOfFifthBonus - 1) + 5 minutes;\n', '\t\n', '\t/**\n', '\t* Defining bonuses according to White Paper.\n', '\t* First week there is bonus 35%.\n', '\t* Second week there is bonus 30%.\n', '\t* Third week there is bonus 20%.\n', '\t* Fourth week there is bonus 10%.\n', '\t* Fifth week there is bonus 5%.\n', '\t*/\n', '\tuint256 firstBonus = 35;\n', '\tuint256 secondBonus = 30;\n', '\tuint256 thirdBonus = 20;\n', '\tuint256 fourthBonus = 10;\n', '\tuint256 fifthBonus = 5;\n', '\n', '\tevent BonusCalculated(uint256 tokenAmount);\n', '\n', '    function BonusScheme() public {\n', '        \n', '    }\n', '\n', '\t/**\n', '\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\n', '\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\n', '\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\n', '\t */\n', '\tfunction getBonusTokens(uint256 _tokenAmount)onlyOwner public returns(uint256) {\n', '\t\tif (block.timestamp >= startOfFirstBonus && block.timestamp <= endOfFirstBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfSecondBonus && block.timestamp <= endOfSecondBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfThirdBonus && block.timestamp <= endOfThirdBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFourthBonus && block.timestamp <= endOfFourthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFifthBonus && block.timestamp <= endOfFifthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\n', '\t\t} else _tokenAmount=0;\n', '\t\temit BonusCalculated(_tokenAmount);\n', '\t\treturn _tokenAmount;\n', '\t}\n', '}']