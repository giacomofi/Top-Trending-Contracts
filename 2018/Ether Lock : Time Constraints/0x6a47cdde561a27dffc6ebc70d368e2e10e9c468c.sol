['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract StandardToken  {\n', '  function balanceOf(address who) constant public returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public{\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract JPPreICO is owned{\n', '    \n', '    StandardToken token;\n', '    address walletAddress;\n', '    uint256 tokenPerEth;\n', '    uint256 startBlock;\n', '    uint256 endBlock;\n', '    uint256 minInvestmentInWei;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Buy(address indexed buyer, uint256 eth, uint256 JPT);\n', '    \n', '    function JPPreICO() public{\n', '        token = StandardToken(0xce4d20b74fAf8C1Ab15e2B0Fd3F1CCCfe6f6d419); // Token address\n', '        walletAddress=0x18aB7d43e9062d8656AE42EE9E473E05dE0DD3B9; //Wallet address\n', '        tokenPerEth=0; //Number of tokens for 1 eth\n', '        startBlock=5362919; //start block of pre ico\n', '        endBlock=5483879; //end block of pre ico\n', '        minInvestmentInWei=22121283624351108; //min investment in wei value\n', '    }\n', '\n', '    function () public payable {\n', '        require(msg.value>=minInvestmentInWei);\n', '        require(msg.data.length==0);\n', '        require((msg.value*tokenPerEth)/(10**16)<=token.balanceOf(this));//Check if pre ICO has enough tokens to transfer\n', '        require(isICOUp());//Check for temporal limits\n', '        uint256 coins = (msg.value * tokenPerEth)/(10**16);\n', '        walletAddress.transfer(msg.value);\n', '        token.transfer(msg.sender, coins);\n', '        //events\n', '        Transfer(this,msg.sender,coins);\n', '        Buy(msg.sender, msg.value, coins);\n', '    }\n', '    \n', '    \n', '    function getMaxEtherToInvest() public view returns (uint256){\n', '        return (token.balanceOf(this)/tokenPerEth);\n', '    }\n', '    \n', '    function setMinInvestmentInWei(uint256 _minInvestmentInWei) public onlyOwner {\n', '        minInvestmentInWei=_minInvestmentInWei;\n', '    }\n', '    \n', '    function isICOUp() public view returns(bool){\n', '        return (block.number>=startBlock && block.number<=endBlock);\n', '    }\n', '    \n', '    function setTokenPerEth (uint256 _change) public onlyOwner{\n', '    \ttokenPerEth = _change;\n', '    }\n', '    \n', '    \n', '    //Funzioni debug\n', '    function getWalletAddress() public view returns(address){\n', '        return walletAddress;\n', '    }\n', '    \n', '    function getTokenPerEth() public view returns(uint256){\n', '        return tokenPerEth;\n', '    }\n', '    \n', '    function getTokenBalance() public view returns(uint256){\n', '        return token.balanceOf(this);\n', '    }\n', '    \n', '    function setEndBlock(uint256 _endBlock) public onlyOwner{\n', '        endBlock=_endBlock;\n', '    }\n', '    \n', '    function setStartBlock(uint256 _startBlock) public onlyOwner{\n', '        startBlock=_startBlock;\n', '    }\n', '    \n', '    function sendBackTokens() public onlyOwner{\n', '        require(!isICOUp());\n', '        token.transfer(walletAddress,token.balanceOf(this));\n', '    }\n', ' \n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract StandardToken  {\n', '  function balanceOf(address who) constant public returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public{\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract JPPreICO is owned{\n', '    \n', '    StandardToken token;\n', '    address walletAddress;\n', '    uint256 tokenPerEth;\n', '    uint256 startBlock;\n', '    uint256 endBlock;\n', '    uint256 minInvestmentInWei;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Buy(address indexed buyer, uint256 eth, uint256 JPT);\n', '    \n', '    function JPPreICO() public{\n', '        token = StandardToken(0xce4d20b74fAf8C1Ab15e2B0Fd3F1CCCfe6f6d419); // Token address\n', '        walletAddress=0x18aB7d43e9062d8656AE42EE9E473E05dE0DD3B9; //Wallet address\n', '        tokenPerEth=0; //Number of tokens for 1 eth\n', '        startBlock=5362919; //start block of pre ico\n', '        endBlock=5483879; //end block of pre ico\n', '        minInvestmentInWei=22121283624351108; //min investment in wei value\n', '    }\n', '\n', '    function () public payable {\n', '        require(msg.value>=minInvestmentInWei);\n', '        require(msg.data.length==0);\n', '        require((msg.value*tokenPerEth)/(10**16)<=token.balanceOf(this));//Check if pre ICO has enough tokens to transfer\n', '        require(isICOUp());//Check for temporal limits\n', '        uint256 coins = (msg.value * tokenPerEth)/(10**16);\n', '        walletAddress.transfer(msg.value);\n', '        token.transfer(msg.sender, coins);\n', '        //events\n', '        Transfer(this,msg.sender,coins);\n', '        Buy(msg.sender, msg.value, coins);\n', '    }\n', '    \n', '    \n', '    function getMaxEtherToInvest() public view returns (uint256){\n', '        return (token.balanceOf(this)/tokenPerEth);\n', '    }\n', '    \n', '    function setMinInvestmentInWei(uint256 _minInvestmentInWei) public onlyOwner {\n', '        minInvestmentInWei=_minInvestmentInWei;\n', '    }\n', '    \n', '    function isICOUp() public view returns(bool){\n', '        return (block.number>=startBlock && block.number<=endBlock);\n', '    }\n', '    \n', '    function setTokenPerEth (uint256 _change) public onlyOwner{\n', '    \ttokenPerEth = _change;\n', '    }\n', '    \n', '    \n', '    //Funzioni debug\n', '    function getWalletAddress() public view returns(address){\n', '        return walletAddress;\n', '    }\n', '    \n', '    function getTokenPerEth() public view returns(uint256){\n', '        return tokenPerEth;\n', '    }\n', '    \n', '    function getTokenBalance() public view returns(uint256){\n', '        return token.balanceOf(this);\n', '    }\n', '    \n', '    function setEndBlock(uint256 _endBlock) public onlyOwner{\n', '        endBlock=_endBlock;\n', '    }\n', '    \n', '    function setStartBlock(uint256 _startBlock) public onlyOwner{\n', '        startBlock=_startBlock;\n', '    }\n', '    \n', '    function sendBackTokens() public onlyOwner{\n', '        require(!isICOUp());\n', '        token.transfer(walletAddress,token.balanceOf(this));\n', '    }\n', ' \n', '}']
