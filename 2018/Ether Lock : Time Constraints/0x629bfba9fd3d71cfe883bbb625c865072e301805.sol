['pragma solidity ^0.4.4;\n', '\n', '// mainnet: 0x629bfba9fd3d71cfe883bbb625c865072e301805\n', '\n', 'contract ERC223Token {\n', '  function transfer(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'contract Operations {\n', '\n', '  mapping (address => uint) public balances;\n', '  mapping (address => bytes32) public activeCall;\n', '\n', '  // remember who was call recipient based on callHash\n', '  mapping (bytes32 => address) public recipientsMap;\n', '\n', '  mapping (address => uint) public endCallRequestDate;\n', '\n', '  uint endCallRequestDelay = 1 hours;\n', '\n', '  ERC223Token public exy;\n', '\n', '  function Operations() public {\n', '    exy = ERC223Token(0xFA74F89A6d4a918167C51132614BbBE193Ee8c22);\n', '  }\n', '\n', '  // falback for EXY deposits\n', '  function tokenFallback(address _from, uint _value, bytes _data) public {\n', '    balances[_from] += _value;\n', '  }\n', '\n', '  function withdraw(uint value) public {\n', '    // dont allow to withdraw any balance if user have active call\n', '    require(activeCall[msg.sender] == 0x0);\n', '\n', '    uint balance = balances[msg.sender];\n', '\n', '    // requested value cant be greater than balance\n', '    require(value <= balance);\n', '\n', '    balances[msg.sender] -= value;\n', '    bytes memory empty;\n', '    exy.transfer(msg.sender, value, empty);\n', '  }\n', '\n', '  function startCall(uint timestamp, uint8 _v, bytes32 _r, bytes32 _s) public {\n', '    // address caller == ecrecover(...)\n', '    address recipient = msg.sender;\n', "    bytes32 callHash = keccak256('Experty.io startCall:', recipient, timestamp);\n", '    address caller = ecrecover(callHash, _v, _r, _s);\n', '\n', '    // caller cant start more than 1 call\n', '    require(activeCall[caller] == 0x0);\n', '\n', '    // save callHash for this caller\n', '    activeCall[caller] = callHash;\n', '    recipientsMap[callHash] = recipient;\n', '\n', '    // clean endCallRequestDate for this address\n', '    // if it was set before\n', '    endCallRequestDate[caller] = 0;\n', '  }\n', '\n', '  function endCall(bytes32 callHash, uint amount, uint8 _v, bytes32 _r, bytes32 _s) public {\n', '    // get recipient from map using callHash\n', '    address recipient = recipientsMap[callHash];\n', '\n', '    // only recipient can push this transaction\n', '    require(recipient == msg.sender);\n', '\n', "    bytes32 endHash = keccak256('Experty.io endCall:', recipient, callHash, amount);\n", '    address caller = ecrecover(endHash, _v, _r, _s);\n', '\n', '    // check if call hash was created by caller\n', '    require(activeCall[caller] == callHash);\n', '\n', '    uint maxAmount = amount;\n', '    if (maxAmount > balances[caller]) {\n', '      maxAmount = balances[caller];\n', '    }\n', '\n', '    // remove recipient address from map\n', '    recipientsMap[callHash] = 0x0;\n', '    // clean callHash from caller map\n', '    activeCall[caller] = 0x0;\n', '\n', '    settlePayment(caller, msg.sender, maxAmount);\n', '  }\n', '\n', '  // end call can be requested by caller\n', '  // if recipient did not published it\n', '  function requestEndCall() public {\n', '    // only caller can request end his call\n', '    require(activeCall[msg.sender] != 0x0);\n', '\n', '    // save current timestamp\n', '    endCallRequestDate[msg.sender] = block.timestamp;\n', '  }\n', '\n', '  // endCall can be called by caller only if he requested\n', '  // endCall more than endCallRequestDelay ago\n', '  function forceEndCall() public {\n', '    // only caller can request end his call\n', '    require(activeCall[msg.sender] != 0x0);\n', '    // endCallRequestDate needs to be set\n', '    require(endCallRequestDate[msg.sender] != 0);\n', '    require(endCallRequestDate[msg.sender] + endCallRequestDelay < block.timestamp);\n', '\n', '    endCallRequestDate[msg.sender] = 0;\n', '\n', '    // remove recipient address from map\n', '    recipientsMap[activeCall[msg.sender]] = 0x0;\n', '    // clean callHash from caller map\n', '    activeCall[msg.sender] = 0x0;\n', '  }\n', '\n', '  function settlePayment(address sender, address recipient, uint value) private {\n', '    balances[sender] -= value;\n', '    balances[recipient] += value;\n', '  }\n', '\n', '}']