['pragma solidity ^0.4.19;\n', '\n', 'contract IGold {\n', '    function balanceOf(address _owner) constant returns (uint256);\n', '    function issueTokens(address _who, uint _tokens);\n', '    function burnTokens(address _who, uint _tokens);\n', '}\n', '\n', '// StdToken inheritance is commented, because no &#39;totalSupply&#39; needed\n', 'contract IMNTP { /*is StdToken */\n', '    function balanceOf(address _owner) constant returns (uint256);\n', '\n', '    // Additional methods that MNTP contract provides\n', '    function lockTransfer(bool _lock);\n', '    function issueTokens(address _who, uint _tokens);\n', '    function burnTokens(address _who, uint _tokens);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '     }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract CreatorEnabled {\n', '    address public creator = 0x0;\n', '\n', '    modifier onlyCreator() { require(msg.sender == creator); _; }\n', '\n', '    function changeCreator(address _to) public onlyCreator {\n', '        creator = _to;\n', '    }\n', '}\n', '\n', 'contract StringMover {\n', '    function stringToBytes32(string s) constant returns(bytes32){\n', '        bytes32 out;\n', '        assembly {\n', '             out := mload(add(s, 32))\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function stringToBytes64(string s) constant returns(bytes32,bytes32){\n', '        bytes32 out;\n', '        bytes32 out2;\n', '\n', '        assembly {\n', '             out := mload(add(s, 32))\n', '             out2 := mload(add(s, 64))\n', '        }\n', '        return (out,out2);\n', '    }\n', '\n', '    function bytes32ToString(bytes32 x) constant returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '             if (char != 0) {\n', '                  bytesString[charCount] = char;\n', '                  charCount++;\n', '             }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '             bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '\n', '    function bytes64ToString(bytes32 x, bytes32 y) constant returns (string) {\n', '        bytes memory bytesString = new bytes(64);\n', '        uint charCount = 0;\n', '\n', '        for (uint j = 0; j < 32; j++) {\n', '             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '             if (char != 0) {\n', '                  bytesString[charCount] = char;\n', '                  charCount++;\n', '             }\n', '        }\n', '        for (j = 0; j < 32; j++) {\n', '             char = byte(bytes32(uint(y) * 2 ** (8 * j)));\n', '             if (char != 0) {\n', '                  bytesString[charCount] = char;\n', '                  charCount++;\n', '             }\n', '        }\n', '\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '             bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '\n', 'contract Storage is SafeMath, StringMover {\n', '    function Storage() public {\n', '        controllerAddress = msg.sender;\n', '    }\n', '\n', '    address public controllerAddress = 0x0;\n', '    modifier onlyController() { require(msg.sender==controllerAddress); _; }\n', '\n', '    function setControllerAddress(address _newController) onlyController {\n', '        controllerAddress = _newController;\n', '    }\n', '\n', '    address public hotWalletAddress = 0x0;\n', '\n', '    function setHotWalletAddress(address _address) onlyController {\n', '       hotWalletAddress = _address;\n', '    }\n', '\n', '\n', '    // Fields - 1\n', '    mapping(uint => string) docs;\n', '    uint public docCount = 0;\n', '\n', '    // Fields - 2\n', '    mapping(string => mapping(uint => int)) fiatTxs;\n', '    mapping(string => uint) fiatBalancesCents;\n', '    mapping(string => uint) fiatTxCounts;\n', '    uint fiatTxTotal = 0;\n', '\n', '    // Fields - 3\n', '    mapping(string => mapping(uint => int)) goldTxs;\n', '    mapping(string => uint) goldHotBalances;\n', '    mapping(string => uint) goldTxCounts;\n', '    uint goldTxTotal = 0;\n', '\n', '    // Fields - 4\n', '    struct Request {\n', '        address sender;\n', '        string userId;\n', '        string requestHash;\n', '        bool buyRequest;         // otherwise - sell\n', '\n', '        // 0 - init\n', '        // 1 - processed\n', '        // 2 - cancelled\n', '        uint8 state;\n', '    }\n', '\n', '    mapping (uint=>Request) requests;\n', '    uint public requestsCount = 0;\n', '\n', '    ///////\n', '    function addDoc(string _ipfsDocLink) public onlyController returns(uint) {\n', '        docs[docCount] = _ipfsDocLink;\n', '        uint out = docCount;\n', '        docCount++;\n', '\n', '        return out;\n', '    }\n', '\n', '    function getDocCount() public constant returns (uint) {\n', '        return docCount;\n', '    }\n', '\n', '    function getDocAsBytes64(uint _index) public constant returns (bytes32,bytes32) {\n', '        require(_index < docCount);\n', '        return stringToBytes64(docs[_index]);\n', '    }\n', '\n', '    function addFiatTransaction(string _userId, int _amountCents) public onlyController returns(uint) {\n', '        require(0 != _amountCents);\n', '\n', '        uint c = fiatTxCounts[_userId];\n', '\n', '        fiatTxs[_userId][c] = _amountCents;\n', '\n', '        if (_amountCents > 0) {\n', '            fiatBalancesCents[_userId] = safeAdd(fiatBalancesCents[_userId], uint(_amountCents));\n', '        } else {\n', '            fiatBalancesCents[_userId] = safeSub(fiatBalancesCents[_userId], uint(-_amountCents));\n', '        }\n', '\n', '        fiatTxCounts[_userId] = safeAdd(fiatTxCounts[_userId], 1);\n', '\n', '        fiatTxTotal++;\n', '        return c;\n', '    }\n', '\n', '    function getFiatTransactionsCount(string _userId) public constant returns (uint) {\n', '        return fiatTxCounts[_userId];\n', '    }\n', '\n', '    function getAllFiatTransactionsCount() public constant returns (uint) {\n', '        return fiatTxTotal;\n', '    }\n', '\n', '    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {\n', '        require(_index < fiatTxCounts[_userId]);\n', '        return fiatTxs[_userId][_index];\n', '    }\n', '\n', '    function getUserFiatBalance(string _userId) public constant returns(uint) {\n', '        return fiatBalancesCents[_userId];\n', '    }\n', '\n', '    function addGoldTransaction(string _userId, int _amount) public onlyController returns(uint) {\n', '        require(0 != _amount);\n', '\n', '        uint c = goldTxCounts[_userId];\n', '\n', '        goldTxs[_userId][c] = _amount;\n', '\n', '        if (_amount > 0) {\n', '            goldHotBalances[_userId] = safeAdd(goldHotBalances[_userId], uint(_amount));\n', '        } else {\n', '            goldHotBalances[_userId] = safeSub(goldHotBalances[_userId], uint(-_amount));\n', '        }\n', '\n', '        goldTxCounts[_userId] = safeAdd(goldTxCounts[_userId], 1);\n', '\n', '        goldTxTotal++;\n', '        return c;\n', '    }\n', '\n', '    function getGoldTransactionsCount(string _userId) public constant returns (uint) {\n', '        return goldTxCounts[_userId];\n', '    }\n', '\n', '    function getAllGoldTransactionsCount() public constant returns (uint) {\n', '        return goldTxTotal;\n', '    }\n', '\n', '    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {\n', '        require(_index < goldTxCounts[_userId]);\n', '        return goldTxs[_userId][_index];\n', '    }\n', '\n', '    function getUserHotGoldBalance(string _userId) public constant returns(uint) {\n', '        return goldHotBalances[_userId];\n', '    }\n', '\n', '    function addBuyTokensRequest(address _who, string _userId, string _requestHash) public onlyController returns(uint) {\n', '        Request memory r;\n', '        r.sender = _who;\n', '        r.userId = _userId;\n', '        r.requestHash = _requestHash;\n', '        r.buyRequest = true;\n', '        r.state = 0;\n', '\n', '        requests[requestsCount] = r;\n', '        uint out = requestsCount;\n', '        requestsCount++;\n', '        return out;\n', '    }\n', '\n', '    function addSellTokensRequest(address _who, string _userId, string _requestHash) onlyController returns(uint) {\n', '        Request memory r;\n', '        r.sender = _who;\n', '        r.userId = _userId;\n', '        r.requestHash = _requestHash;\n', '        r.buyRequest = false;\n', '        r.state = 0;\n', '\n', '        requests[requestsCount] = r;\n', '        uint out = requestsCount;\n', '        requestsCount++;\n', '        return out;\n', '    }\n', '\n', '    function getRequestsCount() public constant returns(uint) {\n', '        return requestsCount;\n', '    }\n', '\n', '    function getRequest(uint _index) public constant returns(\n', '        address a,\n', '        bytes32 userId,\n', '        bytes32 hashA, bytes32 hashB,\n', '        bool buy, uint8 state)\n', '    {\n', '        require(_index < requestsCount);\n', '\n', '        Request memory r = requests[_index];\n', '\n', '        bytes32 userBytes = stringToBytes32(r.userId);\n', '        var (out1, out2) = stringToBytes64(r.requestHash);\n', '\n', '        return (r.sender, userBytes, out1, out2, r.buyRequest, r.state);\n', '    }\n', '\n', '    function cancelRequest(uint _index) onlyController public {\n', '        require(_index < requestsCount);\n', '        require(0==requests[_index].state);\n', '\n', '        requests[_index].state = 2;\n', '    }\n', '\n', '    function setRequestProcessed(uint _index) onlyController public {\n', '        requests[_index].state = 1;\n', '    }\n', '}\n', '\n', 'contract GoldFiatFee is CreatorEnabled, StringMover {\n', '    string gmUserId = "";\n', '\n', '    // Functions:\n', '    function GoldFiatFee(string _gmUserId) {\n', '        creator = msg.sender;\n', '        gmUserId = _gmUserId;\n', '    }\n', '\n', '    function getGoldmintFeeAccount() public constant returns(bytes32) {\n', '        bytes32 userBytes = stringToBytes32(gmUserId);\n', '        return userBytes;\n', '    }\n', '\n', '    function setGoldmintFeeAccount(string _gmUserId) public onlyCreator {\n', '        gmUserId = _gmUserId;\n', '    }\n', '\n', '    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {\n', '        return 0;\n', '    }\n', '\n', '    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {\n', '        // If the sender holds 0 MNTP, then the transaction fee is 3% fiat,\n', '        // If the sender holds at least 10 MNTP, then the transaction fee is 2% fiat,\n', '        // If the sender holds at least 1000 MNTP, then the transaction fee is 1.5% fiat,\n', '        // If the sender holds at least 10000 MNTP, then the transaction fee is 1% fiat,\n', '        if (_mntpBalance >= (10000 * 1 ether)) {\n', '             return (75 * _goldValue / 10000);\n', '        }\n', '\n', '        if (_mntpBalance >= (1000 * 1 ether)) {\n', '             return (15 * _goldValue / 1000);\n', '        }\n', '\n', '        if (_mntpBalance >= (10 * 1 ether)) {\n', '             return (25 * _goldValue / 1000);\n', '        }\n', '\n', '        // 3%\n', '        return (3 * _goldValue / 100);\n', '    }\n', '}\n', '\n', 'contract IGoldFiatFee {\n', '    function getGoldmintFeeAccount()public constant returns(bytes32);\n', '    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);\n', '    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);\n', '}\n', '\n', 'contract StorageController is SafeMath, CreatorEnabled, StringMover {\n', '    Storage public stor;\n', '    IMNTP public mntpToken;\n', '    IGold public goldToken;\n', '    IGoldFiatFee public fiatFee;\n', '\n', '    address public ethDepositAddress = 0x0;\n', '    address public managerAddress = 0x0;\n', '\n', '    event NewTokenBuyRequest(address indexed _from, string indexed _userId);\n', '    event NewTokenSellRequest(address indexed _from, string indexed _userId);\n', '    event RequestCancelled(uint indexed _reqId);\n', '    event RequestProcessed(uint indexed _reqId);\n', '    event EthDeposited(uint indexed _requestId, address indexed _address, uint _ethValue);\n', '\n', '    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }\n', '\n', '    function StorageController(address _mntpContractAddress, address _goldContractAddress, address _storageAddress, address _fiatFeeContract) {\n', '        creator = msg.sender;\n', '\n', '        if (0 != _storageAddress) {\n', '             // use existing storage\n', '             stor = Storage(_storageAddress);\n', '        } else {\n', '             stor = new Storage();\n', '        }\n', '\n', '        require(0x0!=_mntpContractAddress);\n', '        require(0x0!=_goldContractAddress);\n', '        require(0x0!=_fiatFeeContract);\n', '\n', '        mntpToken = IMNTP(_mntpContractAddress);\n', '        goldToken = IGold(_goldContractAddress);\n', '        fiatFee = IGoldFiatFee(_fiatFeeContract);\n', '    }\n', '\n', '    function setEthDepositAddress(address _address) public onlyCreator {\n', '       ethDepositAddress = _address;\n', '    }\n', '\n', '    function setManagerAddress(address _address) public onlyCreator {\n', '       managerAddress = _address;\n', '    }\n', '\n', '    function getEthDepositAddress() public constant returns (address) {\n', '       return ethDepositAddress;\n', '    }\n', '\n', '    // Only old controller can call setControllerAddress\n', '    function changeController(address _newController) public onlyCreator {\n', '        stor.setControllerAddress(_newController);\n', '    }\n', '\n', '    function setHotWalletAddress(address _hotWalletAddress) public onlyCreator {\n', '       stor.setHotWalletAddress(_hotWalletAddress);\n', '    }\n', '\n', '    function getHotWalletAddress() public constant returns (address) {\n', '        return stor.hotWalletAddress();\n', '    }\n', '\n', '    function changeFiatFeeContract(address _newFiatFee) public onlyCreator {\n', '        fiatFee = IGoldFiatFee(_newFiatFee);\n', '    }\n', '\n', '    function addDoc(string _ipfsDocLink) public onlyCreator returns(uint) {\n', '        return stor.addDoc(_ipfsDocLink);\n', '    }\n', '\n', '    function getDocCount() public constant returns (uint) {\n', '        return stor.docCount();\n', '    }\n', '\n', '    function getDoc(uint _index) public constant returns (string) {\n', '        var (x, y) = stor.getDocAsBytes64(_index);\n', '        return bytes64ToString(x,y);\n', '    }\n', '\n', '\n', '    // _amountCents can be negative\n', '    // returns index in user array\n', '    function addFiatTransaction(string _userId, int _amountCents) public onlyManagerOrCreator returns(uint) {\n', '        return stor.addFiatTransaction(_userId, _amountCents);\n', '    }\n', '\n', '    function getFiatTransactionsCount(string _userId) public constant returns (uint) {\n', '        return stor.getFiatTransactionsCount(_userId);\n', '    }\n', '\n', '    function getAllFiatTransactionsCount() public constant returns (uint) {\n', '        return stor.getAllFiatTransactionsCount();\n', '    }\n', '\n', '    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {\n', '        return stor.getFiatTransaction(_userId, _index);\n', '    }\n', '\n', '    function getUserFiatBalance(string _userId) public constant returns(uint) {\n', '        return stor.getUserFiatBalance(_userId);\n', '    }\n', '\n', '    function addGoldTransaction(string _userId, int _amount) public onlyManagerOrCreator returns(uint) {\n', '        return stor.addGoldTransaction(_userId, _amount);\n', '    }\n', '\n', '    function getGoldTransactionsCount(string _userId) public constant returns (uint) {\n', '        return stor.getGoldTransactionsCount(_userId);\n', '    }\n', '\n', '    function getAllGoldTransactionsCount() public constant returns (uint) {\n', '        return stor.getAllGoldTransactionsCount();\n', '    }\n', '\n', '    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {\n', '        require(keccak256(_userId) != keccak256(""));\n', '\n', '        return stor.getGoldTransaction(_userId, _index);\n', '    }\n', '\n', '    function getUserHotGoldBalance(string _userId) public constant returns(uint) {\n', '        require(keccak256(_userId) != keccak256(""));\n', '\n', '        return stor.getUserHotGoldBalance(_userId);\n', '    }\n', '\n', '\n', '    function addBuyTokensRequest(string _userId, string _requestHash) public returns(uint) {\n', '        require(keccak256(_userId) != keccak256(""));\n', '\n', '        NewTokenBuyRequest(msg.sender, _userId);\n', '        return stor.addBuyTokensRequest(msg.sender, _userId, _requestHash);\n', '    }\n', '\n', '    function addSellTokensRequest(string _userId, string _requestHash) public returns(uint) {\n', '      require(keccak256(_userId) != keccak256(""));\n', '\n', '      NewTokenSellRequest(msg.sender, _userId);\n', '\n', '    return stor.addSellTokensRequest(msg.sender, _userId, _requestHash);\n', '    }\n', '\n', '    function getRequestsCount() public constant returns(uint) {\n', '        return stor.getRequestsCount();\n', '    }\n', '\n', '    function getRequest(uint _index) public constant returns(address, string, string, bool, uint8) {\n', '        var (sender, userIdBytes, hashA, hashB, buy, state) = stor.getRequest(_index);\n', '\n', '        string memory userId = bytes32ToString(userIdBytes);\n', '        string memory hash = bytes64ToString(hashA, hashB);\n', '\n', '        return (sender, userId, hash, buy, state);\n', '    }\n', '\n', '    function cancelRequest(uint _index) onlyManagerOrCreator public {\n', '        RequestCancelled(_index);\n', '        stor.cancelRequest(_index);\n', '    }\n', '\n', '    function processRequest(uint _index, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {\n', '        require(_index < getRequestsCount());\n', '\n', '        var (sender, userId, hash, isBuy, state) = getRequest(_index);\n', '        require(0 == state);\n', '\n', '        if (isBuy) {\n', '             processBuyRequest(userId, sender, _amountCents, _centsPerGold);\n', '        } else {\n', '             processSellRequest(userId, sender, _amountCents, _centsPerGold);\n', '        }\n', '\n', '        // 3 - update state\n', '        stor.setRequestProcessed(_index);\n', '\n', '        // 4 - send event\n', '        RequestProcessed(_index);\n', '    }\n', '\n', '    function processBuyRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {\n', '        require(keccak256(_userId) != keccak256(""));\n', '\n', '        uint userFiatBalance = getUserFiatBalance(_userId);\n', '        require(userFiatBalance > 0);\n', '\n', '        if (_amountCents > userFiatBalance) {\n', '             _amountCents = userFiatBalance;\n', '        }\n', '\n', '        uint userMntpBalance = mntpToken.balanceOf(_userAddress);\n', '        uint fee = fiatFee.calculateBuyGoldFee(userMntpBalance, _amountCents);\n', '        require(_amountCents > fee);\n', '\n', '        // 1 - issue tokens minus fee\n', '        uint amountMinusFee = _amountCents;\n', '        if (fee > 0) {\n', '             amountMinusFee = safeSub(_amountCents, fee);\n', '        }\n', '\n', '        require(amountMinusFee > 0);\n', '\n', '        uint tokens = (uint(amountMinusFee) * 1 ether) / _centsPerGold;\n', '        issueGoldTokens(_userAddress, tokens);\n', '\n', '        // request from hot wallet\n', '        if (isHotWallet(_userAddress)) {\n', '          addGoldTransaction(_userId, int(tokens));\n', '        }\n', '\n', '        // 2 - add fiat tx\n', '        // negative for buy (total amount including fee!)\n', '        addFiatTransaction(_userId, - int(_amountCents));\n', '\n', '        // 3 - send fee to Goldmint\n', '        // positive for sell\n', '        if (fee > 0) {\n', '             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());\n', '             addFiatTransaction(gmAccount, int(fee));\n', '        }\n', '    }\n', '\n', '    function processSellRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {\n', '        require(keccak256(_userId) != keccak256(""));\n', '\n', '        uint tokens = (uint(_amountCents) * 1 ether) / _centsPerGold;\n', '        uint tokenBalance = goldToken.balanceOf(_userAddress);\n', '\n', '        if (isHotWallet(_userAddress)) {\n', '            tokenBalance = getUserHotGoldBalance(_userId);\n', '        }\n', '\n', '        if (tokenBalance < tokens) {\n', '             tokens = tokenBalance;\n', '             _amountCents = uint((tokens * _centsPerGold) / 1 ether);\n', '        }\n', '\n', '        burnGoldTokens(_userAddress, tokens);\n', '\n', '        // request from hot wallet\n', '        if (isHotWallet(_userAddress)) {\n', '          addGoldTransaction(_userId, - int(tokens));\n', '        }\n', '\n', '        // 2 - add fiat tx\n', '        uint userMntpBalance = mntpToken.balanceOf(_userAddress);\n', '        uint fee = fiatFee.calculateSellGoldFee(userMntpBalance, _amountCents);\n', '        require(_amountCents > fee);\n', '\n', '        uint amountMinusFee = _amountCents;\n', '\n', '        if (fee > 0) {\n', '             amountMinusFee = safeSub(_amountCents, fee);\n', '        }\n', '\n', '        require(amountMinusFee > 0);\n', '        // positive for sell\n', '        addFiatTransaction(_userId, int(amountMinusFee));\n', '\n', '        // 3 - send fee to Goldmint\n', '        if (fee > 0) {\n', '             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());\n', '             addFiatTransaction(gmAccount, int(fee));\n', '        }\n', '    }\n', '\n', '    //////// INTERNAL REQUESTS FROM HOT WALLET\n', '    function processInternalRequest(string _userId, bool _isBuy, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {\n', '      if (_isBuy) {\n', '          processBuyRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);\n', '      } else {\n', '          processSellRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);\n', '      }\n', '    }\n', '\n', '    function transferGoldFromHotWallet(address _to, uint _value, string _userId) onlyManagerOrCreator public {\n', '      require(keccak256(_userId) != keccak256(""));\n', '\n', '      uint balance = getUserHotGoldBalance(_userId);\n', '      require(balance >= _value);\n', '\n', '      goldToken.burnTokens(getHotWalletAddress(), _value);\n', '      goldToken.issueTokens(_to, _value);\n', '\n', '      addGoldTransaction(_userId, -int(_value));\n', '    }\n', '\n', '    ////////\n', '    function issueGoldTokens(address _userAddress, uint _tokenAmount) internal {\n', '        require(0!=_tokenAmount);\n', '        goldToken.issueTokens(_userAddress, _tokenAmount);\n', '    }\n', '\n', '    function burnGoldTokens(address _userAddress, uint _tokenAmount) internal {\n', '        require(0!=_tokenAmount);\n', '        goldToken.burnTokens(_userAddress, _tokenAmount);\n', '    }\n', '\n', '    function isHotWallet(address _address) internal returns(bool) {\n', '       return _address == getHotWalletAddress();\n', '    }\n', '\n', '    ///////\n', '    function depositEth(uint _requestId) public payable {\n', '      require(ethDepositAddress != 0x0);\n', '      //min deposit is 0.01 ETH\n', '      require(msg.value >= 0.01 * 1 ether);\n', '\n', '      ethDepositAddress.transfer(msg.value);\n', '\n', '      EthDeposited(_requestId, msg.sender, msg.value);\n', '    }\n', '\n', '    // do not allow to send money to this contract...\n', '    function() external payable {\n', '      revert();\n', '    }\n', '}']