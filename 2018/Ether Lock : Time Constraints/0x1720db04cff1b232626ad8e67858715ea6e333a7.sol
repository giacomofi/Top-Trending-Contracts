['pragma solidity ^0.4.24;\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Copyright (c) 2018 Decentralization Authority MDAO.\n', ' * Released under the MIT License.\n', ' *\n', ' * ZeroGold POW Mining\n', ' * \n', ' * An ERC20 token wallet which dispenses tokens via Proof of Work mining.\n', ' * Based on recommendation from /u/diego_91\n', ' * \n', ' * Version 18.8.19\n', ' *\n', ' * Web    : https://d14na.org\n', ' * Email  : <span class="__cf_email__" data-cfemail="592a2c2929362b2d193d686d373877362b3e">[email&#160;protected]</span>\n', ' */\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * SafeMath\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Owned contract\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC Token Standard #20 Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC 918 Mineable Token Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-918.md\n', ' */\n', 'contract ERC918Interface {\n', '    function getChallengeNumber() public constant returns (bytes32);\n', '    function getMiningDifficulty() public constant returns (uint);\n', '    function getMiningTarget() public constant returns (uint);\n', '    function getMiningReward() public constant returns (uint);\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    address public lastRewardTo;\n', '    uint public lastRewardAmount;\n', '    uint public lastRewardEthBlockNumber;\n', '    bytes32 public challengeNumber;\n', '}\n', '\n', '/*******************************************************************************\n', ' *\n', ' * @notice ZeroGoldDust - Merged Mining Contract\n', ' *\n', ' * @dev This is a standard ERC20 mineable token contract.\n', ' */\n', 'contract ZeroGoldPOWMining is Owned {\n', '    using SafeMath for uint;\n', '\n', '    /* Initialize the ZeroGold contract. */\n', '    ERC20Interface zeroGold;\n', '    \n', '    /* Initialize the Mining Leader contract. */\n', '    ERC918Interface public miningLeader;\n', '    \n', '    /* Initialize the Mint Helper. */\n', '    address public mintHelper = 0x0;\n', '\n', '    modifier onlyMintHelper {\n', '        require(msg.sender == mintHelper);\n', '        _;\n', '    }\n', '    \n', '    /* Reward divisor. */\n', '    // NOTE A value of 20 means the reward is 1/20 (5%) \n', '    //      of current tokens held in the quarry. \n', '    uint rewardDivisor = 20;\n', '\n', '    /* Number of times this has been mined. */\n', '    uint epochCount = 0;\n', '    \n', '    /* Initialize last reward value. */\n', '    uint public lastRewardAmount = 0;\n', '\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    constructor(address _miningLeader, address _mintHelper) public  {\n', '        /* Initialize the mining leader. */\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '\n', '        /* Initialize the mint helper (address ONLY). */\n', '        mintHelper = _mintHelper;\n', '\n', '        /* Initialize the ZeroGold contract. */\n', '        // NOTE We hard-code the address here, since it should never change.\n', '        zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968);\n', '    }\n', '\n', '    /**\n', '     * Merge\n', '     * (called from our mining leader)\n', '     * \n', '     * Ensure that mergeMint() can only be called once per Parent::mint().\n', '     * Do this by ensuring that the "new" challenge number from \n', '     * Parent::challenge post mint can be called once and that this block time \n', '     * is the same as this mint, and the caller is msg.sender.\n', '     * \n', '     * Only allow one reward for each challenge. Do this by calculating what \n', '     * the new challenge will be in _startNewMiningEpoch, and verify that \n', '     * it is not that value this checks happen in the local contract, not in the parent\n', '     * \n', '     */\n', '    function merge() external onlyMintHelper returns (bool success) {\n', '        /* Retrieve the future challenge number from mining leader. */\n', '        bytes32 futureChallengeNumber = blockhash(block.number - 1);\n', '\n', '        /* Retrieve the challenge number from the mining leader. */\n', '        bytes32 challengeNumber = miningLeader.getChallengeNumber();\n', '\n', '        /* Verify the next challenge is different from the current. */\n', '        if (challengeNumber == futureChallengeNumber) {\n', '            // NOTE This is likely the second time that merge() has been\n', '            //      called in a transaction, so return false (don&#39;t revert).\n', '            return false; \n', '        }\n', '\n', '        /* Verify Parent::lastRewardTo == msg.sender. */\n', '        if (miningLeader.lastRewardTo() != msg.sender) {\n', '            // NOTE A different address called mint last \n', '            //      so return false (don&#39;t revert).\n', '            return false;\n', '        }\n', '            \n', '        /* Verify Parent::lastRewardEthBlockNumber == block.number. */\n', '        if (miningLeader.lastRewardEthBlockNumber() != block.number) {\n', '            // NOTE parent::mint() was called in a different block number \n', '            //      so return false (don&#39;t revert).\n', '            return false;\n', '        }\n', '\n', '        // We now update the solutionForChallenge hashmap with the value of \n', '        // parent::challengeNumber when a solution is merge minted. Only allow \n', '        // one reward for each challenge based on parent::challengeNumber.\n', '        bytes32 parentChallengeNumber = miningLeader.challengeNumber();\n', '        bytes32 solution = solutionForChallenge[parentChallengeNumber];\n', '        if (solution != 0x0) return false; // prevent the same answer from awarding twice\n', '        \n', '        bytes32 digest = &#39;merge&#39;;\n', '        solutionForChallenge[parentChallengeNumber] = digest;\n', '\n', '        // We may safely run the relevant logic to give an award to the sender, \n', '        // and update the contract.\n', '        \n', '        /* Retrieve the reward value. */\n', '        uint rewardAmount = getRewardAmount();\n', '\n', '        /* Retrieve our ZeroGold balance. */\n', '        uint balance = zeroGold.balanceOf(address(this));\n', '\n', '        /* Verify that we are not trying to transfer more than we HODL. */\n', '        assert(rewardAmount <= balance);\n', '\n', '        /* Set last reward amount. */\n', '        // NOTE `lastRewardAmount` is called from MintHelper during `merge` \n', '        //      to assign `merge_totalReward`.\n', '        lastRewardAmount = rewardAmount;\n', '        \n', '        /* Increment the epoch count. */\n', '        epochCount = epochCount.add(1);\n', '\n', '        // NOTE: Use 0 to indicate a merge mine.\n', '        emit Mint(msg.sender, rewardAmount, epochCount, 0);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Transfer the ZeroGold reward to our mining leader&#39;s payout wallets. */\n', '    // NOTE This function will be called twice by MintHelper.merge(), \n', '    //      once for `minterWallet` and once for `payoutsWallet`.\n', '    function transfer(\n', '        address _wallet, \n', '        uint _reward\n', '    ) external onlyMintHelper returns (bool) {\n', '        /* Verify our mining leader isn&#39;t trying to over reward its wallets. */\n', '        if (_reward > lastRewardAmount) {\n', '            return false;\n', '        }\n', '            \n', '        /* Reduce the last reward amount. */\n', '        lastRewardAmount = lastRewardAmount.sub(_reward);\n', '\n', '        /* Transfer the ZeroGold to mining leader. */\n', '        zeroGold.transfer(_wallet, _reward);\n', '    }\n', '\n', '    /* Calculate the current reward value. */\n', '    function getRewardAmount() public constant returns (uint) {\n', '        /* Retrieve the balance of the mineable token. */\n', '        uint totalBalance = zeroGold.balanceOf(address(this));\n', '\n', '        return totalBalance.div(rewardDivisor);\n', '    }\n', '\n', '    /* Set the mining leader. */\n', '    function setMiningLeader(address _miningLeader) external onlyOwner {\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '    }\n', '\n', '    /* Set the mint helper. */\n', '    function setMintHelper(address _mintHelper) external onlyOwner {\n', '        mintHelper = _mintHelper;\n', '    }\n', '\n', '    /* Set the reward divisor. */\n', '    function setRewardDivisor(uint _rewardDivisor) external onlyOwner {\n', '        rewardDivisor = _rewardDivisor;\n', '    }\n', '\n', '    /**\n', '     * THIS CONTRACT DOES NOT ACCEPT DIRECT ETHER\n', '     */\n', '    function () public payable {\n', '        /* Cancel this transaction. */\n', '        revert(&#39;Oops! Direct payments are NOT permitted here.&#39;);\n', '    }\n', '\n', '    /**\n', '     * Transfer Any ERC20 Token\n', '     *\n', '     * @notice Owner can transfer out any accidentally sent ERC20 tokens.\n', '     *\n', '     * @dev Provides an ERC20 interface, which allows for the recover\n', '     *      of any accidentally sent ERC20 tokens.\n', '     */\n', '    function transferAnyERC20Token(\n', '        address tokenAddress, uint tokens\n', '    ) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Copyright (c) 2018 Decentralization Authority MDAO.\n', ' * Released under the MIT License.\n', ' *\n', ' * ZeroGold POW Mining\n', ' * \n', ' * An ERC20 token wallet which dispenses tokens via Proof of Work mining.\n', ' * Based on recommendation from /u/diego_91\n', ' * \n', ' * Version 18.8.19\n', ' *\n', ' * Web    : https://d14na.org\n', ' * Email  : support@d14na.org\n', ' */\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * SafeMath\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Owned contract\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC Token Standard #20 Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC 918 Mineable Token Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-918.md\n', ' */\n', 'contract ERC918Interface {\n', '    function getChallengeNumber() public constant returns (bytes32);\n', '    function getMiningDifficulty() public constant returns (uint);\n', '    function getMiningTarget() public constant returns (uint);\n', '    function getMiningReward() public constant returns (uint);\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    address public lastRewardTo;\n', '    uint public lastRewardAmount;\n', '    uint public lastRewardEthBlockNumber;\n', '    bytes32 public challengeNumber;\n', '}\n', '\n', '/*******************************************************************************\n', ' *\n', ' * @notice ZeroGoldDust - Merged Mining Contract\n', ' *\n', ' * @dev This is a standard ERC20 mineable token contract.\n', ' */\n', 'contract ZeroGoldPOWMining is Owned {\n', '    using SafeMath for uint;\n', '\n', '    /* Initialize the ZeroGold contract. */\n', '    ERC20Interface zeroGold;\n', '    \n', '    /* Initialize the Mining Leader contract. */\n', '    ERC918Interface public miningLeader;\n', '    \n', '    /* Initialize the Mint Helper. */\n', '    address public mintHelper = 0x0;\n', '\n', '    modifier onlyMintHelper {\n', '        require(msg.sender == mintHelper);\n', '        _;\n', '    }\n', '    \n', '    /* Reward divisor. */\n', '    // NOTE A value of 20 means the reward is 1/20 (5%) \n', '    //      of current tokens held in the quarry. \n', '    uint rewardDivisor = 20;\n', '\n', '    /* Number of times this has been mined. */\n', '    uint epochCount = 0;\n', '    \n', '    /* Initialize last reward value. */\n', '    uint public lastRewardAmount = 0;\n', '\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    constructor(address _miningLeader, address _mintHelper) public  {\n', '        /* Initialize the mining leader. */\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '\n', '        /* Initialize the mint helper (address ONLY). */\n', '        mintHelper = _mintHelper;\n', '\n', '        /* Initialize the ZeroGold contract. */\n', '        // NOTE We hard-code the address here, since it should never change.\n', '        zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968);\n', '    }\n', '\n', '    /**\n', '     * Merge\n', '     * (called from our mining leader)\n', '     * \n', '     * Ensure that mergeMint() can only be called once per Parent::mint().\n', '     * Do this by ensuring that the "new" challenge number from \n', '     * Parent::challenge post mint can be called once and that this block time \n', '     * is the same as this mint, and the caller is msg.sender.\n', '     * \n', '     * Only allow one reward for each challenge. Do this by calculating what \n', '     * the new challenge will be in _startNewMiningEpoch, and verify that \n', '     * it is not that value this checks happen in the local contract, not in the parent\n', '     * \n', '     */\n', '    function merge() external onlyMintHelper returns (bool success) {\n', '        /* Retrieve the future challenge number from mining leader. */\n', '        bytes32 futureChallengeNumber = blockhash(block.number - 1);\n', '\n', '        /* Retrieve the challenge number from the mining leader. */\n', '        bytes32 challengeNumber = miningLeader.getChallengeNumber();\n', '\n', '        /* Verify the next challenge is different from the current. */\n', '        if (challengeNumber == futureChallengeNumber) {\n', '            // NOTE This is likely the second time that merge() has been\n', "            //      called in a transaction, so return false (don't revert).\n", '            return false; \n', '        }\n', '\n', '        /* Verify Parent::lastRewardTo == msg.sender. */\n', '        if (miningLeader.lastRewardTo() != msg.sender) {\n', '            // NOTE A different address called mint last \n', "            //      so return false (don't revert).\n", '            return false;\n', '        }\n', '            \n', '        /* Verify Parent::lastRewardEthBlockNumber == block.number. */\n', '        if (miningLeader.lastRewardEthBlockNumber() != block.number) {\n', '            // NOTE parent::mint() was called in a different block number \n', "            //      so return false (don't revert).\n", '            return false;\n', '        }\n', '\n', '        // We now update the solutionForChallenge hashmap with the value of \n', '        // parent::challengeNumber when a solution is merge minted. Only allow \n', '        // one reward for each challenge based on parent::challengeNumber.\n', '        bytes32 parentChallengeNumber = miningLeader.challengeNumber();\n', '        bytes32 solution = solutionForChallenge[parentChallengeNumber];\n', '        if (solution != 0x0) return false; // prevent the same answer from awarding twice\n', '        \n', "        bytes32 digest = 'merge';\n", '        solutionForChallenge[parentChallengeNumber] = digest;\n', '\n', '        // We may safely run the relevant logic to give an award to the sender, \n', '        // and update the contract.\n', '        \n', '        /* Retrieve the reward value. */\n', '        uint rewardAmount = getRewardAmount();\n', '\n', '        /* Retrieve our ZeroGold balance. */\n', '        uint balance = zeroGold.balanceOf(address(this));\n', '\n', '        /* Verify that we are not trying to transfer more than we HODL. */\n', '        assert(rewardAmount <= balance);\n', '\n', '        /* Set last reward amount. */\n', '        // NOTE `lastRewardAmount` is called from MintHelper during `merge` \n', '        //      to assign `merge_totalReward`.\n', '        lastRewardAmount = rewardAmount;\n', '        \n', '        /* Increment the epoch count. */\n', '        epochCount = epochCount.add(1);\n', '\n', '        // NOTE: Use 0 to indicate a merge mine.\n', '        emit Mint(msg.sender, rewardAmount, epochCount, 0);\n', '\n', '        return true;\n', '    }\n', '\n', "    /* Transfer the ZeroGold reward to our mining leader's payout wallets. */\n", '    // NOTE This function will be called twice by MintHelper.merge(), \n', '    //      once for `minterWallet` and once for `payoutsWallet`.\n', '    function transfer(\n', '        address _wallet, \n', '        uint _reward\n', '    ) external onlyMintHelper returns (bool) {\n', "        /* Verify our mining leader isn't trying to over reward its wallets. */\n", '        if (_reward > lastRewardAmount) {\n', '            return false;\n', '        }\n', '            \n', '        /* Reduce the last reward amount. */\n', '        lastRewardAmount = lastRewardAmount.sub(_reward);\n', '\n', '        /* Transfer the ZeroGold to mining leader. */\n', '        zeroGold.transfer(_wallet, _reward);\n', '    }\n', '\n', '    /* Calculate the current reward value. */\n', '    function getRewardAmount() public constant returns (uint) {\n', '        /* Retrieve the balance of the mineable token. */\n', '        uint totalBalance = zeroGold.balanceOf(address(this));\n', '\n', '        return totalBalance.div(rewardDivisor);\n', '    }\n', '\n', '    /* Set the mining leader. */\n', '    function setMiningLeader(address _miningLeader) external onlyOwner {\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '    }\n', '\n', '    /* Set the mint helper. */\n', '    function setMintHelper(address _mintHelper) external onlyOwner {\n', '        mintHelper = _mintHelper;\n', '    }\n', '\n', '    /* Set the reward divisor. */\n', '    function setRewardDivisor(uint _rewardDivisor) external onlyOwner {\n', '        rewardDivisor = _rewardDivisor;\n', '    }\n', '\n', '    /**\n', '     * THIS CONTRACT DOES NOT ACCEPT DIRECT ETHER\n', '     */\n', '    function () public payable {\n', '        /* Cancel this transaction. */\n', "        revert('Oops! Direct payments are NOT permitted here.');\n", '    }\n', '\n', '    /**\n', '     * Transfer Any ERC20 Token\n', '     *\n', '     * @notice Owner can transfer out any accidentally sent ERC20 tokens.\n', '     *\n', '     * @dev Provides an ERC20 interface, which allows for the recover\n', '     *      of any accidentally sent ERC20 tokens.\n', '     */\n', '    function transferAnyERC20Token(\n', '        address tokenAddress, uint tokens\n', '    ) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
