['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract BlockWar {\n', '    using SafeMath for uint256;\n', '    address owner;\n', '    mapping (uint => mapping(address => uint)) public leftUserBlockNumber;\n', '    mapping (uint => mapping(address => uint)) public rightUserBlockNumber;\n', '    mapping (uint => bool) public mapGameLeftWin;  // 0 for left, 1 for right\n', '    mapping (uint => uint) public mapGamePrizePerBlock;  // gamePrizePerBlock\n', '    mapping (address => uint) public userWithdrawRound;  //round lower than userWithdrawRound has withdraw\n', '    uint currentRound = 0;\n', '    uint leftBlockNumber = 0;\n', '    uint rightBlockNumber = 0;\n', '    uint maxBlockNumber = 500;  \n', '    uint buildFee = 100 finney;\n', '    uint gameStartTimestamp;  // if gameEnded and currentRound==0 wait gameStartTimestamp\n', '    uint gameIntervalTimestamp = 600;  // how many seconds game start after game end\n', '    uint gamePrizePool = 0;  // game prize pool\n', '    uint public gameLength = 10800;  \n', '    uint public doCallNumber;\n', '    /* Modifiers */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyInGame() {\n', '        require(now > gameStartTimestamp);\n', '        _;\n', '    }\n', '\n', '    /* Owner */\n', '    function setOwner (address _owner) onlyOwner() public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function BlockWar() public {\n', '        owner = msg.sender;\n', '        gameStartTimestamp = 1535605200;  // set gameStartTimestamp\n', '    }\n', '\n', '    function getBlockBuildFee(uint currentBlockNumber) public view returns(uint) {\n', '        if (currentBlockNumber <= 10) {\n', '            return 0;\n', '        }\n', '        if (currentBlockNumber <= 20) {\n', '            return buildFee.div(4);\n', '        }\n', '\t\tif (currentBlockNumber <= 100) {\n', '\t\t\treturn buildFee.div(2);  // 50 percent\n', '\t\t}\n', '\t\tif (currentBlockNumber <= 200) {\n', '\t\t\treturn buildFee.mul(3).div(4);  // 75 percent\n', '\t\t}\n', '\t\treturn buildFee; // 100 percent\n', '    }\n', '\n', '    function buildLeft(address inviteAddress, uint blockNumber) public payable onlyInGame {\n', '    \tuint totalMoney = buildFee.mul(blockNumber);\n', '    \trequire(msg.value >= totalMoney);\n', '        require(blockNumber > 0);\n', '        uint excess = msg.value.sub(totalMoney);\n', '        uint totalBuildFee = 0;\n', '        for (uint i=leftBlockNumber;i<leftBlockNumber+blockNumber;i++) {\n', '    \t\ttotalBuildFee = totalBuildFee.add(getBlockBuildFee(i+1));\n', '        }\n', '        excess = excess.add(totalMoney.sub(totalBuildFee));\n', '        if (excess > 0) {\n', '        \tmsg.sender.transfer(excess);\n', '        }\n', '        // handle ether\n', '        uint devFee = 0;\n', '        uint inviteFee = 0;\n', '        devFee = totalBuildFee.mul(4).div(100);\n', '        if (inviteAddress != address(0)) {\n', '    \t\tinviteFee = totalBuildFee.mul(3).div(100);\n', '        } else {\n', '    \t\tdevFee = totalBuildFee.mul(7).div(100);  // 7% percent if not invite\n', '        }\n', '        owner.transfer(devFee);\n', '        if (inviteFee > 0) {\n', '    \t\tinviteAddress.transfer(inviteFee);\n', '        }\n', '        leftBlockNumber = leftBlockNumber.add(blockNumber);\n', '        gamePrizePool = gamePrizePool.add(totalBuildFee.sub(devFee).sub(inviteFee));\n', '\n', '        // record user block number\n', '        leftUserBlockNumber[currentRound][msg.sender] += blockNumber;\n', '       \t// try trigger game end\n', '       \ttrigger_game_end(totalBuildFee);\n', '    }\n', '\n', '    function buildRight(address inviteAddress, uint blockNumber) public payable onlyInGame {\n', '\t\tuint totalMoney = buildFee.mul(blockNumber);\n', '\t\trequire(msg.value >= totalMoney);\n', '        require(blockNumber > 0);\n', '        uint excess = msg.value.sub(totalMoney);\n', '        uint totalBuildFee = 0;\n', '        for (uint i=rightBlockNumber;i<rightBlockNumber+blockNumber;i++) {\n', '    \t\ttotalBuildFee = totalBuildFee.add(getBlockBuildFee(i+1));\n', '        }\n', '        excess = excess.add(totalMoney.sub(totalBuildFee));\n', '        if (excess > 0) {\n', '        \tmsg.sender.transfer(excess);\n', '        }\n', '        // handle ether\n', '        uint devFee = 0;\n', '        uint inviteFee = 0;\n', '        devFee = totalBuildFee.mul(4).div(100);\n', '        if (inviteAddress != address(0)) {\n', '    \t\tinviteFee = totalBuildFee.mul(3).div(100);\n', '        } else {\n', '    \t\tdevFee = totalBuildFee.mul(7).div(100);  // 7% percent if not invite\n', '        }\n', '        owner.transfer(devFee);\n', '        if (inviteFee > 0) {\n', '    \t\tinviteAddress.transfer(inviteFee);\n', '        }\n', '        rightBlockNumber = rightBlockNumber.add(blockNumber);\n', '        gamePrizePool = gamePrizePool.add(totalBuildFee.sub(devFee).sub(inviteFee));\n', '\n', '        // record user block number\n', '        rightUserBlockNumber[currentRound][msg.sender] += blockNumber;\n', '       \t// try trigger game end\n', '       \ttrigger_game_end(totalBuildFee);\n', '    }\n', '\n', '    function trigger_game_end(uint totalBuildFee) private onlyInGame {\n', '\t\t// game end\n', '\t\tbool gameEnd = false;\n', '\t\tif (rightBlockNumber > maxBlockNumber) {\n', '\t\t\t\tgameEnd = true;\n', '\t\t}\n', '\t\tif (leftBlockNumber > maxBlockNumber) {\n', '\t\t\t\tgameEnd = true;\n', '\t\t}\n', '\t\tif (now.sub(gameStartTimestamp) > gameLength) {\n', '\t\t\t\tgameEnd = true;\n', '\t\t}\n', '\t\tif (gameEnd) {\n', '\t\t\tuint maxUserPrize = gamePrizePool.mul(3).div(100);\n', '\t\t\tuint nextGamePrizePool = gamePrizePool.div(10);\n', '\t\t\tif (gamePrizePool > 0) {\n', '\t\t\t\t\tmsg.sender.transfer(maxUserPrize);\n', '\t\t\t}\n', '\t\t\tgamePrizePool = gamePrizePool.sub(maxUserPrize).sub(nextGamePrizePool);\n', '\t\t\tuint prizePerBlock = 0;\n', '\t\t\tif (leftBlockNumber > maxBlockNumber) {\n', '\t\t\t\t// right win\n', '\t\t\t\tif (rightBlockNumber > 0) {\n', '\t\t\t\t    prizePerBlock = gamePrizePool/rightBlockNumber;\n', '\t\t\t\t} else {\n', '\t\t\t\t    owner.transfer(gamePrizePool);\n', '\t\t\t\t    prizePerBlock = 0;\n', '\t\t\t\t}\n', '\t\t\t\tmapGameLeftWin[currentRound] = false;\n', '\t\t\t} else if (rightBlockNumber > maxBlockNumber) {\n', '\t\t\t\t// left win\n', '\t\t\t\tif (leftBlockNumber > 0) {\n', '\t\t\t\t    prizePerBlock = gamePrizePool/leftBlockNumber;\n', '\t\t\t\t} else {\n', '\t\t\t\t    owner.transfer(gamePrizePool);\n', '\t\t\t\t    prizePerBlock = 0;\n', '\t\t\t\t}\n', '\t\t\t\tmapGameLeftWin[currentRound] = true;\n', '\t\t\t} else {\n', '\t\t\t\tif (leftBlockNumber >= rightBlockNumber) {\n', '\t\t\t\t\t// left win\n', '\t\t\t\t\tprizePerBlock = gamePrizePool/leftBlockNumber;\n', '\t\t\t\t\tmapGameLeftWin[currentRound] = true;\n', '\t\t\t\t} else {\n', '\t\t\t\t\t// right win\n', '\t\t\t\t\tprizePerBlock = gamePrizePool/rightBlockNumber;\n', '\t\t\t\t\tmapGameLeftWin[currentRound] = false;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t// record game prize\n', '\t\t\tmapGamePrizePerBlock[currentRound] = prizePerBlock;\n', '\t\t\t// start next game\n', '\t\t\tgamePrizePool = nextGamePrizePool;\n', '\t\t\tgameStartTimestamp = now + gameIntervalTimestamp;  // new game start\n', '\t\t\tcurrentRound += 1;\n', '\t\t\tleftBlockNumber = 0;\n', '\t\t\trightBlockNumber = 0;\n', '\t\t}\n', '    }\n', '\n', '    function getUserMoney(address userAddress) public view returns(uint){\n', '\t\tuint userTotalPrize = 0;\n', '\t\tfor (uint i=userWithdrawRound[userAddress]; i<currentRound;i++) {\n', '\t\t\tif (mapGameLeftWin[i]) {\n', '\t\t\t\tuserTotalPrize = userTotalPrize.add(leftUserBlockNumber[i][userAddress].mul(mapGamePrizePerBlock[i]));\n', '\t\t\t} else {\n', '\t\t\t\tuserTotalPrize = userTotalPrize.add(rightUserBlockNumber[i][userAddress].mul(mapGamePrizePerBlock[i]));\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn userTotalPrize;\n', '    }\n', '\n', '    function withdrawUserPrize() public {\n', '\t\trequire(currentRound > 0);\n', '\t\tuint userTotalPrize = getUserMoney(msg.sender);\n', '\t\tuserWithdrawRound[msg.sender] = currentRound;\n', '\t\tif (userTotalPrize > 0) {\n', '\t\t\tmsg.sender.transfer(userTotalPrize);\n', '\t\t}\n', '    }\n', '\n', '    function daCall() public {\n', '        doCallNumber += 1;\n', '    }\n', '\n', '    function getGameStats() public view returns(uint[]) {\n', '        // 1. currentRound\n', '        // 2. gameStartTimestamp\n', '        // 3. leftBlockNumber\n', '        // 4. rightBlockNumber\n', '        // 5. gamePrizePool\n', '        // 6. userPrize\n', '        uint[] memory result = new uint[](8);\n', '        uint userPrize = getUserMoney(msg.sender);\n', '        result[0] = currentRound;\n', '        result[1] = gameStartTimestamp;\n', '        result[2] = leftBlockNumber;\n', '        result[3] = rightBlockNumber;\n', '        result[4] = gamePrizePool;\n', '        result[5] = userPrize;\n', '        result[6] = leftUserBlockNumber[currentRound][msg.sender];\n', '        result[7] = rightUserBlockNumber[currentRound][msg.sender];\n', '        return result;\n', '    }\n', '}']