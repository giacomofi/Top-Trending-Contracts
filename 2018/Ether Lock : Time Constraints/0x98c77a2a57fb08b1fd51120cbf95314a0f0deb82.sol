['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Base { \n', '    using SafeMath for uint256; \n', '    uint public createTime = now;\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '        owner = _newOwner;\n', '    }    \n', '            \n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {         \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }    \n', '\n', '    function setLock()  public onlyOwner{      \n', '        globalLocked = false;     \n', '    }\n', '\n', '    mapping (address => uint256) public userEtherOf;    \n', '    \n', '    function userRefund() public  returns(bool _result) {             \n', '        return _userRefund(msg.sender);\n', '    }\n', '\n', '    function _userRefund(address _to) internal returns(bool _result){  \n', '        require (_to != 0x0);  \n', '        lock();\n', '        uint256 amount = userEtherOf[msg.sender];   \n', '        if(amount > 0){\n', '            userEtherOf[msg.sender] = 0;\n', '            _to.transfer(amount); \n', '            _result = true;\n', '        }\n', '        else{\n', '            _result = false;\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    uint public currentEventId = 1;                         \n', '\n', '    function getEventId() internal returns(uint _result) {    \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '   \n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC20 is Base {                                             \n', '    string public name = &#39;Don Quixote Token&#39;;                           \n', '    string public symbol = &#39;DON&#39;;\n', '    uint8 public decimals = 9;\n', '    uint256 public totalSupply = (10 ** 9) * (10 ** uint256(decimals));    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', ' \n', '    function webGiftUnTransfer(address _from, address _to) public view returns(bool _result);   \n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to].add(_value) >= balanceOf[_to]);\n', '\n', '        require(_from != _to);\n', '        require(!webGiftUnTransfer(_from, _to));                                         \n', '\n', '        uint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from].add( balanceOf[_to]) == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(_value <= allowance[_from][msg.sender]);    \n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {  \n', '        require(_spender != 0x0);\n', '        require(_value > 0);\n', '        //require(_value <= balanceOf[msg.sender]);         \n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        require(_spender != 0x0);\n', '        require(_value > 0);\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {           \n', '        require(_value > 0);\n', '        require(balanceOf[msg.sender] >= _value);  \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); \n', '        totalSupply = totalSupply.sub(_value);   \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0);\n', '        require(_value > 0);\n', '        assert(1 >= 2);\n', '        symbol = &#39;DON&#39;;\n', '        return false;\n', '    }\n', '}\n', '\n', 'contract DonQuixoteToken is TokenERC20{          \n', '    address public iniOwner;                      \n', '\n', '    function DonQuixoteToken(address _santaClaus)  public {\n', '        require(_santaClaus != 0x0 && _santaClaus != msg.sender);\n', '        owner = msg.sender;\n', '        iniOwner = msg.sender;\n', '        balanceOf[msg.sender] = totalSupply; \n', '        santaClaus = _santaClaus;\n', '    }\n', '\n', '    uint public lastAddYear = now;\n', '\n', '    event OnAddYearToken(uint256 _lastTotalSupply, uint256 _currentTotalSupply, uint _years, uint _eventTime, uint _eventId);\n', '\n', '    function addYearToken() public returns(bool _result) {   \n', '        _result = false;\n', '        if(now - lastAddYear > 1 years){\n', '            uint256 _lastTotalSupply = totalSupply;\n', '            uint y = (now - lastAddYear).div(1 years);  \n', '            if(y > 0){\n', '                for(uint i = 1; i <= y; i++){\n', '                    totalSupply = totalSupply.mul(102).div(100);       \n', '                }\n', '                uint256 _add = totalSupply.sub(_lastTotalSupply);\n', '                balanceOf[iniOwner] = balanceOf[iniOwner].add(_add);\n', '                lastAddYear = lastAddYear.add(y.mul(1 years));\n', '                emit OnAddYearToken(_lastTotalSupply, totalSupply, y, now, getEventId());\n', '                _result = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    address public santaClaus;                         \n', '\n', '    function setSantaClaus(address _newSantaClaus)  public  onlyOwner {  \n', '        require(_newSantaClaus != 0x0);\n', '        santaClaus = _newSantaClaus;\n', '    }\n', '\n', '    modifier onlySantaClaus {\n', '        require(msg.sender == santaClaus);\n', '        _;\n', '    }\n', '\n', '    uint    public webGiftLineTime = now + 60 days;\n', '    uint256 public webGiftTotalAmount = totalSupply * 5 / 100;  \n', '    uint256 public webGiftSentAmount  = 0;                       \n', '    uint256 public webGiftOnceMaxAmount = 600 * (10 ** uint256(decimals));  \n', '    uint256 public webGiftEtherAmount = 0.005 ether;                      \n', '    bool    public stopSendWebGift  = false;\n', '\n', '    function setWebGiftEtherAmount(uint256 _value) public onlyOwner{\n', '        require(_value <= 0.1 ether);\n', '        webGiftEtherAmount = _value;\n', '    }\n', '\n', '    function setStopSendWebGift(bool _value) public onlyOwner{\n', '        stopSendWebGift = _value;\n', '    }\n', '\n', '    function canSendWebGift() public view returns (bool _result){\n', '        _result = (now < webGiftLineTime) && (!stopSendWebGift) && (webGiftSentAmount <= webGiftTotalAmount) && (balanceOf[iniOwner] >= webGiftOnceMaxAmount);\n', '    }\n', '\n', '    function canSendWebGifAmount() public view returns(uint256 _result) {     \n', '        _result = 0;\n', '        if(canSendWebGift()){\n', '            _result = webGiftTotalAmount.sub(webGiftSentAmount);  \n', '        }\n', '    }\n', '\n', '    function setWebGiftOnceMaxAmount(uint256 _value) public onlyOwner{\n', '        require(_value < 1000 * (10 ** uint256(decimals)) && _value > 0);   \n', '        webGiftOnceMaxAmount = _value;\n', '    }    \n', '\n', '    event OnSendWebGiftToken(address _user, uint256 _gifTokenAmount, bool _result, uint _eventTime, uint _eventId);\n', '\n', '    function sendWebGiftToken(address _user, uint256 _gifAmount) public onlySantaClaus returns(bool _result)  {\n', '        lock();   \n', '        _result = _sendWebGiftToken( _user,  _gifAmount);\n', '        unLock();\n', '    }\n', '\n', '    function _sendWebGiftToken(address _user, uint256 _gifAmount) private returns(bool _result)  { \n', '        _result = false;\n', '        require(_user != 0x0);\n', '        require(_gifAmount > 0);\n', '        require(_user != iniOwner);                              \n', '        require(_gifAmount <= webGiftOnceMaxAmount);\n', '        require(canSendWebGifAmount() >= _gifAmount);    \n', '        _transfer(iniOwner, _user, _gifAmount);\n', '        webGiftSentAmount = webGiftSentAmount.add(_gifAmount);\n', '        \n', '        _logSendWebGiftAndSendEther(_user, _gifAmount);\n', '\n', '        _result = true;\n', '        emit OnSendWebGiftToken(_user, _gifAmount, _result, now,  getEventId());\n', '    }\n', '\n', '    function batchSendWebGiftToken(address[] _users, uint256 _gifAmount) public  onlySantaClaus returns(uint _result)  {\n', '        lock();   \n', '        _result = 0;\n', '        for (uint index = 0; index < _users.length; index++) {\n', '            address _user =  _users[index];\n', '            if(_sendWebGiftToken(_user, _gifAmount)){\n', '                _result = _result.add(1);\n', '            } \n', '        }\n', '        unLock();\n', '    }\n', '\n', '    mapping (address=>mapping(address=>bool)) public gameTransferFlagOf;   \n', '\n', '    function setGameTransferFlag(address _gameAddress, bool _gameCanTransfer) public { \n', '        require(_gameAddress != 0x0);\n', '        gameTransferFlagOf[msg.sender][_gameAddress] = !_gameCanTransfer;\n', '    }\n', '\n', '    mapping(address => bool) public gameWhiteListOf;                           \n', '\n', '    event OnWhiteListChange(address indexed _gameAddr, address _operator, bool _result,  uint _eventTime, uint _eventId);\n', '\n', '    function addWhiteList(address _gameAddr) public onlyOwner {\n', '        require (_gameAddr != 0x0);  \n', '        gameWhiteListOf[_gameAddr] = true;\n', '        emit OnWhiteListChange(_gameAddr, msg.sender, true, now, getEventId());\n', '    }  \n', '\n', '    function delWhiteList(address _gameAddr) public onlyOwner {\n', '        require (_gameAddr != 0x0);  \n', '        gameWhiteListOf[_gameAddr] = false;   \n', '        emit OnWhiteListChange(_gameAddr, msg.sender, false, now, getEventId()); \n', '    }\n', '    \n', '    function isWhiteList(address _gameAddr) private view returns(bool _result) {\n', '        require (_gameAddr != 0x0);  \n', '        _result = gameWhiteListOf[_gameAddr];\n', '    }\n', '\n', '    function withhold(address _user,  uint256 _amount) public returns (bool _result) {    \n', '        require(_user != 0x0);\n', '        require(_amount > 0);\n', '        require(msg.sender != tx.origin);\n', '        require(!gameTransferFlagOf[_user][msg.sender]);\n', '        require(isWhiteList(msg.sender));\n', '        require(balanceOf[_user] >= _amount);\n', '        \n', '        //lock();     \n', '        _transfer(_user, msg.sender, _amount);\n', '        //unLock();\n', '        return true;\n', '    }\n', '\n', '\n', '    uint    public gameGiftLineTime = now + 90 days;  \n', '    uint256 public gameGiftMaxAmount  = totalSupply * 5 / 100; \n', '    uint256 public gameGiftSentAmount  = 0;                      \n', '    uint256 public gameGiftOnceAmount  = 60 * (10 ** uint256(decimals));   \n', '    uint    public gameGiftUserTotalTimes = 100;            \n', '    uint    public gameGiftUserDayTimes = 20;                         \n', '    \n', '    struct gameGiftInfo     \n', '    {\n', '        uint ThisDay;       \n', '        uint DayTimes;     \n', '        uint TotalTimes;  \n', '    }\n', '\n', '    mapping(address => gameGiftInfo) public gameGiftInfoList;   \n', '\n', '    function _logGameGiftInfo(address _player) private {\n', '        gameGiftInfo storage ggi = gameGiftInfoList[_player];\n', '        uint thisDay = now / (1 days);\n', '        if (ggi.ThisDay == thisDay){\n', '            ggi.DayTimes = ggi.DayTimes.add(1);\n', '        }\n', '        else\n', '        {\n', '            ggi.ThisDay = thisDay;\n', '            ggi.DayTimes = 1;\n', '        }\n', '        ggi.TotalTimes = ggi.TotalTimes.add(1);\n', '    }\n', '\n', '    function timesIsOver(address _player) public view returns(bool _result){ \n', '        gameGiftInfo storage ggi = gameGiftInfoList[_player];\n', '        uint thisDay = now / (1 days);\n', '        if (ggi.ThisDay == thisDay){\n', '            _result = (ggi.DayTimes >= gameGiftUserDayTimes) || (ggi.TotalTimes >= gameGiftUserTotalTimes);\n', '        }\n', '        else{\n', '            _result = ggi.TotalTimes >= gameGiftUserTotalTimes;\n', '        }\n', '    }\n', '\n', '    function setGameGiftOnceAmount(uint256 _value) public onlyOwner{\n', '        require(_value > 0 && _value < 100 * (10 ** uint256(decimals)));\n', '        gameGiftOnceAmount = _value;\n', '    }\n', '\n', '    function gameGifIsOver() view public returns(bool _result){\n', '        _result = (gameGiftLineTime <= now) || (balanceOf[iniOwner] < gameGiftOnceAmount) || (gameGiftMaxAmount < gameGiftSentAmount.add(gameGiftOnceAmount));    \n', '    }  \n', '\n', '    event OnSendGameGift(address _game, address _player, uint256 _gameGiftOnceAmount, uint _eventTime, uint _eventId);\n', '    \n', '    function _canSendGameGift() view private returns(bool _result){\n', '        _result = (isWhiteList(msg.sender)) && (!gameGifIsOver());\n', '    }\n', '\n', '    function sendGameGift(address _player) public returns (bool _result) {\n', '        uint256 _tokenAmount = gameGiftOnceAmount;\n', '        _result = _sendGameGift(_player, _tokenAmount);\n', '    }\n', '\n', '    function sendGameGift2(address _player, uint256 _tokenAmount) public returns (bool _result) {\n', '        require(gameGiftOnceAmount >= _tokenAmount);\n', '        _result = _sendGameGift(_player, _tokenAmount);\n', '    }\n', '\n', '    function _sendGameGift(address _player, uint256 _tokenAmount) private returns (bool _result) {\n', '        require(_player != 0x0);\n', '        require(_tokenAmount > 0 && _tokenAmount <= gameGiftOnceAmount);\n', '        \n', '        if(_player == iniOwner){ \n', '            return;\n', '        }                                 \n', '\n', '        require(msg.sender != tx.origin);\n', '        if(!_canSendGameGift()){   \n', '            return;\n', '        }\n', '        if(timesIsOver(_player)){ \n', '            return;\n', '        }\n', '\n', '        lock();         \n', '        _transfer(iniOwner, _player, _tokenAmount);\n', '        gameGiftSentAmount = gameGiftSentAmount.add(_tokenAmount);\n', '        emit OnSendGameGift(msg.sender,  _player,   _tokenAmount, now, getEventId());\n', '        _logGameGiftInfo(_player);    \n', '        unLock();\n', '        _result = true;\n', '    }\n', '\n', '\n', '    uint256  public baseIcoPrice =  (0.0002 ether) / (10 ** uint256(decimals)); \n', '  \n', '    function getIcoPrice() view public returns(uint256 _result){\n', '        _result = baseIcoPrice;\n', '        uint256 addDays = (now - createTime) / (1 days); \n', '        for(uint i = 1; i <= addDays; i++){\n', '            _result = _result.mul(101).div(100);\n', '        }\n', '    } \n', ' \n', '    uint256 public icoMaxAmount = totalSupply * 40 / 100;   \n', '    uint256 public icoedAmount = 0;                        \n', '    uint    public icoEndLine = now + 180 days;          \n', '\n', '    function icoIsOver() view public returns(bool _result){\n', '        _result = (icoEndLine < now)  || (icoedAmount >= icoMaxAmount) || (balanceOf[iniOwner] < (icoMaxAmount - icoedAmount)); \n', '    }  \n', '\n', '    function getAvaIcoAmount() view public returns(uint256 _result){  \n', '        _result = 0;\n', '        if (!icoIsOver()){\n', '            if (icoMaxAmount > icoedAmount){               \n', '                _result = icoMaxAmount.sub(icoedAmount);  \n', '            }\n', '        }\n', '    }  \n', '\n', '    event OnBuyIcoToken(uint256 _tokenPrice, uint256 _tokenAmount, uint256 _etherAmount, address _buyer, uint _eventTime, uint _eventId);\n', '\n', '    function buyIcoToken1()  public payable returns (bool _result) {  \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '        _result = _buyIcoToken(totalSupply);    \n', '    }\n', '\n', '    function buyIcoToken2(uint256 _tokenAmount)  public payable returns (bool _result) {  \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '        _result = _buyIcoToken(_tokenAmount); \n', '    }\n', '\n', '    function _buyIcoToken(uint256 _tokenAmount)  private returns (bool _result) {  \n', '        _result = false;    \n', '        require(_tokenAmount > 0);   \n', '        require(!icoIsOver());   \n', '        require(msg.sender != iniOwner);                                      \n', '        require(balanceOf[iniOwner] > 0);\n', '\n', '        uint256 buyIcoPrice =  getIcoPrice();\n', '        uint256 canTokenAmount = userEtherOf[msg.sender].div(buyIcoPrice);    \n', '        require(userEtherOf[msg.sender] > 0 && canTokenAmount > 0);\n', '        if(_tokenAmount < canTokenAmount){\n', '            canTokenAmount = _tokenAmount;\n', '        }\n', '\n', '        lock();\n', '\n', '        uint256 avaIcoAmount = getAvaIcoAmount();\n', '        if(canTokenAmount > avaIcoAmount){\n', '             canTokenAmount = avaIcoAmount;\n', '        }\n', '        require(canTokenAmount > 0);\n', '        uint256 etherAmount = canTokenAmount.mul(buyIcoPrice);\n', '        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(etherAmount);   \n', '        userEtherOf[iniOwner] = userEtherOf[iniOwner].add(etherAmount);        \n', '        _transfer(iniOwner, msg.sender, canTokenAmount);                      \n', '        emit OnBuyIcoToken(buyIcoPrice, canTokenAmount, etherAmount, msg.sender, now, getEventId());\n', '        icoedAmount = icoedAmount.add(canTokenAmount);\n', '        _result = true;\n', '\n', '        unLock();\n', '    }\n', '\n', '    struct webGiftInfo   \n', '    {\n', '        uint256 Amount; \n', '        uint PlayingTime; \n', '    }\n', '\n', '    mapping(address  => webGiftInfo) public webGiftList;\n', '\n', '    function _logSendWebGiftAndSendEther(address _to, uint256 _amount) private {\n', '        require(_to != 0x0);\n', '        webGiftInfo storage wgi = webGiftList[_to];\n', '\n', '        if(wgi.Amount == 0){\n', '            if (userEtherOf[iniOwner] >= webGiftEtherAmount){          \n', '                userEtherOf[iniOwner] = userEtherOf[iniOwner].sub(webGiftEtherAmount);\n', '                _to.transfer(webGiftEtherAmount);\n', '            }\n', '        }\n', '\n', '        if(wgi.PlayingTime == 0){\n', '            wgi.Amount = wgi.Amount.add(_amount);\n', '        }\n', '    }\n', '\n', '    event OnLogPlaying(address _player, uint _eventTime, uint _eventId);\n', '\n', '    function logPlaying(address _player) public returns (bool _result) {\n', '        _result = false;\n', '        require(_player != 0x0);\n', '        require(msg.sender != tx.origin);\n', '        require(isWhiteList(msg.sender)); \n', '\n', '        if (gameGiftLineTime < now) {\n', '            return;\n', '        }\n', '        \n', '        webGiftInfo storage wgi = webGiftList[_player];\n', '        if(wgi.PlayingTime == 0){                                   \n', '            wgi.PlayingTime = now;\n', '            emit OnLogPlaying(_player, now, getEventId());\n', '        }\n', '        _result = true;\n', '    }\n', '\n', '    function webGiftUnTransfer(address _from, address _to) public view returns(bool _result){\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        if(isWhiteList(_to) || _to == iniOwner){    \n', '            _result = false;\n', '            return;\n', '        }\n', '        webGiftInfo storage wgi = webGiftList[_from];\n', '        _result = (wgi.Amount > 0) && (wgi.PlayingTime == 0) && (now <= gameGiftLineTime);   \n', '    }\n', '\n', '    event OnRestoreWebGift(address _user, uint256 _tokenAmount, uint _eventTime, uint _eventId);\n', '\n', '    function restoreWebGift(address _user) public  returns (bool _result) { \n', '        _result = false;\n', '        require(_user != 0x0);\n', '        webGiftInfo storage wgi = webGiftList[_user];\n', '        if ((0 == wgi.PlayingTime) && (0 < wgi.Amount)){  \n', '            if (gameGiftLineTime.sub(20 days) < now  && now <= gameGiftLineTime) {   \n', '                uint256 amount = wgi.Amount;\n', '                if (amount > balanceOf[_user]){\n', '                    amount = balanceOf[_user];\n', '                }\n', '                _transfer(_user, iniOwner, amount);\n', '                emit OnRestoreWebGift(_user, amount, now, getEventId());\n', '                _result = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    function batchRestoreWebGift(address[] _users) public  returns (uint _result) {       \n', '        _result = 0;\n', '        for(uint i = 0; i < _users.length; i ++){\n', '            if(restoreWebGift(_users[i])){\n', '                _result = _result.add(1);\n', '            }\n', '        }\n', '    \n', '    }\n', '\n', '    \n', '    function () public payable {                      \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '\n', '        if(msg.sender != iniOwner){\n', '            if ((userEtherOf[msg.sender] > 0) && (!icoIsOver())){\n', '                _buyIcoToken(totalSupply);             \n', '            }\n', '        }\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Base { \n', '    using SafeMath for uint256; \n', '    uint public createTime = now;\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '        owner = _newOwner;\n', '    }    \n', '            \n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {         \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }    \n', '\n', '    function setLock()  public onlyOwner{      \n', '        globalLocked = false;     \n', '    }\n', '\n', '    mapping (address => uint256) public userEtherOf;    \n', '    \n', '    function userRefund() public  returns(bool _result) {             \n', '        return _userRefund(msg.sender);\n', '    }\n', '\n', '    function _userRefund(address _to) internal returns(bool _result){  \n', '        require (_to != 0x0);  \n', '        lock();\n', '        uint256 amount = userEtherOf[msg.sender];   \n', '        if(amount > 0){\n', '            userEtherOf[msg.sender] = 0;\n', '            _to.transfer(amount); \n', '            _result = true;\n', '        }\n', '        else{\n', '            _result = false;\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    uint public currentEventId = 1;                         \n', '\n', '    function getEventId() internal returns(uint _result) {    \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '   \n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC20 is Base {                                             \n', "    string public name = 'Don Quixote Token';                           \n", "    string public symbol = 'DON';\n", '    uint8 public decimals = 9;\n', '    uint256 public totalSupply = (10 ** 9) * (10 ** uint256(decimals));    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', ' \n', '    function webGiftUnTransfer(address _from, address _to) public view returns(bool _result);   \n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to].add(_value) >= balanceOf[_to]);\n', '\n', '        require(_from != _to);\n', '        require(!webGiftUnTransfer(_from, _to));                                         \n', '\n', '        uint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from].add( balanceOf[_to]) == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(_value <= allowance[_from][msg.sender]);    \n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {  \n', '        require(_spender != 0x0);\n', '        require(_value > 0);\n', '        //require(_value <= balanceOf[msg.sender]);         \n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        require(_spender != 0x0);\n', '        require(_value > 0);\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {           \n', '        require(_value > 0);\n', '        require(balanceOf[msg.sender] >= _value);  \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); \n', '        totalSupply = totalSupply.sub(_value);   \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0);\n', '        require(_value > 0);\n', '        assert(1 >= 2);\n', "        symbol = 'DON';\n", '        return false;\n', '    }\n', '}\n', '\n', 'contract DonQuixoteToken is TokenERC20{          \n', '    address public iniOwner;                      \n', '\n', '    function DonQuixoteToken(address _santaClaus)  public {\n', '        require(_santaClaus != 0x0 && _santaClaus != msg.sender);\n', '        owner = msg.sender;\n', '        iniOwner = msg.sender;\n', '        balanceOf[msg.sender] = totalSupply; \n', '        santaClaus = _santaClaus;\n', '    }\n', '\n', '    uint public lastAddYear = now;\n', '\n', '    event OnAddYearToken(uint256 _lastTotalSupply, uint256 _currentTotalSupply, uint _years, uint _eventTime, uint _eventId);\n', '\n', '    function addYearToken() public returns(bool _result) {   \n', '        _result = false;\n', '        if(now - lastAddYear > 1 years){\n', '            uint256 _lastTotalSupply = totalSupply;\n', '            uint y = (now - lastAddYear).div(1 years);  \n', '            if(y > 0){\n', '                for(uint i = 1; i <= y; i++){\n', '                    totalSupply = totalSupply.mul(102).div(100);       \n', '                }\n', '                uint256 _add = totalSupply.sub(_lastTotalSupply);\n', '                balanceOf[iniOwner] = balanceOf[iniOwner].add(_add);\n', '                lastAddYear = lastAddYear.add(y.mul(1 years));\n', '                emit OnAddYearToken(_lastTotalSupply, totalSupply, y, now, getEventId());\n', '                _result = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    address public santaClaus;                         \n', '\n', '    function setSantaClaus(address _newSantaClaus)  public  onlyOwner {  \n', '        require(_newSantaClaus != 0x0);\n', '        santaClaus = _newSantaClaus;\n', '    }\n', '\n', '    modifier onlySantaClaus {\n', '        require(msg.sender == santaClaus);\n', '        _;\n', '    }\n', '\n', '    uint    public webGiftLineTime = now + 60 days;\n', '    uint256 public webGiftTotalAmount = totalSupply * 5 / 100;  \n', '    uint256 public webGiftSentAmount  = 0;                       \n', '    uint256 public webGiftOnceMaxAmount = 600 * (10 ** uint256(decimals));  \n', '    uint256 public webGiftEtherAmount = 0.005 ether;                      \n', '    bool    public stopSendWebGift  = false;\n', '\n', '    function setWebGiftEtherAmount(uint256 _value) public onlyOwner{\n', '        require(_value <= 0.1 ether);\n', '        webGiftEtherAmount = _value;\n', '    }\n', '\n', '    function setStopSendWebGift(bool _value) public onlyOwner{\n', '        stopSendWebGift = _value;\n', '    }\n', '\n', '    function canSendWebGift() public view returns (bool _result){\n', '        _result = (now < webGiftLineTime) && (!stopSendWebGift) && (webGiftSentAmount <= webGiftTotalAmount) && (balanceOf[iniOwner] >= webGiftOnceMaxAmount);\n', '    }\n', '\n', '    function canSendWebGifAmount() public view returns(uint256 _result) {     \n', '        _result = 0;\n', '        if(canSendWebGift()){\n', '            _result = webGiftTotalAmount.sub(webGiftSentAmount);  \n', '        }\n', '    }\n', '\n', '    function setWebGiftOnceMaxAmount(uint256 _value) public onlyOwner{\n', '        require(_value < 1000 * (10 ** uint256(decimals)) && _value > 0);   \n', '        webGiftOnceMaxAmount = _value;\n', '    }    \n', '\n', '    event OnSendWebGiftToken(address _user, uint256 _gifTokenAmount, bool _result, uint _eventTime, uint _eventId);\n', '\n', '    function sendWebGiftToken(address _user, uint256 _gifAmount) public onlySantaClaus returns(bool _result)  {\n', '        lock();   \n', '        _result = _sendWebGiftToken( _user,  _gifAmount);\n', '        unLock();\n', '    }\n', '\n', '    function _sendWebGiftToken(address _user, uint256 _gifAmount) private returns(bool _result)  { \n', '        _result = false;\n', '        require(_user != 0x0);\n', '        require(_gifAmount > 0);\n', '        require(_user != iniOwner);                              \n', '        require(_gifAmount <= webGiftOnceMaxAmount);\n', '        require(canSendWebGifAmount() >= _gifAmount);    \n', '        _transfer(iniOwner, _user, _gifAmount);\n', '        webGiftSentAmount = webGiftSentAmount.add(_gifAmount);\n', '        \n', '        _logSendWebGiftAndSendEther(_user, _gifAmount);\n', '\n', '        _result = true;\n', '        emit OnSendWebGiftToken(_user, _gifAmount, _result, now,  getEventId());\n', '    }\n', '\n', '    function batchSendWebGiftToken(address[] _users, uint256 _gifAmount) public  onlySantaClaus returns(uint _result)  {\n', '        lock();   \n', '        _result = 0;\n', '        for (uint index = 0; index < _users.length; index++) {\n', '            address _user =  _users[index];\n', '            if(_sendWebGiftToken(_user, _gifAmount)){\n', '                _result = _result.add(1);\n', '            } \n', '        }\n', '        unLock();\n', '    }\n', '\n', '    mapping (address=>mapping(address=>bool)) public gameTransferFlagOf;   \n', '\n', '    function setGameTransferFlag(address _gameAddress, bool _gameCanTransfer) public { \n', '        require(_gameAddress != 0x0);\n', '        gameTransferFlagOf[msg.sender][_gameAddress] = !_gameCanTransfer;\n', '    }\n', '\n', '    mapping(address => bool) public gameWhiteListOf;                           \n', '\n', '    event OnWhiteListChange(address indexed _gameAddr, address _operator, bool _result,  uint _eventTime, uint _eventId);\n', '\n', '    function addWhiteList(address _gameAddr) public onlyOwner {\n', '        require (_gameAddr != 0x0);  \n', '        gameWhiteListOf[_gameAddr] = true;\n', '        emit OnWhiteListChange(_gameAddr, msg.sender, true, now, getEventId());\n', '    }  \n', '\n', '    function delWhiteList(address _gameAddr) public onlyOwner {\n', '        require (_gameAddr != 0x0);  \n', '        gameWhiteListOf[_gameAddr] = false;   \n', '        emit OnWhiteListChange(_gameAddr, msg.sender, false, now, getEventId()); \n', '    }\n', '    \n', '    function isWhiteList(address _gameAddr) private view returns(bool _result) {\n', '        require (_gameAddr != 0x0);  \n', '        _result = gameWhiteListOf[_gameAddr];\n', '    }\n', '\n', '    function withhold(address _user,  uint256 _amount) public returns (bool _result) {    \n', '        require(_user != 0x0);\n', '        require(_amount > 0);\n', '        require(msg.sender != tx.origin);\n', '        require(!gameTransferFlagOf[_user][msg.sender]);\n', '        require(isWhiteList(msg.sender));\n', '        require(balanceOf[_user] >= _amount);\n', '        \n', '        //lock();     \n', '        _transfer(_user, msg.sender, _amount);\n', '        //unLock();\n', '        return true;\n', '    }\n', '\n', '\n', '    uint    public gameGiftLineTime = now + 90 days;  \n', '    uint256 public gameGiftMaxAmount  = totalSupply * 5 / 100; \n', '    uint256 public gameGiftSentAmount  = 0;                      \n', '    uint256 public gameGiftOnceAmount  = 60 * (10 ** uint256(decimals));   \n', '    uint    public gameGiftUserTotalTimes = 100;            \n', '    uint    public gameGiftUserDayTimes = 20;                         \n', '    \n', '    struct gameGiftInfo     \n', '    {\n', '        uint ThisDay;       \n', '        uint DayTimes;     \n', '        uint TotalTimes;  \n', '    }\n', '\n', '    mapping(address => gameGiftInfo) public gameGiftInfoList;   \n', '\n', '    function _logGameGiftInfo(address _player) private {\n', '        gameGiftInfo storage ggi = gameGiftInfoList[_player];\n', '        uint thisDay = now / (1 days);\n', '        if (ggi.ThisDay == thisDay){\n', '            ggi.DayTimes = ggi.DayTimes.add(1);\n', '        }\n', '        else\n', '        {\n', '            ggi.ThisDay = thisDay;\n', '            ggi.DayTimes = 1;\n', '        }\n', '        ggi.TotalTimes = ggi.TotalTimes.add(1);\n', '    }\n', '\n', '    function timesIsOver(address _player) public view returns(bool _result){ \n', '        gameGiftInfo storage ggi = gameGiftInfoList[_player];\n', '        uint thisDay = now / (1 days);\n', '        if (ggi.ThisDay == thisDay){\n', '            _result = (ggi.DayTimes >= gameGiftUserDayTimes) || (ggi.TotalTimes >= gameGiftUserTotalTimes);\n', '        }\n', '        else{\n', '            _result = ggi.TotalTimes >= gameGiftUserTotalTimes;\n', '        }\n', '    }\n', '\n', '    function setGameGiftOnceAmount(uint256 _value) public onlyOwner{\n', '        require(_value > 0 && _value < 100 * (10 ** uint256(decimals)));\n', '        gameGiftOnceAmount = _value;\n', '    }\n', '\n', '    function gameGifIsOver() view public returns(bool _result){\n', '        _result = (gameGiftLineTime <= now) || (balanceOf[iniOwner] < gameGiftOnceAmount) || (gameGiftMaxAmount < gameGiftSentAmount.add(gameGiftOnceAmount));    \n', '    }  \n', '\n', '    event OnSendGameGift(address _game, address _player, uint256 _gameGiftOnceAmount, uint _eventTime, uint _eventId);\n', '    \n', '    function _canSendGameGift() view private returns(bool _result){\n', '        _result = (isWhiteList(msg.sender)) && (!gameGifIsOver());\n', '    }\n', '\n', '    function sendGameGift(address _player) public returns (bool _result) {\n', '        uint256 _tokenAmount = gameGiftOnceAmount;\n', '        _result = _sendGameGift(_player, _tokenAmount);\n', '    }\n', '\n', '    function sendGameGift2(address _player, uint256 _tokenAmount) public returns (bool _result) {\n', '        require(gameGiftOnceAmount >= _tokenAmount);\n', '        _result = _sendGameGift(_player, _tokenAmount);\n', '    }\n', '\n', '    function _sendGameGift(address _player, uint256 _tokenAmount) private returns (bool _result) {\n', '        require(_player != 0x0);\n', '        require(_tokenAmount > 0 && _tokenAmount <= gameGiftOnceAmount);\n', '        \n', '        if(_player == iniOwner){ \n', '            return;\n', '        }                                 \n', '\n', '        require(msg.sender != tx.origin);\n', '        if(!_canSendGameGift()){   \n', '            return;\n', '        }\n', '        if(timesIsOver(_player)){ \n', '            return;\n', '        }\n', '\n', '        lock();         \n', '        _transfer(iniOwner, _player, _tokenAmount);\n', '        gameGiftSentAmount = gameGiftSentAmount.add(_tokenAmount);\n', '        emit OnSendGameGift(msg.sender,  _player,   _tokenAmount, now, getEventId());\n', '        _logGameGiftInfo(_player);    \n', '        unLock();\n', '        _result = true;\n', '    }\n', '\n', '\n', '    uint256  public baseIcoPrice =  (0.0002 ether) / (10 ** uint256(decimals)); \n', '  \n', '    function getIcoPrice() view public returns(uint256 _result){\n', '        _result = baseIcoPrice;\n', '        uint256 addDays = (now - createTime) / (1 days); \n', '        for(uint i = 1; i <= addDays; i++){\n', '            _result = _result.mul(101).div(100);\n', '        }\n', '    } \n', ' \n', '    uint256 public icoMaxAmount = totalSupply * 40 / 100;   \n', '    uint256 public icoedAmount = 0;                        \n', '    uint    public icoEndLine = now + 180 days;          \n', '\n', '    function icoIsOver() view public returns(bool _result){\n', '        _result = (icoEndLine < now)  || (icoedAmount >= icoMaxAmount) || (balanceOf[iniOwner] < (icoMaxAmount - icoedAmount)); \n', '    }  \n', '\n', '    function getAvaIcoAmount() view public returns(uint256 _result){  \n', '        _result = 0;\n', '        if (!icoIsOver()){\n', '            if (icoMaxAmount > icoedAmount){               \n', '                _result = icoMaxAmount.sub(icoedAmount);  \n', '            }\n', '        }\n', '    }  \n', '\n', '    event OnBuyIcoToken(uint256 _tokenPrice, uint256 _tokenAmount, uint256 _etherAmount, address _buyer, uint _eventTime, uint _eventId);\n', '\n', '    function buyIcoToken1()  public payable returns (bool _result) {  \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '        _result = _buyIcoToken(totalSupply);    \n', '    }\n', '\n', '    function buyIcoToken2(uint256 _tokenAmount)  public payable returns (bool _result) {  \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '        _result = _buyIcoToken(_tokenAmount); \n', '    }\n', '\n', '    function _buyIcoToken(uint256 _tokenAmount)  private returns (bool _result) {  \n', '        _result = false;    \n', '        require(_tokenAmount > 0);   \n', '        require(!icoIsOver());   \n', '        require(msg.sender != iniOwner);                                      \n', '        require(balanceOf[iniOwner] > 0);\n', '\n', '        uint256 buyIcoPrice =  getIcoPrice();\n', '        uint256 canTokenAmount = userEtherOf[msg.sender].div(buyIcoPrice);    \n', '        require(userEtherOf[msg.sender] > 0 && canTokenAmount > 0);\n', '        if(_tokenAmount < canTokenAmount){\n', '            canTokenAmount = _tokenAmount;\n', '        }\n', '\n', '        lock();\n', '\n', '        uint256 avaIcoAmount = getAvaIcoAmount();\n', '        if(canTokenAmount > avaIcoAmount){\n', '             canTokenAmount = avaIcoAmount;\n', '        }\n', '        require(canTokenAmount > 0);\n', '        uint256 etherAmount = canTokenAmount.mul(buyIcoPrice);\n', '        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(etherAmount);   \n', '        userEtherOf[iniOwner] = userEtherOf[iniOwner].add(etherAmount);        \n', '        _transfer(iniOwner, msg.sender, canTokenAmount);                      \n', '        emit OnBuyIcoToken(buyIcoPrice, canTokenAmount, etherAmount, msg.sender, now, getEventId());\n', '        icoedAmount = icoedAmount.add(canTokenAmount);\n', '        _result = true;\n', '\n', '        unLock();\n', '    }\n', '\n', '    struct webGiftInfo   \n', '    {\n', '        uint256 Amount; \n', '        uint PlayingTime; \n', '    }\n', '\n', '    mapping(address  => webGiftInfo) public webGiftList;\n', '\n', '    function _logSendWebGiftAndSendEther(address _to, uint256 _amount) private {\n', '        require(_to != 0x0);\n', '        webGiftInfo storage wgi = webGiftList[_to];\n', '\n', '        if(wgi.Amount == 0){\n', '            if (userEtherOf[iniOwner] >= webGiftEtherAmount){          \n', '                userEtherOf[iniOwner] = userEtherOf[iniOwner].sub(webGiftEtherAmount);\n', '                _to.transfer(webGiftEtherAmount);\n', '            }\n', '        }\n', '\n', '        if(wgi.PlayingTime == 0){\n', '            wgi.Amount = wgi.Amount.add(_amount);\n', '        }\n', '    }\n', '\n', '    event OnLogPlaying(address _player, uint _eventTime, uint _eventId);\n', '\n', '    function logPlaying(address _player) public returns (bool _result) {\n', '        _result = false;\n', '        require(_player != 0x0);\n', '        require(msg.sender != tx.origin);\n', '        require(isWhiteList(msg.sender)); \n', '\n', '        if (gameGiftLineTime < now) {\n', '            return;\n', '        }\n', '        \n', '        webGiftInfo storage wgi = webGiftList[_player];\n', '        if(wgi.PlayingTime == 0){                                   \n', '            wgi.PlayingTime = now;\n', '            emit OnLogPlaying(_player, now, getEventId());\n', '        }\n', '        _result = true;\n', '    }\n', '\n', '    function webGiftUnTransfer(address _from, address _to) public view returns(bool _result){\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        if(isWhiteList(_to) || _to == iniOwner){    \n', '            _result = false;\n', '            return;\n', '        }\n', '        webGiftInfo storage wgi = webGiftList[_from];\n', '        _result = (wgi.Amount > 0) && (wgi.PlayingTime == 0) && (now <= gameGiftLineTime);   \n', '    }\n', '\n', '    event OnRestoreWebGift(address _user, uint256 _tokenAmount, uint _eventTime, uint _eventId);\n', '\n', '    function restoreWebGift(address _user) public  returns (bool _result) { \n', '        _result = false;\n', '        require(_user != 0x0);\n', '        webGiftInfo storage wgi = webGiftList[_user];\n', '        if ((0 == wgi.PlayingTime) && (0 < wgi.Amount)){  \n', '            if (gameGiftLineTime.sub(20 days) < now  && now <= gameGiftLineTime) {   \n', '                uint256 amount = wgi.Amount;\n', '                if (amount > balanceOf[_user]){\n', '                    amount = balanceOf[_user];\n', '                }\n', '                _transfer(_user, iniOwner, amount);\n', '                emit OnRestoreWebGift(_user, amount, now, getEventId());\n', '                _result = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    function batchRestoreWebGift(address[] _users) public  returns (uint _result) {       \n', '        _result = 0;\n', '        for(uint i = 0; i < _users.length; i ++){\n', '            if(restoreWebGift(_users[i])){\n', '                _result = _result.add(1);\n', '            }\n', '        }\n', '    \n', '    }\n', '\n', '    \n', '    function () public payable {                      \n', '        if(msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value); \n', '        }\n', '\n', '        if(msg.sender != iniOwner){\n', '            if ((userEtherOf[msg.sender] > 0) && (!icoIsOver())){\n', '                _buyIcoToken(totalSupply);             \n', '            }\n', '        }\n', '    }\n', '\n', '\n', '}']
