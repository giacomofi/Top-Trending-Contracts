['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract ToorToken is ERC20Basic, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Account {\n', '        uint balance;\n', '        uint lastInterval;\n', '    }\n', '\n', '    mapping(address => Account) public accounts;\n', '    mapping(uint256 => uint256) ratesByYear;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 private rateMultiplier;\n', '\n', '    uint256 initialSupply_;\n', '    uint256 totalSupply_;\n', '    uint256 public maxSupply;\n', '    uint256 public startTime;\n', '    uint256 public pendingRewardsToMint;\n', '\n', '    string public name;\n', '    uint public decimals;\n', '    string public symbol;\n', '\n', '    uint256 private tokenGenInterval; // This defines the frequency at which we calculate rewards\n', '    uint256 private vestingPeriod; // Defines how often tokens vest to team\n', '    uint256 private cliff; // Defines the minimum amount of time required before tokens vest\n', '    uint256 public pendingInstallments; // Defines the number of pending vesting installments for team\n', '    uint256 public paidInstallments; // Defines the number of paid vesting installments for team\n', '    uint256 private totalVestingPool; //  Defines total vesting pool set aside for team\n', '    uint256 public pendingVestingPool; // Defines pending tokens in pool set aside for team\n', '    uint256 public finalIntervalForTokenGen; // The last instance of reward calculation, after which rewards will cease\n', '    uint256 private totalRateWindows; // This specifies the number of rate windows over the total period of time\n', '    uint256 private intervalsPerWindow; // Total number of times we calculate rewards within 1 rate window\n', '\n', '    // Variable to define once reward generation is complete\n', '    bool public rewardGenerationComplete;\n', '\n', '    // Ether addresses of founders and company\n', '    mapping(uint256 => address) public distributionAddresses;\n', '\n', '    // Events section\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function ToorToken() public {\n', '        name = "ToorCoin";\n', '        decimals = 18;\n', '        symbol = "TOOR";\n', '\n', '        // Setup the token staking reward percentage per year\n', '        rateMultiplier = 10**9;\n', '        ratesByYear[1] = 1.00474436 * 10**9;\n', '        ratesByYear[2] = 1.003278088 * 10**9;\n', '        ratesByYear[3] = 1.002799842 * 10**9;\n', '        ratesByYear[4] = 1.002443535 * 10**9;\n', '        ratesByYear[5] = 1.002167763 * 10**9;\n', '        ratesByYear[6] = 1.001947972 * 10**9;\n', '        ratesByYear[7] = 1.001768676 * 10**9;\n', '        ratesByYear[8] = 1.001619621 * 10**9;\n', '        ratesByYear[9] = 1.001493749 * 10**9;\n', '        ratesByYear[10] = 1.001386038 * 10**9;\n', '        ratesByYear[11] = 1.001292822 * 10**9;\n', '        ratesByYear[12] = 1.001211358 * 10**9;\n', '        ratesByYear[13] = 1.001139554 * 10**9;\n', '        ratesByYear[14] = 1.001075789 * 10**9;\n', '        ratesByYear[15] = 1.001018783 * 10**9;\n', '        ratesByYear[16] = 1.000967516 * 10**9;\n', '        ratesByYear[17] = 1.000921162 * 10**9;\n', '        ratesByYear[18] = 1.000879048 * 10**9;\n', '        ratesByYear[19] = 1.000840616 * 10**9;\n', '        ratesByYear[20] = 1.000805405 * 10**9;\n', '\n', '        totalRateWindows = 20;\n', '        \n', '        maxSupply = 100000000 * 10**18;\n', '        initialSupply_ = 13500000 * 10**18;\n', '        pendingInstallments = 7;\n', '        paidInstallments = 0;\n', '        totalVestingPool = 4500000 * 10**18;\n', '        startTime = now;\n', '\n', '        distributionAddresses[1] = 0x7d3BC9bb69dAB0544d34b7302DED8806bCF715e6; // founder 1\n', '        distributionAddresses[2] = 0x34Cf9afae3f926B9D040CA7A279C411355c5C480; // founder 2\n', '        distributionAddresses[3] = 0x059Cbd8A57b1dD944Da020a0D0a18D8dD7e78E04; // founder 3\n', '        distributionAddresses[4] = 0x4F8bC705827Fb8A781b27B9F02d2491F531f8962; // founder 4\n', '        distributionAddresses[5] = 0x532d370a98a478714625E9148D1205be061Df3bf; // founder 5\n', '        distributionAddresses[6] = 0xDe485bB000fA57e73197eF709960Fb7e32e0380E; // company\n', '        distributionAddresses[7] = 0xd562f635c75D2d7f3BE0005FBd3808a5cfb896bd; // bounty\n', '        \n', '        // This is for 20 years\n', '        tokenGenInterval = 603936;  // This is roughly 1 week in seconds\n', '        uint256 timeToGenAllTokens = 628093440; // This is close to 20 years in seconds\n', '\n', '        rewardGenerationComplete = false;\n', '        \n', '        // Mint initial tokens\n', '        accounts[distributionAddresses[6]].balance = (initialSupply_ * 60) / 100; // 60% of initial balance goes to Company\n', '        accounts[distributionAddresses[6]].lastInterval = 0;\n', '        generateMintEvents(distributionAddresses[6],accounts[distributionAddresses[6]].balance);\n', '        accounts[distributionAddresses[7]].balance = (initialSupply_ * 40) / 100; // 40% of inital balance goes to Bounty\n', '        accounts[distributionAddresses[7]].lastInterval = 0;\n', '        generateMintEvents(distributionAddresses[7],accounts[distributionAddresses[7]].balance);\n', '\n', '        pendingVestingPool = totalVestingPool;\n', '        pendingRewardsToMint = maxSupply - initialSupply_ - totalVestingPool;\n', '        totalSupply_ = initialSupply_;\n', '        vestingPeriod = timeToGenAllTokens / (totalRateWindows * 12); // One vesting period is a month\n', '        cliff = vestingPeriod * 6; // Cliff is six vesting periods aka 6 months roughly\n', '        finalIntervalForTokenGen = timeToGenAllTokens / tokenGenInterval;\n', '        intervalsPerWindow = finalIntervalForTokenGen / totalRateWindows;\n', '    }\n', '\n', '    // This gives the total supply of actual minted coins. Does not take rewards pending minting into consideration\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    // This function is called directly by users who wish to transfer tokens\n', '    function transfer(address _to, uint256 _value) canTransfer(_to) public returns (bool) {\n', '        // Call underlying transfer method and pass in the sender address\n', '        transferBasic(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // This function is called by both transfer and transferFrom\n', '    function transferBasic(address _from, address _to, uint256 _value) internal {\n', '        uint256 tokensOwedSender = 0;\n', '        uint256 tokensOwedReceiver = 0;\n', '        uint256 balSender = balanceOfBasic(_from);\n', '\n', '        // Distribute rewards tokens first\n', '        if (!rewardGenerationComplete) {\n', '            tokensOwedSender = tokensOwed(_from);\n', '            require(_value <= (balSender.add(tokensOwedSender))); // Sender should have the number of tokens they want to send\n', '\n', '            tokensOwedReceiver = tokensOwed(_to);\n', '\n', '            // If there were tokens owed, increase total supply accordingly\n', '            if ((tokensOwedSender.add(tokensOwedReceiver)) > 0) {\n', '                increaseTotalSupply(tokensOwedSender.add(tokensOwedReceiver)); // This will break if total exceeds max cap\n', '                pendingRewardsToMint = pendingRewardsToMint.sub(tokensOwedSender.add(tokensOwedReceiver));\n', '            }\n', '\n', '            // If there were tokens owed, raise mint events for them\n', '            raiseEventIfMinted(_from, tokensOwedSender);\n', '            raiseEventIfMinted(_to, tokensOwedReceiver);\n', '        } else {\n', '            require(_value <= balSender);\n', '        }\n', '        \n', '        // Update balances of sender and receiver\n', '        accounts[_from].balance = (balSender.add(tokensOwedSender)).sub(_value);\n', '        accounts[_to].balance = (accounts[_to].balance.add(tokensOwedReceiver)).add(_value);\n', '\n', '        // Update last intervals for sender and receiver\n', '        uint256 currInt = intervalAtTime(now);\n', '        accounts[_from].lastInterval = currInt;\n', '        accounts[_to].lastInterval = currInt;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // If you want to transfer tokens to multiple receivers at once\n', '    function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) {\n', '        uint256 cnt = _receivers.length;\n', '        uint256 amount = cnt.mul(_value);\n', '        \n', '        // Check that the value to send is more than 0\n', '        require(_value > 0);\n', '\n', '        // Add pending rewards for sender first\n', '        if (!rewardGenerationComplete) {\n', '            addReward(msg.sender);\n', '        }\n', '\n', '        // Get current balance of sender\n', '        uint256 balSender = balanceOfBasic(msg.sender);\n', '\n', '        // Check that the sender has the required amount\n', '        require(balSender >= amount);\n', '\n', '        // Update balance and lastInterval of sender\n', '        accounts[msg.sender].balance = balSender.sub(amount);\n', '        uint256 currInt = intervalAtTime(now);\n', '        accounts[msg.sender].lastInterval = currInt;\n', '        \n', '        \n', '        for (uint i = 0; i < cnt; i++) {\n', '            // Add pending rewards for receiver first\n', '            if (!rewardGenerationComplete) {\n', '                address receiver = _receivers[i];\n', '                \n', '                addReward(receiver);\n', '            }\n', '\n', '            // Update balance and lastInterval of receiver\n', '            accounts[_receivers[i]].balance = (accounts[_receivers[i]].balance).add(_value);\n', '            accounts[_receivers[i]].lastInterval = currInt;\n', '            emit Transfer(msg.sender, _receivers[i], _value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // This function allows someone to withdraw tokens from someone&#39;s address\n', '    // For this to work, the person needs to have been approved by the account owner (via the approve function)\n', '    function transferFrom(address _from, address _to, uint256 _value) canTransfer(_to) public returns (bool)\n', '    {\n', '        // Check that function caller has been approved to withdraw tokens\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Call out base transfer method\n', '        transferBasic(_from, _to, _value);\n', '\n', '        // Subtract withdrawn tokens from allowance\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        return true;\n', '    }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '      /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '    function allowance(address _owner, address _spender) public view returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '  \n', '   // Increase the amount of tokens that an owner allowed to a spender.\n', '   // approve should be called when allowed[_spender] == 0. To increment\n', '   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '   // Decrease the amount of tokens that an owner allowed to a spender.\n', '   // approve should be called when allowed[_spender] == 0. To decrement\n', '   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function raiseEventIfMinted(address owner, uint256 tokensToReward) private returns (bool) {\n', '        if (tokensToReward > 0) {\n', '            generateMintEvents(owner, tokensToReward);\n', '        }\n', '    }\n', '\n', '    function addReward(address owner) private returns (bool) {\n', '        uint256 tokensToReward = tokensOwed(owner);\n', '\n', '        if (tokensToReward > 0) {\n', '            increaseTotalSupply(tokensToReward); // This will break if total supply exceeds max cap. Should never happen though as tokensOwed checks for this condition\n', '            accounts[owner].balance = accounts[owner].balance.add(tokensToReward);\n', '            accounts[owner].lastInterval = intervalAtTime(now);\n', '            pendingRewardsToMint = pendingRewardsToMint.sub(tokensToReward); // This helps track rounding errors when computing rewards\n', '            generateMintEvents(owner, tokensToReward);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // This function is to vest tokens to the founding team\n', '    // This deliberately doesn&#39;t use SafeMath as all the values are controlled without risk of overflow\n', '    function vestTokens() public returns (bool) {\n', '        require(pendingInstallments > 0);\n', '        require(paidInstallments < 7);\n', '        require(pendingVestingPool > 0);\n', '        require(now - startTime > cliff);\n', '\n', '        // If they have rewards pending, allocate those first\n', '        if (!rewardGenerationComplete) {\n', '            for (uint256 i = 1; i <= 5; i++) {\n', '                addReward(distributionAddresses[i]);\n', '            }\n', '        }\n', '\n', '        uint256 currInterval = intervalAtTime(now);\n', '        uint256 tokensToVest = 0;\n', '        uint256 totalTokensToVest = 0;\n', '        uint256 totalPool = totalVestingPool;\n', '\n', '        uint256[2] memory founderCat;\n', '        founderCat[0] = 0;\n', '        founderCat[1] = 0;\n', '\n', '        uint256[5] memory origFounderBal;\n', '        origFounderBal[0] = accounts[distributionAddresses[1]].balance;\n', '        origFounderBal[1] = accounts[distributionAddresses[2]].balance;\n', '        origFounderBal[2] = accounts[distributionAddresses[3]].balance;\n', '        origFounderBal[3] = accounts[distributionAddresses[4]].balance;\n', '        origFounderBal[4] = accounts[distributionAddresses[5]].balance;\n', '\n', '        uint256[2] memory rewardCat;\n', '        rewardCat[0] = 0;\n', '        rewardCat[1] = 0;\n', '\n', '        // Pay out cliff\n', '        if (paidInstallments < 1) {\n', '            uint256 intervalAtCliff = intervalAtTime(cliff + startTime);\n', '            tokensToVest = totalPool / 4;\n', '\n', '            founderCat[0] = tokensToVest / 4;\n', '            founderCat[1] = tokensToVest / 8;\n', '\n', '            // Update vesting pool\n', '            pendingVestingPool -= tokensToVest;\n', '\n', '            // This condition checks if there are any rewards to pay after the cliff\n', '            if (currInterval > intervalAtCliff && !rewardGenerationComplete) {\n', '                rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalAtCliff, currInterval);\n', '                rewardCat[1] = rewardCat[0] / 2;\n', '\n', '                // Add rewards to founder tokens being vested\n', '                founderCat[0] += rewardCat[0];\n', '                founderCat[1] += rewardCat[1];\n', '\n', '                // Increase total amount of tokens to vest\n', '                tokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                // Reduce pending rewards\n', '                pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '            }\n', '\n', '            // Vest tokens for each of the founders, this includes any rewards pending since cliff passed\n', '            accounts[distributionAddresses[1]].balance += founderCat[0];\n', '            accounts[distributionAddresses[2]].balance += founderCat[0];\n', '            accounts[distributionAddresses[3]].balance += founderCat[0];\n', '            accounts[distributionAddresses[4]].balance += founderCat[1];\n', '            accounts[distributionAddresses[5]].balance += founderCat[1];\n', '\n', '            totalTokensToVest = tokensToVest;\n', '\n', '            // Update pending and paid installments\n', '            pendingInstallments -= 1;\n', '            paidInstallments += 1;\n', '        }\n', '\n', '        // Calculate the pending non-cliff installments to pay based on current time\n', '        uint256 installments = ((currInterval * tokenGenInterval) - cliff) / vestingPeriod;\n', '        uint256 installmentsToPay = installments + 1 - paidInstallments;\n', '\n', '        // If there are no installments to pay, skip this\n', '        if (installmentsToPay > 0) {\n', '            if (installmentsToPay > pendingInstallments) {\n', '                installmentsToPay = pendingInstallments;\n', '            }\n', '\n', '            // 12.5% vesting monthly after the cliff\n', '            tokensToVest = (totalPool * 125) / 1000;\n', '\n', '            founderCat[0] = tokensToVest / 4;\n', '            founderCat[1] = tokensToVest / 8;\n', '\n', '            uint256 intervalsAtVest = 0;\n', '\n', '            // Loop through installments to pay, so that we can add token holding rewards as we go along\n', '            for (uint256 installment = paidInstallments; installment < (installmentsToPay + paidInstallments); installment++) {\n', '                intervalsAtVest = intervalAtTime(cliff + (installment * vestingPeriod) + startTime);\n', '\n', '                // This condition checks if there are any rewards to pay after the cliff\n', '                if (currInterval >= intervalsAtVest && !rewardGenerationComplete) {\n', '                    rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalsAtVest, currInterval);\n', '                    rewardCat[1] = rewardCat[0] / 2;\n', '\n', '                    // Increase total amount of tokens to vest\n', '                    totalTokensToVest += tokensToVest;\n', '                    totalTokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                    // Reduce pending rewards\n', '                    pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                    // Vest tokens for each of the founders, this includes any rewards pending since vest interval passed\n', '                    accounts[distributionAddresses[1]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[2]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[3]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[4]].balance += (founderCat[1] + rewardCat[1]);\n', '                    accounts[distributionAddresses[5]].balance += (founderCat[1] + rewardCat[1]);\n', '                }\n', '            }\n', '\n', '            // Reduce pendingVestingPool and update pending and paid installments\n', '            pendingVestingPool -= (installmentsToPay * tokensToVest);\n', '            pendingInstallments -= installmentsToPay;\n', '            paidInstallments += installmentsToPay;\n', '        }\n', '\n', '        // Increase total supply by the number of tokens being vested\n', '        increaseTotalSupply(totalTokensToVest);\n', '            \n', '        accounts[distributionAddresses[1]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[2]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[3]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[4]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[5]].lastInterval = currInterval;\n', '\n', '        // Create events for token generation\n', '        generateMintEvents(distributionAddresses[1], (accounts[distributionAddresses[1]].balance - origFounderBal[0]));\n', '        generateMintEvents(distributionAddresses[2], (accounts[distributionAddresses[2]].balance - origFounderBal[1]));\n', '        generateMintEvents(distributionAddresses[3], (accounts[distributionAddresses[3]].balance - origFounderBal[2]));\n', '        generateMintEvents(distributionAddresses[4], (accounts[distributionAddresses[4]].balance - origFounderBal[3]));\n', '        generateMintEvents(distributionAddresses[5], (accounts[distributionAddresses[5]].balance - origFounderBal[4]));\n', '    }\n', '\n', '    function increaseTotalSupply (uint256 tokens) private returns (bool) {\n', '        require ((totalSupply_.add(tokens)) <= maxSupply);\n', '        totalSupply_ = totalSupply_.add(tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function tokensOwed(address owner) public view returns (uint256) {\n', '        // This array is introduced to circumvent stack depth issues\n', '        uint256 currInterval = intervalAtTime(now);\n', '        uint256 lastInterval = accounts[owner].lastInterval;\n', '        uint256 balance = accounts[owner].balance;\n', '\n', '        return tokensOwedByInterval(balance, lastInterval, currInterval);\n', '    }\n', '\n', '    function tokensOwedByInterval(uint256 balance, uint256 lastInterval, uint256 currInterval) public view returns (uint256) {\n', '        // Once the specified address has received all possible rewards, don&#39;t calculate anything\n', '        if (lastInterval >= currInterval || lastInterval >= finalIntervalForTokenGen) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 tokensHeld = balance; //tokensHeld\n', '        uint256 intPerWin = intervalsPerWindow;\n', '        uint256 totalRateWinds = totalRateWindows;\n', '\n', '        // Defines the number of intervals we compute rewards for at a time\n', '        uint256 intPerBatch = 5; // Hardcoded here instead of storing on blockchain to save gas\n', '\n', '        mapping(uint256 => uint256) ratByYear = ratesByYear;\n', '        uint256 ratMultiplier = rateMultiplier;\n', '\n', '        uint256 minRateWindow = (lastInterval / intPerWin).add(1);\n', '        uint256 maxRateWindow = (currInterval / intPerWin).add(1);\n', '        if (maxRateWindow > totalRateWinds) {\n', '            maxRateWindow = totalRateWinds;\n', '        }\n', '\n', '        // Loop through pending periods of rewards, and calculate the total balance user should hold\n', '        for (uint256 rateWindow = minRateWindow; rateWindow <= maxRateWindow; rateWindow++) {\n', '            uint256 intervals = getIntervalsForWindow(rateWindow, lastInterval, currInterval, intPerWin);\n', '\n', '            // This part is to ensure we don&#39;t overflow when rewards are pending for a large number of intervals\n', '            // Loop through interval in batches\n', '            while (intervals > 0) {\n', '                if (intervals >= intPerBatch) {\n', '                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intPerBatch)) / (ratMultiplier ** intPerBatch);\n', '                    intervals = intervals.sub(intPerBatch);\n', '                } else {\n', '                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intervals)) / (ratMultiplier ** intervals);\n', '                    intervals = 0;\n', '                }\n', '            }            \n', '        }\n', '\n', '        // Rewards owed are the total balance that user SHOULD have minus what they currently have\n', '        return (tokensHeld.sub(balance));\n', '    }\n', '\n', '    function intervalAtTime(uint256 time) public view returns (uint256) {\n', '        // Check to see that time passed in is not before contract generation time, as that would cause a negative value in the next step\n', '        if (time <= startTime) {\n', '            return 0;\n', '        }\n', '\n', '        // Based on time passed in, check how many intervals have elapsed\n', '        uint256 interval = (time.sub(startTime)) / tokenGenInterval;\n', '        uint256 finalInt = finalIntervalForTokenGen; // Assign to local to reduce gas\n', '        \n', '        // Return max intervals if it&#39;s greater than that time\n', '        if (interval > finalInt) {\n', '            return finalInt;\n', '        } else {\n', '            return interval;\n', '        }\n', '    }\n', '\n', '    // This function checks how many intervals for a given window do we owe tokens to someone for \n', '    function getIntervalsForWindow(uint256 rateWindow, uint256 lastInterval, uint256 currInterval, uint256 intPerWind) public pure returns (uint256) {\n', '        // If lastInterval for holder falls in a window previous to current one, the lastInterval for the window passed into the function would be the window start interval\n', '        if (lastInterval < ((rateWindow.sub(1)).mul(intPerWind))) {\n', '            lastInterval = ((rateWindow.sub(1)).mul(intPerWind));\n', '        }\n', '\n', '        // If currentInterval for holder falls in a window higher than current one, the currentInterval for the window passed into the function would be the window end interval\n', '        if (currInterval > rateWindow.mul(intPerWind)) {\n', '            currInterval = rateWindow.mul(intPerWind);\n', '        }\n', '\n', '        return currInterval.sub(lastInterval);\n', '    }\n', '\n', '    // This function tells the balance of tokens at a particular address\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        if (rewardGenerationComplete) {\n', '            return accounts[_owner].balance;\n', '        } else {\n', '            return (accounts[_owner].balance).add(tokensOwed(_owner));\n', '        }\n', '    }\n', '\n', '    function balanceOfBasic(address _owner) public view returns (uint256 balance) {\n', '        return accounts[_owner].balance;\n', '    }\n', '\n', '    // This functions returns the last time at which rewards were transferred to a particular address\n', '    function lastTimeOf(address _owner) public view returns (uint256 interval, uint256 time) {\n', '        return (accounts[_owner].lastInterval, ((accounts[_owner].lastInterval).mul(tokenGenInterval)).add(startTime));\n', '    }\n', '\n', '    // This function is not meant to be used. It&#39;s only written as a fail-safe against potential unforeseen issues\n', '    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '        // Add pending rewards for recipient of minted tokens\n', '        if (!rewardGenerationComplete) {\n', '            addReward(_to);\n', '        }\n', '\n', '        // Increase total supply by minted amount\n', '        increaseTotalSupply(_amount);\n', '\n', '        // Update balance and last interval\n', '        accounts[_to].lastInterval = intervalAtTime(now);\n', '        accounts[_to].balance = (accounts[_to].balance).add(_amount);\n', '\n', '        generateMintEvents(_to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function generateMintEvents(address _to, uint256 _amount) private returns (bool) {\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Allows the burning of tokens\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balanceOf(msg.sender));\n', '\n', '        // First add any rewards pending for the person burning tokens\n', '        if (!rewardGenerationComplete) {\n', '            addReward(msg.sender);\n', '        }\n', '\n', '        // Update balance and lastInterval of person burning tokens\n', '        accounts[msg.sender].balance = (accounts[msg.sender].balance).sub(_value);\n', '        accounts[msg.sender].lastInterval = intervalAtTime(now);\n', '\n', '        // Update total supply\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '\n', '        // Raise events\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '    }\n', '\n', '    // These set of functions allow changing of founder and company addresses\n', '    function setFounder(uint256 id, address _to) onlyOwner public returns (bool) {\n', '        require(_to != address(0));\n', '        distributionAddresses[id] = _to;\n', '        return true;\n', '    }\n', '\n', '    // This is a setter for rewardGenerationComplete. It will be used to see if token rewards need to be computed, and can only be set by owner\n', '    function setRewardGenerationComplete(bool _value) onlyOwner public returns (bool) {\n', '        rewardGenerationComplete = _value;\n', '        return true;\n', '    }\n', '\n', '    // This function is added to get a state of where the token is in term of reward generation\n', '    function getNow() public view returns (uint256, uint256, uint256) {\n', '        return (now, block.number, intervalAtTime(now));\n', '    }\n', '\n', '    // This modifier is used on the transfer method and defines where tokens CANNOT be sent\n', '    modifier canTransfer(address _to) {\n', '        require(_to != address(0)); // Transfer should not be allowed to burn tokens\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract ToorToken is ERC20Basic, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Account {\n', '        uint balance;\n', '        uint lastInterval;\n', '    }\n', '\n', '    mapping(address => Account) public accounts;\n', '    mapping(uint256 => uint256) ratesByYear;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 private rateMultiplier;\n', '\n', '    uint256 initialSupply_;\n', '    uint256 totalSupply_;\n', '    uint256 public maxSupply;\n', '    uint256 public startTime;\n', '    uint256 public pendingRewardsToMint;\n', '\n', '    string public name;\n', '    uint public decimals;\n', '    string public symbol;\n', '\n', '    uint256 private tokenGenInterval; // This defines the frequency at which we calculate rewards\n', '    uint256 private vestingPeriod; // Defines how often tokens vest to team\n', '    uint256 private cliff; // Defines the minimum amount of time required before tokens vest\n', '    uint256 public pendingInstallments; // Defines the number of pending vesting installments for team\n', '    uint256 public paidInstallments; // Defines the number of paid vesting installments for team\n', '    uint256 private totalVestingPool; //  Defines total vesting pool set aside for team\n', '    uint256 public pendingVestingPool; // Defines pending tokens in pool set aside for team\n', '    uint256 public finalIntervalForTokenGen; // The last instance of reward calculation, after which rewards will cease\n', '    uint256 private totalRateWindows; // This specifies the number of rate windows over the total period of time\n', '    uint256 private intervalsPerWindow; // Total number of times we calculate rewards within 1 rate window\n', '\n', '    // Variable to define once reward generation is complete\n', '    bool public rewardGenerationComplete;\n', '\n', '    // Ether addresses of founders and company\n', '    mapping(uint256 => address) public distributionAddresses;\n', '\n', '    // Events section\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function ToorToken() public {\n', '        name = "ToorCoin";\n', '        decimals = 18;\n', '        symbol = "TOOR";\n', '\n', '        // Setup the token staking reward percentage per year\n', '        rateMultiplier = 10**9;\n', '        ratesByYear[1] = 1.00474436 * 10**9;\n', '        ratesByYear[2] = 1.003278088 * 10**9;\n', '        ratesByYear[3] = 1.002799842 * 10**9;\n', '        ratesByYear[4] = 1.002443535 * 10**9;\n', '        ratesByYear[5] = 1.002167763 * 10**9;\n', '        ratesByYear[6] = 1.001947972 * 10**9;\n', '        ratesByYear[7] = 1.001768676 * 10**9;\n', '        ratesByYear[8] = 1.001619621 * 10**9;\n', '        ratesByYear[9] = 1.001493749 * 10**9;\n', '        ratesByYear[10] = 1.001386038 * 10**9;\n', '        ratesByYear[11] = 1.001292822 * 10**9;\n', '        ratesByYear[12] = 1.001211358 * 10**9;\n', '        ratesByYear[13] = 1.001139554 * 10**9;\n', '        ratesByYear[14] = 1.001075789 * 10**9;\n', '        ratesByYear[15] = 1.001018783 * 10**9;\n', '        ratesByYear[16] = 1.000967516 * 10**9;\n', '        ratesByYear[17] = 1.000921162 * 10**9;\n', '        ratesByYear[18] = 1.000879048 * 10**9;\n', '        ratesByYear[19] = 1.000840616 * 10**9;\n', '        ratesByYear[20] = 1.000805405 * 10**9;\n', '\n', '        totalRateWindows = 20;\n', '        \n', '        maxSupply = 100000000 * 10**18;\n', '        initialSupply_ = 13500000 * 10**18;\n', '        pendingInstallments = 7;\n', '        paidInstallments = 0;\n', '        totalVestingPool = 4500000 * 10**18;\n', '        startTime = now;\n', '\n', '        distributionAddresses[1] = 0x7d3BC9bb69dAB0544d34b7302DED8806bCF715e6; // founder 1\n', '        distributionAddresses[2] = 0x34Cf9afae3f926B9D040CA7A279C411355c5C480; // founder 2\n', '        distributionAddresses[3] = 0x059Cbd8A57b1dD944Da020a0D0a18D8dD7e78E04; // founder 3\n', '        distributionAddresses[4] = 0x4F8bC705827Fb8A781b27B9F02d2491F531f8962; // founder 4\n', '        distributionAddresses[5] = 0x532d370a98a478714625E9148D1205be061Df3bf; // founder 5\n', '        distributionAddresses[6] = 0xDe485bB000fA57e73197eF709960Fb7e32e0380E; // company\n', '        distributionAddresses[7] = 0xd562f635c75D2d7f3BE0005FBd3808a5cfb896bd; // bounty\n', '        \n', '        // This is for 20 years\n', '        tokenGenInterval = 603936;  // This is roughly 1 week in seconds\n', '        uint256 timeToGenAllTokens = 628093440; // This is close to 20 years in seconds\n', '\n', '        rewardGenerationComplete = false;\n', '        \n', '        // Mint initial tokens\n', '        accounts[distributionAddresses[6]].balance = (initialSupply_ * 60) / 100; // 60% of initial balance goes to Company\n', '        accounts[distributionAddresses[6]].lastInterval = 0;\n', '        generateMintEvents(distributionAddresses[6],accounts[distributionAddresses[6]].balance);\n', '        accounts[distributionAddresses[7]].balance = (initialSupply_ * 40) / 100; // 40% of inital balance goes to Bounty\n', '        accounts[distributionAddresses[7]].lastInterval = 0;\n', '        generateMintEvents(distributionAddresses[7],accounts[distributionAddresses[7]].balance);\n', '\n', '        pendingVestingPool = totalVestingPool;\n', '        pendingRewardsToMint = maxSupply - initialSupply_ - totalVestingPool;\n', '        totalSupply_ = initialSupply_;\n', '        vestingPeriod = timeToGenAllTokens / (totalRateWindows * 12); // One vesting period is a month\n', '        cliff = vestingPeriod * 6; // Cliff is six vesting periods aka 6 months roughly\n', '        finalIntervalForTokenGen = timeToGenAllTokens / tokenGenInterval;\n', '        intervalsPerWindow = finalIntervalForTokenGen / totalRateWindows;\n', '    }\n', '\n', '    // This gives the total supply of actual minted coins. Does not take rewards pending minting into consideration\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    // This function is called directly by users who wish to transfer tokens\n', '    function transfer(address _to, uint256 _value) canTransfer(_to) public returns (bool) {\n', '        // Call underlying transfer method and pass in the sender address\n', '        transferBasic(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // This function is called by both transfer and transferFrom\n', '    function transferBasic(address _from, address _to, uint256 _value) internal {\n', '        uint256 tokensOwedSender = 0;\n', '        uint256 tokensOwedReceiver = 0;\n', '        uint256 balSender = balanceOfBasic(_from);\n', '\n', '        // Distribute rewards tokens first\n', '        if (!rewardGenerationComplete) {\n', '            tokensOwedSender = tokensOwed(_from);\n', '            require(_value <= (balSender.add(tokensOwedSender))); // Sender should have the number of tokens they want to send\n', '\n', '            tokensOwedReceiver = tokensOwed(_to);\n', '\n', '            // If there were tokens owed, increase total supply accordingly\n', '            if ((tokensOwedSender.add(tokensOwedReceiver)) > 0) {\n', '                increaseTotalSupply(tokensOwedSender.add(tokensOwedReceiver)); // This will break if total exceeds max cap\n', '                pendingRewardsToMint = pendingRewardsToMint.sub(tokensOwedSender.add(tokensOwedReceiver));\n', '            }\n', '\n', '            // If there were tokens owed, raise mint events for them\n', '            raiseEventIfMinted(_from, tokensOwedSender);\n', '            raiseEventIfMinted(_to, tokensOwedReceiver);\n', '        } else {\n', '            require(_value <= balSender);\n', '        }\n', '        \n', '        // Update balances of sender and receiver\n', '        accounts[_from].balance = (balSender.add(tokensOwedSender)).sub(_value);\n', '        accounts[_to].balance = (accounts[_to].balance.add(tokensOwedReceiver)).add(_value);\n', '\n', '        // Update last intervals for sender and receiver\n', '        uint256 currInt = intervalAtTime(now);\n', '        accounts[_from].lastInterval = currInt;\n', '        accounts[_to].lastInterval = currInt;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // If you want to transfer tokens to multiple receivers at once\n', '    function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) {\n', '        uint256 cnt = _receivers.length;\n', '        uint256 amount = cnt.mul(_value);\n', '        \n', '        // Check that the value to send is more than 0\n', '        require(_value > 0);\n', '\n', '        // Add pending rewards for sender first\n', '        if (!rewardGenerationComplete) {\n', '            addReward(msg.sender);\n', '        }\n', '\n', '        // Get current balance of sender\n', '        uint256 balSender = balanceOfBasic(msg.sender);\n', '\n', '        // Check that the sender has the required amount\n', '        require(balSender >= amount);\n', '\n', '        // Update balance and lastInterval of sender\n', '        accounts[msg.sender].balance = balSender.sub(amount);\n', '        uint256 currInt = intervalAtTime(now);\n', '        accounts[msg.sender].lastInterval = currInt;\n', '        \n', '        \n', '        for (uint i = 0; i < cnt; i++) {\n', '            // Add pending rewards for receiver first\n', '            if (!rewardGenerationComplete) {\n', '                address receiver = _receivers[i];\n', '                \n', '                addReward(receiver);\n', '            }\n', '\n', '            // Update balance and lastInterval of receiver\n', '            accounts[_receivers[i]].balance = (accounts[_receivers[i]].balance).add(_value);\n', '            accounts[_receivers[i]].lastInterval = currInt;\n', '            emit Transfer(msg.sender, _receivers[i], _value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', "    // This function allows someone to withdraw tokens from someone's address\n", '    // For this to work, the person needs to have been approved by the account owner (via the approve function)\n', '    function transferFrom(address _from, address _to, uint256 _value) canTransfer(_to) public returns (bool)\n', '    {\n', '        // Check that function caller has been approved to withdraw tokens\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Call out base transfer method\n', '        transferBasic(_from, _to, _value);\n', '\n', '        // Subtract withdrawn tokens from allowance\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        return true;\n', '    }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '      /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '    function allowance(address _owner, address _spender) public view returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '  \n', '   // Increase the amount of tokens that an owner allowed to a spender.\n', '   // approve should be called when allowed[_spender] == 0. To increment\n', '   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '   // Decrease the amount of tokens that an owner allowed to a spender.\n', '   // approve should be called when allowed[_spender] == 0. To decrement\n', '   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function raiseEventIfMinted(address owner, uint256 tokensToReward) private returns (bool) {\n', '        if (tokensToReward > 0) {\n', '            generateMintEvents(owner, tokensToReward);\n', '        }\n', '    }\n', '\n', '    function addReward(address owner) private returns (bool) {\n', '        uint256 tokensToReward = tokensOwed(owner);\n', '\n', '        if (tokensToReward > 0) {\n', '            increaseTotalSupply(tokensToReward); // This will break if total supply exceeds max cap. Should never happen though as tokensOwed checks for this condition\n', '            accounts[owner].balance = accounts[owner].balance.add(tokensToReward);\n', '            accounts[owner].lastInterval = intervalAtTime(now);\n', '            pendingRewardsToMint = pendingRewardsToMint.sub(tokensToReward); // This helps track rounding errors when computing rewards\n', '            generateMintEvents(owner, tokensToReward);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // This function is to vest tokens to the founding team\n', "    // This deliberately doesn't use SafeMath as all the values are controlled without risk of overflow\n", '    function vestTokens() public returns (bool) {\n', '        require(pendingInstallments > 0);\n', '        require(paidInstallments < 7);\n', '        require(pendingVestingPool > 0);\n', '        require(now - startTime > cliff);\n', '\n', '        // If they have rewards pending, allocate those first\n', '        if (!rewardGenerationComplete) {\n', '            for (uint256 i = 1; i <= 5; i++) {\n', '                addReward(distributionAddresses[i]);\n', '            }\n', '        }\n', '\n', '        uint256 currInterval = intervalAtTime(now);\n', '        uint256 tokensToVest = 0;\n', '        uint256 totalTokensToVest = 0;\n', '        uint256 totalPool = totalVestingPool;\n', '\n', '        uint256[2] memory founderCat;\n', '        founderCat[0] = 0;\n', '        founderCat[1] = 0;\n', '\n', '        uint256[5] memory origFounderBal;\n', '        origFounderBal[0] = accounts[distributionAddresses[1]].balance;\n', '        origFounderBal[1] = accounts[distributionAddresses[2]].balance;\n', '        origFounderBal[2] = accounts[distributionAddresses[3]].balance;\n', '        origFounderBal[3] = accounts[distributionAddresses[4]].balance;\n', '        origFounderBal[4] = accounts[distributionAddresses[5]].balance;\n', '\n', '        uint256[2] memory rewardCat;\n', '        rewardCat[0] = 0;\n', '        rewardCat[1] = 0;\n', '\n', '        // Pay out cliff\n', '        if (paidInstallments < 1) {\n', '            uint256 intervalAtCliff = intervalAtTime(cliff + startTime);\n', '            tokensToVest = totalPool / 4;\n', '\n', '            founderCat[0] = tokensToVest / 4;\n', '            founderCat[1] = tokensToVest / 8;\n', '\n', '            // Update vesting pool\n', '            pendingVestingPool -= tokensToVest;\n', '\n', '            // This condition checks if there are any rewards to pay after the cliff\n', '            if (currInterval > intervalAtCliff && !rewardGenerationComplete) {\n', '                rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalAtCliff, currInterval);\n', '                rewardCat[1] = rewardCat[0] / 2;\n', '\n', '                // Add rewards to founder tokens being vested\n', '                founderCat[0] += rewardCat[0];\n', '                founderCat[1] += rewardCat[1];\n', '\n', '                // Increase total amount of tokens to vest\n', '                tokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                // Reduce pending rewards\n', '                pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '            }\n', '\n', '            // Vest tokens for each of the founders, this includes any rewards pending since cliff passed\n', '            accounts[distributionAddresses[1]].balance += founderCat[0];\n', '            accounts[distributionAddresses[2]].balance += founderCat[0];\n', '            accounts[distributionAddresses[3]].balance += founderCat[0];\n', '            accounts[distributionAddresses[4]].balance += founderCat[1];\n', '            accounts[distributionAddresses[5]].balance += founderCat[1];\n', '\n', '            totalTokensToVest = tokensToVest;\n', '\n', '            // Update pending and paid installments\n', '            pendingInstallments -= 1;\n', '            paidInstallments += 1;\n', '        }\n', '\n', '        // Calculate the pending non-cliff installments to pay based on current time\n', '        uint256 installments = ((currInterval * tokenGenInterval) - cliff) / vestingPeriod;\n', '        uint256 installmentsToPay = installments + 1 - paidInstallments;\n', '\n', '        // If there are no installments to pay, skip this\n', '        if (installmentsToPay > 0) {\n', '            if (installmentsToPay > pendingInstallments) {\n', '                installmentsToPay = pendingInstallments;\n', '            }\n', '\n', '            // 12.5% vesting monthly after the cliff\n', '            tokensToVest = (totalPool * 125) / 1000;\n', '\n', '            founderCat[0] = tokensToVest / 4;\n', '            founderCat[1] = tokensToVest / 8;\n', '\n', '            uint256 intervalsAtVest = 0;\n', '\n', '            // Loop through installments to pay, so that we can add token holding rewards as we go along\n', '            for (uint256 installment = paidInstallments; installment < (installmentsToPay + paidInstallments); installment++) {\n', '                intervalsAtVest = intervalAtTime(cliff + (installment * vestingPeriod) + startTime);\n', '\n', '                // This condition checks if there are any rewards to pay after the cliff\n', '                if (currInterval >= intervalsAtVest && !rewardGenerationComplete) {\n', '                    rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalsAtVest, currInterval);\n', '                    rewardCat[1] = rewardCat[0] / 2;\n', '\n', '                    // Increase total amount of tokens to vest\n', '                    totalTokensToVest += tokensToVest;\n', '                    totalTokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                    // Reduce pending rewards\n', '                    pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\n', '\n', '                    // Vest tokens for each of the founders, this includes any rewards pending since vest interval passed\n', '                    accounts[distributionAddresses[1]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[2]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[3]].balance += (founderCat[0] + rewardCat[0]);\n', '                    accounts[distributionAddresses[4]].balance += (founderCat[1] + rewardCat[1]);\n', '                    accounts[distributionAddresses[5]].balance += (founderCat[1] + rewardCat[1]);\n', '                }\n', '            }\n', '\n', '            // Reduce pendingVestingPool and update pending and paid installments\n', '            pendingVestingPool -= (installmentsToPay * tokensToVest);\n', '            pendingInstallments -= installmentsToPay;\n', '            paidInstallments += installmentsToPay;\n', '        }\n', '\n', '        // Increase total supply by the number of tokens being vested\n', '        increaseTotalSupply(totalTokensToVest);\n', '            \n', '        accounts[distributionAddresses[1]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[2]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[3]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[4]].lastInterval = currInterval;\n', '        accounts[distributionAddresses[5]].lastInterval = currInterval;\n', '\n', '        // Create events for token generation\n', '        generateMintEvents(distributionAddresses[1], (accounts[distributionAddresses[1]].balance - origFounderBal[0]));\n', '        generateMintEvents(distributionAddresses[2], (accounts[distributionAddresses[2]].balance - origFounderBal[1]));\n', '        generateMintEvents(distributionAddresses[3], (accounts[distributionAddresses[3]].balance - origFounderBal[2]));\n', '        generateMintEvents(distributionAddresses[4], (accounts[distributionAddresses[4]].balance - origFounderBal[3]));\n', '        generateMintEvents(distributionAddresses[5], (accounts[distributionAddresses[5]].balance - origFounderBal[4]));\n', '    }\n', '\n', '    function increaseTotalSupply (uint256 tokens) private returns (bool) {\n', '        require ((totalSupply_.add(tokens)) <= maxSupply);\n', '        totalSupply_ = totalSupply_.add(tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function tokensOwed(address owner) public view returns (uint256) {\n', '        // This array is introduced to circumvent stack depth issues\n', '        uint256 currInterval = intervalAtTime(now);\n', '        uint256 lastInterval = accounts[owner].lastInterval;\n', '        uint256 balance = accounts[owner].balance;\n', '\n', '        return tokensOwedByInterval(balance, lastInterval, currInterval);\n', '    }\n', '\n', '    function tokensOwedByInterval(uint256 balance, uint256 lastInterval, uint256 currInterval) public view returns (uint256) {\n', "        // Once the specified address has received all possible rewards, don't calculate anything\n", '        if (lastInterval >= currInterval || lastInterval >= finalIntervalForTokenGen) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 tokensHeld = balance; //tokensHeld\n', '        uint256 intPerWin = intervalsPerWindow;\n', '        uint256 totalRateWinds = totalRateWindows;\n', '\n', '        // Defines the number of intervals we compute rewards for at a time\n', '        uint256 intPerBatch = 5; // Hardcoded here instead of storing on blockchain to save gas\n', '\n', '        mapping(uint256 => uint256) ratByYear = ratesByYear;\n', '        uint256 ratMultiplier = rateMultiplier;\n', '\n', '        uint256 minRateWindow = (lastInterval / intPerWin).add(1);\n', '        uint256 maxRateWindow = (currInterval / intPerWin).add(1);\n', '        if (maxRateWindow > totalRateWinds) {\n', '            maxRateWindow = totalRateWinds;\n', '        }\n', '\n', '        // Loop through pending periods of rewards, and calculate the total balance user should hold\n', '        for (uint256 rateWindow = minRateWindow; rateWindow <= maxRateWindow; rateWindow++) {\n', '            uint256 intervals = getIntervalsForWindow(rateWindow, lastInterval, currInterval, intPerWin);\n', '\n', "            // This part is to ensure we don't overflow when rewards are pending for a large number of intervals\n", '            // Loop through interval in batches\n', '            while (intervals > 0) {\n', '                if (intervals >= intPerBatch) {\n', '                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intPerBatch)) / (ratMultiplier ** intPerBatch);\n', '                    intervals = intervals.sub(intPerBatch);\n', '                } else {\n', '                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intervals)) / (ratMultiplier ** intervals);\n', '                    intervals = 0;\n', '                }\n', '            }            \n', '        }\n', '\n', '        // Rewards owed are the total balance that user SHOULD have minus what they currently have\n', '        return (tokensHeld.sub(balance));\n', '    }\n', '\n', '    function intervalAtTime(uint256 time) public view returns (uint256) {\n', '        // Check to see that time passed in is not before contract generation time, as that would cause a negative value in the next step\n', '        if (time <= startTime) {\n', '            return 0;\n', '        }\n', '\n', '        // Based on time passed in, check how many intervals have elapsed\n', '        uint256 interval = (time.sub(startTime)) / tokenGenInterval;\n', '        uint256 finalInt = finalIntervalForTokenGen; // Assign to local to reduce gas\n', '        \n', "        // Return max intervals if it's greater than that time\n", '        if (interval > finalInt) {\n', '            return finalInt;\n', '        } else {\n', '            return interval;\n', '        }\n', '    }\n', '\n', '    // This function checks how many intervals for a given window do we owe tokens to someone for \n', '    function getIntervalsForWindow(uint256 rateWindow, uint256 lastInterval, uint256 currInterval, uint256 intPerWind) public pure returns (uint256) {\n', '        // If lastInterval for holder falls in a window previous to current one, the lastInterval for the window passed into the function would be the window start interval\n', '        if (lastInterval < ((rateWindow.sub(1)).mul(intPerWind))) {\n', '            lastInterval = ((rateWindow.sub(1)).mul(intPerWind));\n', '        }\n', '\n', '        // If currentInterval for holder falls in a window higher than current one, the currentInterval for the window passed into the function would be the window end interval\n', '        if (currInterval > rateWindow.mul(intPerWind)) {\n', '            currInterval = rateWindow.mul(intPerWind);\n', '        }\n', '\n', '        return currInterval.sub(lastInterval);\n', '    }\n', '\n', '    // This function tells the balance of tokens at a particular address\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        if (rewardGenerationComplete) {\n', '            return accounts[_owner].balance;\n', '        } else {\n', '            return (accounts[_owner].balance).add(tokensOwed(_owner));\n', '        }\n', '    }\n', '\n', '    function balanceOfBasic(address _owner) public view returns (uint256 balance) {\n', '        return accounts[_owner].balance;\n', '    }\n', '\n', '    // This functions returns the last time at which rewards were transferred to a particular address\n', '    function lastTimeOf(address _owner) public view returns (uint256 interval, uint256 time) {\n', '        return (accounts[_owner].lastInterval, ((accounts[_owner].lastInterval).mul(tokenGenInterval)).add(startTime));\n', '    }\n', '\n', "    // This function is not meant to be used. It's only written as a fail-safe against potential unforeseen issues\n", '    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '        // Add pending rewards for recipient of minted tokens\n', '        if (!rewardGenerationComplete) {\n', '            addReward(_to);\n', '        }\n', '\n', '        // Increase total supply by minted amount\n', '        increaseTotalSupply(_amount);\n', '\n', '        // Update balance and last interval\n', '        accounts[_to].lastInterval = intervalAtTime(now);\n', '        accounts[_to].balance = (accounts[_to].balance).add(_amount);\n', '\n', '        generateMintEvents(_to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function generateMintEvents(address _to, uint256 _amount) private returns (bool) {\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Allows the burning of tokens\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balanceOf(msg.sender));\n', '\n', '        // First add any rewards pending for the person burning tokens\n', '        if (!rewardGenerationComplete) {\n', '            addReward(msg.sender);\n', '        }\n', '\n', '        // Update balance and lastInterval of person burning tokens\n', '        accounts[msg.sender].balance = (accounts[msg.sender].balance).sub(_value);\n', '        accounts[msg.sender].lastInterval = intervalAtTime(now);\n', '\n', '        // Update total supply\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '\n', '        // Raise events\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '    }\n', '\n', '    // These set of functions allow changing of founder and company addresses\n', '    function setFounder(uint256 id, address _to) onlyOwner public returns (bool) {\n', '        require(_to != address(0));\n', '        distributionAddresses[id] = _to;\n', '        return true;\n', '    }\n', '\n', '    // This is a setter for rewardGenerationComplete. It will be used to see if token rewards need to be computed, and can only be set by owner\n', '    function setRewardGenerationComplete(bool _value) onlyOwner public returns (bool) {\n', '        rewardGenerationComplete = _value;\n', '        return true;\n', '    }\n', '\n', '    // This function is added to get a state of where the token is in term of reward generation\n', '    function getNow() public view returns (uint256, uint256, uint256) {\n', '        return (now, block.number, intervalAtTime(now));\n', '    }\n', '\n', '    // This modifier is used on the transfer method and defines where tokens CANNOT be sent\n', '    modifier canTransfer(address _to) {\n', '        require(_to != address(0)); // Transfer should not be allowed to burn tokens\n', '        _;\n', '    }\n', '}']
