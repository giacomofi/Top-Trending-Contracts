['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', 'contract PlagueEvents {\n', '\t\n', '\t//infective person\n', '    event onInfectiveStage\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 keys,\n', '        uint256 eth,\n', '        uint256 timeStamp,\n', '\t\taddress indexed inveter\n', '    );\n', '\n', '    // become leader during second stage\n', '    event onDevelopmentStage\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 eth,\n', '        uint256 timeStamp,\n', '\t\taddress indexed inveter\n', '    );\n', '\n', '    // award\n', '    event onAward\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 eth,\n', '        uint256 timeStamp\n', '    );\n', '}\n', '\n', 'contract Plague is PlagueEvents{\n', '    using SafeMath for *;\n', '    using KeysCalc for uint256;\n', '\n', '    struct Round {\n', '        uint256 eth;                // total eth\n', '        uint256 keys;               // total keys\n', '        uint256 startTime;          // end time\n', '        uint256 endTime;            // end time\n', '        uint256 infectiveEndTime;   // infective end time\n', '        address leader;             // leader\n', '        address infectLastPlayer;   // the player will award 10% eth\n', '        address [11] lastInfective;  // the lastest 11 infective\n', '        address [4] loseInfective;  // the lose infective\n', '        bool [11] infectiveAward_m; //\n', '        uint256 totalInfective;     // the count of this round\n', '        uint256 inveterAmount;      // remain inveter amount of this round\n', '        uint256 lastRoundReward;    // last round remain eth 10% + eth 4% - inveterAmount + last remain award\n', '        uint256 exAward;            // development award\n', '    }\n', '\n', '    struct PlayerRound {\n', '        uint256 eth;        // eth player has added to round\n', '        uint256 keys;       // keys\n', '        uint256 withdraw;   // how many eth has been withdraw\n', '        uint256 getInveterAmount; // inverter amount\n', '        uint256 hasGetAwardAmount;  // player has get award amount\n', '    }\n', '\n', '    uint256 public rndNo = 1;                                   // current round number\n', '    uint256 public totalEth = 0;                                // total eth in all round\n', '\n', '    uint256 constant private rndInfectiveStage_ = 10 minutes;          // round timer at iinfective stage12 hours;\n', '    uint256 constant private rndInfectiveReadyTime_ = 1 minutes;      // round timer at infective stage ready time\n', '    uint256 constant private rndDevelopmentStage_ = 3 minutes;       // round timer at development stage 30 minutes; \n', '    uint256 constant private rndDevelopmentReadyTime_ = 1 minutes;       // round timer at development stage ready time 1 hours;\n', '    uint256 constant private allKeys_ = 100 * (10 ** 18);   // all keys count\n', '    uint256 constant private allEths_ = 7500773437500000; // all eths count\n', '    uint256 constant private rndIncreaseTime_ = 3 minutes;       // increase time 3 hours\n', '    uint256 constant private developmentAwardPercent = 1;   // 0.1% reduction every 3 hours\n', '\n', '    mapping (uint256 => Round) public round_m;                  // (rndNo => Round)\n', '    mapping (uint256 => mapping (address => PlayerRound)) public playerRound_m;   // (rndNo => addr => PlayerRound)\n', '\n', '    address public owner;               // owner address\n', '    address public receiver = address(0);            // receive eth address\n', '    uint256 public ownerWithdraw = 0;   // how many eth has been withdraw by owner\n', '    bool public isStartGame = false;    // start game flag\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev prevents contracts from interacting\n', '     */\n', '    modifier onlyHuman() \n', '    {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev sets boundaries for incoming tx \n', '     */\n', '    modifier isWithinLimits(uint256 _eth) \n', '    {\n', '        require(_eth >= 1000000000, "pocket lint: not a valid currency");\n', '        require(_eth <= 100000000000000000000000, "no vitalik, no");\n', '        _;    \n', '    }\n', '\n', '    /**\n', '     * @dev only owner\n', '     */\n', '    modifier onlyOwner() \n', '    {\n', '        require(owner == msg.sender, "only owner can do it");\n', '        _;    \n', '    }\n', '    \n', '    /**\n', '     * @dev It must be human beings to call the function.\n', '     */\n', '    function isHuman(address _addr) private view returns (bool)\n', '    {\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        return _codeLength == 0;\n', '    }\n', '   \n', '   /**\n', '\t * @dev player infect a person at current round\n', '\t * \n', '\t */\n', '    function buyKeys(address _inveter) private\n', '    {\n', '        uint256 _eth = msg.value;\n', '        uint256 _now = now;\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _ethUse = msg.value;\n', '\n', '        // start next round?\n', '        if (_now > round_m[_rndNo].endTime)\n', '        {\n', '            require(round_m[_rndNo].endTime + rndDevelopmentReadyTime_ < _now, "we should wait some times");\n', '            \n', '            uint256 lastAwardEth = (round_m[_rndNo].eth.mul(14) / 100).sub(round_m[_rndNo].inveterAmount);\n', '            \n', '            if(round_m[_rndNo].totalInfective < round_m[_rndNo].lastInfective.length.sub(1))\n', '            {\n', '                uint256 nextPlayersAward = round_m[_rndNo].lastInfective.length.sub(1).sub(round_m[_rndNo].totalInfective);\n', '                uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '                _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '                if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                {\n', '                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(3)/100));\n', '                }\n', '                else\n', '                {\n', '                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(4)/100));\n', '                }\n', '            }\n', '            \n', '            _rndNo = _rndNo.add(1);\n', '            rndNo = _rndNo;\n', '            round_m[_rndNo].startTime = _now;\n', '            round_m[_rndNo].endTime = _now + rndInfectiveStage_;\n', '            round_m[_rndNo].totalInfective = 0;\n', '            round_m[_rndNo].lastRoundReward = lastAwardEth;\n', '        }\n', '\n', '        // infective or second stage\n', '        if (round_m[_rndNo].keys < allKeys_)\n', '        {\n', '            // infection stage\n', '            uint256 _keys = (round_m[_rndNo].eth).keysRec(_eth);\n', '            \n', '            if (_keys.add(round_m[_rndNo].keys) >= allKeys_)\n', '            {\n', '                _keys = allKeys_.sub(round_m[_rndNo].keys);\n', '\n', '                if (round_m[_rndNo].eth >= allEths_)\n', '                {\n', '                    _ethUse = 0;\n', '                } \n', '                else {\n', '                    _ethUse = (allEths_).sub(round_m[_rndNo].eth);\n', '                }\n', '\n', '                if (_eth > _ethUse)\n', '                {\n', '                    // refund\n', '                    msg.sender.transfer(_eth.sub(_ethUse));\n', '                } \n', '                else {\n', '                    // fix\n', '                    _ethUse = _eth;\n', '                }\n', '                // first stage is over, record current time\n', '                round_m[_rndNo].infectiveEndTime = _now.add(rndInfectiveReadyTime_);\n', '                round_m[_rndNo].endTime = _now.add(rndDevelopmentStage_).add(rndInfectiveReadyTime_);\n', '                round_m[_rndNo].infectLastPlayer = msg.sender;\n', '            }\n', '            else\n', '            {\n', '                require (_keys >= 1 * 10 ** 19, "at least 10 thound people");\n', '                round_m[_rndNo].endTime = _now + rndInfectiveStage_;\n', '            }\n', '            \n', '            round_m[_rndNo].leader = msg.sender;\n', '\n', '            // update playerRound\n', '            playerRound_m[_rndNo][msg.sender].keys = _keys.add(playerRound_m[_rndNo][msg.sender].keys);\n', '            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\n', '\n', '            // update round\n', '            round_m[_rndNo].keys = _keys.add(round_m[_rndNo].keys);\n', '            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\n', '\n', '            // update global variable\n', '            totalEth = _ethUse.add(totalEth);\n', '\n', '            // event\n', '            emit PlagueEvents.onInfectiveStage\n', '            (\n', '                msg.sender,\n', '                _rndNo,\n', '                _keys,\n', '                _ethUse,\n', '                _now,\n', '\t\t\t\t_inveter\n', '            );\n', '        } else {\n', '            // second stage\n', '            require(round_m[_rndNo].infectiveEndTime < _now, "The virus is being prepared...");\n', '            \n', '            // increase 0.05 Ether every 3 hours\n', '            _ethUse = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\n', '            \n', '            require(_eth >= _ethUse, "Ether amount is wrong");\n', '            \n', '            if(_eth > _ethUse)\n', '            {\n', '                msg.sender.transfer(_eth.sub(_ethUse));\n', '            }\n', '\n', '            round_m[_rndNo].endTime = _now + rndDevelopmentStage_;\n', '            round_m[_rndNo].leader = msg.sender;\n', '\n', '            // update playerRound\n', '            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\n', '\n', '            // update round\n', '            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\n', '\n', '            // update global variable\n', '            totalEth = _ethUse.add(totalEth);\n', '            \n', '            // update development award\n', '            uint256 _exAwardPercent = ((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(developmentAwardPercent).add(developmentAwardPercent);\n', '            if(_exAwardPercent >= 410)\n', '            {\n', '                _exAwardPercent = 410;\n', '            }\n', '            round_m[_rndNo].exAward = (_exAwardPercent.mul(_ethUse) / 1000).add(round_m[_rndNo].exAward);\n', '\n', '            // event\n', '            emit PlagueEvents.onDevelopmentStage\n', '            (\n', '                msg.sender,\n', '                _rndNo,\n', '                _ethUse,\n', '                _now,\n', '\t\t\t\t_inveter\n', '            );\n', '        }\n', '        \n', '        // caculate share inveter amount\n', '        if(_inveter != address(0) && isHuman(_inveter)) \n', '        {\n', '            playerRound_m[_rndNo][_inveter].getInveterAmount = playerRound_m[_rndNo][_inveter].getInveterAmount.add(_ethUse.mul(10) / 100);\n', '            round_m[_rndNo].inveterAmount = round_m[_rndNo].inveterAmount.add(_ethUse.mul(10) / 100);\n', '        }\n', '        \n', '        round_m[_rndNo].loseInfective[round_m[_rndNo].totalInfective % 4] = round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11];\n', '        round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11] = msg.sender;\n', '        \n', '        round_m[_rndNo].totalInfective = round_m[_rndNo].totalInfective.add(1);\n', '    }\n', '    \n', '\t/**\n', '\t * @dev recommend a player\n', '\t */\n', '    function buyKeyByAddr(address _inveter)\n', '        onlyHuman()\n', '        isWithinLimits(msg.value)\n', '        public\n', '        payable\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        buyKeys(_inveter);\n', '    }\n', '\n', '    /**\n', '     * @dev play\n', '     */\n', '    function()\n', '        onlyHuman()\n', '        isWithinLimits(msg.value)\n', '        public\n', '        payable\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        buyKeys(address(0));\n', '    }\n', '    \n', '    /**\n', '     * @dev Award by rndNo.\n', '     * 0x80ec35ff\n', '     * 0x80ec35ff0000000000000000000000000000000000000000000000000000000000000001\n', '     */\n', '    function awardByRndNo(uint256 _rndNo)\n', '        onlyHuman()\n', '        public\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        require(_rndNo <= rndNo, "You&#39;re running too fast");\n', '        \n', '        uint256 _ethOut = 0;\n', '        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\n', '        uint256 _getAward = 0;\n', '        \n', '        //withdraw award\n', '        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\n', '        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\n', '        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][msg.sender].keys));\n', '        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\n', '        \n', '        uint256 _inveterAmount = playerRound_m[_rndNo][msg.sender].getInveterAmount;\n', '        _totalWithdraw = _totalWithdraw.add(_inveterAmount);\n', '        uint256 _withdrawed = playerRound_m[_rndNo][msg.sender].withdraw;\n', '        if(_totalWithdraw > _withdrawed)\n', '        {\n', '            _ethOut = _ethOut.add(_totalWithdraw.sub(_withdrawed));\n', '            playerRound_m[_rndNo][msg.sender].withdraw = _totalWithdraw;\n', '        }\n', '        \n', '         //lastest infect player\n', '        if(msg.sender == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\n', '        {\n', '            _getAward = _getAward.add(_totalAward.mul(10)/100);\n', '        }\n', '        \n', '        if(now > round_m[_rndNo].endTime)\n', '        {\n', '            // finally award\n', '            if(round_m[_rndNo].leader == msg.sender)\n', '            {\n', '                _getAward = _getAward.add(_totalAward.mul(60)/100);\n', '            }\n', '            \n', '            //finally ten person award\n', '            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\n', '            {\n', '                if(round_m[_rndNo].lastInfective[i] == msg.sender && (round_m[_rndNo].totalInfective.sub(1) % 11) != i){\n', '                    if(round_m[_rndNo].infectiveAward_m[i])\n', '                        continue;\n', '                    if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                    {\n', '                        _getAward = _getAward.add(_totalAward.mul(3)/100);\n', '                    }\n', '                    else{\n', '                        _getAward = _getAward.add(_totalAward.mul(4)/100);\n', '                    }\n', '                        \n', '                    round_m[_rndNo].infectiveAward_m[i] = true;\n', '                }\n', '            }\n', '        }\n', '        _ethOut = _ethOut.add(_getAward.sub(playerRound_m[_rndNo][msg.sender].hasGetAwardAmount));\n', '        playerRound_m[_rndNo][msg.sender].hasGetAwardAmount = _getAward;\n', '        \n', '        if(_ethOut != 0)\n', '        {\n', '            msg.sender.transfer(_ethOut); \n', '        }\n', '        \n', '        // event\n', '        emit PlagueEvents.onAward\n', '        (\n', '            msg.sender,\n', '            _rndNo,\n', '            _ethOut,\n', '            now\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev Get player bonus data\n', '     * 0xd982466d\n', '     * 0xd982466d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000028f211f6c07d3b79e0aab886d56333e4027d4f59\n', '     * @return player&#39;s award\n', '     * @return player&#39;s can withdraw amount\n', '     * @return player&#39;s inveter amount\n', '     * @return player&#39;s has been withdraw\n', '     */\n', '    function getPlayerAwardByRndNo(uint256 _rndNo, address _playAddr)\n', '        view\n', '        public\n', '        returns (uint256, uint256, uint256, uint256)\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        require(_rndNo <= rndNo, "You&#39;re running too fast");\n', '        \n', '        uint256 _ethPlayerAward = 0;\n', '        \n', '        //withdraw award\n', '        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\n', '        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\n', '        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][_playAddr].keys));\n', '        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\n', '        \n', '        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\n', '        \n', '        //lastest infect player\n', '        if(_playAddr == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\n', '        {\n', '            _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(10)/100);\n', '        }\n', '        \n', '        if(now > round_m[_rndNo].endTime)\n', '        {\n', '            // finally award\n', '            if(round_m[_rndNo].leader == _playAddr)\n', '            {\n', '                _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(60)/100);\n', '            }\n', '            \n', '            //finally ten person award\n', '            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\n', '            {\n', '                if(round_m[_rndNo].lastInfective[i] == _playAddr && (round_m[_rndNo].totalInfective.sub(1) % 11) != i)\n', '                {\n', '                    if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                    {\n', '                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(3)/100);\n', '                    }\n', '                    else{\n', '                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(4)/100);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        \n', '        \n', '        return\n', '        (\n', '            _ethPlayerAward,\n', '            _totalWithdraw,\n', '            playerRound_m[_rndNo][_playAddr].getInveterAmount,\n', '            playerRound_m[_rndNo][_playAddr].hasGetAwardAmount + playerRound_m[_rndNo][_playAddr].withdraw\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev fee withdraw to receiver, everyone can do it.\n', '     * 0x6561e6ba\n', '     */\n', '    function feeWithdraw()\n', '        onlyHuman()\n', '        public \n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        require(receiver != address(0), "The receiver address has not been initialized.");\n', '        \n', '        uint256 _total = (totalEth.mul(5) / (100));\n', '        uint256 _withdrawed = ownerWithdraw;\n', '        require(_total > _withdrawed, "No need to withdraw");\n', '        ownerWithdraw = _total;\n', '        receiver.transfer(_total.sub(_withdrawed));\n', '    }\n', '    \n', '    /**\n', '     * @dev start game\n', '     */\n', '    function startGame()\n', '        onlyOwner()\n', '        public\n', '    {\n', '        round_m[1].startTime = now;\n', '        round_m[1].endTime = now + rndInfectiveStage_;\n', '        round_m[1].lastRoundReward = 0;\n', '        isStartGame = true;\n', '    }\n', '\n', '    /**\n', '     * @dev change owner.\n', '     */\n', '    function changeReceiver(address newReceiver)\n', '        onlyOwner()\n', '        public\n', '    {\n', '        receiver = newReceiver;\n', '    }\n', '\n', '    /**\n', '     * @dev returns all current round info needed for front end\n', '     * 0x747dff42\n', '     */\n', '    function getCurrentRoundInfo()\n', '        public \n', '        view \n', '        returns(uint256, uint256[2], uint256[3], address[2], uint256[6], address[11],address[4])\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _totalAwardAtRound = round_m[_rndNo].lastRoundReward.add(round_m[_rndNo].exAward).add(round_m[_rndNo].eth.mul(30) / 100);\n', '        \n', '        return (\n', '            _rndNo,\n', '            [round_m[_rndNo].eth, round_m[_rndNo].keys],\n', '            [round_m[_rndNo].startTime, round_m[_rndNo].endTime, round_m[_rndNo].infectiveEndTime],\n', '            [round_m[_rndNo].leader, round_m[_rndNo].infectLastPlayer],\n', '            [getBuyPrice(), round_m[_rndNo].lastRoundReward, _totalAwardAtRound, round_m[_rndNo].inveterAmount, round_m[_rndNo].totalInfective % 11, round_m[_rndNo].exAward],\n', '            round_m[_rndNo].lastInfective,\n', '            round_m[_rndNo].loseInfective\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev return the price buyer will pay for next 1 individual key during first stage.\n', '     * 0x018a25e8\n', '     * @return price for next key bought (in wei format)\n', '     */\n', '    function getBuyPrice()\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(isStartGame == true, "The game hasn&#39;t started yet.");\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _now = now;\n', '        \n', '        // start next round?\n', '        if (_now > round_m[_rndNo].endTime)\n', '        {\n', '            return (750007031250000);\n', '        }\n', '        if (round_m[_rndNo].keys < allKeys_)\n', '        {\n', '            return ((round_m[_rndNo].keys.add(10000000000000000000)).ethRec(10000000000000000000));\n', '        }\n', '        if(round_m[_rndNo].keys >= allKeys_ && \n', '            round_m[_rndNo].infectiveEndTime != 0 && \n', '            round_m[_rndNo].infectLastPlayer != address(0) &&\n', '            _now < round_m[_rndNo].infectiveEndTime)\n', '        {\n', '            return 5 * 10 ** 16;\n', '        }\n', '        if(round_m[_rndNo].keys >= allKeys_ && _now > round_m[_rndNo].infectiveEndTime)\n', '        {\n', '            // increase 0.05 Ether every 3 hours\n', '            uint256 currentPrice = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\n', '            return currentPrice;\n', '        }\n', '        //second stage\n', '        return (0);\n', '    }\n', '}\n', '\n', 'library KeysCalc {\n', '    using SafeMath for *;\n', '    /**\n', '     * @dev calculates number of keys received given X eth \n', '     * @param _curEth current amount of eth in contract \n', '     * @param _newEth eth being spent\n', '     * @return amount of ticket purchased\n', '     */\n', '    function keysRec(uint256 _curEth, uint256 _newEth)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n', '    }\n', '    \n', '    /**\n', '     * @dev calculates amount of eth received if you sold X keys \n', '     * @param _curKeys current amount of keys that exist \n', '     * @param _sellKeys amount of keys you wish to sell\n', '     * @return amount of eth received\n', '     */\n', '    function ethRec(uint256 _curKeys, uint256 _sellKeys)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n', '    }\n', '\n', '    /**\n', '     * @dev calculates how many keys would exist with given an amount of eth\n', '     * @param _eth eth "in contract"\n', '     * @return number of keys that would exist\n', '     */\n', '    function keys(uint256 _eth) \n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n', '    }\n', '    \n', '    /**\n', '     * @dev calculates how much eth would be in contract given a number of keys\n', '     * @param _keys number of keys "in contract" \n', '     * @return eth that would exists\n', '     */\n', '    function eth(uint256 _keys) \n', '        internal\n', '        pure\n', '        returns(uint256)  \n', '    {\n', '        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', 'contract PlagueEvents {\n', '\t\n', '\t//infective person\n', '    event onInfectiveStage\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 keys,\n', '        uint256 eth,\n', '        uint256 timeStamp,\n', '\t\taddress indexed inveter\n', '    );\n', '\n', '    // become leader during second stage\n', '    event onDevelopmentStage\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 eth,\n', '        uint256 timeStamp,\n', '\t\taddress indexed inveter\n', '    );\n', '\n', '    // award\n', '    event onAward\n', '    (\n', '        address indexed player,\n', '        uint256 indexed rndNo,\n', '        uint256 eth,\n', '        uint256 timeStamp\n', '    );\n', '}\n', '\n', 'contract Plague is PlagueEvents{\n', '    using SafeMath for *;\n', '    using KeysCalc for uint256;\n', '\n', '    struct Round {\n', '        uint256 eth;                // total eth\n', '        uint256 keys;               // total keys\n', '        uint256 startTime;          // end time\n', '        uint256 endTime;            // end time\n', '        uint256 infectiveEndTime;   // infective end time\n', '        address leader;             // leader\n', '        address infectLastPlayer;   // the player will award 10% eth\n', '        address [11] lastInfective;  // the lastest 11 infective\n', '        address [4] loseInfective;  // the lose infective\n', '        bool [11] infectiveAward_m; //\n', '        uint256 totalInfective;     // the count of this round\n', '        uint256 inveterAmount;      // remain inveter amount of this round\n', '        uint256 lastRoundReward;    // last round remain eth 10% + eth 4% - inveterAmount + last remain award\n', '        uint256 exAward;            // development award\n', '    }\n', '\n', '    struct PlayerRound {\n', '        uint256 eth;        // eth player has added to round\n', '        uint256 keys;       // keys\n', '        uint256 withdraw;   // how many eth has been withdraw\n', '        uint256 getInveterAmount; // inverter amount\n', '        uint256 hasGetAwardAmount;  // player has get award amount\n', '    }\n', '\n', '    uint256 public rndNo = 1;                                   // current round number\n', '    uint256 public totalEth = 0;                                // total eth in all round\n', '\n', '    uint256 constant private rndInfectiveStage_ = 10 minutes;          // round timer at iinfective stage12 hours;\n', '    uint256 constant private rndInfectiveReadyTime_ = 1 minutes;      // round timer at infective stage ready time\n', '    uint256 constant private rndDevelopmentStage_ = 3 minutes;       // round timer at development stage 30 minutes; \n', '    uint256 constant private rndDevelopmentReadyTime_ = 1 minutes;       // round timer at development stage ready time 1 hours;\n', '    uint256 constant private allKeys_ = 100 * (10 ** 18);   // all keys count\n', '    uint256 constant private allEths_ = 7500773437500000; // all eths count\n', '    uint256 constant private rndIncreaseTime_ = 3 minutes;       // increase time 3 hours\n', '    uint256 constant private developmentAwardPercent = 1;   // 0.1% reduction every 3 hours\n', '\n', '    mapping (uint256 => Round) public round_m;                  // (rndNo => Round)\n', '    mapping (uint256 => mapping (address => PlayerRound)) public playerRound_m;   // (rndNo => addr => PlayerRound)\n', '\n', '    address public owner;               // owner address\n', '    address public receiver = address(0);            // receive eth address\n', '    uint256 public ownerWithdraw = 0;   // how many eth has been withdraw by owner\n', '    bool public isStartGame = false;    // start game flag\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev prevents contracts from interacting\n', '     */\n', '    modifier onlyHuman() \n', '    {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev sets boundaries for incoming tx \n', '     */\n', '    modifier isWithinLimits(uint256 _eth) \n', '    {\n', '        require(_eth >= 1000000000, "pocket lint: not a valid currency");\n', '        require(_eth <= 100000000000000000000000, "no vitalik, no");\n', '        _;    \n', '    }\n', '\n', '    /**\n', '     * @dev only owner\n', '     */\n', '    modifier onlyOwner() \n', '    {\n', '        require(owner == msg.sender, "only owner can do it");\n', '        _;    \n', '    }\n', '    \n', '    /**\n', '     * @dev It must be human beings to call the function.\n', '     */\n', '    function isHuman(address _addr) private view returns (bool)\n', '    {\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        return _codeLength == 0;\n', '    }\n', '   \n', '   /**\n', '\t * @dev player infect a person at current round\n', '\t * \n', '\t */\n', '    function buyKeys(address _inveter) private\n', '    {\n', '        uint256 _eth = msg.value;\n', '        uint256 _now = now;\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _ethUse = msg.value;\n', '\n', '        // start next round?\n', '        if (_now > round_m[_rndNo].endTime)\n', '        {\n', '            require(round_m[_rndNo].endTime + rndDevelopmentReadyTime_ < _now, "we should wait some times");\n', '            \n', '            uint256 lastAwardEth = (round_m[_rndNo].eth.mul(14) / 100).sub(round_m[_rndNo].inveterAmount);\n', '            \n', '            if(round_m[_rndNo].totalInfective < round_m[_rndNo].lastInfective.length.sub(1))\n', '            {\n', '                uint256 nextPlayersAward = round_m[_rndNo].lastInfective.length.sub(1).sub(round_m[_rndNo].totalInfective);\n', '                uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '                _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '                if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                {\n', '                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(3)/100));\n', '                }\n', '                else\n', '                {\n', '                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(4)/100));\n', '                }\n', '            }\n', '            \n', '            _rndNo = _rndNo.add(1);\n', '            rndNo = _rndNo;\n', '            round_m[_rndNo].startTime = _now;\n', '            round_m[_rndNo].endTime = _now + rndInfectiveStage_;\n', '            round_m[_rndNo].totalInfective = 0;\n', '            round_m[_rndNo].lastRoundReward = lastAwardEth;\n', '        }\n', '\n', '        // infective or second stage\n', '        if (round_m[_rndNo].keys < allKeys_)\n', '        {\n', '            // infection stage\n', '            uint256 _keys = (round_m[_rndNo].eth).keysRec(_eth);\n', '            \n', '            if (_keys.add(round_m[_rndNo].keys) >= allKeys_)\n', '            {\n', '                _keys = allKeys_.sub(round_m[_rndNo].keys);\n', '\n', '                if (round_m[_rndNo].eth >= allEths_)\n', '                {\n', '                    _ethUse = 0;\n', '                } \n', '                else {\n', '                    _ethUse = (allEths_).sub(round_m[_rndNo].eth);\n', '                }\n', '\n', '                if (_eth > _ethUse)\n', '                {\n', '                    // refund\n', '                    msg.sender.transfer(_eth.sub(_ethUse));\n', '                } \n', '                else {\n', '                    // fix\n', '                    _ethUse = _eth;\n', '                }\n', '                // first stage is over, record current time\n', '                round_m[_rndNo].infectiveEndTime = _now.add(rndInfectiveReadyTime_);\n', '                round_m[_rndNo].endTime = _now.add(rndDevelopmentStage_).add(rndInfectiveReadyTime_);\n', '                round_m[_rndNo].infectLastPlayer = msg.sender;\n', '            }\n', '            else\n', '            {\n', '                require (_keys >= 1 * 10 ** 19, "at least 10 thound people");\n', '                round_m[_rndNo].endTime = _now + rndInfectiveStage_;\n', '            }\n', '            \n', '            round_m[_rndNo].leader = msg.sender;\n', '\n', '            // update playerRound\n', '            playerRound_m[_rndNo][msg.sender].keys = _keys.add(playerRound_m[_rndNo][msg.sender].keys);\n', '            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\n', '\n', '            // update round\n', '            round_m[_rndNo].keys = _keys.add(round_m[_rndNo].keys);\n', '            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\n', '\n', '            // update global variable\n', '            totalEth = _ethUse.add(totalEth);\n', '\n', '            // event\n', '            emit PlagueEvents.onInfectiveStage\n', '            (\n', '                msg.sender,\n', '                _rndNo,\n', '                _keys,\n', '                _ethUse,\n', '                _now,\n', '\t\t\t\t_inveter\n', '            );\n', '        } else {\n', '            // second stage\n', '            require(round_m[_rndNo].infectiveEndTime < _now, "The virus is being prepared...");\n', '            \n', '            // increase 0.05 Ether every 3 hours\n', '            _ethUse = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\n', '            \n', '            require(_eth >= _ethUse, "Ether amount is wrong");\n', '            \n', '            if(_eth > _ethUse)\n', '            {\n', '                msg.sender.transfer(_eth.sub(_ethUse));\n', '            }\n', '\n', '            round_m[_rndNo].endTime = _now + rndDevelopmentStage_;\n', '            round_m[_rndNo].leader = msg.sender;\n', '\n', '            // update playerRound\n', '            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\n', '\n', '            // update round\n', '            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\n', '\n', '            // update global variable\n', '            totalEth = _ethUse.add(totalEth);\n', '            \n', '            // update development award\n', '            uint256 _exAwardPercent = ((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(developmentAwardPercent).add(developmentAwardPercent);\n', '            if(_exAwardPercent >= 410)\n', '            {\n', '                _exAwardPercent = 410;\n', '            }\n', '            round_m[_rndNo].exAward = (_exAwardPercent.mul(_ethUse) / 1000).add(round_m[_rndNo].exAward);\n', '\n', '            // event\n', '            emit PlagueEvents.onDevelopmentStage\n', '            (\n', '                msg.sender,\n', '                _rndNo,\n', '                _ethUse,\n', '                _now,\n', '\t\t\t\t_inveter\n', '            );\n', '        }\n', '        \n', '        // caculate share inveter amount\n', '        if(_inveter != address(0) && isHuman(_inveter)) \n', '        {\n', '            playerRound_m[_rndNo][_inveter].getInveterAmount = playerRound_m[_rndNo][_inveter].getInveterAmount.add(_ethUse.mul(10) / 100);\n', '            round_m[_rndNo].inveterAmount = round_m[_rndNo].inveterAmount.add(_ethUse.mul(10) / 100);\n', '        }\n', '        \n', '        round_m[_rndNo].loseInfective[round_m[_rndNo].totalInfective % 4] = round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11];\n', '        round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11] = msg.sender;\n', '        \n', '        round_m[_rndNo].totalInfective = round_m[_rndNo].totalInfective.add(1);\n', '    }\n', '    \n', '\t/**\n', '\t * @dev recommend a player\n', '\t */\n', '    function buyKeyByAddr(address _inveter)\n', '        onlyHuman()\n', '        isWithinLimits(msg.value)\n', '        public\n', '        payable\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        buyKeys(_inveter);\n', '    }\n', '\n', '    /**\n', '     * @dev play\n', '     */\n', '    function()\n', '        onlyHuman()\n', '        isWithinLimits(msg.value)\n', '        public\n', '        payable\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        buyKeys(address(0));\n', '    }\n', '    \n', '    /**\n', '     * @dev Award by rndNo.\n', '     * 0x80ec35ff\n', '     * 0x80ec35ff0000000000000000000000000000000000000000000000000000000000000001\n', '     */\n', '    function awardByRndNo(uint256 _rndNo)\n', '        onlyHuman()\n', '        public\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        require(_rndNo <= rndNo, "You\'re running too fast");\n', '        \n', '        uint256 _ethOut = 0;\n', '        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\n', '        uint256 _getAward = 0;\n', '        \n', '        //withdraw award\n', '        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\n', '        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\n', '        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][msg.sender].keys));\n', '        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\n', '        \n', '        uint256 _inveterAmount = playerRound_m[_rndNo][msg.sender].getInveterAmount;\n', '        _totalWithdraw = _totalWithdraw.add(_inveterAmount);\n', '        uint256 _withdrawed = playerRound_m[_rndNo][msg.sender].withdraw;\n', '        if(_totalWithdraw > _withdrawed)\n', '        {\n', '            _ethOut = _ethOut.add(_totalWithdraw.sub(_withdrawed));\n', '            playerRound_m[_rndNo][msg.sender].withdraw = _totalWithdraw;\n', '        }\n', '        \n', '         //lastest infect player\n', '        if(msg.sender == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\n', '        {\n', '            _getAward = _getAward.add(_totalAward.mul(10)/100);\n', '        }\n', '        \n', '        if(now > round_m[_rndNo].endTime)\n', '        {\n', '            // finally award\n', '            if(round_m[_rndNo].leader == msg.sender)\n', '            {\n', '                _getAward = _getAward.add(_totalAward.mul(60)/100);\n', '            }\n', '            \n', '            //finally ten person award\n', '            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\n', '            {\n', '                if(round_m[_rndNo].lastInfective[i] == msg.sender && (round_m[_rndNo].totalInfective.sub(1) % 11) != i){\n', '                    if(round_m[_rndNo].infectiveAward_m[i])\n', '                        continue;\n', '                    if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                    {\n', '                        _getAward = _getAward.add(_totalAward.mul(3)/100);\n', '                    }\n', '                    else{\n', '                        _getAward = _getAward.add(_totalAward.mul(4)/100);\n', '                    }\n', '                        \n', '                    round_m[_rndNo].infectiveAward_m[i] = true;\n', '                }\n', '            }\n', '        }\n', '        _ethOut = _ethOut.add(_getAward.sub(playerRound_m[_rndNo][msg.sender].hasGetAwardAmount));\n', '        playerRound_m[_rndNo][msg.sender].hasGetAwardAmount = _getAward;\n', '        \n', '        if(_ethOut != 0)\n', '        {\n', '            msg.sender.transfer(_ethOut); \n', '        }\n', '        \n', '        // event\n', '        emit PlagueEvents.onAward\n', '        (\n', '            msg.sender,\n', '            _rndNo,\n', '            _ethOut,\n', '            now\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev Get player bonus data\n', '     * 0xd982466d\n', '     * 0xd982466d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000028f211f6c07d3b79e0aab886d56333e4027d4f59\n', "     * @return player's award\n", "     * @return player's can withdraw amount\n", "     * @return player's inveter amount\n", "     * @return player's has been withdraw\n", '     */\n', '    function getPlayerAwardByRndNo(uint256 _rndNo, address _playAddr)\n', '        view\n', '        public\n', '        returns (uint256, uint256, uint256, uint256)\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        require(_rndNo <= rndNo, "You\'re running too fast");\n', '        \n', '        uint256 _ethPlayerAward = 0;\n', '        \n', '        //withdraw award\n', '        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\n', '        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\n', '        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][_playAddr].keys));\n', '        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\n', '        \n', '        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\n', '        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\n', '        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\n', '        \n', '        //lastest infect player\n', '        if(_playAddr == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\n', '        {\n', '            _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(10)/100);\n', '        }\n', '        \n', '        if(now > round_m[_rndNo].endTime)\n', '        {\n', '            // finally award\n', '            if(round_m[_rndNo].leader == _playAddr)\n', '            {\n', '                _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(60)/100);\n', '            }\n', '            \n', '            //finally ten person award\n', '            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\n', '            {\n', '                if(round_m[_rndNo].lastInfective[i] == _playAddr && (round_m[_rndNo].totalInfective.sub(1) % 11) != i)\n', '                {\n', '                    if(round_m[_rndNo].infectLastPlayer != address(0))\n', '                    {\n', '                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(3)/100);\n', '                    }\n', '                    else{\n', '                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(4)/100);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        \n', '        \n', '        return\n', '        (\n', '            _ethPlayerAward,\n', '            _totalWithdraw,\n', '            playerRound_m[_rndNo][_playAddr].getInveterAmount,\n', '            playerRound_m[_rndNo][_playAddr].hasGetAwardAmount + playerRound_m[_rndNo][_playAddr].withdraw\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev fee withdraw to receiver, everyone can do it.\n', '     * 0x6561e6ba\n', '     */\n', '    function feeWithdraw()\n', '        onlyHuman()\n', '        public \n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        require(receiver != address(0), "The receiver address has not been initialized.");\n', '        \n', '        uint256 _total = (totalEth.mul(5) / (100));\n', '        uint256 _withdrawed = ownerWithdraw;\n', '        require(_total > _withdrawed, "No need to withdraw");\n', '        ownerWithdraw = _total;\n', '        receiver.transfer(_total.sub(_withdrawed));\n', '    }\n', '    \n', '    /**\n', '     * @dev start game\n', '     */\n', '    function startGame()\n', '        onlyOwner()\n', '        public\n', '    {\n', '        round_m[1].startTime = now;\n', '        round_m[1].endTime = now + rndInfectiveStage_;\n', '        round_m[1].lastRoundReward = 0;\n', '        isStartGame = true;\n', '    }\n', '\n', '    /**\n', '     * @dev change owner.\n', '     */\n', '    function changeReceiver(address newReceiver)\n', '        onlyOwner()\n', '        public\n', '    {\n', '        receiver = newReceiver;\n', '    }\n', '\n', '    /**\n', '     * @dev returns all current round info needed for front end\n', '     * 0x747dff42\n', '     */\n', '    function getCurrentRoundInfo()\n', '        public \n', '        view \n', '        returns(uint256, uint256[2], uint256[3], address[2], uint256[6], address[11],address[4])\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _totalAwardAtRound = round_m[_rndNo].lastRoundReward.add(round_m[_rndNo].exAward).add(round_m[_rndNo].eth.mul(30) / 100);\n', '        \n', '        return (\n', '            _rndNo,\n', '            [round_m[_rndNo].eth, round_m[_rndNo].keys],\n', '            [round_m[_rndNo].startTime, round_m[_rndNo].endTime, round_m[_rndNo].infectiveEndTime],\n', '            [round_m[_rndNo].leader, round_m[_rndNo].infectLastPlayer],\n', '            [getBuyPrice(), round_m[_rndNo].lastRoundReward, _totalAwardAtRound, round_m[_rndNo].inveterAmount, round_m[_rndNo].totalInfective % 11, round_m[_rndNo].exAward],\n', '            round_m[_rndNo].lastInfective,\n', '            round_m[_rndNo].loseInfective\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev return the price buyer will pay for next 1 individual key during first stage.\n', '     * 0x018a25e8\n', '     * @return price for next key bought (in wei format)\n', '     */\n', '    function getBuyPrice()\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(isStartGame == true, "The game hasn\'t started yet.");\n', '        uint256 _rndNo = rndNo;\n', '        uint256 _now = now;\n', '        \n', '        // start next round?\n', '        if (_now > round_m[_rndNo].endTime)\n', '        {\n', '            return (750007031250000);\n', '        }\n', '        if (round_m[_rndNo].keys < allKeys_)\n', '        {\n', '            return ((round_m[_rndNo].keys.add(10000000000000000000)).ethRec(10000000000000000000));\n', '        }\n', '        if(round_m[_rndNo].keys >= allKeys_ && \n', '            round_m[_rndNo].infectiveEndTime != 0 && \n', '            round_m[_rndNo].infectLastPlayer != address(0) &&\n', '            _now < round_m[_rndNo].infectiveEndTime)\n', '        {\n', '            return 5 * 10 ** 16;\n', '        }\n', '        if(round_m[_rndNo].keys >= allKeys_ && _now > round_m[_rndNo].infectiveEndTime)\n', '        {\n', '            // increase 0.05 Ether every 3 hours\n', '            uint256 currentPrice = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\n', '            return currentPrice;\n', '        }\n', '        //second stage\n', '        return (0);\n', '    }\n', '}\n', '\n', 'library KeysCalc {\n', '    using SafeMath for *;\n', '    /**\n', '     * @dev calculates number of keys received given X eth \n', '     * @param _curEth current amount of eth in contract \n', '     * @param _newEth eth being spent\n', '     * @return amount of ticket purchased\n', '     */\n', '    function keysRec(uint256 _curEth, uint256 _newEth)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n', '    }\n', '    \n', '    /**\n', '     * @dev calculates amount of eth received if you sold X keys \n', '     * @param _curKeys current amount of keys that exist \n', '     * @param _sellKeys amount of keys you wish to sell\n', '     * @return amount of eth received\n', '     */\n', '    function ethRec(uint256 _curKeys, uint256 _sellKeys)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n', '    }\n', '\n', '    /**\n', '     * @dev calculates how many keys would exist with given an amount of eth\n', '     * @param _eth eth "in contract"\n', '     * @return number of keys that would exist\n', '     */\n', '    function keys(uint256 _eth) \n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n', '    }\n', '    \n', '    /**\n', '     * @dev calculates how much eth would be in contract given a number of keys\n', '     * @param _keys number of keys "in contract" \n', '     * @return eth that would exists\n', '     */\n', '    function eth(uint256 _keys) \n', '        internal\n', '        pure\n', '        returns(uint256)  \n', '    {\n', '        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n', '    }\n', '}']
