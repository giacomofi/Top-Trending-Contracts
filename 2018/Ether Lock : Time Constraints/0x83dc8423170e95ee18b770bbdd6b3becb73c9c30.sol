['contract SafeMath {\n', '\t  function safeMul(uint a, uint b) internal returns (uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t  }\n', '\t  function safeSub(uint a, uint b) internal returns (uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t  }\n', '\t  function safeAdd(uint a, uint b) internal returns (uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c>=a && c>=b);\n', '\t\treturn c;\n', '\t  }\n', '\t  // mitigate short address attack\n', '\t  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '\t  // TODO: doublecheck implication of >= compared to ==\n', '\t  modifier onlyPayloadSize(uint numWords) {\n', '\t\t assert(msg.data.length >= numWords * 32 + 4);\n', '\t\t _;\n', '\t  }\n', '\t}\n', '\n', '\tcontract Token { // ERC20 standard\n', '\t\tfunction balanceOf(address _owner) public  view returns (uint256 balance);\n', '\t\tfunction transfer(address _to, uint256 _value) public  returns (bool success);\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n', '\t\tfunction approve(address _spender, uint256 _value)  returns (bool success);\n', '\t\tfunction allowance(address _owner, address _spender) public  view returns (uint256 remaining);\n', '\t\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\t\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\t}\n', '\n', '\tcontract StandardToken is Token, SafeMath {\n', '\t\tuint256 public totalSupply;\n', '\t\t// TODO: update tests to expect throw\n', '\t\tfunction transfer(address _to, uint256 _value) public  onlyPayloadSize(2) returns (bool success) {\n', '\t\t\trequire(_to != address(0));\n', '\t\t\trequire(balances[msg.sender] >= _value && _value > 0);\n', '\t\t\tbalances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\t\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\t\t\tTransfer(msg.sender, _to, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\t// TODO: update tests to expect throw\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\n', '\t\t\trequire(_to != address(0));\n', '\t\t\trequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '\t\t\tbalances[_from] = safeSub(balances[_from], _value);\n', '\t\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\t\t\tallowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '\t\t\tTransfer(_from, _to, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction balanceOf(address _owner) view returns (uint256 balance) {\n', '\t\t\treturn balances[_owner];\n', '\t\t}\n', '\t\t// To change the approve amount you first have to reduce the addresses&#39;\n', '\t\t//  allowance to zero by calling &#39;approve(_spender, 0)&#39; if it is not\n', '\t\t//  already 0 to mitigate the race condition described here:\n', '\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t\tfunction approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '\t\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\t\t\tallowed[msg.sender][_spender] = _value;\n', '\t\t\tApproval(msg.sender, _spender, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success) {\n', '\t\t\trequire(allowed[msg.sender][_spender] == _oldValue);\n', '\t\t\tallowed[msg.sender][_spender] = _newValue;\n', '\t\t\tApproval(msg.sender, _spender, _newValue);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction allowance(address _owner, address _spender) public  view returns (uint256 remaining) {\n', '\t\t  return allowed[_owner][_spender];\n', '\t\t}\n', '\t\tmapping (address => uint256) public  balances;\n', '\t\tmapping (address => mapping (address => uint256)) public  allowed;\n', '\t}\n', '\n', '\tcontract STC is StandardToken {\n', '\t\t// FIELDS\n', '\t\tstring public name = "SmarterThanCrypto";\n', '\t\tstring public symbol = "STC";\n', '\t\tuint256 public decimals = 18;\n', '\t\tstring public version = "10.0";\n', '\t\tuint256 public tokenCap = 100000000 * 10**18;\n', '\t\t// crowdsale parameters\n', '\t\tuint256 public fundingStartTime;\n', '\t\tuint256 public fundingEndTime;\n', '\t\t// vesting fields\n', '\t\taddress public vestingContract;\n', '\t\tbool private vestingSet = false;\n', '\t\t// root control\n', '\t\taddress public fundWallet;\n', '\t\t// control of liquidity and limited control of updatePrice\n', '\t\taddress public controlWallet;\n', '\t\t// time to wait between controlWallet price updates\n', '\t\tuint256 public waitTime = 1 hours;\n', '\t\t// fundWallet controlled state variables\n', '\t\t// halted: halt buying due to emergency, tradeable: signal that assets have been acquired\n', '\t\tbool public halted = false;\n', '\t\tbool public tradeable = false;\n', '\t\t// -- totalSupply defined in StandardToken\n', '\t\t// -- mapping to token balances done in StandardToken\n', '\t\tuint256 public previousUpdateTime = 0;\n', '\t\tPrice public currentPrice;\n', '\t\tuint256 public minAmount = 0.04 ether;\n', '\t\tuint256 public OfferTime = 2592000;\n', '\t \n', '\n', '\t\t// map participant address to a withdrawal request\n', '\t\tmapping (address => Withdrawal) public withdrawals;\n', '\t\t// maps previousUpdateTime to the next price\n', '\t\tmapping (uint256 => Price) public prices;\n', '\t\t// maps addresses\n', '\t\tmapping (address => bool) public whitelist;\n', '\t\t// TYPES\n', '\t\tstruct Price { // tokensPerEth\n', '\t\t\tuint256 numerator;\n', '\t\t\tuint256 denominator;\n', '\t\t}\n', '\t\tstruct Withdrawal {\n', '\t\t\tuint256 tokens;\n', '\t\t\tuint256 time; // time for each withdrawal is set to the previousUpdateTime\n', '\t\t}\n', '\t\t// EVENTS\n', '\t\tevent Buy(address indexed participant, address indexed beneficiary, uint256 ethValue, uint256 amountTokens);\n', '\t\tevent AllocatePresale(address indexed participant, uint256 amountTokens);\n', '\t\tevent Whitelist(address indexed participant);\n', '\t\tevent PriceUpdate(uint256 numerator, uint256 denominator);\n', '\t\tevent AddLiquidity(uint256 ethAmount);\n', '\t\tevent RemoveLiquidity(uint256 ethAmount);\n', '\t\tevent WithdrawRequest(address indexed participant, uint256 amountTokens);\n', '\t\tevent Withdraw(address indexed participant, uint256 amountTokens, uint256 etherAmount);\n', '\t\t// MODIFIERS\n', '\t\tmodifier isTradeable { // exempt vestingContract and fundWallet to allow dev allocations\n', '\t\t\trequire(tradeable || msg.sender == fundWallet || msg.sender == vestingContract);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyWhitelist {\n', '\t\t\trequire(whitelist[msg.sender]);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyFundWallet {\n', '\t\t\trequire(msg.sender == fundWallet);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyManagingWallets {\n', '\t\t\trequire(msg.sender == controlWallet || msg.sender == fundWallet);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier only_if_controlWallet {\n', '\t\t\tif (msg.sender == controlWallet) _;\n', '\t\t}\n', '\t\tmodifier require_waited {\n', '\t\t\trequire(safeSub(now, waitTime) >= previousUpdateTime);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier only_if_increase (uint256 newNumerator) {\n', '\t\t\tif (newNumerator > currentPrice.numerator) _;\n', '\t\t}\n', '\t\t// CONSTRUCTOR\n', '\t\tfunction STC(address controlWalletInput, uint256 priceNumeratorInput, uint256 startTimeInput, uint256 endTimeInput) public  {\n', '\t\t\trequire(controlWalletInput != address(0));\n', '\t\t\trequire(priceNumeratorInput > 0);\n', '\t\t\trequire(endTimeInput > startTimeInput);\n', '\t\t\tfundWallet = msg.sender;\n', '\t\t\tcontrolWallet = controlWalletInput;\n', '\t\t\twhitelist[fundWallet] = true;\n', '\t\t\twhitelist[controlWallet] = true;\n', '\t\t\tcurrentPrice = Price(priceNumeratorInput, 10000); // 1 token = 1 usd at ICO start\n', '\t\t\tfundingStartTime = startTimeInput;\n', '\t\t\tfundingEndTime = endTimeInput;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t}\t\t\t\n', '\t\t// METHODS\t\n', '\t\tfunction setOfferTime(uint256 newOfferTime) external onlyFundWallet {\n', '\t\t\trequire(newOfferTime>0);\n', '\t\t\trequire(newOfferTime<safeSub(fundingEndTime,fundingStartTime));\n', '\t\t\tOfferTime = newOfferTime;\n', '\t\t}\t\t\n', '\t\tfunction setVestingContract(address vestingContractInput) external onlyFundWallet {\n', '\t\t\trequire(vestingContractInput != address(0));\n', '\t\t\tvestingContract = vestingContractInput;\n', '\t\t\twhitelist[vestingContract] = true;\n', '\t\t\tvestingSet = true;\n', '\t\t}\n', '\t\t// allows controlWallet to update the price within a time contstraint, allows fundWallet complete control\n', '\t\tfunction updatePrice(uint256 newNumerator) external onlyManagingWallets {\n', '\t\t\trequire(newNumerator > 0);\n', '\t\t\trequire_limited_change(newNumerator);\n', '\t\t\t// either controlWallet command is compliant or transaction came from fundWallet\n', '\t\t\tcurrentPrice.numerator = newNumerator;\n', '\t\t\t// maps time to new Price (if not during ICO)\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(newNumerator, currentPrice.denominator);\n', '\t\t}\n', '\t\tfunction require_limited_change (uint256 newNumerator)\n', '\t\t\tprivate\n', '\t\t\tonly_if_controlWallet\n', '\t\t\trequire_waited\n', '\t\t\tonly_if_increase(newNumerator)\n', '\t\t{\n', '\t\t\tuint256 percentage_diff = 0;\n', '\t\t\tpercentage_diff = safeMul(newNumerator, 10000) / currentPrice.numerator;\n', '\t\t\tpercentage_diff = safeSub(percentage_diff, 10000);\n', '\t\t\t// controlWallet can only increase price by max 20% and only every waitTime\n', '\t\t\t//require(percentage_diff <= 20);\n', '\t\t}\n', '\t\tfunction updatePriceDenominator(uint256 newDenominator) external onlyManagingWallets {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(newDenominator > 0);\n', '\t\t\tcurrentPrice.denominator = newDenominator;\n', '\t\t\t// maps time to new Price\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(currentPrice.numerator, newDenominator);\n', '\t\t}\n', '\t\tfunction updatePriceAndDenominator(uint256 newNumerator, uint256 newDenominator) external onlyManagingWallets {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(newDenominator > 0);\n', '\t\t\trequire(newNumerator > 0);\n', '\t\t\trequire(safeSub(now, waitTime) >= previousUpdateTime);\n', '\t\t\tcurrentPrice.denominator = newDenominator;\n', '\t\t\tcurrentPrice.numerator = newNumerator;\n', '\t\t\t// maps time to new Price\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(currentPrice.numerator, newDenominator);\n', '\t\t}\n', '\t\tfunction allocateTokens(address participant, uint256 amountTokens) private {\n', '\t\t\trequire(vestingSet);\n', '\t\t\t// 13% of total allocated for PR, Marketing, Team, Advisors\n', '\t\t\tuint256 developmentAllocation = safeMul(amountTokens, 14942528735632200) / 100000000000000000;\n', '\t\t\t// check that token cap is not exceeded\n', '\t\t\tuint256 newTokens = safeAdd(amountTokens, developmentAllocation);\n', '\t\t\trequire(safeAdd(totalSupply, newTokens) <= tokenCap);\n', '\t\t\t// increase token supply, assign tokens to participant\n', '\t\t\ttotalSupply = safeAdd(totalSupply, newTokens);\n', '\t\t\tbalances[participant] = safeAdd(balances[participant], amountTokens);\n', '\t\t\tbalances[vestingContract] = safeAdd(balances[vestingContract], developmentAllocation);\n', '\t\t}\n', '\t\tfunction allocatePresaleTokens(address participant, uint amountTokens) external onlyManagingWallets {\n', '\t\t\trequire(!halted);\n', '\t\t\trequire(participant != address(0));\n', '\t\t\twhitelist[participant] = true; // automatically whitelist accepted presale\n', '\t\t\tallocateTokens(participant, amountTokens);\n', '\t\t\tWhitelist(participant);\n', '\t\t\tAllocatePresale(participant, amountTokens);\n', '\t\t}\n', '\t\tfunction verifyParticipant(address participant) external onlyManagingWallets {\n', '\t\t\twhitelist[participant] = true;\n', '\t\t\tWhitelist(participant);\n', '\t\t}\n', '\t\tfunction buy() external payable {\n', '\t\t\tbuyTo(msg.sender);\n', '\t\t}\n', '\t\tfunction buyTo(address participant) public payable onlyWhitelist {\n', '\t\t\trequire(!halted);\n', '\t\t\trequire(participant != address(0));\n', '\t\t\trequire(msg.value >= minAmount);\n', '\t\t\trequire(now >= fundingStartTime);\n', '\t\t\tuint256 icoDenominator = icoDenominatorPrice();\n', '\t\t\tuint256 tokensToBuy = safeMul(msg.value, currentPrice.numerator) / icoDenominator;\n', '\t\t\tallocateTokens(participant, tokensToBuy);\n', '\t\t\t// send ether to fundWallet\n', '\t\t\tfundWallet.transfer(msg.value);\n', '\t\t\tBuy(msg.sender, participant, msg.value, tokensToBuy);\n', '\t\t}\n', '\t\t// time based on blocknumbers, assuming a blocktime of 30s\n', '\t\tfunction icoDenominatorPrice() public view returns (uint256) {\n', '\t\t\tuint256 icoDuration = safeSub(now, fundingStartTime);\n', '\t\t\tuint256 denominator;\n', '\t\t\tif (icoDuration < 172800) { // time in sec = (48*60*60) = 172800\n', '\t\t\t   denominator = safeMul(currentPrice.denominator, 95) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t} else if (icoDuration < OfferTime ) { // time in sec = (((4*7)+2)*24*60*60) = 2592000\n', '\t\t\t\tdenominator = safeMul(currentPrice.denominator, 100) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t} else if (now > fundingEndTime ) {\n', '\t\t\t   denominator = safeMul(currentPrice.denominator, 100) / 100;\n', '\t\t\t   return denominator;   \n', '\t\t\t} else {\n', '\t\t\t\tdenominator = safeMul(currentPrice.denominator, 105) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t}\n', '\t\t}\n', '\t\tfunction requestWithdrawal(uint256 amountTokensToWithdraw) external isTradeable onlyWhitelist {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\taddress participant = msg.sender;\n', '\t\t\trequire(balanceOf(participant) >= amountTokensToWithdraw);\n', '\t\t\trequire(withdrawals[participant].tokens == 0); // participant cannot have outstanding withdrawals\n', '\t\t\tbalances[participant] = safeSub(balances[participant], amountTokensToWithdraw);\n', '\t\t\twithdrawals[participant] = Withdrawal({tokens: amountTokensToWithdraw, time: previousUpdateTime});\n', '\t\t\tWithdrawRequest(participant, amountTokensToWithdraw);\n', '\t\t}\n', '\t\tfunction withdraw() external {\n', '\t\t\taddress participant = msg.sender;\n', '\t\t\tuint256 tokens = withdrawals[participant].tokens;\n', '\t\t\trequire(tokens > 0); // participant must have requested a withdrawal\n', '\t\t\tuint256 requestTime = withdrawals[participant].time;\n', '\t\t\t// obtain the next price that was set after the request\n', '\t\t\tPrice price = prices[requestTime];\n', '\t\t\trequire(price.numerator > 0); // price must have been set\n', '\t\t\tuint256 withdrawValue  = safeMul(tokens, price.denominator) / price.numerator;\n', '\t\t\t// if contract ethbal > then send + transfer tokens to fundWallet, otherwise give tokens back\n', '\t\t\twithdrawals[participant].tokens = 0;\n', '\t\t\tif (this.balance >= withdrawValue)\n', '\t\t\t\tenact_withdrawal_greater_equal(participant, withdrawValue, tokens);\n', '\t\t\telse\n', '\t\t\t\tenact_withdrawal_less(participant, withdrawValue, tokens);\n', '\t\t}\n', '\t\tfunction enact_withdrawal_greater_equal(address participant, uint256 withdrawValue, uint256 tokens)\n', '\t\t\tprivate\n', '\t\t{\n', '\t\t\tassert(this.balance >= withdrawValue);\n', '\t\t\tbalances[fundWallet] = safeAdd(balances[fundWallet], tokens);\n', '\t\t\tparticipant.transfer(withdrawValue);\n', '\t\t\tWithdraw(participant, tokens, withdrawValue);\n', '\t\t}\n', '\t\tfunction enact_withdrawal_less(address participant, uint256 withdrawValue, uint256 tokens)\n', '\t\t\tprivate\n', '\t\t{\n', '\t\t\tassert(this.balance < withdrawValue);\n', '\t\t\tbalances[participant] = safeAdd(balances[participant], tokens);\n', '\t\t\tWithdraw(participant, tokens, 0); // indicate a failed withdrawal\n', '\t\t}\n', '\t\tfunction checkWithdrawValue(uint256 amountTokensToWithdraw) public  view returns (uint256 etherValue) {\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\trequire(balanceOf(msg.sender) >= amountTokensToWithdraw);\n', '\t\t\tuint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\n', '\t\t\trequire(this.balance >= withdrawValue);\n', '\t\t\treturn withdrawValue;\n', '\t\t}\n', '\t\tfunction checkWithdrawValueForAddress(address participant,uint256 amountTokensToWithdraw) public  view returns (uint256 etherValue) {\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\trequire(balanceOf(participant) >= amountTokensToWithdraw);\n', '\t\t\tuint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\n', '\t\t\treturn withdrawValue;\n', '\t\t}\n', '\t\t// allow fundWallet or controlWallet to add ether to contract\n', '\t\tfunction addLiquidity() external onlyManagingWallets payable {\n', '\t\t\trequire(msg.value > 0);\n', '\t\t\tAddLiquidity(msg.value);\n', '\t\t}\n', '\t\t// allow fundWallet to remove ether from contract\n', '\t\tfunction removeLiquidity(uint256 amount) external onlyManagingWallets {\n', '\t\t\trequire(amount <= this.balance);\n', '\t\t\tfundWallet.transfer(amount);\n', '\t\t\tRemoveLiquidity(amount);\n', '\t\t}\n', '\t\tfunction changeFundWallet(address newFundWallet) external onlyFundWallet {\n', '\t\t\trequire(newFundWallet != address(0));\n', '\t\t\tfundWallet = newFundWallet;\n', '\t\t}\n', '\t\tfunction changeControlWallet(address newControlWallet) external onlyFundWallet {\n', '\t\t\trequire(newControlWallet != address(0));\n', '\t\t\tcontrolWallet = newControlWallet;\n', '\t\t}\n', '\t\tfunction changeWaitTime(uint256 newWaitTime) external onlyFundWallet {\n', '\t\t\twaitTime = newWaitTime;\n', '\t\t}\n', '\t\tfunction updatefundingStartTime(uint256 newfundingStartTime) external onlyFundWallet {\n', '\t\t   // require(now < fundingStartTime);\n', '\t\t   // require(now < newfundingStartTime);\n', '\t\t\tfundingStartTime = newfundingStartTime;\n', '\t\t}\n', '\t\tfunction updatefundingEndTime(uint256 newfundingEndTime) external onlyFundWallet {\n', '\t\t  //  require(now < fundingEndTime);\n', '\t\t  //  require(now < newfundingEndTime);\n', '\t\t\tfundingEndTime = newfundingEndTime;\n', '\t\t}\n', '\t\tfunction halt() external onlyFundWallet {\n', '\t\t\thalted = true;\n', '\t\t}\n', '\t\tfunction unhalt() external onlyFundWallet {\n', '\t\t\thalted = false;\n', '\t\t}\n', '\t\tfunction enableTrading() external onlyFundWallet {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\ttradeable = true;\n', '\t\t}\n', '\t\t// fallback function\n', '\t\tfunction() payable {\n', '\t\t\trequire(tx.origin == msg.sender);\n', '\t\t\tbuyTo(msg.sender);\n', '\t\t}\n', '\t\tfunction claimTokens(address _token) external onlyFundWallet {\n', '\t\t\trequire(_token != address(0));\n', '\t\t\tToken token = Token(_token);\n', '\t\t\tuint256 balance = token.balanceOf(this);\n', '\t\t\ttoken.transfer(fundWallet, balance);\n', '\t\t }\n', '\t\t// prevent transfers until trading allowed\n', '\t\tfunction transfer(address _to, uint256 _value) isTradeable returns (bool success) {\n', '\t\t\treturn super.transfer(_to, _value);\n', '\t\t}\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) public  isTradeable returns (bool success) {\n', '\t\t\treturn super.transferFrom(_from, _to, _value);\n', '\t\t}\n', '\t}']
['contract SafeMath {\n', '\t  function safeMul(uint a, uint b) internal returns (uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t  }\n', '\t  function safeSub(uint a, uint b) internal returns (uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t  }\n', '\t  function safeAdd(uint a, uint b) internal returns (uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c>=a && c>=b);\n', '\t\treturn c;\n', '\t  }\n', '\t  // mitigate short address attack\n', '\t  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '\t  // TODO: doublecheck implication of >= compared to ==\n', '\t  modifier onlyPayloadSize(uint numWords) {\n', '\t\t assert(msg.data.length >= numWords * 32 + 4);\n', '\t\t _;\n', '\t  }\n', '\t}\n', '\n', '\tcontract Token { // ERC20 standard\n', '\t\tfunction balanceOf(address _owner) public  view returns (uint256 balance);\n', '\t\tfunction transfer(address _to, uint256 _value) public  returns (bool success);\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n', '\t\tfunction approve(address _spender, uint256 _value)  returns (bool success);\n', '\t\tfunction allowance(address _owner, address _spender) public  view returns (uint256 remaining);\n', '\t\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\t\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\t}\n', '\n', '\tcontract StandardToken is Token, SafeMath {\n', '\t\tuint256 public totalSupply;\n', '\t\t// TODO: update tests to expect throw\n', '\t\tfunction transfer(address _to, uint256 _value) public  onlyPayloadSize(2) returns (bool success) {\n', '\t\t\trequire(_to != address(0));\n', '\t\t\trequire(balances[msg.sender] >= _value && _value > 0);\n', '\t\t\tbalances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\t\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\t\t\tTransfer(msg.sender, _to, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\t// TODO: update tests to expect throw\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\n', '\t\t\trequire(_to != address(0));\n', '\t\t\trequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '\t\t\tbalances[_from] = safeSub(balances[_from], _value);\n', '\t\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\t\t\tallowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '\t\t\tTransfer(_from, _to, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction balanceOf(address _owner) view returns (uint256 balance) {\n', '\t\t\treturn balances[_owner];\n', '\t\t}\n', "\t\t// To change the approve amount you first have to reduce the addresses'\n", "\t\t//  allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '\t\t//  already 0 to mitigate the race condition described here:\n', '\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t\tfunction approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '\t\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\t\t\tallowed[msg.sender][_spender] = _value;\n', '\t\t\tApproval(msg.sender, _spender, _value);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success) {\n', '\t\t\trequire(allowed[msg.sender][_spender] == _oldValue);\n', '\t\t\tallowed[msg.sender][_spender] = _newValue;\n', '\t\t\tApproval(msg.sender, _spender, _newValue);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tfunction allowance(address _owner, address _spender) public  view returns (uint256 remaining) {\n', '\t\t  return allowed[_owner][_spender];\n', '\t\t}\n', '\t\tmapping (address => uint256) public  balances;\n', '\t\tmapping (address => mapping (address => uint256)) public  allowed;\n', '\t}\n', '\n', '\tcontract STC is StandardToken {\n', '\t\t// FIELDS\n', '\t\tstring public name = "SmarterThanCrypto";\n', '\t\tstring public symbol = "STC";\n', '\t\tuint256 public decimals = 18;\n', '\t\tstring public version = "10.0";\n', '\t\tuint256 public tokenCap = 100000000 * 10**18;\n', '\t\t// crowdsale parameters\n', '\t\tuint256 public fundingStartTime;\n', '\t\tuint256 public fundingEndTime;\n', '\t\t// vesting fields\n', '\t\taddress public vestingContract;\n', '\t\tbool private vestingSet = false;\n', '\t\t// root control\n', '\t\taddress public fundWallet;\n', '\t\t// control of liquidity and limited control of updatePrice\n', '\t\taddress public controlWallet;\n', '\t\t// time to wait between controlWallet price updates\n', '\t\tuint256 public waitTime = 1 hours;\n', '\t\t// fundWallet controlled state variables\n', '\t\t// halted: halt buying due to emergency, tradeable: signal that assets have been acquired\n', '\t\tbool public halted = false;\n', '\t\tbool public tradeable = false;\n', '\t\t// -- totalSupply defined in StandardToken\n', '\t\t// -- mapping to token balances done in StandardToken\n', '\t\tuint256 public previousUpdateTime = 0;\n', '\t\tPrice public currentPrice;\n', '\t\tuint256 public minAmount = 0.04 ether;\n', '\t\tuint256 public OfferTime = 2592000;\n', '\t \n', '\n', '\t\t// map participant address to a withdrawal request\n', '\t\tmapping (address => Withdrawal) public withdrawals;\n', '\t\t// maps previousUpdateTime to the next price\n', '\t\tmapping (uint256 => Price) public prices;\n', '\t\t// maps addresses\n', '\t\tmapping (address => bool) public whitelist;\n', '\t\t// TYPES\n', '\t\tstruct Price { // tokensPerEth\n', '\t\t\tuint256 numerator;\n', '\t\t\tuint256 denominator;\n', '\t\t}\n', '\t\tstruct Withdrawal {\n', '\t\t\tuint256 tokens;\n', '\t\t\tuint256 time; // time for each withdrawal is set to the previousUpdateTime\n', '\t\t}\n', '\t\t// EVENTS\n', '\t\tevent Buy(address indexed participant, address indexed beneficiary, uint256 ethValue, uint256 amountTokens);\n', '\t\tevent AllocatePresale(address indexed participant, uint256 amountTokens);\n', '\t\tevent Whitelist(address indexed participant);\n', '\t\tevent PriceUpdate(uint256 numerator, uint256 denominator);\n', '\t\tevent AddLiquidity(uint256 ethAmount);\n', '\t\tevent RemoveLiquidity(uint256 ethAmount);\n', '\t\tevent WithdrawRequest(address indexed participant, uint256 amountTokens);\n', '\t\tevent Withdraw(address indexed participant, uint256 amountTokens, uint256 etherAmount);\n', '\t\t// MODIFIERS\n', '\t\tmodifier isTradeable { // exempt vestingContract and fundWallet to allow dev allocations\n', '\t\t\trequire(tradeable || msg.sender == fundWallet || msg.sender == vestingContract);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyWhitelist {\n', '\t\t\trequire(whitelist[msg.sender]);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyFundWallet {\n', '\t\t\trequire(msg.sender == fundWallet);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier onlyManagingWallets {\n', '\t\t\trequire(msg.sender == controlWallet || msg.sender == fundWallet);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier only_if_controlWallet {\n', '\t\t\tif (msg.sender == controlWallet) _;\n', '\t\t}\n', '\t\tmodifier require_waited {\n', '\t\t\trequire(safeSub(now, waitTime) >= previousUpdateTime);\n', '\t\t\t_;\n', '\t\t}\n', '\t\tmodifier only_if_increase (uint256 newNumerator) {\n', '\t\t\tif (newNumerator > currentPrice.numerator) _;\n', '\t\t}\n', '\t\t// CONSTRUCTOR\n', '\t\tfunction STC(address controlWalletInput, uint256 priceNumeratorInput, uint256 startTimeInput, uint256 endTimeInput) public  {\n', '\t\t\trequire(controlWalletInput != address(0));\n', '\t\t\trequire(priceNumeratorInput > 0);\n', '\t\t\trequire(endTimeInput > startTimeInput);\n', '\t\t\tfundWallet = msg.sender;\n', '\t\t\tcontrolWallet = controlWalletInput;\n', '\t\t\twhitelist[fundWallet] = true;\n', '\t\t\twhitelist[controlWallet] = true;\n', '\t\t\tcurrentPrice = Price(priceNumeratorInput, 10000); // 1 token = 1 usd at ICO start\n', '\t\t\tfundingStartTime = startTimeInput;\n', '\t\t\tfundingEndTime = endTimeInput;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t}\t\t\t\n', '\t\t// METHODS\t\n', '\t\tfunction setOfferTime(uint256 newOfferTime) external onlyFundWallet {\n', '\t\t\trequire(newOfferTime>0);\n', '\t\t\trequire(newOfferTime<safeSub(fundingEndTime,fundingStartTime));\n', '\t\t\tOfferTime = newOfferTime;\n', '\t\t}\t\t\n', '\t\tfunction setVestingContract(address vestingContractInput) external onlyFundWallet {\n', '\t\t\trequire(vestingContractInput != address(0));\n', '\t\t\tvestingContract = vestingContractInput;\n', '\t\t\twhitelist[vestingContract] = true;\n', '\t\t\tvestingSet = true;\n', '\t\t}\n', '\t\t// allows controlWallet to update the price within a time contstraint, allows fundWallet complete control\n', '\t\tfunction updatePrice(uint256 newNumerator) external onlyManagingWallets {\n', '\t\t\trequire(newNumerator > 0);\n', '\t\t\trequire_limited_change(newNumerator);\n', '\t\t\t// either controlWallet command is compliant or transaction came from fundWallet\n', '\t\t\tcurrentPrice.numerator = newNumerator;\n', '\t\t\t// maps time to new Price (if not during ICO)\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(newNumerator, currentPrice.denominator);\n', '\t\t}\n', '\t\tfunction require_limited_change (uint256 newNumerator)\n', '\t\t\tprivate\n', '\t\t\tonly_if_controlWallet\n', '\t\t\trequire_waited\n', '\t\t\tonly_if_increase(newNumerator)\n', '\t\t{\n', '\t\t\tuint256 percentage_diff = 0;\n', '\t\t\tpercentage_diff = safeMul(newNumerator, 10000) / currentPrice.numerator;\n', '\t\t\tpercentage_diff = safeSub(percentage_diff, 10000);\n', '\t\t\t// controlWallet can only increase price by max 20% and only every waitTime\n', '\t\t\t//require(percentage_diff <= 20);\n', '\t\t}\n', '\t\tfunction updatePriceDenominator(uint256 newDenominator) external onlyManagingWallets {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(newDenominator > 0);\n', '\t\t\tcurrentPrice.denominator = newDenominator;\n', '\t\t\t// maps time to new Price\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(currentPrice.numerator, newDenominator);\n', '\t\t}\n', '\t\tfunction updatePriceAndDenominator(uint256 newNumerator, uint256 newDenominator) external onlyManagingWallets {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(newDenominator > 0);\n', '\t\t\trequire(newNumerator > 0);\n', '\t\t\trequire(safeSub(now, waitTime) >= previousUpdateTime);\n', '\t\t\tcurrentPrice.denominator = newDenominator;\n', '\t\t\tcurrentPrice.numerator = newNumerator;\n', '\t\t\t// maps time to new Price\n', '\t\t\tprices[previousUpdateTime] = currentPrice;\n', '\t\t\tpreviousUpdateTime = now;\n', '\t\t\tPriceUpdate(currentPrice.numerator, newDenominator);\n', '\t\t}\n', '\t\tfunction allocateTokens(address participant, uint256 amountTokens) private {\n', '\t\t\trequire(vestingSet);\n', '\t\t\t// 13% of total allocated for PR, Marketing, Team, Advisors\n', '\t\t\tuint256 developmentAllocation = safeMul(amountTokens, 14942528735632200) / 100000000000000000;\n', '\t\t\t// check that token cap is not exceeded\n', '\t\t\tuint256 newTokens = safeAdd(amountTokens, developmentAllocation);\n', '\t\t\trequire(safeAdd(totalSupply, newTokens) <= tokenCap);\n', '\t\t\t// increase token supply, assign tokens to participant\n', '\t\t\ttotalSupply = safeAdd(totalSupply, newTokens);\n', '\t\t\tbalances[participant] = safeAdd(balances[participant], amountTokens);\n', '\t\t\tbalances[vestingContract] = safeAdd(balances[vestingContract], developmentAllocation);\n', '\t\t}\n', '\t\tfunction allocatePresaleTokens(address participant, uint amountTokens) external onlyManagingWallets {\n', '\t\t\trequire(!halted);\n', '\t\t\trequire(participant != address(0));\n', '\t\t\twhitelist[participant] = true; // automatically whitelist accepted presale\n', '\t\t\tallocateTokens(participant, amountTokens);\n', '\t\t\tWhitelist(participant);\n', '\t\t\tAllocatePresale(participant, amountTokens);\n', '\t\t}\n', '\t\tfunction verifyParticipant(address participant) external onlyManagingWallets {\n', '\t\t\twhitelist[participant] = true;\n', '\t\t\tWhitelist(participant);\n', '\t\t}\n', '\t\tfunction buy() external payable {\n', '\t\t\tbuyTo(msg.sender);\n', '\t\t}\n', '\t\tfunction buyTo(address participant) public payable onlyWhitelist {\n', '\t\t\trequire(!halted);\n', '\t\t\trequire(participant != address(0));\n', '\t\t\trequire(msg.value >= minAmount);\n', '\t\t\trequire(now >= fundingStartTime);\n', '\t\t\tuint256 icoDenominator = icoDenominatorPrice();\n', '\t\t\tuint256 tokensToBuy = safeMul(msg.value, currentPrice.numerator) / icoDenominator;\n', '\t\t\tallocateTokens(participant, tokensToBuy);\n', '\t\t\t// send ether to fundWallet\n', '\t\t\tfundWallet.transfer(msg.value);\n', '\t\t\tBuy(msg.sender, participant, msg.value, tokensToBuy);\n', '\t\t}\n', '\t\t// time based on blocknumbers, assuming a blocktime of 30s\n', '\t\tfunction icoDenominatorPrice() public view returns (uint256) {\n', '\t\t\tuint256 icoDuration = safeSub(now, fundingStartTime);\n', '\t\t\tuint256 denominator;\n', '\t\t\tif (icoDuration < 172800) { // time in sec = (48*60*60) = 172800\n', '\t\t\t   denominator = safeMul(currentPrice.denominator, 95) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t} else if (icoDuration < OfferTime ) { // time in sec = (((4*7)+2)*24*60*60) = 2592000\n', '\t\t\t\tdenominator = safeMul(currentPrice.denominator, 100) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t} else if (now > fundingEndTime ) {\n', '\t\t\t   denominator = safeMul(currentPrice.denominator, 100) / 100;\n', '\t\t\t   return denominator;   \n', '\t\t\t} else {\n', '\t\t\t\tdenominator = safeMul(currentPrice.denominator, 105) / 100;\n', '\t\t\t   return denominator;\n', '\t\t\t}\n', '\t\t}\n', '\t\tfunction requestWithdrawal(uint256 amountTokensToWithdraw) external isTradeable onlyWhitelist {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\taddress participant = msg.sender;\n', '\t\t\trequire(balanceOf(participant) >= amountTokensToWithdraw);\n', '\t\t\trequire(withdrawals[participant].tokens == 0); // participant cannot have outstanding withdrawals\n', '\t\t\tbalances[participant] = safeSub(balances[participant], amountTokensToWithdraw);\n', '\t\t\twithdrawals[participant] = Withdrawal({tokens: amountTokensToWithdraw, time: previousUpdateTime});\n', '\t\t\tWithdrawRequest(participant, amountTokensToWithdraw);\n', '\t\t}\n', '\t\tfunction withdraw() external {\n', '\t\t\taddress participant = msg.sender;\n', '\t\t\tuint256 tokens = withdrawals[participant].tokens;\n', '\t\t\trequire(tokens > 0); // participant must have requested a withdrawal\n', '\t\t\tuint256 requestTime = withdrawals[participant].time;\n', '\t\t\t// obtain the next price that was set after the request\n', '\t\t\tPrice price = prices[requestTime];\n', '\t\t\trequire(price.numerator > 0); // price must have been set\n', '\t\t\tuint256 withdrawValue  = safeMul(tokens, price.denominator) / price.numerator;\n', '\t\t\t// if contract ethbal > then send + transfer tokens to fundWallet, otherwise give tokens back\n', '\t\t\twithdrawals[participant].tokens = 0;\n', '\t\t\tif (this.balance >= withdrawValue)\n', '\t\t\t\tenact_withdrawal_greater_equal(participant, withdrawValue, tokens);\n', '\t\t\telse\n', '\t\t\t\tenact_withdrawal_less(participant, withdrawValue, tokens);\n', '\t\t}\n', '\t\tfunction enact_withdrawal_greater_equal(address participant, uint256 withdrawValue, uint256 tokens)\n', '\t\t\tprivate\n', '\t\t{\n', '\t\t\tassert(this.balance >= withdrawValue);\n', '\t\t\tbalances[fundWallet] = safeAdd(balances[fundWallet], tokens);\n', '\t\t\tparticipant.transfer(withdrawValue);\n', '\t\t\tWithdraw(participant, tokens, withdrawValue);\n', '\t\t}\n', '\t\tfunction enact_withdrawal_less(address participant, uint256 withdrawValue, uint256 tokens)\n', '\t\t\tprivate\n', '\t\t{\n', '\t\t\tassert(this.balance < withdrawValue);\n', '\t\t\tbalances[participant] = safeAdd(balances[participant], tokens);\n', '\t\t\tWithdraw(participant, tokens, 0); // indicate a failed withdrawal\n', '\t\t}\n', '\t\tfunction checkWithdrawValue(uint256 amountTokensToWithdraw) public  view returns (uint256 etherValue) {\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\trequire(balanceOf(msg.sender) >= amountTokensToWithdraw);\n', '\t\t\tuint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\n', '\t\t\trequire(this.balance >= withdrawValue);\n', '\t\t\treturn withdrawValue;\n', '\t\t}\n', '\t\tfunction checkWithdrawValueForAddress(address participant,uint256 amountTokensToWithdraw) public  view returns (uint256 etherValue) {\n', '\t\t\trequire(amountTokensToWithdraw > 0);\n', '\t\t\trequire(balanceOf(participant) >= amountTokensToWithdraw);\n', '\t\t\tuint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\n', '\t\t\treturn withdrawValue;\n', '\t\t}\n', '\t\t// allow fundWallet or controlWallet to add ether to contract\n', '\t\tfunction addLiquidity() external onlyManagingWallets payable {\n', '\t\t\trequire(msg.value > 0);\n', '\t\t\tAddLiquidity(msg.value);\n', '\t\t}\n', '\t\t// allow fundWallet to remove ether from contract\n', '\t\tfunction removeLiquidity(uint256 amount) external onlyManagingWallets {\n', '\t\t\trequire(amount <= this.balance);\n', '\t\t\tfundWallet.transfer(amount);\n', '\t\t\tRemoveLiquidity(amount);\n', '\t\t}\n', '\t\tfunction changeFundWallet(address newFundWallet) external onlyFundWallet {\n', '\t\t\trequire(newFundWallet != address(0));\n', '\t\t\tfundWallet = newFundWallet;\n', '\t\t}\n', '\t\tfunction changeControlWallet(address newControlWallet) external onlyFundWallet {\n', '\t\t\trequire(newControlWallet != address(0));\n', '\t\t\tcontrolWallet = newControlWallet;\n', '\t\t}\n', '\t\tfunction changeWaitTime(uint256 newWaitTime) external onlyFundWallet {\n', '\t\t\twaitTime = newWaitTime;\n', '\t\t}\n', '\t\tfunction updatefundingStartTime(uint256 newfundingStartTime) external onlyFundWallet {\n', '\t\t   // require(now < fundingStartTime);\n', '\t\t   // require(now < newfundingStartTime);\n', '\t\t\tfundingStartTime = newfundingStartTime;\n', '\t\t}\n', '\t\tfunction updatefundingEndTime(uint256 newfundingEndTime) external onlyFundWallet {\n', '\t\t  //  require(now < fundingEndTime);\n', '\t\t  //  require(now < newfundingEndTime);\n', '\t\t\tfundingEndTime = newfundingEndTime;\n', '\t\t}\n', '\t\tfunction halt() external onlyFundWallet {\n', '\t\t\thalted = true;\n', '\t\t}\n', '\t\tfunction unhalt() external onlyFundWallet {\n', '\t\t\thalted = false;\n', '\t\t}\n', '\t\tfunction enableTrading() external onlyFundWallet {\n', '\t\t\trequire(now > fundingEndTime);\n', '\t\t\ttradeable = true;\n', '\t\t}\n', '\t\t// fallback function\n', '\t\tfunction() payable {\n', '\t\t\trequire(tx.origin == msg.sender);\n', '\t\t\tbuyTo(msg.sender);\n', '\t\t}\n', '\t\tfunction claimTokens(address _token) external onlyFundWallet {\n', '\t\t\trequire(_token != address(0));\n', '\t\t\tToken token = Token(_token);\n', '\t\t\tuint256 balance = token.balanceOf(this);\n', '\t\t\ttoken.transfer(fundWallet, balance);\n', '\t\t }\n', '\t\t// prevent transfers until trading allowed\n', '\t\tfunction transfer(address _to, uint256 _value) isTradeable returns (bool success) {\n', '\t\t\treturn super.transfer(_to, _value);\n', '\t\t}\n', '\t\tfunction transferFrom(address _from, address _to, uint256 _value) public  isTradeable returns (bool success) {\n', '\t\t\treturn super.transferFrom(_from, _to, _value);\n', '\t\t}\n', '\t}']
