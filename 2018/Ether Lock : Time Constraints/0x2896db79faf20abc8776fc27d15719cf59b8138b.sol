['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract Bob {\n', '  using SafeMath for uint;\n', '\n', '  enum DepositState {\n', '    Uninitialized,\n', '    BobMadeDeposit,\n', '    AliceClaimedDeposit,\n', '    BobClaimedDeposit\n', '  }\n', '\n', '  enum PaymentState {\n', '    Uninitialized,\n', '    BobMadePayment,\n', '    AliceClaimedPayment,\n', '    BobClaimedPayment\n', '  }\n', '\n', '  struct BobDeposit {\n', '    bytes20 depositHash;\n', '    uint64 lockTime;\n', '    DepositState state;\n', '  }\n', '\n', '  struct BobPayment {\n', '    bytes20 paymentHash;\n', '    uint64 lockTime;\n', '    PaymentState state;\n', '  }\n', '\n', '  mapping (bytes32 => BobDeposit) public deposits;\n', '\n', '  mapping (bytes32 => BobPayment) public payments;\n', '\n', '  constructor() public { }\n', '\n', '  function bobMakesEthDeposit(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _bobHash,\n', '    bytes20 _aliceHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && deposits[_txId].state == DepositState.Uninitialized);\n', '    bytes20 depositHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      _bobHash,\n', '      _aliceHash,\n', '      address(0),\n', '      msg.value\n', '    ));\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Deposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _bobHash,\n', '    bytes20 _aliceHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    bytes20 depositHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      _bobHash,\n', '      _aliceHash,\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _bobSecret,\n', '    bytes20 _aliceHash,\n', '    address _alice,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_bobSecret)))),\n', '      _aliceHash,\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    require(depositHash == deposits[_txId].depositHash && now < deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.BobClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _aliceSecret,\n', '    address _bob,\n', '    address _tokenAddress,\n', '    bytes20 _bobHash\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(abi.encodePacked(\n', '      msg.sender,\n', '      _bob,\n', '      _bobHash,\n', '      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_aliceSecret)))),\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    require(depositHash == deposits[_txId].depositHash && now >= deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.AliceClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function bobMakesEthPayment(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && payments[_txId].state == PaymentState.Uninitialized);\n', '    bytes20 paymentHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      address(0),\n', '      msg.value\n', '    ));\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Payment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    require(\n', '      _alice != 0x0 &&\n', '      _amount > 0 &&\n', '      payments[_txId].state == PaymentState.Uninitialized &&\n', '      _tokenAddress != 0x0\n', '    );\n', '    bytes20 paymentHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    address _tokenAddress,\n', '    bytes20 _secretHash\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(abi.encodePacked(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    require(now >= payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.BobClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _secret,\n', '    address _bob,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(abi.encodePacked(\n', '      msg.sender,\n', '      _bob,\n', '      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_secret)))),\n', '      _tokenAddress,\n', '      _amount\n', '    ));\n', '    require(now < payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.AliceClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '}']