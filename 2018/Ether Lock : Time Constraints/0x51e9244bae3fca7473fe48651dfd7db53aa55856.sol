['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '     /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else{\n', '            uint256 z = x;\n', '            for (uint256 i = 1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface shareProfit {\n', '    function increaseProfit() external payable returns(bool);\n', '}\n', '\n', 'contract RobTheBank{\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public constant BASE_PRICE = 0.003 ether;\n', '    address public owner;\n', '    address public service;\n', '    struct Big {\n', '        uint256 totalKey;\n', '        uint256 jackpotBalance;\n', '        uint256 KeyProfit;\n', '        mapping (address=>uint256) received;\n', '        address winner;\n', '        uint256 winnerProfit;\n', '    }\n', '    struct Small {\n', '        uint256 totalKey;\n', '        address winner;\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        uint256 winKey;\n', '        uint256 winnerProfit;\n', '    }\n', '    struct KeyPurchases {\n', '        KeyPurchase[] keysBought;\n', '        uint256 numPurchases;\n', '    }\n', '    struct KeyPurchase {\n', '        uint256 startId;\n', '        uint256 endId;\n', '    }\n', '    mapping (uint256=>Big) public bigRound;\n', '    mapping (uint256=>mapping (uint256=>Small)) public smallRound;\n', '    shareProfit public RTB1;\n', '    shareProfit public RTB2;\n', '    mapping (uint256=>mapping (uint256=>mapping (address=>uint256))) public userSmallRoundkey;\n', '    mapping (uint256=>mapping (address=>uint256)) public userBigRoundKey;\n', '    mapping (uint256=>mapping (uint256=>mapping (address=>KeyPurchases))) public userXkeyPurchases;\n', '    uint256 keysBought;\n', '    mapping (address=>uint256) public recommender;\n', '    mapping (address=>bool) public recommenderAllow;\n', '    uint256 public allowPrice;\n', '    uint256 devFee;\n', '    uint256 public smallId;\n', '    uint256 public bigId;\n', '    bool public isPaused = false;\n', '    \n', '    event buyEvent(address indexed _buyer, uint256 _amount, uint256 _total, uint256 _bigRound, uint256 _smallRound, uint256 _startId, uint256 _endId, uint256 _index);\n', '    event lotteryEvent(address indexed _winner, uint256 _bigRound, uint256 _smallRound, uint256 _money, uint256 _type);\n', '    event withdrawEvent(address indexed _winner, uint256 _amount, uint256 _round);\n', '    event RecommenderAllow(address indexed _user, bool _status);\n', '    event createKey(uint256 _winkey, uint256 _bigRound, uint256 _smallRound);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyService() {\n', '        require(msg.sender == service, "only service");\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!isPaused, "is Paused");\n', '        _;\n', '    }\n', '\n', '    modifier isHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '\n', '    constructor (address _rtb1, address _rtb2) public {\n', '        owner = msg.sender;\n', '        service = msg.sender;\n', '        bigId = 1;\n', '        smallId = 1;\n', '        allowPrice = 0.01 ether;\n', '        RTB1 = shareProfit(_rtb1);\n', '        RTB2 = shareProfit(_rtb2);\n', '    }\n', '\n', '    function() external payable{\n', '        require(msg.value > 0);\n', '        bigRound[bigId].jackpotBalance = bigRound[bigId].jackpotBalance.add(msg.value);\n', '    }\n', '    \n', '    ///@dev Start new game\n', '    function startGame() public onlyOwner{\n', '        uint256 time = block.timestamp;\n', '        smallRound[bigId][smallId].startTime = time;\n', '        smallRound[bigId][smallId].endTime = time + 41400;\n', '    }\n', '    \n', '    ///@dev Buy key\n', '    function buy(uint256 _amount, address _invite) public isHuman whenNotPaused payable{\n', '        require(smallRound[bigId][smallId].startTime < block.timestamp, "The game has not started yet");\n', '        require(smallRound[bigId][smallId].endTime > block.timestamp, "The game is over");\n', '        uint256 _money = _amount.mul(getPrice());\n', '        require(_amount > 0 && _money > 0);\n', '        require(_money == msg.value, "The amount is incorrect");\n', '\n', '        if (_invite != address(0) && _invite != msg.sender && recommenderAllow[_invite] == true){\n', '            recommender[_invite] = _money.mul(10).div(100).add(recommender[_invite]);\n', '            _money = _money.mul(90).div(100);\n', '        }\n', '\n', '        _buy(_amount, _money);\n', '    }\n', '    \n', '    ///@dev Use vault\n', '    function buyAgain(uint256 _amount) public isHuman whenNotPaused {\n', '        require(smallRound[bigId][smallId].startTime < block.timestamp, "The game has not started yet");\n', '        require(smallRound[bigId][smallId].endTime > block.timestamp, "The game is over");\n', '        uint256 _money = _amount.mul(getPrice());\n', '        uint256 profit = getMyProfit(bigId);\n', '        require(_amount > 0 && _money > 0);\n', '        require(profit >= _money);\n', '        bigRound[bigId].received[msg.sender] = _money.add(bigRound[bigId].received[msg.sender]);\n', '        _buy(_amount, _money);\n', '    }\n', '    \n', '    function _buy(uint256 _amount, uint256 _money) internal whenNotPaused{\n', '        //Number of record keys\n', '        userBigRoundKey[bigId][msg.sender] = userBigRoundKey[bigId][msg.sender].add(_amount);\n', '        userSmallRoundkey[bigId][smallId][msg.sender] = userSmallRoundkey[bigId][smallId][msg.sender].add(_amount);\n', '        \n', "        //Record player's key\n", '        KeyPurchases storage purchases = userXkeyPurchases[bigId][smallId][msg.sender];\n', '        if (purchases.numPurchases == purchases.keysBought.length) {\n', '            purchases.keysBought.length += 1;\n', '        }\n', "        purchases.keysBought[purchases.numPurchases] = KeyPurchase(keysBought, keysBought + (_amount - 1)); // (eg: buy 10, get id's 0-9)\n", '        purchases.numPurchases++;\n', '        emit buyEvent(msg.sender, _amount, msg.value, bigId, smallId, keysBought, keysBought + (_amount - 1), purchases.numPurchases);\n', '        keysBought = keysBought.add(_amount);\n', '\n', '        //40% for all players\n', '        uint256 _playerFee = _money.mul(40).div(100);\n', '        if(bigRound[bigId].totalKey > 0){\n', '            bigRound[bigId].KeyProfit = _playerFee.div(bigRound[bigId].totalKey).add(bigRound[bigId].KeyProfit);\n', '            bigRound[bigId].received[msg.sender] = bigRound[bigId].KeyProfit.mul(_amount).add(bigRound[bigId].received[msg.sender]);\n', '        }else{\n', '            devFee = devFee.add(_playerFee);\n', '        }\n', '\n', '        //35% for jackpot\n', '        bigRound[bigId].jackpotBalance = _money.mul(35).div(100).add(bigRound[bigId].jackpotBalance);\n', '        \n', '        //15% for RTB1 and RTB2\n', '        uint256 _shareFee = _money.mul(15).div(100);\n', '        RTB1.increaseProfit.value(_shareFee.mul(3).div(10))(); // 300/1000 = 30%\n', '        RTB2.increaseProfit.value(_shareFee.mul(7).div(10))(); // 700/1000 = 70%\n', '        \n', '        //10% for winner\n', '        smallRound[bigId][smallId].winnerProfit = _money.mul(10).div(100).add(smallRound[bigId][smallId].winnerProfit);\n', '\n', '        bigRound[bigId].totalKey = bigRound[bigId].totalKey.add(_amount);\n', '        smallRound[bigId][smallId].totalKey = smallRound[bigId][smallId].totalKey.add(_amount);\n', '    }\n', '    \n', '    ///@dev Create a winner\n', '    function createWinner() public onlyService whenNotPaused{\n', '        require(smallRound[bigId][smallId].endTime < block.timestamp);\n', '        require(smallRound[bigId][smallId].winKey == 0);\n', '        uint256 seed = _random();\n', '        smallRound[bigId][smallId].winKey = addmod(uint256(blockhash(block.number-1)), seed, smallRound[bigId][smallId].totalKey);\n', '        emit createKey(smallRound[bigId][smallId].winKey, bigId, smallId);\n', '    }\n', '\n', '    ///@dev Lottery\n', '    function lottery(address _winner, uint256 _checkIndex) external onlyService whenNotPaused{\n', '        require(_winner != address(0));\n', '        require(address(this).balance > smallRound[bigId][smallId].winnerProfit);\n', '        \n', '        KeyPurchases storage keys = userXkeyPurchases[bigId][smallId][_winner];\n', '        if(keys.numPurchases > 0 && _checkIndex < keys.numPurchases){\n', '            KeyPurchase storage checkKeys = keys.keysBought[_checkIndex];\n', '            if(smallRound[bigId][smallId].winKey >= checkKeys.startId && smallRound[bigId][smallId].winKey <= checkKeys.endId){\n', '                smallRound[bigId][smallId].winner = _winner;\n', '                _winner.transfer(smallRound[bigId][smallId].winnerProfit);\n', '                emit lotteryEvent(_winner, bigId, smallId, smallRound[bigId][smallId].winnerProfit, 1);\n', '                \n', '                _bigLottery(_winner);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _bigLottery(address _winner) internal whenNotPaused{\n', '        uint256 seed = _random();\n', '        uint256 mod;\n', '        if(smallId < 50){\n', '            mod = (51 - smallId) * 3 - 4;\n', '        }else{\n', '            mod = 1;\n', '        }\n', '        uint256 number =  addmod(uint256(blockhash(block.number-1)), seed, mod);\n', '        if(number == 0){\n', '            //Congratulations, win the grand prize\n', '            require(address(this).balance >= bigRound[bigId].jackpotBalance);\n', '\n', '            //10% for all player\n', '            uint256 _playerFee = bigRound[bigId].jackpotBalance.mul(10).div(100);\n', '            bigRound[bigId].KeyProfit = _playerFee.div(bigRound[bigId].totalKey).add(bigRound[bigId].KeyProfit);\n', '            \n', '            //10% for next jackpot\n', '            uint256 _jackpotFee = bigRound[bigId].jackpotBalance.mul(10).div(100);\n', '            \n', '            //10% for RTB1 and RTB2\n', '            uint256 _shareFee =  bigRound[bigId].jackpotBalance.mul(10).div(100);\n', '            RTB1.increaseProfit.value(_shareFee.mul(3).div(10))(); // 300/1000 = 30%\n', '            RTB2.increaseProfit.value(_shareFee.mul(7).div(10))(); // 700/1000 = 70%\n', '            \n', '            //8% for dev\n', '            devFee = bigRound[bigId].jackpotBalance.mul(8).div(100).add(devFee);\n', '            \n', '            //62% for winner\n', '            uint256 _winnerProfit = bigRound[bigId].jackpotBalance.mul(62).div(100);\n', '            _winner.transfer(_winnerProfit);\n', '            emit lotteryEvent(_winner, bigId, smallId, _winnerProfit, 2);\n', '            bigRound[bigId].winnerProfit = _winnerProfit;\n', '            \n', '            //Start a new round\n', '            bigId++;\n', '            smallId = 1;\n', '            bigRound[bigId].jackpotBalance = _jackpotFee;\n', '        }else{\n', "            //You didn't win the grand prize\n", '            //Start new round\n', '            smallId++;\n', '        }\n', '        keysBought = 0;\n', '    }\n', '\n', '    function withdraw(uint256 _round) public whenNotPaused{\n', '        uint profit = getMyProfit(_round);\n', '        uint256 money = recommender[msg.sender].add(profit);\n', '        require(money > 0);\n', '        recommender[msg.sender] = 0;\n', '        bigRound[_round].received[msg.sender] = bigRound[_round].received[msg.sender].add(profit);\n', '        msg.sender.transfer(money);\n', '        emit withdrawEvent(msg.sender, money, _round);\n', '    }\n', '    \n', '    function devWithdraw() public onlyOwner{\n', '        owner.transfer(devFee);\n', '        emit withdrawEvent(owner, devFee, 0);\n', '        devFee = 0;\n', '    }\n', '    \n', '    function getMyProfit(uint256 _round) public view returns(uint256){\n', '        return bigRound[_round].KeyProfit.mul(userBigRoundKey[_round][msg.sender]).sub(bigRound[_round].received[msg.sender]);\n', '    }\n', '\n', '    function getPrice() public view returns(uint256) {\n', '        require(smallId >= 1 && smallId <= 50);\n', '        uint256 _round = smallId.sub(1);\n', '        return _round.mul(_round).mul(1200000000000000).div(25).add(BASE_PRICE);\n', '    }\n', '\n', '     //random\n', '    function _random() internal view returns(uint256){\n', '        uint256 seed = uint256(keccak256( (\n', '            (block.timestamp).add\n', '            (block.difficulty).add\n', '            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n', '            (block.gaslimit).add\n', '            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n', '            (block.number)\n', '        )));\n', '\n', '        return seed;\n', '    }\n', '    \n', '    function setAllowPrice(uint256 _price) public onlyOwner{\n', '        allowPrice = _price;\n', '    }\n', '    \n', '    function setRecommenderAllow() public payable{\n', '        require(msg.value == allowPrice);\n', '        require(recommenderAllow[msg.sender] == false);\n', '        devFee = devFee.add(msg.value);\n', '        emit RecommenderAllow(msg.sender, true);\n', '        recommenderAllow[msg.sender] = true;\n', '    }\n', '    \n', '    function setGame(bool _bool) public onlyOwner{\n', '        isPaused = _bool;\n', '    }\n', '\n', '    function setService(address _addr) public onlyOwner{\n', '        service = _addr;\n', '    }\n', '}']