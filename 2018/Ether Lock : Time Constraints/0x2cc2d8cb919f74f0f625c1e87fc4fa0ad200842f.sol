['pragma solidity ^0.4.24;\n', '/**\n', ' * @title POPO v1.3.1\n', ' *\n', ' * This product is protected under license.  Any unauthorized copy, modification, or use without \n', ' * express written consent from the creators is prohibited.\n', ' * \n', ' * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY.\n', ' */\n', '// Author: https://playpopo.com\n', '// Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5929353820293629362d3c3834193e34383035773a3634">[email&#160;protected]</a>\n', 'library PopoDatasets {\n', '\n', '  struct Order {\n', '    uint256 pID;\n', '    uint256 createTime;\n', '    uint256 createDayIndex;\n', '    uint256 orderValue;\n', '    uint256 refund;\n', '    uint256 withdrawn;\n', '    bool hasWithdrawn;\n', '  }\n', '  \n', '  struct Player {\n', '    address addr;\n', '    bytes32 name;\n', '\n', '    bool inviteEnable;\n', '    uint256 inviterPID;\n', '    uint256 [] inviteePIDs;\n', '    uint256 inviteReward1;\n', '    uint256 inviteReward2;\n', '    uint256 inviteReward3;\n', '    uint256 inviteRewardWithdrawn;\n', '\n', '    uint256 [] oIDs;\n', '    uint256 lastOrderDayIndex;\n', '    uint256 dayEthIn;\n', '  }\n', '\n', '}\n', 'contract PopoEvents {\n', '\n', '  event onEnableInvite\n', '  (\n', '    uint256 pID,\n', '    address pAddr,\n', '    bytes32 pName,\n', '    uint256 timeStamp\n', '  );\n', '  \n', '\n', '  event onSetInviter\n', '  (\n', '    uint256 pID,\n', '    address pAddr,\n', '    uint256 indexed inviterPID,\n', '    address indexed inviterAddr,\n', '    bytes32 indexed inviterName,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 indexed dayIndex,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawOrderRefund\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawOrderRefundToOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawInviteReward\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawInviteRewardToOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '    \n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'library NameFilter {\n', '  \n', '    using SafeMath for *;\n', '\n', '    /**\n', '     * @dev filters name strings\n', '     * -converts uppercase to lower case.  \n', '     * -makes sure it does not start/end with a space\n', '     * -makes sure it does not contain multiple spaces in a row\n', '     * -cannot be only numbers\n', '     * -cannot start with 0x \n', '     * -restricts characters to A-Z, a-z, 0-9, and space.\n', '     * @return reprocessed string in bytes32 format\n', '     */\n', '    function nameFilter(string _input)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        bytes memory _temp = bytes(_input);\n', '        uint256 _length = _temp.length;\n', '        \n', '        //sorry limited to 32 characters\n', '        require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");\n', '        // make sure it doesnt start with or end with space\n', '        require(_temp[0] != 0x20 && _temp[_length.sub(1)] != 0x20, "string cannot start or end with space");\n', '        // make sure first two characters are not 0x\n', '        if (_temp[0] == 0x30)\n', '        {\n', '            require(_temp[1] != 0x78, "string cannot start with 0x");\n', '            require(_temp[1] != 0x58, "string cannot start with 0X");\n', '        }\n', '        \n', '        // create a bool to track if we have a non number character\n', '        bool _hasNonNumber;\n', '        \n', '        // convert & check\n', '        for (uint256 i = 0; i < _length; i = i.add(1))\n', '        {\n', '            // if its uppercase A-Z\n', '            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n', '            {\n', '                // convert to lower case a-z\n', '                _temp[i] = byte(uint(_temp[i]) + 32);\n', '                \n', '                // we have a non number\n', '                if (_hasNonNumber == false)\n', '                    _hasNonNumber = true;\n', '            } else {\n', '                require\n', '                (\n', '                    // require character is a space\n', '                    _temp[i] == 0x20 || \n', '                    // OR lowercase a-z\n', '                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n', '                    // or 0-9\n', '                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n', '                    "string contains invalid characters"\n', '                );\n', '                // make sure theres not 2x spaces in a row\n', '                if (_temp[i] == 0x20)\n', '                    require(_temp[i.add(1)] != 0x20, "string cannot contain consecutive spaces");\n', '                \n', '                // see if we have a character other than a number\n', '                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n', '                    _hasNonNumber = true;    \n', '            }\n', '        }\n', '        \n', '        require(_hasNonNumber == true, "string cannot be only numbers");\n', '        \n', '        bytes32 _ret;\n', '        assembly {\n', '            _ret := mload(add(_temp, 32))\n', '        }\n', '        return (_ret);\n', '    }\n', '}\n', 'contract SafePopo {\n', '\n', '  using SafeMath for *;\n', '\n', '  bool public activated_;\n', '  uint256 public activated_time_;\n', '\n', '  modifier isHuman() {\n', '    address _addr = msg.sender;\n', '    uint256 _codeLength;\n', '      \n', '    assembly {_codeLength := extcodesize(_addr)}\n', '    require (_codeLength == 0, "sorry humans only");\n', '    _;\n', '  }\n', '\n', '  modifier isWithinLimits(uint256 _eth) {\n', '    require (_eth >= 0.1 ether, "0.1 ether at least");\n', '    require (_eth <= 10000000 ether, "no, too much ether");\n', '    _;    \n', '  }\n', '\n', '  modifier isActivated() {\n', '    require (activated_ == true, "popo is not activated"); \n', '    _;\n', '  }\n', '\n', '  modifier onlyCEO() {\n', '    require \n', '    (\n', '      msg.sender == 0x5927774a0438f452747b847E4e9097884DA6afE9 || \n', '      msg.sender == 0xA2CDecFe929Eccbd519A6c98b1220b16f5b6B0B5\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCommunityLeader() { \n', '    require \n', '    (\n', '      msg.sender == 0xede5Adf9F68C02537Cc1737CFF4506BCfFAAB63d || \n', '      msg.sender == 0x7400A7B7D67814B0d8B27362CC198F4Ae2840e16\n', '    );\n', '    _;\n', '  }\n', '\n', '  function activate() \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    require (activated_ == false, "popo has been activated already");\n', '\n', '    activated_ = true;\n', '    activated_time_ = now;\n', '  }\n', '  \n', '}\n', 'contract CorePopo is SafePopo, PopoEvents {\n', '\n', '  uint256 public startTime_;\n', '\n', '  uint256 public teamPot_;\n', '  uint256 public communityPot_;\n', '  \n', '  mapping (uint256 => uint256) public day_ethIn;\n', '  uint256 public ethIn_;\n', '\n', '  uint256 public dayEthInLimit_ = 300 ether;\n', '  uint256 public playerDayEthInLimit_ = 10 ether;\n', '\n', '  uint256 public pIDIndex_;\n', '  mapping (uint256 => PopoDatasets.Player) public pID_Player_;\n', '  mapping (address => uint256) public addr_pID_;\n', '  mapping (bytes32 => uint256) public name_pID_;\n', '\n', '  mapping (uint256 => uint256) public inviteePID_inviteReward1_;\n', '\n', '  uint256 public oIDIndex_;\n', '  mapping (uint256 => PopoDatasets.Order) public oID_Order_;\n', '\n', '  uint256 [] public refundOIDs_;\n', '  uint256 public refundOIDIndex_;\n', '\n', '  function determinePID ()\n', '    internal\n', '  {\n', '    if (addr_pID_[msg.sender] != 0) {\n', '      return;\n', '    }\n', '\n', '    pIDIndex_ = pIDIndex_.add(1);\n', '    \n', '    pID_Player_[pIDIndex_].addr = msg.sender;\n', '\n', '    addr_pID_[msg.sender] = pIDIndex_;\n', '  }\n', '\n', '  function getDayIndex (uint256 _time)\n', '    internal\n', '    view\n', '    returns (uint256) \n', '  {\n', '    return _time.sub(activated_time_).div(1 days).add(1);\n', '  }\n', '  \n', '}\n', 'contract InvitePopo is CorePopo {\n', '\n', '  using NameFilter for string;\n', '  \n', '  function enableInvite (string _nameString, bytes32 _inviterName)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '    payable\n', '  {\n', '    require (msg.value == 0.01 ether, "enable invite need 0.01 ether");     \n', '\n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '   \n', '    require (pID_Player_[addr_pID_[msg.sender]].inviteEnable == false, "you can only enable invite once");\n', '\n', '    bytes32 _name = _nameString.nameFilter();\n', '    require (name_pID_[_name] == 0, "your name is already registered by others");\n', '    \n', '    pID_Player_[addr_pID_[msg.sender]].name = _name;\n', '    pID_Player_[addr_pID_[msg.sender]].inviteEnable = true;\n', '\n', '    name_pID_[_name] = addr_pID_[msg.sender];\n', '\n', '    communityPot_ = communityPot_.add(msg.value);\n', '\n', '    emit PopoEvents.onEnableInvite\n', '    (\n', '      addr_pID_[msg.sender],\n', '      msg.sender,\n', '      _name,\n', '      now\n', '    );\n', '  }\n', '\n', '  function enableInviteOfSU (string _nameString) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    determinePID();\n', '   \n', '    require (pID_Player_[addr_pID_[msg.sender]].inviteEnable == false, "you can only enable invite once");\n', '\n', '    bytes32 _name = _nameString.nameFilter();\n', '    require (name_pID_[_name] == 0, "your name is already registered by others");\n', '    \n', '    name_pID_[_name] = addr_pID_[msg.sender];\n', '\n', '    pID_Player_[addr_pID_[msg.sender]].name = _name;\n', '    pID_Player_[addr_pID_[msg.sender]].inviteEnable = true;\n', '  }\n', '\n', '  function determineInviter (uint256 _pID, bytes32 _inviterName) \n', '    internal\n', '  {\n', '    if (pID_Player_[_pID].inviterPID != 0) {\n', '      return;\n', '    }\n', '\n', '    uint256 _inviterPID = name_pID_[_inviterName];\n', '    require (_inviterPID != 0, "your inviter name must be registered");\n', '    require (pID_Player_[_inviterPID].inviteEnable == true, "your inviter must enable invite");\n', '    require (_inviterPID != _pID, "you can not invite yourself");\n', '\n', '    pID_Player_[_pID].inviterPID = _inviterPID;\n', '\n', '    emit PopoEvents.onSetInviter\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _inviterPID,\n', '      pID_Player_[_inviterPID].addr,\n', '      _inviterName,\n', '      now\n', '    );\n', '  }\n', '\n', '  function distributeInviteReward (uint256 _pID, uint256 _inviteReward1, uint256 _inviteReward2, uint256 _inviteReward3, uint256 _percent) \n', '    internal\n', '    returns (uint256)\n', '  {\n', '    uint256 inviterPID = pID_Player_[_pID].inviterPID;\n', '    if (pID_Player_[inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID].inviteReward1 = pID_Player_[inviterPID].inviteReward1.add(_inviteReward1);\n', '\n', '      if (inviteePID_inviteReward1_[_pID] == 0) {\n', '        pID_Player_[inviterPID].inviteePIDs.push(_pID);\n', '      }\n', '      inviteePID_inviteReward1_[_pID] = inviteePID_inviteReward1_[_pID].add(_inviteReward1);\n', '\n', '      _percent = _percent.sub(5);\n', '    } \n', '    \n', '    uint256 inviterPID_inviterPID = pID_Player_[inviterPID].inviterPID;\n', '    if (pID_Player_[inviterPID_inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID_inviterPID].inviteReward2 = pID_Player_[inviterPID_inviterPID].inviteReward2.add(_inviteReward2);\n', '\n', '      _percent = _percent.sub(2);\n', '    }\n', '\n', '    uint256 inviterPID_inviterPID_inviterPID = pID_Player_[inviterPID_inviterPID].inviterPID;\n', '    if (pID_Player_[inviterPID_inviterPID_inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID_inviterPID_inviterPID].inviteReward3 = pID_Player_[inviterPID_inviterPID_inviterPID].inviteReward3.add(_inviteReward3);\n', '\n', '      _percent = _percent.sub(1);\n', '    } \n', '\n', '    return\n', '    (\n', '      _percent\n', '    );\n', '  }\n', '  \n', '}\n', 'contract OrderPopo is InvitePopo {\n', '\n', '  function setDayEthInLimit (uint256 dayEthInLimit) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    dayEthInLimit_ = dayEthInLimit;\n', '  }\n', '\n', '  function setPlayerDayEthInLimit (uint256 playerDayEthInLimit) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    playerDayEthInLimit_ = playerDayEthInLimit;\n', '  }\n', '  \n', '  function order (bytes32 _inviterName)\n', '    isActivated()\n', '    isHuman()\n', '    isWithinLimits(msg.value)\n', '    public\n', '    payable\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (_nowDayIndex > 2, "only third day can order");\n', '            \n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '\n', '    orderCore(_now, _nowDayIndex, msg.value);\n', '  }\n', '\n', '  function orderInternal (uint256 _value, bytes32 _inviterName)\n', '    internal\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (_nowDayIndex > 2, "only third day can order");\n', '            \n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '\n', '    orderCore(_now, _nowDayIndex, _value);\n', '  }\n', '\n', '  function orderCore (uint256 _now, uint256 _nowDayIndex, uint256 _value)\n', '    private\n', '  {\n', '    teamPot_ = teamPot_.add(_value.mul(3).div(100));\n', '    communityPot_ = communityPot_.add(_value.mul(4).div(100));\n', '\n', '    require (day_ethIn[_nowDayIndex] < dayEthInLimit_, "beyond the day eth in limit");\n', '    day_ethIn[_nowDayIndex] = day_ethIn[_nowDayIndex].add(_value);\n', '    ethIn_ = ethIn_.add(_value);\n', '\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    if (pID_Player_[_pID].lastOrderDayIndex == _nowDayIndex) {\n', '      require (pID_Player_[_pID].dayEthIn < playerDayEthInLimit_, "beyond the player day eth in limit");\n', '      pID_Player_[_pID].dayEthIn = pID_Player_[_pID].dayEthIn.add(_value);\n', '    } else {\n', '      pID_Player_[_pID].lastOrderDayIndex = _nowDayIndex;\n', '      pID_Player_[_pID].dayEthIn = _value;\n', '    }\n', '\n', '    oIDIndex_ = oIDIndex_.add(1);\n', '    \n', '    oID_Order_[oIDIndex_].pID = _pID;\n', '    oID_Order_[oIDIndex_].createTime = _now;\n', '    oID_Order_[oIDIndex_].createDayIndex = _nowDayIndex;\n', '    oID_Order_[oIDIndex_].orderValue = _value;\n', '\n', '    pID_Player_[_pID].oIDs.push(oIDIndex_);\n', '\n', '    refundOIDs_.push(oIDIndex_);\n', '\n', '    uint256 _percent = 33;\n', '    if (pID_Player_[_pID].oIDs.length < 3) {\n', '      _percent = distributeInviteReward(_pID, _value.mul(5).div(100), _value.mul(2).div(100), _value.mul(1).div(100), _percent);\n', '      refund(_nowDayIndex, _value.mul(_percent).div(100));\n', '    } else {\n', '      refund(_nowDayIndex, _value.mul(_percent).div(100));\n', '    }\n', '\n', '    emit PopoEvents.onOrder\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _nowDayIndex,\n', '      oIDIndex_,\n', '      _value,\n', '      now\n', '    );\n', '  }\n', '\n', '  function refund (uint256 _nowDayIndex, uint256 _pot)\n', '    private\n', '  {\n', '    while\n', '    (\n', '      (_pot > 0) &&\n', '      (refundOIDIndex_ < refundOIDs_.length)\n', '    )\n', '    {\n', '      (_pot, refundOIDIndex_) = doRefund(_nowDayIndex, refundOIDIndex_, _pot);\n', '    }\n', '  }\n', '  \n', '  function doRefund (uint256 _nowDayIndex, uint256 _refundOIDIndex, uint256 _pot)\n', '    private\n', '    returns (uint256, uint256)\n', '  {\n', '    uint256 _refundOID = refundOIDs_[_refundOIDIndex];\n', '\n', '    uint _orderState = getOrderStateHelper(_nowDayIndex, _refundOID);\n', '    if (_orderState != 1) {\n', '      return\n', '      (\n', '        _pot,\n', '        _refundOIDIndex.add(1)\n', '      );\n', '    }\n', '\n', '    uint256 _maxRefund = oID_Order_[_refundOID].orderValue.mul(60).div(100);\n', '    if (oID_Order_[_refundOID].refund < _maxRefund) {\n', '      uint256 _needRefund = _maxRefund.sub(oID_Order_[_refundOID].refund);\n', '\n', '      if \n', '      (\n', '        _needRefund > _pot\n', '      ) \n', '      {\n', '        oID_Order_[_refundOID].refund = oID_Order_[_refundOID].refund.add(_pot);\n', '\n', '        return\n', '        (\n', '          0,\n', '          _refundOIDIndex\n', '        );\n', '      } \n', '      else\n', '      {\n', '        oID_Order_[_refundOID].refund = oID_Order_[_refundOID].refund.add(_needRefund);\n', '\n', '        return\n', '        (\n', '          _pot.sub(_needRefund),\n', '          _refundOIDIndex.add(1)\n', '        );\n', '      }\n', '    }\n', '    else\n', '    {\n', '      return\n', '      (\n', '        _pot,\n', '        _refundOIDIndex.add(1)\n', '      );\n', '    }\n', '  }\n', '\n', '  function getOrderStateHelper (uint256 _nowDayIndex, uint256 _oID)\n', '    internal\n', '    view\n', '    returns (uint)\n', '  {\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    \n', '    if \n', '    (\n', '      _order.hasWithdrawn\n', '    ) \n', '    {\n', '      return\n', '      (\n', '        3\n', '      );\n', '    } \n', '    else \n', '    {\n', '      if \n', '      (\n', '        _nowDayIndex < _order.createDayIndex || \n', '        _nowDayIndex > _order.createDayIndex.add(5)\n', '      )\n', '      {\n', '        return\n', '        (\n', '          2\n', '        );\n', '      }\n', '      else \n', '      {\n', '        return\n', '        (\n', '          1\n', '        );\n', '      }\n', '    }\n', '  }\n', '  \n', '}\n', 'contract InspectorPopo is OrderPopo {\n', '\n', '  function getAdminDashboard () \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256, uint256)\n', '  {\n', '    return\n', '    (\n', '      teamPot_,\n', '      communityPot_\n', '    ); \n', '  }\n', '\n', '  function getDayEthIn (uint256 _dayIndex) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256)\n', '  {\n', '    return\n', '    (\n', '      day_ethIn[_dayIndex]\n', '    ); \n', '  }\n', '\n', '  function getAddressLost (address _addr) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256) \n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    uint256 pID = addr_pID_[_addr];\n', '    require (pID != 0, "address need to be registered");\n', '    \n', '    uint256 _orderValue = 0;\n', '    uint256 _actualTotalRefund = 0;\n', '\n', '    uint256 [] memory _oIDs = pID_Player_[pID].oIDs;\n', '    for (uint256 _index = 0; _index < _oIDs.length; _index = _index.add(1)) {\n', '      PopoDatasets.Order memory _order = oID_Order_[_oIDs[_index]];\n', '      _orderValue = _orderValue.add(_order.orderValue);\n', '      _actualTotalRefund = _actualTotalRefund.add(getOrderActualTotalRefundHelper(_nowDayIndex, _oIDs[_index]));\n', '    }\n', '\n', '    if (_orderValue > _actualTotalRefund) {\n', '      return \n', '      (\n', '        _orderValue.sub(_actualTotalRefund)\n', '      );\n', '    }\n', '    else\n', '    {\n', '      return \n', '      (\n', '        0\n', '      );\n', '    }\n', '  }\n', '\n', '  function getInviteInfo () \n', '    public\n', '    view\n', '    returns (bool, bytes32, uint256, bytes32, uint256, uint256, uint256, uint256)\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    return \n', '    (\n', '      pID_Player_[_pID].inviteEnable,\n', '      pID_Player_[_pID].name,\n', '      pID_Player_[_pID].inviterPID,\n', '      pID_Player_[pID_Player_[_pID].inviterPID].name,\n', '      pID_Player_[_pID].inviteReward1,\n', '      pID_Player_[_pID].inviteReward2,\n', '      pID_Player_[_pID].inviteReward3,\n', '      pID_Player_[_pID].inviteRewardWithdrawn\n', '    );\n', '  }\n', '\n', '  function getInviteePIDs () \n', '    public\n', '    view\n', '    returns (uint256 []) \n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    return \n', '    (\n', '      pID_Player_[_pID].inviteePIDs\n', '    );\n', '  }\n', '\n', '  function getInviteeInfo (uint256 _inviteePID) \n', '    public\n', '    view\n', '    returns (uint256, bytes32) \n', '  {\n', '\n', '    require (pID_Player_[_inviteePID].inviterPID == addr_pID_[msg.sender], "you must have invited this player");\n', '\n', '    return \n', '    (\n', '      inviteePID_inviteReward1_[_inviteePID],\n', '      pID_Player_[_inviteePID].name\n', '    );\n', '  }\n', '\n', '  function getOrderInfo () \n', '    public\n', '    view\n', '    returns (bool, uint256 []) \n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    bool _isWithinPlayerDayEthInLimits = true;\n', '    if\n', '    (\n', '      (pID_Player_[_pID].lastOrderDayIndex == _nowDayIndex) &&\n', '      (pID_Player_[_pID].dayEthIn >= playerDayEthInLimit_) \n', '    )\n', '    {\n', '      _isWithinPlayerDayEthInLimits = false;\n', '    }\n', '\n', '    return \n', '    (\n', '      _isWithinPlayerDayEthInLimits,\n', '      pID_Player_[_pID].oIDs\n', '    );\n', '  }\n', '\n', '  function getOrder (uint256 _oID) \n', '    public\n', '    view\n', '    returns (uint256, uint256, uint256, uint, uint256)\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (oID_Order_[_oID].pID == addr_pID_[msg.sender], "only owner can get its order");\n', '\n', '    return \n', '    (\n', '      oID_Order_[_oID].createTime,\n', '      oID_Order_[_oID].createDayIndex,\n', '      oID_Order_[_oID].orderValue,\n', '      getOrderStateHelper(_nowDayIndex, _oID),\n', '      getOrderActualTotalRefundHelper(_nowDayIndex, _oID)\n', '    );\n', '  }\n', '\n', '  function getOverall ()\n', '    public\n', '    view \n', '    returns (uint256, uint256, uint256, uint256, uint256, bool, uint256)\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '    uint256 _tommorrow = _nowDayIndex.mul(1 days).add(activated_time_);\n', '    bool _isWithinDayEthInLimits = day_ethIn[_nowDayIndex] < dayEthInLimit_ ? true : false;\n', '\n', '    return (\n', '      _now,\n', '      _nowDayIndex,\n', '      _tommorrow,\n', '      ethIn_,\n', '      dayEthInLimit_,\n', '      _isWithinDayEthInLimits,\n', '      playerDayEthInLimit_\n', '    ); \n', '  }\n', '\n', '  function getOrderActualTotalRefundHelper (uint256 _nowDayIndex, uint256 _oID) \n', '    internal\n', '    view \n', '    returns (uint256)\n', '  {\n', '    if (oID_Order_[_oID].hasWithdrawn) {\n', '      return\n', '      (\n', '        oID_Order_[_oID].withdrawn\n', '      );\n', '    }\n', '\n', '    uint256 _actualTotalRefund = oID_Order_[_oID].orderValue.mul(60).div(100);\n', '    uint256 _dayGap = _nowDayIndex.sub(oID_Order_[_oID].createDayIndex);\n', '    if (_dayGap > 0) {\n', '      _dayGap = _dayGap > 5 ? 5 : _dayGap;\n', '      uint256 _maxRefund = oID_Order_[_oID].orderValue.mul(12).mul(_dayGap).div(100);\n', '\n', '      if (oID_Order_[_oID].refund < _maxRefund)\n', '      {\n', '        _actualTotalRefund = _actualTotalRefund.add(oID_Order_[_oID].refund);\n', '      } \n', '      else \n', '      {\n', '        _actualTotalRefund = _actualTotalRefund.add(_maxRefund);\n', '      }\n', '    }\n', '    return\n', '    (\n', '      _actualTotalRefund\n', '    );\n', '  }\n', '\n', '}\n', 'contract WithdrawPopo is InspectorPopo {\n', '\n', '  function withdrawOrderRefund(uint256 _oID)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    require (_order.pID == addr_pID_[msg.sender], "only owner can withdraw");\n', '    require (!_order.hasWithdrawn, "order refund has been withdrawn");\n', '\n', '    uint256 _actualTotalRefund = getOrderActualTotalRefundHelper(_nowDayIndex, _oID);\n', '    require (_actualTotalRefund > 0, "no order refund need to be withdrawn");\n', '\n', '    msg.sender.transfer(_actualTotalRefund);\n', '\n', '    oID_Order_[_oID].withdrawn = _actualTotalRefund;\n', '    oID_Order_[_oID].hasWithdrawn = true;\n', '\n', '    uint256 _totalRefund = _order.orderValue.mul(60).div(100);\n', '    _totalRefund = _totalRefund.add(_order.refund);\n', '    communityPot_ = communityPot_.add(_totalRefund.sub(_actualTotalRefund));\n', '\n', '    emit PopoEvents.onWithdrawOrderRefund\n', '    (\n', '      _order.pID,\n', '      msg.sender,\n', '      _oID,\n', '      _actualTotalRefund,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawOrderRefundToOrder(uint256 _oID)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    require (_order.pID == addr_pID_[msg.sender], "only owner can withdraw");\n', '    require (!_order.hasWithdrawn, "order refund has been withdrawn");\n', '\n', '    uint256 _actualTotalRefund = getOrderActualTotalRefundHelper(_nowDayIndex, _oID);\n', '    require (_actualTotalRefund > 0, "no order refund need to be withdrawn");\n', '\n', '    orderInternal(_actualTotalRefund, pID_Player_[pID_Player_[_order.pID].inviterPID].name);\n', '\n', '    oID_Order_[_oID].withdrawn = _actualTotalRefund;\n', '    oID_Order_[_oID].hasWithdrawn = true;\n', '\n', '    uint256 _totalRefund = _order.orderValue.mul(60).div(100);\n', '    _totalRefund = _totalRefund.add(_order.refund);\n', '    communityPot_ = communityPot_.add(_totalRefund.sub(_actualTotalRefund));\n', '\n', '    emit PopoEvents.onWithdrawOrderRefundToOrder\n', '    (\n', '      _order.pID,\n', '      msg.sender,\n', '      _oID,\n', '      _actualTotalRefund,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawInviteReward ()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    uint256 _withdrawal = pID_Player_[_pID].inviteReward1\n', '                            .add(pID_Player_[_pID].inviteReward2)\n', '                            .add(pID_Player_[_pID].inviteReward3)\n', '                            .sub(pID_Player_[_pID].inviteRewardWithdrawn);\n', '    require (_withdrawal > 0, "you have no invite reward to withdraw");\n', '\n', '    msg.sender.transfer(_withdrawal);\n', '\n', '    pID_Player_[_pID].inviteRewardWithdrawn = pID_Player_[_pID].inviteRewardWithdrawn.add(_withdrawal);\n', '\n', '    emit PopoEvents.onWithdrawInviteReward\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _withdrawal,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawInviteRewardToOrder ()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    uint256 _withdrawal = pID_Player_[_pID].inviteReward1\n', '                            .add(pID_Player_[_pID].inviteReward2)\n', '                            .add(pID_Player_[_pID].inviteReward3)\n', '                            .sub(pID_Player_[_pID].inviteRewardWithdrawn);\n', '    require (_withdrawal > 0, "you have no invite reward to withdraw");\n', '\n', '    orderInternal(_withdrawal, pID_Player_[pID_Player_[_pID].inviterPID].name);\n', '\n', '    pID_Player_[_pID].inviteRewardWithdrawn = pID_Player_[_pID].inviteRewardWithdrawn.add(_withdrawal);\n', '\n', '    emit PopoEvents.onWithdrawInviteRewardToOrder\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _withdrawal,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawTeamPot ()\n', '    onlyCEO()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    if (teamPot_ <= 0) {\n', '      return;\n', '    }\n', '\n', '    msg.sender.transfer(teamPot_);\n', '    teamPot_ = 0;\n', '  }\n', '\n', '  function withdrawCommunityPot ()\n', '    onlyCommunityLeader()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    if (communityPot_ <= 0) {\n', '      return;\n', '    }\n', '\n', '    msg.sender.transfer(communityPot_);\n', '    communityPot_ = 0;\n', '  }\n', '\n', '}\n', 'contract Popo is WithdrawPopo {\n', '  \n', '  constructor()\n', '    public \n', '  {\n', '\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.24;\n', '/**\n', ' * @title POPO v1.3.1\n', ' *\n', ' * This product is protected under license.  Any unauthorized copy, modification, or use without \n', ' * express written consent from the creators is prohibited.\n', ' * \n', ' * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY.\n', ' */\n', '// Author: https://playpopo.com\n', '// Contact: playpopoteam@gmail.com\n', 'library PopoDatasets {\n', '\n', '  struct Order {\n', '    uint256 pID;\n', '    uint256 createTime;\n', '    uint256 createDayIndex;\n', '    uint256 orderValue;\n', '    uint256 refund;\n', '    uint256 withdrawn;\n', '    bool hasWithdrawn;\n', '  }\n', '  \n', '  struct Player {\n', '    address addr;\n', '    bytes32 name;\n', '\n', '    bool inviteEnable;\n', '    uint256 inviterPID;\n', '    uint256 [] inviteePIDs;\n', '    uint256 inviteReward1;\n', '    uint256 inviteReward2;\n', '    uint256 inviteReward3;\n', '    uint256 inviteRewardWithdrawn;\n', '\n', '    uint256 [] oIDs;\n', '    uint256 lastOrderDayIndex;\n', '    uint256 dayEthIn;\n', '  }\n', '\n', '}\n', 'contract PopoEvents {\n', '\n', '  event onEnableInvite\n', '  (\n', '    uint256 pID,\n', '    address pAddr,\n', '    bytes32 pName,\n', '    uint256 timeStamp\n', '  );\n', '  \n', '\n', '  event onSetInviter\n', '  (\n', '    uint256 pID,\n', '    address pAddr,\n', '    uint256 indexed inviterPID,\n', '    address indexed inviterAddr,\n', '    bytes32 indexed inviterName,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 indexed dayIndex,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawOrderRefund\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawOrderRefundToOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 oID,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawInviteReward\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '\n', '  event onWithdrawInviteRewardToOrder\n', '  (\n', '    uint256 indexed pID,\n', '    address indexed pAddr,\n', '    uint256 value,\n', '    uint256 timeStamp\n', '  );\n', '    \n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'library NameFilter {\n', '  \n', '    using SafeMath for *;\n', '\n', '    /**\n', '     * @dev filters name strings\n', '     * -converts uppercase to lower case.  \n', '     * -makes sure it does not start/end with a space\n', '     * -makes sure it does not contain multiple spaces in a row\n', '     * -cannot be only numbers\n', '     * -cannot start with 0x \n', '     * -restricts characters to A-Z, a-z, 0-9, and space.\n', '     * @return reprocessed string in bytes32 format\n', '     */\n', '    function nameFilter(string _input)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        bytes memory _temp = bytes(_input);\n', '        uint256 _length = _temp.length;\n', '        \n', '        //sorry limited to 32 characters\n', '        require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");\n', '        // make sure it doesnt start with or end with space\n', '        require(_temp[0] != 0x20 && _temp[_length.sub(1)] != 0x20, "string cannot start or end with space");\n', '        // make sure first two characters are not 0x\n', '        if (_temp[0] == 0x30)\n', '        {\n', '            require(_temp[1] != 0x78, "string cannot start with 0x");\n', '            require(_temp[1] != 0x58, "string cannot start with 0X");\n', '        }\n', '        \n', '        // create a bool to track if we have a non number character\n', '        bool _hasNonNumber;\n', '        \n', '        // convert & check\n', '        for (uint256 i = 0; i < _length; i = i.add(1))\n', '        {\n', '            // if its uppercase A-Z\n', '            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n', '            {\n', '                // convert to lower case a-z\n', '                _temp[i] = byte(uint(_temp[i]) + 32);\n', '                \n', '                // we have a non number\n', '                if (_hasNonNumber == false)\n', '                    _hasNonNumber = true;\n', '            } else {\n', '                require\n', '                (\n', '                    // require character is a space\n', '                    _temp[i] == 0x20 || \n', '                    // OR lowercase a-z\n', '                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n', '                    // or 0-9\n', '                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n', '                    "string contains invalid characters"\n', '                );\n', '                // make sure theres not 2x spaces in a row\n', '                if (_temp[i] == 0x20)\n', '                    require(_temp[i.add(1)] != 0x20, "string cannot contain consecutive spaces");\n', '                \n', '                // see if we have a character other than a number\n', '                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n', '                    _hasNonNumber = true;    \n', '            }\n', '        }\n', '        \n', '        require(_hasNonNumber == true, "string cannot be only numbers");\n', '        \n', '        bytes32 _ret;\n', '        assembly {\n', '            _ret := mload(add(_temp, 32))\n', '        }\n', '        return (_ret);\n', '    }\n', '}\n', 'contract SafePopo {\n', '\n', '  using SafeMath for *;\n', '\n', '  bool public activated_;\n', '  uint256 public activated_time_;\n', '\n', '  modifier isHuman() {\n', '    address _addr = msg.sender;\n', '    uint256 _codeLength;\n', '      \n', '    assembly {_codeLength := extcodesize(_addr)}\n', '    require (_codeLength == 0, "sorry humans only");\n', '    _;\n', '  }\n', '\n', '  modifier isWithinLimits(uint256 _eth) {\n', '    require (_eth >= 0.1 ether, "0.1 ether at least");\n', '    require (_eth <= 10000000 ether, "no, too much ether");\n', '    _;    \n', '  }\n', '\n', '  modifier isActivated() {\n', '    require (activated_ == true, "popo is not activated"); \n', '    _;\n', '  }\n', '\n', '  modifier onlyCEO() {\n', '    require \n', '    (\n', '      msg.sender == 0x5927774a0438f452747b847E4e9097884DA6afE9 || \n', '      msg.sender == 0xA2CDecFe929Eccbd519A6c98b1220b16f5b6B0B5\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCommunityLeader() { \n', '    require \n', '    (\n', '      msg.sender == 0xede5Adf9F68C02537Cc1737CFF4506BCfFAAB63d || \n', '      msg.sender == 0x7400A7B7D67814B0d8B27362CC198F4Ae2840e16\n', '    );\n', '    _;\n', '  }\n', '\n', '  function activate() \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    require (activated_ == false, "popo has been activated already");\n', '\n', '    activated_ = true;\n', '    activated_time_ = now;\n', '  }\n', '  \n', '}\n', 'contract CorePopo is SafePopo, PopoEvents {\n', '\n', '  uint256 public startTime_;\n', '\n', '  uint256 public teamPot_;\n', '  uint256 public communityPot_;\n', '  \n', '  mapping (uint256 => uint256) public day_ethIn;\n', '  uint256 public ethIn_;\n', '\n', '  uint256 public dayEthInLimit_ = 300 ether;\n', '  uint256 public playerDayEthInLimit_ = 10 ether;\n', '\n', '  uint256 public pIDIndex_;\n', '  mapping (uint256 => PopoDatasets.Player) public pID_Player_;\n', '  mapping (address => uint256) public addr_pID_;\n', '  mapping (bytes32 => uint256) public name_pID_;\n', '\n', '  mapping (uint256 => uint256) public inviteePID_inviteReward1_;\n', '\n', '  uint256 public oIDIndex_;\n', '  mapping (uint256 => PopoDatasets.Order) public oID_Order_;\n', '\n', '  uint256 [] public refundOIDs_;\n', '  uint256 public refundOIDIndex_;\n', '\n', '  function determinePID ()\n', '    internal\n', '  {\n', '    if (addr_pID_[msg.sender] != 0) {\n', '      return;\n', '    }\n', '\n', '    pIDIndex_ = pIDIndex_.add(1);\n', '    \n', '    pID_Player_[pIDIndex_].addr = msg.sender;\n', '\n', '    addr_pID_[msg.sender] = pIDIndex_;\n', '  }\n', '\n', '  function getDayIndex (uint256 _time)\n', '    internal\n', '    view\n', '    returns (uint256) \n', '  {\n', '    return _time.sub(activated_time_).div(1 days).add(1);\n', '  }\n', '  \n', '}\n', 'contract InvitePopo is CorePopo {\n', '\n', '  using NameFilter for string;\n', '  \n', '  function enableInvite (string _nameString, bytes32 _inviterName)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '    payable\n', '  {\n', '    require (msg.value == 0.01 ether, "enable invite need 0.01 ether");     \n', '\n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '   \n', '    require (pID_Player_[addr_pID_[msg.sender]].inviteEnable == false, "you can only enable invite once");\n', '\n', '    bytes32 _name = _nameString.nameFilter();\n', '    require (name_pID_[_name] == 0, "your name is already registered by others");\n', '    \n', '    pID_Player_[addr_pID_[msg.sender]].name = _name;\n', '    pID_Player_[addr_pID_[msg.sender]].inviteEnable = true;\n', '\n', '    name_pID_[_name] = addr_pID_[msg.sender];\n', '\n', '    communityPot_ = communityPot_.add(msg.value);\n', '\n', '    emit PopoEvents.onEnableInvite\n', '    (\n', '      addr_pID_[msg.sender],\n', '      msg.sender,\n', '      _name,\n', '      now\n', '    );\n', '  }\n', '\n', '  function enableInviteOfSU (string _nameString) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    determinePID();\n', '   \n', '    require (pID_Player_[addr_pID_[msg.sender]].inviteEnable == false, "you can only enable invite once");\n', '\n', '    bytes32 _name = _nameString.nameFilter();\n', '    require (name_pID_[_name] == 0, "your name is already registered by others");\n', '    \n', '    name_pID_[_name] = addr_pID_[msg.sender];\n', '\n', '    pID_Player_[addr_pID_[msg.sender]].name = _name;\n', '    pID_Player_[addr_pID_[msg.sender]].inviteEnable = true;\n', '  }\n', '\n', '  function determineInviter (uint256 _pID, bytes32 _inviterName) \n', '    internal\n', '  {\n', '    if (pID_Player_[_pID].inviterPID != 0) {\n', '      return;\n', '    }\n', '\n', '    uint256 _inviterPID = name_pID_[_inviterName];\n', '    require (_inviterPID != 0, "your inviter name must be registered");\n', '    require (pID_Player_[_inviterPID].inviteEnable == true, "your inviter must enable invite");\n', '    require (_inviterPID != _pID, "you can not invite yourself");\n', '\n', '    pID_Player_[_pID].inviterPID = _inviterPID;\n', '\n', '    emit PopoEvents.onSetInviter\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _inviterPID,\n', '      pID_Player_[_inviterPID].addr,\n', '      _inviterName,\n', '      now\n', '    );\n', '  }\n', '\n', '  function distributeInviteReward (uint256 _pID, uint256 _inviteReward1, uint256 _inviteReward2, uint256 _inviteReward3, uint256 _percent) \n', '    internal\n', '    returns (uint256)\n', '  {\n', '    uint256 inviterPID = pID_Player_[_pID].inviterPID;\n', '    if (pID_Player_[inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID].inviteReward1 = pID_Player_[inviterPID].inviteReward1.add(_inviteReward1);\n', '\n', '      if (inviteePID_inviteReward1_[_pID] == 0) {\n', '        pID_Player_[inviterPID].inviteePIDs.push(_pID);\n', '      }\n', '      inviteePID_inviteReward1_[_pID] = inviteePID_inviteReward1_[_pID].add(_inviteReward1);\n', '\n', '      _percent = _percent.sub(5);\n', '    } \n', '    \n', '    uint256 inviterPID_inviterPID = pID_Player_[inviterPID].inviterPID;\n', '    if (pID_Player_[inviterPID_inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID_inviterPID].inviteReward2 = pID_Player_[inviterPID_inviterPID].inviteReward2.add(_inviteReward2);\n', '\n', '      _percent = _percent.sub(2);\n', '    }\n', '\n', '    uint256 inviterPID_inviterPID_inviterPID = pID_Player_[inviterPID_inviterPID].inviterPID;\n', '    if (pID_Player_[inviterPID_inviterPID_inviterPID].inviteEnable) \n', '    {\n', '      pID_Player_[inviterPID_inviterPID_inviterPID].inviteReward3 = pID_Player_[inviterPID_inviterPID_inviterPID].inviteReward3.add(_inviteReward3);\n', '\n', '      _percent = _percent.sub(1);\n', '    } \n', '\n', '    return\n', '    (\n', '      _percent\n', '    );\n', '  }\n', '  \n', '}\n', 'contract OrderPopo is InvitePopo {\n', '\n', '  function setDayEthInLimit (uint256 dayEthInLimit) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    dayEthInLimit_ = dayEthInLimit;\n', '  }\n', '\n', '  function setPlayerDayEthInLimit (uint256 playerDayEthInLimit) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '  {\n', '    playerDayEthInLimit_ = playerDayEthInLimit;\n', '  }\n', '  \n', '  function order (bytes32 _inviterName)\n', '    isActivated()\n', '    isHuman()\n', '    isWithinLimits(msg.value)\n', '    public\n', '    payable\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (_nowDayIndex > 2, "only third day can order");\n', '            \n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '\n', '    orderCore(_now, _nowDayIndex, msg.value);\n', '  }\n', '\n', '  function orderInternal (uint256 _value, bytes32 _inviterName)\n', '    internal\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (_nowDayIndex > 2, "only third day can order");\n', '            \n', '    determinePID();\n', '    determineInviter(addr_pID_[msg.sender], _inviterName);\n', '\n', '    orderCore(_now, _nowDayIndex, _value);\n', '  }\n', '\n', '  function orderCore (uint256 _now, uint256 _nowDayIndex, uint256 _value)\n', '    private\n', '  {\n', '    teamPot_ = teamPot_.add(_value.mul(3).div(100));\n', '    communityPot_ = communityPot_.add(_value.mul(4).div(100));\n', '\n', '    require (day_ethIn[_nowDayIndex] < dayEthInLimit_, "beyond the day eth in limit");\n', '    day_ethIn[_nowDayIndex] = day_ethIn[_nowDayIndex].add(_value);\n', '    ethIn_ = ethIn_.add(_value);\n', '\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    if (pID_Player_[_pID].lastOrderDayIndex == _nowDayIndex) {\n', '      require (pID_Player_[_pID].dayEthIn < playerDayEthInLimit_, "beyond the player day eth in limit");\n', '      pID_Player_[_pID].dayEthIn = pID_Player_[_pID].dayEthIn.add(_value);\n', '    } else {\n', '      pID_Player_[_pID].lastOrderDayIndex = _nowDayIndex;\n', '      pID_Player_[_pID].dayEthIn = _value;\n', '    }\n', '\n', '    oIDIndex_ = oIDIndex_.add(1);\n', '    \n', '    oID_Order_[oIDIndex_].pID = _pID;\n', '    oID_Order_[oIDIndex_].createTime = _now;\n', '    oID_Order_[oIDIndex_].createDayIndex = _nowDayIndex;\n', '    oID_Order_[oIDIndex_].orderValue = _value;\n', '\n', '    pID_Player_[_pID].oIDs.push(oIDIndex_);\n', '\n', '    refundOIDs_.push(oIDIndex_);\n', '\n', '    uint256 _percent = 33;\n', '    if (pID_Player_[_pID].oIDs.length < 3) {\n', '      _percent = distributeInviteReward(_pID, _value.mul(5).div(100), _value.mul(2).div(100), _value.mul(1).div(100), _percent);\n', '      refund(_nowDayIndex, _value.mul(_percent).div(100));\n', '    } else {\n', '      refund(_nowDayIndex, _value.mul(_percent).div(100));\n', '    }\n', '\n', '    emit PopoEvents.onOrder\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _nowDayIndex,\n', '      oIDIndex_,\n', '      _value,\n', '      now\n', '    );\n', '  }\n', '\n', '  function refund (uint256 _nowDayIndex, uint256 _pot)\n', '    private\n', '  {\n', '    while\n', '    (\n', '      (_pot > 0) &&\n', '      (refundOIDIndex_ < refundOIDs_.length)\n', '    )\n', '    {\n', '      (_pot, refundOIDIndex_) = doRefund(_nowDayIndex, refundOIDIndex_, _pot);\n', '    }\n', '  }\n', '  \n', '  function doRefund (uint256 _nowDayIndex, uint256 _refundOIDIndex, uint256 _pot)\n', '    private\n', '    returns (uint256, uint256)\n', '  {\n', '    uint256 _refundOID = refundOIDs_[_refundOIDIndex];\n', '\n', '    uint _orderState = getOrderStateHelper(_nowDayIndex, _refundOID);\n', '    if (_orderState != 1) {\n', '      return\n', '      (\n', '        _pot,\n', '        _refundOIDIndex.add(1)\n', '      );\n', '    }\n', '\n', '    uint256 _maxRefund = oID_Order_[_refundOID].orderValue.mul(60).div(100);\n', '    if (oID_Order_[_refundOID].refund < _maxRefund) {\n', '      uint256 _needRefund = _maxRefund.sub(oID_Order_[_refundOID].refund);\n', '\n', '      if \n', '      (\n', '        _needRefund > _pot\n', '      ) \n', '      {\n', '        oID_Order_[_refundOID].refund = oID_Order_[_refundOID].refund.add(_pot);\n', '\n', '        return\n', '        (\n', '          0,\n', '          _refundOIDIndex\n', '        );\n', '      } \n', '      else\n', '      {\n', '        oID_Order_[_refundOID].refund = oID_Order_[_refundOID].refund.add(_needRefund);\n', '\n', '        return\n', '        (\n', '          _pot.sub(_needRefund),\n', '          _refundOIDIndex.add(1)\n', '        );\n', '      }\n', '    }\n', '    else\n', '    {\n', '      return\n', '      (\n', '        _pot,\n', '        _refundOIDIndex.add(1)\n', '      );\n', '    }\n', '  }\n', '\n', '  function getOrderStateHelper (uint256 _nowDayIndex, uint256 _oID)\n', '    internal\n', '    view\n', '    returns (uint)\n', '  {\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    \n', '    if \n', '    (\n', '      _order.hasWithdrawn\n', '    ) \n', '    {\n', '      return\n', '      (\n', '        3\n', '      );\n', '    } \n', '    else \n', '    {\n', '      if \n', '      (\n', '        _nowDayIndex < _order.createDayIndex || \n', '        _nowDayIndex > _order.createDayIndex.add(5)\n', '      )\n', '      {\n', '        return\n', '        (\n', '          2\n', '        );\n', '      }\n', '      else \n', '      {\n', '        return\n', '        (\n', '          1\n', '        );\n', '      }\n', '    }\n', '  }\n', '  \n', '}\n', 'contract InspectorPopo is OrderPopo {\n', '\n', '  function getAdminDashboard () \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256, uint256)\n', '  {\n', '    return\n', '    (\n', '      teamPot_,\n', '      communityPot_\n', '    ); \n', '  }\n', '\n', '  function getDayEthIn (uint256 _dayIndex) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256)\n', '  {\n', '    return\n', '    (\n', '      day_ethIn[_dayIndex]\n', '    ); \n', '  }\n', '\n', '  function getAddressLost (address _addr) \n', '    onlyCEO()\n', '    onlyCommunityLeader()\n', '    public\n', '    view \n', '    returns (uint256) \n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    uint256 pID = addr_pID_[_addr];\n', '    require (pID != 0, "address need to be registered");\n', '    \n', '    uint256 _orderValue = 0;\n', '    uint256 _actualTotalRefund = 0;\n', '\n', '    uint256 [] memory _oIDs = pID_Player_[pID].oIDs;\n', '    for (uint256 _index = 0; _index < _oIDs.length; _index = _index.add(1)) {\n', '      PopoDatasets.Order memory _order = oID_Order_[_oIDs[_index]];\n', '      _orderValue = _orderValue.add(_order.orderValue);\n', '      _actualTotalRefund = _actualTotalRefund.add(getOrderActualTotalRefundHelper(_nowDayIndex, _oIDs[_index]));\n', '    }\n', '\n', '    if (_orderValue > _actualTotalRefund) {\n', '      return \n', '      (\n', '        _orderValue.sub(_actualTotalRefund)\n', '      );\n', '    }\n', '    else\n', '    {\n', '      return \n', '      (\n', '        0\n', '      );\n', '    }\n', '  }\n', '\n', '  function getInviteInfo () \n', '    public\n', '    view\n', '    returns (bool, bytes32, uint256, bytes32, uint256, uint256, uint256, uint256)\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    return \n', '    (\n', '      pID_Player_[_pID].inviteEnable,\n', '      pID_Player_[_pID].name,\n', '      pID_Player_[_pID].inviterPID,\n', '      pID_Player_[pID_Player_[_pID].inviterPID].name,\n', '      pID_Player_[_pID].inviteReward1,\n', '      pID_Player_[_pID].inviteReward2,\n', '      pID_Player_[_pID].inviteReward3,\n', '      pID_Player_[_pID].inviteRewardWithdrawn\n', '    );\n', '  }\n', '\n', '  function getInviteePIDs () \n', '    public\n', '    view\n', '    returns (uint256 []) \n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    return \n', '    (\n', '      pID_Player_[_pID].inviteePIDs\n', '    );\n', '  }\n', '\n', '  function getInviteeInfo (uint256 _inviteePID) \n', '    public\n', '    view\n', '    returns (uint256, bytes32) \n', '  {\n', '\n', '    require (pID_Player_[_inviteePID].inviterPID == addr_pID_[msg.sender], "you must have invited this player");\n', '\n', '    return \n', '    (\n', '      inviteePID_inviteReward1_[_inviteePID],\n', '      pID_Player_[_inviteePID].name\n', '    );\n', '  }\n', '\n', '  function getOrderInfo () \n', '    public\n', '    view\n', '    returns (bool, uint256 []) \n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    bool _isWithinPlayerDayEthInLimits = true;\n', '    if\n', '    (\n', '      (pID_Player_[_pID].lastOrderDayIndex == _nowDayIndex) &&\n', '      (pID_Player_[_pID].dayEthIn >= playerDayEthInLimit_) \n', '    )\n', '    {\n', '      _isWithinPlayerDayEthInLimits = false;\n', '    }\n', '\n', '    return \n', '    (\n', '      _isWithinPlayerDayEthInLimits,\n', '      pID_Player_[_pID].oIDs\n', '    );\n', '  }\n', '\n', '  function getOrder (uint256 _oID) \n', '    public\n', '    view\n', '    returns (uint256, uint256, uint256, uint, uint256)\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    require (oID_Order_[_oID].pID == addr_pID_[msg.sender], "only owner can get its order");\n', '\n', '    return \n', '    (\n', '      oID_Order_[_oID].createTime,\n', '      oID_Order_[_oID].createDayIndex,\n', '      oID_Order_[_oID].orderValue,\n', '      getOrderStateHelper(_nowDayIndex, _oID),\n', '      getOrderActualTotalRefundHelper(_nowDayIndex, _oID)\n', '    );\n', '  }\n', '\n', '  function getOverall ()\n', '    public\n', '    view \n', '    returns (uint256, uint256, uint256, uint256, uint256, bool, uint256)\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '    uint256 _tommorrow = _nowDayIndex.mul(1 days).add(activated_time_);\n', '    bool _isWithinDayEthInLimits = day_ethIn[_nowDayIndex] < dayEthInLimit_ ? true : false;\n', '\n', '    return (\n', '      _now,\n', '      _nowDayIndex,\n', '      _tommorrow,\n', '      ethIn_,\n', '      dayEthInLimit_,\n', '      _isWithinDayEthInLimits,\n', '      playerDayEthInLimit_\n', '    ); \n', '  }\n', '\n', '  function getOrderActualTotalRefundHelper (uint256 _nowDayIndex, uint256 _oID) \n', '    internal\n', '    view \n', '    returns (uint256)\n', '  {\n', '    if (oID_Order_[_oID].hasWithdrawn) {\n', '      return\n', '      (\n', '        oID_Order_[_oID].withdrawn\n', '      );\n', '    }\n', '\n', '    uint256 _actualTotalRefund = oID_Order_[_oID].orderValue.mul(60).div(100);\n', '    uint256 _dayGap = _nowDayIndex.sub(oID_Order_[_oID].createDayIndex);\n', '    if (_dayGap > 0) {\n', '      _dayGap = _dayGap > 5 ? 5 : _dayGap;\n', '      uint256 _maxRefund = oID_Order_[_oID].orderValue.mul(12).mul(_dayGap).div(100);\n', '\n', '      if (oID_Order_[_oID].refund < _maxRefund)\n', '      {\n', '        _actualTotalRefund = _actualTotalRefund.add(oID_Order_[_oID].refund);\n', '      } \n', '      else \n', '      {\n', '        _actualTotalRefund = _actualTotalRefund.add(_maxRefund);\n', '      }\n', '    }\n', '    return\n', '    (\n', '      _actualTotalRefund\n', '    );\n', '  }\n', '\n', '}\n', 'contract WithdrawPopo is InspectorPopo {\n', '\n', '  function withdrawOrderRefund(uint256 _oID)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    require (_order.pID == addr_pID_[msg.sender], "only owner can withdraw");\n', '    require (!_order.hasWithdrawn, "order refund has been withdrawn");\n', '\n', '    uint256 _actualTotalRefund = getOrderActualTotalRefundHelper(_nowDayIndex, _oID);\n', '    require (_actualTotalRefund > 0, "no order refund need to be withdrawn");\n', '\n', '    msg.sender.transfer(_actualTotalRefund);\n', '\n', '    oID_Order_[_oID].withdrawn = _actualTotalRefund;\n', '    oID_Order_[_oID].hasWithdrawn = true;\n', '\n', '    uint256 _totalRefund = _order.orderValue.mul(60).div(100);\n', '    _totalRefund = _totalRefund.add(_order.refund);\n', '    communityPot_ = communityPot_.add(_totalRefund.sub(_actualTotalRefund));\n', '\n', '    emit PopoEvents.onWithdrawOrderRefund\n', '    (\n', '      _order.pID,\n', '      msg.sender,\n', '      _oID,\n', '      _actualTotalRefund,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawOrderRefundToOrder(uint256 _oID)\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _now = now;\n', '    uint256 _nowDayIndex = getDayIndex(_now);\n', '\n', '    PopoDatasets.Order memory _order = oID_Order_[_oID];\n', '    require (_order.pID == addr_pID_[msg.sender], "only owner can withdraw");\n', '    require (!_order.hasWithdrawn, "order refund has been withdrawn");\n', '\n', '    uint256 _actualTotalRefund = getOrderActualTotalRefundHelper(_nowDayIndex, _oID);\n', '    require (_actualTotalRefund > 0, "no order refund need to be withdrawn");\n', '\n', '    orderInternal(_actualTotalRefund, pID_Player_[pID_Player_[_order.pID].inviterPID].name);\n', '\n', '    oID_Order_[_oID].withdrawn = _actualTotalRefund;\n', '    oID_Order_[_oID].hasWithdrawn = true;\n', '\n', '    uint256 _totalRefund = _order.orderValue.mul(60).div(100);\n', '    _totalRefund = _totalRefund.add(_order.refund);\n', '    communityPot_ = communityPot_.add(_totalRefund.sub(_actualTotalRefund));\n', '\n', '    emit PopoEvents.onWithdrawOrderRefundToOrder\n', '    (\n', '      _order.pID,\n', '      msg.sender,\n', '      _oID,\n', '      _actualTotalRefund,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawInviteReward ()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    uint256 _withdrawal = pID_Player_[_pID].inviteReward1\n', '                            .add(pID_Player_[_pID].inviteReward2)\n', '                            .add(pID_Player_[_pID].inviteReward3)\n', '                            .sub(pID_Player_[_pID].inviteRewardWithdrawn);\n', '    require (_withdrawal > 0, "you have no invite reward to withdraw");\n', '\n', '    msg.sender.transfer(_withdrawal);\n', '\n', '    pID_Player_[_pID].inviteRewardWithdrawn = pID_Player_[_pID].inviteRewardWithdrawn.add(_withdrawal);\n', '\n', '    emit PopoEvents.onWithdrawInviteReward\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _withdrawal,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawInviteRewardToOrder ()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    uint256 _pID = addr_pID_[msg.sender];\n', '\n', '    uint256 _withdrawal = pID_Player_[_pID].inviteReward1\n', '                            .add(pID_Player_[_pID].inviteReward2)\n', '                            .add(pID_Player_[_pID].inviteReward3)\n', '                            .sub(pID_Player_[_pID].inviteRewardWithdrawn);\n', '    require (_withdrawal > 0, "you have no invite reward to withdraw");\n', '\n', '    orderInternal(_withdrawal, pID_Player_[pID_Player_[_pID].inviterPID].name);\n', '\n', '    pID_Player_[_pID].inviteRewardWithdrawn = pID_Player_[_pID].inviteRewardWithdrawn.add(_withdrawal);\n', '\n', '    emit PopoEvents.onWithdrawInviteRewardToOrder\n', '    (\n', '      _pID,\n', '      msg.sender,\n', '      _withdrawal,\n', '      now\n', '    );\n', '  }\n', '\n', '  function withdrawTeamPot ()\n', '    onlyCEO()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    if (teamPot_ <= 0) {\n', '      return;\n', '    }\n', '\n', '    msg.sender.transfer(teamPot_);\n', '    teamPot_ = 0;\n', '  }\n', '\n', '  function withdrawCommunityPot ()\n', '    onlyCommunityLeader()\n', '    isActivated()\n', '    isHuman()\n', '    public\n', '  {\n', '    if (communityPot_ <= 0) {\n', '      return;\n', '    }\n', '\n', '    msg.sender.transfer(communityPot_);\n', '    communityPot_ = 0;\n', '  }\n', '\n', '}\n', 'contract Popo is WithdrawPopo {\n', '  \n', '  constructor()\n', '    public \n', '  {\n', '\n', '  }\n', '  \n', '}']
