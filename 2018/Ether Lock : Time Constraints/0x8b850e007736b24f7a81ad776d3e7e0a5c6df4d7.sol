['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '     return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\taddress public newOwner;\n', '\n', '\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner, "msg.sender == owner");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(address(0) != _newOwner, "address(0) != _newOwner");\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == newOwner, "msg.sender == newOwner");\n', '\t\temit OwnershipTransferred(owner, msg.sender);\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '}\n', '\n', 'contract tokenInterface {\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool);\n', '\tfunction burn(uint256 _value) public returns(bool);\n', '\tuint256 public totalSupply;\n', '\tuint256 public decimals;\n', '}\n', '\n', 'contract AtomaxKycInterface {\n', '\n', '    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\n', '    function started() public view returns(bool);\n', '\n', '    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\n', '    function ended() public view returns(bool);\n', '\n', '    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\n', '    function startTime() public view returns(uint256);\n', '\n', '    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\n', '    function endTime() public view returns(uint256);\n', '\n', '    // returns the total number of the tokens available for the sale, must not change when the ico is started\n', '    function totalTokens() public view returns(uint256);\n', '\n', '    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\n', '    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\n', '    function remainingTokens() public view returns(uint256);\n', '\n', '    // return the price as number of tokens released for each ether\n', '    function price() public view returns(uint256);\n', '}\n', '\n', 'contract AtomaxKyc {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => bool) public isKycSigner;\n', '    mapping (bytes32 => uint256) public alreadyPayed;\n', '\n', '    event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount);\n', '\n', '    constructor() internal {\n', '        isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; //ATOMAX KYC 1 SIGNER\n', '        isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; //ATOMAX KYC 2 SIGNER\n', '    }\n', '\n', '    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\n', '    function releaseTokensTo(address buyer) internal returns(bool);\n', '\n', '    \n', '    function buyTokensFor(address _buyerAddress, bytes32 _buyerId, uint _maxAmount, uint8 _v, bytes32 _r, bytes32 _s, uint8 _bv, bytes32 _br, bytes32 _bs) public payable returns (bool) {\n', '        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\n', '        address signer = ecrecover(hash, _bv, _br, _bs);\n', '        require ( signer == _buyerAddress, "signer == _buyerAddress " );\n', '        \n', '        return buyImplementation(_buyerAddress, _buyerId, _maxAmount, _v, _r, _s);\n', '    }\n', '    \n', '    function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) {\n', '        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\n', '    }\n', '\n', '    function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) {\n', '        // check the signature\n', '        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\n', '        address signer = ecrecover(hash, _v, _r, _s);\n', '\t\t\n', '\t\trequire( isKycSigner[signer], "isKycSigner[signer]");\n', '        \n', '\t\tuint256 totalPayed = alreadyPayed[_buyerId].add(msg.value);\n', '\t\trequire(totalPayed <= _maxAmount);\n', '\t\talreadyPayed[_buyerId] = totalPayed;\n', '\t\t\n', '\t\temit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount);\n', '\t\treturn releaseTokensTo(_buyerAddress);\n', '\n', '    }\n', '    \n', '    function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) {\n', '        hash = keccak256(abi.encodePacked("Atomax authorization:", this, _buyerAddress, _buyerId, _maxAmount));\n', '    }\n', '}\n', '\n', 'contract RC_KYC is AtomaxKycInterface, AtomaxKyc {\n', '    using SafeMath for uint256;\n', '    \n', '    TokedoDaico tokenSaleContract;\n', '    \n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    \n', '    uint256 public etherMinimum;\n', '    uint256 public soldTokens;\n', '    uint256 public remainingTokens;\n', '    uint256 public tokenPrice;\n', '\t\n', '\tmapping(address => uint256) public etherUser; // address => ether amount\n', '\tmapping(address => uint256) public pendingTokenUser; // address => token amount that will be claimed after KYC\n', '\tmapping(address => uint256) public tokenUser; // address => token amount owned\n', '\t\n', '    constructor(address _tokenSaleContract, uint256 _tokenPrice, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime) public {\n', '        require ( _tokenSaleContract != address(0), "_tokenSaleContract != address(0)" );\n', '        require ( _tokenPrice != 0, "_tokenPrice != 0" );\n', '        require ( _remainingTokens != 0, "_remainingTokens != 0" );  \n', '        require ( _startTime != 0, "_startTime != 0" );\n', '        require ( _endTime != 0, "_endTime != 0" );\n', '        \n', '        tokenSaleContract = TokedoDaico(_tokenSaleContract);\n', '        \n', '        soldTokens = 0;\n', '        remainingTokens = _remainingTokens;\n', '        tokenPrice = _tokenPrice;\n', '        etherMinimum = _etherMinimum;\n', '        \n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == tokenSaleContract.owner() );\n', '        _;\n', '    }\n', '    \n', '    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\n', '        if ( _newStart != 0 ) startTime = _newStart;\n', '        if ( _newEnd != 0 ) endTime = _newEnd;\n', '    }\n', '    \n', '    function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner {\n', '        etherMinimum = _newEtherMinimum;\n', '    }\n', '    \n', '    function releaseTokensTo(address buyer) internal returns(bool) {\n', '        if( msg.value > 0 ) takeEther(buyer);\n', '        giveToken(buyer);\n', '        return true;\n', '    }\n', '    \n', '    function started() public view returns(bool) {\n', '        return now > startTime || remainingTokens == 0;\n', '    }\n', '    \n', '    function ended() public view returns(bool) {\n', '        return now > endTime || remainingTokens == 0;\n', '    }\n', '    \n', '    function startTime() public view returns(uint) {\n', '        return startTime;\n', '    }\n', '    \n', '    function endTime() public view returns(uint) {\n', '        return endTime;\n', '    }\n', '    \n', '    function totalTokens() public view returns(uint) {\n', '        return remainingTokens.add(soldTokens);\n', '    }\n', '    \n', '    function remainingTokens() public view returns(uint) {\n', '        return remainingTokens;\n', '    }\n', '    \n', '    function price() public view returns(uint) {\n', '        return uint256(1 ether).div( tokenPrice ).mul( 10 ** uint256(tokenSaleContract.decimals()) );\n', '    }\n', '\t\n', '\tfunction () public payable{\n', '\t    takeEther(msg.sender);\n', '\t}\n', '\t\n', '\tevent TakeEther(address buyer, uint256 value, uint256 soldToken, uint256 tokenPrice );\n', '\t\n', '\tfunction takeEther(address _buyer) internal {\n', '\t    require( now > startTime, "now > startTime" );\n', '\t\trequire( now < endTime, "now < endTime");\n', '        require( msg.value >= etherMinimum, "msg.value >= etherMinimum"); \n', '        require( remainingTokens > 0, "remainingTokens > 0" );\n', '        \n', '        uint256 oneToken = 10 ** uint256(tokenSaleContract.decimals());\n', '        uint256 tokenAmount = msg.value.mul( oneToken ).div( tokenPrice );\n', '        \n', '        uint256 remainingTokensGlobal = tokenInterface( tokenSaleContract.tokenContract() ).balanceOf( address(tokenSaleContract) );\n', '        \n', '        uint256 remainingTokensApplied;\n', '        if ( remainingTokensGlobal > remainingTokens ) { \n', '            remainingTokensApplied = remainingTokens;\n', '        } else {\n', '            remainingTokensApplied = remainingTokensGlobal;\n', '        }\n', '        \n', '        uint256 refund = 0;\n', '        if ( remainingTokensApplied < tokenAmount ) {\n', '            refund = (tokenAmount - remainingTokensApplied).mul(tokenPrice).div(oneToken);\n', '            tokenAmount = remainingTokensApplied;\n', '\t\t\tremainingTokens = 0; // set remaining token to 0\n', '            _buyer.transfer(refund);\n', '        } else {\n', '\t\t\tremainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus\n', '        }\n', '        \n', '        etherUser[_buyer] = etherUser[_buyer].add(msg.value.sub(refund));\n', '        pendingTokenUser[_buyer] = pendingTokenUser[_buyer].add(tokenAmount);\t\n', '        \n', '        emit TakeEther( _buyer, msg.value, tokenAmount, tokenPrice );\n', '\t}\n', '\t\n', '\tfunction giveToken(address _buyer) internal {\n', '\t    require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );\n', '\n', '\t\ttokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);\n', '\t\n', '\t\ttokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);\n', '\t\tsoldTokens = soldTokens.add(pendingTokenUser[_buyer]);\n', '\t\tpendingTokenUser[_buyer] = 0;\n', '\t\t\n', '\t\trequire( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );\n', '\t\tetherUser[_buyer] = 0;\n', '\t}\n', '\n', '    function refundEther(address to) public onlyTokenSaleOwner {\n', '        to.transfer(etherUser[to]);\n', '        etherUser[to] = 0;\n', '        pendingTokenUser[to] = 0;\n', '    }\n', '    \n', '    function withdraw(address to, uint256 value) public onlyTokenSaleOwner { \n', '        to.transfer(value);\n', '    }\n', '\t\n', '\tfunction userBalance(address _user) public view returns( uint256 _pendingTokenUser, uint256 _tokenUser, uint256 _etherUser ) {\n', '\t\treturn (pendingTokenUser[_user], tokenUser[_user], etherUser[_user]);\n', '\t}\n', '}\n', '\n', 'contract TokedoDaico is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    tokenInterface public tokenContract;\n', '    \n', '    address public milestoneSystem;\n', '\tuint256 public decimals;\n', '    uint256 public tokenPrice;\n', '\n', '    mapping(address => bool) public rc;\n', '\n', '    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\n', '        tokenContract = tokenInterface(_tokenAddress);\n', '        decimals = tokenContract.decimals();\n', '        tokenPrice = _tokenPrice;\n', '        milestoneSystem = new MilestoneSystem(_wallet,_tokenAddress, _time, _funds, _tokenPrice, _activeSupply);\n', '    }\n', '    \n', '    modifier onlyRC() {\n', '        require( rc[msg.sender], "rc[msg.sender]" ); //check if is an authorized rcContract\n', '        _;\n', '    }\n', '    \n', '    function forwardEther() onlyRC payable public returns(bool) {\n', '        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");\n', '        return true;\n', '    }\n', '    \n', '\tfunction sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {\n', '        return tokenContract.transfer(_buyer, _amount);\n', '    }\n', '\n', '    event NewRC(address contr);\n', '    \n', '    function addRC(address _rc) onlyOwner public {\n', '        rc[ _rc ]  = true;\n', '        emit NewRC(_rc);\n', '    }\n', '    \n', '    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n', '        return tokenContract.transfer(to, value);\n', '    }\n', '    \n', '    function setTokenContract(address _tokenContract) public onlyOwner {\n', '        tokenContract = tokenInterface(_tokenContract);\n', '    }\n', '}\n', '\n', 'contract MilestoneSystem {\n', '    using SafeMath for uint256;\n', '    \n', '    tokenInterface public tokenContract;\n', '    TokedoDaico public tokenSaleContract;\n', '    \n', '    uint256[] public time;\n', '    uint256[] public funds;\n', '    \n', '    bool public locked = false; \n', '    uint256 public endTimeToReturnTokens; \n', '    \n', '    uint8 public step = 0;\n', '    \n', '    uint256 public constant timeframeMilestone = 3 days; \n', '    uint256 public constant timeframeDeath = 30 days; \n', '    \n', '    uint256 public activeSupply;\n', '    \n', '    uint256 public tokenPrice;\n', '    \n', '    uint256 public etherReceived;\n', '    address public wallet;\n', '    \n', '    mapping(address => mapping(uint8 => uint256) ) public balance;\n', '    mapping(uint8 => uint256) public tokenDistrusted;\n', '    \n', '    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\n', '        require( _wallet != address(0), "_wallet != address(0)" );\n', '        require( _time.length != 0, "_time.length != 0" );\n', '        require( _time.length == _funds.length, "_time.length == _funds.length" );\n', '        \n', '        wallet = _wallet;\n', '        \n', '        tokenContract = tokenInterface(_tokenAddress);\n', '        tokenSaleContract = TokedoDaico(msg.sender);\n', '        \n', '        time = _time;\n', '        funds = _funds;\n', '        \n', '        activeSupply = _activeSupply;\n', '        tokenPrice = _tokenPrice;\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == tokenSaleContract.owner(), "msg.sender == tokenSaleContract.owner()" );\n', '        _;\n', '    }\n', '    \n', '    event Distrust(address sender, uint256 amount);\n', '    event Locked();\n', '    \n', '    function distrust(address _from, uint _value, bytes _data) public {\n', '        require(msg.sender == address(tokenContract), "msg.sender == address(tokenContract)");\n', '        \n', '        if ( !locked ) {\n', '            \n', '            uint256 startTimeMilestone = time[step].sub(timeframeMilestone);\n', '            uint256 endTimeMilestone = time[step];\n', '            uint256 startTimeProjectDeath = time[step].add(timeframeDeath);\n', '            bool unclaimedFunds = funds[step] > 0;\n', '            \n', '            require( \n', '                ( now > startTimeMilestone && now < endTimeMilestone ) || \n', '                ( now > startTimeProjectDeath && unclaimedFunds ), \n', '                "( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )" \n', '            );\n', '        } else {\n', '            require( locked && now < endTimeToReturnTokens ); //a timeframePost to deposit all tokens and then claim the refundMe method\n', '        }\n', '        \n', '        balance[_from][step] = balance[_from][step].add(_value);\n', '        tokenDistrusted[step] = tokenDistrusted[step].add(_value);\n', '        \n', '        emit Distrust(msg.sender, _value);\n', '        \n', '        if( tokenDistrusted[step] > activeSupply && !locked ) {\n', '            locked = true;\n', '            endTimeToReturnTokens = now.add(timeframeDeath);\n', '            emit Locked();\n', '        }\n', '    }\n', '    \n', '    function tokenFallback(address _from, uint _value, bytes _data) public {\n', '        distrust( _from, _value, _data);\n', '    }\n', '\t\n', '\tfunction receiveApproval( address _from, uint _value, bytes _data) public {\n', '\t    require(msg.sender == address(tokenContract), "msg.sender == address(tokenContract)");\n', '\t\trequire(msg.sender.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, this, _value));\n', '        distrust( _from, _value, _data);\n', '    }\n', '    \n', '    event Trust(address sender, uint256 amount);\n', '    event Unlocked();\n', '    \n', '    function trust(uint8 _step) public {\n', '        require( balance[msg.sender][_step] > 0 , "balance[msg.sender] > 0");\n', '        \n', '        uint256 amount = balance[msg.sender][_step];\n', '        balance[msg.sender][_step] = 0;\n', '        \n', '        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '        \n', '        emit Trust(msg.sender, amount);\n', '        \n', '        if( tokenDistrusted[step] <= activeSupply && locked ) {\n', '            locked = false;\n', '            endTimeToReturnTokens = 0;\n', '            emit Unlocked();\n', '        }\n', '    }\n', '    \n', '    event Refund(address sender, uint256 money);\n', '    \n', '    function refundMe() public {\n', '        require(locked, "locked");\n', '        require( now > endTimeToReturnTokens, "now > endTimeToReturnTokens" );\n', '        \n', '        uint256 ethTot = address(this).balance;\n', '        require( ethTot > 0 , "ethTot > 0");\n', '        \n', '        uint256 tknAmount = balance[msg.sender][step];\n', '        require( tknAmount > 0 , "tknAmount > 0");\n', '        \n', '        balance[msg.sender][step] = 0;\n', '        \n', '        tokenContract.burn(tknAmount);\n', '        \n', '        uint256 tknTot = tokenDistrusted[step];\n', '        uint256 rate = tknAmount.mul(1e18).div(tknTot);\n', '        uint256 money = ethTot.mul(rate).div(1e18);\n', '        \n', '        if( money > address(this).balance ) {\n', '\t\t    money = address(this).balance;\n', '\t\t}\n', '        msg.sender.transfer(money);\n', '        \n', '        emit Refund(msg.sender, money);\n', '    }\n', '    \n', '    function ownerWithdraw() public onlyTokenSaleOwner {\n', '        require(!locked, "!locked");\n', '        \n', '        require(now > time[step], "now > time[step]");\n', '        require(funds[step] > 0, "funds[step] > 0");\n', '        \n', '        uint256 amountApplied = funds[step];\n', '        funds[step] = 0;\n', '\t\tstep = step+1;\n', '\t\t\n', '\t\tuint256 value;\n', '\t\tif( amountApplied > address(this).balance || time.length == step+1)\n', '\t\t    value = address(this).balance;\n', '\t\telse {\n', '\t\t    value = amountApplied;\n', '\t\t}\n', '\t\t\n', '        msg.sender.transfer(value);\n', '    }\n', '    \n', '    function ownerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { //for airdrop reason to distribute to Tokedo Token Holder\n', '        require( _tokenContract != address(tokenContract), "_tokenContract != address(tokenContract)"); // the owner can withdraw tokens except Tokedo Tokens\n', '        return tokenInterface(_tokenContract).transfer(to, value);\n', '    }\n', '    \n', '    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {\n', '        require( _wallet != address(0), "_wallet != address(0)" );\n', '        wallet = _wallet;\n', '\t\treturn true;\n', '    }\n', '    \n', '    function () public payable {\n', '        require(msg.sender == address(tokenSaleContract), "msg.sender == address(tokenSaleContract)");\n', '        \n', '        if( etherReceived < funds[0]  ) {\n', '            require( wallet != address(0), "wallet != address(0)" );\n', '            wallet.transfer(msg.value);\n', '        }\n', '        \n', '        etherReceived = etherReceived.add(msg.value);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '     return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\taddress public newOwner;\n', '\n', '\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner, "msg.sender == owner");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(address(0) != _newOwner, "address(0) != _newOwner");\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == newOwner, "msg.sender == newOwner");\n', '\t\temit OwnershipTransferred(owner, msg.sender);\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '}\n', '\n', 'contract tokenInterface {\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool);\n', '\tfunction burn(uint256 _value) public returns(bool);\n', '\tuint256 public totalSupply;\n', '\tuint256 public decimals;\n', '}\n', '\n', 'contract AtomaxKycInterface {\n', '\n', '    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\n', '    function started() public view returns(bool);\n', '\n', '    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\n', '    function ended() public view returns(bool);\n', '\n', '    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\n', '    function startTime() public view returns(uint256);\n', '\n', '    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\n', '    function endTime() public view returns(uint256);\n', '\n', '    // returns the total number of the tokens available for the sale, must not change when the ico is started\n', '    function totalTokens() public view returns(uint256);\n', '\n', '    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\n', '    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\n', '    function remainingTokens() public view returns(uint256);\n', '\n', '    // return the price as number of tokens released for each ether\n', '    function price() public view returns(uint256);\n', '}\n', '\n', 'contract AtomaxKyc {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => bool) public isKycSigner;\n', '    mapping (bytes32 => uint256) public alreadyPayed;\n', '\n', '    event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount);\n', '\n', '    constructor() internal {\n', '        isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; //ATOMAX KYC 1 SIGNER\n', '        isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; //ATOMAX KYC 2 SIGNER\n', '    }\n', '\n', '    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\n', '    function releaseTokensTo(address buyer) internal returns(bool);\n', '\n', '    \n', '    function buyTokensFor(address _buyerAddress, bytes32 _buyerId, uint _maxAmount, uint8 _v, bytes32 _r, bytes32 _s, uint8 _bv, bytes32 _br, bytes32 _bs) public payable returns (bool) {\n', '        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\n', '        address signer = ecrecover(hash, _bv, _br, _bs);\n', '        require ( signer == _buyerAddress, "signer == _buyerAddress " );\n', '        \n', '        return buyImplementation(_buyerAddress, _buyerId, _maxAmount, _v, _r, _s);\n', '    }\n', '    \n', '    function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) {\n', '        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\n', '    }\n', '\n', '    function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) {\n', '        // check the signature\n', '        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\n', '        address signer = ecrecover(hash, _v, _r, _s);\n', '\t\t\n', '\t\trequire( isKycSigner[signer], "isKycSigner[signer]");\n', '        \n', '\t\tuint256 totalPayed = alreadyPayed[_buyerId].add(msg.value);\n', '\t\trequire(totalPayed <= _maxAmount);\n', '\t\talreadyPayed[_buyerId] = totalPayed;\n', '\t\t\n', '\t\temit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount);\n', '\t\treturn releaseTokensTo(_buyerAddress);\n', '\n', '    }\n', '    \n', '    function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) {\n', '        hash = keccak256(abi.encodePacked("Atomax authorization:", this, _buyerAddress, _buyerId, _maxAmount));\n', '    }\n', '}\n', '\n', 'contract RC_KYC is AtomaxKycInterface, AtomaxKyc {\n', '    using SafeMath for uint256;\n', '    \n', '    TokedoDaico tokenSaleContract;\n', '    \n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    \n', '    uint256 public etherMinimum;\n', '    uint256 public soldTokens;\n', '    uint256 public remainingTokens;\n', '    uint256 public tokenPrice;\n', '\t\n', '\tmapping(address => uint256) public etherUser; // address => ether amount\n', '\tmapping(address => uint256) public pendingTokenUser; // address => token amount that will be claimed after KYC\n', '\tmapping(address => uint256) public tokenUser; // address => token amount owned\n', '\t\n', '    constructor(address _tokenSaleContract, uint256 _tokenPrice, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime) public {\n', '        require ( _tokenSaleContract != address(0), "_tokenSaleContract != address(0)" );\n', '        require ( _tokenPrice != 0, "_tokenPrice != 0" );\n', '        require ( _remainingTokens != 0, "_remainingTokens != 0" );  \n', '        require ( _startTime != 0, "_startTime != 0" );\n', '        require ( _endTime != 0, "_endTime != 0" );\n', '        \n', '        tokenSaleContract = TokedoDaico(_tokenSaleContract);\n', '        \n', '        soldTokens = 0;\n', '        remainingTokens = _remainingTokens;\n', '        tokenPrice = _tokenPrice;\n', '        etherMinimum = _etherMinimum;\n', '        \n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == tokenSaleContract.owner() );\n', '        _;\n', '    }\n', '    \n', '    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\n', '        if ( _newStart != 0 ) startTime = _newStart;\n', '        if ( _newEnd != 0 ) endTime = _newEnd;\n', '    }\n', '    \n', '    function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner {\n', '        etherMinimum = _newEtherMinimum;\n', '    }\n', '    \n', '    function releaseTokensTo(address buyer) internal returns(bool) {\n', '        if( msg.value > 0 ) takeEther(buyer);\n', '        giveToken(buyer);\n', '        return true;\n', '    }\n', '    \n', '    function started() public view returns(bool) {\n', '        return now > startTime || remainingTokens == 0;\n', '    }\n', '    \n', '    function ended() public view returns(bool) {\n', '        return now > endTime || remainingTokens == 0;\n', '    }\n', '    \n', '    function startTime() public view returns(uint) {\n', '        return startTime;\n', '    }\n', '    \n', '    function endTime() public view returns(uint) {\n', '        return endTime;\n', '    }\n', '    \n', '    function totalTokens() public view returns(uint) {\n', '        return remainingTokens.add(soldTokens);\n', '    }\n', '    \n', '    function remainingTokens() public view returns(uint) {\n', '        return remainingTokens;\n', '    }\n', '    \n', '    function price() public view returns(uint) {\n', '        return uint256(1 ether).div( tokenPrice ).mul( 10 ** uint256(tokenSaleContract.decimals()) );\n', '    }\n', '\t\n', '\tfunction () public payable{\n', '\t    takeEther(msg.sender);\n', '\t}\n', '\t\n', '\tevent TakeEther(address buyer, uint256 value, uint256 soldToken, uint256 tokenPrice );\n', '\t\n', '\tfunction takeEther(address _buyer) internal {\n', '\t    require( now > startTime, "now > startTime" );\n', '\t\trequire( now < endTime, "now < endTime");\n', '        require( msg.value >= etherMinimum, "msg.value >= etherMinimum"); \n', '        require( remainingTokens > 0, "remainingTokens > 0" );\n', '        \n', '        uint256 oneToken = 10 ** uint256(tokenSaleContract.decimals());\n', '        uint256 tokenAmount = msg.value.mul( oneToken ).div( tokenPrice );\n', '        \n', '        uint256 remainingTokensGlobal = tokenInterface( tokenSaleContract.tokenContract() ).balanceOf( address(tokenSaleContract) );\n', '        \n', '        uint256 remainingTokensApplied;\n', '        if ( remainingTokensGlobal > remainingTokens ) { \n', '            remainingTokensApplied = remainingTokens;\n', '        } else {\n', '            remainingTokensApplied = remainingTokensGlobal;\n', '        }\n', '        \n', '        uint256 refund = 0;\n', '        if ( remainingTokensApplied < tokenAmount ) {\n', '            refund = (tokenAmount - remainingTokensApplied).mul(tokenPrice).div(oneToken);\n', '            tokenAmount = remainingTokensApplied;\n', '\t\t\tremainingTokens = 0; // set remaining token to 0\n', '            _buyer.transfer(refund);\n', '        } else {\n', '\t\t\tremainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus\n', '        }\n', '        \n', '        etherUser[_buyer] = etherUser[_buyer].add(msg.value.sub(refund));\n', '        pendingTokenUser[_buyer] = pendingTokenUser[_buyer].add(tokenAmount);\t\n', '        \n', '        emit TakeEther( _buyer, msg.value, tokenAmount, tokenPrice );\n', '\t}\n', '\t\n', '\tfunction giveToken(address _buyer) internal {\n', '\t    require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );\n', '\n', '\t\ttokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);\n', '\t\n', '\t\ttokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);\n', '\t\tsoldTokens = soldTokens.add(pendingTokenUser[_buyer]);\n', '\t\tpendingTokenUser[_buyer] = 0;\n', '\t\t\n', '\t\trequire( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );\n', '\t\tetherUser[_buyer] = 0;\n', '\t}\n', '\n', '    function refundEther(address to) public onlyTokenSaleOwner {\n', '        to.transfer(etherUser[to]);\n', '        etherUser[to] = 0;\n', '        pendingTokenUser[to] = 0;\n', '    }\n', '    \n', '    function withdraw(address to, uint256 value) public onlyTokenSaleOwner { \n', '        to.transfer(value);\n', '    }\n', '\t\n', '\tfunction userBalance(address _user) public view returns( uint256 _pendingTokenUser, uint256 _tokenUser, uint256 _etherUser ) {\n', '\t\treturn (pendingTokenUser[_user], tokenUser[_user], etherUser[_user]);\n', '\t}\n', '}\n', '\n', 'contract TokedoDaico is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    tokenInterface public tokenContract;\n', '    \n', '    address public milestoneSystem;\n', '\tuint256 public decimals;\n', '    uint256 public tokenPrice;\n', '\n', '    mapping(address => bool) public rc;\n', '\n', '    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\n', '        tokenContract = tokenInterface(_tokenAddress);\n', '        decimals = tokenContract.decimals();\n', '        tokenPrice = _tokenPrice;\n', '        milestoneSystem = new MilestoneSystem(_wallet,_tokenAddress, _time, _funds, _tokenPrice, _activeSupply);\n', '    }\n', '    \n', '    modifier onlyRC() {\n', '        require( rc[msg.sender], "rc[msg.sender]" ); //check if is an authorized rcContract\n', '        _;\n', '    }\n', '    \n', '    function forwardEther() onlyRC payable public returns(bool) {\n', '        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");\n', '        return true;\n', '    }\n', '    \n', '\tfunction sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {\n', '        return tokenContract.transfer(_buyer, _amount);\n', '    }\n', '\n', '    event NewRC(address contr);\n', '    \n', '    function addRC(address _rc) onlyOwner public {\n', '        rc[ _rc ]  = true;\n', '        emit NewRC(_rc);\n', '    }\n', '    \n', '    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n', '        return tokenContract.transfer(to, value);\n', '    }\n', '    \n', '    function setTokenContract(address _tokenContract) public onlyOwner {\n', '        tokenContract = tokenInterface(_tokenContract);\n', '    }\n', '}\n', '\n', 'contract MilestoneSystem {\n', '    using SafeMath for uint256;\n', '    \n', '    tokenInterface public tokenContract;\n', '    TokedoDaico public tokenSaleContract;\n', '    \n', '    uint256[] public time;\n', '    uint256[] public funds;\n', '    \n', '    bool public locked = false; \n', '    uint256 public endTimeToReturnTokens; \n', '    \n', '    uint8 public step = 0;\n', '    \n', '    uint256 public constant timeframeMilestone = 3 days; \n', '    uint256 public constant timeframeDeath = 30 days; \n', '    \n', '    uint256 public activeSupply;\n', '    \n', '    uint256 public tokenPrice;\n', '    \n', '    uint256 public etherReceived;\n', '    address public wallet;\n', '    \n', '    mapping(address => mapping(uint8 => uint256) ) public balance;\n', '    mapping(uint8 => uint256) public tokenDistrusted;\n', '    \n', '    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\n', '        require( _wallet != address(0), "_wallet != address(0)" );\n', '        require( _time.length != 0, "_time.length != 0" );\n', '        require( _time.length == _funds.length, "_time.length == _funds.length" );\n', '        \n', '        wallet = _wallet;\n', '        \n', '        tokenContract = tokenInterface(_tokenAddress);\n', '        tokenSaleContract = TokedoDaico(msg.sender);\n', '        \n', '        time = _time;\n', '        funds = _funds;\n', '        \n', '        activeSupply = _activeSupply;\n', '        tokenPrice = _tokenPrice;\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == tokenSaleContract.owner(), "msg.sender == tokenSaleContract.owner()" );\n', '        _;\n', '    }\n', '    \n', '    event Distrust(address sender, uint256 amount);\n', '    event Locked();\n', '    \n', '    function distrust(address _from, uint _value, bytes _data) public {\n', '        require(msg.sender == address(tokenContract), "msg.sender == address(tokenContract)");\n', '        \n', '        if ( !locked ) {\n', '            \n', '            uint256 startTimeMilestone = time[step].sub(timeframeMilestone);\n', '            uint256 endTimeMilestone = time[step];\n', '            uint256 startTimeProjectDeath = time[step].add(timeframeDeath);\n', '            bool unclaimedFunds = funds[step] > 0;\n', '            \n', '            require( \n', '                ( now > startTimeMilestone && now < endTimeMilestone ) || \n', '                ( now > startTimeProjectDeath && unclaimedFunds ), \n', '                "( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )" \n', '            );\n', '        } else {\n', '            require( locked && now < endTimeToReturnTokens ); //a timeframePost to deposit all tokens and then claim the refundMe method\n', '        }\n', '        \n', '        balance[_from][step] = balance[_from][step].add(_value);\n', '        tokenDistrusted[step] = tokenDistrusted[step].add(_value);\n', '        \n', '        emit Distrust(msg.sender, _value);\n', '        \n', '        if( tokenDistrusted[step] > activeSupply && !locked ) {\n', '            locked = true;\n', '            endTimeToReturnTokens = now.add(timeframeDeath);\n', '            emit Locked();\n', '        }\n', '    }\n', '    \n', '    function tokenFallback(address _from, uint _value, bytes _data) public {\n', '        distrust( _from, _value, _data);\n', '    }\n', '\t\n', '\tfunction receiveApproval( address _from, uint _value, bytes _data) public {\n', '\t    require(msg.sender == address(tokenContract), "msg.sender == address(tokenContract)");\n', '\t\trequire(msg.sender.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, this, _value));\n', '        distrust( _from, _value, _data);\n', '    }\n', '    \n', '    event Trust(address sender, uint256 amount);\n', '    event Unlocked();\n', '    \n', '    function trust(uint8 _step) public {\n', '        require( balance[msg.sender][_step] > 0 , "balance[msg.sender] > 0");\n', '        \n', '        uint256 amount = balance[msg.sender][_step];\n', '        balance[msg.sender][_step] = 0;\n', '        \n', '        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '        \n', '        emit Trust(msg.sender, amount);\n', '        \n', '        if( tokenDistrusted[step] <= activeSupply && locked ) {\n', '            locked = false;\n', '            endTimeToReturnTokens = 0;\n', '            emit Unlocked();\n', '        }\n', '    }\n', '    \n', '    event Refund(address sender, uint256 money);\n', '    \n', '    function refundMe() public {\n', '        require(locked, "locked");\n', '        require( now > endTimeToReturnTokens, "now > endTimeToReturnTokens" );\n', '        \n', '        uint256 ethTot = address(this).balance;\n', '        require( ethTot > 0 , "ethTot > 0");\n', '        \n', '        uint256 tknAmount = balance[msg.sender][step];\n', '        require( tknAmount > 0 , "tknAmount > 0");\n', '        \n', '        balance[msg.sender][step] = 0;\n', '        \n', '        tokenContract.burn(tknAmount);\n', '        \n', '        uint256 tknTot = tokenDistrusted[step];\n', '        uint256 rate = tknAmount.mul(1e18).div(tknTot);\n', '        uint256 money = ethTot.mul(rate).div(1e18);\n', '        \n', '        if( money > address(this).balance ) {\n', '\t\t    money = address(this).balance;\n', '\t\t}\n', '        msg.sender.transfer(money);\n', '        \n', '        emit Refund(msg.sender, money);\n', '    }\n', '    \n', '    function ownerWithdraw() public onlyTokenSaleOwner {\n', '        require(!locked, "!locked");\n', '        \n', '        require(now > time[step], "now > time[step]");\n', '        require(funds[step] > 0, "funds[step] > 0");\n', '        \n', '        uint256 amountApplied = funds[step];\n', '        funds[step] = 0;\n', '\t\tstep = step+1;\n', '\t\t\n', '\t\tuint256 value;\n', '\t\tif( amountApplied > address(this).balance || time.length == step+1)\n', '\t\t    value = address(this).balance;\n', '\t\telse {\n', '\t\t    value = amountApplied;\n', '\t\t}\n', '\t\t\n', '        msg.sender.transfer(value);\n', '    }\n', '    \n', '    function ownerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { //for airdrop reason to distribute to Tokedo Token Holder\n', '        require( _tokenContract != address(tokenContract), "_tokenContract != address(tokenContract)"); // the owner can withdraw tokens except Tokedo Tokens\n', '        return tokenInterface(_tokenContract).transfer(to, value);\n', '    }\n', '    \n', '    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {\n', '        require( _wallet != address(0), "_wallet != address(0)" );\n', '        wallet = _wallet;\n', '\t\treturn true;\n', '    }\n', '    \n', '    function () public payable {\n', '        require(msg.sender == address(tokenSaleContract), "msg.sender == address(tokenSaleContract)");\n', '        \n', '        if( etherReceived < funds[0]  ) {\n', '            require( wallet != address(0), "wallet != address(0)" );\n', '            wallet.transfer(msg.value);\n', '        }\n', '        \n', '        etherReceived = etherReceived.add(msg.value);\n', '    }\n', '}']
