['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  \n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract tokenInterface {\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract rateInterface {\n', '    function readRate(string _currency) public view returns (uint256 oneEtherValue);\n', '}\n', '\n', 'contract RC {\n', '    using SafeMath for uint256;\n', '    TokenSale tokenSaleContract;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    \n', '    uint256 public soldTokens;\n', '    uint256 public remainingTokens;\n', '    \n', '    uint256 public oneTokenInUsdWei;\n', '\n', '    function RC(address _tokenSaleContract, uint256 _oneTokenInUsdWei, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n', '        require ( _tokenSaleContract != 0 );\n', '        require ( _oneTokenInUsdWei != 0 );\n', '        require( _remainingTokens != 0 );\n', '        \n', '        tokenSaleContract = TokenSale(_tokenSaleContract);\n', '        \n', '        tokenSaleContract.addMeByRC();\n', '        \n', '        soldTokens = 0;\n', '        remainingTokens = _remainingTokens;\n', '        oneTokenInUsdWei = _oneTokenInUsdWei;\n', '        \n', '        setTimeRC( _startTime, _endTime );\n', '    }\n', '    \n', '    function setTimeRC(uint256 _startTime, uint256 _endTime ) internal {\n', '        if( _startTime == 0 ) {\n', '            startTime = tokenSaleContract.startTime();\n', '        } else {\n', '            startTime = _startTime;\n', '        }\n', '        if( _endTime == 0 ) {\n', '            endTime = tokenSaleContract.endTime();\n', '        } else {\n', '            endTime = _endTime;\n', '        }\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == tokenSaleContract.owner() );\n', '        _;\n', '    }\n', '    \n', '    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\n', '        if ( _newStart != 0 ) startTime = _newStart;\n', '        if ( _newEnd != 0 ) endTime = _newEnd;\n', '    }\n', '    \n', '    event BuyRC(address indexed buyer, bytes trackID, uint256 value, uint256 soldToken, uint256 valueTokenInUsdWei );\n', '    \n', '    function () public payable {\n', '        require( now > startTime );\n', '        require( now < endTime );\n', '        require( msg.value >= 1*10**18); //1 Ether\n', '        require( remainingTokens > 0 );\n', '        \n', '        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(msg.sender, oneTokenInUsdWei, remainingTokens);\n', '        \n', '        remainingTokens = remainingTokens.sub(tokenAmount);\n', '        soldTokens = soldTokens.add(tokenAmount);\n', '        \n', '        BuyRC( msg.sender, msg.data, msg.value, tokenAmount, oneTokenInUsdWei );\n', '    }\n', '}\n', '\n', 'contract CardSale {\n', '    using SafeMath for uint256;\n', '    TokenSale tokenSaleContract;\n', '    \n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    \n', '    uint256 public soldTokens;\n', '    uint256 public remainingTokens;    \n', '    \n', '    mapping(address => bool) public rc;\n', '    \n', '    function CardSale(address _tokenSaleContract, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n', '        require ( _tokenSaleContract != 0 );\n', '        require( _remainingTokens != 0 );\n', '        \n', '        tokenSaleContract = TokenSale(_tokenSaleContract);\n', '        \n', '        tokenSaleContract.addMeByRC();\n', '        \n', '        soldTokens = 0;\n', '        remainingTokens = _remainingTokens;\n', '        \n', '        setTimeRC( _startTime, _endTime );\n', '    }\n', '    \n', '    function setTimeRC(uint256 _startTime, uint256 _endTime ) internal {\n', '        if( _startTime == 0 ) {\n', '            startTime = tokenSaleContract.startTime();\n', '        } else {\n', '            startTime = _startTime;\n', '        }\n', '        if( _endTime == 0 ) {\n', '            endTime = tokenSaleContract.endTime();\n', '        } else {\n', '            endTime = _endTime;\n', '        }\n', '    }\n', '\n', '    function owner() view public returns (address) {\n', '        return tokenSaleContract.owner();\n', '    }\n', '    \n', '    modifier onlyTokenSaleOwner() {\n', '        require(msg.sender == owner() );\n', '        _;\n', '    }\n', '    \n', '    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\n', '        if ( _newStart != 0 ) startTime = _newStart;\n', '        if ( _newEnd != 0 ) endTime = _newEnd;\n', '    }\n', '    \n', '    event NewRC(address contr);\n', '    \n', '    function addMeByRC() public {\n', '        require(tx.origin == owner() );\n', '        \n', '        rc[ msg.sender ]  = true;\n', '        \n', '        NewRC(msg.sender);\n', '    }\n', '    \n', '    function newCard(uint256 _oneTokenInUsdWei) onlyTokenSaleOwner public {\n', '        new RC(this, _oneTokenInUsdWei, remainingTokens, 0, 0 );\n', '    }\n', '    \n', '    function () public payable {\n', '        revert();\n', '    }\n', '    \n', '    modifier onlyRC() {\n', '        require( rc[msg.sender] ); //check if is an authorized rcContract\n', '        _;\n', '    }\n', '    \n', '    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 ) onlyRC public payable returns(uint256) {\n', '        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(_buyer, _rcTokenValue, remainingTokens);\n', '        remainingTokens = remainingTokens.sub(tokenAmount);\n', '        soldTokens = soldTokens.add(tokenAmount);\n', '        return tokenAmount;\n', '    }\n', '}\n', '\n', 'contract TokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '    tokenInterface public tokenContract;\n', '    rateInterface public rateContract;\n', '    \n', '    address public wallet;\n', '    address public advisor;\n', '    uint256 public advisorFee; // 1 = 0,1%\n', '    \n', '\tuint256 public constant decimals = 18;\n', '    \n', '    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z\n', '    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z\n', '\n', '    mapping(address => bool) public rc;\n', '\n', '\n', '    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {\n', '        tokenContract = tokenInterface(_tokenAddress);\n', '        rateContract = rateInterface(_rateAddress);\n', '        setTime(_startTime, _endTime); \n', '        wallet = msg.sender;\n', '        advisor = msg.sender;\n', '        advisorFee = 0 * 10**3;\n', '    }\n', '    \n', '    function tokenValueInEther(uint256 _oneTokenInUsdWei) public view returns(uint256 tknValue) {\n', '        uint256 oneEtherInUsd = rateContract.readRate("usd");\n', '        tknValue = _oneTokenInUsdWei.mul(10 ** uint256(decimals)).div(oneEtherInUsd);\n', '        return tknValue;\n', '    } \n', '    \n', '    modifier isBuyable() {\n', '        require( now > startTime ); // check if started\n', '        require( now < endTime ); // check if ended\n', '        require( msg.value > 0 );\n', '\t\t\n', '\t\tuint256 remainingTokens = tokenContract.balanceOf(this);\n', '        require( remainingTokens > 0 ); // Check if there are any remaining tokens \n', '        _;\n', '    }\n', '    \n', '    event Buy(address buyer, uint256 value, address indexed ambassador);\n', '    \n', '    modifier onlyRC() {\n', '        require( rc[msg.sender] ); //check if is an authorized rcContract\n', '        _;\n', '    }\n', '    \n', '    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {\n', '        uint256 oneToken = 10 ** uint256(decimals);\n', '        uint256 tokenValue = tokenValueInEther(_rcTokenValue);\n', '        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);\n', '        address _ambassador = msg.sender;\n', '        \n', '        \n', '        uint256 remainingTokens = tokenContract.balanceOf(this);\n', '        if ( _remainingTokens < remainingTokens ) {\n', '            remainingTokens = _remainingTokens;\n', '        }\n', '        \n', '        if ( remainingTokens < tokenAmount ) {\n', '            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);\n', '            tokenAmount = remainingTokens;\n', '            forward(msg.value-refund);\n', '\t\t\tremainingTokens = 0; // set remaining token to 0\n', '             _buyer.transfer(refund);\n', '        } else {\n', '\t\t\tremainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus\n', '            forward(msg.value);\n', '        }\n', '        \n', '        tokenContract.transfer(_buyer, tokenAmount);\n', '        Buy(_buyer, tokenAmount, _ambassador);\n', '\t\t\n', '        return tokenAmount; \n', '    }\n', '    \n', '    function forward(uint256 _amount) internal {\n', '        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);\n', '        uint256 walletAmount = _amount - advisorAmount;\n', '        advisor.transfer(advisorAmount);\n', '        wallet.transfer(walletAmount);\n', '    }\n', '\n', '    event NewRC(address contr);\n', '    \n', '    function addMeByRC() public {\n', '        require(tx.origin == owner);\n', '        \n', '        rc[ msg.sender ]  = true;\n', '        \n', '        NewRC(msg.sender);\n', '    }\n', '    \n', '    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {\n', '        if ( _newStart != 0 ) startTime = _newStart;\n', '        if ( _newEnd != 0 ) endTime = _newEnd;\n', '    }\n', '\n', '    function withdraw(address to, uint256 value) public onlyOwner {\n', '        to.transfer(value);\n', '    }\n', '    \n', '    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n', '        return tokenContract.transfer(to, value);\n', '    }\n', '    \n', '    function setTokenContract(address _tokenContract) public onlyOwner {\n', '        tokenContract = tokenInterface(_tokenContract);\n', '    }\n', '\n', '    function setWalletAddress(address _wallet) public onlyOwner {\n', '        wallet = _wallet;\n', '    }\n', '    \n', '    function setAdvisorAddress(address _advisor) public onlyOwner {\n', '            advisor = _advisor;\n', '    }\n', '    \n', '    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {\n', '            advisorFee = _advisorFee;\n', '    }\n', '    \n', '    function setRateContract(address _rateAddress) public onlyOwner {\n', '        rateContract = rateInterface(_rateAddress);\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '    \n', '    function newRC(uint256 _oneTokenInUsdWei, uint256 _remainingTokens) onlyOwner public {\n', '        new RC(this, _oneTokenInUsdWei, _remainingTokens, 0, 0 );\n', '    }\n', '}']