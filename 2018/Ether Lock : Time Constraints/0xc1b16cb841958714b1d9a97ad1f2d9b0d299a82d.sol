['pragma solidity ^0.4.15;\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '  \n', '    uint256 c = a / b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', ' contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', ' contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract DOXToken is StandardToken, owned {\n', '\n', 'string public constant name = "DOX";\n', 'string public constant symbol = "DOX";\n', 'uint32 public constant decimals = 3;\n', 'uint256 public  exchangeRate=200;\n', 'uint256 public INITIAL_SUPPLY = 100000000 * 1000;\n', '\n', 'address addressSellAgent;\n', 'address addressSellAgentSiteReg;\n', 'address addressSellAgentCreators;\n', 'address addressSellAgentBounty;\n', 'address addressRateAgent;\n', ' \n', 'uint256 public START_PRESALE_TIMESTAMP   = 1523721600; \n', 'uint256 public START_PREICO_TIMESTAMP   = 1526313600;  \n', 'uint256 public START_ICO_TIMESTAMP   = 1528992000;     \n', ' \n', 'uint256 public END_PRESALE_TIMESTAMP   = 0;\n', 'uint256 public END_PREICO_TIMESTAMP   = 0;\n', 'uint256 public END_ICO_TIMESTAMP   = 0;\n', ' \n', 'uint256 public LOCKUP_3M_ICO_TIMESTAMP   = 0;\n', 'uint256 public LOCKUP_6M_ICO_TIMESTAMP   = 0;\n', ' \n', 'uint32 public  PRESALE_HARDCAP=  250000;\n', 'uint32 public   PREICO_HARDCAP=  950000;\n', 'uint32 public      ICO_HARDCAP=11450000;\n', '  \n', 'uint256 public   PRESALE_PERIOD=28;\n', 'uint256 public   PREICO_PERIOD=28;\n', 'uint256 public     ICO_PERIOD=28;\n', ' \n', 'address addressPayForService=0xF7F6c903467c0C8b9CF7C9D9eA8e24bA54d3bAdd;\n', '\n', '\n', '    \n', 'uint256 public tokensForBounty=0;\n', 'uint256 public tokensForSiteReg=0;\n', 'uint256 public tokensForCreators=0;\n', '        \n', '\n', 'mapping(address => uint256) arrayCreators;\n', 'mapping(address => uint256) arrayBounty;\n', '\n', 'event PayForServiceETHEvent(address indexed from, uint256 value);\n', 'event PayForServiceCHLEvent(address indexed from, uint256 value);\n', 'event BurnFrom(address indexed from, uint256 value);\n', '\n', 'event TransferCreators(address indexed to, uint256 value);\n', 'event TransferBounty(address indexed to, uint256 value);\n', 'event TransferSiteReg(address indexed to, uint256 value);\n', '\n', 'function DOXToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', ' \n', '        tokensForSiteReg= INITIAL_SUPPLY.div(100);\n', '        tokensForBounty= INITIAL_SUPPLY.mul(4).div(100);\n', '        tokensForCreators=INITIAL_SUPPLY.mul(2).div(10);\n', '     \n', '     \n', '        balances[msg.sender] = INITIAL_SUPPLY-tokensForBounty-tokensForCreators-tokensForSiteReg;\n', ' \n', '        END_PRESALE_TIMESTAMP=START_PRESALE_TIMESTAMP+(PRESALE_PERIOD * 1 days);  \n', '        END_PREICO_TIMESTAMP=START_PREICO_TIMESTAMP+(PREICO_PERIOD * 1 days);   \n', '        END_ICO_TIMESTAMP=START_ICO_TIMESTAMP+(ICO_PERIOD * 1 days);   \n', ' \n', '        LOCKUP_3M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(90 * 1 days); \n', '        LOCKUP_6M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(180 * 1 days);  \n', ' \n', '        addressSellAgent=msg.sender;\n', '        addressPayForService=msg.sender;\n', '        addressSellAgentSiteReg=msg.sender;\n', '        addressSellAgentCreators=msg.sender;\n', '        addressSellAgentBounty=msg.sender;\n', '        addressRateAgent=msg.sender;\n', ' \n', '}\n', '    function SetRate( uint32 newRate)   external returns (bool) {\n', '        require(msg.sender==addressRateAgent) ;\n', '        require(newRate>0);\n', '\t    exchangeRate = newRate;\n', '\t   return true;\n', '     }\n', '     \n', '       function Update_START_PRESALE_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t  START_PRESALE_TIMESTAMP = newTS;\n', '\t   END_PRESALE_TIMESTAMP=START_PRESALE_TIMESTAMP+(PRESALE_PERIOD * 1 days);  \n', '     }\n', '       function Update_START_PREICO_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t  START_PREICO_TIMESTAMP = newTS;\n', '\t  END_PREICO_TIMESTAMP=START_PREICO_TIMESTAMP+(PREICO_PERIOD * 1 days);  \n', '     }\n', '     \n', '        function Update_START_ICO_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t    START_ICO_TIMESTAMP = newTS;\n', '\t    END_ICO_TIMESTAMP=START_ICO_TIMESTAMP+(ICO_PERIOD * 1 days);  \n', '\t    LOCKUP_3M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(90 * 1 days);  \n', '        LOCKUP_6M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(180 * 1 days);  \n', '     }\n', '     \n', '  \n', '  function UpdateSellAgent(address new_address) onlyOwner {\n', '   addressSellAgent=new_address;\n', '  }\n', '  \n', 'function UpdateSellAgentSiteReg(address new_address) onlyOwner {\n', '   addressSellAgentSiteReg=new_address;\n', '  }\n', '  function UpdateSellAgentBounty(address new_address) onlyOwner {\n', '   addressSellAgentBounty=new_address;\n', '  }\n', '  function UpdateSellAgentCreators(address new_address) onlyOwner {\n', '   addressSellAgentCreators=new_address;\n', '  }\n', '  function UpdateAddressPayForService(address new_address) onlyOwner {\n', '   addressPayForService=new_address;\n', '  }\n', '  \n', '   function UpdateRateAgent(address new_address) onlyOwner {\n', '   addressRateAgent=new_address;\n', '  }\n', '\n', ' \n', '   function TransferSellAgent(address _to, uint256 _value) external returns (bool) {\n', '      require(msg.sender==addressSellAgent) ;\n', '\n', '    balances[owner] = balances[owner].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(owner, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function TransferSellAgentMulti(address[] _toes, uint256 _value) external returns (bool) {\n', '      require(msg.sender==addressSellAgent) ;\n', '      \n', '       require(  balances[owner]>=_value.mul(_toes.length));\n', '      \n', '      for (uint i = 0; i < _toes.length; i++) {\n', '          \n', '        balances[owner] = balances[owner].sub(_value);\n', '        balances[_toes[i]] = balances[_toes[i]].add(_value);\n', '         \n', '     Transfer(owner, _toes[i], _value);\n', '\n', '        }\n', '  \n', '\n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '     function TransferSellAgentSiteReg(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentSiteReg) ;\n', '    require(tokensForSiteReg>=_value);\n', '    \n', '\n', '    tokensForSiteReg = tokensForSiteReg.sub(_value);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '\n', '    TransferSiteReg( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '    function TransferSellAgentSiteRegMulti(address[] _toes, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentSiteReg);\n', '    require(tokensForSiteReg>=_value.mul(_toes.length));\n', '    \n', '     for (uint i = 0; i < _toes.length; i++) {\n', '         \n', '        tokensForSiteReg = tokensForSiteReg.sub(_value);\n', '        balances[_toes[i]] = balances[_toes[i]].add(_value);\n', '        TransferSiteReg(_toes[i], _value);\n', '        }\n', '        \n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '  function TransferSellAgentBounty(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentBounty) ;\n', '    require(tokensForBounty>=_value);\n', '     require(now>END_ICO_TIMESTAMP );\n', '    \n', '    tokensForBounty = tokensForBounty.sub(_value);\n', '    arrayBounty[_to]=arrayBounty[_to].add(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    TransferBounty( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '    function TransferSellAgentCreators(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentCreators) ;\n', '    require(tokensForCreators>=_value);\n', '    require(now>END_ICO_TIMESTAMP );\n', '    \n', '    tokensForCreators = tokensForCreators.sub(_value);\n', '    arrayCreators[_to]=arrayCreators[_to].add(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    TransferCreators( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  \n', '\n', '  \n', '   modifier isSelling() {\n', '    require( ((now>START_PRESALE_TIMESTAMP&&now<END_PRESALE_TIMESTAMP ) ||(now>START_PREICO_TIMESTAMP&&now<END_PREICO_TIMESTAMP ) ||(now>START_ICO_TIMESTAMP&&now<END_ICO_TIMESTAMP ) ) );\n', '     require(balances[owner]>0 );\n', '    \n', '    \n', '    _;\n', '  }\n', '  \n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        require(!( arrayCreators[msg.sender]>0)||now>LOCKUP_6M_ICO_TIMESTAMP);\n', '        require(!( arrayBounty[msg.sender]>0) ||now>LOCKUP_3M_ICO_TIMESTAMP);\n', '        \n', '       \n', '        \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  \n', '    function() external payable isSelling {\n', '\n', '     uint tokens = exchangeRate.mul(5000).mul(msg.value).div(1 ether);\n', '     uint newBalance=exchangeRate.mul(msg.value+owner.balance).div(1 ether);\n', '\n', 'if (now>START_PRESALE_TIMESTAMP&&now<END_PRESALE_TIMESTAMP)\n', '{\n', '    require(newBalance<PRESALE_HARDCAP);\n', '    \n', '       tokens=tokens.mul(3).div(2);\n', '    \n', '       \n', '} else \n', '\n', 'if (now>START_PREICO_TIMESTAMP&&now<END_PREICO_TIMESTAMP)\n', '{\n', '    require(newBalance<PREICO_HARDCAP);\n', '    \n', '      uint bonusTokens = 0;\n', '        if(now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4)) {\n', '          bonusTokens = tokens.mul(3).div(10);\n', '        } else if(now >= START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4) && now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(2)) {\n', '          bonusTokens = tokens.div(4);\n', '        } else if(now >= START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(2) && now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(3)) {\n', '          bonusTokens = tokens.div(5);\n', '        } else\n', '        {\n', '             bonusTokens = tokens.mul(3).div(20);\n', '        }\n', '        \n', '        \n', '        tokens += bonusTokens;\n', '       \n', '       \n', '} else \n', '     \n', '     if (now>START_ICO_TIMESTAMP&&now<END_ICO_TIMESTAMP)\n', '{\n', '    require(newBalance<ICO_HARDCAP);\n', '    \n', '      uint bonusTokensICO = 0;\n', '        if(now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4)) {\n', '          bonusTokensICO = tokens.div(8);\n', '        } else if(now >= START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4) && now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(2)) {\n', '          bonusTokensICO = tokens.mul(2).div(15);\n', '        } else if(now >= START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(2) && now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(3)) {\n', '          bonusTokensICO = tokens.div(40);\n', '        } else\n', '        {\n', '             bonusTokensICO =0;\n', '        }\n', '        \n', '        \n', '        tokens += bonusTokensICO;\n', '       \n', '       \n', '} else {\n', '   revert();\n', '}\n', '  \n', '     \n', '  \n', '    owner.transfer(msg.value);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    Transfer(owner, msg.sender, tokens);\n', '           \n', '    }\n', '     function PayForServiceETH() external payable  {\n', '      \n', '      addressPayForService.transfer(msg.value);\n', '      PayForServiceETHEvent(msg.sender,msg.value);\n', '      \n', '  }\n', '    function PayForServiceCHL(uint256 _value)  external    {\n', '     \n', '      require(balances[msg.sender]>=_value&&_value>0);\n', '      \n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[addressPayForService] = balances[addressPayForService].add(_value);\n', '      PayForServiceCHLEvent(msg.sender,_value);\n', '      \n', '  }\n', '  function BurnTokensFrom(address _from, uint256 _value) external onlyOwner  {\n', '    require (balances[_from] >= _value&&_value>0);                \n', '   \n', '    balances[_from]  = balances[_from].sub(_value);\n', '    totalSupply =totalSupply.sub(_value);\n', '    BurnFrom(_from, _value);\n', '   \n', '}\n', '  \n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '  \n', '    uint256 c = a / b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', ' contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', ' contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract DOXToken is StandardToken, owned {\n', '\n', 'string public constant name = "DOX";\n', 'string public constant symbol = "DOX";\n', 'uint32 public constant decimals = 3;\n', 'uint256 public  exchangeRate=200;\n', 'uint256 public INITIAL_SUPPLY = 100000000 * 1000;\n', '\n', 'address addressSellAgent;\n', 'address addressSellAgentSiteReg;\n', 'address addressSellAgentCreators;\n', 'address addressSellAgentBounty;\n', 'address addressRateAgent;\n', ' \n', 'uint256 public START_PRESALE_TIMESTAMP   = 1523721600; \n', 'uint256 public START_PREICO_TIMESTAMP   = 1526313600;  \n', 'uint256 public START_ICO_TIMESTAMP   = 1528992000;     \n', ' \n', 'uint256 public END_PRESALE_TIMESTAMP   = 0;\n', 'uint256 public END_PREICO_TIMESTAMP   = 0;\n', 'uint256 public END_ICO_TIMESTAMP   = 0;\n', ' \n', 'uint256 public LOCKUP_3M_ICO_TIMESTAMP   = 0;\n', 'uint256 public LOCKUP_6M_ICO_TIMESTAMP   = 0;\n', ' \n', 'uint32 public  PRESALE_HARDCAP=  250000;\n', 'uint32 public   PREICO_HARDCAP=  950000;\n', 'uint32 public      ICO_HARDCAP=11450000;\n', '  \n', 'uint256 public   PRESALE_PERIOD=28;\n', 'uint256 public   PREICO_PERIOD=28;\n', 'uint256 public     ICO_PERIOD=28;\n', ' \n', 'address addressPayForService=0xF7F6c903467c0C8b9CF7C9D9eA8e24bA54d3bAdd;\n', '\n', '\n', '    \n', 'uint256 public tokensForBounty=0;\n', 'uint256 public tokensForSiteReg=0;\n', 'uint256 public tokensForCreators=0;\n', '        \n', '\n', 'mapping(address => uint256) arrayCreators;\n', 'mapping(address => uint256) arrayBounty;\n', '\n', 'event PayForServiceETHEvent(address indexed from, uint256 value);\n', 'event PayForServiceCHLEvent(address indexed from, uint256 value);\n', 'event BurnFrom(address indexed from, uint256 value);\n', '\n', 'event TransferCreators(address indexed to, uint256 value);\n', 'event TransferBounty(address indexed to, uint256 value);\n', 'event TransferSiteReg(address indexed to, uint256 value);\n', '\n', 'function DOXToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', ' \n', '        tokensForSiteReg= INITIAL_SUPPLY.div(100);\n', '        tokensForBounty= INITIAL_SUPPLY.mul(4).div(100);\n', '        tokensForCreators=INITIAL_SUPPLY.mul(2).div(10);\n', '     \n', '     \n', '        balances[msg.sender] = INITIAL_SUPPLY-tokensForBounty-tokensForCreators-tokensForSiteReg;\n', ' \n', '        END_PRESALE_TIMESTAMP=START_PRESALE_TIMESTAMP+(PRESALE_PERIOD * 1 days);  \n', '        END_PREICO_TIMESTAMP=START_PREICO_TIMESTAMP+(PREICO_PERIOD * 1 days);   \n', '        END_ICO_TIMESTAMP=START_ICO_TIMESTAMP+(ICO_PERIOD * 1 days);   \n', ' \n', '        LOCKUP_3M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(90 * 1 days); \n', '        LOCKUP_6M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(180 * 1 days);  \n', ' \n', '        addressSellAgent=msg.sender;\n', '        addressPayForService=msg.sender;\n', '        addressSellAgentSiteReg=msg.sender;\n', '        addressSellAgentCreators=msg.sender;\n', '        addressSellAgentBounty=msg.sender;\n', '        addressRateAgent=msg.sender;\n', ' \n', '}\n', '    function SetRate( uint32 newRate)   external returns (bool) {\n', '        require(msg.sender==addressRateAgent) ;\n', '        require(newRate>0);\n', '\t    exchangeRate = newRate;\n', '\t   return true;\n', '     }\n', '     \n', '       function Update_START_PRESALE_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t  START_PRESALE_TIMESTAMP = newTS;\n', '\t   END_PRESALE_TIMESTAMP=START_PRESALE_TIMESTAMP+(PRESALE_PERIOD * 1 days);  \n', '     }\n', '       function Update_START_PREICO_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t  START_PREICO_TIMESTAMP = newTS;\n', '\t  END_PREICO_TIMESTAMP=START_PREICO_TIMESTAMP+(PREICO_PERIOD * 1 days);  \n', '     }\n', '     \n', '        function Update_START_ICO_TIMESTAMP( uint256 newTS)  onlyOwner {\n', '\t    START_ICO_TIMESTAMP = newTS;\n', '\t    END_ICO_TIMESTAMP=START_ICO_TIMESTAMP+(ICO_PERIOD * 1 days);  \n', '\t    LOCKUP_3M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(90 * 1 days);  \n', '        LOCKUP_6M_ICO_TIMESTAMP=END_ICO_TIMESTAMP+(180 * 1 days);  \n', '     }\n', '     \n', '  \n', '  function UpdateSellAgent(address new_address) onlyOwner {\n', '   addressSellAgent=new_address;\n', '  }\n', '  \n', 'function UpdateSellAgentSiteReg(address new_address) onlyOwner {\n', '   addressSellAgentSiteReg=new_address;\n', '  }\n', '  function UpdateSellAgentBounty(address new_address) onlyOwner {\n', '   addressSellAgentBounty=new_address;\n', '  }\n', '  function UpdateSellAgentCreators(address new_address) onlyOwner {\n', '   addressSellAgentCreators=new_address;\n', '  }\n', '  function UpdateAddressPayForService(address new_address) onlyOwner {\n', '   addressPayForService=new_address;\n', '  }\n', '  \n', '   function UpdateRateAgent(address new_address) onlyOwner {\n', '   addressRateAgent=new_address;\n', '  }\n', '\n', ' \n', '   function TransferSellAgent(address _to, uint256 _value) external returns (bool) {\n', '      require(msg.sender==addressSellAgent) ;\n', '\n', '    balances[owner] = balances[owner].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(owner, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function TransferSellAgentMulti(address[] _toes, uint256 _value) external returns (bool) {\n', '      require(msg.sender==addressSellAgent) ;\n', '      \n', '       require(  balances[owner]>=_value.mul(_toes.length));\n', '      \n', '      for (uint i = 0; i < _toes.length; i++) {\n', '          \n', '        balances[owner] = balances[owner].sub(_value);\n', '        balances[_toes[i]] = balances[_toes[i]].add(_value);\n', '         \n', '     Transfer(owner, _toes[i], _value);\n', '\n', '        }\n', '  \n', '\n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '     function TransferSellAgentSiteReg(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentSiteReg) ;\n', '    require(tokensForSiteReg>=_value);\n', '    \n', '\n', '    tokensForSiteReg = tokensForSiteReg.sub(_value);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '\n', '    TransferSiteReg( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '    function TransferSellAgentSiteRegMulti(address[] _toes, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentSiteReg);\n', '    require(tokensForSiteReg>=_value.mul(_toes.length));\n', '    \n', '     for (uint i = 0; i < _toes.length; i++) {\n', '         \n', '        tokensForSiteReg = tokensForSiteReg.sub(_value);\n', '        balances[_toes[i]] = balances[_toes[i]].add(_value);\n', '        TransferSiteReg(_toes[i], _value);\n', '        }\n', '        \n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '  function TransferSellAgentBounty(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentBounty) ;\n', '    require(tokensForBounty>=_value);\n', '     require(now>END_ICO_TIMESTAMP );\n', '    \n', '    tokensForBounty = tokensForBounty.sub(_value);\n', '    arrayBounty[_to]=arrayBounty[_to].add(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    TransferBounty( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '    function TransferSellAgentCreators(address _to, uint256 _value) external returns (bool) {\n', '    require(msg.sender==addressSellAgentCreators) ;\n', '    require(tokensForCreators>=_value);\n', '    require(now>END_ICO_TIMESTAMP );\n', '    \n', '    tokensForCreators = tokensForCreators.sub(_value);\n', '    arrayCreators[_to]=arrayCreators[_to].add(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    TransferCreators( _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  \n', '\n', '  \n', '   modifier isSelling() {\n', '    require( ((now>START_PRESALE_TIMESTAMP&&now<END_PRESALE_TIMESTAMP ) ||(now>START_PREICO_TIMESTAMP&&now<END_PREICO_TIMESTAMP ) ||(now>START_ICO_TIMESTAMP&&now<END_ICO_TIMESTAMP ) ) );\n', '     require(balances[owner]>0 );\n', '    \n', '    \n', '    _;\n', '  }\n', '  \n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        require(!( arrayCreators[msg.sender]>0)||now>LOCKUP_6M_ICO_TIMESTAMP);\n', '        require(!( arrayBounty[msg.sender]>0) ||now>LOCKUP_3M_ICO_TIMESTAMP);\n', '        \n', '       \n', '        \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  \n', '    function() external payable isSelling {\n', '\n', '     uint tokens = exchangeRate.mul(5000).mul(msg.value).div(1 ether);\n', '     uint newBalance=exchangeRate.mul(msg.value+owner.balance).div(1 ether);\n', '\n', 'if (now>START_PRESALE_TIMESTAMP&&now<END_PRESALE_TIMESTAMP)\n', '{\n', '    require(newBalance<PRESALE_HARDCAP);\n', '    \n', '       tokens=tokens.mul(3).div(2);\n', '    \n', '       \n', '} else \n', '\n', 'if (now>START_PREICO_TIMESTAMP&&now<END_PREICO_TIMESTAMP)\n', '{\n', '    require(newBalance<PREICO_HARDCAP);\n', '    \n', '      uint bonusTokens = 0;\n', '        if(now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4)) {\n', '          bonusTokens = tokens.mul(3).div(10);\n', '        } else if(now >= START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4) && now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(2)) {\n', '          bonusTokens = tokens.div(4);\n', '        } else if(now >= START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(2) && now < START_PREICO_TIMESTAMP + (PREICO_PERIOD * 1 days).div(4).mul(3)) {\n', '          bonusTokens = tokens.div(5);\n', '        } else\n', '        {\n', '             bonusTokens = tokens.mul(3).div(20);\n', '        }\n', '        \n', '        \n', '        tokens += bonusTokens;\n', '       \n', '       \n', '} else \n', '     \n', '     if (now>START_ICO_TIMESTAMP&&now<END_ICO_TIMESTAMP)\n', '{\n', '    require(newBalance<ICO_HARDCAP);\n', '    \n', '      uint bonusTokensICO = 0;\n', '        if(now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4)) {\n', '          bonusTokensICO = tokens.div(8);\n', '        } else if(now >= START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4) && now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(2)) {\n', '          bonusTokensICO = tokens.mul(2).div(15);\n', '        } else if(now >= START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(2) && now < START_ICO_TIMESTAMP + (ICO_PERIOD * 1 days).div(4).mul(3)) {\n', '          bonusTokensICO = tokens.div(40);\n', '        } else\n', '        {\n', '             bonusTokensICO =0;\n', '        }\n', '        \n', '        \n', '        tokens += bonusTokensICO;\n', '       \n', '       \n', '} else {\n', '   revert();\n', '}\n', '  \n', '     \n', '  \n', '    owner.transfer(msg.value);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    Transfer(owner, msg.sender, tokens);\n', '           \n', '    }\n', '     function PayForServiceETH() external payable  {\n', '      \n', '      addressPayForService.transfer(msg.value);\n', '      PayForServiceETHEvent(msg.sender,msg.value);\n', '      \n', '  }\n', '    function PayForServiceCHL(uint256 _value)  external    {\n', '     \n', '      require(balances[msg.sender]>=_value&&_value>0);\n', '      \n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[addressPayForService] = balances[addressPayForService].add(_value);\n', '      PayForServiceCHLEvent(msg.sender,_value);\n', '      \n', '  }\n', '  function BurnTokensFrom(address _from, uint256 _value) external onlyOwner  {\n', '    require (balances[_from] >= _value&&_value>0);                \n', '   \n', '    balances[_from]  = balances[_from].sub(_value);\n', '    totalSupply =totalSupply.sub(_value);\n', '    BurnFrom(_from, _value);\n', '   \n', '}\n', '  \n', '}']
