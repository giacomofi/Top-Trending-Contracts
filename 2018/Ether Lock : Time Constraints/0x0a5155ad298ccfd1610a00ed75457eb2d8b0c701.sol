['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' * OASIS is an international community of financially independent people,\n', ' * united by the principles of trust and mutual assistance.\n', ' * \n', ' * This community was implemented based on the Ethereum smart contract.\n', ' * The technology is completely transparent and has no analogues in the world.\n', ' * Ethereum blockchain stores all the information concerning the distribution \n', ' * of community finances.\n', ' * \n', ' * Smart contract stores the funds of community members, managing payments\n', ' * according to the algorithm. This function allows the community to develop\n', ' * on the principles of trust and mutual assistance.\n', ' * \n', ' * The community has activated smart contract’s “REFUSE FROM OWNERSHIP” function,\n', ' * thus, no one can change this smart contract, including the community creators.\n', ' * \n', ' * The community distributes funds in accordance with the following scheme:\n', ' *   80% for community members;\n', ' *   15% for advertising budget;\n', ' *   4% for technical support;\n', ' *   1% to contribute to SENS Research Foundation.\n', ' * \n', ' * The profit is 3% for 24 hours (interest is accrued continuously).\n', ' * The deposit is included in the payments, 50 days after the deposit is over and eliminated.\n', ' * Minimum deposit is 0.01 ETH.\n', ' * Each deposit is a new deposit contributed to the community.\n', ' * No more than 50 deposits from one ETH wallet are allowed.\n', ' * \n', ' * Referral system:\n', ' *   Line 1 - 3%\n', ' *   Line 2 - 2%\n', ' *   Line 3 - 1%\n', ' * If you indicate your referral, you get 50% refback from Line 1.\n', ' * \n', ' * How to make a deposit:\n', ' *   Send cryptocurrency from ETH wallet (at least 0.01 ETH) to the address\n', ' *   of the smart contract - 0x0A5155AD298CcfD1610A00eD75457eb2d8B0C701\n', ' * \n', ' * Recommended limits are 200000 ETH, check the current ETH rate at\n', ' * the following link: https://ethgasstation.info/\n', ' * \n', ' * How to get paid:\n', ' *   Request your profit by sending 0 ETH to the address of the smart contract.\n', ' * \n', ' * It is not allowed to make transfers from cryptocurrency exchanges.\n', ' * Only personal ETH wallet with private keys is allowed.\n', ' * \n', ' * The source code of this smart contract was created by CryptoManiacs.\n', ' */\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Oasis.sol\n', '\n', 'contract Oasis {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ONE_HUNDRED_PERCENTS = 10000;               // 100%\n', '    uint256 constant public DAILY_INTEREST = 300;                       // 3%\n', '    uint256 constant public MARKETING_FEE = 1500;                       // 15%\n', '    uint256 constant public TEAM_FEE = 400;                             // 4%\n', '    uint256 constant public CHARITY_FEE = 100;                          // 1%\n', '    uint256 constant public MAX_DEPOSIT_TIME = 50 days;                 // 150%\n', '    uint256 constant public REFERRER_ACTIVATION_PERIOD = 0;\n', '    uint256 constant public MAX_USER_DEPOSITS_COUNT = 50;\n', '    uint256 constant public REFBACK_PERCENT = 150;                      // 1.5%\n', '    uint256[] /*constant*/ public referralPercents = [150, 200, 100];   // 1.5%, 2%, 1%\n', '\n', '    struct Deposit {\n', '        uint256 time;\n', '        uint256 amount;\n', '    }\n', '\n', '    struct User {\n', '        address referrer;\n', '        uint256 firstTime;\n', '        uint256 lastPayment;\n', '        Deposit[] deposits;\n', '    }\n', '\n', '    address public marketing = 0xDB6827de6b9Fc722Dc4EFa7e35f3b78c54932494;\n', '    address public team = 0x31CdA77ab136c8b971511473c3D04BBF7EAe8C0f;\n', '    address public charity = 0x36c92a9Da5256EaA5Ccc355415271b7d2682f32E;\n', '    uint256 public totalDeposits;\n', '    bool public running = true;\n', '    mapping(address => User) public users;\n', '\n', '    event InvestorAdded(address indexed investor);\n', '    event ReferrerAdded(address indexed investor, address indexed referrer);\n', '    event DepositAdded(address indexed investor, uint256 indexed depositsCount, uint256 amount);\n', '    event UserDividendPayed(address indexed investor, uint256 dividend);\n', '    event DepositDividendPayed(address indexed investor, uint256 indexed index, uint256 deposit, uint256 totalPayed, uint256 dividend);\n', '    event ReferrerPayed(address indexed investor, address indexed referrer, uint256 amount, uint256 refAmount, uint256 indexed level);\n', '    event FeePayed(address indexed investor, uint256 amount);\n', '    event TotalDepositsChanged(uint256 totalDeposits);\n', '    event BalanceChanged(uint256 balance);\n', '    \n', '    function() public payable {\n', '        require(running, "Oasis is not running");\n', '        User storage user = users[msg.sender];\n', '\n', '        // Dividends\n', '        uint256[] memory dividends = dividendsForUser(msg.sender);\n', '        uint256 dividendsSum = _dividendsSum(dividends);\n', '        if (dividendsSum > 0) {\n', '            if (dividendsSum >= address(this).balance) {\n', '                dividendsSum = address(this).balance;\n', '                running = false;\n', '            }\n', '\n', '            msg.sender.transfer(dividendsSum);\n', '            user.lastPayment = now;\n', '            emit UserDividendPayed(msg.sender, dividendsSum);\n', '            for (uint i = 0; i < dividends.length; i++) {\n', '                emit DepositDividendPayed(\n', '                    msg.sender,\n', '                    i,\n', '                    user.deposits[i].amount,\n', '                    dividendsForAmountAndTime(user.deposits[i].amount, now.sub(user.deposits[i].time)),\n', '                    dividends[i]\n', '                );\n', '            }\n', '\n', '            // Cleanup deposits array a bit\n', '            for (i = 0; i < user.deposits.length; i++) {\n', '                if (now >= user.deposits[i].time.add(MAX_DEPOSIT_TIME)) {\n', '                    user.deposits[i] = user.deposits[user.deposits.length - 1];\n', '                    user.deposits.length -= 1;\n', '                    i -= 1;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Deposit\n', '        if (msg.value > 0) {\n', '            if (user.firstTime == 0) {\n', '                user.firstTime = now;\n', '                user.lastPayment = now;\n', '                emit InvestorAdded(msg.sender);\n', '            }\n', '\n', '            // Create deposit\n', '            user.deposits.push(Deposit({\n', '                time: now,\n', '                amount: msg.value\n', '            }));\n', '            require(user.deposits.length <= MAX_USER_DEPOSITS_COUNT, "Too many deposits per user");\n', '            emit DepositAdded(msg.sender, user.deposits.length, msg.value);\n', '\n', '            // Add to total deposits\n', '            totalDeposits = totalDeposits.add(msg.value);\n', '            emit TotalDepositsChanged(totalDeposits);\n', '\n', '            // Add referral if possible\n', '            if (user.referrer == address(0) && msg.data.length == 20) {\n', '                address referrer = _bytesToAddress(msg.data);\n', '                if (referrer != address(0) && referrer != msg.sender && users[referrer].firstTime > 0 && now >= users[referrer].firstTime.add(REFERRER_ACTIVATION_PERIOD))\n', '                {\n', '                    user.referrer = referrer;\n', '                    msg.sender.transfer(msg.value.mul(REFBACK_PERCENT).div(ONE_HUNDRED_PERCENTS));\n', '                    emit ReferrerAdded(msg.sender, referrer);\n', '                }\n', '            }\n', '\n', '            // Referrers fees\n', '            referrer = users[msg.sender].referrer;\n', '            for (i = 0; referrer != address(0) && i < referralPercents.length; i++) {\n', '                uint256 refAmount = msg.value.mul(referralPercents[i]).div(ONE_HUNDRED_PERCENTS);\n', '                referrer.send(refAmount); // solium-disable-line security/no-send\n', '                emit ReferrerPayed(msg.sender, referrer, msg.value, refAmount, i);\n', '                referrer = users[referrer].referrer;\n', '            }\n', '\n', '            // Marketing and team fees\n', '            uint256 marketingFee = msg.value.mul(MARKETING_FEE).div(ONE_HUNDRED_PERCENTS);\n', '            uint256 teamFee = msg.value.mul(TEAM_FEE).div(ONE_HUNDRED_PERCENTS);\n', '            uint256 charityFee = msg.value.mul(CHARITY_FEE).div(ONE_HUNDRED_PERCENTS);\n', '            marketing.send(marketingFee); // solium-disable-line security/no-send\n', '            team.send(teamFee); // solium-disable-line security/no-send\n', '            charity.send(charityFee); // solium-disable-line security/no-send\n', '            emit FeePayed(msg.sender, marketingFee.add(teamFee));\n', '        }\n', '\n', '        // Create referrer for free\n', '        if (user.deposits.length == 0 && msg.value == 0) {\n', '            user.firstTime = now;\n', '        }\n', '        emit BalanceChanged(address(this).balance);\n', '    }\n', '\n', '    function depositsCountForUser(address wallet) public view returns(uint256) {\n', '        return users[wallet].deposits.length;\n', '    }\n', '\n', '    function depositForUser(address wallet, uint256 index) public view returns(uint256 time, uint256 amount) {\n', '        time = users[wallet].deposits[index].time;\n', '        amount = users[wallet].deposits[index].amount;\n', '    }\n', '\n', '    function dividendsSumForUser(address wallet) public view returns(uint256 dividendsSum) {\n', '        return _dividendsSum(dividendsForUser(wallet));\n', '    }\n', '\n', '    function dividendsForUser(address wallet) public view returns(uint256[] dividends) {\n', '        User storage user = users[wallet];\n', '        dividends = new uint256[](user.deposits.length);\n', '\n', '        for (uint i = 0; i < user.deposits.length; i++) {\n', '            uint256 howOld = now.sub(user.deposits[i].time);\n', '            uint256 duration = now.sub(user.lastPayment);\n', '            if (howOld > MAX_DEPOSIT_TIME) {\n', '                uint256 overtime = howOld.sub(MAX_DEPOSIT_TIME);\n', '                duration = duration.sub(overtime);\n', '            }\n', '\n', '            dividends[i] = dividendsForAmountAndTime(user.deposits[i].amount, duration);\n', '        }\n', '    }\n', '\n', '    function dividendsForAmountAndTime(uint256 amount, uint256 duration) public pure returns(uint256) {\n', '        return amount\n', '            .mul(DAILY_INTEREST).div(ONE_HUNDRED_PERCENTS)\n', '            .mul(duration).div(1 days);\n', '    }\n', '\n', '    function _bytesToAddress(bytes data) private pure returns(address addr) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            addr := mload(add(data, 20)) \n', '        }\n', '    }\n', '\n', '    function _dividendsSum(uint256[] dividends) private pure returns(uint256 dividendsSum) {\n', '        for (uint i = 0; i < dividends.length; i++) {\n', '            dividendsSum = dividendsSum.add(dividends[i]);\n', '        }\n', '    }\n', '}']