['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    event ReceiveEther(address _from, uint256 _value);\n', '    event WithdrawEther(address _to, uint256 _value);\n', '    event WithdrawToken(address _token, address _to, uint256 _value);\n', '\n', '    /**\n', '         * @dev recording receiving ether from msn.sender\n', '         */\n', '    function () payable public {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw,send ether to target\n', '         * @param _to is where the ether will be sent to\n', '         *        _amount is the number of the ether\n', '         */\n', '    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        _to.transfer(_amount);\n', '        emit WithdrawEther(_to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '         * @param _to is where the tokens will be sent to\n', '         *        _value is the number of the token\n', '         */\n', '    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        tk.transfer(_to, _value);\n', '        emit WithdrawToken(_token, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, and then gain the tokens,\n', '     *      then take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '    //     require(_token != address(0));\n', '    //     require(_from != address(0));\n', '\n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.transferFrom(_from, this, _value));\n', '\n', '    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    // }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract LockedStorage is Withdrawable, Claimable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * account description\n', '     */\n', '    struct Account {\n', '        string name;\n', '        uint256 balance;\n', '        uint256 frozen;\n', '    }\n', '\n', '    // record lock time period and related token amount\n', '    struct TimeRec {\n', '        uint256 amount;\n', '        uint256 remain;\n', '        uint256 endTime;\n', '        uint256 releasePeriodEndTime;\n', '    }\n', '\n', '    mapping (address => Account) accounts;\n', '    mapping (address => bool) public frozenAccounts;\n', '    address[] accountAddresses;\n', '    mapping (address => TimeRec[]) frozenTimes;\n', '\n', '    uint256 public size;\n', '\n', '\n', '    /**\n', '         * @dev add deposit contract address for the default withdraw wallet\n', '     *\n', '     * @param _wallet the default withdraw wallet address\n', '     * @param _name the wallet owner&#39;s name\n', '     * @param _value the balance of the wallet need to be stored in this contract\n', '         */\n', '    function addAccount(address _wallet, string _name, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '\n', '        accounts[_wallet].balance = _value;\n', '        accounts[_wallet].frozen = 0;\n', '        accounts[_wallet].name = _name;\n', '\n', '        accountAddresses.push(_wallet);\n', '        size = size.add(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the account address list\n', '     *\n', '     * @param _wallet the account address in the list\n', '     */\n', '    function removeAccountAddress(address _wallet) internal returns (bool) {\n', '        uint i = 0;\n', '        for (;i < accountAddresses.length; i = i.add(1)) {\n', '            if (accountAddresses[i] == _wallet) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (i >= accountAddresses.length) {\n', '            return false;\n', '        }\n', '\n', '        while (i < accountAddresses.length.sub(1)) {\n', '            accountAddresses[i] = accountAddresses[i.add(1)];\n', '            i = i.add(1);\n', '        }\n', '\n', '        delete accountAddresses[accountAddresses.length.sub(1)];\n', '        accountAddresses.length = accountAddresses.length.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev remove deposit contract address from storage\n', '     *\n', '     * @param _wallet the corresponding deposit address\n', '         */\n', '    function removeAccount(address _wallet) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '\n', '        delete accounts[_wallet];\n', '        delete frozenAccounts[_wallet];\n', '        removeAccountAddress(_wallet);\n', '\n', '        size = size.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev add a time record of one account\n', '     *\n', '     * @param _target the account that holds a list of time records which record the freeze period\n', '     * @param _value the amount of the tokens\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function addLockedTime(address _target,\n', '                           uint256 _value,\n', '                           uint256 _frozenEndTime,\n', '                           uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        TimeRec[] storage lockedTimes = frozenTimes[_target];\n', '        lockedTimes.push(TimeRec(_value, _value, _frozenEndTime, _frozenEndTime.add(_releasePeriod)));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove a time records from the time records list of one account\n', '     *\n', '     * @param _target the account that holds a list of time records which record the freeze period\n', '     * @param _ind the account address index\n', '     */\n', '    function removeLockedTime(address _target, uint _ind) public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        TimeRec[] storage lockedTimes = frozenTimes[_target];\n', '        require(_ind < lockedTimes.length);\n', '\n', '        uint256 i = _ind;\n', '        while (i < lockedTimes.length.sub(1)) {\n', '            lockedTimes[i] = lockedTimes[i.add(1)];\n', '            i = i.add(1);\n', '        }\n', '\n', '        delete lockedTimes[lockedTimes.length.sub(1)];\n', '        lockedTimes.length = lockedTimes.length.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev increase balance of this deposit address\n', '     *\n', '     * @param _wallet the corresponding wallet address\n', '     * @param _value the amount that the balance will be increased\n', '         */\n', '    function increaseBalance(address _wallet, uint256 _value) public returns (bool) {\n', '        require(_wallet != address(0));\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        accounts[_wallet].balance = _balance.add(_value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev decrease balance of this deposit address\n', '     *\n', '     * @param _wallet the corresponding wallet address\n', '     * @param _value the amount that the balance will be decreased\n', '         */\n', '    function decreaseBalance(address _wallet, uint256 _value) public returns (bool) {\n', '        require(_wallet != address(0));\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        accounts[_wallet].balance = _balance.sub(_value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev freeze the tokens in the deposit address\n', '     *\n', '     * @param _wallet the wallet address\n', '     * @param _freeze to freeze or release\n', '     * @param _value the amount of tokens need to be frozen\n', '         */\n', '    function freezeTokens(address _wallet, bool _freeze, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '        // require(_value <= balanceOf(_deposit));\n', '\n', '        frozenAccounts[_wallet] = _freeze;\n', '        uint256 _frozen = accounts[_wallet].frozen;\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        uint256 freezeAble = _balance.sub(_frozen);\n', '        if (_freeze) {\n', '            if (_value > freezeAble) {\n', '                _value = freezeAble;\n', '            }\n', '            accounts[_wallet].frozen = _frozen.add(_value);\n', '        } else {\n', '            if (_value > _frozen) {\n', '                _value = _frozen;\n', '            }\n', '            accounts[_wallet].frozen = _frozen.sub(_value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev get the balance of the deposit account\n', '     *\n', '     * @param _wallet the wallet address\n', '         */\n', '    function isExisted(address _wallet) public view returns (bool) {\n', '        require(_wallet != address(0));\n', '        return (accounts[_wallet].balance != 0);\n', '    }\n', '\n', '    /**\n', '         * @dev get the wallet name for the deposit address\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function walletName(address _wallet) onlyOwner public view returns (string) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].name;\n', '    }\n', '\n', '    /**\n', '         * @dev get the balance of the deposit account\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function balanceOf(address _wallet) public view returns (uint256) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].balance;\n', '    }\n', '\n', '    /**\n', '         * @dev get the frozen amount of the deposit address\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function frozenAmount(address _wallet) public view returns (uint256) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].frozen;\n', '    }\n', '\n', '    /**\n', '         * @dev get the account address by index\n', '     *\n', '     * @param _ind the account address index\n', '         */\n', '    function addressByIndex(uint256 _ind) public view returns (address) {\n', '        return accountAddresses[_ind];\n', '    }\n', '\n', '    /**\n', '     * @dev set the new endtime of the released time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     * @param _newEndTime the new endtime for the lock period\n', '     */\n', '    function changeEndTime(address _target, uint256 _ind, uint256 _newEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_newEndTime > 0);\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.endTime = _newEndTime;\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new released period end time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     * @param _newReleaseEndTime the new endtime for the releasing period\n', '     */\n', '    function setNewReleaseEndTime(address _target, uint256 _ind, uint256 _newReleaseEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_newReleaseEndTime > 0);\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.releasePeriodEndTime = _newReleaseEndTime;\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev decrease the remaining locked amount of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function decreaseRemainLockedOf(address _target, uint256 _ind, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.remain = timePair.remain.sub(_value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev get the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     */\n', '    function lockedStagesNum(address _target) public view returns (uint) {\n', '        require(_target != address(0));\n', '        return (isExisted(_target) ? frozenTimes[_target].length : 0);\n', '    }\n', '\n', '    /**\n', '     * @dev get the endtime of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function endTimeOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.endTime;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function remainOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.remain;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function amountOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.amount;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain releasing period end time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function releaseEndTimeOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.releasePeriodEndTime;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    event ReceiveEther(address _from, uint256 _value);\n', '    event WithdrawEther(address _to, uint256 _value);\n', '    event WithdrawToken(address _token, address _to, uint256 _value);\n', '\n', '    /**\n', '         * @dev recording receiving ether from msn.sender\n', '         */\n', '    function () payable public {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw,send ether to target\n', '         * @param _to is where the ether will be sent to\n', '         *        _amount is the number of the ether\n', '         */\n', '    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        _to.transfer(_amount);\n', '        emit WithdrawEther(_to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '         * @param _to is where the tokens will be sent to\n', '         *        _value is the number of the token\n', '         */\n', '    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        tk.transfer(_to, _value);\n', '        emit WithdrawToken(_token, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, and then gain the tokens,\n', '     *      then take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '    //     require(_token != address(0));\n', '    //     require(_from != address(0));\n', '\n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.transferFrom(_from, this, _value));\n', '\n', '    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    // }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract LockedStorage is Withdrawable, Claimable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * account description\n', '     */\n', '    struct Account {\n', '        string name;\n', '        uint256 balance;\n', '        uint256 frozen;\n', '    }\n', '\n', '    // record lock time period and related token amount\n', '    struct TimeRec {\n', '        uint256 amount;\n', '        uint256 remain;\n', '        uint256 endTime;\n', '        uint256 releasePeriodEndTime;\n', '    }\n', '\n', '    mapping (address => Account) accounts;\n', '    mapping (address => bool) public frozenAccounts;\n', '    address[] accountAddresses;\n', '    mapping (address => TimeRec[]) frozenTimes;\n', '\n', '    uint256 public size;\n', '\n', '\n', '    /**\n', '         * @dev add deposit contract address for the default withdraw wallet\n', '     *\n', '     * @param _wallet the default withdraw wallet address\n', "     * @param _name the wallet owner's name\n", '     * @param _value the balance of the wallet need to be stored in this contract\n', '         */\n', '    function addAccount(address _wallet, string _name, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '\n', '        accounts[_wallet].balance = _value;\n', '        accounts[_wallet].frozen = 0;\n', '        accounts[_wallet].name = _name;\n', '\n', '        accountAddresses.push(_wallet);\n', '        size = size.add(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the account address list\n', '     *\n', '     * @param _wallet the account address in the list\n', '     */\n', '    function removeAccountAddress(address _wallet) internal returns (bool) {\n', '        uint i = 0;\n', '        for (;i < accountAddresses.length; i = i.add(1)) {\n', '            if (accountAddresses[i] == _wallet) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (i >= accountAddresses.length) {\n', '            return false;\n', '        }\n', '\n', '        while (i < accountAddresses.length.sub(1)) {\n', '            accountAddresses[i] = accountAddresses[i.add(1)];\n', '            i = i.add(1);\n', '        }\n', '\n', '        delete accountAddresses[accountAddresses.length.sub(1)];\n', '        accountAddresses.length = accountAddresses.length.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev remove deposit contract address from storage\n', '     *\n', '     * @param _wallet the corresponding deposit address\n', '         */\n', '    function removeAccount(address _wallet) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '\n', '        delete accounts[_wallet];\n', '        delete frozenAccounts[_wallet];\n', '        removeAccountAddress(_wallet);\n', '\n', '        size = size.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev add a time record of one account\n', '     *\n', '     * @param _target the account that holds a list of time records which record the freeze period\n', '     * @param _value the amount of the tokens\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function addLockedTime(address _target,\n', '                           uint256 _value,\n', '                           uint256 _frozenEndTime,\n', '                           uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        TimeRec[] storage lockedTimes = frozenTimes[_target];\n', '        lockedTimes.push(TimeRec(_value, _value, _frozenEndTime, _frozenEndTime.add(_releasePeriod)));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove a time records from the time records list of one account\n', '     *\n', '     * @param _target the account that holds a list of time records which record the freeze period\n', '     * @param _ind the account address index\n', '     */\n', '    function removeLockedTime(address _target, uint _ind) public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        TimeRec[] storage lockedTimes = frozenTimes[_target];\n', '        require(_ind < lockedTimes.length);\n', '\n', '        uint256 i = _ind;\n', '        while (i < lockedTimes.length.sub(1)) {\n', '            lockedTimes[i] = lockedTimes[i.add(1)];\n', '            i = i.add(1);\n', '        }\n', '\n', '        delete lockedTimes[lockedTimes.length.sub(1)];\n', '        lockedTimes.length = lockedTimes.length.sub(1);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev increase balance of this deposit address\n', '     *\n', '     * @param _wallet the corresponding wallet address\n', '     * @param _value the amount that the balance will be increased\n', '         */\n', '    function increaseBalance(address _wallet, uint256 _value) public returns (bool) {\n', '        require(_wallet != address(0));\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        accounts[_wallet].balance = _balance.add(_value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev decrease balance of this deposit address\n', '     *\n', '     * @param _wallet the corresponding wallet address\n', '     * @param _value the amount that the balance will be decreased\n', '         */\n', '    function decreaseBalance(address _wallet, uint256 _value) public returns (bool) {\n', '        require(_wallet != address(0));\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        accounts[_wallet].balance = _balance.sub(_value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev freeze the tokens in the deposit address\n', '     *\n', '     * @param _wallet the wallet address\n', '     * @param _freeze to freeze or release\n', '     * @param _value the amount of tokens need to be frozen\n', '         */\n', '    function freezeTokens(address _wallet, bool _freeze, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '        // require(_value <= balanceOf(_deposit));\n', '\n', '        frozenAccounts[_wallet] = _freeze;\n', '        uint256 _frozen = accounts[_wallet].frozen;\n', '        uint256 _balance = accounts[_wallet].balance;\n', '        uint256 freezeAble = _balance.sub(_frozen);\n', '        if (_freeze) {\n', '            if (_value > freezeAble) {\n', '                _value = freezeAble;\n', '            }\n', '            accounts[_wallet].frozen = _frozen.add(_value);\n', '        } else {\n', '            if (_value > _frozen) {\n', '                _value = _frozen;\n', '            }\n', '            accounts[_wallet].frozen = _frozen.sub(_value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev get the balance of the deposit account\n', '     *\n', '     * @param _wallet the wallet address\n', '         */\n', '    function isExisted(address _wallet) public view returns (bool) {\n', '        require(_wallet != address(0));\n', '        return (accounts[_wallet].balance != 0);\n', '    }\n', '\n', '    /**\n', '         * @dev get the wallet name for the deposit address\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function walletName(address _wallet) onlyOwner public view returns (string) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].name;\n', '    }\n', '\n', '    /**\n', '         * @dev get the balance of the deposit account\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function balanceOf(address _wallet) public view returns (uint256) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].balance;\n', '    }\n', '\n', '    /**\n', '         * @dev get the frozen amount of the deposit address\n', '     *\n', '     * @param _wallet the deposit address\n', '         */\n', '    function frozenAmount(address _wallet) public view returns (uint256) {\n', '        require(_wallet != address(0));\n', '        return accounts[_wallet].frozen;\n', '    }\n', '\n', '    /**\n', '         * @dev get the account address by index\n', '     *\n', '     * @param _ind the account address index\n', '         */\n', '    function addressByIndex(uint256 _ind) public view returns (address) {\n', '        return accountAddresses[_ind];\n', '    }\n', '\n', '    /**\n', '     * @dev set the new endtime of the released time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     * @param _newEndTime the new endtime for the lock period\n', '     */\n', '    function changeEndTime(address _target, uint256 _ind, uint256 _newEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_newEndTime > 0);\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.endTime = _newEndTime;\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new released period end time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     * @param _newReleaseEndTime the new endtime for the releasing period\n', '     */\n', '    function setNewReleaseEndTime(address _target, uint256 _ind, uint256 _newReleaseEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_newReleaseEndTime > 0);\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.releasePeriodEndTime = _newReleaseEndTime;\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev decrease the remaining locked amount of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function decreaseRemainLockedOf(address _target, uint256 _ind, uint256 _value) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec storage timePair = frozenTimes[_target][_ind];\n', '            timePair.remain = timePair.remain.sub(_value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev get the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     */\n', '    function lockedStagesNum(address _target) public view returns (uint) {\n', '        require(_target != address(0));\n', '        return (isExisted(_target) ? frozenTimes[_target].length : 0);\n', '    }\n', '\n', '    /**\n', '     * @dev get the endtime of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function endTimeOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.endTime;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function remainOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.remain;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function amountOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.amount;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain releasing period end time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _ind the stage index of the locked stage\n', '     */\n', '    function releaseEndTimeOfStage(address _target, uint _ind) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        if (isExisted(_target)) {\n', '            TimeRec memory timePair = frozenTimes[_target][_ind];\n', '            return timePair.releasePeriodEndTime;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}']
