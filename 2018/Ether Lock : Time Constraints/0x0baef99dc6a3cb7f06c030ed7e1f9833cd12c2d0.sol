['// File: @laborx/solidity-shared-lib/contracts/ERC20Interface.sol\n', '\n', '/**\n', '* Copyright 2017–2018, LaborX PTY\n', '* Licensed under the AGPL Version 3 license.\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '\n', '/// @title Defines an interface for EIP20 token smart contract\n', 'contract ERC20Interface {\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    string public symbol;\n', '\n', '    function decimals() public view returns (uint8);\n', '    function totalSupply() public view returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '}\n', '\n', '// File: @laborx/solidity-shared-lib/contracts/Owned.sol\n', '\n', '/**\n', '* Copyright 2017–2018, LaborX PTY\n', '* Licensed under the AGPL Version 3 license.\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '\n', '\n', '/// @title Owned contract with safe ownership pass.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', "/// didn't happen yet.\n", 'contract Owned {\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    address public contractOwner;\n', '    address public pendingContractOwner;\n', '\n', '    modifier onlyContractOwner {\n', '        if (msg.sender == contractOwner) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    constructor()\n', '    public\n', '    {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /// @notice Prepares ownership pass.\n', '    /// Can only be called by current owner.\n', '    /// @param _to address of the next owner.\n', '    /// @return success.\n', '    function changeContractOwnership(address _to)\n', '    public\n', '    onlyContractOwner\n', '    returns (bool)\n', '    {\n', '        if (_to == 0x0) {\n', '            return false;\n', '        }\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Finalize ownership pass.\n', '    /// Can only be called by pending owner.\n', '    /// @return success.\n', '    function claimContractOwnership()\n', '    public\n', '    returns (bool)\n', '    {\n', '        if (msg.sender != pendingContractOwner) {\n', '            return false;\n', '        }\n', '\n', '        emit OwnershipTransferred(contractOwner, pendingContractOwner);\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner)\n', '    public\n', '    onlyContractOwner\n', '    returns (bool)\n', '    {\n', '        if (newOwner == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        emit OwnershipTransferred(contractOwner, newOwner);\n', '        contractOwner = newOwner;\n', '        delete pendingContractOwner;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @dev Backward compatibility only.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferContractOwnership(address newOwner)\n', '    public\n', '    returns (bool)\n', '    {\n', '        return transferOwnership(newOwner);\n', '    }\n', '\n', '    /// @notice Withdraw given tokens from contract to owner.\n', '    /// This method is only allowed for contact owner.\n', '    function withdrawTokens(address[] tokens)\n', '    public\n', '    onlyContractOwner\n', '    {\n', '        address _contractOwner = contractOwner;\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20Interface token = ERC20Interface(tokens[i]);\n', '            uint balance = token.balanceOf(this);\n', '            if (balance > 0) {\n', '                token.transfer(_contractOwner, balance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Withdraw ether from contract to owner.\n', '    /// This method is only allowed for contact owner.\n', '    function withdrawEther()\n', '    public\n', '    onlyContractOwner\n', '    {\n', '        uint balance = address(this).balance;\n', '        if (balance > 0)  {\n', '            contractOwner.transfer(balance);\n', '        }\n', '    }\n', '\n', '    /// @notice Transfers ether to another address.\n', '    /// Allowed only for contract owners.\n', '    /// @param _to recepient address\n', '    /// @param _value wei to transfer; must be less or equal to total balance on the contract\n', '    function transferEther(address _to, uint256 _value)\n', '    public\n', '    onlyContractOwner\n', '    {\n', '        require(_to != 0x0, "INVALID_ETHER_RECEPIENT_ADDRESS");\n', '        if (_value > address(this).balance) {\n', '            revert("INVALID_VALUE_TO_TRANSFER_ETHER");\n', '        }\n', '\n', '        _to.transfer(_value);\n', '    }\n', '}\n', '\n', '// File: @laborx/solidity-eventshistory-lib/contracts/EventsHistorySourceAdapter.sol\n', '\n', '/**\n', '* Copyright 2017–2018, LaborX PTY\n', '* Licensed under the AGPL Version 3 license.\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title EventsHistory Source Adapter.\n', ' */\n', 'contract EventsHistorySourceAdapter {\n', '\n', '    // It is address of MultiEventsHistory caller assuming we are inside of delegate call.\n', '    function _self()\n', '    internal\n', '    view\n', '    returns (address)\n', '    {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', '// File: @laborx/solidity-eventshistory-lib/contracts/MultiEventsHistoryAdapter.sol\n', '\n', '/**\n', '* Copyright 2017–2018, LaborX PTY\n', '* Licensed under the AGPL Version 3 license.\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title General MultiEventsHistory user.\n', ' */\n', 'contract MultiEventsHistoryAdapter is EventsHistorySourceAdapter {\n', '\n', '    address internal localEventsHistory;\n', '\n', '    event ErrorCode(address indexed self, uint errorCode);\n', '\n', '    function getEventsHistory()\n', '    public\n', '    view\n', '    returns (address)\n', '    {\n', '        address _eventsHistory = localEventsHistory;\n', '        return _eventsHistory != 0x0 ? _eventsHistory : this;\n', '    }\n', '\n', '    function emitErrorCode(uint _errorCode) public {\n', '        emit ErrorCode(_self(), _errorCode);\n', '    }\n', '\n', '    function _setEventsHistory(address _eventsHistory) internal returns (bool) {\n', '        localEventsHistory = _eventsHistory;\n', '        return true;\n', '    }\n', '    \n', '    function _emitErrorCode(uint _errorCode) internal returns (uint) {\n', '        MultiEventsHistoryAdapter(getEventsHistory()).emitErrorCode(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}\n', '\n', '// File: contracts/StorageManager.sol\n', '\n', '/**\n', ' * Copyright 2017–2018, LaborX PTY\n', ' * Licensed under the AGPL Version 3 license.\n', ' */\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '\n', '\n', '\n', 'contract StorageManager is Owned, MultiEventsHistoryAdapter {\n', '\n', '    uint constant OK = 1;\n', '\n', '    event AccessGiven(address indexed self, address indexed actor, bytes32 role);\n', '    event AccessBlocked(address indexed self, address indexed actor, bytes32 role);\n', '    event AuthorizationGranted(address indexed self, address indexed account);\n', '    event AuthorizationRevoked(address indexed self, address indexed account);\n', '\n', '    mapping (address => uint) public authorised;\n', '    mapping (bytes32 => bool) public accessRights;\n', '    mapping (address => bool) public acl;\n', '\n', '    modifier onlyAuthorized {\n', '        if (msg.sender == contractOwner || acl[msg.sender]) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function setupEventsHistory(address _eventsHistory)\n', '    external\n', '    onlyContractOwner\n', '    returns (uint)\n', '    {\n', '        _setEventsHistory(_eventsHistory);\n', '        return OK;\n', '    }\n', '\n', '    function authorize(address _address)\n', '    external\n', '    onlyAuthorized\n', '    returns (uint)\n', '    {\n', '        require(_address != 0x0, "STORAGE_MANAGER_INVALID_ADDRESS");\n', '        acl[_address] = true;\n', '\n', '        _emitter().emitAuthorizationGranted(_address);\n', '        return OK;\n', '    }\n', '\n', '    function revoke(address _address)\n', '    external\n', '    onlyContractOwner\n', '    returns (uint)\n', '    {\n', '        require(acl[_address], "STORAGE_MANAGER_ADDRESS_SHOULD_EXIST");\n', '        delete acl[_address];\n', '\n', '        _emitter().emitAuthorizationRevoked(_address);\n', '        return OK;\n', '    }\n', '\n', '    function giveAccess(address _actor, bytes32 _role)\n', '    external\n', '    onlyAuthorized\n', '    returns (uint)\n', '    {\n', '        if (!accessRights[_getKey(_actor, _role)]) {\n', '            accessRights[_getKey(_actor, _role)] = true;\n', '            authorised[_actor] += 1;\n', '            _emitter().emitAccessGiven(_actor, _role);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    function blockAccess(address _actor, bytes32 _role)\n', '    external\n', '    onlyAuthorized\n', '    returns (uint)\n', '    {\n', '        if (accessRights[_getKey(_actor, _role)]) {\n', '            delete accessRights[_getKey(_actor, _role)];\n', '            authorised[_actor] -= 1;\n', '            if (authorised[_actor] == 0) {\n', '                delete authorised[_actor];\n', '            }\n', '            _emitter().emitAccessBlocked(_actor, _role);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    function isAllowed(address _actor, bytes32 _role)\n', '    public\n', '    view\n', '    returns (bool)\n', '    {\n', '        return accessRights[keccak256(abi.encodePacked(_actor, _role))] || (this == _actor);\n', '    }\n', '\n', '    function hasAccess(address _actor)\n', '    public\n', '    view\n', '    returns (bool)\n', '    {\n', '        return (authorised[_actor] > 0) || (address(this) == _actor);\n', '    }\n', '\n', '    function emitAccessGiven(address _user, bytes32 _role) public {\n', '        emit AccessGiven(_self(), _user, _role);\n', '    }\n', '\n', '    function emitAccessBlocked(address _user, bytes32 _role) public {\n', '        emit AccessBlocked(_self(), _user, _role);\n', '    }\n', '\n', '    function emitAuthorizationGranted(address _account) public {\n', '        emit AuthorizationGranted(_self(), _account);\n', '    }\n', '\n', '    function emitAuthorizationRevoked(address _account) public {\n', '        emit AuthorizationRevoked(_self(), _account);\n', '    }\n', '\n', '    function _emitter() internal view returns (StorageManager) {\n', '        return StorageManager(getEventsHistory());\n', '    }\n', '\n', '    function _getKey(address _actor, bytes32 _role) private pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(_actor, _role));\n', '    }\n', '}']