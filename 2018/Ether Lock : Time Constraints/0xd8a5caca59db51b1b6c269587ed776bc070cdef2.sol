['pragma solidity ^0.4.25;\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner = 0x0;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '     modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract CryptoSoulPresale is Ownable{\n', '    struct DataBase{\n', '        uint256 deposit;\n', '        uint256 soulValue;\n', '    }\n', '    \n', '    mapping(address => DataBase) wallets;\n', '    \n', '    uint32 public usersCount = 0;\n', '    uint32 public depositsCount = 0;\n', '    \n', '    uint256 public constant soulCap = 50000000;\n', '    \n', '    uint256 public collectedFunds = 0;\n', '    uint256 public distributedTokens = 0;\n', '    \n', '    uint256 internal soulReward0 = 34000;\n', '    uint256 internal soulReward1 = 40000;\n', '    uint256 internal soulReward2 = 50000;\n', '    \n', '    uint256 public minDeposit = 0.1 ether;\n', '    uint256 internal ethPriceLvl0 = 2.99 ether;\n', '    uint256 internal ethPriceLvl1 = 9.99 ether;\n', '    \n', '    function() external payable{\n', '        require(msg.value >= minDeposit &&\n', '        distributedTokens < soulCap);\n', '        uint256 ethValue = msg.value;\n', '        uint256 soulValue = getSoulByEth(ethValue);     \n', '        uint256 totalSoulValue = distributedTokens + soulValue;\n', '        if (totalSoulValue > soulCap){\n', '            soulValue = soulCap - distributedTokens;\n', '            ethValue = getResidualEtherAmount(ethValue, soulValue);\n', '            uint256 etherNickel = msg.value - ethValue;\n', '            msg.sender.transfer(etherNickel);\n', '        }\n', '        owner.transfer(ethValue);\n', '        depositsCount++;\n', '        countUser(msg.sender);\n', '        wallets[msg.sender].deposit += ethValue;\n', '        wallets[msg.sender].soulValue += soulValue;\n', '        collectedFunds += ethValue;\n', '        distributedTokens += soulValue;\n', '    }\n', '  \n', '  function getDepositValue(address _owner) public view returns(uint256){\n', '      return wallets[_owner].deposit;\n', '  }\n', '  \n', '  function balanceOf(address _owner) public view returns(uint256){\n', '      return wallets[_owner].soulValue;\n', '  }\n', '  \n', '  function getResidualEtherAmount(uint256 _ethValue, uint256 _soulResidual) internal view returns(uint256){\n', '      return _soulResidual * 10 ** 18 / getRewardLevel(_ethValue);\n', '  }\n', '  \n', '   function getSoulByEth(uint256 _ethValue) internal view returns(uint256){\n', '       return (_ethValue * getRewardLevel(_ethValue)) / 10 ** 18;\n', '   }\n', '   \n', '   function getRewardLevel(uint256 _ethValue) internal view returns(uint256){\n', '        if (_ethValue <= ethPriceLvl0){\n', '           return soulReward0;\n', '       } else if (_ethValue > ethPriceLvl0 && _ethValue <= ethPriceLvl1){\n', '           return soulReward1;\n', '       } else if (_ethValue > ethPriceLvl1){\n', '           return soulReward2;\n', '       }\n', '   }\n', '   \n', '   function countUser(address _owner) internal{\n', '       if (wallets[_owner].deposit == 0){\n', '           usersCount++;\n', '       }\n', '   }\n', '   \n', '   function changeSoulReward(uint8 _level, uint256 _value) public onlyOwner{\n', '       require(_level >= 0 && _level <= 2);\n', '       if(_level == 0){\n', '           soulReward0 = _value;\n', '       }else if(_level == 1){\n', '           soulReward1 = _value;\n', '       }else{\n', '           soulReward2 = _value;\n', '       }\n', '   }\n', '   \n', '   function changeMinDeposit(uint256 _value) public onlyOwner{\n', '       minDeposit = _value;\n', '   }\n', '   \n', '}']