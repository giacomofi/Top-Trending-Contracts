['pragma solidity ^0.4.21;\n', '\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '\n', '    function safeDiv(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        uint256 f = x / y;\n', '        return f;\n', '      }\n', '    }\n', '\n', 'contract ERC223ReceivingContract {\n', '\n', '    struct inr {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '      function tokenFallback(address _from, uint _value, bytes _data){\n', '      inr memory igniter;\n', '      igniter.sender = _from;\n', '      igniter.value = _value;\n', '      igniter.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      igniter.sig = bytes4(u);\n', '\n', '    }\n', '  }\n', '\n', 'contract iGniter is SafeMath {\n', '\n', '  struct serPayment {\n', '    uint256 unlockedBlockNumber;\n', '    uint256 unlockedTime;\n', '  }\n', '\n', '  struct dividends {\n', '    uint256 diviReg;\n', '    uint256 diviBlocks;\n', '    uint256 diviPayout;\n', '    uint256 diviBalance;\n', '    uint256 _tier1Reg;\n', '    uint256 _tier2Reg;\n', '    uint256 _tier3Reg;\n', '    uint256 _tier4Reg;\n', '    uint256 _tier5Reg;\n', '    uint256 _tier1Payout;\n', '    uint256 _tier2Payout;\n', '    uint256 _tier3Payout;\n', '    uint256 _tier4Payout;\n', '    uint256 _tier5Payout;\n', '    uint256 _tier1Blocks;\n', '    uint256 _tier2Blocks;\n', '    uint256 _tier3Blocks;\n', '    uint256 _tier4Blocks;\n', '    uint256 _tier5Blocks;\n', '    uint256 _tierPayouts;\n', '    uint256 hodlPayout;\n', '    uint256 _hodlReg;\n', '    uint256 _hodlBlocks;\n', '    uint256 INRpayout;\n', '    uint256 INR_lastbal;\n', '    uint256 INRpaid;\n', '    uint256 INRtransfers;\n', '    uint256 INRbalance;\n', '    uint256 transDiff;\n', '    uint256 individualRewards;\n', '  }\n', '\n', '    string public name;\n', '    bytes32 public symbol;\n', '    uint8 public decimals;\n', '    uint256 private dividendsPerBlockPerAddress;\n', '    uint256 private T1DividendsPerBlockPerAddress;\n', '    uint256 private T2DividendsPerBlockPerAddress;\n', '    uint256 private T3DividendsPerBlockPerAddress;\n', '    uint256 private T4DividendsPerBlockPerAddress;\n', '    uint256 private T5DividendsPerBlockPerAddress;\n', '    uint256 private hodlersDividendsPerBlockPerAddress;\n', '    uint256 private totalInitialAddresses;\n', '    uint256 private initialBlockCount;\n', '    uint256 private minedBlocks;\n', '    uint256 private iGniting;\n', '    uint256 private totalRewards;\n', '    uint256 private initialSupplyPerAddress;\n', '    uint256 private availableAmount;\n', '    uint256 private burnt;\n', '    uint256 private inrSessions;\n', '    uint256 private initialSupply;\n', '    uint256 public currentCost;\n', '    uint256 private blockStats;\n', '    uint256 private blockAverage;\n', '    uint256 private blockAvgDiff;\n', '    uint256 private divRewards;\n', '    uint256 private diviClaims;\n', '    uint256 private Tier1Amt;\n', '    uint256 private Tier2Amt;\n', '    uint256 private Tier3Amt;\n', '    uint256 private Tier4Amt;\n', '    uint256 private Tier5Amt;\n', '    uint256 private Tier1blocks;\n', '    uint256 private Tier2blocks;\n', '    uint256 private Tier3blocks;\n', '    uint256 private Tier4blocks;\n', '    uint256 private Tier5blocks;\n', '    uint256 private hodlBlocks;\n', '    uint256 private hodlersReward;\n', '    uint256 private hodlAmt;\n', '\n', '    uint256 private _tier1Avg;\n', '    uint256 private _tier1AvgDiff;\n', '    uint256 private _tier1Rewards;\n', '    uint256 private _tier2Avg;\n', '    uint256 private _tier2AvgDiff;\n', '    uint256 private _tier2Rewards;\n', '    uint256 private _tier3Avg;\n', '    uint256 private _tier3AvgDiff;\n', '    uint256 private _tier3Rewards;\n', '    uint256 private _tier4Avg;\n', '    uint256 private _tier4AvgDiff;\n', '    uint256 private _tier4Rewards;\n', '    uint256 private _tier5Avg;\n', '    uint256 private _tier5AvgDiff;\n', '    uint256 private _tier5Rewards;\n', '    uint256 private _hodlAvg;\n', '\n', '    uint256 private _hodlAvgDiff;\n', '    uint256 private _hodlRewards;\n', '\n', '    bool private t1active;\n', '    bool private t2active;\n', '    bool private t3active;\n', '    bool private t4active;\n', '    bool private t5active;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => bool) public initialAddress;\n', '    mapping(address => bool) public dividendAddress;\n', '    mapping(address => bool) public qualifiedAddress;\n', '    mapping(address => bool) public TierStarterDividendAddress;\n', '    mapping(address => bool) public TierBasicDividendAddress;\n', '    mapping(address => bool) public TierClassicDividendAddress;\n', '    mapping(address => bool) public TierWildcatDividendAddress;\n', '    mapping(address => bool) public TierRainmakerDividendAddress;\n', '    mapping(address => bool) public HODLERAddress;\n', '    mapping(address => mapping (address => uint)) internal _allowances;\n', '    mapping(address => serPayment) inrPayments;\n', '    mapping(address => dividends) INRdividends;\n', '\n', '    address private _Owner1;\n', '    address private _Owner2;\n', '    address private _Owner3;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    modifier isOwner() {\n', '\n', '      require(msg.sender == _Owner1 || msg.sender == _Owner2 || msg.sender == _Owner3);\n', '      _;\n', '    }\n', '\n', '    function iGniter() {\n', '\n', '        initialSupplyPerAddress = 10000000000; //10000 INR\n', '        initialBlockCount = 5150000;\n', '        dividendsPerBlockPerAddress = 7;\n', '        hodlersDividendsPerBlockPerAddress = 9000;\n', '        T1DividendsPerBlockPerAddress = 30;\n', '        T2DividendsPerBlockPerAddress = 360;\n', '        T3DividendsPerBlockPerAddress = 4200;\n', '        T4DividendsPerBlockPerAddress = 60000;\n', '        T5DividendsPerBlockPerAddress = 1200000;\n', '        totalInitialAddresses = 5000;\n', '        initialSupply = initialSupplyPerAddress * totalInitialAddresses;\n', '        minedBlocks = block.number - initialBlockCount;\n', '        availableAmount = dividendsPerBlockPerAddress * minedBlocks;\n', '        iGniting = availableAmount * totalInitialAddresses;\n', '        _Owner1 = 0x4804D96B17B03B2f5F65a4AaA4b5DB360e22909A;\n', '        _Owner2 = 0x16C890b06FE52e27ed514e7086378a355F1aB28a;\n', '        _Owner3 = 0xa4F78852c7F854b4585491a55FE1594913C2C05D;\n', '    }\n', '\n', '    function currentBlock() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number;\n', '    }\n', '\n', '    function blockDiff() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number - initialBlockCount;\n', '    }\n', '\n', '    function assignInitialAddresses(address[] _address) isOwner public returns (bool success)\n', '    {\n', '        if (block.number < 10000000)\n', '        {\n', '          for (uint i = 0; i < _address.length; i++)\n', '          {\n', '            balanceOf[_address[i]] = balanceOf[_address[i]] + initialSupplyPerAddress;\n', '            initialAddress[_address[i]] = true;\n', '          }\n', '\n', '          return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256 Balance)\n', '    {\n', '        if((qualifiedAddress[_address]) == true || (initialAddress[_address]) == true)\n', '        {\n', '            if (minedBlocks > 105120000) return balanceOf[_address]; //app. 2058\n', '\n', '            INRdividends[_address].INRpayout = dividendRewards(_address);\n', '\n', '            if (INRdividends[_address].INRpayout < INRdividends[_address].INRtransfers)\n', '            {\n', '                INRdividends[_address].INRpaid = 0;\n', '            }\n', '\n', '            if (INRdividends[_address].INRpayout >= INRdividends[_address].INRtransfers)\n', '            {\n', '                INRdividends[_address].transDiff = INRdividends[_address].INRpayout - INRdividends[_address].INRtransfers;\n', '                INRdividends[_address].INRpaid = INRdividends[_address].transDiff;\n', '            }\n', '\n', '            INRdividends[_address].INRbalance = balanceOf[_address] + INRdividends[_address].INRpaid;\n', '\n', '            return INRdividends[_address].INRbalance;\n', '        }\n', '\n', '        else {\n', '            return balanceOf[_address] + INRdividends[_address].INRpaid;\n', '        }\n', '    }\n', '\n', '    function name() constant returns (string _name)\n', '    {\n', '        name = "iGniter";\n', '        return name;\n', '    }\n', '\n', '    function symbol() constant returns (bytes32 _symbol)\n', '    {\n', '        symbol = "INR";\n', '        return symbol;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 _decimals)\n', '    {\n', '        decimals = 6;\n', '        return decimals;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply)\n', '    {\n', '        if(t1active == true)\n', '        {\n', '          _tier1Avg = Tier1blocks/Tier1Amt;\n', '          _tier1AvgDiff = block.number - _tier1Avg;\n', '          _tier1Rewards = _tier1AvgDiff * T1DividendsPerBlockPerAddress * Tier1Amt;\n', '        }\n', '\n', '        if(t2active == true)\n', '        {\n', '          _tier2Avg = Tier2blocks/Tier2Amt;\n', '          _tier2AvgDiff = block.number - _tier2Avg;\n', '          _tier2Rewards = _tier2AvgDiff * T2DividendsPerBlockPerAddress * Tier2Amt;\n', '        }\n', '\n', '        if(t3active == true)\n', '        {\n', '          _tier3Avg = Tier3blocks/Tier3Amt;\n', '          _tier3AvgDiff = block.number - _tier3Avg;\n', '          _tier3Rewards = _tier3AvgDiff * T3DividendsPerBlockPerAddress * Tier3Amt;\n', '        }\n', '\n', '        if(t4active == true)\n', '        {\n', '          _tier4Avg = Tier4blocks/Tier4Amt;\n', '          _tier4AvgDiff = block.number - _tier4Avg;\n', '          _tier4Rewards = _tier4AvgDiff * T4DividendsPerBlockPerAddress * Tier4Amt;\n', '        }\n', '\n', '        if(t5active == true)\n', '        {\n', '          _tier5Avg = Tier5blocks/Tier5Amt;\n', '          _tier5AvgDiff = block.number - _tier5Avg;\n', '          _tier5Rewards = _tier5AvgDiff * T5DividendsPerBlockPerAddress * Tier5Amt;\n', '        }\n', '\n', '        _hodlAvg = hodlBlocks/hodlAmt;\n', '        _hodlAvgDiff = block.number - _hodlAvg;\n', '        _hodlRewards = _hodlAvgDiff * hodlersDividendsPerBlockPerAddress * hodlAmt;\n', '\n', '        blockAverage = blockStats/diviClaims;\n', '        blockAvgDiff = block.number - blockAverage;\n', '        divRewards = blockAvgDiff * dividendsPerBlockPerAddress * diviClaims;\n', '\n', '        totalRewards = _tier1Rewards + _tier2Rewards + _tier3Rewards + _tier4Rewards + _tier5Rewards\n', '                       + _hodlRewards + divRewards;\n', '\n', '        return initialSupply + iGniting + totalRewards - burnt;\n', '    }\n', '\n', '    function burn(uint256 _value) public returns(bool success) {\n', '\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        burnt += _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && !isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            Transfer(msg.sender, _to, _value, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isContract(address _addr) returns (bool) {\n', '        uint codeSize;\n', '        assembly {\n', '            codeSize := extcodesize(_addr)\n', '        }\n', '        return codeSize > 0;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_allowances[_from][msg.sender] > 0 && _value > 0 && _allowances[_from][msg.sender] >= _value &&\n', '            balanceOf[_from] >= _value) {\n', '            balanceOf[_from] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            _allowances[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        _allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return _allowances[_owner][_spender];\n', '    }\n', '\n', '    function PaymentStatusBlockNum(address _address) constant returns (uint256 blockno) {\n', '\n', '      return inrPayments[_address].unlockedBlockNumber;\n', '    }\n', '\n', '    function PaymentStatusTimeStamp(address _address) constant returns (uint256 ut) {\n', '\n', '      return inrPayments[_address].unlockedTime;\n', '    }\n', '\n', '    function updateCost(uint256 _currCost) isOwner public {\n', '\n', '      currentCost = _currCost;\n', '    }\n', '\n', '    function servicePayment(uint _value) public {\n', '\n', '      require(_value >= currentCost);\n', '      require(balanceOf[msg.sender] >= currentCost);\n', '\n', '      inrPayments[msg.sender].unlockedBlockNumber = block.number;\n', '      inrSessions++;\n', '\n', '      balanceOf[msg.sender] -= _value;\n', '      burnt += _value;\n', '      Burn(msg.sender, _value);\n', '    }\n', '\n', '    function withdrawal(uint quantity) isOwner returns(bool) {\n', '\n', '           require(quantity <= this.balance);\n', '\n', '           if(msg.sender == _Owner1)\n', '           {\n', '             _Owner1.transfer(quantity);\n', '           }\n', '\n', '           if(msg.sender == _Owner2)\n', '           {\n', '             _Owner2.transfer(quantity);\n', '           }\n', '\n', '           if(msg.sender == _Owner3)\n', '           {\n', '             _Owner3.transfer(quantity);\n', '           }\n', '\n', '           return true;\n', '   }\n', '\n', '    function dividendRegistration() public {\n', '\n', '      require (dividendAddress[msg.sender] == false);\n', '\n', '      INRdividends[msg.sender].diviReg = block.number;\n', '      dividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      blockStats += block.number;\n', '      diviClaims++;\n', '    }\n', '\n', '    function HODLRegistration() public {\n', '\n', '      require (HODLERAddress[msg.sender] == false);\n', '\n', '          INRdividends[msg.sender]._hodlReg = block.number;\n', '          HODLERAddress[msg.sender] = true;\n', '          qualifiedAddress[msg.sender] = true;\n', '          hodlBlocks += block.number;\n', '          hodlAmt++;\n', '    }\n', '\n', '    function Tier_Starter_Registration() public payable {\n', '\n', '      require(msg.value == 0.01 ether);\n', '\n', '      INRdividends[msg.sender]._tier1Reg = block.number;\n', '      TierStarterDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier1blocks += block.number;\n', '      Tier1Amt++;\n', '      t1active = true;\n', '    }\n', '\n', '    function Tier_Basic_Registration() public payable {\n', '\n', '      require(msg.value >= 0.1 ether);\n', '\n', '      INRdividends[msg.sender]._tier2Reg = block.number;\n', '      TierBasicDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier2blocks += block.number;\n', '      Tier2Amt++;\n', '      t2active = true;\n', '    }\n', '\n', '    function Tier_Classic_Registration() public payable {\n', '\n', '      require(msg.value >= 1 ether);\n', '\n', '      INRdividends[msg.sender]._tier3Reg = block.number;\n', '      TierClassicDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier3blocks += block.number;\n', '      Tier3Amt++;\n', '      t3active = true;\n', '    }\n', '\n', '    function Tier_Wildcat_Registration() public payable {\n', '\n', '      require(msg.value >= 10 ether);\n', '\n', '      INRdividends[msg.sender]._tier4Reg = block.number;\n', '      TierWildcatDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier4blocks += block.number;\n', '      Tier4Amt++;\n', '      t4active = true;\n', '    }\n', '\n', '    function Tier_Rainmaker_Registration() public payable {\n', '\n', '      require(msg.value >= 100 ether);\n', '\n', '      INRdividends[msg.sender]._tier5Reg = block.number;\n', '      TierRainmakerDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier5blocks += block.number;\n', '      Tier5Amt++;\n', '      t5active = true;\n', '    }\n', '\n', '    function claimINRDividends() public\n', '    {\n', '        INRdividends[msg.sender].INRpayout = dividendRewards(msg.sender);\n', '\n', '        if (INRdividends[msg.sender].INRpayout < INRdividends[msg.sender].INRtransfers)\n', '        {\n', '            INRdividends[msg.sender].INRpaid = 0;\n', '        }\n', '\n', '        if (INRdividends[msg.sender].INRpayout >= INRdividends[msg.sender].INRtransfers)\n', '        {\n', '            INRdividends[msg.sender].transDiff = INRdividends[msg.sender].INRpayout - INRdividends[msg.sender].INRtransfers;\n', '            INRdividends[msg.sender].INRpaid = INRdividends[msg.sender].transDiff;\n', '        }\n', '\n', '        balanceOf[msg.sender] += INRdividends[msg.sender].INRpaid;\n', '    }\n', '\n', '    function dividendRewards(address _address) constant returns (uint)\n', '    {\n', '        if(dividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address].diviBlocks = block.number - INRdividends[_address].diviReg;\n', '          INRdividends[_address].diviPayout = dividendsPerBlockPerAddress * INRdividends[_address].diviBlocks;\n', '        }\n', '\n', '        if(TierStarterDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier1Blocks = block.number - INRdividends[_address]._tier1Reg;\n', '          INRdividends[_address]._tier1Payout = T1DividendsPerBlockPerAddress * INRdividends[_address]._tier1Blocks;\n', '        }\n', '\n', '        if(TierBasicDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier2Blocks = block.number - INRdividends[_address]._tier2Reg;\n', '          INRdividends[_address]._tier2Payout = T2DividendsPerBlockPerAddress * INRdividends[_address]._tier2Blocks;\n', '        }\n', '\n', '        if(TierClassicDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier3Blocks = block.number - INRdividends[_address]._tier3Reg;\n', '          INRdividends[_address]._tier3Payout = T3DividendsPerBlockPerAddress * INRdividends[_address]._tier3Blocks;\n', '        }\n', '\n', '        if(TierWildcatDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier4Blocks = block.number - INRdividends[_address]._tier4Reg;\n', '          INRdividends[_address]._tier4Payout = T4DividendsPerBlockPerAddress * INRdividends[_address]._tier4Blocks;\n', '        }\n', '\n', '        if(TierRainmakerDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier5Blocks = block.number - INRdividends[_address]._tier5Reg;\n', '          INRdividends[_address]._tier5Payout = T5DividendsPerBlockPerAddress * INRdividends[_address]._tier5Blocks;\n', '        }\n', '\n', '        if ((balanceOf[_address]) >= 100000000000 && (HODLERAddress[_address] == true)) { //100000INR\n', '          INRdividends[_address]._hodlBlocks = block.number - INRdividends[_address]._hodlReg;\n', '          INRdividends[_address].hodlPayout = hodlersDividendsPerBlockPerAddress * INRdividends[_address]._hodlBlocks;\n', '        }\n', '\n', '        INRdividends[_address]._tierPayouts = INRdividends[_address]._tier1Payout + INRdividends[_address]._tier2Payout +\n', '                                              INRdividends[_address]._tier3Payout + INRdividends[_address]._tier4Payout +\n', '                                              INRdividends[_address]._tier5Payout + INRdividends[_address].hodlPayout +\n', '                                              INRdividends[_address].diviPayout;\n', '\n', '        if ((initialAddress[_address]) == true)\n', '        {\n', '            INRdividends[_address].individualRewards = availableAmount + INRdividends[_address]._tierPayouts;\n', '\n', '            return INRdividends[_address].individualRewards;\n', '        }\n', '\n', '        if ((qualifiedAddress[_address]) == true)\n', '        {\n', '            INRdividends[_address].individualRewards = INRdividends[_address]._tierPayouts;\n', '\n', '            return INRdividends[_address].individualRewards;\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '\n', '    function safeDiv(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        uint256 f = x / y;\n', '        return f;\n', '      }\n', '    }\n', '\n', 'contract ERC223ReceivingContract {\n', '\n', '    struct inr {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '      function tokenFallback(address _from, uint _value, bytes _data){\n', '      inr memory igniter;\n', '      igniter.sender = _from;\n', '      igniter.value = _value;\n', '      igniter.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      igniter.sig = bytes4(u);\n', '\n', '    }\n', '  }\n', '\n', 'contract iGniter is SafeMath {\n', '\n', '  struct serPayment {\n', '    uint256 unlockedBlockNumber;\n', '    uint256 unlockedTime;\n', '  }\n', '\n', '  struct dividends {\n', '    uint256 diviReg;\n', '    uint256 diviBlocks;\n', '    uint256 diviPayout;\n', '    uint256 diviBalance;\n', '    uint256 _tier1Reg;\n', '    uint256 _tier2Reg;\n', '    uint256 _tier3Reg;\n', '    uint256 _tier4Reg;\n', '    uint256 _tier5Reg;\n', '    uint256 _tier1Payout;\n', '    uint256 _tier2Payout;\n', '    uint256 _tier3Payout;\n', '    uint256 _tier4Payout;\n', '    uint256 _tier5Payout;\n', '    uint256 _tier1Blocks;\n', '    uint256 _tier2Blocks;\n', '    uint256 _tier3Blocks;\n', '    uint256 _tier4Blocks;\n', '    uint256 _tier5Blocks;\n', '    uint256 _tierPayouts;\n', '    uint256 hodlPayout;\n', '    uint256 _hodlReg;\n', '    uint256 _hodlBlocks;\n', '    uint256 INRpayout;\n', '    uint256 INR_lastbal;\n', '    uint256 INRpaid;\n', '    uint256 INRtransfers;\n', '    uint256 INRbalance;\n', '    uint256 transDiff;\n', '    uint256 individualRewards;\n', '  }\n', '\n', '    string public name;\n', '    bytes32 public symbol;\n', '    uint8 public decimals;\n', '    uint256 private dividendsPerBlockPerAddress;\n', '    uint256 private T1DividendsPerBlockPerAddress;\n', '    uint256 private T2DividendsPerBlockPerAddress;\n', '    uint256 private T3DividendsPerBlockPerAddress;\n', '    uint256 private T4DividendsPerBlockPerAddress;\n', '    uint256 private T5DividendsPerBlockPerAddress;\n', '    uint256 private hodlersDividendsPerBlockPerAddress;\n', '    uint256 private totalInitialAddresses;\n', '    uint256 private initialBlockCount;\n', '    uint256 private minedBlocks;\n', '    uint256 private iGniting;\n', '    uint256 private totalRewards;\n', '    uint256 private initialSupplyPerAddress;\n', '    uint256 private availableAmount;\n', '    uint256 private burnt;\n', '    uint256 private inrSessions;\n', '    uint256 private initialSupply;\n', '    uint256 public currentCost;\n', '    uint256 private blockStats;\n', '    uint256 private blockAverage;\n', '    uint256 private blockAvgDiff;\n', '    uint256 private divRewards;\n', '    uint256 private diviClaims;\n', '    uint256 private Tier1Amt;\n', '    uint256 private Tier2Amt;\n', '    uint256 private Tier3Amt;\n', '    uint256 private Tier4Amt;\n', '    uint256 private Tier5Amt;\n', '    uint256 private Tier1blocks;\n', '    uint256 private Tier2blocks;\n', '    uint256 private Tier3blocks;\n', '    uint256 private Tier4blocks;\n', '    uint256 private Tier5blocks;\n', '    uint256 private hodlBlocks;\n', '    uint256 private hodlersReward;\n', '    uint256 private hodlAmt;\n', '\n', '    uint256 private _tier1Avg;\n', '    uint256 private _tier1AvgDiff;\n', '    uint256 private _tier1Rewards;\n', '    uint256 private _tier2Avg;\n', '    uint256 private _tier2AvgDiff;\n', '    uint256 private _tier2Rewards;\n', '    uint256 private _tier3Avg;\n', '    uint256 private _tier3AvgDiff;\n', '    uint256 private _tier3Rewards;\n', '    uint256 private _tier4Avg;\n', '    uint256 private _tier4AvgDiff;\n', '    uint256 private _tier4Rewards;\n', '    uint256 private _tier5Avg;\n', '    uint256 private _tier5AvgDiff;\n', '    uint256 private _tier5Rewards;\n', '    uint256 private _hodlAvg;\n', '\n', '    uint256 private _hodlAvgDiff;\n', '    uint256 private _hodlRewards;\n', '\n', '    bool private t1active;\n', '    bool private t2active;\n', '    bool private t3active;\n', '    bool private t4active;\n', '    bool private t5active;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => bool) public initialAddress;\n', '    mapping(address => bool) public dividendAddress;\n', '    mapping(address => bool) public qualifiedAddress;\n', '    mapping(address => bool) public TierStarterDividendAddress;\n', '    mapping(address => bool) public TierBasicDividendAddress;\n', '    mapping(address => bool) public TierClassicDividendAddress;\n', '    mapping(address => bool) public TierWildcatDividendAddress;\n', '    mapping(address => bool) public TierRainmakerDividendAddress;\n', '    mapping(address => bool) public HODLERAddress;\n', '    mapping(address => mapping (address => uint)) internal _allowances;\n', '    mapping(address => serPayment) inrPayments;\n', '    mapping(address => dividends) INRdividends;\n', '\n', '    address private _Owner1;\n', '    address private _Owner2;\n', '    address private _Owner3;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    modifier isOwner() {\n', '\n', '      require(msg.sender == _Owner1 || msg.sender == _Owner2 || msg.sender == _Owner3);\n', '      _;\n', '    }\n', '\n', '    function iGniter() {\n', '\n', '        initialSupplyPerAddress = 10000000000; //10000 INR\n', '        initialBlockCount = 5150000;\n', '        dividendsPerBlockPerAddress = 7;\n', '        hodlersDividendsPerBlockPerAddress = 9000;\n', '        T1DividendsPerBlockPerAddress = 30;\n', '        T2DividendsPerBlockPerAddress = 360;\n', '        T3DividendsPerBlockPerAddress = 4200;\n', '        T4DividendsPerBlockPerAddress = 60000;\n', '        T5DividendsPerBlockPerAddress = 1200000;\n', '        totalInitialAddresses = 5000;\n', '        initialSupply = initialSupplyPerAddress * totalInitialAddresses;\n', '        minedBlocks = block.number - initialBlockCount;\n', '        availableAmount = dividendsPerBlockPerAddress * minedBlocks;\n', '        iGniting = availableAmount * totalInitialAddresses;\n', '        _Owner1 = 0x4804D96B17B03B2f5F65a4AaA4b5DB360e22909A;\n', '        _Owner2 = 0x16C890b06FE52e27ed514e7086378a355F1aB28a;\n', '        _Owner3 = 0xa4F78852c7F854b4585491a55FE1594913C2C05D;\n', '    }\n', '\n', '    function currentBlock() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number;\n', '    }\n', '\n', '    function blockDiff() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number - initialBlockCount;\n', '    }\n', '\n', '    function assignInitialAddresses(address[] _address) isOwner public returns (bool success)\n', '    {\n', '        if (block.number < 10000000)\n', '        {\n', '          for (uint i = 0; i < _address.length; i++)\n', '          {\n', '            balanceOf[_address[i]] = balanceOf[_address[i]] + initialSupplyPerAddress;\n', '            initialAddress[_address[i]] = true;\n', '          }\n', '\n', '          return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256 Balance)\n', '    {\n', '        if((qualifiedAddress[_address]) == true || (initialAddress[_address]) == true)\n', '        {\n', '            if (minedBlocks > 105120000) return balanceOf[_address]; //app. 2058\n', '\n', '            INRdividends[_address].INRpayout = dividendRewards(_address);\n', '\n', '            if (INRdividends[_address].INRpayout < INRdividends[_address].INRtransfers)\n', '            {\n', '                INRdividends[_address].INRpaid = 0;\n', '            }\n', '\n', '            if (INRdividends[_address].INRpayout >= INRdividends[_address].INRtransfers)\n', '            {\n', '                INRdividends[_address].transDiff = INRdividends[_address].INRpayout - INRdividends[_address].INRtransfers;\n', '                INRdividends[_address].INRpaid = INRdividends[_address].transDiff;\n', '            }\n', '\n', '            INRdividends[_address].INRbalance = balanceOf[_address] + INRdividends[_address].INRpaid;\n', '\n', '            return INRdividends[_address].INRbalance;\n', '        }\n', '\n', '        else {\n', '            return balanceOf[_address] + INRdividends[_address].INRpaid;\n', '        }\n', '    }\n', '\n', '    function name() constant returns (string _name)\n', '    {\n', '        name = "iGniter";\n', '        return name;\n', '    }\n', '\n', '    function symbol() constant returns (bytes32 _symbol)\n', '    {\n', '        symbol = "INR";\n', '        return symbol;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 _decimals)\n', '    {\n', '        decimals = 6;\n', '        return decimals;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply)\n', '    {\n', '        if(t1active == true)\n', '        {\n', '          _tier1Avg = Tier1blocks/Tier1Amt;\n', '          _tier1AvgDiff = block.number - _tier1Avg;\n', '          _tier1Rewards = _tier1AvgDiff * T1DividendsPerBlockPerAddress * Tier1Amt;\n', '        }\n', '\n', '        if(t2active == true)\n', '        {\n', '          _tier2Avg = Tier2blocks/Tier2Amt;\n', '          _tier2AvgDiff = block.number - _tier2Avg;\n', '          _tier2Rewards = _tier2AvgDiff * T2DividendsPerBlockPerAddress * Tier2Amt;\n', '        }\n', '\n', '        if(t3active == true)\n', '        {\n', '          _tier3Avg = Tier3blocks/Tier3Amt;\n', '          _tier3AvgDiff = block.number - _tier3Avg;\n', '          _tier3Rewards = _tier3AvgDiff * T3DividendsPerBlockPerAddress * Tier3Amt;\n', '        }\n', '\n', '        if(t4active == true)\n', '        {\n', '          _tier4Avg = Tier4blocks/Tier4Amt;\n', '          _tier4AvgDiff = block.number - _tier4Avg;\n', '          _tier4Rewards = _tier4AvgDiff * T4DividendsPerBlockPerAddress * Tier4Amt;\n', '        }\n', '\n', '        if(t5active == true)\n', '        {\n', '          _tier5Avg = Tier5blocks/Tier5Amt;\n', '          _tier5AvgDiff = block.number - _tier5Avg;\n', '          _tier5Rewards = _tier5AvgDiff * T5DividendsPerBlockPerAddress * Tier5Amt;\n', '        }\n', '\n', '        _hodlAvg = hodlBlocks/hodlAmt;\n', '        _hodlAvgDiff = block.number - _hodlAvg;\n', '        _hodlRewards = _hodlAvgDiff * hodlersDividendsPerBlockPerAddress * hodlAmt;\n', '\n', '        blockAverage = blockStats/diviClaims;\n', '        blockAvgDiff = block.number - blockAverage;\n', '        divRewards = blockAvgDiff * dividendsPerBlockPerAddress * diviClaims;\n', '\n', '        totalRewards = _tier1Rewards + _tier2Rewards + _tier3Rewards + _tier4Rewards + _tier5Rewards\n', '                       + _hodlRewards + divRewards;\n', '\n', '        return initialSupply + iGniting + totalRewards - burnt;\n', '    }\n', '\n', '    function burn(uint256 _value) public returns(bool success) {\n', '\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        burnt += _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && !isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            Transfer(msg.sender, _to, _value, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isContract(address _addr) returns (bool) {\n', '        uint codeSize;\n', '        assembly {\n', '            codeSize := extcodesize(_addr)\n', '        }\n', '        return codeSize > 0;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_allowances[_from][msg.sender] > 0 && _value > 0 && _allowances[_from][msg.sender] >= _value &&\n', '            balanceOf[_from] >= _value) {\n', '            balanceOf[_from] -= _value;\n', '            balanceOf[_to] += _value;\n', '            INRdividends[msg.sender].INRtransfers += _value;\n', '            _allowances[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        _allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return _allowances[_owner][_spender];\n', '    }\n', '\n', '    function PaymentStatusBlockNum(address _address) constant returns (uint256 blockno) {\n', '\n', '      return inrPayments[_address].unlockedBlockNumber;\n', '    }\n', '\n', '    function PaymentStatusTimeStamp(address _address) constant returns (uint256 ut) {\n', '\n', '      return inrPayments[_address].unlockedTime;\n', '    }\n', '\n', '    function updateCost(uint256 _currCost) isOwner public {\n', '\n', '      currentCost = _currCost;\n', '    }\n', '\n', '    function servicePayment(uint _value) public {\n', '\n', '      require(_value >= currentCost);\n', '      require(balanceOf[msg.sender] >= currentCost);\n', '\n', '      inrPayments[msg.sender].unlockedBlockNumber = block.number;\n', '      inrSessions++;\n', '\n', '      balanceOf[msg.sender] -= _value;\n', '      burnt += _value;\n', '      Burn(msg.sender, _value);\n', '    }\n', '\n', '    function withdrawal(uint quantity) isOwner returns(bool) {\n', '\n', '           require(quantity <= this.balance);\n', '\n', '           if(msg.sender == _Owner1)\n', '           {\n', '             _Owner1.transfer(quantity);\n', '           }\n', '\n', '           if(msg.sender == _Owner2)\n', '           {\n', '             _Owner2.transfer(quantity);\n', '           }\n', '\n', '           if(msg.sender == _Owner3)\n', '           {\n', '             _Owner3.transfer(quantity);\n', '           }\n', '\n', '           return true;\n', '   }\n', '\n', '    function dividendRegistration() public {\n', '\n', '      require (dividendAddress[msg.sender] == false);\n', '\n', '      INRdividends[msg.sender].diviReg = block.number;\n', '      dividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      blockStats += block.number;\n', '      diviClaims++;\n', '    }\n', '\n', '    function HODLRegistration() public {\n', '\n', '      require (HODLERAddress[msg.sender] == false);\n', '\n', '          INRdividends[msg.sender]._hodlReg = block.number;\n', '          HODLERAddress[msg.sender] = true;\n', '          qualifiedAddress[msg.sender] = true;\n', '          hodlBlocks += block.number;\n', '          hodlAmt++;\n', '    }\n', '\n', '    function Tier_Starter_Registration() public payable {\n', '\n', '      require(msg.value == 0.01 ether);\n', '\n', '      INRdividends[msg.sender]._tier1Reg = block.number;\n', '      TierStarterDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier1blocks += block.number;\n', '      Tier1Amt++;\n', '      t1active = true;\n', '    }\n', '\n', '    function Tier_Basic_Registration() public payable {\n', '\n', '      require(msg.value >= 0.1 ether);\n', '\n', '      INRdividends[msg.sender]._tier2Reg = block.number;\n', '      TierBasicDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier2blocks += block.number;\n', '      Tier2Amt++;\n', '      t2active = true;\n', '    }\n', '\n', '    function Tier_Classic_Registration() public payable {\n', '\n', '      require(msg.value >= 1 ether);\n', '\n', '      INRdividends[msg.sender]._tier3Reg = block.number;\n', '      TierClassicDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier3blocks += block.number;\n', '      Tier3Amt++;\n', '      t3active = true;\n', '    }\n', '\n', '    function Tier_Wildcat_Registration() public payable {\n', '\n', '      require(msg.value >= 10 ether);\n', '\n', '      INRdividends[msg.sender]._tier4Reg = block.number;\n', '      TierWildcatDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier4blocks += block.number;\n', '      Tier4Amt++;\n', '      t4active = true;\n', '    }\n', '\n', '    function Tier_Rainmaker_Registration() public payable {\n', '\n', '      require(msg.value >= 100 ether);\n', '\n', '      INRdividends[msg.sender]._tier5Reg = block.number;\n', '      TierRainmakerDividendAddress[msg.sender] = true;\n', '      qualifiedAddress[msg.sender] = true;\n', '      Tier5blocks += block.number;\n', '      Tier5Amt++;\n', '      t5active = true;\n', '    }\n', '\n', '    function claimINRDividends() public\n', '    {\n', '        INRdividends[msg.sender].INRpayout = dividendRewards(msg.sender);\n', '\n', '        if (INRdividends[msg.sender].INRpayout < INRdividends[msg.sender].INRtransfers)\n', '        {\n', '            INRdividends[msg.sender].INRpaid = 0;\n', '        }\n', '\n', '        if (INRdividends[msg.sender].INRpayout >= INRdividends[msg.sender].INRtransfers)\n', '        {\n', '            INRdividends[msg.sender].transDiff = INRdividends[msg.sender].INRpayout - INRdividends[msg.sender].INRtransfers;\n', '            INRdividends[msg.sender].INRpaid = INRdividends[msg.sender].transDiff;\n', '        }\n', '\n', '        balanceOf[msg.sender] += INRdividends[msg.sender].INRpaid;\n', '    }\n', '\n', '    function dividendRewards(address _address) constant returns (uint)\n', '    {\n', '        if(dividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address].diviBlocks = block.number - INRdividends[_address].diviReg;\n', '          INRdividends[_address].diviPayout = dividendsPerBlockPerAddress * INRdividends[_address].diviBlocks;\n', '        }\n', '\n', '        if(TierStarterDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier1Blocks = block.number - INRdividends[_address]._tier1Reg;\n', '          INRdividends[_address]._tier1Payout = T1DividendsPerBlockPerAddress * INRdividends[_address]._tier1Blocks;\n', '        }\n', '\n', '        if(TierBasicDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier2Blocks = block.number - INRdividends[_address]._tier2Reg;\n', '          INRdividends[_address]._tier2Payout = T2DividendsPerBlockPerAddress * INRdividends[_address]._tier2Blocks;\n', '        }\n', '\n', '        if(TierClassicDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier3Blocks = block.number - INRdividends[_address]._tier3Reg;\n', '          INRdividends[_address]._tier3Payout = T3DividendsPerBlockPerAddress * INRdividends[_address]._tier3Blocks;\n', '        }\n', '\n', '        if(TierWildcatDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier4Blocks = block.number - INRdividends[_address]._tier4Reg;\n', '          INRdividends[_address]._tier4Payout = T4DividendsPerBlockPerAddress * INRdividends[_address]._tier4Blocks;\n', '        }\n', '\n', '        if(TierRainmakerDividendAddress[_address] == true)\n', '        {\n', '          INRdividends[_address]._tier5Blocks = block.number - INRdividends[_address]._tier5Reg;\n', '          INRdividends[_address]._tier5Payout = T5DividendsPerBlockPerAddress * INRdividends[_address]._tier5Blocks;\n', '        }\n', '\n', '        if ((balanceOf[_address]) >= 100000000000 && (HODLERAddress[_address] == true)) { //100000INR\n', '          INRdividends[_address]._hodlBlocks = block.number - INRdividends[_address]._hodlReg;\n', '          INRdividends[_address].hodlPayout = hodlersDividendsPerBlockPerAddress * INRdividends[_address]._hodlBlocks;\n', '        }\n', '\n', '        INRdividends[_address]._tierPayouts = INRdividends[_address]._tier1Payout + INRdividends[_address]._tier2Payout +\n', '                                              INRdividends[_address]._tier3Payout + INRdividends[_address]._tier4Payout +\n', '                                              INRdividends[_address]._tier5Payout + INRdividends[_address].hodlPayout +\n', '                                              INRdividends[_address].diviPayout;\n', '\n', '        if ((initialAddress[_address]) == true)\n', '        {\n', '            INRdividends[_address].individualRewards = availableAmount + INRdividends[_address]._tierPayouts;\n', '\n', '            return INRdividends[_address].individualRewards;\n', '        }\n', '\n', '        if ((qualifiedAddress[_address]) == true)\n', '        {\n', '            INRdividends[_address].individualRewards = INRdividends[_address]._tierPayouts;\n', '\n', '            return INRdividends[_address].individualRewards;\n', '        }\n', '    }\n', '}']
