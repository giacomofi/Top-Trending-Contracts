['pragma solidity ^0.4.24;\n', '\n', 'contract VerityToken {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract MasterDataProviderLock {\n', '  address public owner;\n', '  address public tokenAddress;\n', '  bool public allFundsCanBeUnlocked = false;\n', '  uint public lastLockingTime;\n', '\n', '  // amount => lockedUntil\n', '  mapping(uint => uint) public validLockingAmountToPeriod;\n', '  mapping(address => mapping(string => uint)) lockingData;\n', '\n', '  event Withdrawn(address indexed withdrawer, uint indexed withdrawnAmount);\n', '  event FundsLocked(\n', '    address indexed user,\n', '    uint indexed lockedAmount,\n', '    uint indexed lockedUntil\n', '  );\n', '  event AllFundsCanBeUnlocked(\n', '    uint indexed triggeredTimestamp,\n', '    bool indexed canAllFundsBeUnlocked\n', '  );\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOnceLockingPeriodIsOver(address _user) {\n', '    require(\n', '      (now >= lockingData[_user]["lockedUntil"] || allFundsCanBeUnlocked)\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier checkValidLockingAmount(uint _funds) {\n', '    require(validLockingAmountToPeriod[_funds] != 0);\n', '    _;\n', '  }\n', '\n', '  modifier checkUsersTokenBalance(uint _fundsToTransfer) {\n', '    require(\n', '      _fundsToTransfer <= VerityToken(tokenAddress).balanceOf(msg.sender)\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyOncePerUser(address _user) {\n', '    require(\n', '      lockingData[_user]["amount"] == 0 &&\n', '        lockingData[_user]["lockedUntil"] == 0\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier checkValidLockingTime() {\n', '    require(now <= lastLockingTime);\n', '    _;\n', '  }\n', '\n', '  modifier lastLockingTimeIsInTheFuture(uint _lastLockingTime) {\n', '    require(now < _lastLockingTime);\n', '    _;\n', '  }\n', '\n', '  modifier checkLockIsNotTerminated() {\n', '    require(allFundsCanBeUnlocked == false);\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address _tokenAddress,\n', '    uint _lastLockingTime,\n', '    uint[3] _lockingAmounts,\n', '    uint[3] _lockingPeriods\n', '  )\n', '    public\n', '    lastLockingTimeIsInTheFuture(_lastLockingTime)\n', '  {\n', '    owner = msg.sender;\n', '    tokenAddress = _tokenAddress;\n', '    lastLockingTime = _lastLockingTime;\n', '\n', '    // expects "ether" format. Number is converted to wei:  num * 10**18\n', '    setValidLockingAmountToPeriod(_lockingAmounts, _lockingPeriods);\n', '  }\n', '\n', '  function lockFunds(uint _tokens)\n', '    public\n', '    checkValidLockingTime()\n', '    checkLockIsNotTerminated()\n', '    checkUsersTokenBalance(_tokens)\n', '    checkValidLockingAmount(_tokens)\n', '    onlyOncePerUser(msg.sender)\n', '  {\n', '    require(\n', '      VerityToken(tokenAddress).transferFrom(msg.sender, address(this), _tokens)\n', '    );\n', '\n', '    lockingData[msg.sender]["amount"] = _tokens;\n', '    lockingData[msg.sender]["lockedUntil"] = validLockingAmountToPeriod[_tokens];\n', '\n', '    emit FundsLocked(\n', '      msg.sender,\n', '      _tokens,\n', '      validLockingAmountToPeriod[_tokens]\n', '    );\n', '  }\n', '\n', '  function withdrawFunds()\n', '    public\n', '    onlyOnceLockingPeriodIsOver(msg.sender)\n', '  {\n', '    uint amountToBeTransferred = lockingData[msg.sender]["amount"];\n', '    lockingData[msg.sender]["amount"] = 0;\n', '    VerityToken(tokenAddress).transfer(msg.sender, amountToBeTransferred);\n', '\n', '    emit Withdrawn(\n', '      msg.sender,\n', '      amountToBeTransferred\n', '    );\n', '  }\n', '\n', '  function terminateTokenLock() public onlyOwner() {\n', '    allFundsCanBeUnlocked = true;\n', '\n', '    emit AllFundsCanBeUnlocked(\n', '      now,\n', '      allFundsCanBeUnlocked\n', '    );\n', '  }\n', '\n', '  function getUserData(address _user) public view returns (uint[2]) {\n', '    return [lockingData[_user]["amount"], lockingData[_user]["lockedUntil"]];\n', '  }\n', '\n', '  function setValidLockingAmountToPeriod(\n', '    uint[3] _lockingAmounts,\n', '    uint[3] _lockingPeriods\n', '  )\n', '  private\n', '  {\n', '    validLockingAmountToPeriod[_lockingAmounts[0] * 10 ** 18] = _lockingPeriods[0];\n', '    validLockingAmountToPeriod[_lockingAmounts[1] * 10 ** 18] = _lockingPeriods[1];\n', '    validLockingAmountToPeriod[_lockingAmounts[2] * 10 ** 18] = _lockingPeriods[2];\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract VerityToken {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract MasterDataProviderLock {\n', '  address public owner;\n', '  address public tokenAddress;\n', '  bool public allFundsCanBeUnlocked = false;\n', '  uint public lastLockingTime;\n', '\n', '  // amount => lockedUntil\n', '  mapping(uint => uint) public validLockingAmountToPeriod;\n', '  mapping(address => mapping(string => uint)) lockingData;\n', '\n', '  event Withdrawn(address indexed withdrawer, uint indexed withdrawnAmount);\n', '  event FundsLocked(\n', '    address indexed user,\n', '    uint indexed lockedAmount,\n', '    uint indexed lockedUntil\n', '  );\n', '  event AllFundsCanBeUnlocked(\n', '    uint indexed triggeredTimestamp,\n', '    bool indexed canAllFundsBeUnlocked\n', '  );\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOnceLockingPeriodIsOver(address _user) {\n', '    require(\n', '      (now >= lockingData[_user]["lockedUntil"] || allFundsCanBeUnlocked)\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier checkValidLockingAmount(uint _funds) {\n', '    require(validLockingAmountToPeriod[_funds] != 0);\n', '    _;\n', '  }\n', '\n', '  modifier checkUsersTokenBalance(uint _fundsToTransfer) {\n', '    require(\n', '      _fundsToTransfer <= VerityToken(tokenAddress).balanceOf(msg.sender)\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyOncePerUser(address _user) {\n', '    require(\n', '      lockingData[_user]["amount"] == 0 &&\n', '        lockingData[_user]["lockedUntil"] == 0\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier checkValidLockingTime() {\n', '    require(now <= lastLockingTime);\n', '    _;\n', '  }\n', '\n', '  modifier lastLockingTimeIsInTheFuture(uint _lastLockingTime) {\n', '    require(now < _lastLockingTime);\n', '    _;\n', '  }\n', '\n', '  modifier checkLockIsNotTerminated() {\n', '    require(allFundsCanBeUnlocked == false);\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address _tokenAddress,\n', '    uint _lastLockingTime,\n', '    uint[3] _lockingAmounts,\n', '    uint[3] _lockingPeriods\n', '  )\n', '    public\n', '    lastLockingTimeIsInTheFuture(_lastLockingTime)\n', '  {\n', '    owner = msg.sender;\n', '    tokenAddress = _tokenAddress;\n', '    lastLockingTime = _lastLockingTime;\n', '\n', '    // expects "ether" format. Number is converted to wei:  num * 10**18\n', '    setValidLockingAmountToPeriod(_lockingAmounts, _lockingPeriods);\n', '  }\n', '\n', '  function lockFunds(uint _tokens)\n', '    public\n', '    checkValidLockingTime()\n', '    checkLockIsNotTerminated()\n', '    checkUsersTokenBalance(_tokens)\n', '    checkValidLockingAmount(_tokens)\n', '    onlyOncePerUser(msg.sender)\n', '  {\n', '    require(\n', '      VerityToken(tokenAddress).transferFrom(msg.sender, address(this), _tokens)\n', '    );\n', '\n', '    lockingData[msg.sender]["amount"] = _tokens;\n', '    lockingData[msg.sender]["lockedUntil"] = validLockingAmountToPeriod[_tokens];\n', '\n', '    emit FundsLocked(\n', '      msg.sender,\n', '      _tokens,\n', '      validLockingAmountToPeriod[_tokens]\n', '    );\n', '  }\n', '\n', '  function withdrawFunds()\n', '    public\n', '    onlyOnceLockingPeriodIsOver(msg.sender)\n', '  {\n', '    uint amountToBeTransferred = lockingData[msg.sender]["amount"];\n', '    lockingData[msg.sender]["amount"] = 0;\n', '    VerityToken(tokenAddress).transfer(msg.sender, amountToBeTransferred);\n', '\n', '    emit Withdrawn(\n', '      msg.sender,\n', '      amountToBeTransferred\n', '    );\n', '  }\n', '\n', '  function terminateTokenLock() public onlyOwner() {\n', '    allFundsCanBeUnlocked = true;\n', '\n', '    emit AllFundsCanBeUnlocked(\n', '      now,\n', '      allFundsCanBeUnlocked\n', '    );\n', '  }\n', '\n', '  function getUserData(address _user) public view returns (uint[2]) {\n', '    return [lockingData[_user]["amount"], lockingData[_user]["lockedUntil"]];\n', '  }\n', '\n', '  function setValidLockingAmountToPeriod(\n', '    uint[3] _lockingAmounts,\n', '    uint[3] _lockingPeriods\n', '  )\n', '  private\n', '  {\n', '    validLockingAmountToPeriod[_lockingAmounts[0] * 10 ** 18] = _lockingPeriods[0];\n', '    validLockingAmountToPeriod[_lockingAmounts[1] * 10 ** 18] = _lockingPeriods[1];\n', '    validLockingAmountToPeriod[_lockingAmounts[2] * 10 ** 18] = _lockingPeriods[2];\n', '  }\n', '}']
