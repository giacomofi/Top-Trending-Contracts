['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' **/\n', 'contract Ownable {\n', '    //using library SafeMath\n', '    using SafeMath for uint;\n', '    \n', '    enum RequestType {\n', '        None,\n', '        Owner,\n', '        CoOwner1,\n', '        CoOwner2\n', '    }\n', '    \n', '    address public owner;\n', '    address coOwner1;\n', '    address coOwner2;\n', '    RequestType requestType;\n', '    address newOwnerRequest;\n', '    \n', '    mapping(address => bool) voterList;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '     **/\n', '    constructor() public {\n', '      owner = msg.sender;\n', '      coOwner1 = address(0x625789684cE563Fe1f8477E8B3c291855E3470dF);\n', '      coOwner2 = address(0xe80a08C003b0b601964b4c78Fb757506d2640055);\n', '    }\n', '    \n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     **/\n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '    modifier onlyCoOwner1() {\n', '        require(msg.sender == coOwner1);\n', '        _;\n', '    }\n', '    modifier onlyCoOwner2() {\n', '        require(msg.sender == coOwner2);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     **/\n', '    function transferOwnership(address newOwner) public {\n', '      require(msg.sender == owner || msg.sender == coOwner1 || msg.sender == coOwner2);\n', '      require(newOwner != address(0));\n', '      \n', '      if(msg.sender == owner) {\n', '          requestType = RequestType.Owner;\n', '      }\n', '      else if(msg.sender == coOwner1) {\n', '          requestType = RequestType.CoOwner1;\n', '      }\n', '      else if(msg.sender == coOwner2) {\n', '          requestType = RequestType.CoOwner2;\n', '      }\n', '      newOwnerRequest = newOwner;\n', '      voterList[msg.sender] = true;\n', '    }\n', '    \n', '    function voteChangeOwner(bool isAgree) public {\n', '        require(msg.sender == owner || msg.sender == coOwner1 || msg.sender == coOwner2);\n', '        require(requestType != RequestType.None);\n', '        voterList[msg.sender] = isAgree;\n', '        checkVote();\n', '    }\n', '    \n', '    function checkVote() private {\n', '        uint iYesCount = 0;\n', '        uint iNoCount = 0;\n', '        if(voterList[owner] == true) {\n', '            iYesCount = iYesCount.add(1);\n', '        }\n', '        else {\n', '            iNoCount = iNoCount.add(1);\n', '        }\n', '        if(voterList[coOwner1] == true) {\n', '            iYesCount = iYesCount.add(1);\n', '        }\n', '        else {\n', '            iNoCount = iNoCount.add(1);\n', '        }\n', '        if(voterList[coOwner2] == true) {\n', '            iYesCount = iYesCount.add(1);\n', '        }\n', '        else {\n', '            iNoCount = iNoCount.add(1);\n', '        }\n', '        \n', '        if(iYesCount >= 2) {\n', '            emit OwnershipTransferred(owner, newOwnerRequest);\n', '            if(requestType == RequestType.Owner) {\n', '                owner = newOwnerRequest;\n', '            }\n', '            else if(requestType == RequestType.CoOwner1) {\n', '                coOwner1 = newOwnerRequest;\n', '            }\n', '            else if(requestType == RequestType.CoOwner2) {\n', '                coOwner2 = newOwnerRequest;\n', '            }\n', '            \n', '            newOwnerRequest = address(0);\n', '            requestType = RequestType.None;\n', '        }\n', '        else if(iNoCount >= 2) {\n', '            newOwnerRequest = address(0);\n', '            requestType = RequestType.None;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Configurable\n', ' * @dev Configurable varriables of the contract\n', ' **/\n', 'contract Configurable {\n', '    uint256 constant cfgPercentDivider = 10000;\n', '    uint256 constant cfgPercentMaxReceive = 30000;\n', '    \n', '    uint256 public cfgMinDepositRequired = 2 * 10**17; //0.2 ETH\n', '    uint256 public cfgMaxDepositRequired = 100*10**18; //100 ETH\n', '    \n', '    uint256 public minReceiveCommission = 2 * 10**16; //0.02 ETH\n', '    uint256 public maxReceiveCommissionPercent = 15000; //150 %\n', '    \n', '    uint256 public supportWaitingTime;\n', '    uint256 public supportPercent;\n', '    uint256 public receiveWaitingTime;\n', '    uint256 public receivePercent;\n', '    \n', '    uint256 public systemFeePercent = 300;          //3%\n', '    address public systemFeeAddress;\n', '    \n', '    uint256 public commissionFeePercent = 300;      //3%\n', '    address public commissionFeeAddress;\n', '    \n', '    uint256 public tokenSupportPercent = 500;       //5%\n', '    address public tokenSupportAddress;\n', '    \n', '    uint256 public directCommissionPercent = 1000;\n', '}\n', '    \n', '/**\n', ' * @title EbcFund \n', ' * @dev Contract to create the game\n', ' **/\n', 'contract EbcFund is Ownable, Configurable {\n', '    \n', '    /**\n', '     * @dev enum\n', '     **/\n', '    enum Stages {\n', '        Preparing,\n', '        Started,\n', '        Paused\n', '    }\n', '    enum GameStatus {\n', '        none,\n', '        processing,\n', '        completed\n', '    }\n', '    \n', '    /**\n', '     * @dev Structs \n', '     **/\n', '    struct Player {\n', '        address parentAddress;\n', '        uint256 totalDeposited;\n', '        uint256 totalAmountInGame;\n', '        uint256 totalReceived;\n', '        uint256 totalCommissionReceived;\n', '        uint lastReceiveCommission;\n', '        bool isKyc;\n', '        uint256 directCommission;\n', '    }\n', '    \n', '    struct Game {\n', '        address playerAddress;\n', '        uint256 depositAmount;\n', '        uint256 receiveAmount;\n', '        GameStatus status;\n', '        //\n', '        uint nextRoundTime;\n', '        uint256 nextRoundAmount;\n', '    }\n', '    \n', '    /**\n', '     * @dev Variables\n', '     **/\n', '    Stages public currentStage;\n', '    address transporter;\n', '    \n', '    /**\n', '     * @dev Events\n', '     **/\n', '    event Logger(string _label, uint256 _note);\n', '    \n', '    /**\n', '     * @dev Mapping\n', '     **/\n', '    mapping(address => bool) public donateList;\n', '    mapping(address => Player) public playerList;\n', '    mapping(uint => Game) public gameList;\n', '    \n', '    /**\n', '     * @dev constructor\n', '     **/\n', '    constructor() public {\n', '        // set configs value\n', '        systemFeeAddress = owner;\n', '        commissionFeeAddress = address(0x4c0037cd34804aB3EB6f54d6596A22A68b05c8CF);\n', '        tokenSupportAddress = address(0xC739c85ffE468fA7a6f2B8A005FF0eacAb4D5f0e);\n', '        //\n', '        supportWaitingTime = 20*86400;//20 days\n', '        supportPercent = 70;//0.7%\n', '        receiveWaitingTime = 5*86400;//5 days\n', '        receivePercent = 10;//0.1%\n', '        // \n', '        currentStage = Stages.Preparing;\n', '        //\n', '        donateList[owner] = true;\n', '        donateList[commissionFeeAddress] = true;\n', '        donateList[tokenSupportAddress] = true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Modifiers\n', '     **/\n', '    modifier onlyPreparing() {\n', '        require (currentStage == Stages.Preparing);\n', '        _;\n', '    }\n', '    modifier onlyStarted() {\n', '        require (currentStage == Stages.Started);\n', '        _;\n', '    }\n', '    modifier onlyPaused() {\n', '        require (currentStage == Stages.Paused);\n', '        _;\n', '    }\n', '    \n', '/* payments */\n', '    /**\n', '     * @dev fallback function to send ether to smart contract\n', '     **/\n', '    function () public payable {\n', '        require(currentStage == Stages.Started);\n', '        require(cfgMinDepositRequired <= msg.value && msg.value <= cfgMaxDepositRequired);\n', '        \n', '        if(donateList[msg.sender] == false) {\n', '            if(transporter != address(0) && msg.sender == transporter) {\n', '                //validate msg.data\n', '                if(msg.data.length > 0) {\n', '                    //init new game\n', '                    processDeposit(bytesToAddress(msg.data));\n', '                }\n', '                else {\n', '                     emit Logger("Thank you for your contribution!.", msg.value);\n', '                }\n', '            }\n', '            else {\n', '                //init new game\n', '                processDeposit(msg.sender);\n', '            }\n', '        }\n', '        else {\n', '            emit Logger("Thank you for your contribution!", msg.value);\n', '        }\n', '    }\n', '    \n', '/* administrative functions */\n', '    /**\n', '     * @dev get transporter address\n', '     **/\n', '    function getTransporter() public view onlyOwner returns(address) {\n', '        return transporter;\n', '    }\n', '\n', '    /**\n', '     * @dev update "transporter"\n', '     **/\n', '    function updateTransporter(address _address) public onlyOwner{\n', '        require (_address != address(0));\n', '        transporter = _address;\n', '    }\n', '    \n', '    /**\n', '     * @dev update "donateList"\n', '     **/\n', '    function updateDonator(address _address, bool _isDonator) public onlyOwner{\n', '        donateList[_address] = _isDonator;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "systemFeeAddress"\n', '     **/\n', '    function updateSystemAddress(address _address) public onlyOwner{\n', '        require(_address != address(0) && _address != systemFeeAddress);\n', '        //\n', '        systemFeeAddress = _address;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "systemFeePercent"\n', '     **/\n', '    function updateSystemFeePercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent != systemFeePercent && _percent <= 500); //maximum is 5%\n', '        systemFeePercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "commissionFeeAddress"\n', '     **/\n', '    function updateCommissionAddress(address _address) public onlyOwner{\n', '        require(_address != address(0) && _address != commissionFeeAddress);\n', '        //\n', '        commissionFeeAddress = _address;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "commissionFeePercent"\n', '     **/\n', '    function updateCommissionFeePercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent != commissionFeePercent && _percent <= 500); //maximum is 5%\n', '        commissionFeePercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "tokenSupportAddress"\n', '     **/\n', '    function updateTokenSupportAddress(address _address) public onlyOwner{\n', '        require(_address != address(0) && _address != tokenSupportAddress);\n', '        //\n', '        tokenSupportAddress = _address;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "tokenSupportPercent"\n', '     **/\n', '    function updateTokenSupportPercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent != tokenSupportPercent && _percent <= 1000); //maximum is 10%\n', '        tokenSupportPercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "directCommissionPercent"\n', '     **/\n', '    function updateDirectCommissionPercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent != directCommissionPercent && _percent <= 2000); //maximum is 20%\n', '        directCommissionPercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "cfgMinDepositRequired"\n', '     **/\n', '    function updateMinDeposit(uint256 _amount) public onlyOwner{\n', '        require(0 < _amount && _amount < cfgMaxDepositRequired);\n', '        require(_amount != cfgMinDepositRequired);\n', '        //\n', '        cfgMinDepositRequired = _amount;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "cfgMaxDepositRequired"\n', '     **/\n', '    function updateMaxDeposit(uint256 _amount) public onlyOwner{\n', '        require(cfgMinDepositRequired < _amount && _amount != cfgMaxDepositRequired);\n', '        //\n', '        cfgMaxDepositRequired = _amount;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "minReceiveCommission"\n', '     **/\n', '    function updateMinReceiveCommission(uint256 _amount) public onlyOwner{\n', '        require(0 < _amount && _amount != minReceiveCommission);\n', '        minReceiveCommission = _amount;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "maxReceiveCommissionPercent"\n', '     **/\n', '    function updateMaxReceiveCommissionPercent(uint256 _percent) public onlyOwner{\n', '        require(5000 <= _percent && _percent <= 20000); //require from 50% to 200%\n', '        //\n', '        maxReceiveCommissionPercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "supportWaitingTime"\n', '     **/\n', '    function updateSupportWaitingTime(uint256 _time) public onlyOwner{\n', '        require(86400 <= _time);\n', '        require(_time != supportWaitingTime);\n', '        //\n', '        supportWaitingTime = _time;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "supportPercent"\n', '     **/\n', '    function updateSupportPercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent < 1000);\n', '        require(_percent != supportPercent);\n', '        //\n', '        supportPercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "receiveWaitingTime"\n', '     **/\n', '    function updateReceiveWaitingTime(uint256 _time) public onlyOwner{\n', '        require(86400 <= _time);\n', '        require(_time != receiveWaitingTime);\n', '        //\n', '        receiveWaitingTime = _time;\n', '    }\n', '    \n', '    /**\n', '     * @dev update config "receivePercent"\n', '     **/\n', '    function updateRecivePercent(uint256 _percent) public onlyOwner{\n', '        require(0 < _percent && _percent < 1000);\n', '        require(_percent != receivePercent);\n', '        //\n', '        receivePercent = _percent;\n', '    }\n', '    \n', '    /**\n', '     * @dev update parent address\n', '     **/\n', '    function updatePlayerParent(address[] _address, address[] _parentAddress) public onlyOwner{\n', '        \n', '        for(uint i = 0; i < _address.length; i++) {\n', '            require(_address[i] != address(0));\n', '            require(_parentAddress[i] != address(0));\n', '            require(_address[i] != _parentAddress[i]);\n', '            \n', '            Player storage currentPlayer = playerList[_address[i]];\n', '            //\n', '            currentPlayer.parentAddress = _parentAddress[i];\n', '            if(0 < currentPlayer.directCommission && currentPlayer.directCommission < address(this).balance) {\n', '                uint256 comAmount = currentPlayer.directCommission;\n', '                currentPlayer.directCommission = 0;\n', '                //Logger\n', '                emit Logger("Send direct commission", comAmount);\n', '                //send direct commission\n', '                _parentAddress[i].transfer(comAmount);\n', '            }\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev update kyc\n', '     **/\n', '    function updatePlayerKyc(address[] _address, bool[] _isKyc) public onlyOwner{\n', '        \n', '        for(uint i = 0; i < _address.length; i++) {\n', '            require(_address[i] != address(0));\n', '            //\n', '            playerList[_address[i]].isKyc = _isKyc[i];\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev start game\n', '     **/\n', '    function startGame() public onlyOwner {\n', '        require(currentStage == Stages.Preparing || currentStage == Stages.Paused);\n', '        currentStage = Stages.Started;\n', '    }\n', '    \n', '    /**\n', '     * @dev pause game\n', '     **/\n', '    function pauseGame() public onlyOwner onlyStarted {\n', '        currentStage = Stages.Paused;\n', '    }\n', '    \n', '    /**\n', '     * @dev insert multi games\n', '     **/\n', '    function importPlayers(\n', '        address[] _playerAddress, \n', '        address[] _parentAddress,\n', '        uint256[] _totalDeposited,\n', '        uint256[] _totalReceived,\n', '        uint256[] _totalCommissionReceived,\n', '        bool[] _isKyc) public onlyOwner onlyPreparing {\n', '            \n', '            for(uint i = 0; i < _playerAddress.length; i++) {\n', '                processImportPlayer(\n', '                    _playerAddress[i], \n', '                    _parentAddress[i],\n', '                    _totalDeposited[i],\n', '                    _totalReceived[i],\n', '                    _totalCommissionReceived[i],\n', '                    _isKyc[i]);\n', '            }\n', '            \n', '        }\n', '    \n', '    function importGames(\n', '        address[] _playerAddress,\n', '        uint[] _gameHash,\n', '        uint256[] _gameAmount,\n', '        uint256[] _gameReceived) public onlyOwner onlyPreparing {\n', '            \n', '            for(uint i = 0; i < _playerAddress.length; i++) {\n', '                processImportGame(\n', '                    _playerAddress[i], \n', '                    _gameHash[i],\n', '                    _gameAmount[i],\n', '                    _gameReceived[i]);\n', '            }\n', '            \n', '        }\n', '    \n', '    /**\n', '     * @dev confirm game information\n', '     **/  \n', '    function confirmGames(address[] _playerAddress, uint[] _gameHash, uint256[] _gameAmount) public onlyCoOwner1 onlyStarted {\n', '        \n', '        for(uint i = 0; i < _playerAddress.length; i++) {\n', '            confirmGame(_playerAddress[i], _gameHash[i], _gameAmount[i]);\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev confirm game information\n', '     **/  \n', '    function confirmGame(address _playerAddress, uint _gameHash, uint256 _gameAmount) public onlyCoOwner1 onlyStarted {\n', '        //validate _gameHash\n', '        require(100000000000 <= _gameHash && _gameHash <= 999999999999);\n', '        //validate player information\n', '        Player storage currentPlayer = playerList[_playerAddress];\n', '        require(cfgMinDepositRequired <= playerList[_playerAddress].totalDeposited);\n', '        assert(currentPlayer.totalDeposited <= currentPlayer.totalAmountInGame.add(_gameAmount));\n', '        //update player information\n', '        currentPlayer.totalAmountInGame = currentPlayer.totalAmountInGame.add(_gameAmount);\n', '        //init game\n', '        initGame(_playerAddress, _gameHash, _gameAmount, 0);\n', '        //Logger\n', '        emit Logger("Game started", _gameAmount);\n', '    }\n', '    \n', '    /**\n', '     * @dev process send direct commission missing\n', '     **/\n', '    function sendMissionDirectCommission(address _address) public onlyCoOwner2 onlyStarted {\n', '        \n', '        require(donateList[_address] == false);\n', '        require(playerList[_address].parentAddress != address(0));\n', '        require(playerList[_address].directCommission > 0);\n', '        \n', '        Player memory currentPlayer = playerList[_address];\n', '        if(0 < currentPlayer.directCommission && currentPlayer.directCommission < address(this).balance) {\n', '            uint256 comAmount = currentPlayer.directCommission;\n', '            playerList[_address].directCommission = 0;\n', '            //Logger\n', '            emit Logger("Send direct commission", comAmount);\n', '            //send direct commission\n', '            currentPlayer.parentAddress.transfer(comAmount);\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev process send commission\n', '     **/\n', '    function sendCommission(address _address, uint256 _amountCom) public onlyCoOwner2 onlyStarted {\n', '        \n', '        require(donateList[_address] == false);\n', '        require(minReceiveCommission <= _amountCom && _amountCom < address(this).balance);\n', '        require(playerList[_address].isKyc == true);\n', '        require(playerList[_address].lastReceiveCommission.add(86400) < now);\n', '        \n', '        //current player\n', '        Player storage currentPlayer = playerList[_address];\n', '        //\n', '        uint256 maxCommissionAmount = getMaximumCommissionAmount(\n', '            currentPlayer.totalAmountInGame, \n', '            currentPlayer.totalReceived, \n', '            currentPlayer.totalCommissionReceived, \n', '            _amountCom);\n', '        if(maxCommissionAmount > 0) {\n', '            //update total receive\n', '            currentPlayer.totalReceived = currentPlayer.totalReceived.add(maxCommissionAmount);\n', '            currentPlayer.totalCommissionReceived = currentPlayer.totalCommissionReceived.add(maxCommissionAmount);\n', '            currentPlayer.lastReceiveCommission = now;\n', '            //fee commission\n', '            uint256 comFee = maxCommissionAmount.mul(commissionFeePercent).div(cfgPercentDivider);\n', '            //Logger\n', '            emit Logger("Send commission successfully", _amountCom);\n', '            \n', '            if(comFee > 0) {\n', '                maxCommissionAmount = maxCommissionAmount.sub(comFee);\n', '                //send commission to store address\n', '                commissionFeeAddress.transfer(comFee);\n', '            }\n', '            if(maxCommissionAmount > 0) {\n', '                //send eth\n', '                _address.transfer(maxCommissionAmount);\n', '            }\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev process send profit in game\n', '     **/\n', '    function sendProfits(\n', '        uint[] _gameHash,\n', '        uint256[] _profitAmount) public onlyCoOwner2 onlyStarted {\n', '            \n', '            for(uint i = 0; i < _gameHash.length; i++) {\n', '                sendProfit(_gameHash[i], _profitAmount[i]);\n', '            }\n', '            \n', '        }\n', '    \n', '    /**\n', '     * @dev process send profit in game\n', '     **/\n', '    function sendProfit(\n', '        uint _gameHash,\n', '        uint256 _profitAmount) public onlyCoOwner2 onlyStarted {\n', '            \n', '            //validate game information\n', '            Game memory game = gameList[_gameHash];\n', '            require(game.status == GameStatus.processing);\n', '            require(0 < _profitAmount && _profitAmount <= game.nextRoundAmount && _profitAmount < address(this).balance);\n', '            require(now <= game.nextRoundTime);\n', '            //validate player information\n', '            Player memory currentPlayer = playerList[gameList[_gameHash].playerAddress];\n', '            assert(currentPlayer.isKyc == true);\n', '            //do sendProfit\n', '            processSendProfit(_gameHash, _profitAmount);\n', '            \n', '        }\n', '    \n', '/* public functions */\n', '    \n', '/* private functions */\n', '    /**\n', '     * @dev process new game by deposit\n', '     **/\n', '    function processDeposit(address _address) private {\n', '        \n', '        //update player information\n', '        Player storage currentPlayer = playerList[_address];\n', '        currentPlayer.totalDeposited = currentPlayer.totalDeposited.add(msg.value);\n', '        \n', '        //Logger\n', '        emit Logger("Game deposited", msg.value);\n', '        \n', '        //send token support\n', '        uint256 tokenSupportAmount = tokenSupportPercent.mul(msg.value).div(cfgPercentDivider);\n', '        if(tokenSupportPercent > 0) {\n', '            tokenSupportAddress.transfer(tokenSupportAmount);\n', '        }\n', '        \n', '        //send parent address\n', '        uint256 directComAmount = directCommissionPercent.mul(msg.value).div(cfgPercentDivider);\n', '        if(currentPlayer.parentAddress != address(0)) {\n', '            currentPlayer.parentAddress.transfer(directComAmount);\n', '        }\n', '        else {\n', '            currentPlayer.directCommission = currentPlayer.directCommission.add(directComAmount);\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev convert bytes to address\n', '     **/\n', '    function bytesToAddress(bytes b) public pure returns (address) {\n', '\n', '        uint result = 0;\n', '        for (uint i = 0; i < b.length; i++) {\n', '            uint c = uint(b[i]);\n', '            if (c >= 48 && c <= 57) {\n', '                result = result * 16 + (c - 48);\n', '            }\n', '            if(c >= 65 && c<= 90) {\n', '                result = result * 16 + (c - 55);\n', '            }\n', '            if(c >= 97 && c<= 122) {\n', '                result = result * 16 + (c - 87);\n', '            }\n', '        }\n', '        return address(result);\n', '          \n', '    }\n', '    \n', '    /**\n', '     * @dev process import player information\n', '     **/ \n', '    function processImportPlayer(\n', '        address _playerAddress, \n', '        address _parentAddress, \n', '        uint256 _totalDeposited,\n', '        uint256 _totalReceived,\n', '        uint256 _totalCommissionReceived,\n', '        bool _isKyc) private {\n', '            \n', '            //update player information\n', '            Player storage currentPlayer = playerList[_playerAddress];\n', '            currentPlayer.parentAddress = _parentAddress;\n', '            currentPlayer.totalDeposited = _totalDeposited;\n', '            currentPlayer.totalReceived = _totalReceived;\n', '            currentPlayer.totalCommissionReceived = _totalCommissionReceived;\n', '            currentPlayer.isKyc = _isKyc;\n', '            \n', '            //Logger\n', '            emit Logger("Player imported", _totalDeposited);\n', '            \n', '        }\n', '     \n', '    /**\n', '     * @dev process import game information\n', '     **/ \n', '    function processImportGame(\n', '        address _playerAddress, \n', '        uint _gameHash,\n', '        uint256 _gameAmount,\n', '        uint256 _gameReceived) private {\n', '            \n', '            //update player information\n', '            Player storage currentPlayer = playerList[_playerAddress];\n', '            currentPlayer.totalAmountInGame = currentPlayer.totalAmountInGame.add(_gameAmount);\n', '            currentPlayer.totalReceived = currentPlayer.totalReceived.add(_gameReceived);\n', '            \n', '            //init game\n', '            initGame(_playerAddress, _gameHash, _gameAmount, _gameReceived);\n', '            \n', '            //Logger\n', '            emit Logger("Game imported", _gameAmount);\n', '            \n', '        }\n', '     \n', '    /**\n', '     * @dev init new game\n', '     **/ \n', '    function initGame(\n', '        address _playerAddress,\n', '        uint _gameHash,\n', '        uint256 _gameAmount,\n', '        uint256 _gameReceived) private {\n', '            \n', '            Game storage game = gameList[_gameHash];\n', '            game.playerAddress = _playerAddress;\n', '            game.depositAmount = _gameAmount;\n', '            game.receiveAmount = _gameReceived;\n', '            game.status = GameStatus.processing;\n', '            game.nextRoundTime = now.add(supportWaitingTime);\n', '            game.nextRoundAmount = getProfitNextRound(_gameAmount);\n', '            \n', '        }\n', '    \n', '    /**\n', '     * @dev process check & send profit\n', '     **/\n', '    function processSendProfit(\n', '        uint _gameHash,\n', '        uint256 _profitAmount) private {\n', '        \n', '            Game storage game = gameList[_gameHash];\n', '            Player storage currentPlayer = playerList[game.playerAddress];\n', '            \n', '            //total receive by game\n', '            uint256 maxGameReceive = game.depositAmount.mul(cfgPercentMaxReceive).div(cfgPercentDivider);\n', '            //total receive by player\n', '            uint256 maxPlayerReceive = currentPlayer.totalAmountInGame.mul(cfgPercentMaxReceive).div(cfgPercentDivider);\n', '            \n', '            if(maxGameReceive <= game.receiveAmount || maxPlayerReceive <= currentPlayer.totalReceived) {\n', '                emit Logger("ERR: Player cannot break game\'s rule [amount].", currentPlayer.totalReceived);\n', '                game.status = GameStatus.completed;\n', '            }\n', '            else {\n', '                if(maxGameReceive < game.receiveAmount.add(_profitAmount)) {\n', '                    _profitAmount = maxGameReceive.sub(game.receiveAmount);\n', '                }\n', '                if(maxPlayerReceive < currentPlayer.totalReceived.add(_profitAmount)) {\n', '                    _profitAmount = maxPlayerReceive.sub(currentPlayer.totalReceived);\n', '                }\n', '                \n', '                //update game totalReceived\n', '                game.receiveAmount = game.receiveAmount.add(_profitAmount);\n', '                game.nextRoundTime = now.add(supportWaitingTime);\n', '                game.nextRoundAmount = getProfitNextRound(game.depositAmount);\n', '                \n', '                //Logger\n', '                emit Logger("Info: send profit", _profitAmount);\n', '                \n', '                //update player total received \n', '                currentPlayer.totalReceived = currentPlayer.totalReceived.add(_profitAmount);\n', '                \n', '                //send systemFeeAddress\n', '                uint256 feeAmount = systemFeePercent.mul(_profitAmount).div(cfgPercentDivider);\n', '                if(feeAmount > 0) {\n', '                    _profitAmount = _profitAmount.sub(feeAmount);\n', '                    //send fee\n', '                    systemFeeAddress.transfer(feeAmount);\n', '                }\n', '                \n', '                //send profit\n', '                game.playerAddress.transfer(_profitAmount);\n', '            }\n', '            \n', '        }\n', '    \n', '    /**\n', '     * @dev get profit next round\n', '     **/\n', '    function getProfitNextRound(uint256 _amount) private constant returns(uint256) {\n', '        \n', '        uint256 support = supportPercent.mul(supportWaitingTime);\n', '        uint256 receive = receivePercent.mul(receiveWaitingTime);\n', '        uint256 totalPercent = support.add(receive);\n', '        //\n', '        return _amount.mul(totalPercent).div(cfgPercentDivider).div(86400);\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev get maximum amount commission avariable\n', '     **/\n', '    function getMaximumCommissionAmount(\n', '        uint256 _totalDeposited,\n', '        uint256 _totalReceived,\n', '        uint256 _totalCommissionReceived,\n', '        uint256 _amountCom) private returns(uint256) {\n', '        \n', '        //maximum commission can receive\n', '        uint256 maxCommissionAmount = _totalDeposited.mul(maxReceiveCommissionPercent).div(cfgPercentDivider);\n', '        //check total receive commission\n', '        if(maxCommissionAmount <= _totalCommissionReceived) {\n', '            emit Logger("Not enough balance [total commission receive]", _totalCommissionReceived);\n', '            return 0;\n', '        }\n', '        else if(maxCommissionAmount < _totalCommissionReceived.add(_amountCom)) {\n', '            _amountCom = maxCommissionAmount.sub(_totalCommissionReceived);\n', '        }\n', '        //check player total maxout\n', '        uint256 maxProfitCanReceive = _totalDeposited.mul(cfgPercentMaxReceive).div(cfgPercentDivider);\n', '        if(maxProfitCanReceive <= _totalReceived) {\n', '            emit Logger("Not enough balance [total maxout receive]", _totalReceived);\n', '            return 0;\n', '        }\n', '        else if(maxProfitCanReceive < _totalReceived.add(_amountCom)) {\n', '            _amountCom = maxProfitCanReceive.sub(_totalReceived);\n', '        }\n', '        \n', '        return _amountCom;\n', '    }\n', '}']