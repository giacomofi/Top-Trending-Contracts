['pragma solidity 0.4.18;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/*\n', ' * @title MerkleProof\n', ' * @dev Merkle proof verification\n', ' * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\n', ' */\n', 'library MerkleProof {\n', '  /*\n', '   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n', '   * and each pair of pre-images is sorted.\n', '   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n', '   * @param _root Merkle root\n', '   * @param _leaf Leaf of Merkle tree\n', '   */\n', '  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\n', '    // Check if proof length is a multiple of 32\n', '    if (_proof.length % 32 != 0) return false;\n', '\n', '    bytes32 proofElement;\n', '    bytes32 computedHash = _leaf;\n', '\n', '    for (uint256 i = 32; i <= _proof.length; i += 32) {\n', '      assembly {\n', '        // Load the current element of the proof\n', '        proofElement := mload(add(_proof, i))\n', '      }\n', '\n', '      if (computedHash < proofElement) {\n', '        // Hash(current computed hash + current element of the proof)\n', '        computedHash = keccak256(computedHash, proofElement);\n', '      } else {\n', '        // Hash(current element of the proof + current computed hash)\n', '        computedHash = keccak256(proofElement, computedHash);\n', '      }\n', '    }\n', '\n', '    // Check if the computed hash (root) is equal to the provided root\n', '    return computedHash == _root;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MerkleMine\n', ' * @dev Token distribution based on providing Merkle proofs of inclusion in genesis state to generate allocation\n', ' */\n', 'contract MerkleMine {\n', '    using SafeMath for uint256;\n', '\n', '    // ERC20 token being distributed\n', '    ERC20 public token;\n', '    // Merkle root representing genesis state which encodes token recipients\n', '    bytes32 public genesisRoot;\n', '    // Total amount of tokens that can be generated\n', '    uint256 public totalGenesisTokens;\n', '    // Total number of recipients included in genesis state\n', '    uint256 public totalGenesisRecipients;\n', '    // Amount of tokens per recipient allocation. Equal to `totalGenesisTokens` / `totalGenesisRecipients`\n', '    uint256 public tokensPerAllocation;\n', '    // Minimum ETH balance threshold for recipients included in genesis state\n', '    uint256 public balanceThreshold;\n', '    // Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '    uint256 public genesisBlock;\n', '    // Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', '    // As the current block gets closer to `callerAllocationEndBlock`, the caller receives a larger precentage of the allocation\n', '    uint256 public callerAllocationStartBlock;\n', '    // From this block onwards, a third party caller (not the recipient) can generate and claim the recipient&#39;s full allocation\n', '    uint256 public callerAllocationEndBlock;\n', '    // Number of blocks in the caller allocation period as defined by `callerAllocationEndBlock` - `callerAllocationStartBlock`\n', '    uint256 public callerAllocationPeriod;\n', '\n', '    // Track if the generation process is started\n', '    bool public started;\n', '\n', '    // Track the already generated allocations for recipients\n', '    mapping (address => bool) public generated;\n', '\n', '    // Check that a recipient&#39;s allocation has not been generated\n', '    modifier notGenerated(address _recipient) {\n', '        require(!generated[_recipient]);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is started\n', '    modifier isStarted() {\n', '        require(started);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is not started\n', '    modifier isNotStarted() {\n', '        require(!started);\n', '        _;\n', '    }\n', '\n', '    event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\n', '\n', '    /**\n', '     * @dev MerkleMine constructor\n', '     * @param _token ERC20 token being distributed\n', '     * @param _genesisRoot Merkle root representing genesis state which encodes token recipients\n', '     * @param _totalGenesisTokens Total amount of tokens that can be generated\n', '     * @param _totalGenesisRecipients Total number of recipients included in genesis state\n', '     * @param _balanceThreshold Minimum ETH balance threshold for recipients included in genesis state\n', '     * @param _genesisBlock Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '     * @param _callerAllocationStartBlock Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', '     * @param _callerAllocationEndBlock From this block onwards, a third party caller (not the recipient) can generate and claim the recipient&#39;s full allocation\n', '     */\n', '    function MerkleMine(\n', '        address _token,\n', '        bytes32 _genesisRoot,\n', '        uint256 _totalGenesisTokens,\n', '        uint256 _totalGenesisRecipients,\n', '        uint256 _balanceThreshold,\n', '        uint256 _genesisBlock,\n', '        uint256 _callerAllocationStartBlock,\n', '        uint256 _callerAllocationEndBlock\n', '    )\n', '        public\n', '    {\n', '        // Address of token contract must not be null\n', '        require(_token != address(0));\n', '        // Number of recipients must be non-zero\n', '        require(_totalGenesisRecipients > 0);\n', '        // Genesis block must be at or before the current block\n', '        require(_genesisBlock <= block.number);\n', '        // Start block for caller allocation must be after current block\n', '        require(_callerAllocationStartBlock > block.number);\n', '        // End block for caller allocation must be after caller allocation start block\n', '        require(_callerAllocationEndBlock > _callerAllocationStartBlock);\n', '\n', '        token = ERC20(_token);\n', '        genesisRoot = _genesisRoot;\n', '        totalGenesisTokens = _totalGenesisTokens;\n', '        totalGenesisRecipients = _totalGenesisRecipients;\n', '        tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\n', '        balanceThreshold = _balanceThreshold;\n', '        genesisBlock = _genesisBlock;\n', '        callerAllocationStartBlock = _callerAllocationStartBlock;\n', '        callerAllocationEndBlock = _callerAllocationEndBlock;\n', '        callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\n', '    }\n', '\n', '    /**\n', '     * @dev Start the generation period - first checks that this contract&#39;s balance is equal to `totalGenesisTokens`\n', '     * The generation period must not already be started\n', '     */\n', '    function start() external isNotStarted {\n', '        // Check that this contract has a sufficient balance for the generation period\n', '        require(token.balanceOf(this) >= totalGenesisTokens);\n', '\n', '        started = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Generate a recipient&#39;s token allocation. Generation period must be started. Starting from `callerAllocationStartBlock`\n', '     * a third party caller (not the recipient) can invoke this function to generate the recipient&#39;s token\n', '     * allocation and claim a percentage of it. The percentage of the allocation claimed by the\n', '     * third party caller is determined by how many blocks have elapsed since `callerAllocationStartBlock`.\n', '     * After `callerAllocationEndBlock`, a third party caller can claim the full allocation\n', '     * @param _recipient Recipient of token allocation\n', '     * @param _merkleProof Proof of recipient&#39;s inclusion in genesis state Merkle root\n', '     */\n', '    function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\n', '        // Check the Merkle proof\n', '        bytes32 leaf = keccak256(_recipient);\n', '        // _merkleProof must prove inclusion of _recipient in the genesis state root\n', '        require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\n', '\n', '        generated[_recipient] = true;\n', '\n', '        address caller = msg.sender;\n', '\n', '        if (caller == _recipient) {\n', '            // If the caller is the recipient, transfer the full allocation to the caller/recipient\n', '            require(token.transfer(_recipient, tokensPerAllocation));\n', '\n', '            Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\n', '        } else {\n', '            // If the caller is not the recipient, the token allocation generation\n', '            // can only take place if we are in the caller allocation period\n', '            require(block.number >= callerAllocationStartBlock);\n', '\n', '            uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\n', '            uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\n', '\n', '            if (callerTokenAmount > 0) {\n', '                require(token.transfer(caller, callerTokenAmount));\n', '            }\n', '\n', '            if (recipientTokenAmount > 0) {\n', '                require(token.transfer(_recipient, recipientTokenAmount));\n', '            }\n', '\n', '            Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Return the amount of tokens claimable by a third party caller when generating a recipient&#39;s token allocation at a given block\n', '     * @param _blockNumber Block at which to compute the amount of tokens claimable by a third party caller\n', '     */\n', '    function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\n', '        if (_blockNumber < callerAllocationStartBlock) {\n', '            // If the block is before the start of the caller allocation period, the third party caller can claim nothing\n', '            return 0;\n', '        } else if (_blockNumber >= callerAllocationEndBlock) {\n', '            // If the block is at or after the end block of the caller allocation period, the third party caller can claim everything\n', '            return tokensPerAllocation;\n', '        } else {\n', '            // During the caller allocation period, the third party caller can claim an increasing percentage\n', '            // of the recipient&#39;s allocation based on a linear curve - as more blocks pass in the caller allocation\n', '            // period, the amount claimable by the third party caller increases linearly\n', '            uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\n', '            return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\n', '        }\n', '    }\n', '}']