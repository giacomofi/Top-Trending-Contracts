['pragma solidity 0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface ICaelumMiner {\n', '    function getMiningReward() external returns (uint) ;\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @dev Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract InterfaceContracts is Ownable {\n', '    InterfaceContracts public _internalMod;\n', '    \n', '    function setModifierContract (address _t) onlyOwner public {\n', '        _internalMod = InterfaceContracts(_t);\n', '    }\n', '\n', '    modifier onlyMiningContract() {\n', '      require(msg.sender == _internalMod._contract_miner(), "Wrong sender");\n', '          _;\n', '      }\n', '\n', '    modifier onlyTokenContract() {\n', '      require(msg.sender == _internalMod._contract_token(), "Wrong sender");\n', '      _;\n', '    }\n', '    \n', '    modifier onlyMasternodeContract() {\n', '      require(msg.sender == _internalMod._contract_masternode(), "Wrong sender");\n', '      _;\n', '    }\n', '    \n', '    modifier onlyVotingOrOwner() {\n', '      require(msg.sender == _internalMod._contract_voting() || msg.sender == owner, "Wrong sender");\n', '      _;\n', '    }\n', '    \n', '    modifier onlyVotingContract() {\n', '      require(msg.sender == _internalMod._contract_voting() || msg.sender == owner, "Wrong sender");\n', '      _;\n', '    }\n', '      \n', '    function _contract_voting () public view returns (address) {\n', '        return _internalMod._contract_voting();\n', '    }\n', '    \n', '    function _contract_masternode () public view returns (address) {\n', '        return _internalMod._contract_masternode();\n', '    }\n', '    \n', '    function _contract_token () public view returns (address) {\n', '        return _internalMod._contract_token();\n', '    }\n', '    \n', '    function _contract_miner () public view returns (address) {\n', '        return _internalMod._contract_miner();\n', '    }\n', '}\n', '\n', 'contract CaelumAbstractMasternode is Ownable {\n', '\n', '    struct MasterNode {\n', '        address accountOwner;\n', '        bool isActive;\n', '        bool isTeamMember;\n', '        uint storedIndex;\n', '        uint startingRound;\n', '        uint nodeCount;\n', '        uint[] indexcounter;\n', '\n', '    }\n', '\n', '    mapping(address => MasterNode) public userByAddress;\n', '    mapping(uint => MasterNode) public masternodeByIndex;\n', '\n', '    uint public userCounter = 0;\n', '    uint public masternodeIDcounter = 0;\n', '    uint public masternodeRound = 0;\n', '    uint public masternodeCandidate;\n', '\n', '    uint public MINING_PHASE_DURATION_BLOCKS = 4500;\n', '\n', '    uint public miningEpoch;\n', '    uint public rewardsProofOfWork;\n', '    uint public rewardsMasternode;\n', '\n', '    bool genesisAdded = false;\n', '\n', '    event NewMasternode(address candidateAddress, uint timeStamp);\n', '    event RemovedMasternode(address candidateAddress, uint timeStamp);\n', '\n', '\n', '    address [] public genesisList = [\n', '      0xdb93CE3cCA2444CE5DA5522a85758af79Af0092D,\n', '      0x375E97e59dE97BE46D332Ba17185620B81bdB7cc,\n', '      0x14dB686439Aad3C076B793335BC14D9039F32C54,\n', '      0x1Ba4b0280163889e7Ee4ab5269C442971F48d13e,\n', '      0xE4Ac657af0690E9437f36D3E96886DC880b24404,\n', '      0x08Fcf0027E1e91a12981fBc6371dE39A269C3a47,\n', '      0x3d664B7B0Eb158798f3E797e194FEe50dD748742,\n', '      0xB85aC167079020d93033a014efEaD75f14018522,\n', '      0xc6d00915CbcF9ABE9B27403F8d2338551f4ac43b,\n', '      0x5256fE3F8e50E0f7f701525e814A2767da2cca06,\n', '      0x2cf23c6610A70d58D61eFbdEfD6454960b200c2C\n', '    ];\n', '\n', '    function addGenesis() onlyOwner public {\n', '        require(!genesisAdded);\n', '\n', '        for (uint i=0; i<genesisList.length; i++) {\n', '          addMasternode(genesisList[i]);\n', '        }\n', '\n', '        genesisAdded = true; // Forever lock this.\n', '    }\n', '\n', '    function addOwner() onlyOwner public {\n', '        addMasternode(owner);\n', '        updateMasternodeAsTeamMember(owner);\n', '    }\n', '\n', '    function addMasternode(address _candidate) internal {\n', '        /**\n', '         * @dev userByAddress is used for general statistic data.\n', '         * All masternode interaction happens by masternodeByIndex!\n', '         */\n', '        userByAddress[_candidate].isActive = true;\n', '        userByAddress[_candidate].accountOwner = _candidate;\n', '        userByAddress[_candidate].storedIndex = masternodeIDcounter;\n', '        userByAddress[_candidate].startingRound = masternodeRound + 1;\n', '        userByAddress[_candidate].indexcounter.push(masternodeIDcounter);\n', '\n', '        masternodeByIndex[masternodeIDcounter].isActive = true;\n', '        masternodeByIndex[masternodeIDcounter].accountOwner = _candidate;\n', '        masternodeByIndex[masternodeIDcounter].storedIndex = masternodeIDcounter;\n', '        masternodeByIndex[masternodeIDcounter].startingRound = masternodeRound + 1;\n', '\n', '        masternodeIDcounter++;\n', '        userCounter++;\n', '    }\n', '\n', '    function updateMasternode(uint _index) internal returns(bool) {\n', '        masternodeByIndex[_index].startingRound++;\n', '        return true;\n', '    }\n', '\n', '    function updateMasternodeAsTeamMember(address _candidate) internal returns(bool) {\n', '        userByAddress[_candidate].isTeamMember = true;\n', '        return (true);\n', '    }\n', '\n', '    function deleteMasternode(uint _index) internal {\n', '        address getUserFrom = getUserFromID(_index);\n', '        userByAddress[getUserFrom].isActive = false;\n', '        masternodeByIndex[_index].isActive = false;\n', '        userCounter--;\n', '    }\n', '\n', '    function getLastActiveBy(address _candidate) public view returns(uint) {\n', '      uint lastFound;\n', '      for (uint i = 0; i < userByAddress[_candidate].indexcounter.length; i++) {\n', '          if (masternodeByIndex[userByAddress[_candidate].indexcounter[i]].isActive == true) {\n', '              lastFound = masternodeByIndex[userByAddress[_candidate].indexcounter[i]].storedIndex;\n', '          }\n', '      }\n', '      return lastFound;\n', '    }\n', '\n', '    function userHasActiveNodes(address _candidate) public view returns(bool) {\n', '\n', '        bool lastFound;\n', '\n', '        for (uint i = 0; i < userByAddress[_candidate].indexcounter.length; i++) {\n', '            if (masternodeByIndex[userByAddress[_candidate].indexcounter[i]].isActive == true) {\n', '                lastFound = true;\n', '            }\n', '        }\n', '        return lastFound;\n', '    }\n', '\n', '    function setMasternodeCandidate() internal returns(address) {\n', '\n', '        uint hardlimitCounter = 0;\n', '\n', '        while (getFollowingCandidate() == 0x0) {\n', '            // We must return a value not to break the contract. Require is a secondary killswitch now.\n', '            require(hardlimitCounter < 6, "Failsafe switched on");\n', '            // Choose if loop over revert/require to terminate the loop and return a 0 address.\n', '            if (hardlimitCounter == 5) return (0);\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '            hardlimitCounter++;\n', '        }\n', '\n', '        if (masternodeCandidate == masternodeIDcounter - 1) {\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeIDcounter; i++) {\n', '            if (masternodeByIndex[i].isActive) {\n', '                if (masternodeByIndex[i].startingRound == masternodeRound) {\n', '                    updateMasternode(i);\n', '                    masternodeCandidate = i;\n', '                    return (masternodeByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        masternodeRound = masternodeRound + 1;\n', '        return (0);\n', '\n', '    }\n', '\n', '    function getFollowingCandidate() public view returns(address _address) {\n', '        uint tmpRound = masternodeRound;\n', '        uint tmpCandidate = masternodeCandidate;\n', '\n', '        if (tmpCandidate == masternodeIDcounter - 1) {\n', '            tmpRound = tmpRound + 1;\n', '            tmpCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeIDcounter; i++) {\n', '            if (masternodeByIndex[i].isActive) {\n', '                if (masternodeByIndex[i].startingRound == tmpRound) {\n', '                    tmpCandidate = i;\n', '                    return (masternodeByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        tmpRound = tmpRound + 1;\n', '        return (0);\n', '    }\n', '\n', '    function calculateRewardStructures() internal {\n', '        //ToDo: Set\n', '        uint _global_reward_amount = getMiningReward();\n', '        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\n', '\n', '        if (getStageOfMining < 10) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 5;\n', '            rewardsMasternode = 0;\n', '            return;\n', '        }\n', '\n', '        if (getStageOfMining > 90) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 2;\n', '            rewardsMasternode = _global_reward_amount / 100 * 98;\n', '            return;\n', '        }\n', '\n', '        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\n', '        uint _powreward = (_global_reward_amount - _mnreward);\n', '\n', '        setBaseRewards(_powreward, _mnreward);\n', '    }\n', '\n', '    function setBaseRewards(uint _pow, uint _mn) internal {\n', '        rewardsMasternode = _mn;\n', '        rewardsProofOfWork = _pow;\n', '    }\n', '\n', '    function _arrangeMasternodeFlow() internal {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    function isMasternodeOwner(address _candidate) public view returns(bool) {\n', '        if (userByAddress[_candidate].indexcounter.length <= 0) return false;\n', '        if (userByAddress[_candidate].accountOwner == _candidate)\n', '            return true;\n', '    }\n', '\n', '    function belongsToUser(address _candidate) public view returns(uint[]) {\n', '        return userByAddress[_candidate].indexcounter;\n', '    }\n', '\n', '    function getLastPerUser(address _candidate) public view returns(uint) {\n', '        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\n', '    }\n', '\n', '    function getUserFromID(uint _index) public view returns(address) {\n', '        return masternodeByIndex[_index].accountOwner;\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return 50 * 1e8;\n', '    }\n', '\n', '    function masternodeInfo(uint _index) public view returns\n', '        (\n', '            address,\n', '            bool,\n', '            uint,\n', '            uint\n', '        ) {\n', '            return (\n', '                masternodeByIndex[_index].accountOwner,\n', '                masternodeByIndex[_index].isActive,\n', '                masternodeByIndex[_index].storedIndex,\n', '                masternodeByIndex[_index].startingRound\n', '            );\n', '        }\n', '\n', '    function contractProgress() public view returns\n', '        (\n', '            uint epoch,\n', '            uint candidate,\n', '            uint round,\n', '            uint miningepoch,\n', '            uint globalreward,\n', '            uint powreward,\n', '            uint masternodereward,\n', '            uint usercount\n', '        ) {\n', '            return (\n', '                0,\n', '                masternodeCandidate,\n', '                masternodeRound,\n', '                miningEpoch,\n', '                getMiningReward(),\n', '                rewardsProofOfWork,\n', '                rewardsMasternode,\n', '                userCounter\n', '            );\n', '        }\n', '\n', '}\n', '\n', 'contract CaelumMasternode is InterfaceContracts, CaelumAbstractMasternode {\n', '\n', '    bool minerSet = false;\n', '    bool tokenSet = false;\n', '    uint swapStartedBlock = now;\n', '\n', '    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\n', '\n', '\n', '    /**\n', '     * @dev Use this to externaly call the _arrangeMasternodeFlow function. ALWAYS set a modifier !\n', '     */\n', '\n', '    function _externalArrangeFlow() onlyMiningContract public {\n', '        _arrangeMasternodeFlow();\n', '    }\n', '\n', '    /**\n', '     * @dev Use this to externaly call the addMasternode function. ALWAYS set a modifier !\n', '     */\n', '    function _externalAddMasternode(address _received) onlyTokenContract public {\n', '        addMasternode(_received);\n', '    }\n', '\n', '    /**\n', '     * @dev Use this to externaly call the deleteMasternode function. ALWAYS set a modifier !\n', '     */\n', '    function _externalStopMasternode(address _received) onlyTokenContract public {\n', '        deleteMasternode(getLastActiveBy(_received));\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return ICaelumMiner(_contract_miner()).getMiningReward();\n', '    }\n', '\n', '    /**\n', '    * @dev Move the voting away from token. All votes will be made from the voting\n', '    */\n', '    function VoteModifierContract (address _contract) onlyVotingContract external {\n', '        //_internalMod = CaelumModifierAbstract(_contract);\n', '        setModifierContract(_contract);\n', '    }\n', '\n', '    function getDataFromContract() onlyOwner public returns(uint) {\n', '\n', '        CaelumMasternode prev = CaelumMasternode(cloneDataFrom);\n', '        (\n', '          uint epoch,\n', '          uint candidate,\n', '          uint round,\n', '          uint miningepoch,\n', '          uint globalreward,\n', '          uint powreward,\n', '          uint masternodereward,\n', '          uint usercounter\n', '        ) = prev.contractProgress();\n', '\n', '        masternodeRound = round;\n', '        miningEpoch = miningepoch;\n', '        rewardsProofOfWork = powreward;\n', '        rewardsMasternode = masternodereward;\n', '    }\n', '\n', '}']