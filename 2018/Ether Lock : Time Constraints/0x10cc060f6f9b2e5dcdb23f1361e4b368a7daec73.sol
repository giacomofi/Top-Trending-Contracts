['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract UnicornInit {\n', '    function init() external;\n', '}\n', '\n', 'contract UnicornManagement {\n', '    using SafeMath for uint;\n', '\n', '    address public ownerAddress;\n', '    address public managerAddress;\n', '    address public communityAddress;\n', '    address public walletAddress;\n', '    address public candyToken;\n', '    address public candyPowerToken;\n', '    address public dividendManagerAddress; //onlyCommunity\n', '    address public blackBoxAddress; //onlyOwner\n', '    address public unicornBreedingAddress; //onlyOwner\n', '    address public geneLabAddress; //onlyOwner\n', '    address public unicornTokenAddress; //onlyOwner\n', '\n', '    uint public createDividendPercent = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercent = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public subFreezingPrice = 1000000000000000000; //\n', '    uint64 public subFreezingTime = 1 hours;\n', '    uint public subTourFreezingPrice = 1000000000000000000; //\n', '    uint64 public subTourFreezingTime = 1 hours;\n', '    uint public createUnicornPrice = 50000000000000000;\n', '    uint public createUnicornPriceInCandy = 25000000000000000000; //25 tokens\n', '    uint public oraclizeFee = 3000000000000000; //0.003 ETH\n', '\n', '    bool public paused = true;\n', '    bool public locked = false;\n', '\n', '    mapping(address => bool) tournaments;//address\n', '\n', '    event GamePaused();\n', '    event GameResumed();\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event NewManagerAddress(address managerAddress);\n', '    event NewCommunityAddress(address communityAddress);\n', '    event NewDividendManagerAddress(address dividendManagerAddress);\n', '    event NewWalletAddress(address walletAddress);\n', '    event NewCreateUnicornPrice(uint price, uint priceCandy);\n', '    event NewOraclizeFee(uint fee);\n', '    event NewSubFreezingPrice(uint price);\n', '    event NewSubFreezingTime(uint time);\n', '    event NewSubTourFreezingPrice(uint price);\n', '    event NewSubTourFreezingTime(uint time);\n', '    event NewCreateUnicornPrice(uint price);\n', '    event NewCreateDividendPercent(uint percent);\n', '    event NewSellDividendPercent(uint percent);\n', '    event AddTournament(address tournamentAddress);\n', '    event DelTournament(address tournamentAddress);\n', '    event NewBlackBoxAddress(address blackBoxAddress);\n', '    event NewBreedingAddress(address breedingAddress);\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == managerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == communityAddress);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenUnlocked() {\n', '        require(!locked);\n', '        _;\n', '    }\n', '\n', '    function lock() external onlyOwner whenPaused whenUnlocked {\n', '        locked = true;\n', '    }\n', '\n', '    function UnicornManagement(address _candyToken) public {\n', '        ownerAddress = msg.sender;\n', '        managerAddress = msg.sender;\n', '        communityAddress = msg.sender;\n', '        walletAddress = msg.sender;\n', '        candyToken = _candyToken;\n', '        candyPowerToken = _candyToken;\n', '    }\n', '\n', '\n', '    struct InitItem {\n', '        uint listIndex;\n', '        bool exists;\n', '    }\n', '\n', '    mapping (address => InitItem) private initItems;\n', '    address[] private initList;\n', '\n', '    function registerInit(address _contract) external whenPaused {\n', '        require(msg.sender == ownerAddress || tx.origin == ownerAddress);\n', '\n', '        if (!initItems[_contract].exists) {\n', '            initItems[_contract] = InitItem({\n', '                listIndex: initList.length,\n', '                exists: true\n', '                });\n', '            initList.push(_contract);\n', '        }\n', '    }\n', '\n', '    function unregisterInit(address _contract) external onlyOwner whenPaused {\n', '        require(initItems[_contract].exists && initList.length > 0);\n', '        uint lastIdx = initList.length - 1;\n', '        initItems[initList[lastIdx]].listIndex = initItems[_contract].listIndex;\n', '        initList[initItems[_contract].listIndex] = initList[lastIdx];\n', '        initList.length--;\n', '        delete initItems[_contract];\n', '\n', '    }\n', '\n', '    function runInit() external onlyOwner whenPaused {\n', '        for(uint i = 0; i < initList.length; i++) {\n', '            UnicornInit(initList[i]).init();\n', '        }\n', '    }\n', '\n', '    function setCandyPowerToken(address _candyPowerToken) external onlyOwner whenPaused {\n', '        require(_candyPowerToken != address(0));\n', '        candyPowerToken = _candyPowerToken;\n', '    }\n', '\n', '    function setUnicornToken(address _unicornTokenAddress) external onlyOwner whenPaused whenUnlocked {\n', '        require(_unicornTokenAddress != address(0));\n', '        //        require(unicornTokenAddress == address(0));\n', '        unicornTokenAddress = _unicornTokenAddress;\n', '    }\n', '\n', '    function setBlackBox(address _blackBoxAddress) external onlyOwner whenPaused {\n', '        require(_blackBoxAddress != address(0));\n', '        blackBoxAddress = _blackBoxAddress;\n', '    }\n', '\n', '    function setGeneLab(address _geneLabAddress) external onlyOwner whenPaused {\n', '        require(_geneLabAddress != address(0));\n', '        geneLabAddress = _geneLabAddress;\n', '    }\n', '\n', '    function setUnicornBreeding(address _unicornBreedingAddress) external onlyOwner whenPaused whenUnlocked {\n', '        require(_unicornBreedingAddress != address(0));\n', '        //        require(unicornBreedingAddress == address(0));\n', '        unicornBreedingAddress = _unicornBreedingAddress;\n', '    }\n', '\n', '    function setManagerAddress(address _managerAddress) external onlyOwner {\n', '        require(_managerAddress != address(0));\n', '        managerAddress = _managerAddress;\n', '        emit NewManagerAddress(_managerAddress);\n', '    }\n', '\n', '    function setDividendManager(address _dividendManagerAddress) external onlyOwner {\n', '        require(_dividendManagerAddress != address(0));\n', '        dividendManagerAddress = _dividendManagerAddress;\n', '        emit NewDividendManagerAddress(_dividendManagerAddress);\n', '    }\n', '\n', '    function setWallet(address _walletAddress) external onlyOwner {\n', '        require(_walletAddress != address(0));\n', '        walletAddress = _walletAddress;\n', '        emit NewWalletAddress(_walletAddress);\n', '    }\n', '\n', '    function setTournament(address _tournamentAddress) external onlyOwner {\n', '        require(_tournamentAddress != address(0));\n', '        tournaments[_tournamentAddress] = true;\n', '        emit AddTournament(_tournamentAddress);\n', '    }\n', '\n', '    function delTournament(address _tournamentAddress) external onlyOwner {\n', '        require(tournaments[_tournamentAddress]);\n', '        tournaments[_tournamentAddress] = false;\n', '        emit DelTournament(_tournamentAddress);\n', '    }\n', '\n', '    function transferOwnership(address _ownerAddress) external onlyOwner {\n', '        require(_ownerAddress != address(0));\n', '        ownerAddress = _ownerAddress;\n', '        emit OwnershipTransferred(ownerAddress, _ownerAddress);\n', '    }\n', '\n', '\n', '    function setCreateDividendPercent(uint _percent) public onlyManager {\n', '        require(_percent < 2500);\n', '        //no more then 25%\n', '        createDividendPercent = _percent;\n', '        emit NewCreateDividendPercent(_percent);\n', '    }\n', '\n', '    function setSellDividendPercent(uint _percent) public onlyManager {\n', '        require(_percent < 2500);\n', '        //no more then 25%\n', '        sellDividendPercent = _percent;\n', '        emit NewSellDividendPercent(_percent);\n', '    }\n', '\n', '    //time in minutes\n', '    function setSubFreezingTime(uint64 _time) external onlyManager {\n', '        subFreezingTime = _time * 1 minutes;\n', '        emit NewSubFreezingTime(_time);\n', '    }\n', '\n', '    //price in CandyCoins\n', '    function setSubFreezingPrice(uint _price) external onlyManager {\n', '        subFreezingPrice = _price;\n', '        emit NewSubFreezingPrice(_price);\n', '    }\n', '\n', '\n', '    //time in minutes\n', '    function setSubTourFreezingTime(uint64 _time) external onlyManager {\n', '        subTourFreezingTime = _time * 1 minutes;\n', '        emit NewSubTourFreezingTime(_time);\n', '    }\n', '\n', '    //price in CandyCoins\n', '    function setSubTourFreezingPrice(uint _price) external onlyManager {\n', '        subTourFreezingPrice = _price;\n', '        emit NewSubTourFreezingPrice(_price);\n', '    }\n', '\n', '    //in weis\n', '    function setOraclizeFee(uint _fee) external onlyManager {\n', '        oraclizeFee = _fee;\n', '        emit NewOraclizeFee(_fee);\n', '    }\n', '\n', '    //price in weis\n', '    function setCreateUnicornPrice(uint _price, uint _candyPrice) external onlyManager {\n', '        createUnicornPrice = _price;\n', '        createUnicornPriceInCandy = _candyPrice;\n', '        emit NewCreateUnicornPrice(_price, _candyPrice);\n', '    }\n', '\n', '    function setCommunity(address _communityAddress) external onlyCommunity {\n', '        require(_communityAddress != address(0));\n', '        communityAddress = _communityAddress;\n', '        emit NewCommunityAddress(_communityAddress);\n', '    }\n', '\n', '\n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit GamePaused();\n', '    }\n', '\n', '    function unpause() external onlyOwner whenPaused {\n', '        paused = false;\n', '        emit GameResumed();\n', '    }\n', '\n', '\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool) {\n', '        return tournaments[_tournamentAddress];\n', '    }\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint) {\n', '        return createUnicornPrice.add(oraclizeFee);\n', '    }\n', '\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint) {\n', '        return createUnicornPriceInCandy;\n', '    }\n', '\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint) {\n', '        return _price.add(valueFromPercent(_price, createDividendPercent));//.add(oraclizeFee);\n', '    }\n', '\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint) {\n', '        return _price.add(valueFromPercent(_price, sellDividendPercent));//.add(oraclizeFee);\n', '    }\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract UnicornInit {\n', '    function init() external;\n', '}\n', '\n', 'contract UnicornManagement {\n', '    using SafeMath for uint;\n', '\n', '    address public ownerAddress;\n', '    address public managerAddress;\n', '    address public communityAddress;\n', '    address public walletAddress;\n', '    address public candyToken;\n', '    address public candyPowerToken;\n', '    address public dividendManagerAddress; //onlyCommunity\n', '    address public blackBoxAddress; //onlyOwner\n', '    address public unicornBreedingAddress; //onlyOwner\n', '    address public geneLabAddress; //onlyOwner\n', '    address public unicornTokenAddress; //onlyOwner\n', '\n', '    uint public createDividendPercent = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercent = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public subFreezingPrice = 1000000000000000000; //\n', '    uint64 public subFreezingTime = 1 hours;\n', '    uint public subTourFreezingPrice = 1000000000000000000; //\n', '    uint64 public subTourFreezingTime = 1 hours;\n', '    uint public createUnicornPrice = 50000000000000000;\n', '    uint public createUnicornPriceInCandy = 25000000000000000000; //25 tokens\n', '    uint public oraclizeFee = 3000000000000000; //0.003 ETH\n', '\n', '    bool public paused = true;\n', '    bool public locked = false;\n', '\n', '    mapping(address => bool) tournaments;//address\n', '\n', '    event GamePaused();\n', '    event GameResumed();\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event NewManagerAddress(address managerAddress);\n', '    event NewCommunityAddress(address communityAddress);\n', '    event NewDividendManagerAddress(address dividendManagerAddress);\n', '    event NewWalletAddress(address walletAddress);\n', '    event NewCreateUnicornPrice(uint price, uint priceCandy);\n', '    event NewOraclizeFee(uint fee);\n', '    event NewSubFreezingPrice(uint price);\n', '    event NewSubFreezingTime(uint time);\n', '    event NewSubTourFreezingPrice(uint price);\n', '    event NewSubTourFreezingTime(uint time);\n', '    event NewCreateUnicornPrice(uint price);\n', '    event NewCreateDividendPercent(uint percent);\n', '    event NewSellDividendPercent(uint percent);\n', '    event AddTournament(address tournamentAddress);\n', '    event DelTournament(address tournamentAddress);\n', '    event NewBlackBoxAddress(address blackBoxAddress);\n', '    event NewBreedingAddress(address breedingAddress);\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == managerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == communityAddress);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenUnlocked() {\n', '        require(!locked);\n', '        _;\n', '    }\n', '\n', '    function lock() external onlyOwner whenPaused whenUnlocked {\n', '        locked = true;\n', '    }\n', '\n', '    function UnicornManagement(address _candyToken) public {\n', '        ownerAddress = msg.sender;\n', '        managerAddress = msg.sender;\n', '        communityAddress = msg.sender;\n', '        walletAddress = msg.sender;\n', '        candyToken = _candyToken;\n', '        candyPowerToken = _candyToken;\n', '    }\n', '\n', '\n', '    struct InitItem {\n', '        uint listIndex;\n', '        bool exists;\n', '    }\n', '\n', '    mapping (address => InitItem) private initItems;\n', '    address[] private initList;\n', '\n', '    function registerInit(address _contract) external whenPaused {\n', '        require(msg.sender == ownerAddress || tx.origin == ownerAddress);\n', '\n', '        if (!initItems[_contract].exists) {\n', '            initItems[_contract] = InitItem({\n', '                listIndex: initList.length,\n', '                exists: true\n', '                });\n', '            initList.push(_contract);\n', '        }\n', '    }\n', '\n', '    function unregisterInit(address _contract) external onlyOwner whenPaused {\n', '        require(initItems[_contract].exists && initList.length > 0);\n', '        uint lastIdx = initList.length - 1;\n', '        initItems[initList[lastIdx]].listIndex = initItems[_contract].listIndex;\n', '        initList[initItems[_contract].listIndex] = initList[lastIdx];\n', '        initList.length--;\n', '        delete initItems[_contract];\n', '\n', '    }\n', '\n', '    function runInit() external onlyOwner whenPaused {\n', '        for(uint i = 0; i < initList.length; i++) {\n', '            UnicornInit(initList[i]).init();\n', '        }\n', '    }\n', '\n', '    function setCandyPowerToken(address _candyPowerToken) external onlyOwner whenPaused {\n', '        require(_candyPowerToken != address(0));\n', '        candyPowerToken = _candyPowerToken;\n', '    }\n', '\n', '    function setUnicornToken(address _unicornTokenAddress) external onlyOwner whenPaused whenUnlocked {\n', '        require(_unicornTokenAddress != address(0));\n', '        //        require(unicornTokenAddress == address(0));\n', '        unicornTokenAddress = _unicornTokenAddress;\n', '    }\n', '\n', '    function setBlackBox(address _blackBoxAddress) external onlyOwner whenPaused {\n', '        require(_blackBoxAddress != address(0));\n', '        blackBoxAddress = _blackBoxAddress;\n', '    }\n', '\n', '    function setGeneLab(address _geneLabAddress) external onlyOwner whenPaused {\n', '        require(_geneLabAddress != address(0));\n', '        geneLabAddress = _geneLabAddress;\n', '    }\n', '\n', '    function setUnicornBreeding(address _unicornBreedingAddress) external onlyOwner whenPaused whenUnlocked {\n', '        require(_unicornBreedingAddress != address(0));\n', '        //        require(unicornBreedingAddress == address(0));\n', '        unicornBreedingAddress = _unicornBreedingAddress;\n', '    }\n', '\n', '    function setManagerAddress(address _managerAddress) external onlyOwner {\n', '        require(_managerAddress != address(0));\n', '        managerAddress = _managerAddress;\n', '        emit NewManagerAddress(_managerAddress);\n', '    }\n', '\n', '    function setDividendManager(address _dividendManagerAddress) external onlyOwner {\n', '        require(_dividendManagerAddress != address(0));\n', '        dividendManagerAddress = _dividendManagerAddress;\n', '        emit NewDividendManagerAddress(_dividendManagerAddress);\n', '    }\n', '\n', '    function setWallet(address _walletAddress) external onlyOwner {\n', '        require(_walletAddress != address(0));\n', '        walletAddress = _walletAddress;\n', '        emit NewWalletAddress(_walletAddress);\n', '    }\n', '\n', '    function setTournament(address _tournamentAddress) external onlyOwner {\n', '        require(_tournamentAddress != address(0));\n', '        tournaments[_tournamentAddress] = true;\n', '        emit AddTournament(_tournamentAddress);\n', '    }\n', '\n', '    function delTournament(address _tournamentAddress) external onlyOwner {\n', '        require(tournaments[_tournamentAddress]);\n', '        tournaments[_tournamentAddress] = false;\n', '        emit DelTournament(_tournamentAddress);\n', '    }\n', '\n', '    function transferOwnership(address _ownerAddress) external onlyOwner {\n', '        require(_ownerAddress != address(0));\n', '        ownerAddress = _ownerAddress;\n', '        emit OwnershipTransferred(ownerAddress, _ownerAddress);\n', '    }\n', '\n', '\n', '    function setCreateDividendPercent(uint _percent) public onlyManager {\n', '        require(_percent < 2500);\n', '        //no more then 25%\n', '        createDividendPercent = _percent;\n', '        emit NewCreateDividendPercent(_percent);\n', '    }\n', '\n', '    function setSellDividendPercent(uint _percent) public onlyManager {\n', '        require(_percent < 2500);\n', '        //no more then 25%\n', '        sellDividendPercent = _percent;\n', '        emit NewSellDividendPercent(_percent);\n', '    }\n', '\n', '    //time in minutes\n', '    function setSubFreezingTime(uint64 _time) external onlyManager {\n', '        subFreezingTime = _time * 1 minutes;\n', '        emit NewSubFreezingTime(_time);\n', '    }\n', '\n', '    //price in CandyCoins\n', '    function setSubFreezingPrice(uint _price) external onlyManager {\n', '        subFreezingPrice = _price;\n', '        emit NewSubFreezingPrice(_price);\n', '    }\n', '\n', '\n', '    //time in minutes\n', '    function setSubTourFreezingTime(uint64 _time) external onlyManager {\n', '        subTourFreezingTime = _time * 1 minutes;\n', '        emit NewSubTourFreezingTime(_time);\n', '    }\n', '\n', '    //price in CandyCoins\n', '    function setSubTourFreezingPrice(uint _price) external onlyManager {\n', '        subTourFreezingPrice = _price;\n', '        emit NewSubTourFreezingPrice(_price);\n', '    }\n', '\n', '    //in weis\n', '    function setOraclizeFee(uint _fee) external onlyManager {\n', '        oraclizeFee = _fee;\n', '        emit NewOraclizeFee(_fee);\n', '    }\n', '\n', '    //price in weis\n', '    function setCreateUnicornPrice(uint _price, uint _candyPrice) external onlyManager {\n', '        createUnicornPrice = _price;\n', '        createUnicornPriceInCandy = _candyPrice;\n', '        emit NewCreateUnicornPrice(_price, _candyPrice);\n', '    }\n', '\n', '    function setCommunity(address _communityAddress) external onlyCommunity {\n', '        require(_communityAddress != address(0));\n', '        communityAddress = _communityAddress;\n', '        emit NewCommunityAddress(_communityAddress);\n', '    }\n', '\n', '\n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit GamePaused();\n', '    }\n', '\n', '    function unpause() external onlyOwner whenPaused {\n', '        paused = false;\n', '        emit GameResumed();\n', '    }\n', '\n', '\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool) {\n', '        return tournaments[_tournamentAddress];\n', '    }\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint) {\n', '        return createUnicornPrice.add(oraclizeFee);\n', '    }\n', '\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint) {\n', '        return createUnicornPriceInCandy;\n', '    }\n', '\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint) {\n', '        return _price.add(valueFromPercent(_price, createDividendPercent));//.add(oraclizeFee);\n', '    }\n', '\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint) {\n', '        return _price.add(valueFromPercent(_price, sellDividendPercent));//.add(oraclizeFee);\n', '    }\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '}']
