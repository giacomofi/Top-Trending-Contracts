['pragma solidity ^0.4.25;\n', '\n', 'interface HourglassInterface {\n', '    function() payable external;\n', '    function buy(address _investorAddress) payable external returns(uint256);\n', '    function reinvest() external;\n', '    function exit() payable external;\n', '    function withdraw() payable external;\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function totalEthereumBalance() external;\n', '    function totalSupply() external;\n', '    function myTokens() external returns(uint256);\n', '    function myDividends(bool _includeReferralBonus) external returns (uint256);\n', '    function balanceOf(address _investorAddress) external returns (uint256);\n', '    function dividendsOf(address _investorAddress) external returns (uint256);\n', '    function sellPrice() payable external returns (uint256);\n', '    function buyPrice() external;\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) external;\n', '    function calculateEthereumReceived(uint256 _tokensToSell) external returns(uint256);\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) external;\n', '}\n', '\n', 'contract CryptoMinerFund {\n', '    using ItsJustBasicMathBro\n', '    for uint;\n', '    \n', '    /* Marketing private wallet*/\n', '    address constant _parojectMarketing = 0x3d3B4a38caD44c2B77DAAC1D746124D2e2b8a27C;\n', '    address constant _cmtfContractAddress = 0x0a97094c19295E320D5121d72139A150021a2702;\n', '    /* Interface to main CMT contract */    \n', '    HourglassInterface constant CMTContract = HourglassInterface(_cmtfContractAddress);\n', '    /* Hashtables for functionality */\n', '    mapping(address => uint) public walletDeposits;\n', '    mapping(address => uint) public walletTimer;\n', '    mapping(address => uint) public withdrawedAmounts;\n', '    \n', '    /* % Fee that will be deducted from initial transfer and sent to CMT contract */\n', '    uint constant _masterTaxOnInvestment = 8;\n', '    /* Time modifier for return value incremental increase */\n', '    uint constant payOutInterval = 1 hours;\n', '    /* Percent rates */\n', '    uint constant basePercent = 250;\n', '    uint constant lowPercent = 300;\n', '    uint constant averagePercent = 350;\n', '    uint constant highPercent = 500;\n', '    /* Balance switches for % */\n', '    uint constant phasePreperation = 200 ether;\n', '    uint constant phaseEngineStart = 500 ether;\n', '    uint constant phaseLiftoff = 2000 ether;\n', '    uint constant taxFreeEpoc = 1540321200;\n', '\n', '    /* Fallback that allows to call early exit or with any other value to make a deposit after 1 hour */\n', '    function() external payable {\n', '        if (msg.value > 0) {\n', '            makeDeposit();\n', '        } else {\n', '            requestPayDay();\n', '        }\n', '    }\n', '\n', '    /* Internal function that makes record into walletDeposits for incomming deposit */\n', '    function makeDeposit() internal{\n', '        if (msg.value > 0) {\n', '                /* If user has already deposited we add value to balance & reset timer */\n', '                if(walletDeposits[msg.sender]>0){\n', '                     walletDeposits[msg.sender] += msg.value;\n', '                     walletTimer[msg.sender] = now;\n', '                }\n', '                else{\n', '                     walletDeposits[msg.sender] = walletDeposits[msg.sender].add(msg.value);\n', '                }\n', '              \n', '               walletTimer[msg.sender] = now;\n', '               /* Till 2018. 23. October, Thursday, 22:00:00 is divident free investments */\n', '              if(now > taxFreeEpoc){\n', '                startDivDistribution();\n', '              }\n', '        }\n', '    }\n', '\n', "    /* Calculates if balance > 92% of investment and returns user he's 92% on early exit or all balance if > */\n", '    function requestPayDay() internal{\n', '        uint payDay = 0;\n', '        if(walletDeposits[msg.sender] > getAvailablePayout()){\n', '            if(walletTimer[msg.sender] > taxFreeEpoc){\n', '                payDay = walletDeposits[msg.sender].mul(92).div(100);\n', '            } else{\n', '                payDay = walletDeposits[msg.sender];\n', '            }\n', '            withdrawedAmounts[msg.sender] = 0;\n', '        } else{\n', '            payDay = getAvailablePayout();\n', '            withdrawedAmounts[msg.sender] += payDay;\n', '        }\n', '        walletTimer[msg.sender] = 0;\n', '        walletDeposits[msg.sender] = 0;\n', '        msg.sender.transfer(payDay);\n', '    }\n', '    \n', '    /* Internal function to distribute masterx tax fee into dividends to all CMT holders */\n', '    function startDivDistribution() internal{\n', '            /*#######################################  !  IMPORTANT  !  ##############################################\n', '            ## Here we buy CMT tokens with 8% from deposit and we intentionally use marketing wallet as masternode  ##\n', '            ## that results into 33% from 10% deducted on 8% goes to marketing & server running  purposes by our    ##\n', '            ## team but the rest of 8% is distributet to all holder with selling CMT tokens & then reinvesting      ##\n', '            ## again  (LOGIC FROM CMT) This kindof functionality allows us to decrease the % tax on deposit since   ##\n', '            ## 1% from deposit is much  more than 33% from 8%.                                                      ##\n', '            ########################################################################################################*/\n', '            CMTContract.buy.value(msg.value.mul(_masterTaxOnInvestment).div(100))(_parojectMarketing);\n', '            uint _cmtBalance = getFundCMTBalance();\n', '            CMTContract.sell(_cmtBalance);\n', '            CMTContract.reinvest();\n', '    }\n', '      \n', '    /* Calculates actual value of % earned */\n', '    function getAvailablePayout() public view returns(uint) {\n', '        uint percent = resolvePercentRate();\n', '        uint interestRate = now.sub(walletTimer[msg.sender]).div(payOutInterval);\n', '        uint baseRate = walletDeposits[msg.sender].mul(percent).div(100000);\n', '        uint withdrawAmount = baseRate.mul(interestRate);\n', '        if(withdrawAmount > walletDeposits[msg.sender].mul(2)){\n', '            return walletDeposits[msg.sender].mul(2);\n', '        }\n', '        return (withdrawAmount);\n', '    }\n', '\n', '    /* Resolve percent rate for deposit */\n', '    function resolvePercentRate() public view returns(uint) {\n', '        uint balance = address(this).balance;\n', '        if (balance < phasePreperation) {\n', '            return (basePercent);\n', '        }\n', '        if (balance >= phasePreperation && balance < phaseEngineStart) {\n', '            return (lowPercent);\n', '        }\n', '        if (balance >= phaseEngineStart && balance < phaseLiftoff) {\n', '            return (averagePercent);\n', '        }\n', '        if (balance >= phaseLiftoff) {\n', '            return (highPercent);\n', '        }\n', '    }\n', '\n', '    /* Returns contracts balance on CMT contract */\n', '    function getFundCMTBalance() internal returns (uint256){\n', '        return CMTContract.myTokens();\n', '    }\n', '    \n', '    /* Returns total balance of contract wallet */\n', '    function totalEthereumBalance() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '\n', '}\n', '\n', 'library ItsJustBasicMathBro {\n', '\n', '    function mul(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}']