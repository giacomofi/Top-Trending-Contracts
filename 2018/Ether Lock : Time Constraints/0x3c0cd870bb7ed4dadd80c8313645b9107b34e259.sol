['pragma solidity ^0.4.25;\n', '\n', 'interface HourglassInterface {\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function reinvest() external;\n', '    function withdraw() external;\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function balanceOf(address _customerAddress) view external returns(uint256);\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '}\n', '\n', 'contract StrongHandsManager {\n', '    \n', '    event CreatedStrongHand(address indexed owner, address indexed strongHand);\n', '    \n', '    mapping (address => address) public strongHands;\n', '    \n', '    function isStrongHand()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return strongHands[msg.sender] != address(0);\n', '    }\n', '    \n', '    function myStrongHand()\n', '        external\n', '        view\n', '        returns (address)\n', '    {  \n', '        require(isStrongHand(), "You are not a Stronghand");\n', '        \n', '        return strongHands[msg.sender];\n', '    }\n', '    \n', '    function create(uint256 _unlockAfterNDays)\n', '        public\n', '    {\n', '        require(!isStrongHand(), "You already became a Stronghand");\n', '        require(_unlockAfterNDays > 0);\n', '        \n', '        address owner = msg.sender;\n', '    \n', '        strongHands[owner] = new StrongHand(owner, _unlockAfterNDays);\n', '        \n', '        emit CreatedStrongHand(owner, strongHands[owner]);\n', '    }\n', '}\n', '\n', 'contract StrongHand {\n', '\n', '    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '    \n', '    address public owner;\n', '    \n', '    uint256 public creationDate;\n', '    \n', '    uint256 public unlockAfterNDays;\n', '    \n', '    modifier timeLocked()\n', '    {\n', '        require(now >= creationDate + unlockAfterNDays * 1 days);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    constructor(address _owner, uint256 _unlockAfterNDays)\n', '        public\n', '    {\n', '        owner = _owner;\n', '        unlockAfterNDays =_unlockAfterNDays;\n', '        \n', '        creationDate = now;\n', '    }\n', '    \n', '    function() public payable {}\n', '    \n', '    function isLocked()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return now < creationDate + unlockAfterNDays * 1 days;\n', '    }\n', '    \n', '    function lockedUntil()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return creationDate + unlockAfterNDays * 1 days;\n', '    }\n', '    \n', '    function extendLock(uint256 _howManyDays)\n', '        external\n', '        onlyOwner\n', '    {\n', '        uint256 newLockTime = unlockAfterNDays + _howManyDays;\n', '        \n', '        require(newLockTime > unlockAfterNDays);\n', '        \n', '        unlockAfterNDays = newLockTime;\n', '    }\n', '    \n', '    //safety functions\n', '    \n', '    function withdraw()\n', '        external\n', '        onlyOwner\n', '    {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function buyWithBalance()\n', '        external\n', '        onlyOwner\n', '    {\n', '       p3dContract.buy.value(address(this).balance)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\n', '    }\n', '    \n', '    //P3D functions\n', '    \n', '    function balanceOf()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return p3dContract.balanceOf(address(this));\n', '    }\n', '    \n', '    function dividendsOf()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return p3dContract.myDividends(true);\n', '    }\n', '    \n', '    function buy()\n', '        external\n', '        payable\n', '        onlyOwner\n', '    {\n', '        p3dContract.buy.value(msg.value)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\n', '    }\n', '    \n', '    function reinvest()\n', '        external\n', '        onlyOwner\n', '    {\n', '        p3dContract.reinvest();\n', '    }\n', '\n', '    function withdrawDividends()\n', '        external\n', '        onlyOwner\n', '    {\n', '        p3dContract.withdraw();\n', '        \n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function sell(uint256 _amount)\n', '        external\n', '        timeLocked\n', '        onlyOwner\n', '    {\n', '        p3dContract.sell(_amount);\n', '        \n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        external\n', '        timeLocked\n', '        onlyOwner\n', '        returns(bool)\n', '    {\n', '        return p3dContract.transfer(_toAddress, _amountOfTokens);\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'interface HourglassInterface {\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function reinvest() external;\n', '    function withdraw() external;\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function balanceOf(address _customerAddress) view external returns(uint256);\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '}\n', '\n', 'contract StrongHandsManager {\n', '    \n', '    event CreatedStrongHand(address indexed owner, address indexed strongHand);\n', '    \n', '    mapping (address => address) public strongHands;\n', '    \n', '    function isStrongHand()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return strongHands[msg.sender] != address(0);\n', '    }\n', '    \n', '    function myStrongHand()\n', '        external\n', '        view\n', '        returns (address)\n', '    {  \n', '        require(isStrongHand(), "You are not a Stronghand");\n', '        \n', '        return strongHands[msg.sender];\n', '    }\n', '    \n', '    function create(uint256 _unlockAfterNDays)\n', '        public\n', '    {\n', '        require(!isStrongHand(), "You already became a Stronghand");\n', '        require(_unlockAfterNDays > 0);\n', '        \n', '        address owner = msg.sender;\n', '    \n', '        strongHands[owner] = new StrongHand(owner, _unlockAfterNDays);\n', '        \n', '        emit CreatedStrongHand(owner, strongHands[owner]);\n', '    }\n', '}\n', '\n', 'contract StrongHand {\n', '\n', '    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '    \n', '    address public owner;\n', '    \n', '    uint256 public creationDate;\n', '    \n', '    uint256 public unlockAfterNDays;\n', '    \n', '    modifier timeLocked()\n', '    {\n', '        require(now >= creationDate + unlockAfterNDays * 1 days);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    constructor(address _owner, uint256 _unlockAfterNDays)\n', '        public\n', '    {\n', '        owner = _owner;\n', '        unlockAfterNDays =_unlockAfterNDays;\n', '        \n', '        creationDate = now;\n', '    }\n', '    \n', '    function() public payable {}\n', '    \n', '    function isLocked()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return now < creationDate + unlockAfterNDays * 1 days;\n', '    }\n', '    \n', '    function lockedUntil()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return creationDate + unlockAfterNDays * 1 days;\n', '    }\n', '    \n', '    function extendLock(uint256 _howManyDays)\n', '        external\n', '        onlyOwner\n', '    {\n', '        uint256 newLockTime = unlockAfterNDays + _howManyDays;\n', '        \n', '        require(newLockTime > unlockAfterNDays);\n', '        \n', '        unlockAfterNDays = newLockTime;\n', '    }\n', '    \n', '    //safety functions\n', '    \n', '    function withdraw()\n', '        external\n', '        onlyOwner\n', '    {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function buyWithBalance()\n', '        external\n', '        onlyOwner\n', '    {\n', '       p3dContract.buy.value(address(this).balance)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\n', '    }\n', '    \n', '    //P3D functions\n', '    \n', '    function balanceOf()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return p3dContract.balanceOf(address(this));\n', '    }\n', '    \n', '    function dividendsOf()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return p3dContract.myDividends(true);\n', '    }\n', '    \n', '    function buy()\n', '        external\n', '        payable\n', '        onlyOwner\n', '    {\n', '        p3dContract.buy.value(msg.value)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\n', '    }\n', '    \n', '    function reinvest()\n', '        external\n', '        onlyOwner\n', '    {\n', '        p3dContract.reinvest();\n', '    }\n', '\n', '    function withdrawDividends()\n', '        external\n', '        onlyOwner\n', '    {\n', '        p3dContract.withdraw();\n', '        \n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function sell(uint256 _amount)\n', '        external\n', '        timeLocked\n', '        onlyOwner\n', '    {\n', '        p3dContract.sell(_amount);\n', '        \n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        external\n', '        timeLocked\n', '        onlyOwner\n', '        returns(bool)\n', '    {\n', '        return p3dContract.transfer(_toAddress, _amountOfTokens);\n', '    }\n', '}']
