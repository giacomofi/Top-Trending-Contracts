['pragma solidity ^0.4.18;\n', '\n', '    contract Owned {\n', '\n', '        modifier onlyOwner { require(msg.sender == owner); _; }\n', '\n', '        address public owner;\n', '\n', '        function Owned() public { owner = msg.sender;}\n', '\n', '        function changeOwner(address _newOwner) public onlyOwner {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '    contract TokenController {\n', '\n', '        function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '        function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '    }\n', '\n', '    contract ApproveAndCallFallBack {\n', '        function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '    }\n', '\n', '    contract KayoToken is Owned {\n', '\n', '        string public name;                \n', '        uint8 public decimals;             \n', '        string public symbol;              \n', '\n', '        struct  Checkpoint {\n', '\n', '            uint128 fromBlock;\n', '\n', '            uint128 value;\n', '        }\n', '\n', '        KayoToken public parentToken;\n', '\n', '        uint public parentSnapShotBlock;\n', '\n', '        uint public creationBlock;\n', '\n', '        mapping (address => Checkpoint[]) balances;\n', '\n', '        uint public preSaleTokenBalances;\n', '\n', '        mapping (address => mapping (address => uint256)) allowed;\n', '\n', '        Checkpoint[] totalSupplyHistory;\n', '\n', '        bool public transfersEnabled;\n', '        \n', '        bool public IsPreSaleEnabled = false;\n', '\n', '        bool public IsSaleEnabled = false;\n', '        \n', '        address public owner;\n', '\n', '        address public rewardManager;\n', '        \n', '        uint public allowedRewardTokens;\n', '\n', '        mapping (address => bool) public frozenAccount;\n', '        event FrozenFunds(address target, bool frozen);\n', '        \n', '        modifier canReleaseToken {\n', '            if (IsSaleEnabled == true || IsPreSaleEnabled == true) \n', '                _;\n', '            else\n', '                revert();\n', '        }\n', '\n', '        modifier onlyRewardManager { \n', '            require(msg.sender == rewardManager || owner == msg.sender); _; \n', '        }\n', '\n', '        function KayoToken(\n', '            address _tokenFactory,\n', '            address _parentToken,\n', '            uint _parentSnapShotBlock,\n', '            string _tokenName,\n', '            uint8 _decimalUnits,\n', '            string _tokenSymbol,\n', '            bool _transfersEnabled\n', '        ) public {\n', '            owner = _tokenFactory;\n', '            name = _tokenName;                                 \n', '            decimals = _decimalUnits;                          \n', '            symbol = _tokenSymbol;                             \n', '            parentToken = KayoToken(_parentToken);\n', '            parentSnapShotBlock = _parentSnapShotBlock;\n', '            transfersEnabled = _transfersEnabled;\n', '            creationBlock = block.number;\n', '        }\n', '\n', '        function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '            require(transfersEnabled);\n', '            transferFrom(msg.sender, _to, _amount);\n', '            return true;\n', '        }\n', '\n', '        function freezeAccount(address target, bool freeze) onlyOwner public{\n', '            frozenAccount[target] = freeze;\n', '            FrozenFunds(target, freeze);\n', '        }\n', '\n', '        function setPreSale (bool _value) onlyOwner public {\n', '            IsPreSaleEnabled = _value;\n', '        }\n', '\n', '        function setSale (bool _value) onlyOwner public {\n', '            IsSaleEnabled = _value;\n', '        }\n', '\n', '        function setRewardManger (address _address) onlyOwner public{\n', '            rewardManager = _address;\n', '        }\n', '\n', '        function setRewardManagerLimit(uint _amount) onlyOwner public returns (bool success){\n', '            allowedRewardTokens = _amount;\n', '            approve(rewardManager, _amount);\n', '            return true;\n', '        }\n', '\n', '        function invest(address _to, uint256 _amount) canReleaseToken onlyRewardManager public returns (bool success) {\n', '            \n', '            require((_to != 0) && (_to != address(this)));\n', '\n', '            bool IsTransferAllowed = false;\n', '\n', '            if(IsPreSaleEnabled){\n', '                require(preSaleTokenBalances >= _amount);\n', '                IsTransferAllowed = true;\n', '                preSaleTokenBalances = preSaleTokenBalances - _amount;\n', '\n', '                return true;\n', '            }\n', '            else if(IsSaleEnabled){\n', '                IsTransferAllowed = true;\n', '            }\n', '            else{\n', '                revert();\n', '            }\n', '\n', '            require(IsTransferAllowed);\n', '            var previousBalanceFrom = balanceOfAt(msg.sender, block.number);\n', '            require(previousBalanceFrom >= _amount);\n', '            updateValueAtNow(balances[msg.sender], previousBalanceFrom - _amount);\n', '\n', '            var previousBalanceTo = balanceOfAt(_to, block.number);\n', '            require(previousBalanceTo + _amount >= previousBalanceTo);\n', '            updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '            if(msg.sender == rewardManager){\n', '                transferFrom(owner, _to, _amount);      //Reward manager sending tokens \n', '            }\n', '            else{\n', '                transferFrom(msg.sender, _to, _amount); //Owner sending tokens\n', '            }\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '\n', '            require(IsSaleEnabled && !IsPreSaleEnabled);\n', '\n', '            if (_amount == 0) {\n', '                Transfer(_from, _to, _amount);\n', '                return;\n', '            }\n', '\n', '            if (msg.sender != owner) {\n', '                require(allowed[_from][msg.sender] >= _amount);\n', '                allowed[_from][msg.sender] -= _amount;\n', '            }\n', '\n', '            Transfer(_from, _to, _amount);\n', '\n', '            return true;\n', '        }\n', '\n', '        function balanceOf(address _owner) public constant returns (uint256 tokenBalance) {\n', '            return balanceOfAt(_owner, block.number);\n', '        }\n', '\n', '        function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '\n', '            require(transfersEnabled);\n', '            require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '            if (isValidAddress(owner)) {\n', '                require(TokenController(owner).onApprove(msg.sender, _spender, _amount));\n', '            }\n', '\n', '            allowed[msg.sender][_spender] = _amount;\n', '            Approval(msg.sender, _spender, _amount);\n', '            return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '            return allowed[_owner][_spender];\n', '        }\n', '\n', '        function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n', '\n', '            require(approve(_spender, _amount));\n', '            ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData);\n', '            return true;\n', '        }\n', '\n', '        function totalSupply() public constant returns (uint) {\n', '            return totalSupplyAt(block.number);\n', '        }\n', '\n', '        function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\n', '\n', '            if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '                if (address(parentToken) != 0) {\n', '                    return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '                } else {\n', '                    return 0;\n', '                }\n', '\n', '            } else {\n', '                return getValueAt(balances[_owner], _blockNumber);\n', '            }\n', '        }\n', '\n', '        function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '\n', '            if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '                if (address(parentToken) != 0) {\n', '                    return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '                } else {\n', '                    return 0;\n', '                }\n', '\n', '            } else {\n', '                return getValueAt(totalSupplyHistory, _blockNumber);\n', '            }\n', '        }\n', '\n', '        function generateTokens(address _owner, uint _amount) public onlyOwner returns (bool) {\n', '            uint curTotalSupply = totalSupply();\n', '            require(curTotalSupply + _amount >= curTotalSupply);\n', '            uint previousBalanceTo = balanceOf(_owner);\n', '            require(previousBalanceTo + _amount >= previousBalanceTo);\n', '\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '            updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '\n', '            uint256 _bal = _amount * 30;\n', '            preSaleTokenBalances = preSaleTokenBalances + _bal / 100;\n', '            Transfer(0, _owner, _amount);\n', '            return true;\n', '        }\n', '\n', '        function destroyTokens(address _owner, uint _amount) onlyOwner public returns (bool) {\n', '            uint curTotalSupply = totalSupply();\n', '            require(curTotalSupply >= _amount);\n', '            uint previousBalanceFrom = balanceOf(_owner);\n', '            require(previousBalanceFrom >= _amount);\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n', '            updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n', '            Transfer(_owner, 0, _amount);\n', '            return true;\n', '        }\n', '        \n', '        function destroyAllTokens(address _owner) onlyOwner public returns (bool) {\n', '            updateValueAtNow(totalSupplyHistory, 0);\n', '            updateValueAtNow(balances[_owner], 0);\n', '            Transfer(_owner, 0, 0);\n', '            return true;\n', '        }\n', '\n', '        function enableTransfers(bool _transfersEnabled) public onlyOwner {\n', '            transfersEnabled = _transfersEnabled;\n', '        }\n', '\n', '\n', '        function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {\n', '            \n', '            if (checkpoints.length == 0) return 0;\n', '\n', '            if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '                return checkpoints[checkpoints.length-1].value;\n', '\n', '            if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '            uint minValue = 0;\n', '            uint maximum = checkpoints.length-1;\n', '            while (maximum > minValue) {\n', '                uint midddle = (maximum + minValue + 1)/ 2;\n', '                if (checkpoints[midddle].fromBlock<=_block) {\n', '                    minValue = midddle;\n', '                } else {\n', '                    maximum = midddle-1;\n', '                }\n', '            }\n', '            return checkpoints[minValue].value;\n', '        }\n', '\n', '        function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {\n', '            if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '                Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '                newCheckPoint.fromBlock =  uint128(block.number);\n', '                newCheckPoint.value = uint128(_value);\n', '            } else {\n', '                Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '                oldCheckPoint.value = uint128(_value);\n', '            }\n', '        }\n', '\n', '        function isValidAddress(address _addr) constant internal returns(bool) {\n', '            uint size;\n', '            if (_addr == 0) return false;\n', '            assembly {\n', '                size := extcodesize(_addr)\n', '            }\n', '            return size > 0;\n', '        }\n', '\n', '        function min(uint a, uint b) pure internal returns (uint) {\n', '            return a < b ? a : b;\n', '        }\n', '\n', '        event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '        event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '\n', '    }']
['pragma solidity ^0.4.18;\n', '\n', '    contract Owned {\n', '\n', '        modifier onlyOwner { require(msg.sender == owner); _; }\n', '\n', '        address public owner;\n', '\n', '        function Owned() public { owner = msg.sender;}\n', '\n', '        function changeOwner(address _newOwner) public onlyOwner {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '    contract TokenController {\n', '\n', '        function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '        function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '    }\n', '\n', '    contract ApproveAndCallFallBack {\n', '        function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '    }\n', '\n', '    contract KayoToken is Owned {\n', '\n', '        string public name;                \n', '        uint8 public decimals;             \n', '        string public symbol;              \n', '\n', '        struct  Checkpoint {\n', '\n', '            uint128 fromBlock;\n', '\n', '            uint128 value;\n', '        }\n', '\n', '        KayoToken public parentToken;\n', '\n', '        uint public parentSnapShotBlock;\n', '\n', '        uint public creationBlock;\n', '\n', '        mapping (address => Checkpoint[]) balances;\n', '\n', '        uint public preSaleTokenBalances;\n', '\n', '        mapping (address => mapping (address => uint256)) allowed;\n', '\n', '        Checkpoint[] totalSupplyHistory;\n', '\n', '        bool public transfersEnabled;\n', '        \n', '        bool public IsPreSaleEnabled = false;\n', '\n', '        bool public IsSaleEnabled = false;\n', '        \n', '        address public owner;\n', '\n', '        address public rewardManager;\n', '        \n', '        uint public allowedRewardTokens;\n', '\n', '        mapping (address => bool) public frozenAccount;\n', '        event FrozenFunds(address target, bool frozen);\n', '        \n', '        modifier canReleaseToken {\n', '            if (IsSaleEnabled == true || IsPreSaleEnabled == true) \n', '                _;\n', '            else\n', '                revert();\n', '        }\n', '\n', '        modifier onlyRewardManager { \n', '            require(msg.sender == rewardManager || owner == msg.sender); _; \n', '        }\n', '\n', '        function KayoToken(\n', '            address _tokenFactory,\n', '            address _parentToken,\n', '            uint _parentSnapShotBlock,\n', '            string _tokenName,\n', '            uint8 _decimalUnits,\n', '            string _tokenSymbol,\n', '            bool _transfersEnabled\n', '        ) public {\n', '            owner = _tokenFactory;\n', '            name = _tokenName;                                 \n', '            decimals = _decimalUnits;                          \n', '            symbol = _tokenSymbol;                             \n', '            parentToken = KayoToken(_parentToken);\n', '            parentSnapShotBlock = _parentSnapShotBlock;\n', '            transfersEnabled = _transfersEnabled;\n', '            creationBlock = block.number;\n', '        }\n', '\n', '        function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '            require(transfersEnabled);\n', '            transferFrom(msg.sender, _to, _amount);\n', '            return true;\n', '        }\n', '\n', '        function freezeAccount(address target, bool freeze) onlyOwner public{\n', '            frozenAccount[target] = freeze;\n', '            FrozenFunds(target, freeze);\n', '        }\n', '\n', '        function setPreSale (bool _value) onlyOwner public {\n', '            IsPreSaleEnabled = _value;\n', '        }\n', '\n', '        function setSale (bool _value) onlyOwner public {\n', '            IsSaleEnabled = _value;\n', '        }\n', '\n', '        function setRewardManger (address _address) onlyOwner public{\n', '            rewardManager = _address;\n', '        }\n', '\n', '        function setRewardManagerLimit(uint _amount) onlyOwner public returns (bool success){\n', '            allowedRewardTokens = _amount;\n', '            approve(rewardManager, _amount);\n', '            return true;\n', '        }\n', '\n', '        function invest(address _to, uint256 _amount) canReleaseToken onlyRewardManager public returns (bool success) {\n', '            \n', '            require((_to != 0) && (_to != address(this)));\n', '\n', '            bool IsTransferAllowed = false;\n', '\n', '            if(IsPreSaleEnabled){\n', '                require(preSaleTokenBalances >= _amount);\n', '                IsTransferAllowed = true;\n', '                preSaleTokenBalances = preSaleTokenBalances - _amount;\n', '\n', '                return true;\n', '            }\n', '            else if(IsSaleEnabled){\n', '                IsTransferAllowed = true;\n', '            }\n', '            else{\n', '                revert();\n', '            }\n', '\n', '            require(IsTransferAllowed);\n', '            var previousBalanceFrom = balanceOfAt(msg.sender, block.number);\n', '            require(previousBalanceFrom >= _amount);\n', '            updateValueAtNow(balances[msg.sender], previousBalanceFrom - _amount);\n', '\n', '            var previousBalanceTo = balanceOfAt(_to, block.number);\n', '            require(previousBalanceTo + _amount >= previousBalanceTo);\n', '            updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '            if(msg.sender == rewardManager){\n', '                transferFrom(owner, _to, _amount);      //Reward manager sending tokens \n', '            }\n', '            else{\n', '                transferFrom(msg.sender, _to, _amount); //Owner sending tokens\n', '            }\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '\n', '            require(IsSaleEnabled && !IsPreSaleEnabled);\n', '\n', '            if (_amount == 0) {\n', '                Transfer(_from, _to, _amount);\n', '                return;\n', '            }\n', '\n', '            if (msg.sender != owner) {\n', '                require(allowed[_from][msg.sender] >= _amount);\n', '                allowed[_from][msg.sender] -= _amount;\n', '            }\n', '\n', '            Transfer(_from, _to, _amount);\n', '\n', '            return true;\n', '        }\n', '\n', '        function balanceOf(address _owner) public constant returns (uint256 tokenBalance) {\n', '            return balanceOfAt(_owner, block.number);\n', '        }\n', '\n', '        function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '\n', '            require(transfersEnabled);\n', '            require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '            if (isValidAddress(owner)) {\n', '                require(TokenController(owner).onApprove(msg.sender, _spender, _amount));\n', '            }\n', '\n', '            allowed[msg.sender][_spender] = _amount;\n', '            Approval(msg.sender, _spender, _amount);\n', '            return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '            return allowed[_owner][_spender];\n', '        }\n', '\n', '        function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n', '\n', '            require(approve(_spender, _amount));\n', '            ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData);\n', '            return true;\n', '        }\n', '\n', '        function totalSupply() public constant returns (uint) {\n', '            return totalSupplyAt(block.number);\n', '        }\n', '\n', '        function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\n', '\n', '            if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '                if (address(parentToken) != 0) {\n', '                    return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '                } else {\n', '                    return 0;\n', '                }\n', '\n', '            } else {\n', '                return getValueAt(balances[_owner], _blockNumber);\n', '            }\n', '        }\n', '\n', '        function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '\n', '            if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '                if (address(parentToken) != 0) {\n', '                    return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '                } else {\n', '                    return 0;\n', '                }\n', '\n', '            } else {\n', '                return getValueAt(totalSupplyHistory, _blockNumber);\n', '            }\n', '        }\n', '\n', '        function generateTokens(address _owner, uint _amount) public onlyOwner returns (bool) {\n', '            uint curTotalSupply = totalSupply();\n', '            require(curTotalSupply + _amount >= curTotalSupply);\n', '            uint previousBalanceTo = balanceOf(_owner);\n', '            require(previousBalanceTo + _amount >= previousBalanceTo);\n', '\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '            updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '\n', '            uint256 _bal = _amount * 30;\n', '            preSaleTokenBalances = preSaleTokenBalances + _bal / 100;\n', '            Transfer(0, _owner, _amount);\n', '            return true;\n', '        }\n', '\n', '        function destroyTokens(address _owner, uint _amount) onlyOwner public returns (bool) {\n', '            uint curTotalSupply = totalSupply();\n', '            require(curTotalSupply >= _amount);\n', '            uint previousBalanceFrom = balanceOf(_owner);\n', '            require(previousBalanceFrom >= _amount);\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n', '            updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n', '            Transfer(_owner, 0, _amount);\n', '            return true;\n', '        }\n', '        \n', '        function destroyAllTokens(address _owner) onlyOwner public returns (bool) {\n', '            updateValueAtNow(totalSupplyHistory, 0);\n', '            updateValueAtNow(balances[_owner], 0);\n', '            Transfer(_owner, 0, 0);\n', '            return true;\n', '        }\n', '\n', '        function enableTransfers(bool _transfersEnabled) public onlyOwner {\n', '            transfersEnabled = _transfersEnabled;\n', '        }\n', '\n', '\n', '        function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {\n', '            \n', '            if (checkpoints.length == 0) return 0;\n', '\n', '            if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '                return checkpoints[checkpoints.length-1].value;\n', '\n', '            if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '            uint minValue = 0;\n', '            uint maximum = checkpoints.length-1;\n', '            while (maximum > minValue) {\n', '                uint midddle = (maximum + minValue + 1)/ 2;\n', '                if (checkpoints[midddle].fromBlock<=_block) {\n', '                    minValue = midddle;\n', '                } else {\n', '                    maximum = midddle-1;\n', '                }\n', '            }\n', '            return checkpoints[minValue].value;\n', '        }\n', '\n', '        function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {\n', '            if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '                Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '                newCheckPoint.fromBlock =  uint128(block.number);\n', '                newCheckPoint.value = uint128(_value);\n', '            } else {\n', '                Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '                oldCheckPoint.value = uint128(_value);\n', '            }\n', '        }\n', '\n', '        function isValidAddress(address _addr) constant internal returns(bool) {\n', '            uint size;\n', '            if (_addr == 0) return false;\n', '            assembly {\n', '                size := extcodesize(_addr)\n', '            }\n', '            return size > 0;\n', '        }\n', '\n', '        function min(uint a, uint b) pure internal returns (uint) {\n', '            return a < b ? a : b;\n', '        }\n', '\n', '        event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '        event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '\n', '    }']
