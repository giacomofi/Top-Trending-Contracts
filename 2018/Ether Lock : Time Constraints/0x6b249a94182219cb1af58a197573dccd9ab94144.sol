['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/library/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n', ' * - added sqrt\n', ' * - added sq\n', ' * - added pwr \n', ' * - changed asserts to requires with error log outputs\n', ' * - removed div, its useless\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/library/TimeUtils.sol\n', '\n', 'library TimeUtils {\n', '    /*\n', '     *  Date and Time utilities for ethereum contracts\n', '     *\n', '     */\n', '    struct _DateTime {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 minute;\n', '        uint8 second;\n', '        uint8 weekday;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint constant HOUR_IN_SECONDS = 3600;\n', '    uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) public pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '            return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '            return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) public pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '            return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '            return 29;\n', '        }\n', '        else {\n', '            return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        // Year\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        // Day\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '\n', '        // Hour\n', '        dt.hour = getHour(timestamp);\n', '\n', '        // Minute\n', '        dt.minute = getMinute(timestamp);\n', '\n', '        // Second\n', '        dt.second = getSecond(timestamp);\n', '\n', '        // Day of week.\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '\n', '    function parseTimestampToYM(uint timestamp) internal pure returns (uint16, uint8) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        uint16 year;\n', '        uint8 month;\n', '\n', '        // Year\n', '        year = getYear(timestamp);\n', '        buf = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for(i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, year);\n', '            if(secondsInMonth + secondsAccountedFor > timestamp) {\n', '                month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        return (year, month);\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        // Year\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '            if (isLeapYear(uint16(year - 1))) {\n', '                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            }\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function getHour(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60 / 60) % 24);\n', '    }\n', '\n', '    function getMinute(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60) % 60);\n', '    }\n', '\n', '    function getSecond(uint timestamp) public pure returns (uint8) {\n', '        return uint8(timestamp % 60);\n', '    }\n', '\n', '    function getWeekday(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '        uint16 i;\n', '\n', '        // Year\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '            if (isLeapYear(i)) {\n', '                timestamp += LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                timestamp += YEAR_IN_SECONDS;\n', '            }\n', '        }\n', '\n', '        // Month\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '            monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '            monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        // Day\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '        // Hour\n', '        timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '        // Minute\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '        // Second\n', '        timestamp += second;\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', '// File: contracts/interface/DRSCoinInterface.sol\n', '\n', 'interface DRSCoinInterface {\n', '    function mint(address _to, uint256 _amount) external;\n', '    function profitEth() external payable;\n', '}\n', '\n', '// File: contracts/DRSCoin.sol\n', '\n', 'contract DRSCoin {\n', '    using SafeMath for uint256;\n', '    using TimeUtils for uint;\n', '\n', '    struct MonthInfo {\n', '        uint256 ethIncome;\n', '        uint256 totalTokenSupply;\n', '    }\n', '\n', '    string constant tokenName = "DRSCoin";\n', '    string constant tokenSymbol = "DRS";\n', '    uint8 constant decimalUnits = 18;\n', '\n', '    uint256 public constant tokenExchangeInitRate = 500; // 500 tokens per 1 ETH initial\n', '    uint256 public constant tokenExchangeLeastRate = 10; // 10 tokens per 1 ETH at least\n', '    uint256 public constant tokenReduceValue = 5000000;\n', '    uint256 public constant coinReduceRate = 90;\n', '\n', '    uint256 constant private proposingPeriod = 2 days;\n', '    // uint256 constant private proposingPeriod = 2 seconds;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    uint256 public totalSupply = 0;\n', '    uint256 public tokenReduceAmount;\n', '    uint256 public tokenExchangeRate; // DRSCoin / eth\n', '    uint256 public nextReduceSupply;  // next DRSCoin reduction supply\n', '\n', '    address public owner;\n', '\n', '    mapping(address => bool) restrictedAddresses;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    mapping(address => uint32) public lastRefundMonth;\n', '\n', '    mapping(address => uint256) public refundEth;  //record the user profit\n', '\n', '    mapping(uint32 => MonthInfo) monthInfos;\n', '\n', '    mapping(address => bool) allowedGameAddress;\n', '\n', '    mapping(address => uint256) proposedGames;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Mint(address indexed _to, uint256 _value);\n', '\n', '    // event Info(uint256 _value);\n', '\n', '    /* This notifies clients about the amount burnt */\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    event Profit(address indexed from, uint256 year, uint256 month, uint256 value);\n', '\n', '    event Withdraw(address indexed from, uint256 value);\n', '\n', '    modifier onlyOwner {\n', '        assert(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowedGameAddress {\n', '        require(allowedGameAddress[msg.sender], "only allowed games permit to call");\n', '        _;\n', '    }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    constructor() public\n', '    {\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '        decimals = decimalUnits;                            // Amount of decimals for display purposes\n', '\n', '        tokenReduceAmount = tokenReduceValue.mul(uint256(10) ** uint256(decimals));\n', '        tokenExchangeRate = tokenExchangeInitRate;          // Set initial token exchange rate\n', '        nextReduceSupply = tokenReduceAmount;               // Set next token reduction supply\n', '\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // _startMonth included\n', '    // _nowMonth excluded\n', '    function settleEth(address _addr, uint32 _startMonth, uint32 _nowMonth) internal {\n', '        require(_nowMonth >= _startMonth);\n', '\n', '        // _startMonth == 0 means new address\n', '        if(_startMonth == 0) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        if(_nowMonth == _startMonth) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        uint256 _balance = balanceOf[_addr];\n', '        if(_balance == 0) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _balance);\n', '        refundEth[_addr] = refundEth[_addr].add(_unpaidPerfit);\n', '\n', '        lastRefundMonth[_addr] = _nowMonth;\n', '        return;\n', '    }\n', '\n', '    function getCurrentMonth() internal view returns(uint32) {\n', '        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\n', '        return _year * 12 + _month - 1;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool success) {\n', '        require(_value > 0);\n', '        require(balanceOf[msg.sender] >= _value);              // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows\n', '        require(!restrictedAddresses[msg.sender]);\n', '        require(!restrictedAddresses[_to]);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        // settle msg.sender&#39;s eth\n', '        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\n', '\n', '        // settle _to&#39;s eth\n', '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        // transfer token\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                 // Add the same to the recipient\n', '        emit Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool success) {\n', '        allowance[msg.sender][_spender] = _value;                 // Set allowance\n', '        emit Approval(msg.sender, _spender, _value);              // Raise Approval event\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        require(balanceOf[_from] >= _value);                  // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);   // Check for overflows\n', '        require(_value <= allowance[_from][msg.sender]);      // Check allowance\n', '        require(!restrictedAddresses[_from]);\n', '        require(!restrictedAddresses[msg.sender]);\n', '        require(!restrictedAddresses[_to]);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        // settle _from&#39;s eth\n', '        settleEth(_from, lastRefundMonth[_from], _nowMonth);\n', '\n', '        // settle _to&#39;s eth\n', '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        // transfer token\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);        // Add the same to the recipient\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function getUnpaidPerfit(uint32 _startMonth, uint32 _endMonth, uint256 _tokenAmount) internal view returns(uint256)\n', '    {\n', '        require(_startMonth > 0);\n', '        require(_endMonth >= _startMonth);\n', '\n', '        if(_startMonth == _endMonth) {\n', '            return 0;\n', '        }\n', '\n', '        if(_tokenAmount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _profit = 0;\n', '\n', '        uint256 _income;\n', '        uint256 _totalSupply;\n', '        for(uint32 j = _startMonth; j < _endMonth; j++) {\n', '            _income = monthInfos[j].ethIncome;\n', '            _totalSupply = monthInfos[j].totalTokenSupply;\n', '            if(_income > 0 && _totalSupply > 0) {\n', '                _profit = _profit.add(_income.mul(_tokenAmount).div(_totalSupply));\n', '            }\n', '        }\n', '\n', '        return _profit;\n', '    }\n', '\n', '    function totalSupply() constant public returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function tokenExchangeRate() constant public returns(uint256) {\n', '        return tokenExchangeRate;\n', '    }\n', '\n', '    function nextReduceSupply() constant public returns(uint256) {\n', '        return nextReduceSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns(uint256) {\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns(uint256) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    /* Owner can add new restricted address or removes one */\n', '    function editRestrictedAddress(address _newRestrictedAddress) public onlyOwner {\n', '        restrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];\n', '    }\n', '\n', '    function isRestrictedAddress(address _querryAddress) constant public returns(bool) {\n', '        return restrictedAddresses[_querryAddress];\n', '    }\n', '\n', '    function getMintAmount(uint256 _eth) private view returns(uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) {\n', '        _nextReduceSupply = nextReduceSupply;\n', '        _tokenExchangeRate = tokenExchangeRate;\n', '\n', '        _amount = 0;\n', '        uint256 _part = _nextReduceSupply.sub(totalSupply);  // calculate how many DRSCoin can mint in this period\n', '        while(_part <= _eth.mul(_tokenExchangeRate)) {\n', '            _eth = _eth.sub(_part.div(_tokenExchangeRate));  // sub eth amount\n', '            _amount = _amount.add(_part);                    // add DRSCoin mint in this small part\n', '\n', '            _part = tokenReduceAmount;\n', '            _nextReduceSupply = _nextReduceSupply.add(tokenReduceAmount);\n', '\n', '            if(_tokenExchangeRate > tokenExchangeLeastRate) {\n', '                _tokenExchangeRate = _tokenExchangeRate.mul(coinReduceRate).div(100);\n', '                if(_tokenExchangeRate < tokenExchangeLeastRate) {\n', '                    _tokenExchangeRate = tokenExchangeLeastRate;\n', '                }\n', '            }\n', '        }\n', '\n', '        _amount = _amount.add(_eth.mul(_tokenExchangeRate));\n', '\n', '        return (_amount, _nextReduceSupply, _tokenExchangeRate);\n', '    }\n', '\n', '    function mint(address _to, uint256 _eth) external onlyAllowedGameAddress {\n', '        require(_eth > 0);\n', '\n', '        (uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) = getMintAmount(_eth);\n', '\n', '        require(_amount > 0);\n', '        require(totalSupply + _amount > totalSupply);\n', '        require(balanceOf[_to] + _amount > balanceOf[_to]);     // Check for overflows\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        // settle _to&#39;s eth\n', '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        totalSupply = _amount.add(totalSupply);                 // Update total supply\n', '        balanceOf[_to] = _amount.add(balanceOf[_to]);           // Set minted coins to target\n', '\n', '        // add current month&#39;s totalTokenSupply\n', '        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '\n', '        if(_nextReduceSupply != nextReduceSupply) {\n', '            nextReduceSupply = _nextReduceSupply;\n', '        }\n', '        if(_tokenExchangeRate != tokenExchangeRate) {\n', '            tokenExchangeRate = _tokenExchangeRate;\n', '        }\n', '\n', '        emit Mint(_to, _amount);                                // Create Mint event\n', '        emit Transfer(0x0, _to, _amount);                       // Create Transfer event from 0x\n', '    }\n', '\n', '    function burn(uint256 _value) public returns(bool success) {\n', '        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough\n', '        require(_value > 0);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        // settle msg.sender&#39;s eth\n', '        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender\n', '        totalSupply = totalSupply.sub(_value);                                // Updates totalSupply\n', '\n', '        // update current month&#39;s totalTokenSupply\n', '        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function addGame(address gameAddress) public onlyOwner {\n', '        require(!allowedGameAddress[gameAddress], "game already in allow list");\n', '        require(proposedGames[gameAddress] > 0, "game must be in proposed list first");\n', '        require(now > proposedGames[gameAddress].add(proposingPeriod), "game must be debated for 2 days");\n', '\n', '        // add gameAddress to allowedGameAddress\n', '        allowedGameAddress[gameAddress] = true;\n', '\n', '        // delete gameAddress from proposedGames\n', '        proposedGames[gameAddress] = 0;\n', '    }\n', '\n', '    function proposeGame(address gameAddress) public onlyOwner {\n', '        require(!allowedGameAddress[gameAddress], "game already in allow list");\n', '        require(proposedGames[gameAddress] == 0, "game already in proposed list");\n', '\n', '        // add gameAddress to proposedGames\n', '        proposedGames[gameAddress] = now;\n', '    }\n', '\n', '    function deleteGame (address gameAddress) public onlyOwner {\n', '        require(allowedGameAddress[gameAddress] || proposedGames[gameAddress] > 0, "game must in allow list or proposed list");\n', '\n', '        // delete gameAddress from allowedGameAddress\n', '        allowedGameAddress[gameAddress] = false;\n', '\n', '        // delete gameAddress from proposedGames\n', '        proposedGames[gameAddress] = 0;\n', '    }\n', '\n', '    function gameCountdown(address gameAddress) public view returns(uint256) {\n', '        require(proposedGames[gameAddress] > 0, "game not in proposed list");\n', '\n', '        uint256 proposedTime = proposedGames[gameAddress];\n', '\n', '        if(now < proposedTime.add(proposingPeriod)) {\n', '            return proposedTime.add(proposingPeriod).sub(now);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function profitEth() external payable onlyAllowedGameAddress {\n', '        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\n', '        uint32 _nowMonth = _year * 12 + _month - 1;\n', '\n', '        uint256 _ethIncome = monthInfos[_nowMonth].ethIncome.add(msg.value);\n', '\n', '        monthInfos[_nowMonth].ethIncome = _ethIncome;\n', '\n', '        if(monthInfos[_nowMonth].totalTokenSupply == 0) {\n', '            monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '        }\n', '\n', '        emit Profit(msg.sender, _year, _month, _ethIncome);\n', '    }\n', '\n', '    function withdraw() public {\n', '        require(!restrictedAddresses[msg.sender]);  // check if msg.sender is restricted\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        uint32 _startMonth = lastRefundMonth[msg.sender];\n', '        require(_startMonth > 0);\n', '\n', '        settleEth(msg.sender, _startMonth, _nowMonth);\n', '\n', '        uint256 _profit = refundEth[msg.sender];\n', '        require(_profit > 0);\n', '\n', '        refundEth[msg.sender] = 0;\n', '        msg.sender.transfer(_profit);\n', '\n', '        emit Withdraw(msg.sender, _profit);\n', '    }\n', '\n', '    function getEthPerfit(address _addr) public view returns(uint256) {\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        uint32 _startMonth = lastRefundMonth[_addr];\n', '        // new user\n', '        if(_startMonth == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _tokenAmount = balanceOf[_addr];\n', '\n', '        uint256 _perfit = refundEth[_addr];\n', '\n', '        if(_startMonth < _nowMonth && _tokenAmount > 0) {\n', '            uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _tokenAmount);\n', '            _perfit = _perfit.add(_unpaidPerfit);\n', '        }\n', '\n', '        return _perfit;\n', '    }\n', '}\n', '\n', '// contract DRSCoinTestContract {\n', '//     DRSCoinInterface public drsCoin;\n', '\n', '//     constructor(address _drsCoin) public {\n', '//         drsCoin = DRSCoinInterface(_drsCoin);\n', '//     }\n', '\n', '//     function mintDRSCoin(address _addr, uint256 _amount) public {\n', '//         drsCoin.mint(_addr, _amount);\n', '//     }\n', '// }']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/library/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n', ' * - added sqrt\n', ' * - added sq\n', ' * - added pwr \n', ' * - changed asserts to requires with error log outputs\n', ' * - removed div, its useless\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/library/TimeUtils.sol\n', '\n', 'library TimeUtils {\n', '    /*\n', '     *  Date and Time utilities for ethereum contracts\n', '     *\n', '     */\n', '    struct _DateTime {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 minute;\n', '        uint8 second;\n', '        uint8 weekday;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint constant HOUR_IN_SECONDS = 3600;\n', '    uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) public pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '            return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '            return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) public pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '            return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '            return 29;\n', '        }\n', '        else {\n', '            return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        // Year\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        // Day\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '\n', '        // Hour\n', '        dt.hour = getHour(timestamp);\n', '\n', '        // Minute\n', '        dt.minute = getMinute(timestamp);\n', '\n', '        // Second\n', '        dt.second = getSecond(timestamp);\n', '\n', '        // Day of week.\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '\n', '    function parseTimestampToYM(uint timestamp) internal pure returns (uint16, uint8) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        uint16 year;\n', '        uint8 month;\n', '\n', '        // Year\n', '        year = getYear(timestamp);\n', '        buf = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for(i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, year);\n', '            if(secondsInMonth + secondsAccountedFor > timestamp) {\n', '                month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        return (year, month);\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        // Year\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '            if (isLeapYear(uint16(year - 1))) {\n', '                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            }\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function getHour(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60 / 60) % 24);\n', '    }\n', '\n', '    function getMinute(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60) % 60);\n', '    }\n', '\n', '    function getSecond(uint timestamp) public pure returns (uint8) {\n', '        return uint8(timestamp % 60);\n', '    }\n', '\n', '    function getWeekday(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '        uint16 i;\n', '\n', '        // Year\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '            if (isLeapYear(i)) {\n', '                timestamp += LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                timestamp += YEAR_IN_SECONDS;\n', '            }\n', '        }\n', '\n', '        // Month\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '            monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '            monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        // Day\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '        // Hour\n', '        timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '        // Minute\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '        // Second\n', '        timestamp += second;\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', '// File: contracts/interface/DRSCoinInterface.sol\n', '\n', 'interface DRSCoinInterface {\n', '    function mint(address _to, uint256 _amount) external;\n', '    function profitEth() external payable;\n', '}\n', '\n', '// File: contracts/DRSCoin.sol\n', '\n', 'contract DRSCoin {\n', '    using SafeMath for uint256;\n', '    using TimeUtils for uint;\n', '\n', '    struct MonthInfo {\n', '        uint256 ethIncome;\n', '        uint256 totalTokenSupply;\n', '    }\n', '\n', '    string constant tokenName = "DRSCoin";\n', '    string constant tokenSymbol = "DRS";\n', '    uint8 constant decimalUnits = 18;\n', '\n', '    uint256 public constant tokenExchangeInitRate = 500; // 500 tokens per 1 ETH initial\n', '    uint256 public constant tokenExchangeLeastRate = 10; // 10 tokens per 1 ETH at least\n', '    uint256 public constant tokenReduceValue = 5000000;\n', '    uint256 public constant coinReduceRate = 90;\n', '\n', '    uint256 constant private proposingPeriod = 2 days;\n', '    // uint256 constant private proposingPeriod = 2 seconds;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    uint256 public totalSupply = 0;\n', '    uint256 public tokenReduceAmount;\n', '    uint256 public tokenExchangeRate; // DRSCoin / eth\n', '    uint256 public nextReduceSupply;  // next DRSCoin reduction supply\n', '\n', '    address public owner;\n', '\n', '    mapping(address => bool) restrictedAddresses;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    mapping(address => uint32) public lastRefundMonth;\n', '\n', '    mapping(address => uint256) public refundEth;  //record the user profit\n', '\n', '    mapping(uint32 => MonthInfo) monthInfos;\n', '\n', '    mapping(address => bool) allowedGameAddress;\n', '\n', '    mapping(address => uint256) proposedGames;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Mint(address indexed _to, uint256 _value);\n', '\n', '    // event Info(uint256 _value);\n', '\n', '    /* This notifies clients about the amount burnt */\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    event Profit(address indexed from, uint256 year, uint256 month, uint256 value);\n', '\n', '    event Withdraw(address indexed from, uint256 value);\n', '\n', '    modifier onlyOwner {\n', '        assert(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowedGameAddress {\n', '        require(allowedGameAddress[msg.sender], "only allowed games permit to call");\n', '        _;\n', '    }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    constructor() public\n', '    {\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '        decimals = decimalUnits;                            // Amount of decimals for display purposes\n', '\n', '        tokenReduceAmount = tokenReduceValue.mul(uint256(10) ** uint256(decimals));\n', '        tokenExchangeRate = tokenExchangeInitRate;          // Set initial token exchange rate\n', '        nextReduceSupply = tokenReduceAmount;               // Set next token reduction supply\n', '\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // _startMonth included\n', '    // _nowMonth excluded\n', '    function settleEth(address _addr, uint32 _startMonth, uint32 _nowMonth) internal {\n', '        require(_nowMonth >= _startMonth);\n', '\n', '        // _startMonth == 0 means new address\n', '        if(_startMonth == 0) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        if(_nowMonth == _startMonth) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        uint256 _balance = balanceOf[_addr];\n', '        if(_balance == 0) {\n', '            lastRefundMonth[_addr] = _nowMonth;\n', '            return;\n', '        }\n', '\n', '        uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _balance);\n', '        refundEth[_addr] = refundEth[_addr].add(_unpaidPerfit);\n', '\n', '        lastRefundMonth[_addr] = _nowMonth;\n', '        return;\n', '    }\n', '\n', '    function getCurrentMonth() internal view returns(uint32) {\n', '        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\n', '        return _year * 12 + _month - 1;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool success) {\n', '        require(_value > 0);\n', '        require(balanceOf[msg.sender] >= _value);              // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows\n', '        require(!restrictedAddresses[msg.sender]);\n', '        require(!restrictedAddresses[_to]);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', "        // settle msg.sender's eth\n", '        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\n', '\n', "        // settle _to's eth\n", '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        // transfer token\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                 // Add the same to the recipient\n', '        emit Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool success) {\n', '        allowance[msg.sender][_spender] = _value;                 // Set allowance\n', '        emit Approval(msg.sender, _spender, _value);              // Raise Approval event\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        require(balanceOf[_from] >= _value);                  // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);   // Check for overflows\n', '        require(_value <= allowance[_from][msg.sender]);      // Check allowance\n', '        require(!restrictedAddresses[_from]);\n', '        require(!restrictedAddresses[msg.sender]);\n', '        require(!restrictedAddresses[_to]);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', "        // settle _from's eth\n", '        settleEth(_from, lastRefundMonth[_from], _nowMonth);\n', '\n', "        // settle _to's eth\n", '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        // transfer token\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);        // Add the same to the recipient\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function getUnpaidPerfit(uint32 _startMonth, uint32 _endMonth, uint256 _tokenAmount) internal view returns(uint256)\n', '    {\n', '        require(_startMonth > 0);\n', '        require(_endMonth >= _startMonth);\n', '\n', '        if(_startMonth == _endMonth) {\n', '            return 0;\n', '        }\n', '\n', '        if(_tokenAmount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _profit = 0;\n', '\n', '        uint256 _income;\n', '        uint256 _totalSupply;\n', '        for(uint32 j = _startMonth; j < _endMonth; j++) {\n', '            _income = monthInfos[j].ethIncome;\n', '            _totalSupply = monthInfos[j].totalTokenSupply;\n', '            if(_income > 0 && _totalSupply > 0) {\n', '                _profit = _profit.add(_income.mul(_tokenAmount).div(_totalSupply));\n', '            }\n', '        }\n', '\n', '        return _profit;\n', '    }\n', '\n', '    function totalSupply() constant public returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function tokenExchangeRate() constant public returns(uint256) {\n', '        return tokenExchangeRate;\n', '    }\n', '\n', '    function nextReduceSupply() constant public returns(uint256) {\n', '        return nextReduceSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns(uint256) {\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns(uint256) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    /* Owner can add new restricted address or removes one */\n', '    function editRestrictedAddress(address _newRestrictedAddress) public onlyOwner {\n', '        restrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];\n', '    }\n', '\n', '    function isRestrictedAddress(address _querryAddress) constant public returns(bool) {\n', '        return restrictedAddresses[_querryAddress];\n', '    }\n', '\n', '    function getMintAmount(uint256 _eth) private view returns(uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) {\n', '        _nextReduceSupply = nextReduceSupply;\n', '        _tokenExchangeRate = tokenExchangeRate;\n', '\n', '        _amount = 0;\n', '        uint256 _part = _nextReduceSupply.sub(totalSupply);  // calculate how many DRSCoin can mint in this period\n', '        while(_part <= _eth.mul(_tokenExchangeRate)) {\n', '            _eth = _eth.sub(_part.div(_tokenExchangeRate));  // sub eth amount\n', '            _amount = _amount.add(_part);                    // add DRSCoin mint in this small part\n', '\n', '            _part = tokenReduceAmount;\n', '            _nextReduceSupply = _nextReduceSupply.add(tokenReduceAmount);\n', '\n', '            if(_tokenExchangeRate > tokenExchangeLeastRate) {\n', '                _tokenExchangeRate = _tokenExchangeRate.mul(coinReduceRate).div(100);\n', '                if(_tokenExchangeRate < tokenExchangeLeastRate) {\n', '                    _tokenExchangeRate = tokenExchangeLeastRate;\n', '                }\n', '            }\n', '        }\n', '\n', '        _amount = _amount.add(_eth.mul(_tokenExchangeRate));\n', '\n', '        return (_amount, _nextReduceSupply, _tokenExchangeRate);\n', '    }\n', '\n', '    function mint(address _to, uint256 _eth) external onlyAllowedGameAddress {\n', '        require(_eth > 0);\n', '\n', '        (uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) = getMintAmount(_eth);\n', '\n', '        require(_amount > 0);\n', '        require(totalSupply + _amount > totalSupply);\n', '        require(balanceOf[_to] + _amount > balanceOf[_to]);     // Check for overflows\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', "        // settle _to's eth\n", '        settleEth(_to, lastRefundMonth[_to], _nowMonth);\n', '\n', '        totalSupply = _amount.add(totalSupply);                 // Update total supply\n', '        balanceOf[_to] = _amount.add(balanceOf[_to]);           // Set minted coins to target\n', '\n', "        // add current month's totalTokenSupply\n", '        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '\n', '        if(_nextReduceSupply != nextReduceSupply) {\n', '            nextReduceSupply = _nextReduceSupply;\n', '        }\n', '        if(_tokenExchangeRate != tokenExchangeRate) {\n', '            tokenExchangeRate = _tokenExchangeRate;\n', '        }\n', '\n', '        emit Mint(_to, _amount);                                // Create Mint event\n', '        emit Transfer(0x0, _to, _amount);                       // Create Transfer event from 0x\n', '    }\n', '\n', '    function burn(uint256 _value) public returns(bool success) {\n', '        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough\n', '        require(_value > 0);\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', "        // settle msg.sender's eth\n", '        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender\n', '        totalSupply = totalSupply.sub(_value);                                // Updates totalSupply\n', '\n', "        // update current month's totalTokenSupply\n", '        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function addGame(address gameAddress) public onlyOwner {\n', '        require(!allowedGameAddress[gameAddress], "game already in allow list");\n', '        require(proposedGames[gameAddress] > 0, "game must be in proposed list first");\n', '        require(now > proposedGames[gameAddress].add(proposingPeriod), "game must be debated for 2 days");\n', '\n', '        // add gameAddress to allowedGameAddress\n', '        allowedGameAddress[gameAddress] = true;\n', '\n', '        // delete gameAddress from proposedGames\n', '        proposedGames[gameAddress] = 0;\n', '    }\n', '\n', '    function proposeGame(address gameAddress) public onlyOwner {\n', '        require(!allowedGameAddress[gameAddress], "game already in allow list");\n', '        require(proposedGames[gameAddress] == 0, "game already in proposed list");\n', '\n', '        // add gameAddress to proposedGames\n', '        proposedGames[gameAddress] = now;\n', '    }\n', '\n', '    function deleteGame (address gameAddress) public onlyOwner {\n', '        require(allowedGameAddress[gameAddress] || proposedGames[gameAddress] > 0, "game must in allow list or proposed list");\n', '\n', '        // delete gameAddress from allowedGameAddress\n', '        allowedGameAddress[gameAddress] = false;\n', '\n', '        // delete gameAddress from proposedGames\n', '        proposedGames[gameAddress] = 0;\n', '    }\n', '\n', '    function gameCountdown(address gameAddress) public view returns(uint256) {\n', '        require(proposedGames[gameAddress] > 0, "game not in proposed list");\n', '\n', '        uint256 proposedTime = proposedGames[gameAddress];\n', '\n', '        if(now < proposedTime.add(proposingPeriod)) {\n', '            return proposedTime.add(proposingPeriod).sub(now);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function profitEth() external payable onlyAllowedGameAddress {\n', '        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\n', '        uint32 _nowMonth = _year * 12 + _month - 1;\n', '\n', '        uint256 _ethIncome = monthInfos[_nowMonth].ethIncome.add(msg.value);\n', '\n', '        monthInfos[_nowMonth].ethIncome = _ethIncome;\n', '\n', '        if(monthInfos[_nowMonth].totalTokenSupply == 0) {\n', '            monthInfos[_nowMonth].totalTokenSupply = totalSupply;\n', '        }\n', '\n', '        emit Profit(msg.sender, _year, _month, _ethIncome);\n', '    }\n', '\n', '    function withdraw() public {\n', '        require(!restrictedAddresses[msg.sender]);  // check if msg.sender is restricted\n', '\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        uint32 _startMonth = lastRefundMonth[msg.sender];\n', '        require(_startMonth > 0);\n', '\n', '        settleEth(msg.sender, _startMonth, _nowMonth);\n', '\n', '        uint256 _profit = refundEth[msg.sender];\n', '        require(_profit > 0);\n', '\n', '        refundEth[msg.sender] = 0;\n', '        msg.sender.transfer(_profit);\n', '\n', '        emit Withdraw(msg.sender, _profit);\n', '    }\n', '\n', '    function getEthPerfit(address _addr) public view returns(uint256) {\n', '        uint32 _nowMonth = getCurrentMonth();\n', '\n', '        uint32 _startMonth = lastRefundMonth[_addr];\n', '        // new user\n', '        if(_startMonth == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _tokenAmount = balanceOf[_addr];\n', '\n', '        uint256 _perfit = refundEth[_addr];\n', '\n', '        if(_startMonth < _nowMonth && _tokenAmount > 0) {\n', '            uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _tokenAmount);\n', '            _perfit = _perfit.add(_unpaidPerfit);\n', '        }\n', '\n', '        return _perfit;\n', '    }\n', '}\n', '\n', '// contract DRSCoinTestContract {\n', '//     DRSCoinInterface public drsCoin;\n', '\n', '//     constructor(address _drsCoin) public {\n', '//         drsCoin = DRSCoinInterface(_drsCoin);\n', '//     }\n', '\n', '//     function mintDRSCoin(address _addr, uint256 _amount) public {\n', '//         drsCoin.mint(_addr, _amount);\n', '//     }\n', '// }']
