['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupply;\n', '\n', '  mapping(address => uint256) balances;\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /**\n', '   * @dev Gets the balance of the specified address.\n', '   * @param _owner The address to query the the balance of.\n', '   * @return An uint256 representing the amount owned by the passed address.\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * Internal transfer, only can be called by this contract\n', '   */\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '    require(_value > 0);\n', '    require(balances[_from] >= _value);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '  \n', '  /**\n', '   * @dev transfer token for a specified address\n', '   * @param _to The address to transfer to.\n', '   * @param _value The amount to be transferred.\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    _transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require (_value <= allowed[_from][msg.sender]);\n', '\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    _transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract SEXNToken is StandardToken, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "SexChain";\n', '  string public constant symbol = "SEXN";\n', '  uint8 public constant decimals = 18;\n', '\n', '  struct lockInfo {\n', '    uint256 amount;            // Total number of token locks\n', '    uint256 start;             // The time when the lock was started.\n', '    uint256 transfered;        // The number of tokens that have been unlocked.\n', '    uint256 duration;          // The lock time for each cycle.\n', '    uint256 releaseCount;      // locking cycle.\n', '  }\n', '\n', '  mapping(address => lockInfo) internal _lockInfo;\n', '  // Query locked balance\n', '  mapping(address => uint256) internal _lockupBalances;\n', '\n', '  bool public preSaleFinished = false;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive) \n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // how many token units a buyer gets per wei\n', '  uint256 public rate;\n', '\n', '  //The number of locks for each round of presale. eg: 5 is 5 days\n', '  uint256 public lockCycle;\n', '\n', '  // The length of one lock cycle, \n', '  uint256 public constant DURATION = 24 * 3600;  // a day\n', '\n', '  /* The maximum amount of single users for pre-sales in the first period is 20,000. */\n', '  uint256 public constant CAT_FIRST = 20000 * (10 ** 18);\n', '\n', '  enum PresaleAction {\n', '    Ready,\n', '    FirstPresaleActivity,\n', '    SecondPresaleActivity,\n', '    ThirdPresaleActivity,\n', '    END\n', '  }\n', '\n', '  PresaleAction public saleAction = PresaleAction.Ready;\n', '\n', '\n', '  address private PRESALE_ADDRESS = 0xFD8C2759Fcf6E0BB57128d5dFCf1747AE9C7e3a1;         // Presale         \n', '  address private FOUNDATION_ADDRESS = 0x096D756888F725ab56eA5bD2002102d10271BEc3;      // Community rewards \n', '  address private COMMERCIAL_PLAN_ADDRESS = 0x51bE0d2Ed867cB68450Bee2Fcbf11a5960843bbd; // commercial plan  \n', '  address private POS_ADDRESS = 0x17c5fD5915DfaDe37EC0C04f1D70Ee495d6957af;             // DPOS                     \n', '  address private TEAM_ADDRESS = 0xE38e1dB1fD7915D2ed877E8cE53697E57EC2417e;            // Technical team   \n', '  address private COMMUNITY_TEAM_ADDRESS = 0xa34C472688D92511beb8fCDA42269a0526CfCCf0;  // community team   \n', '\n', '  address public wallet = 0xDcE9E02972fDfEd54F4b307C75bd0755067cBc90;\n', '\n', '\n', '  /////////////////\n', '  /// Event\n', '  /////////////////\n', '\n', '  event UnLock(address indexed beneficiary, uint256 amount);\n', '  event SellTokens(address indexed recipient, uint256 sellTokens, uint256 rate);\n', '\n', '  /////////////////\n', '  /// Modifier\n', '  /////////////////\n', '\n', '  /* check presale is active */\n', '  modifier beginSaleActive() {\n', '    require(now >= startTime && now <= endTime);\n', '    _;\n', '  }\n', '\n', '  /* check presale is not active */\n', '  modifier notpreSaleActive() {\n', '    require(now <= startTime || now >= endTime);\n', '    _;\n', '  }\n', '\n', '  /* For security reasons, need to change the wallet address */\n', '  function changeWallet(address _newWallet) public {\n', '      require(_newWallet != address(0x0));\n', '      require(msg.sender == wallet);\n', '      \n', '      wallet = _newWallet;\n', '  }\n', '\n', '  /* Query the number of tokens for which an address is locked. */\n', '  function getLockBalance(address _owner) public view returns(uint256){\n', '    return _lockupBalances[_owner];\n', '  }\n', '\n', '  /* Check the remaining quantity of presale in this round. */\n', '  function getRemainingPreSalesAmount() public view returns(uint256){\n', '    return balances[PRESALE_ADDRESS];\n', '  }\n', '\n', '  /*Gets the unlocked time of the specified address. */\n', '  function getLockTime(address _owner) public view returns(uint256){\n', '    // start + ( lockCycle * duration )\n', '    return _lockInfo[_owner].start.add(\n', '        _lockInfo[_owner].releaseCount.mul(_lockInfo[_owner].duration));\n', '  }\n', '\n', '  /**\n', '   * @dev Set the time and amount of presale for each period.\n', '   * @param _round uint8  The number of presale activities\n', '   * @param _startTime uint256  The current round of presales begins.\n', '   * @param _stopTime uint256  The end of the round of presales.\n', '   * @param _rate uint256   How many token units a buyer gets per wei.\n', '   * @param _amount uint256  The number of presale tokens.\n', '   */\n', '  function setSaleInfo(uint8 _round ,uint256 _startTime, uint256 _stopTime, uint256 _rate, uint256 _amount) external notpreSaleActive onlyOwner {\n', '    require(_round == 1 || _round == 2 || _round == 3);\n', '    require(_startTime < _stopTime);\n', '    require(_rate != 0 && _amount >= 0);\n', '    require(_startTime > now); \n', '    require(!preSaleFinished);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].add(_amount);\n', '\n', '    startTime = _startTime;\n', '    endTime = _stopTime;\n', '    rate = _rate;\n', '    _caluLocktime(_round);\n', '  }\n', '\n', '  function _caluLocktime(uint8 _round) internal {\n', '    require(_round == 1 || _round == 2 || _round == 3);\n', '    if (_round == 1 ){\n', '      saleAction = PresaleAction.FirstPresaleActivity;\n', '      lockCycle = 200;        // 200 days\n', '    }\n', '\n', '    if (_round == 2){\n', '      saleAction = PresaleAction.SecondPresaleActivity;\n', '      lockCycle = 150;        // 150 days\n', '    }\n', '\n', '    if (_round == 3){\n', '      saleAction = PresaleAction.ThirdPresaleActivity;\n', '      lockCycle = 120;        // 120 days\n', '    }\n', '  }\n', '\n', '\n', '  /* End the setup of presale activities. */\n', '  function closeSale() public onlyOwner notpreSaleActive {\n', '    preSaleFinished = true;\n', '    saleAction = PresaleAction.END;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Distribute tokens from presale address to an address.\n', '   * @param _to address  The address which you want to distribute to\n', '   * @param _amount uint256  The amount of tokens to be distributed\n', '   * @param _lockCycle uint256  Token locking cycle.\n', '   * @param _duration uint256  The lock time for each cycle.\n', '   */\n', '  function _distribute(address _to, uint256 _amount, uint256 _lockCycle, uint256 _duration) internal returns(bool)  {\n', '    ////Do not allow multiple distributions of the same address. Avoid locking time reset.\n', '    require(_lockInfo[_to].amount == 0 );\n', '    require(_lockupBalances[_to] == 0);\n', '\n', '    _lockInfo[_to].amount = _amount;\n', '    _lockInfo[_to].releaseCount = _lockCycle;\n', '    _lockInfo[_to].start = now;\n', '    _lockInfo[_to].transfered = 0;\n', '    _lockInfo[_to].duration = _duration;\n', '    \n', '    //Easy to query locked balance\n', '    _lockupBalances[_to] = _amount;\n', '\n', '    return true;\n', '  }\n', '\n', '  /* Distribute tokens from presale address to an address. */\n', '  function distribute(address _to, uint256 _amount) public onlyOwner beginSaleActive {\n', '    require(_to != 0x0);\n', '    require(_amount != 0);\n', '    \n', '    _distribute(_to, _amount,lockCycle, DURATION);\n', '    \n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(_amount);\n', '    emit Transfer(PRESALE_ADDRESS, _to, _amount);\n', '  }\n', '\n', '\n', '  /* Calculate the unlockable balance */\n', '  function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){\n', '    lockInfo storage userLockInfo = _lockInfo[_owner]; \n', '    if (userLockInfo.transfered == userLockInfo.amount){\n', '      return 0;\n', '    }\n', '\n', '    // Unlockable tokens per cycle.\n', '    uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); //amount/cnt\n', '    // Total unlockable balance.\n', '    uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration));\n', '\n', '    if (amount > userLockInfo.amount){\n', '      amount = userLockInfo.amount;\n', '    }\n', '    // \n', '    amount = amount.sub(userLockInfo.transfered);\n', '\n', '    return amount;\n', '  }\n', '\n', '\n', '  /* Unlock locked tokens */\n', '  function relaseLock() internal returns(uint256){\n', '    uint256 amount = _releasableAmount(msg.sender, now);\n', '    if (amount > 0){\n', '      _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount);\n', '      balances[msg.sender] = balances[msg.sender].add(amount);\n', '      _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount);\n', '      emit UnLock(msg.sender, amount);\n', '    }\n', '    return 0;\n', '  }\n', '\n', '\n', '  function _initialize() internal {\n', '\n', '    uint256 PRESALE_SUPPLY = totalSupply.mul(20).div(100);          // 20% for presale\n', '    uint256 DPOS_SUPPLY = totalSupply.mul(30).div(100);             // 30% for DPOS\n', '    uint256 COMMUNITY_REWARDS_SUPPLY = totalSupply.mul(20).div(100);// 20% for community rewards\n', '    uint256 COMMUNITY_TEAM_SUPPLY = totalSupply.mul(10).div(100);   // 10% for community team\n', '    uint256 COMMERCIAL_PLAN_SUPPLY = totalSupply * 10 / 100;        // 10% for commercial plan\n', '    uint256 TEAM_SUPPLY = totalSupply.mul(10).div(100);             // 10% for technical team \n', '\n', '    balances[msg.sender] = PRESALE_SUPPLY;\n', '    balances[FOUNDATION_ADDRESS] = COMMUNITY_REWARDS_SUPPLY;\n', '    balances[POS_ADDRESS] = DPOS_SUPPLY;\n', '    balances[COMMERCIAL_PLAN_ADDRESS] = COMMERCIAL_PLAN_SUPPLY;\n', '\n', '    //This part of the token locks for one year。\n', '    _distribute(COMMUNITY_TEAM_ADDRESS, COMMUNITY_TEAM_SUPPLY, 1, 365 days);\n', '\n', '    //This part of the token is locked until August 1, divided into 2 phases to unlock.\n', '    _distribute(0x7C88a1EC1D25c232464549ea9eF72B9bDc2a010A, TEAM_SUPPLY.mul(20).div(100), 2, 70 days); //0801\n', '\n', '    // This part of the token locks for one year。\n', '    _distribute(TEAM_ADDRESS, TEAM_SUPPLY.mul(80).div(100), 1, 365 days);\n', '\n', '  }\n', '\n', '\n', '\n', '  function SEXNToken() public {\n', '    totalSupply = 580000000 * (10 ** 18); // 580 million\n', '    _initialize();\n', '  }\n', '\n', '\n', '  /**\n', '   * Fallback function\n', '   * \n', '   * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '   * sell tokens automatic\n', '   */\n', '  function () external payable beginSaleActive {\n', '      sellTokens();\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sell tokens to msg.sender\n', '   *\n', '   */\n', '  function sellTokens() public payable beginSaleActive {\n', '    require(msg.value > 0);\n', '\n', '    uint256 amount = msg.value;\n', '    uint256 tokens = amount.mul(rate);\n', '\n', '    // check there are tokens for sale;\n', '    require(tokens <= balances[PRESALE_ADDRESS]);\n', '\n', '    if (saleAction == PresaleAction.FirstPresaleActivity){\n', '      // The maximum amount of single users for presales in the first period is 20,000.\n', '      require (tokens <= CAT_FIRST);\n', '    }\n', '\n', '    // send tokens to buyer\n', '    _distribute(msg.sender, tokens, lockCycle, DURATION);\n', '\n', '    \n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(tokens);\n', '\n', '    emit Transfer(PRESALE_ADDRESS, msg.sender, tokens);\n', '    emit SellTokens(msg.sender, tokens, rate);\n', '\n', '    forwardFunds();\n', '  }\n', '\n', '\n', '  // send ether to the fund collection wallet\n', '  // override to create custom fund forwarding mechanisms\n', '  function forwardFunds() internal {\n', '      wallet.transfer(msg.value);\n', '  }\n', '\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner].add(_lockupBalances[_owner]);\n', '  }\n', '\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    if (_lockupBalances[msg.sender] > 0){\n', '      relaseLock();\n', '    }\n', '\n', '    return  super.transfer( _to, _value);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupply;\n', '\n', '  mapping(address => uint256) balances;\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /**\n', '   * @dev Gets the balance of the specified address.\n', '   * @param _owner The address to query the the balance of.\n', '   * @return An uint256 representing the amount owned by the passed address.\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * Internal transfer, only can be called by this contract\n', '   */\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '    require(_value > 0);\n', '    require(balances[_from] >= _value);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '  \n', '  /**\n', '   * @dev transfer token for a specified address\n', '   * @param _to The address to transfer to.\n', '   * @param _value The amount to be transferred.\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    _transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require (_value <= allowed[_from][msg.sender]);\n', '\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    _transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract SEXNToken is StandardToken, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "SexChain";\n', '  string public constant symbol = "SEXN";\n', '  uint8 public constant decimals = 18;\n', '\n', '  struct lockInfo {\n', '    uint256 amount;            // Total number of token locks\n', '    uint256 start;             // The time when the lock was started.\n', '    uint256 transfered;        // The number of tokens that have been unlocked.\n', '    uint256 duration;          // The lock time for each cycle.\n', '    uint256 releaseCount;      // locking cycle.\n', '  }\n', '\n', '  mapping(address => lockInfo) internal _lockInfo;\n', '  // Query locked balance\n', '  mapping(address => uint256) internal _lockupBalances;\n', '\n', '  bool public preSaleFinished = false;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive) \n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // how many token units a buyer gets per wei\n', '  uint256 public rate;\n', '\n', '  //The number of locks for each round of presale. eg: 5 is 5 days\n', '  uint256 public lockCycle;\n', '\n', '  // The length of one lock cycle, \n', '  uint256 public constant DURATION = 24 * 3600;  // a day\n', '\n', '  /* The maximum amount of single users for pre-sales in the first period is 20,000. */\n', '  uint256 public constant CAT_FIRST = 20000 * (10 ** 18);\n', '\n', '  enum PresaleAction {\n', '    Ready,\n', '    FirstPresaleActivity,\n', '    SecondPresaleActivity,\n', '    ThirdPresaleActivity,\n', '    END\n', '  }\n', '\n', '  PresaleAction public saleAction = PresaleAction.Ready;\n', '\n', '\n', '  address private PRESALE_ADDRESS = 0xFD8C2759Fcf6E0BB57128d5dFCf1747AE9C7e3a1;         // Presale         \n', '  address private FOUNDATION_ADDRESS = 0x096D756888F725ab56eA5bD2002102d10271BEc3;      // Community rewards \n', '  address private COMMERCIAL_PLAN_ADDRESS = 0x51bE0d2Ed867cB68450Bee2Fcbf11a5960843bbd; // commercial plan  \n', '  address private POS_ADDRESS = 0x17c5fD5915DfaDe37EC0C04f1D70Ee495d6957af;             // DPOS                     \n', '  address private TEAM_ADDRESS = 0xE38e1dB1fD7915D2ed877E8cE53697E57EC2417e;            // Technical team   \n', '  address private COMMUNITY_TEAM_ADDRESS = 0xa34C472688D92511beb8fCDA42269a0526CfCCf0;  // community team   \n', '\n', '  address public wallet = 0xDcE9E02972fDfEd54F4b307C75bd0755067cBc90;\n', '\n', '\n', '  /////////////////\n', '  /// Event\n', '  /////////////////\n', '\n', '  event UnLock(address indexed beneficiary, uint256 amount);\n', '  event SellTokens(address indexed recipient, uint256 sellTokens, uint256 rate);\n', '\n', '  /////////////////\n', '  /// Modifier\n', '  /////////////////\n', '\n', '  /* check presale is active */\n', '  modifier beginSaleActive() {\n', '    require(now >= startTime && now <= endTime);\n', '    _;\n', '  }\n', '\n', '  /* check presale is not active */\n', '  modifier notpreSaleActive() {\n', '    require(now <= startTime || now >= endTime);\n', '    _;\n', '  }\n', '\n', '  /* For security reasons, need to change the wallet address */\n', '  function changeWallet(address _newWallet) public {\n', '      require(_newWallet != address(0x0));\n', '      require(msg.sender == wallet);\n', '      \n', '      wallet = _newWallet;\n', '  }\n', '\n', '  /* Query the number of tokens for which an address is locked. */\n', '  function getLockBalance(address _owner) public view returns(uint256){\n', '    return _lockupBalances[_owner];\n', '  }\n', '\n', '  /* Check the remaining quantity of presale in this round. */\n', '  function getRemainingPreSalesAmount() public view returns(uint256){\n', '    return balances[PRESALE_ADDRESS];\n', '  }\n', '\n', '  /*Gets the unlocked time of the specified address. */\n', '  function getLockTime(address _owner) public view returns(uint256){\n', '    // start + ( lockCycle * duration )\n', '    return _lockInfo[_owner].start.add(\n', '        _lockInfo[_owner].releaseCount.mul(_lockInfo[_owner].duration));\n', '  }\n', '\n', '  /**\n', '   * @dev Set the time and amount of presale for each period.\n', '   * @param _round uint8  The number of presale activities\n', '   * @param _startTime uint256  The current round of presales begins.\n', '   * @param _stopTime uint256  The end of the round of presales.\n', '   * @param _rate uint256   How many token units a buyer gets per wei.\n', '   * @param _amount uint256  The number of presale tokens.\n', '   */\n', '  function setSaleInfo(uint8 _round ,uint256 _startTime, uint256 _stopTime, uint256 _rate, uint256 _amount) external notpreSaleActive onlyOwner {\n', '    require(_round == 1 || _round == 2 || _round == 3);\n', '    require(_startTime < _stopTime);\n', '    require(_rate != 0 && _amount >= 0);\n', '    require(_startTime > now); \n', '    require(!preSaleFinished);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].add(_amount);\n', '\n', '    startTime = _startTime;\n', '    endTime = _stopTime;\n', '    rate = _rate;\n', '    _caluLocktime(_round);\n', '  }\n', '\n', '  function _caluLocktime(uint8 _round) internal {\n', '    require(_round == 1 || _round == 2 || _round == 3);\n', '    if (_round == 1 ){\n', '      saleAction = PresaleAction.FirstPresaleActivity;\n', '      lockCycle = 200;        // 200 days\n', '    }\n', '\n', '    if (_round == 2){\n', '      saleAction = PresaleAction.SecondPresaleActivity;\n', '      lockCycle = 150;        // 150 days\n', '    }\n', '\n', '    if (_round == 3){\n', '      saleAction = PresaleAction.ThirdPresaleActivity;\n', '      lockCycle = 120;        // 120 days\n', '    }\n', '  }\n', '\n', '\n', '  /* End the setup of presale activities. */\n', '  function closeSale() public onlyOwner notpreSaleActive {\n', '    preSaleFinished = true;\n', '    saleAction = PresaleAction.END;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Distribute tokens from presale address to an address.\n', '   * @param _to address  The address which you want to distribute to\n', '   * @param _amount uint256  The amount of tokens to be distributed\n', '   * @param _lockCycle uint256  Token locking cycle.\n', '   * @param _duration uint256  The lock time for each cycle.\n', '   */\n', '  function _distribute(address _to, uint256 _amount, uint256 _lockCycle, uint256 _duration) internal returns(bool)  {\n', '    ////Do not allow multiple distributions of the same address. Avoid locking time reset.\n', '    require(_lockInfo[_to].amount == 0 );\n', '    require(_lockupBalances[_to] == 0);\n', '\n', '    _lockInfo[_to].amount = _amount;\n', '    _lockInfo[_to].releaseCount = _lockCycle;\n', '    _lockInfo[_to].start = now;\n', '    _lockInfo[_to].transfered = 0;\n', '    _lockInfo[_to].duration = _duration;\n', '    \n', '    //Easy to query locked balance\n', '    _lockupBalances[_to] = _amount;\n', '\n', '    return true;\n', '  }\n', '\n', '  /* Distribute tokens from presale address to an address. */\n', '  function distribute(address _to, uint256 _amount) public onlyOwner beginSaleActive {\n', '    require(_to != 0x0);\n', '    require(_amount != 0);\n', '    \n', '    _distribute(_to, _amount,lockCycle, DURATION);\n', '    \n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(_amount);\n', '    emit Transfer(PRESALE_ADDRESS, _to, _amount);\n', '  }\n', '\n', '\n', '  /* Calculate the unlockable balance */\n', '  function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){\n', '    lockInfo storage userLockInfo = _lockInfo[_owner]; \n', '    if (userLockInfo.transfered == userLockInfo.amount){\n', '      return 0;\n', '    }\n', '\n', '    // Unlockable tokens per cycle.\n', '    uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); //amount/cnt\n', '    // Total unlockable balance.\n', '    uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration));\n', '\n', '    if (amount > userLockInfo.amount){\n', '      amount = userLockInfo.amount;\n', '    }\n', '    // \n', '    amount = amount.sub(userLockInfo.transfered);\n', '\n', '    return amount;\n', '  }\n', '\n', '\n', '  /* Unlock locked tokens */\n', '  function relaseLock() internal returns(uint256){\n', '    uint256 amount = _releasableAmount(msg.sender, now);\n', '    if (amount > 0){\n', '      _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount);\n', '      balances[msg.sender] = balances[msg.sender].add(amount);\n', '      _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount);\n', '      emit UnLock(msg.sender, amount);\n', '    }\n', '    return 0;\n', '  }\n', '\n', '\n', '  function _initialize() internal {\n', '\n', '    uint256 PRESALE_SUPPLY = totalSupply.mul(20).div(100);          // 20% for presale\n', '    uint256 DPOS_SUPPLY = totalSupply.mul(30).div(100);             // 30% for DPOS\n', '    uint256 COMMUNITY_REWARDS_SUPPLY = totalSupply.mul(20).div(100);// 20% for community rewards\n', '    uint256 COMMUNITY_TEAM_SUPPLY = totalSupply.mul(10).div(100);   // 10% for community team\n', '    uint256 COMMERCIAL_PLAN_SUPPLY = totalSupply * 10 / 100;        // 10% for commercial plan\n', '    uint256 TEAM_SUPPLY = totalSupply.mul(10).div(100);             // 10% for technical team \n', '\n', '    balances[msg.sender] = PRESALE_SUPPLY;\n', '    balances[FOUNDATION_ADDRESS] = COMMUNITY_REWARDS_SUPPLY;\n', '    balances[POS_ADDRESS] = DPOS_SUPPLY;\n', '    balances[COMMERCIAL_PLAN_ADDRESS] = COMMERCIAL_PLAN_SUPPLY;\n', '\n', '    //This part of the token locks for one year。\n', '    _distribute(COMMUNITY_TEAM_ADDRESS, COMMUNITY_TEAM_SUPPLY, 1, 365 days);\n', '\n', '    //This part of the token is locked until August 1, divided into 2 phases to unlock.\n', '    _distribute(0x7C88a1EC1D25c232464549ea9eF72B9bDc2a010A, TEAM_SUPPLY.mul(20).div(100), 2, 70 days); //0801\n', '\n', '    // This part of the token locks for one year。\n', '    _distribute(TEAM_ADDRESS, TEAM_SUPPLY.mul(80).div(100), 1, 365 days);\n', '\n', '  }\n', '\n', '\n', '\n', '  function SEXNToken() public {\n', '    totalSupply = 580000000 * (10 ** 18); // 580 million\n', '    _initialize();\n', '  }\n', '\n', '\n', '  /**\n', '   * Fallback function\n', '   * \n', '   * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '   * sell tokens automatic\n', '   */\n', '  function () external payable beginSaleActive {\n', '      sellTokens();\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sell tokens to msg.sender\n', '   *\n', '   */\n', '  function sellTokens() public payable beginSaleActive {\n', '    require(msg.value > 0);\n', '\n', '    uint256 amount = msg.value;\n', '    uint256 tokens = amount.mul(rate);\n', '\n', '    // check there are tokens for sale;\n', '    require(tokens <= balances[PRESALE_ADDRESS]);\n', '\n', '    if (saleAction == PresaleAction.FirstPresaleActivity){\n', '      // The maximum amount of single users for presales in the first period is 20,000.\n', '      require (tokens <= CAT_FIRST);\n', '    }\n', '\n', '    // send tokens to buyer\n', '    _distribute(msg.sender, tokens, lockCycle, DURATION);\n', '\n', '    \n', '    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(tokens);\n', '\n', '    emit Transfer(PRESALE_ADDRESS, msg.sender, tokens);\n', '    emit SellTokens(msg.sender, tokens, rate);\n', '\n', '    forwardFunds();\n', '  }\n', '\n', '\n', '  // send ether to the fund collection wallet\n', '  // override to create custom fund forwarding mechanisms\n', '  function forwardFunds() internal {\n', '      wallet.transfer(msg.value);\n', '  }\n', '\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner].add(_lockupBalances[_owner]);\n', '  }\n', '\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    if (_lockupBalances[msg.sender] > 0){\n', '      relaseLock();\n', '    }\n', '\n', '    return  super.transfer( _to, _value);\n', '  }\n', '\n', '}']
