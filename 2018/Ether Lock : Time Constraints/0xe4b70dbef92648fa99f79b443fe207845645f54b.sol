['pragma solidity ^0.4.24;\n', '\n', '// SafeMath library\n', 'library SafeMath {\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\tuint256 c = _a + _b;\n', '\t\tassert(c >= _a);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\tassert(_a >= _b);\n', '\t\treturn _a - _b;\n', '\t}\n', '\n', '\tfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    if (_a == 0) {\n', '     return 0;\n', '    }\n', '\t\tuint256 c = _a * _b;\n', '\t\tassert(c / _a == _b);\n', '\t\treturn c;\n', '\t}\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\treturn _a / _b;\n', '\t}\n', '}\n', '\n', '// Contract must have an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "onlyOwner wrong");\n', '    _;\n', '  }\n', '\n', '  function setOwner(address _owner) onlyOwner public {\n', '    owner = _owner;\n', '  }\n', '}\n', '\n', 'interface WTAGameBook {\n', '  function getPlayerIdByAddress(address _addr) external view returns (uint256);\n', '  function getPlayerAddressById(uint256 _id) external view returns (address);\n', '  function getPlayerRefById(uint256 _id) external view returns (uint256);\n', '  function getGameIdByAddress(address _addr) external view returns (uint256);\n', '  function getGameAddressById(uint256 _id) external view returns (address);\n', '  function isAdmin(address _addr) external view returns (bool);\n', '}\n', '\n', 'interface WTAGameRun {\n', '  function getCurrentRoundStartTime() external view returns (uint256);\n', '  function getCurrentRoundEndTime() external view returns (uint256);\n', '  function getCurrentRoundWinner() external view returns (uint256);\n', '}\n', '\n', 'interface ERC20Token {\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function balanceOf(address _addr) external view returns (uint256);\n', '  function decimals() external view returns (uint8);\n', '}\n', '\n', '// The WTA Token Pool that stores and handles token information\n', 'contract WTATokenPool is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 constant private DAY_IN_SECONDS = 86400;\n', '  string public name = "WTATokenPool V0.5";\n', '  string public version = "0.5";\n', '\n', '  // various token related stuff\n', '  struct TokenInfo {\n', '    ERC20Token token;\n', '    address addr;\n', '    uint8 decimals;\n', '    address payaddr;\n', '    uint256 bought;\n', '    uint256 safed;\n', '    uint256 potted;\n', '    uint256 price;\n', '    uint256 buypercent;\n', '    uint256 potpercent;\n', '    uint256 lockperiod;\n', '    uint256 tid;\n', '    bool active;\n', '  }\n', '\n', '  // Player&#39;s time-locked safe to store tokens\n', '  struct PlayerSafe {\n', '    mapping (uint256 => uint256) lockValue;\n', '    mapping (uint256 => uint256) lockTime;\n', '    uint256 locks;\n', '    uint256 withdraws;\n', '    uint256 withdrawn;\n', '  }\n', '\n', '  uint256 public tokenNum = 0;\n', '  mapping (uint256 => TokenInfo) public tokenPool;\n', '  mapping (address => bool) public tokenInPool;\n', '\n', '  mapping (uint256 => mapping(uint256 => PlayerSafe)) public playerSafes;\n', '  WTAGameBook public gamebook;\n', '\n', '  event TokenBought(uint256 _tid, uint256 _pid, uint256 _amount);\n', '  event TokenLocked(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _locktime);\n', '  event TokenFundPaid(uint256 _tid, address indexed _paddr, uint256 _value);\n', '  event TokenPotFunded(uint256 _tid, uint256 _amount);\n', '  event TokenPotWon(uint256 _tid, uint256 _pid, uint256 _amount);\n', '  event TokenWithdrawn(uint256 _tid, uint256 _pid, uint256 _amount);\n', '\n', '  event InactiveTokenEmptied(uint256 _tid, address indexed _addr, uint256 _amount);\n', '  event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount);\n', '  event WrongEtherEmptied(address indexed _addr, uint256 _amount);\n', '\n', '  // initial tokens\n', '  // IMPORTANT: price needs to be in Wei per 1 unit of token\n', '  // IMPORTANT: percent needs to be in %\n', '  // _tokenAddress: list of token addresses need to be added to the pool at contract creation\n', '  // _payAddress: list of token owner addresses which receives the payments\n', '  // _price: list of token prices\n', '  // _buypercent: list of how much token needs to be allocated to players relative to the listed buying price, in percentage form, for example 200 means 200%\n', '  // _potpercent: list of how much token needs to be allocated to the pot relative to the listed buying price, in percentage form, for example 40 means 40%\n', '  // _lockperiod: list of timelock periods for tokens allocated to the players before they can withdraw them, in seconds\n', '  // _gamebook: the address of the GameBook contract\n', '  constructor(address[] _tokenAddress, address[] _payAddress, uint256[] _price, uint256[] _buypercent, uint256[] _potpercent, uint256[] _lockperiod, address _gamebook) public {\n', '    require((_tokenAddress.length == _payAddress.length) && (_payAddress.length == _price.length) && (_price.length == _buypercent.length) && (_buypercent.length == _potpercent.length), "TokenPool constructor wrong");\n', '    tokenNum = _tokenAddress.length;\n', '    for (uint256 i = 0; i < tokenNum; i++) {\n', '      tokenPool[i].token = ERC20Token(_tokenAddress[i]);\n', '      tokenPool[i].addr = _tokenAddress[i];\n', '      tokenPool[i].decimals = tokenPool[i].token.decimals();\n', '      tokenPool[i].payaddr = _payAddress[i];\n', '      tokenPool[i].bought = 0;\n', '      tokenPool[i].safed = 0;\n', '      tokenPool[i].potted = 0;\n', '      tokenPool[i].price = _price[i];\n', '      tokenPool[i].buypercent = _buypercent[i];\n', '      tokenPool[i].potpercent = _potpercent[i];\n', '      tokenPool[i].lockperiod = _lockperiod[i];\n', '      tokenPool[i].tid = i;\n', '      tokenPool[i].active = true;\n', '      tokenInPool[_tokenAddress[i]] = true;\n', '    }\n', '    gamebook = WTAGameBook(_gamebook);\n', '  }\n', '\n', '  modifier isAdmin() {\n', '    require(gamebook.isAdmin(msg.sender), "isAdmin wrong");\n', '    _;\n', '  }\n', '\n', '  modifier isGame() {\n', '    require(gamebook.getGameIdByAddress(msg.sender) > 0, "isGame wrong");\n', '    _;\n', '  }\n', '\n', '  modifier isPaid() {\n', '    // paymnent must be greater than 1GWei and less than 100k ETH\n', '    require((msg.value > 1000000000) && (msg.value < 100000000000000000000000), "isPaid wrong");\n', '    _;\n', '  }\n', '\n', '  // admins may set a token to be active or inactive in the games\n', '  function setTokenActive(uint256 _tid, bool _active) isAdmin public {\n', '    require(_tid < tokenNum, "setTokenActive wrong");\n', '    tokenPool[_tid].active = _active;\n', '  }\n', '\n', '  // IMPORTANT: price needs to be in Wei per 1 unit of token\n', '  // admins may add new tokens into the pool\n', '  function addToken(address _tokenAddress, address _payAddress, uint256 _price, uint256 _buypercent, uint256 _potpercent, uint256 _lockperiod) isAdmin public {\n', '    tokenPool[tokenNum].token = ERC20Token(_tokenAddress);\n', '    tokenPool[tokenNum].addr = _tokenAddress;\n', '    tokenPool[tokenNum].decimals = tokenPool[tokenNum].token.decimals();\n', '    tokenPool[tokenNum].payaddr = _payAddress;\n', '    tokenPool[tokenNum].bought = 0;\n', '    tokenPool[tokenNum].safed = 0;\n', '    tokenPool[tokenNum].potted = 0;\n', '    tokenPool[tokenNum].price = _price;\n', '    tokenPool[tokenNum].buypercent = _buypercent;\n', '    tokenPool[tokenNum].potpercent = _potpercent;\n', '    tokenPool[tokenNum].lockperiod = _lockperiod;\n', '    tokenPool[tokenNum].tid = tokenNum;\n', '    tokenPool[tokenNum].active = true;\n', '    tokenInPool[_tokenAddress] = true;\n', '    tokenNum++;\n', '  }\n', '\n', '  function tokenBalance(uint256 _tid) public view returns (uint256 _balance) {\n', '    return tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted);\n', '  }\n', '\n', '  function tokenBuyable(uint256 _tid, uint256 _eth) public view returns (bool _buyable) {\n', '    if (!tokenPool[_tid].active) return false;\n', '    uint256 buyAmount = (_eth).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    uint256 potAmount = (_eth).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    return (tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount));\n', '  }\n', '\n', '  // Handles the buying of Tokens\n', '  function buyToken(uint256 _tid, uint256 _pid) isGame isPaid public payable {\n', '    require(gamebook.getPlayerAddressById(_pid) != address(0x0), "buyToken need valid player");\n', '    require(_tid < tokenNum, "buyToken need valid token");\n', '    require(tokenPool[_tid].active, "buyToken need active token");\n', '\n', '    uint256 buyAmount = (msg.value).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    uint256 potAmount = (msg.value).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    require(tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount), "buyToken need more balance");\n', '\n', '    tokenPool[_tid].bought = tokenPool[_tid].bought.add(buyAmount);\n', '    tokenPool[_tid].safed = tokenPool[_tid].safed.add(buyAmount);\n', '    tokenPool[_tid].potted = tokenPool[_tid].potted.add(potAmount);\n', '\n', '    emit TokenBought(_tid, _pid, buyAmount);\n', '    emit TokenPotFunded(_tid, potAmount);\n', '\n', '    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\n', '    tokenSafeLock(_tid, _pid, buyAmount, lockStartTime);\n', '\n', '    tokenPool[_tid].payaddr.transfer(msg.value);\n', '\n', '    emit TokenFundPaid(_tid, tokenPool[_tid].payaddr, msg.value);\n', '  }\n', '\n', '  // handling the Pot Winning\n', '  function winPot(uint256[] _tids) isGame public {\n', '    require(now > WTAGameRun(msg.sender).getCurrentRoundEndTime(), "winPot need round end");\n', '    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\n', '    uint256 winnerId = WTAGameRun(msg.sender).getCurrentRoundWinner();\n', '    require(gamebook.getPlayerAddressById(winnerId) != address(0x0), "winPot need valid player");\n', '    for (uint256 i = 0; i< _tids.length; i++) {\n', '      uint256 tid = _tids[i];\n', '      if (tokenPool[tid].active) {\n', '        uint256 potAmount = tokenPool[tid].potted;\n', '        tokenPool[tid].potted = 0;\n', '        tokenPool[tid].safed = tokenPool[tid].safed.add(potAmount);\n', '\n', '        tokenSafeLock(tid, winnerId, potAmount, lockStartTime);\n', '\n', '        emit TokenPotWon(tid, winnerId, potAmount);\n', '      }\n', '    }\n', '  }\n', '\n', '  // lock the Tokens allocated to players with a timelock\n', '  function tokenSafeLock(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _start) private {\n', '    uint256 lockTime = _start + tokenPool[_tid].lockperiod;\n', '    uint256 lockNum = playerSafes[_pid][_tid].locks;\n', '    uint256 withdrawNum = playerSafes[_pid][_tid].withdraws;\n', '\n', '    if (lockNum > 0 && lockNum > withdrawNum) {\n', '      if (playerSafes[_pid][_tid].lockTime[lockNum-1] == lockTime) {\n', '        playerSafes[_pid][_tid].lockValue[lockNum-1] = playerSafes[_pid][_tid].lockValue[lockNum-1].add(_amount);\n', '      } else {\n', '        playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\n', '        playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\n', '        playerSafes[_pid][_tid].locks++;\n', '      }\n', '    } else {\n', '      playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\n', '      playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\n', '      playerSafes[_pid][_tid].locks++;\n', '    }\n', '\n', '    emit TokenLocked(_tid, _pid, _amount, lockTime);\n', '  }\n', '\n', '  // show a player&#39;s allocated tokens\n', '  function showPlayerSafeByAddress(address _addr, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\n', '    uint256 pid = gamebook.getPlayerIdByAddress(_addr);\n', '    require(pid > 0, "showPlayerSafeByAddress wrong");\n', '    return showPlayerSafeById(pid, _tid);\n', '  }\n', '\n', '  function showPlayerSafeById(uint256 _pid, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\n', '    require(gamebook.getPlayerAddressById(_pid) != address(0x0), "showPlayerSafeById need valid player");\n', '    require(_tid < tokenNum, "showPlayerSafeById need valid token");\n', '    uint256 locked = 0;\n', '    uint256 unlocked = 0;\n', '    uint256 withdrawable = 0;\n', '    uint256 withdraws = playerSafes[_pid][_tid].withdraws;\n', '    uint256 locks = playerSafes[_pid][_tid].locks;\n', '    uint256 count = 0;\n', '    for (uint256 i = withdraws; i < locks; i++) {\n', '      if (playerSafes[_pid][_tid].lockTime[i] < now) {\n', '        unlocked = unlocked.add(playerSafes[_pid][_tid].lockValue[i]);\n', '        if (count < 50) withdrawable = withdrawable.add(playerSafes[_pid][_tid].lockValue[i]);\n', '      } else {\n', '        locked = locked.add(playerSafes[_pid][_tid].lockValue[i]);\n', '      }\n', '      count++;\n', '    }\n', '    return (locked, unlocked, withdrawable);\n', '  }\n', '\n', '  // player may withdraw tokens after the timelock period\n', '  function withdraw(uint256 _tid) public {\n', '    require(_tid < tokenNum, "withdraw need valid token");\n', '    uint256 pid = gamebook.getPlayerIdByAddress(msg.sender);\n', '    require(pid > 0, "withdraw need valid player");\n', '    uint256 withdrawable = 0;\n', '    uint256 i = playerSafes[pid][_tid].withdraws;\n', '    uint256 count = 0;\n', '    uint256 locks = playerSafes[pid][_tid].locks;\n', '    for (; (i < locks) && (count < 50); i++) {\n', '      if (playerSafes[pid][_tid].lockTime[i] < now) {\n', '        withdrawable = withdrawable.add(playerSafes[pid][_tid].lockValue[i]);\n', '        playerSafes[pid][_tid].withdraws = i + 1;\n', '      } else {\n', '        break;\n', '      }\n', '      count++;\n', '    }\n', '\n', '    assert((tokenPool[_tid].token.balanceOf(address(this)) >= withdrawable) && (tokenPool[_tid].safed >= withdrawable));\n', '    tokenPool[_tid].safed = tokenPool[_tid].safed.sub(withdrawable);\n', '    playerSafes[pid][_tid].withdrawn = playerSafes[pid][_tid].withdrawn.add(withdrawable);\n', '    require(tokenPool[_tid].token.transfer(msg.sender, withdrawable), "withdraw transfer wrong");\n', '\n', '    emit TokenWithdrawn(_tid, pid, withdrawable);\n', '  }\n', '\n', '  // Safety measures\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  function emptyInactiveToken(uint256 _tid) isAdmin public {\n', '    require(_tid < tokenNum, "emptyInactiveToken need valid token");\n', '    require(tokenPool[_tid].active == false, "emptyInactiveToken need token inactive");\n', '    uint256 amount = tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed);\n', '    tokenPool[_tid].potted = 0;\n', '    require(tokenPool[_tid].token.transfer(msg.sender, amount), "emptyInactiveToken transfer wrong");\n', '\n', '    emit InactiveTokenEmptied(_tid, msg.sender, amount);\n', '  }\n', '\n', '  function emptyWrongToken(address _addr) isAdmin public {\n', '    require(tokenInPool[_addr] == false, "emptyWrongToken need wrong token");\n', '    ERC20Token wrongToken = ERC20Token(_addr);\n', '    uint256 amount = wrongToken.balanceOf(address(this));\n', '    require(amount > 0, "emptyWrongToken need more balance");\n', '    require(wrongToken.transfer(msg.sender, amount), "emptyWrongToken transfer wrong");\n', '\n', '    emit WrongTokenEmptied(_addr, msg.sender, amount);\n', '  }\n', '\n', '  function emptyWrongEther() isAdmin public {\n', '    // require all tokens to be inactive before emptying ether\n', '    for (uint256 i=0; i < tokenNum; i++) {\n', '      require(tokenPool[i].active == false, "emptyWrongEther need all tokens inactive");\n', '    }\n', '    uint256 amount = address(this).balance;\n', '    require(amount > 0, "emptyWrongEther need more balance");\n', '    msg.sender.transfer(amount);\n', '\n', '    emit WrongEtherEmptied(msg.sender, amount);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// SafeMath library\n', 'library SafeMath {\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\tuint256 c = _a + _b;\n', '\t\tassert(c >= _a);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\tassert(_a >= _b);\n', '\t\treturn _a - _b;\n', '\t}\n', '\n', '\tfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    if (_a == 0) {\n', '     return 0;\n', '    }\n', '\t\tuint256 c = _a * _b;\n', '\t\tassert(c / _a == _b);\n', '\t\treturn c;\n', '\t}\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '\t\treturn _a / _b;\n', '\t}\n', '}\n', '\n', '// Contract must have an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "onlyOwner wrong");\n', '    _;\n', '  }\n', '\n', '  function setOwner(address _owner) onlyOwner public {\n', '    owner = _owner;\n', '  }\n', '}\n', '\n', 'interface WTAGameBook {\n', '  function getPlayerIdByAddress(address _addr) external view returns (uint256);\n', '  function getPlayerAddressById(uint256 _id) external view returns (address);\n', '  function getPlayerRefById(uint256 _id) external view returns (uint256);\n', '  function getGameIdByAddress(address _addr) external view returns (uint256);\n', '  function getGameAddressById(uint256 _id) external view returns (address);\n', '  function isAdmin(address _addr) external view returns (bool);\n', '}\n', '\n', 'interface WTAGameRun {\n', '  function getCurrentRoundStartTime() external view returns (uint256);\n', '  function getCurrentRoundEndTime() external view returns (uint256);\n', '  function getCurrentRoundWinner() external view returns (uint256);\n', '}\n', '\n', 'interface ERC20Token {\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function balanceOf(address _addr) external view returns (uint256);\n', '  function decimals() external view returns (uint8);\n', '}\n', '\n', '// The WTA Token Pool that stores and handles token information\n', 'contract WTATokenPool is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 constant private DAY_IN_SECONDS = 86400;\n', '  string public name = "WTATokenPool V0.5";\n', '  string public version = "0.5";\n', '\n', '  // various token related stuff\n', '  struct TokenInfo {\n', '    ERC20Token token;\n', '    address addr;\n', '    uint8 decimals;\n', '    address payaddr;\n', '    uint256 bought;\n', '    uint256 safed;\n', '    uint256 potted;\n', '    uint256 price;\n', '    uint256 buypercent;\n', '    uint256 potpercent;\n', '    uint256 lockperiod;\n', '    uint256 tid;\n', '    bool active;\n', '  }\n', '\n', "  // Player's time-locked safe to store tokens\n", '  struct PlayerSafe {\n', '    mapping (uint256 => uint256) lockValue;\n', '    mapping (uint256 => uint256) lockTime;\n', '    uint256 locks;\n', '    uint256 withdraws;\n', '    uint256 withdrawn;\n', '  }\n', '\n', '  uint256 public tokenNum = 0;\n', '  mapping (uint256 => TokenInfo) public tokenPool;\n', '  mapping (address => bool) public tokenInPool;\n', '\n', '  mapping (uint256 => mapping(uint256 => PlayerSafe)) public playerSafes;\n', '  WTAGameBook public gamebook;\n', '\n', '  event TokenBought(uint256 _tid, uint256 _pid, uint256 _amount);\n', '  event TokenLocked(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _locktime);\n', '  event TokenFundPaid(uint256 _tid, address indexed _paddr, uint256 _value);\n', '  event TokenPotFunded(uint256 _tid, uint256 _amount);\n', '  event TokenPotWon(uint256 _tid, uint256 _pid, uint256 _amount);\n', '  event TokenWithdrawn(uint256 _tid, uint256 _pid, uint256 _amount);\n', '\n', '  event InactiveTokenEmptied(uint256 _tid, address indexed _addr, uint256 _amount);\n', '  event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount);\n', '  event WrongEtherEmptied(address indexed _addr, uint256 _amount);\n', '\n', '  // initial tokens\n', '  // IMPORTANT: price needs to be in Wei per 1 unit of token\n', '  // IMPORTANT: percent needs to be in %\n', '  // _tokenAddress: list of token addresses need to be added to the pool at contract creation\n', '  // _payAddress: list of token owner addresses which receives the payments\n', '  // _price: list of token prices\n', '  // _buypercent: list of how much token needs to be allocated to players relative to the listed buying price, in percentage form, for example 200 means 200%\n', '  // _potpercent: list of how much token needs to be allocated to the pot relative to the listed buying price, in percentage form, for example 40 means 40%\n', '  // _lockperiod: list of timelock periods for tokens allocated to the players before they can withdraw them, in seconds\n', '  // _gamebook: the address of the GameBook contract\n', '  constructor(address[] _tokenAddress, address[] _payAddress, uint256[] _price, uint256[] _buypercent, uint256[] _potpercent, uint256[] _lockperiod, address _gamebook) public {\n', '    require((_tokenAddress.length == _payAddress.length) && (_payAddress.length == _price.length) && (_price.length == _buypercent.length) && (_buypercent.length == _potpercent.length), "TokenPool constructor wrong");\n', '    tokenNum = _tokenAddress.length;\n', '    for (uint256 i = 0; i < tokenNum; i++) {\n', '      tokenPool[i].token = ERC20Token(_tokenAddress[i]);\n', '      tokenPool[i].addr = _tokenAddress[i];\n', '      tokenPool[i].decimals = tokenPool[i].token.decimals();\n', '      tokenPool[i].payaddr = _payAddress[i];\n', '      tokenPool[i].bought = 0;\n', '      tokenPool[i].safed = 0;\n', '      tokenPool[i].potted = 0;\n', '      tokenPool[i].price = _price[i];\n', '      tokenPool[i].buypercent = _buypercent[i];\n', '      tokenPool[i].potpercent = _potpercent[i];\n', '      tokenPool[i].lockperiod = _lockperiod[i];\n', '      tokenPool[i].tid = i;\n', '      tokenPool[i].active = true;\n', '      tokenInPool[_tokenAddress[i]] = true;\n', '    }\n', '    gamebook = WTAGameBook(_gamebook);\n', '  }\n', '\n', '  modifier isAdmin() {\n', '    require(gamebook.isAdmin(msg.sender), "isAdmin wrong");\n', '    _;\n', '  }\n', '\n', '  modifier isGame() {\n', '    require(gamebook.getGameIdByAddress(msg.sender) > 0, "isGame wrong");\n', '    _;\n', '  }\n', '\n', '  modifier isPaid() {\n', '    // paymnent must be greater than 1GWei and less than 100k ETH\n', '    require((msg.value > 1000000000) && (msg.value < 100000000000000000000000), "isPaid wrong");\n', '    _;\n', '  }\n', '\n', '  // admins may set a token to be active or inactive in the games\n', '  function setTokenActive(uint256 _tid, bool _active) isAdmin public {\n', '    require(_tid < tokenNum, "setTokenActive wrong");\n', '    tokenPool[_tid].active = _active;\n', '  }\n', '\n', '  // IMPORTANT: price needs to be in Wei per 1 unit of token\n', '  // admins may add new tokens into the pool\n', '  function addToken(address _tokenAddress, address _payAddress, uint256 _price, uint256 _buypercent, uint256 _potpercent, uint256 _lockperiod) isAdmin public {\n', '    tokenPool[tokenNum].token = ERC20Token(_tokenAddress);\n', '    tokenPool[tokenNum].addr = _tokenAddress;\n', '    tokenPool[tokenNum].decimals = tokenPool[tokenNum].token.decimals();\n', '    tokenPool[tokenNum].payaddr = _payAddress;\n', '    tokenPool[tokenNum].bought = 0;\n', '    tokenPool[tokenNum].safed = 0;\n', '    tokenPool[tokenNum].potted = 0;\n', '    tokenPool[tokenNum].price = _price;\n', '    tokenPool[tokenNum].buypercent = _buypercent;\n', '    tokenPool[tokenNum].potpercent = _potpercent;\n', '    tokenPool[tokenNum].lockperiod = _lockperiod;\n', '    tokenPool[tokenNum].tid = tokenNum;\n', '    tokenPool[tokenNum].active = true;\n', '    tokenInPool[_tokenAddress] = true;\n', '    tokenNum++;\n', '  }\n', '\n', '  function tokenBalance(uint256 _tid) public view returns (uint256 _balance) {\n', '    return tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted);\n', '  }\n', '\n', '  function tokenBuyable(uint256 _tid, uint256 _eth) public view returns (bool _buyable) {\n', '    if (!tokenPool[_tid].active) return false;\n', '    uint256 buyAmount = (_eth).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    uint256 potAmount = (_eth).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    return (tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount));\n', '  }\n', '\n', '  // Handles the buying of Tokens\n', '  function buyToken(uint256 _tid, uint256 _pid) isGame isPaid public payable {\n', '    require(gamebook.getPlayerAddressById(_pid) != address(0x0), "buyToken need valid player");\n', '    require(_tid < tokenNum, "buyToken need valid token");\n', '    require(tokenPool[_tid].active, "buyToken need active token");\n', '\n', '    uint256 buyAmount = (msg.value).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    uint256 potAmount = (msg.value).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\n', '    require(tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount), "buyToken need more balance");\n', '\n', '    tokenPool[_tid].bought = tokenPool[_tid].bought.add(buyAmount);\n', '    tokenPool[_tid].safed = tokenPool[_tid].safed.add(buyAmount);\n', '    tokenPool[_tid].potted = tokenPool[_tid].potted.add(potAmount);\n', '\n', '    emit TokenBought(_tid, _pid, buyAmount);\n', '    emit TokenPotFunded(_tid, potAmount);\n', '\n', '    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\n', '    tokenSafeLock(_tid, _pid, buyAmount, lockStartTime);\n', '\n', '    tokenPool[_tid].payaddr.transfer(msg.value);\n', '\n', '    emit TokenFundPaid(_tid, tokenPool[_tid].payaddr, msg.value);\n', '  }\n', '\n', '  // handling the Pot Winning\n', '  function winPot(uint256[] _tids) isGame public {\n', '    require(now > WTAGameRun(msg.sender).getCurrentRoundEndTime(), "winPot need round end");\n', '    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\n', '    uint256 winnerId = WTAGameRun(msg.sender).getCurrentRoundWinner();\n', '    require(gamebook.getPlayerAddressById(winnerId) != address(0x0), "winPot need valid player");\n', '    for (uint256 i = 0; i< _tids.length; i++) {\n', '      uint256 tid = _tids[i];\n', '      if (tokenPool[tid].active) {\n', '        uint256 potAmount = tokenPool[tid].potted;\n', '        tokenPool[tid].potted = 0;\n', '        tokenPool[tid].safed = tokenPool[tid].safed.add(potAmount);\n', '\n', '        tokenSafeLock(tid, winnerId, potAmount, lockStartTime);\n', '\n', '        emit TokenPotWon(tid, winnerId, potAmount);\n', '      }\n', '    }\n', '  }\n', '\n', '  // lock the Tokens allocated to players with a timelock\n', '  function tokenSafeLock(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _start) private {\n', '    uint256 lockTime = _start + tokenPool[_tid].lockperiod;\n', '    uint256 lockNum = playerSafes[_pid][_tid].locks;\n', '    uint256 withdrawNum = playerSafes[_pid][_tid].withdraws;\n', '\n', '    if (lockNum > 0 && lockNum > withdrawNum) {\n', '      if (playerSafes[_pid][_tid].lockTime[lockNum-1] == lockTime) {\n', '        playerSafes[_pid][_tid].lockValue[lockNum-1] = playerSafes[_pid][_tid].lockValue[lockNum-1].add(_amount);\n', '      } else {\n', '        playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\n', '        playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\n', '        playerSafes[_pid][_tid].locks++;\n', '      }\n', '    } else {\n', '      playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\n', '      playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\n', '      playerSafes[_pid][_tid].locks++;\n', '    }\n', '\n', '    emit TokenLocked(_tid, _pid, _amount, lockTime);\n', '  }\n', '\n', "  // show a player's allocated tokens\n", '  function showPlayerSafeByAddress(address _addr, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\n', '    uint256 pid = gamebook.getPlayerIdByAddress(_addr);\n', '    require(pid > 0, "showPlayerSafeByAddress wrong");\n', '    return showPlayerSafeById(pid, _tid);\n', '  }\n', '\n', '  function showPlayerSafeById(uint256 _pid, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\n', '    require(gamebook.getPlayerAddressById(_pid) != address(0x0), "showPlayerSafeById need valid player");\n', '    require(_tid < tokenNum, "showPlayerSafeById need valid token");\n', '    uint256 locked = 0;\n', '    uint256 unlocked = 0;\n', '    uint256 withdrawable = 0;\n', '    uint256 withdraws = playerSafes[_pid][_tid].withdraws;\n', '    uint256 locks = playerSafes[_pid][_tid].locks;\n', '    uint256 count = 0;\n', '    for (uint256 i = withdraws; i < locks; i++) {\n', '      if (playerSafes[_pid][_tid].lockTime[i] < now) {\n', '        unlocked = unlocked.add(playerSafes[_pid][_tid].lockValue[i]);\n', '        if (count < 50) withdrawable = withdrawable.add(playerSafes[_pid][_tid].lockValue[i]);\n', '      } else {\n', '        locked = locked.add(playerSafes[_pid][_tid].lockValue[i]);\n', '      }\n', '      count++;\n', '    }\n', '    return (locked, unlocked, withdrawable);\n', '  }\n', '\n', '  // player may withdraw tokens after the timelock period\n', '  function withdraw(uint256 _tid) public {\n', '    require(_tid < tokenNum, "withdraw need valid token");\n', '    uint256 pid = gamebook.getPlayerIdByAddress(msg.sender);\n', '    require(pid > 0, "withdraw need valid player");\n', '    uint256 withdrawable = 0;\n', '    uint256 i = playerSafes[pid][_tid].withdraws;\n', '    uint256 count = 0;\n', '    uint256 locks = playerSafes[pid][_tid].locks;\n', '    for (; (i < locks) && (count < 50); i++) {\n', '      if (playerSafes[pid][_tid].lockTime[i] < now) {\n', '        withdrawable = withdrawable.add(playerSafes[pid][_tid].lockValue[i]);\n', '        playerSafes[pid][_tid].withdraws = i + 1;\n', '      } else {\n', '        break;\n', '      }\n', '      count++;\n', '    }\n', '\n', '    assert((tokenPool[_tid].token.balanceOf(address(this)) >= withdrawable) && (tokenPool[_tid].safed >= withdrawable));\n', '    tokenPool[_tid].safed = tokenPool[_tid].safed.sub(withdrawable);\n', '    playerSafes[pid][_tid].withdrawn = playerSafes[pid][_tid].withdrawn.add(withdrawable);\n', '    require(tokenPool[_tid].token.transfer(msg.sender, withdrawable), "withdraw transfer wrong");\n', '\n', '    emit TokenWithdrawn(_tid, pid, withdrawable);\n', '  }\n', '\n', '  // Safety measures\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  function emptyInactiveToken(uint256 _tid) isAdmin public {\n', '    require(_tid < tokenNum, "emptyInactiveToken need valid token");\n', '    require(tokenPool[_tid].active == false, "emptyInactiveToken need token inactive");\n', '    uint256 amount = tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed);\n', '    tokenPool[_tid].potted = 0;\n', '    require(tokenPool[_tid].token.transfer(msg.sender, amount), "emptyInactiveToken transfer wrong");\n', '\n', '    emit InactiveTokenEmptied(_tid, msg.sender, amount);\n', '  }\n', '\n', '  function emptyWrongToken(address _addr) isAdmin public {\n', '    require(tokenInPool[_addr] == false, "emptyWrongToken need wrong token");\n', '    ERC20Token wrongToken = ERC20Token(_addr);\n', '    uint256 amount = wrongToken.balanceOf(address(this));\n', '    require(amount > 0, "emptyWrongToken need more balance");\n', '    require(wrongToken.transfer(msg.sender, amount), "emptyWrongToken transfer wrong");\n', '\n', '    emit WrongTokenEmptied(_addr, msg.sender, amount);\n', '  }\n', '\n', '  function emptyWrongEther() isAdmin public {\n', '    // require all tokens to be inactive before emptying ether\n', '    for (uint256 i=0; i < tokenNum; i++) {\n', '      require(tokenPool[i].active == false, "emptyWrongEther need all tokens inactive");\n', '    }\n', '    uint256 amount = address(this).balance;\n', '    require(amount > 0, "emptyWrongEther need more balance");\n', '    msg.sender.transfer(amount);\n', '\n', '    emit WrongEtherEmptied(msg.sender, amount);\n', '  }\n', '\n', '}']
