['pragma solidity ^0.4.21;\n', '\n', 'contract ABXToken \n', '{\n', '  mapping(address => uint256) public balanceOf;\n', '  function transfer(address newTokensHolder, uint256 tokensNumber) \n', '    public \n', '    returns(bool);\n', '}\n', '\n', 'contract VestingContractABX\n', '{\n', '  //structures\n', '  struct AccountData\n', '  {\n', '    uint original_balance;\n', '    uint limit_per_period;\n', '    uint current_balance;\n', '    uint current_limit;\n', '    uint current_transferred;\n', '  }\n', '\n', '  //storage\n', '  address public owner;\n', '  ABXToken public abx_token;\n', '  mapping (address => AccountData) public account_data;\n', '  uint public current_period;\n', '  uint[] public periods;\n', '  address[] public accounts;\n', '\n', '  //modifiers\n', '  modifier onlyOwner\n', '  {\n', '    require(owner == msg.sender);\n', '    _;\n', '  }\n', '  \n', '  //Events\n', '  event Transfer(address indexed to, uint indexed value);\n', '  event OwnerTransfer(address indexed to, uint indexed value);\n', '  event OwnerChanged(address indexed owner);\n', '  event CurrentPeriodChanged(uint indexed current_period);\n', '\n', '  //functions\n', '\n', '  //debug functions\n', '  function setPeriod(uint i, uint v)\n', '    public\n', '  {\n', '    periods[i] = v;\n', '  }\n', '\n', '  //constructor\n', '  function VestingContractABX(ABXToken _abx_token)\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '    abx_token = _abx_token;\n', '    \n', '    periods.push(1524355200);  //2018-04-22\n', '    periods.push(1526947200);  //2018-05-22\n', '    periods.push(2**256 - 1);  //very far future\n', '    current_period = 0;\n', '    \n', '    initData(0xB99f9Ff7349A74f74Ee78bA76F692381925B4372, 192998805 * 10**16);\n', '    initData(0x6f15F81d3726dEc1c7D8db7c7C139de5B8a5DCdA, 50000 * 10**18);\n', '    initData(0x0339Db6d5827cFf0271a5bd3EEe991bE1DCe2AD9, 50000 * 10**18);\n', '    initData(0x4477A5b0Bd59E4661008D07938293e61A95cbC9D, 25725 * 10**18);\n', '    initData(0x1c8dBee998C6B905B46e517Cf5A6E935673b7c8F, 33650 * 10**18);\n', '    initData(0xF3E33Ee85414Cb9b2D1EcFf9508BD24285fD3194, 46350 * 10**18);\n', '    initData(0x70d370528cd58A2531Db49e477964D760cf9fE56, 413950 * 10**18);\n', '    initData(0xd2A64d99025b1b0B0Eb8C65d7a89AD6444842E60, 500000 * 10**18);\n', '    initData(0xf8767ced61c1f86f5572e64289247b1c86083ef1, 33333333 * 10**16);\n', '  }\n', '  \n', '  /// @dev Fallback function: don&#39;t accept ETH\n', '  function()\n', '    public\n', '    payable\n', '  {\n', '    revert();\n', '  }\n', '\n', '  /// @dev Get current balance of the contract\n', '  function getBalance()\n', '    constant\n', '    public\n', '    returns(uint)\n', '  {\n', '    return abx_token.balanceOf(this);\n', '  }\n', '\n', '  function initData(address a, uint v) \n', '    private\n', '  {\n', '    accounts.push(a);\n', '    account_data[a].original_balance = v;\n', '    account_data[a].current_balance = account_data[a].original_balance;\n', '    account_data[a].limit_per_period = account_data[a].original_balance / 3;\n', '    account_data[a].current_limit = account_data[a].limit_per_period;\n', '    account_data[a].current_transferred = 0;\n', '  }\n', '\n', '  function setOwner(address _owner) \n', '    public \n', '    onlyOwner \n', '  {\n', '    require(_owner != 0);\n', '    \n', '    owner = _owner;\n', '    emit OwnerChanged(owner);\n', '  }\n', '  \n', '  //allow owner to transfer surplus\n', '  function ownerTransfer(address to, uint value)\n', '    public\n', '    onlyOwner\n', '  {\n', '    uint current_balance_all = 0;\n', '    for (uint i = 0; i < accounts.length; i++)\n', '      current_balance_all += account_data[accounts[i]].current_balance;\n', '    require(getBalance() > current_balance_all && value <= getBalance() - current_balance_all);\n', '    if (abx_token.transfer(to, value))\n', '      emit OwnerTransfer(to, value);\n', '  }\n', '  \n', '  function updateCurrentPeriod()\n', '    public\n', '  {\n', '    require(account_data[msg.sender].original_balance > 0 || msg.sender == owner);\n', '    \n', '    uint new_period = current_period;\n', '    for (uint i = current_period; i < periods.length; i++)\n', '      if (periods[i] > now)\n', '      {\n', '        new_period = i;\n', '        break;\n', '      }\n', '    if (new_period != current_period)\n', '    {\n', '      current_period = new_period;\n', '      for (i = 0; i < accounts.length; i++)\n', '      {\n', '        account_data[accounts[i]].current_transferred = 0;\n', '        account_data[accounts[i]].current_limit = account_data[accounts[i]].limit_per_period;\n', '        if (current_period == periods.length - 1)\n', '          account_data[accounts[i]].current_limit = 2**256 - 1;  //unlimited\n', '      }\n', '      emit CurrentPeriodChanged(current_period);\n', '    }\n', '  }\n', '\n', '  function transfer(address to, uint value) \n', '    public\n', '  {\n', '    updateCurrentPeriod();\n', '    require(value <= abx_token.balanceOf(this) \n', '      && value <= account_data[msg.sender].current_balance \n', '      && account_data[msg.sender].current_transferred + value <= account_data[msg.sender].current_limit);\n', '\n', '    if (abx_token.transfer(to, value)) \n', '    {\n', '      account_data[msg.sender].current_transferred += value;\n', '      account_data[msg.sender].current_balance -= value;\n', '      emit Transfer(to, value);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract ABXToken \n', '{\n', '  mapping(address => uint256) public balanceOf;\n', '  function transfer(address newTokensHolder, uint256 tokensNumber) \n', '    public \n', '    returns(bool);\n', '}\n', '\n', 'contract VestingContractABX\n', '{\n', '  //structures\n', '  struct AccountData\n', '  {\n', '    uint original_balance;\n', '    uint limit_per_period;\n', '    uint current_balance;\n', '    uint current_limit;\n', '    uint current_transferred;\n', '  }\n', '\n', '  //storage\n', '  address public owner;\n', '  ABXToken public abx_token;\n', '  mapping (address => AccountData) public account_data;\n', '  uint public current_period;\n', '  uint[] public periods;\n', '  address[] public accounts;\n', '\n', '  //modifiers\n', '  modifier onlyOwner\n', '  {\n', '    require(owner == msg.sender);\n', '    _;\n', '  }\n', '  \n', '  //Events\n', '  event Transfer(address indexed to, uint indexed value);\n', '  event OwnerTransfer(address indexed to, uint indexed value);\n', '  event OwnerChanged(address indexed owner);\n', '  event CurrentPeriodChanged(uint indexed current_period);\n', '\n', '  //functions\n', '\n', '  //debug functions\n', '  function setPeriod(uint i, uint v)\n', '    public\n', '  {\n', '    periods[i] = v;\n', '  }\n', '\n', '  //constructor\n', '  function VestingContractABX(ABXToken _abx_token)\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '    abx_token = _abx_token;\n', '    \n', '    periods.push(1524355200);  //2018-04-22\n', '    periods.push(1526947200);  //2018-05-22\n', '    periods.push(2**256 - 1);  //very far future\n', '    current_period = 0;\n', '    \n', '    initData(0xB99f9Ff7349A74f74Ee78bA76F692381925B4372, 192998805 * 10**16);\n', '    initData(0x6f15F81d3726dEc1c7D8db7c7C139de5B8a5DCdA, 50000 * 10**18);\n', '    initData(0x0339Db6d5827cFf0271a5bd3EEe991bE1DCe2AD9, 50000 * 10**18);\n', '    initData(0x4477A5b0Bd59E4661008D07938293e61A95cbC9D, 25725 * 10**18);\n', '    initData(0x1c8dBee998C6B905B46e517Cf5A6E935673b7c8F, 33650 * 10**18);\n', '    initData(0xF3E33Ee85414Cb9b2D1EcFf9508BD24285fD3194, 46350 * 10**18);\n', '    initData(0x70d370528cd58A2531Db49e477964D760cf9fE56, 413950 * 10**18);\n', '    initData(0xd2A64d99025b1b0B0Eb8C65d7a89AD6444842E60, 500000 * 10**18);\n', '    initData(0xf8767ced61c1f86f5572e64289247b1c86083ef1, 33333333 * 10**16);\n', '  }\n', '  \n', "  /// @dev Fallback function: don't accept ETH\n", '  function()\n', '    public\n', '    payable\n', '  {\n', '    revert();\n', '  }\n', '\n', '  /// @dev Get current balance of the contract\n', '  function getBalance()\n', '    constant\n', '    public\n', '    returns(uint)\n', '  {\n', '    return abx_token.balanceOf(this);\n', '  }\n', '\n', '  function initData(address a, uint v) \n', '    private\n', '  {\n', '    accounts.push(a);\n', '    account_data[a].original_balance = v;\n', '    account_data[a].current_balance = account_data[a].original_balance;\n', '    account_data[a].limit_per_period = account_data[a].original_balance / 3;\n', '    account_data[a].current_limit = account_data[a].limit_per_period;\n', '    account_data[a].current_transferred = 0;\n', '  }\n', '\n', '  function setOwner(address _owner) \n', '    public \n', '    onlyOwner \n', '  {\n', '    require(_owner != 0);\n', '    \n', '    owner = _owner;\n', '    emit OwnerChanged(owner);\n', '  }\n', '  \n', '  //allow owner to transfer surplus\n', '  function ownerTransfer(address to, uint value)\n', '    public\n', '    onlyOwner\n', '  {\n', '    uint current_balance_all = 0;\n', '    for (uint i = 0; i < accounts.length; i++)\n', '      current_balance_all += account_data[accounts[i]].current_balance;\n', '    require(getBalance() > current_balance_all && value <= getBalance() - current_balance_all);\n', '    if (abx_token.transfer(to, value))\n', '      emit OwnerTransfer(to, value);\n', '  }\n', '  \n', '  function updateCurrentPeriod()\n', '    public\n', '  {\n', '    require(account_data[msg.sender].original_balance > 0 || msg.sender == owner);\n', '    \n', '    uint new_period = current_period;\n', '    for (uint i = current_period; i < periods.length; i++)\n', '      if (periods[i] > now)\n', '      {\n', '        new_period = i;\n', '        break;\n', '      }\n', '    if (new_period != current_period)\n', '    {\n', '      current_period = new_period;\n', '      for (i = 0; i < accounts.length; i++)\n', '      {\n', '        account_data[accounts[i]].current_transferred = 0;\n', '        account_data[accounts[i]].current_limit = account_data[accounts[i]].limit_per_period;\n', '        if (current_period == periods.length - 1)\n', '          account_data[accounts[i]].current_limit = 2**256 - 1;  //unlimited\n', '      }\n', '      emit CurrentPeriodChanged(current_period);\n', '    }\n', '  }\n', '\n', '  function transfer(address to, uint value) \n', '    public\n', '  {\n', '    updateCurrentPeriod();\n', '    require(value <= abx_token.balanceOf(this) \n', '      && value <= account_data[msg.sender].current_balance \n', '      && account_data[msg.sender].current_transferred + value <= account_data[msg.sender].current_limit);\n', '\n', '    if (abx_token.transfer(to, value)) \n', '    {\n', '      account_data[msg.sender].current_transferred += value;\n', '      account_data[msg.sender].current_balance -= value;\n', '      emit Transfer(to, value);\n', '    }\n', '  }\n', '}']
