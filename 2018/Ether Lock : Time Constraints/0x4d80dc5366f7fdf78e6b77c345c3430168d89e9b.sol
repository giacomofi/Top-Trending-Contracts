['pragma solidity ^0.4.25;\n', '\n', '\n', 'contract Ownable \n', '{\n', '    address public owner;\n', '    address public newOwner;\n', '    \n', '    constructor() public \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner, "Can used only by owner");\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public \n', '    {\n', '        require(_owner != 0, "Please provide new owner address");\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public \n', '    {\n', '        require(newOwner == msg.sender, "Please call from new owner");\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath \n', '{\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) \n', '    {\n', '        if (_a == 0) { return 0; }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) \n', '    {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) \n', '    {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) \n', '    {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract KassaNetwork is Ownable \n', '{\n', '    using SafeMath for uint;\n', '\n', "    string  public constant name    = 'Kassa 200/100';\n", '    uint public startTimestamp = now;\n', '\n', '    uint public constant procKoef = 10000;\n', '    uint public constant perDay = 100;\n', '    uint public constant ownerFee = 400;\n', '    uint[4] public bonusReferrer = [600, 200, 100, 50];\n', '\n', '    uint public constant procReturn = 9000;\n', '\n', '\n', '    uint public constant maxDepositDays = 200;\n', '\n', '\n', '    uint public constant minimalDeposit = 0.5 ether;\n', '    uint public constant maximalDepositStart = 20 ether;\n', '\n', '    uint public constant minimalDepositForBonusReferrer = 0.015 ether;\n', '\n', '\n', '    uint public constant dayLimitStart = 50 ether;\n', '\n', '\n', '    uint public constant progressProcKoef = 100;\n', '    uint public constant dayLimitProgressProc = 2;\n', '    uint public constant maxDepositProgressProc = 1;\n', '\n', '\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPenalty = 0;\n', '    uint public totalSelfInvest = 0;\n', '    uint public totalPaid = 0;\n', '\n', '    event LogInvestment(address _addr, uint _value, bytes _refData);\n', '    event LogTransfer(address _addr, uint _amount, uint _contactBalance);\n', '    event LogSelfInvestment(uint _value);\n', '\n', '    event LogPreparePayment(address _addr, uint _totalInteres, uint _paidInteres, uint _amount);\n', '    event LogSkipPreparePayment(address _addr, uint _totalInteres, uint _paidInteres);\n', '\n', '    event LogPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals, uint _amount);\n', '    event LogSkipPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals);\n', '\n', '    event LogMinimalDepositPayment(address _addr, uint _money, uint _totalPenalty);\n', '    event LogPenaltyPayment(address _addr, uint currentSenderDeposit, uint referrerAdressLength, address _referrer, uint currentReferrerDeposit, uint _money, uint _sendBackAmount, uint _totalPenalty);\n', '    event LogExceededRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _badDeposit, uint _sendBackAmount, uint _totalPenalty, uint _willDeposit);\n', '\n', '    event LogUsedRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _realDeposit, uint _usedDepositPerDay);\n', '    event LogCalcBonusReferrer(address _referrer, uint _money, uint _index, uint _bonusReferrer, uint _amountReferrer, address _nextReferrer);\n', '\n', '\n', '    struct User\n', '    {\n', '        uint balance;\n', '        uint paidInteres;\n', '        uint timestamp;\n', '        uint countReferrals;\n', '        uint earnOnReferrals;\n', '        uint paidReferrals;\n', '        address referrer;\n', '    }\n', '\n', '    mapping (address => User) private user;\n', '\n', '    mapping (uint => uint) private usedDeposit;\n', '\n', '    function getInteres(address addr) private view returns(uint interes) \n', '    {\n', '        uint diffDays = getNDay(user[addr].timestamp);\n', '\n', '        if( diffDays > maxDepositDays ) diffDays = maxDepositDays;\n', '\n', '        interes = user[addr].balance.mul(perDay).mul(diffDays).div(procKoef);\n', '    }\n', '\n', '    function getUser(address addr) public view returns(uint balance, uint timestamp, uint paidInteres, uint totalInteres, uint countReferrals, uint earnOnReferrals, uint paidReferrals, address referrer) \n', '    {\n', '        address a = addr;\n', '        return (\n', '            user[a].balance,\n', '            user[a].timestamp,\n', '            user[a].paidInteres,\n', '            getInteres(a),\n', '            user[a].countReferrals,\n', '            user[a].earnOnReferrals,\n', '            user[a].paidReferrals,\n', '            user[a].referrer\n', '        );\n', '    }\n', '\n', '    function getCurrentDay() public view returns(uint nday) \n', '    {\n', '        nday = getNDay(startTimestamp);\n', '    }\n', '\n', '    function getNDay(uint date) public view returns(uint nday) \n', '    {\n', '        uint diffTime = date > 0 ? now.sub(date) : 0;\n', '\n', '        nday = diffTime.div(24 hours);\n', '    }\n', '\n', '    function getCurrentDayDepositLimit() public view returns(uint limit) \n', '    {\n', '        uint nDay = getCurrentDay();\n', '\n', '        limit = getDayDepositLimit(nDay);\n', '    }\n', '\n', '\n', '    function calcProgress(uint start, uint proc, uint nDay) public pure returns(uint res) \n', '    {\n', '        uint s = start;\n', '\n', '        for (uint i = 0; i < nDay; i++)\n', '        {\n', '            s = s.mul(progressProcKoef + proc).div(progressProcKoef);\n', '        }\n', '\n', '        return s;\n', '    }\n', '\n', '    function getDayDepositLimit(uint nDay) public pure returns(uint limit) \n', '    {                         \n', '        return calcProgress(dayLimitStart, dayLimitProgressProc, nDay );\n', '    }\n', '\n', '    function getMaximalDeposit(uint nDay) public pure returns(uint limit) \n', '    {                 \n', '        return calcProgress(maximalDepositStart, maxDepositProgressProc, nDay );\n', '    }\n', '\n', '    function getCurrentDayRestDepositLimit() public view returns(uint restLimit) \n', '    {\n', '        uint nDay = getCurrentDay();\n', '\n', '        restLimit = getDayRestDepositLimit(nDay);\n', '    }\n', '\n', '    function getDayRestDepositLimit(uint nDay) public view returns(uint restLimit) \n', '    {\n', '        restLimit = getCurrentDayDepositLimit().sub(usedDeposit[nDay]);\n', '    }\n', '\n', '\n', '    function getCurrentMaximalDeposit() public view returns(uint maximalDeposit) \n', '    {\n', '        uint nDay = getCurrentDay();\n', '\n', '        maximalDeposit = getMaximalDeposit(nDay);\n', '    }\n', '\n', '\n', '    function() external payable \n', '    {\n', '        emit LogInvestment(msg.sender, msg.value, msg.data);\n', '        processPayment(msg.value, msg.data);\n', '    }\n', '\n', '    function processPayment(uint moneyValue, bytes refData) private\n', '    {\n', '        if (msg.sender == owner) \n', '        { \n', '            totalSelfInvest = totalSelfInvest.add(moneyValue);\n', '            emit LogSelfInvestment(moneyValue);\n', '            return; \n', '        }\n', '\n', '        if (moneyValue == 0) \n', '        { \n', '            preparePayment();\n', '            return; \n', '        }\n', '\n', '        if (moneyValue < minimalDeposit) \n', '        { \n', '            totalPenalty = totalPenalty.add(moneyValue);\n', '            emit LogMinimalDepositPayment(msg.sender, moneyValue, totalPenalty);\n', '            return; \n', '        }\n', '\n', '        address referrer = bytesToAddress(refData);\n', '\n', '        if (user[msg.sender].balance > 0 || \n', '            refData.length != 20 || \n', '            moneyValue > getCurrentMaximalDeposit() ||\n', '            referrer != owner &&\n', '              (\n', '                 user[referrer].balance <= 0 || \n', '                 referrer == msg.sender) \n', '              )\n', '        { \n', '            uint amount = moneyValue.mul(procReturn).div(procKoef);\n', '\n', '            totalPenalty = totalPenalty.add(moneyValue.sub(amount));\n', '\n', '            emit LogPenaltyPayment(msg.sender, user[msg.sender].balance, refData.length, referrer, user[referrer].balance, moneyValue, amount, totalPenalty);\n', '\n', '            msg.sender.transfer(amount);\n', '\n', '            return; \n', '        }\n', '\n', '\n', '\n', '        uint nDay = getCurrentDay();\n', '\n', '        uint restDepositPerDay = getDayRestDepositLimit(nDay);\n', '\n', '        uint addDeposit = moneyValue;\n', '\n', '\n', '        if (moneyValue > restDepositPerDay)\n', '        {\n', '            uint returnDeposit = moneyValue.sub(restDepositPerDay);\n', '\n', '            uint returnAmount = returnDeposit.mul(procReturn).div(procKoef);\n', '\n', '            addDeposit = addDeposit.sub(returnDeposit);\n', '\n', '            totalPenalty = totalPenalty.add(returnDeposit.sub(returnAmount));\n', '\n', '            emit LogExceededRestDepositPerDay(msg.sender, referrer, moneyValue, nDay, restDepositPerDay, returnDeposit, returnAmount, totalPenalty, addDeposit);\n', '\n', '            msg.sender.transfer(returnAmount);\n', '        }\n', '\n', '        usedDeposit[nDay] = usedDeposit[nDay].add(addDeposit);\n', '\n', '        emit LogUsedRestDepositPerDay(msg.sender, referrer, moneyValue, nDay, restDepositPerDay, addDeposit, usedDeposit[nDay]);\n', '\n', '\n', '        registerInvestor(referrer);\n', '        sendOwnerFee(addDeposit);\n', '        calcBonusReferrers(referrer, addDeposit);\n', '        updateInvestBalance(addDeposit);\n', '    }\n', '\n', '\n', '    function registerInvestor(address referrer) private \n', '    {\n', '        user[msg.sender].timestamp = now;\n', '        countInvestors++;\n', '\n', '        user[msg.sender].referrer = referrer;\n', '        user[referrer].countReferrals++;\n', '    }\n', '\n', '    function sendOwnerFee(uint addDeposit) private \n', '    {\n', '        transfer(owner, addDeposit.mul(ownerFee).div(procKoef));\n', '    }\n', '\n', '    function calcBonusReferrers(address referrer, uint addDeposit) private \n', '    {\n', '        for (uint i = 0; i < bonusReferrer.length && referrer != 0; i++)\n', '        {\n', '            uint amountReferrer = addDeposit.mul(bonusReferrer[i]).div(procKoef);\n', '\n', '            address nextReferrer = user[referrer].referrer;\n', '\n', '            emit LogCalcBonusReferrer(referrer, addDeposit, i, bonusReferrer[i], amountReferrer, nextReferrer);\n', '\n', '            preparePaymentReferrer(referrer, amountReferrer);\n', '\n', '            referrer = nextReferrer;\n', '        }\n', '    }\n', '\n', '\n', '    function preparePaymentReferrer(address referrer, uint amountReferrer) private \n', '    {\n', '        user[referrer].earnOnReferrals = user[referrer].earnOnReferrals.add(amountReferrer);\n', '\n', '        uint totalReferrals = user[referrer].earnOnReferrals;\n', '        uint paidReferrals = user[referrer].paidReferrals;\n', '\n', '\n', '        if (totalReferrals >= paidReferrals.add(minimalDepositForBonusReferrer)) \n', '        {\n', '            uint amount = totalReferrals.sub(paidReferrals);\n', '\n', '            user[referrer].paidReferrals = user[referrer].paidReferrals.add(amount);\n', '\n', '            emit LogPreparePaymentReferrer(referrer, totalReferrals, paidReferrals, amount);\n', '\n', '            transfer(referrer, amount);\n', '        }\n', '        else\n', '        {\n', '            emit LogSkipPreparePaymentReferrer(referrer, totalReferrals, paidReferrals);\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function preparePayment() public \n', '    {\n', '        uint totalInteres = getInteres(msg.sender);\n', '        uint paidInteres = user[msg.sender].paidInteres;\n', '        if (totalInteres > paidInteres) \n', '        {\n', '            uint amount = totalInteres.sub(paidInteres);\n', '\n', '            emit LogPreparePayment(msg.sender, totalInteres, paidInteres, amount);\n', '\n', '            user[msg.sender].paidInteres = user[msg.sender].paidInteres.add(amount);\n', '            transfer(msg.sender, amount);\n', '        }\n', '        else\n', '        {\n', '            emit LogSkipPreparePayment(msg.sender, totalInteres, paidInteres);\n', '        }\n', '    }\n', '\n', '    function updateInvestBalance(uint addDeposit) private \n', '    {\n', '        user[msg.sender].balance = user[msg.sender].balance.add(addDeposit);\n', '        totalInvest = totalInvest.add(addDeposit);\n', '    }\n', '\n', '    function transfer(address receiver, uint amount) private \n', '    {\n', '        if (amount > 0) \n', '        {\n', '            if (receiver != owner) { totalPaid = totalPaid.add(amount); }\n', '\n', '            uint balance = address(this).balance;\n', '\n', '            emit LogTransfer(receiver, amount, balance);\n', '\n', '            require(amount < balance, "Not enough balance. Please retry later.");\n', '\n', '            receiver.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function bytesToAddress(bytes source) private pure returns(address addr) \n', '    {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function getTotals() public view returns(uint _maxDepositDays, \n', '                                             uint _perDay, \n', '                                             uint _startTimestamp, \n', '\n', '                                             uint _minimalDeposit, \n', '                                             uint _maximalDeposit, \n', '                                             uint[4] _bonusReferrer, \n', '                                             uint _minimalDepositForBonusReferrer, \n', '                                             uint _ownerFee, \n', '\n', '                                             uint _countInvestors, \n', '                                             uint _totalInvest, \n', '                                             uint _totalPenalty, \n', '//                                             uint _totalSelfInvest, \n', '                                             uint _totalPaid, \n', '\n', '                                             uint _currentDayDepositLimit, \n', '                                             uint _currentDayRestDepositLimit)\n', '    {\n', '        return (\n', '                 maxDepositDays,\n', '                 perDay,\n', '                 startTimestamp,\n', '\n', '                 minimalDeposit,\n', '                 getCurrentMaximalDeposit(),\n', '                 bonusReferrer,\n', '                 minimalDepositForBonusReferrer,\n', '                 ownerFee,\n', '\n', '                 countInvestors,\n', '                 totalInvest,\n', '                 totalPenalty,\n', '//                 totalSelfInvest,\n', '                 totalPaid,\n', '\n', '                 getCurrentDayDepositLimit(),\n', '                 getCurrentDayRestDepositLimit()\n', '               );\n', '    }\n', '\n', '}']