['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '}\n', '\n', 'contract RakuRakuEth {\n', '  using SafeMath for uint256;\n', '\n', '  enum Status {\n', '    Pending,\n', '    Requested,\n', '    Canceled,\n', '    Paid,\n', '    Rejected\n', '  }\n', '  \n', '  struct Payment {\n', '    uint256 amountJpy;\n', '    uint256 amountWei;\n', '    uint256 rateEthJpy;\n', '    uint256 paymentDue;\n', '    uint256 requestedTime;\n', '    Status status; //0: pending, 1: requested, 2: canceled, 3: paid, 4: rejected\n', '  }\n', '  \n', '  address public owner;\n', '  address public creditor;\n', '  address public debtor;\n', '  uint256 ethWei = 10**18;\n', '\n', '  Payment[] payments;\n', '  mapping (address => uint256) balances;\n', '  \n', '  modifier onlyCreditor() {\n', '    require(msg.sender == creditor);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyDebtor() {\n', '    require(msg.sender == debtor);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyStakeholders() {\n', '    require(msg.sender == debtor || msg.sender == creditor);\n', '    _;\n', '  }\n', '\n', '  constructor (address _creditor, address _debtor) public {\n', '    owner = msg.sender;\n', '    creditor = _creditor;\n', '    debtor = _debtor;\n', '  }\n', '  \n', '  // Public Function (anyone can call)\n', '  function getCurrentTimestamp () external view returns (uint256 timestamp) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  function collectPayment(uint256 _index) external returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(payments[_index].requestedTime + 24*60*60 < block.timestamp);\n', '    require(balances[debtor] >= payments[_index].amountWei);\n', '    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n', '    balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n', '    payments[_index].status = Status.Paid;\n', '    return true;\n', '  }\n', '  \n', '  // Function for stakeholders (debtor or creditor)\n', '  function getBalance(address _address) external view returns (uint256 balance) {\n', '    return balances[_address];\n', '  }\n', '  \n', '  function getPayment(uint256 _index) external view returns (uint256 amountJpy, uint256 amountWei, uint256 rateEthJpy, uint256 paymentDue, uint256 requestedTime, Status status) {\n', '    Payment memory pm = payments[_index];\n', '    return (pm.amountJpy, pm.amountWei, pm.rateEthJpy, pm.paymentDue, pm.requestedTime, pm.status);\n', '  }\n', '  \n', '  function getNumPayments() external view returns (uint256 num) {\n', '    return payments.length;\n', '  }\n', '  \n', '  function withdraw(uint256 _amount) external returns (bool) {\n', '    require(balances[msg.sender] >= _amount);\n', '    msg.sender.transfer(_amount);\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    return true;\n', '  }\n', '  \n', '  // Functions for creditor\n', '  function addPayment(uint256 _amountJpy, uint256 _paymentDue) external onlyCreditor returns (uint256 index) {\n', '    payments.push(Payment(_amountJpy, 0, 0, _paymentDue, 0, Status.Pending));\n', '    return payments.length-1;\n', '  }\n', '  \n', '  function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) {\n', '    require(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected);\n', '    require(payments[_index].paymentDue <= block.timestamp);\n', '    payments[_index].rateEthJpy = _rateEthJpy;\n', '    payments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy);\n', '    payments[_index].requestedTime = block.timestamp;\n', '    payments[_index].status = Status.Requested;\n', '    return true;\n', '  }\n', '  \n', '  function cancelPayment(uint256 _index) external onlyCreditor returns (bool) {\n', '    require(payments[_index].status != Status.Paid);\n', '    payments[_index].status = Status.Canceled;\n', '    return true;\n', '  }\n', '\n', '  // Function for debtor\n', '  function () external payable onlyDebtor {\n', '    balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '  }\n', '  \n', '  function rejectPayment(uint256 _index) external onlyDebtor returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(payments[_index].requestedTime + 24*60*60 > block.timestamp);\n', '    payments[_index].status = Status.Rejected;\n', '    return true;\n', '  }\n', '  \n', '  function approvePayment(uint256 _index) external onlyDebtor returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(balances[debtor] >= payments[_index].amountWei);\n', '    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n', '    balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n', '    payments[_index].status = Status.Paid;\n', '    return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '}\n', '\n', 'contract RakuRakuEth {\n', '  using SafeMath for uint256;\n', '\n', '  enum Status {\n', '    Pending,\n', '    Requested,\n', '    Canceled,\n', '    Paid,\n', '    Rejected\n', '  }\n', '  \n', '  struct Payment {\n', '    uint256 amountJpy;\n', '    uint256 amountWei;\n', '    uint256 rateEthJpy;\n', '    uint256 paymentDue;\n', '    uint256 requestedTime;\n', '    Status status; //0: pending, 1: requested, 2: canceled, 3: paid, 4: rejected\n', '  }\n', '  \n', '  address public owner;\n', '  address public creditor;\n', '  address public debtor;\n', '  uint256 ethWei = 10**18;\n', '\n', '  Payment[] payments;\n', '  mapping (address => uint256) balances;\n', '  \n', '  modifier onlyCreditor() {\n', '    require(msg.sender == creditor);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyDebtor() {\n', '    require(msg.sender == debtor);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyStakeholders() {\n', '    require(msg.sender == debtor || msg.sender == creditor);\n', '    _;\n', '  }\n', '\n', '  constructor (address _creditor, address _debtor) public {\n', '    owner = msg.sender;\n', '    creditor = _creditor;\n', '    debtor = _debtor;\n', '  }\n', '  \n', '  // Public Function (anyone can call)\n', '  function getCurrentTimestamp () external view returns (uint256 timestamp) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  function collectPayment(uint256 _index) external returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(payments[_index].requestedTime + 24*60*60 < block.timestamp);\n', '    require(balances[debtor] >= payments[_index].amountWei);\n', '    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n', '    balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n', '    payments[_index].status = Status.Paid;\n', '    return true;\n', '  }\n', '  \n', '  // Function for stakeholders (debtor or creditor)\n', '  function getBalance(address _address) external view returns (uint256 balance) {\n', '    return balances[_address];\n', '  }\n', '  \n', '  function getPayment(uint256 _index) external view returns (uint256 amountJpy, uint256 amountWei, uint256 rateEthJpy, uint256 paymentDue, uint256 requestedTime, Status status) {\n', '    Payment memory pm = payments[_index];\n', '    return (pm.amountJpy, pm.amountWei, pm.rateEthJpy, pm.paymentDue, pm.requestedTime, pm.status);\n', '  }\n', '  \n', '  function getNumPayments() external view returns (uint256 num) {\n', '    return payments.length;\n', '  }\n', '  \n', '  function withdraw(uint256 _amount) external returns (bool) {\n', '    require(balances[msg.sender] >= _amount);\n', '    msg.sender.transfer(_amount);\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    return true;\n', '  }\n', '  \n', '  // Functions for creditor\n', '  function addPayment(uint256 _amountJpy, uint256 _paymentDue) external onlyCreditor returns (uint256 index) {\n', '    payments.push(Payment(_amountJpy, 0, 0, _paymentDue, 0, Status.Pending));\n', '    return payments.length-1;\n', '  }\n', '  \n', '  function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) {\n', '    require(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected);\n', '    require(payments[_index].paymentDue <= block.timestamp);\n', '    payments[_index].rateEthJpy = _rateEthJpy;\n', '    payments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy);\n', '    payments[_index].requestedTime = block.timestamp;\n', '    payments[_index].status = Status.Requested;\n', '    return true;\n', '  }\n', '  \n', '  function cancelPayment(uint256 _index) external onlyCreditor returns (bool) {\n', '    require(payments[_index].status != Status.Paid);\n', '    payments[_index].status = Status.Canceled;\n', '    return true;\n', '  }\n', '\n', '  // Function for debtor\n', '  function () external payable onlyDebtor {\n', '    balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '  }\n', '  \n', '  function rejectPayment(uint256 _index) external onlyDebtor returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(payments[_index].requestedTime + 24*60*60 > block.timestamp);\n', '    payments[_index].status = Status.Rejected;\n', '    return true;\n', '  }\n', '  \n', '  function approvePayment(uint256 _index) external onlyDebtor returns (bool) {\n', '    require(payments[_index].status == Status.Requested);\n', '    require(balances[debtor] >= payments[_index].amountWei);\n', '    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n', '    balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n', '    payments[_index].status = Status.Paid;\n', '    return true;\n', '  }\n', '\n', '}']
