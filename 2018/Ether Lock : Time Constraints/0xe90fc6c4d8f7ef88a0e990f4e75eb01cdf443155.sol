['pragma solidity ^0.4.16;\n', '\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', ' \n', 'contract Exchange {\n', '\n', '  address public owner;\n', '  mapping (address => uint256) public invalidOrder;\n', '\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\n', '\n', '  mapping (address => bool) public admins;\n', '  mapping (address => uint256) public lastActiveTransaction;\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  address public feeAccount;\n', '  uint256 public inactivityReleasePeriod;\n', '  mapping (bytes32 => bool) public traded;\n', '  mapping (bytes32 => bool) public withdrawn;\n', '  event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '\n', '  function setInactivityReleasePeriod(uint256 expiry)  returns (bool success) {\n', '    if (expiry > 1000000) throw;\n', '    inactivityReleasePeriod = expiry;\n', '    return true;\n', '  }\n', '\n', '\n', '\n', '  function Exchange(address feeAccount_) {\n', '    owner = msg.sender;\n', '    feeAccount = feeAccount_;\n', '    inactivityReleasePeriod = 100000;\n', '  }\n', '\n', '\n', '  function assert(bool assertion) {\n', '    if (!assertion) throw;\n', '  }\n', '  function safeMul(uint a, uint b) returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '\n', '  function depositToken(address token, uint256 amount) {\n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n', '    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '\n', '\n', '  function deposit() payable {\n', '    tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', '\n', '\n', '}']