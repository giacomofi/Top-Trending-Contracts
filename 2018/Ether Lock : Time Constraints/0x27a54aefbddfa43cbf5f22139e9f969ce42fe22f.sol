['//Gladiate\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'library gladiate {\n', '    enum Weapon {None, Knife, Sword, Spear}\n', '    enum GladiatorState {Null, Incoming, Active, Outgoing}\n', '    \n', '    struct Gladiator {\n', '        GladiatorState state;\n', '        uint stateTransitionBlock;\n', '        uint8 x;\n', '        uint8 y;\n', '        Weapon weapon;\n', '        uint8 coins;\n', '    }\n', '}\n', '\n', 'contract Arena {\n', '    uint8 pseudoRandomNonce;\n', '    function pseudoRandomUint8(uint8 limit)\n', '    internal\n', '    returns (uint8) {\n', '        return uint8(keccak256(block.blockhash(block.number-1), pseudoRandomNonce)) % limit;\n', '        pseudoRandomNonce++;\n', '    }\n', '    \n', '    uint constant public coinValue = 50000000000000000; // 0.05 ETH\n', '    \n', '    uint constant spawnTime = 3;\n', '    uint constant despawnTime = 2;\n', '    \n', '    address public emperor;\n', '    mapping (address => gladiate.Gladiator) public gladiators;\n', '    \n', '    struct Tile {\n', '        uint coins;\n', '        gladiate.Weapon weapon;\n', '        address gladiator;\n', '    }\n', '    \n', '    Tile[10][10] tiles;\n', '    \n', '    function Arena()\n', '    public {\n', '        emperor = msg.sender;\n', '    }\n', '    \n', '    modifier onlyEmporer() \n', '        {require(msg.sender == emperor); _;}\n', '    modifier gladiatorExists(address owner) \n', '        {require(gladiators[owner].state != gladiate.GladiatorState.Null); _;}\n', '    modifier gladiatorInState(address owner, gladiate.GladiatorState s) \n', '        {require(gladiators[owner].state == s); _;}\n', '    \n', '    function startGladiatorWithCoin(uint8 x, uint8 y, address owner)\n', '    internal {\n', '        gladiators[owner].state = gladiate.GladiatorState.Incoming;\n', '        gladiators[owner].stateTransitionBlock = block.number + spawnTime;\n', '        gladiators[owner].x = x;\n', '        gladiators[owner].y = y;\n', '        gladiators[owner].coins = 1;\n', '        \n', '        tiles[x][y].gladiator = owner;\n', '    }\n', '    \n', '    function despawnGladiatorAndAwardCoins(address owner)\n', '    internal {\n', '        owner.transfer(gladiators[owner].coins * coinValue);\n', '        \n', '        gladiators[owner].state = gladiate.GladiatorState.Null;\n', '    }\n', '    \n', '    function addCoins(uint8 x, uint8 y, uint amount)\n', '    internal {\n', '        tiles[x][y].coins += amount;\n', '    }\n', '    \n', '    function throwIn()\n', '    external\n', '    payable \n', '    returns (bool) {\n', '        require(gladiators[msg.sender].state == gladiate.GladiatorState.Null);\n', '        require(msg.value == coinValue);\n', '        \n', '        uint8 lastX;\n', '        uint8 lastY;\n', '        for (uint8 i=0; i<3; i++) {\n', '            uint8 x = pseudoRandomUint8(10);\n', '            uint8 y = pseudoRandomUint8(10);\n', '            lastX = x;\n', '            lastY = y;\n', '            \n', '            if (tiles[x][y].gladiator == 0x0) {\n', '                startGladiatorWithCoin(x, y, msg.sender);\n', '                return true;\n', '            }\n', '        }\n', '        //Couldn&#39;t find a place for the gladiator. Let&#39;s take the money anyway and put it in the Arena.\n', '        //Ether is already in the contract unless we revert, so just have to put a coin somewhere\n', '        addCoins(lastX, lastY, 1);\n', '        return false;\n', '    }\n', '    \n', '    function activateGladiator(address who)\n', '    external\n', '    gladiatorExists(who)\n', '    gladiatorInState(who, gladiate.GladiatorState.Incoming) {\n', '        require(gladiators[who].stateTransitionBlock <= block.number);\n', '        \n', '        gladiators[who].state = gladiate.GladiatorState.Active;\n', '        gladiators[who].stateTransitionBlock = (uint(0) - 1);//max int\n', '    }\n', '    \n', '    function imOut()\n', '    external\n', '    gladiatorInState(msg.sender, gladiate.GladiatorState.Active) {\n', '        gladiators[msg.sender].state = gladiate.GladiatorState.Outgoing;\n', '        gladiators[msg.sender].stateTransitionBlock = block.number + despawnTime;\n', '    }\n', '    \n', '    function getOut()\n', '    external\n', '    gladiatorInState(msg.sender, gladiate.GladiatorState.Outgoing) {\n', '        require(gladiators[msg.sender].stateTransitionBlock <= block.number);\n', '        \n', '        despawnGladiatorAndAwardCoins(msg.sender);\n', '    }\n', '    \n', '    function nextBlock() \n', '    public {\n', '        gladiators[0x0].coins ++;\n', '    }\n', '}']
['//Gladiate\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'library gladiate {\n', '    enum Weapon {None, Knife, Sword, Spear}\n', '    enum GladiatorState {Null, Incoming, Active, Outgoing}\n', '    \n', '    struct Gladiator {\n', '        GladiatorState state;\n', '        uint stateTransitionBlock;\n', '        uint8 x;\n', '        uint8 y;\n', '        Weapon weapon;\n', '        uint8 coins;\n', '    }\n', '}\n', '\n', 'contract Arena {\n', '    uint8 pseudoRandomNonce;\n', '    function pseudoRandomUint8(uint8 limit)\n', '    internal\n', '    returns (uint8) {\n', '        return uint8(keccak256(block.blockhash(block.number-1), pseudoRandomNonce)) % limit;\n', '        pseudoRandomNonce++;\n', '    }\n', '    \n', '    uint constant public coinValue = 50000000000000000; // 0.05 ETH\n', '    \n', '    uint constant spawnTime = 3;\n', '    uint constant despawnTime = 2;\n', '    \n', '    address public emperor;\n', '    mapping (address => gladiate.Gladiator) public gladiators;\n', '    \n', '    struct Tile {\n', '        uint coins;\n', '        gladiate.Weapon weapon;\n', '        address gladiator;\n', '    }\n', '    \n', '    Tile[10][10] tiles;\n', '    \n', '    function Arena()\n', '    public {\n', '        emperor = msg.sender;\n', '    }\n', '    \n', '    modifier onlyEmporer() \n', '        {require(msg.sender == emperor); _;}\n', '    modifier gladiatorExists(address owner) \n', '        {require(gladiators[owner].state != gladiate.GladiatorState.Null); _;}\n', '    modifier gladiatorInState(address owner, gladiate.GladiatorState s) \n', '        {require(gladiators[owner].state == s); _;}\n', '    \n', '    function startGladiatorWithCoin(uint8 x, uint8 y, address owner)\n', '    internal {\n', '        gladiators[owner].state = gladiate.GladiatorState.Incoming;\n', '        gladiators[owner].stateTransitionBlock = block.number + spawnTime;\n', '        gladiators[owner].x = x;\n', '        gladiators[owner].y = y;\n', '        gladiators[owner].coins = 1;\n', '        \n', '        tiles[x][y].gladiator = owner;\n', '    }\n', '    \n', '    function despawnGladiatorAndAwardCoins(address owner)\n', '    internal {\n', '        owner.transfer(gladiators[owner].coins * coinValue);\n', '        \n', '        gladiators[owner].state = gladiate.GladiatorState.Null;\n', '    }\n', '    \n', '    function addCoins(uint8 x, uint8 y, uint amount)\n', '    internal {\n', '        tiles[x][y].coins += amount;\n', '    }\n', '    \n', '    function throwIn()\n', '    external\n', '    payable \n', '    returns (bool) {\n', '        require(gladiators[msg.sender].state == gladiate.GladiatorState.Null);\n', '        require(msg.value == coinValue);\n', '        \n', '        uint8 lastX;\n', '        uint8 lastY;\n', '        for (uint8 i=0; i<3; i++) {\n', '            uint8 x = pseudoRandomUint8(10);\n', '            uint8 y = pseudoRandomUint8(10);\n', '            lastX = x;\n', '            lastY = y;\n', '            \n', '            if (tiles[x][y].gladiator == 0x0) {\n', '                startGladiatorWithCoin(x, y, msg.sender);\n', '                return true;\n', '            }\n', '        }\n', "        //Couldn't find a place for the gladiator. Let's take the money anyway and put it in the Arena.\n", '        //Ether is already in the contract unless we revert, so just have to put a coin somewhere\n', '        addCoins(lastX, lastY, 1);\n', '        return false;\n', '    }\n', '    \n', '    function activateGladiator(address who)\n', '    external\n', '    gladiatorExists(who)\n', '    gladiatorInState(who, gladiate.GladiatorState.Incoming) {\n', '        require(gladiators[who].stateTransitionBlock <= block.number);\n', '        \n', '        gladiators[who].state = gladiate.GladiatorState.Active;\n', '        gladiators[who].stateTransitionBlock = (uint(0) - 1);//max int\n', '    }\n', '    \n', '    function imOut()\n', '    external\n', '    gladiatorInState(msg.sender, gladiate.GladiatorState.Active) {\n', '        gladiators[msg.sender].state = gladiate.GladiatorState.Outgoing;\n', '        gladiators[msg.sender].stateTransitionBlock = block.number + despawnTime;\n', '    }\n', '    \n', '    function getOut()\n', '    external\n', '    gladiatorInState(msg.sender, gladiate.GladiatorState.Outgoing) {\n', '        require(gladiators[msg.sender].stateTransitionBlock <= block.number);\n', '        \n', '        despawnGladiatorAndAwardCoins(msg.sender);\n', '    }\n', '    \n', '    function nextBlock() \n', '    public {\n', '        gladiators[0x0].coins ++;\n', '    }\n', '}']
