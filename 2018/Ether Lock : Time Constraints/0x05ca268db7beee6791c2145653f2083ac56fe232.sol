['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender)\n', '        public view returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '    );\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '  \n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '    function burn(uint256 _value) public {\n', '        _burn(msg.sender, _value);\n', '    }\n', '\n', '    function _burn(address _who, uint256 _value) internal {\n', '        require(_value <= balances[_who]);\n', '\n', '        balances[_who] = balances[_who].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burn(_who, _value);\n', '        emit Transfer(_who, address(0), _value);\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint _addedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint _subtractedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract NRXtoken is StandardToken, BurnableToken {\n', '    string public constant name = "Neironix";\n', '    string public constant symbol = "NRX";\n', '    uint32 public constant decimals = 18;\n', '    uint256 public INITIAL_SUPPLY = 140000000 * 1 ether;\n', '    address public CrowdsaleAddress;\n', '    bool public lockTransfers = false;\n', '\n', '    event AcceptToken(address indexed from, uint256 value);\n', '\n', '    constructor(address _CrowdsaleAddress) public {\n', '        CrowdsaleAddress = _CrowdsaleAddress;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;      \n', '    }\n', '  \n', '    modifier onlyOwner() {\n', '        // only Crowdsale contract\n', '        require(msg.sender == CrowdsaleAddress);\n', '        _;\n', '    }\n', '\n', '     // Override\n', '    function transfer(address _to, uint256 _value) public returns(bool){\n', '        if (msg.sender != CrowdsaleAddress){\n', '            require(!lockTransfers, "Transfers are prohibited in Crowdsale period");\n', '        }\n', '        return super.transfer(_to,_value);\n', '    }\n', '\n', '     // Override\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\n', '        if (msg.sender != CrowdsaleAddress){\n', '            require(!lockTransfers, "Transfers are prohibited in Crowdsale period");\n', '        }\n', '        return super.transferFrom(_from,_to,_value);\n', '    }\n', '\n', '    /**\n', '     * @dev function accept tokens from users as a payment for servises and burn their\n', '     * @dev can run only from crowdsale contract\n', '    */\n', '    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){\n', '        require (balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit AcceptToken(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev function transfer tokens from special address to users\n', '     * @dev can run only from crowdsale contract\n', '    */\n', '    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner returns (bool){\n', '        require (balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function lockTransfer(bool _lock) public onlyOwner {\n', '        lockTransfers = _lock;\n', '    }\n', '\n', '\n', '\n', '    function() external payable {\n', '        revert("The token contract don`t receive ether");\n', '    }  \n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address candidate;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        candidate = newOwner;\n', '    }\n', '\n', '    function confirmOwnership() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '\n', '}\n', '\n', 'contract ProjectFundAddress {\n', '    //Address where stored project fund tokens- 7%\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', '\n', 'contract TeamAddress {\n', '    //Address where stored command tokens- 10%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract PartnersAddress {\n', '    //Address where stored partners tokens- 10%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract AdvisorsAddress {\n', '    //Address where stored advisors tokens- 3,5%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract BountyAddress {\n', '    //Address where stored bounty tokens- 3%\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', '/**\n', ' * @title Crowdsale contract and burnable token ERC20\n', ' */\n', 'contract Crowdsale is Ownable {\n', '    using SafeMath for uint; \n', '    event LogStateSwitch(State newState);\n', '    event Withdraw(address indexed from, address indexed to, uint256 amount);\n', '\n', '    address myAddress = this;\n', '\n', '    uint64 crowdSaleStartTime = 0;\n', '    uint64 crowdSaleEndTime = 0;\n', '\n', '    uint public  tokenRate = 942;  //tokens for 1 ether\n', '\n', '    address public marketingProfitAddress = 0x0;\n', '    address public neironixProfitAddress = 0x0;\n', '    address public lawSupportProfitAddress = 0x0;\n', '    address public hostingProfitAddress = 0x0;\n', '    address public teamProfitAddress = 0x0;\n', '    address public contractorsProfitAddress = 0x0;\n', '    address public saasApiProfitAddress = 0x0;\n', '\n', '    \n', '    NRXtoken public token = new NRXtoken(myAddress);\n', '\n', '    /**\n', '    * @dev New address for hold tokens\n', '    */\n', '    ProjectFundAddress public holdAddress1 = new ProjectFundAddress();\n', '    TeamAddress public holdAddress2 = new TeamAddress();\n', '    PartnersAddress public holdAddress3 = new PartnersAddress();\n', '    AdvisorsAddress public holdAddress4 = new AdvisorsAddress();\n', '    BountyAddress public holdAddress5 = new BountyAddress();\n', '\n', '    /**\n', '     * @dev Create state of contract \n', '     */\n', '    enum State { \n', '        Init,    \n', '        CrowdSale,\n', '        WorkTime\n', '    }\n', '        \n', '    State public currentState = State.Init;\n', '\n', '    modifier onlyInState(State state){ \n', '        require(state==currentState); \n', '        _; \n', '    }\n', '\n', '    constructor() public {\n', '        uint256 TotalTokens = token.INITIAL_SUPPLY().div(1 ether);\n', '        // distribute tokens\n', '        //Transer tokens to project fund address.  (7%)\n', '        _transferTokens(address(holdAddress1), TotalTokens.mul(7).div(100));\n', '        // Transer tokens to team address.  (10%)\n', '        _transferTokens(address(holdAddress2), TotalTokens.div(10));\n', '        // Transer tokens to partners address. (10%)\n', '        _transferTokens(address(holdAddress3), TotalTokens.div(10));\n', '        // Transer tokens to advisors address. (3.5%)\n', '        _transferTokens(address(holdAddress4), TotalTokens.mul(35).div(1000));\n', '        // Transer tokens to bounty address. (3%)\n', '        _transferTokens(address(holdAddress5), TotalTokens.mul(3).div(100));\n', '        \n', '        /**\n', '         * @dev Create periods\n', '         * TokenSale between 01/09/2018 and 30/11/2018\n', '         * Unix timestamp 01/09/2018 - 1535760000\n', '        */\n', '\n', '\n', '        crowdSaleStartTime = 1535760000;\n', '        crowdSaleEndTime = crowdSaleStartTime + 91 days;\n', '        \n', '        \n', '    }\n', '    \n', '    function setRate(uint _newRate) public onlyOwner {\n', '        /**\n', '         * @dev Enter the amount of tokens per 1 ether\n', '         */\n', '        tokenRate = _newRate;\n', '    }\n', '\n', '    function setMarketingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        marketingProfitAddress = _addr;\n', '    }\n', '    \n', '    function setNeironixProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        neironixProfitAddress = _addr;\n', '    }\n', '\n', '    function setLawSupportProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        lawSupportProfitAddress = _addr;\n', '    }\n', ' \n', '    function setHostingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        hostingProfitAddress = _addr;\n', '    }\n', ' \n', '    function setTeamProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        teamProfitAddress = _addr;\n', '    }\n', '    \n', '    function setContractorsProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        contractorsProfitAddress = _addr;\n', '    }\n', '\n', '    function setSaasApiProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        saasApiProfitAddress = _addr;\n', '    }\n', '    \n', '    function acceptTokensFromUsers(address _investor, uint256 _value) public onlyOwner{\n', '        token.acceptTokens(_investor, _value); \n', '    }\n', '\n', '    function transferTokensFromProjectFundAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from ProjectFundAddress  to investor\n', '         * not hold\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        token.transferTokensFromSpecialAddress(address(holdAddress1), _investor, value); \n', '        return true;\n', '    } \n', '\n', '    function transferTokensFromTeamAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function tranfer tokens from TeamAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 182 days, "only after 182 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress2), _investor, value); \n', '        return true;\n', '    } \n', '    \n', '    function transferTokensFromPartnersAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from PartnersAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 91 days, "only after 91 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress3), _investor, value); \n', '        return true;\n', '    } \n', '    \n', '    function transferTokensFromAdvisorsAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from AdvisorsAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 91 days, "only after 91 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress4), _investor, value); \n', '        return true;\n', '    }     \n', '    \n', '    function transferTokensFromBountyAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from BountyAddress to investor\n', '         * not hold\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        token.transferTokensFromSpecialAddress(address(holdAddress5), _investor, value); \n', '        return true;\n', '    }     \n', '\n', '\n', '    function _transferTokens(address _newInvestor, uint256 _value) internal {\n', '        require (_newInvestor != address(0));\n', '        require (_value >= 1);\n', '        uint256 value = _value;\n', '        value = value.mul(1 ether);\n', '        token.transfer(_newInvestor, value);\n', '    }  \n', '\n', '    function transferTokens(address _newInvestor, uint256 _value) public onlyOwner {\n', '        /**\n', '         * @dev the function transfer tokens to new investor\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        _transferTokens(_newInvestor, _value);\n', '    }\n', '    \n', '    function setState(State _state) internal {\n', '        currentState = _state;\n', '        emit LogStateSwitch(_state);\n', '    }\n', '\n', '    function startSale() public onlyOwner onlyInState(State.Init) {\n', '        require(uint64(now) > crowdSaleStartTime, "Sale time is not coming.");\n', '        require(neironixProfitAddress != address(0));\n', '        setState(State.CrowdSale);\n', '        token.lockTransfer(true);\n', '    }\n', '\n', '\n', '    function finishCrowdSale() public onlyOwner onlyInState(State.CrowdSale) {\n', '        /**\n', '         * @dev the function is burn all unsolded tokens and unblock external token transfer\n', '         */\n', '        require (now > crowdSaleEndTime, "CrowdSale stage is not over");\n', '        setState(State.WorkTime);\n', '        token.lockTransfer(false);\n', '        // burn all unsolded tokens\n', '        token.burn(token.balanceOf(myAddress));\n', '    }\n', '\n', '\n', '    function blockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\n', '        /**\n', '         * @dev Blocking all external token transfer\n', '         */\n', '        require (token.lockTransfers() == false);\n', '        token.lockTransfer(true);\n', '    }\n', '\n', '    function unBlockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\n', '        /**\n', '         * @dev Unblocking all external token transfer\n', '         */\n', '        require (token.lockTransfers() == true);\n', '        token.lockTransfer(false);\n', '    }\n', '\n', '\n', '    function setBonus () public view returns(uint256) {\n', '        /**\n', '         * @dev calculation bonus\n', '         */\n', '        uint256 actualBonus = 0;\n', '        if ((uint64(now) >= crowdSaleStartTime) && (uint64(now) < crowdSaleStartTime + 30 days)){\n', '            actualBonus = 35;\n', '        }\n', '        if ((uint64(now) >= crowdSaleStartTime + 30 days) && (uint64(now) < crowdSaleStartTime + 61 days)){\n', '            actualBonus = 15;\n', '        }\n', '        if ((uint64(now) >= crowdSaleStartTime + 61 days) && (uint64(now) < crowdSaleStartTime + 91 days)){\n', '            actualBonus = 5;\n', '        }\n', '        return actualBonus;\n', '    }\n', '\n', '    function _withdrawProfit () internal {\n', '        /**\n', '         * @dev Distributing profit\n', '         * the function start automatically every time when contract receive a payable transaction\n', '         */\n', '        \n', '        uint256 marketingProfit = myAddress.balance.mul(30).div(100);   // 30%\n', '        uint256 lawSupportProfit = myAddress.balance.div(20);           // 5%\n', '        uint256 hostingProfit = myAddress.balance.div(20);              // 5%\n', '        uint256 teamProfit = myAddress.balance.div(10);                 // 10%\n', '        uint256 contractorsProfit = myAddress.balance.div(20);          // 5%\n', '        uint256 saasApiProfit = myAddress.balance.div(20);              // 5%\n', '        //uint256 neironixProfit =  myAddress.balance.mul(40).div(100); // 40% but not use. Just transfer all rest\n', '\n', '\n', '        if (marketingProfitAddress != address(0)) {\n', '            marketingProfitAddress.transfer(marketingProfit);\n', '            emit Withdraw(msg.sender, marketingProfitAddress, marketingProfit);\n', '        }\n', '        \n', '        if (lawSupportProfitAddress != address(0)) {\n', '            lawSupportProfitAddress.transfer(lawSupportProfit);\n', '            emit Withdraw(msg.sender, lawSupportProfitAddress, lawSupportProfit);\n', '        }\n', '\n', '        if (hostingProfitAddress != address(0)) {\n', '            hostingProfitAddress.transfer(hostingProfit);\n', '            emit Withdraw(msg.sender, hostingProfitAddress, hostingProfit);\n', '        }\n', '\n', '        if (teamProfitAddress != address(0)) {\n', '            teamProfitAddress.transfer(teamProfit);\n', '            emit Withdraw(msg.sender, teamProfitAddress, teamProfit);\n', '        }\n', '\n', '        if (contractorsProfitAddress != address(0)) {\n', '            contractorsProfitAddress.transfer(contractorsProfit);\n', '            emit Withdraw(msg.sender, contractorsProfitAddress, contractorsProfit);\n', '        }\n', '\n', '        if (saasApiProfitAddress != address(0)) {\n', '            saasApiProfitAddress.transfer(saasApiProfit);\n', '            emit Withdraw(msg.sender, saasApiProfitAddress, saasApiProfit);\n', '        }\n', '\n', '        require(neironixProfitAddress != address(0));\n', '        uint myBalance = myAddress.balance;\n', '        neironixProfitAddress.transfer(myBalance);\n', '        emit Withdraw(msg.sender, neironixProfitAddress, myBalance);\n', '\n', '    }\n', ' \n', '    function _saleTokens() internal returns(bool) {\n', '        require(uint64(now) > crowdSaleStartTime, "Sale stage is not yet, Contract is init, do not accept ether."); \n', '         \n', '        if (currentState == State.Init) {\n', '            require(neironixProfitAddress != address(0),"At least one of profit addresses must be entered");\n', '            setState(State.CrowdSale);\n', '        }\n', '        \n', '        /**\n', '         * @dev calculation length of periods, pauses, auto set next stage\n', '         */\n', '        if (uint64(now) > crowdSaleEndTime){\n', '            require (false, "CrowdSale stage is passed - contract do not accept ether");\n', '        }\n', '        \n', '        uint tokens = tokenRate.mul(msg.value);\n', '        \n', '        if (currentState == State.CrowdSale) {\n', '            require (msg.value <= 250 ether, "Maximum 250 ether for transaction all CrowdSale period");\n', '            require (msg.value >= 0.1 ether, "Minimum 0,1 ether for transaction all CrowdSale period");\n', '        }\n', '        \n', '        tokens = tokens.add(tokens.mul(setBonus()).div(100));\n', '        token.transfer(msg.sender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    function() external payable {\n', '        if (_saleTokens()) {\n', '            _withdrawProfit();\n', '        }\n', '    }    \n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender)\n', '        public view returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '    );\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '  \n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '    function burn(uint256 _value) public {\n', '        _burn(msg.sender, _value);\n', '    }\n', '\n', '    function _burn(address _who, uint256 _value) internal {\n', '        require(_value <= balances[_who]);\n', '\n', '        balances[_who] = balances[_who].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burn(_who, _value);\n', '        emit Transfer(_who, address(0), _value);\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint _addedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint _subtractedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract NRXtoken is StandardToken, BurnableToken {\n', '    string public constant name = "Neironix";\n', '    string public constant symbol = "NRX";\n', '    uint32 public constant decimals = 18;\n', '    uint256 public INITIAL_SUPPLY = 140000000 * 1 ether;\n', '    address public CrowdsaleAddress;\n', '    bool public lockTransfers = false;\n', '\n', '    event AcceptToken(address indexed from, uint256 value);\n', '\n', '    constructor(address _CrowdsaleAddress) public {\n', '        CrowdsaleAddress = _CrowdsaleAddress;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;      \n', '    }\n', '  \n', '    modifier onlyOwner() {\n', '        // only Crowdsale contract\n', '        require(msg.sender == CrowdsaleAddress);\n', '        _;\n', '    }\n', '\n', '     // Override\n', '    function transfer(address _to, uint256 _value) public returns(bool){\n', '        if (msg.sender != CrowdsaleAddress){\n', '            require(!lockTransfers, "Transfers are prohibited in Crowdsale period");\n', '        }\n', '        return super.transfer(_to,_value);\n', '    }\n', '\n', '     // Override\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\n', '        if (msg.sender != CrowdsaleAddress){\n', '            require(!lockTransfers, "Transfers are prohibited in Crowdsale period");\n', '        }\n', '        return super.transferFrom(_from,_to,_value);\n', '    }\n', '\n', '    /**\n', '     * @dev function accept tokens from users as a payment for servises and burn their\n', '     * @dev can run only from crowdsale contract\n', '    */\n', '    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){\n', '        require (balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit AcceptToken(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev function transfer tokens from special address to users\n', '     * @dev can run only from crowdsale contract\n', '    */\n', '    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner returns (bool){\n', '        require (balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function lockTransfer(bool _lock) public onlyOwner {\n', '        lockTransfers = _lock;\n', '    }\n', '\n', '\n', '\n', '    function() external payable {\n', '        revert("The token contract don`t receive ether");\n', '    }  \n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address candidate;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        candidate = newOwner;\n', '    }\n', '\n', '    function confirmOwnership() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '\n', '}\n', '\n', 'contract ProjectFundAddress {\n', '    //Address where stored project fund tokens- 7%\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', '\n', 'contract TeamAddress {\n', '    //Address where stored command tokens- 10%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract PartnersAddress {\n', '    //Address where stored partners tokens- 10%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract AdvisorsAddress {\n', '    //Address where stored advisors tokens- 3,5%\n', '    //Withdraw tokens allowed only after 0.5 year\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', 'contract BountyAddress {\n', '    //Address where stored bounty tokens- 3%\n', '    function() external payable {\n', '        // The contract don`t receive ether\n', '        revert();\n', '    } \n', '}\n', '\n', '/**\n', ' * @title Crowdsale contract and burnable token ERC20\n', ' */\n', 'contract Crowdsale is Ownable {\n', '    using SafeMath for uint; \n', '    event LogStateSwitch(State newState);\n', '    event Withdraw(address indexed from, address indexed to, uint256 amount);\n', '\n', '    address myAddress = this;\n', '\n', '    uint64 crowdSaleStartTime = 0;\n', '    uint64 crowdSaleEndTime = 0;\n', '\n', '    uint public  tokenRate = 942;  //tokens for 1 ether\n', '\n', '    address public marketingProfitAddress = 0x0;\n', '    address public neironixProfitAddress = 0x0;\n', '    address public lawSupportProfitAddress = 0x0;\n', '    address public hostingProfitAddress = 0x0;\n', '    address public teamProfitAddress = 0x0;\n', '    address public contractorsProfitAddress = 0x0;\n', '    address public saasApiProfitAddress = 0x0;\n', '\n', '    \n', '    NRXtoken public token = new NRXtoken(myAddress);\n', '\n', '    /**\n', '    * @dev New address for hold tokens\n', '    */\n', '    ProjectFundAddress public holdAddress1 = new ProjectFundAddress();\n', '    TeamAddress public holdAddress2 = new TeamAddress();\n', '    PartnersAddress public holdAddress3 = new PartnersAddress();\n', '    AdvisorsAddress public holdAddress4 = new AdvisorsAddress();\n', '    BountyAddress public holdAddress5 = new BountyAddress();\n', '\n', '    /**\n', '     * @dev Create state of contract \n', '     */\n', '    enum State { \n', '        Init,    \n', '        CrowdSale,\n', '        WorkTime\n', '    }\n', '        \n', '    State public currentState = State.Init;\n', '\n', '    modifier onlyInState(State state){ \n', '        require(state==currentState); \n', '        _; \n', '    }\n', '\n', '    constructor() public {\n', '        uint256 TotalTokens = token.INITIAL_SUPPLY().div(1 ether);\n', '        // distribute tokens\n', '        //Transer tokens to project fund address.  (7%)\n', '        _transferTokens(address(holdAddress1), TotalTokens.mul(7).div(100));\n', '        // Transer tokens to team address.  (10%)\n', '        _transferTokens(address(holdAddress2), TotalTokens.div(10));\n', '        // Transer tokens to partners address. (10%)\n', '        _transferTokens(address(holdAddress3), TotalTokens.div(10));\n', '        // Transer tokens to advisors address. (3.5%)\n', '        _transferTokens(address(holdAddress4), TotalTokens.mul(35).div(1000));\n', '        // Transer tokens to bounty address. (3%)\n', '        _transferTokens(address(holdAddress5), TotalTokens.mul(3).div(100));\n', '        \n', '        /**\n', '         * @dev Create periods\n', '         * TokenSale between 01/09/2018 and 30/11/2018\n', '         * Unix timestamp 01/09/2018 - 1535760000\n', '        */\n', '\n', '\n', '        crowdSaleStartTime = 1535760000;\n', '        crowdSaleEndTime = crowdSaleStartTime + 91 days;\n', '        \n', '        \n', '    }\n', '    \n', '    function setRate(uint _newRate) public onlyOwner {\n', '        /**\n', '         * @dev Enter the amount of tokens per 1 ether\n', '         */\n', '        tokenRate = _newRate;\n', '    }\n', '\n', '    function setMarketingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        marketingProfitAddress = _addr;\n', '    }\n', '    \n', '    function setNeironixProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        neironixProfitAddress = _addr;\n', '    }\n', '\n', '    function setLawSupportProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        lawSupportProfitAddress = _addr;\n', '    }\n', ' \n', '    function setHostingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        hostingProfitAddress = _addr;\n', '    }\n', ' \n', '    function setTeamProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        teamProfitAddress = _addr;\n', '    }\n', '    \n', '    function setContractorsProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        contractorsProfitAddress = _addr;\n', '    }\n', '\n', '    function setSaasApiProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\n', '        require (_addr != address(0));\n', '        saasApiProfitAddress = _addr;\n', '    }\n', '    \n', '    function acceptTokensFromUsers(address _investor, uint256 _value) public onlyOwner{\n', '        token.acceptTokens(_investor, _value); \n', '    }\n', '\n', '    function transferTokensFromProjectFundAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from ProjectFundAddress  to investor\n', '         * not hold\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        token.transferTokensFromSpecialAddress(address(holdAddress1), _investor, value); \n', '        return true;\n', '    } \n', '\n', '    function transferTokensFromTeamAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function tranfer tokens from TeamAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 182 days, "only after 182 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress2), _investor, value); \n', '        return true;\n', '    } \n', '    \n', '    function transferTokensFromPartnersAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from PartnersAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 91 days, "only after 91 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress3), _investor, value); \n', '        return true;\n', '    } \n', '    \n', '    function transferTokensFromAdvisorsAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from AdvisorsAddress to investor\n', '         * only after 182 days\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        require (now >= crowdSaleEndTime + 91 days, "only after 91 days");\n', '        token.transferTokensFromSpecialAddress(address(holdAddress4), _investor, value); \n', '        return true;\n', '    }     \n', '    \n', '    function transferTokensFromBountyAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\n', '        /**\n', '         * @dev the function transfer tokens from BountyAddress to investor\n', '         * not hold\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        uint256 value = _value;\n', '        require (value >= 1);\n', '        value = value.mul(1 ether);\n', '        token.transferTokensFromSpecialAddress(address(holdAddress5), _investor, value); \n', '        return true;\n', '    }     \n', '\n', '\n', '    function _transferTokens(address _newInvestor, uint256 _value) internal {\n', '        require (_newInvestor != address(0));\n', '        require (_value >= 1);\n', '        uint256 value = _value;\n', '        value = value.mul(1 ether);\n', '        token.transfer(_newInvestor, value);\n', '    }  \n', '\n', '    function transferTokens(address _newInvestor, uint256 _value) public onlyOwner {\n', '        /**\n', '         * @dev the function transfer tokens to new investor\n', '         * the sum is entered in whole tokens (1 = 1 token)\n', '         */\n', '        _transferTokens(_newInvestor, _value);\n', '    }\n', '    \n', '    function setState(State _state) internal {\n', '        currentState = _state;\n', '        emit LogStateSwitch(_state);\n', '    }\n', '\n', '    function startSale() public onlyOwner onlyInState(State.Init) {\n', '        require(uint64(now) > crowdSaleStartTime, "Sale time is not coming.");\n', '        require(neironixProfitAddress != address(0));\n', '        setState(State.CrowdSale);\n', '        token.lockTransfer(true);\n', '    }\n', '\n', '\n', '    function finishCrowdSale() public onlyOwner onlyInState(State.CrowdSale) {\n', '        /**\n', '         * @dev the function is burn all unsolded tokens and unblock external token transfer\n', '         */\n', '        require (now > crowdSaleEndTime, "CrowdSale stage is not over");\n', '        setState(State.WorkTime);\n', '        token.lockTransfer(false);\n', '        // burn all unsolded tokens\n', '        token.burn(token.balanceOf(myAddress));\n', '    }\n', '\n', '\n', '    function blockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\n', '        /**\n', '         * @dev Blocking all external token transfer\n', '         */\n', '        require (token.lockTransfers() == false);\n', '        token.lockTransfer(true);\n', '    }\n', '\n', '    function unBlockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\n', '        /**\n', '         * @dev Unblocking all external token transfer\n', '         */\n', '        require (token.lockTransfers() == true);\n', '        token.lockTransfer(false);\n', '    }\n', '\n', '\n', '    function setBonus () public view returns(uint256) {\n', '        /**\n', '         * @dev calculation bonus\n', '         */\n', '        uint256 actualBonus = 0;\n', '        if ((uint64(now) >= crowdSaleStartTime) && (uint64(now) < crowdSaleStartTime + 30 days)){\n', '            actualBonus = 35;\n', '        }\n', '        if ((uint64(now) >= crowdSaleStartTime + 30 days) && (uint64(now) < crowdSaleStartTime + 61 days)){\n', '            actualBonus = 15;\n', '        }\n', '        if ((uint64(now) >= crowdSaleStartTime + 61 days) && (uint64(now) < crowdSaleStartTime + 91 days)){\n', '            actualBonus = 5;\n', '        }\n', '        return actualBonus;\n', '    }\n', '\n', '    function _withdrawProfit () internal {\n', '        /**\n', '         * @dev Distributing profit\n', '         * the function start automatically every time when contract receive a payable transaction\n', '         */\n', '        \n', '        uint256 marketingProfit = myAddress.balance.mul(30).div(100);   // 30%\n', '        uint256 lawSupportProfit = myAddress.balance.div(20);           // 5%\n', '        uint256 hostingProfit = myAddress.balance.div(20);              // 5%\n', '        uint256 teamProfit = myAddress.balance.div(10);                 // 10%\n', '        uint256 contractorsProfit = myAddress.balance.div(20);          // 5%\n', '        uint256 saasApiProfit = myAddress.balance.div(20);              // 5%\n', '        //uint256 neironixProfit =  myAddress.balance.mul(40).div(100); // 40% but not use. Just transfer all rest\n', '\n', '\n', '        if (marketingProfitAddress != address(0)) {\n', '            marketingProfitAddress.transfer(marketingProfit);\n', '            emit Withdraw(msg.sender, marketingProfitAddress, marketingProfit);\n', '        }\n', '        \n', '        if (lawSupportProfitAddress != address(0)) {\n', '            lawSupportProfitAddress.transfer(lawSupportProfit);\n', '            emit Withdraw(msg.sender, lawSupportProfitAddress, lawSupportProfit);\n', '        }\n', '\n', '        if (hostingProfitAddress != address(0)) {\n', '            hostingProfitAddress.transfer(hostingProfit);\n', '            emit Withdraw(msg.sender, hostingProfitAddress, hostingProfit);\n', '        }\n', '\n', '        if (teamProfitAddress != address(0)) {\n', '            teamProfitAddress.transfer(teamProfit);\n', '            emit Withdraw(msg.sender, teamProfitAddress, teamProfit);\n', '        }\n', '\n', '        if (contractorsProfitAddress != address(0)) {\n', '            contractorsProfitAddress.transfer(contractorsProfit);\n', '            emit Withdraw(msg.sender, contractorsProfitAddress, contractorsProfit);\n', '        }\n', '\n', '        if (saasApiProfitAddress != address(0)) {\n', '            saasApiProfitAddress.transfer(saasApiProfit);\n', '            emit Withdraw(msg.sender, saasApiProfitAddress, saasApiProfit);\n', '        }\n', '\n', '        require(neironixProfitAddress != address(0));\n', '        uint myBalance = myAddress.balance;\n', '        neironixProfitAddress.transfer(myBalance);\n', '        emit Withdraw(msg.sender, neironixProfitAddress, myBalance);\n', '\n', '    }\n', ' \n', '    function _saleTokens() internal returns(bool) {\n', '        require(uint64(now) > crowdSaleStartTime, "Sale stage is not yet, Contract is init, do not accept ether."); \n', '         \n', '        if (currentState == State.Init) {\n', '            require(neironixProfitAddress != address(0),"At least one of profit addresses must be entered");\n', '            setState(State.CrowdSale);\n', '        }\n', '        \n', '        /**\n', '         * @dev calculation length of periods, pauses, auto set next stage\n', '         */\n', '        if (uint64(now) > crowdSaleEndTime){\n', '            require (false, "CrowdSale stage is passed - contract do not accept ether");\n', '        }\n', '        \n', '        uint tokens = tokenRate.mul(msg.value);\n', '        \n', '        if (currentState == State.CrowdSale) {\n', '            require (msg.value <= 250 ether, "Maximum 250 ether for transaction all CrowdSale period");\n', '            require (msg.value >= 0.1 ether, "Minimum 0,1 ether for transaction all CrowdSale period");\n', '        }\n', '        \n', '        tokens = tokens.add(tokens.mul(setBonus()).div(100));\n', '        token.transfer(msg.sender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    function() external payable {\n', '        if (_saleTokens()) {\n', '            _withdrawProfit();\n', '        }\n', '    }    \n', '\n', '}']
