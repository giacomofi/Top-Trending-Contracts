['pragma solidity 0.4.25;\n', '\n', 'contract SmartMinFin {\n', '    using SafeMath for uint;\n', '    mapping(address => uint) public deposited;\n', '    mapping(address => uint) public time;\n', '    mapping(address => uint) public timeFirstDeposit;\n', '    mapping(address => uint) public withdraw;\n', '    mapping(address => uint) public reservedBalance;\n', '    uint public stepTime = 24 hours;\n', '    uint public countOfInvestors = 0;\n', '    address admin1 = 0x49D2Fc41d52EE4bE85bC0A364A4BCF828B186FdC; //10%\n', '    address admin2 = 0x0798C4A872571F924Beea03acD48c6fbd655Eeee; //1%\n', '    address admin3 = 0xC0bFE578866CE6eD326caaBf19966158A601F4d0; //3%\n', '    address admin4 = 0xdc4d7a065c97d126d49D6107E29cD70EA5e31bf6; //1%\n', '    uint firstWithdrawal = stepTime * 7;\n', '    uint public maxWithdrawal = 3 ether;\n', '    uint public minDeposit = 1 ether / 10;\n', '    uint public maxDeposit = 30 ether;\n', '\n', '    event Invest(address investor, uint256 amount);\n', '    event Withdraw(address investor, uint256 amount);\n', '\n', '    modifier userExist() {\n', '        require(deposited[msg.sender] > 0, "Address not found");\n', '        _;\n', '    }\n', '\n', '    modifier checkTime() {\n', '        require(now >= timeFirstDeposit[msg.sender].add(firstWithdrawal), "Too fast for first withdrawal");\n', '        require(now >= time[msg.sender].add(stepTime), "Too fast payout request");\n', '        _;\n', '    }\n', '\n', '    function collectPercent() userExist checkTime internal {\n', '        uint different = now.sub(time[msg.sender]).div(stepTime);\n', '        uint percent = different > 10 ? 10 : different;\n', '        uint rate = deposited[msg.sender].mul(percent).div(1000);\n', '        uint withdrawalAmount = rate.mul(different);\n', '        uint availableToWithdrawal = deposited[msg.sender].mul(3) - withdraw[msg.sender];\n', '\n', '        if (reservedBalance[msg.sender] > 0) {\n', '            withdrawalAmount = withdrawalAmount.add(reservedBalance[msg.sender]);\n', '            reservedBalance[msg.sender] = 0;\n', '        }\n', '\n', '        if (withdrawalAmount > maxWithdrawal) {\n', '            reservedBalance[msg.sender] = withdrawalAmount - maxWithdrawal;\n', '            withdrawalAmount = maxWithdrawal;\n', '        }\n', '\n', '        if (withdrawalAmount >= availableToWithdrawal) {\n', '            withdrawalAmount = availableToWithdrawal;\n', '            msg.sender.send(withdrawalAmount);\n', '\n', '            deposited[msg.sender] = 0;\n', '            time[msg.sender] = 0;\n', '            timeFirstDeposit[msg.sender] = 0;\n', '            withdraw[msg.sender] = 0;\n', '            reservedBalance[msg.sender] = 0;\n', '            countOfInvestors--;\n', '        } else {\n', '            msg.sender.send(withdrawalAmount);\n', '\n', '            time[msg.sender] = different.mul(stepTime).add(time[msg.sender]);\n', '            withdraw[msg.sender] = withdraw[msg.sender].add(withdrawalAmount);\n', '        }\n', '\n', '        emit Withdraw(msg.sender, withdrawalAmount);\n', '    }\n', '\n', '    function deposit() private {\n', '        if (msg.value > 0) {\n', '            require(msg.value >= minDeposit && msg.value <= maxDeposit, "Wrong deposit value");\n', '            require(deposited[msg.sender] == 0, "This address is already in use.");\n', '\n', '            countOfInvestors += 1;\n', '            deposited[msg.sender] = msg.value;\n', '            time[msg.sender] = now;\n', '            timeFirstDeposit[msg.sender] = now;\n', '            withdraw[msg.sender] = 0;\n', '            reservedBalance[msg.sender] = 0;\n', '\n', '            admin1.send(msg.value.mul(10).div(100));\n', '            admin2.send(msg.value.mul(1).div(100));\n', '            admin3.send(msg.value.mul(3).div(100));\n', '            admin4.send(msg.value.mul(1).div(100));\n', '\n', '            emit Invest(msg.sender, msg.value);\n', '        } else {\n', '            collectPercent();\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        deposit();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']