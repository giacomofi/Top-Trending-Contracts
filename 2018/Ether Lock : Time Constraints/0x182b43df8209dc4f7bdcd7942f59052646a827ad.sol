['// Human token smart contract.\n', '// Developed by Phenom.Team <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50393e363f102038353e3f3d7e2435313d">[email&#160;protected]</a>>\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' *   @title SafeMath\n', ' *   @dev Math operations with safety checks that throw on error\n', ' */\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal constant returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal constant returns(uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal constant returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal constant returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' *   @title ERC20\n', ' *   @dev Standart ERC20 token interface\n', ' */\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '}\n', '\n', ' /**\n', ' *   @title HumanTokenAllocator contract  -  issues Human tokens\n', ' */\n', 'contract HumanTokenAllocator {\n', '    using SafeMath for uint;\n', '    HumanToken public Human;\n', '    uint public rateEth = 700; // Rate USD per ETH\n', '    uint public tokenPerUsdNumerator = 1;\n', '    uint public tokenPerUsdDenominator = 1;\n', '    uint public firstStageRaised;\n', '    uint public secondStageRaised;\n', '    uint public firstStageCap = 7*10**24;\n', '    uint public secondStageCap = 32*10**24;\n', '    uint public FIFTY_THOUSANDS_LIMIT = 5*10**22;\n', '    uint teamPart = 7*10**24;\n', '\n', '    bool public publicAllocationEnabled;\n', '\n', '    address public teamFund;\n', '    address public owner;\n', '    address public oracle; // Oracle address\n', '    address public company;\n', '\n', '    event LogBuyForInvestor(address investor, uint humanValue, string txHash);\n', '    event ControllerAdded(address _controller);\n', '    event ControllerRemoved(address _controller);\n', '    event FirstStageStarted(uint _timestamp);\n', '    event SecondStageStarted(uint _timestamp);\n', '    event AllocationFinished(uint _timestamp);\n', '    event PublicAllocationEnabled(uint _timestamp);\n', '    event PublicAllocationDisabled(uint _timestamp);\n', '\n', '    mapping(address => bool) public isController;\n', '\n', '    // Allows execution by the owner only     \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the oracle only\n', '    modifier onlyOracle { \n', '        require(msg.sender == oracle);\n', '        _; \n', '    }\n', '\n', '    // Allows execution by the controllers only\n', '    modifier onlyControllers { \n', '        require(isController[msg.sender]);\n', '        _; \n', '    }\n', '\n', '    // Possible statuses\n', '    enum Status {\n', '        Created,\n', '        firstStage,\n', '        secondStage,\n', '        Finished\n', '    }\n', '\n', '    Status public status = Status.Created;\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets outside addresses\n', '    */\n', '    function HumanTokenAllocator(\n', '        address _owner,\n', '        address _oracle,\n', '        address _company,\n', '        address _teamFund,\n', '        address _eventManager\n', '    ) public {\n', '        owner = _owner;\n', '        oracle = _oracle;\n', '        company = _company;\n', '        teamFund = _teamFund;\n', '        Human = new HumanToken(address(this), _eventManager);\n', '    }   \n', '\n', '   /**\n', '    *   @dev Fallback function calls buy(address _holder, uint _humanValue) function to issue tokens\n', '    */\n', '    function() external payable {\n', '        require(publicAllocationEnabled);\n', '        uint humanValue = msg.value.mul(rateEth).mul(tokenPerUsdNumerator).div(tokenPerUsdDenominator);\n', '        if (status == Status.secondStage) {\n', '            require(humanValue >= FIFTY_THOUSANDS_LIMIT);\n', '        } \n', '        buy(msg.sender, humanValue);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to set rate of ETH\n', '    *   @param _rateEth       current ETH rate\n', '    */\n', '    function setRate(uint _rateEth) external onlyOracle {\n', '        rateEth = _rateEth;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to set current token price\n', '    *   @param _numerator       human token per usd numerator\n', '    *   @param _denominator     human token per usd denominator\n', '    */\n', '    function setPrice(uint _numerator, uint _denominator) external onlyOracle {\n', '        tokenPerUsdNumerator = _numerator;\n', '        tokenPerUsdDenominator = _denominator;\n', '    }\n', '    \n', '\n', '   /**\n', '    *   @dev Function to issues tokens for investors who made purchases in other cryptocurrencies\n', '    *   @param _holder        address the tokens will be issued to\n', '    *   @param _humanValue    number of Human tokens\n', '    *   @param _txHash        transaction hash of investor&#39;s payment\n', '    */\n', '\n', '    function buyForInvestor(\n', '        address _holder, \n', '        uint _humanValue, \n', '        string _txHash\n', '    ) \n', '        external \n', '        onlyControllers {\n', '        buy(_holder, _humanValue);\n', '        LogBuyForInvestor(_holder, _humanValue, _txHash);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to issue tokens for investors who paid in ether\n', '    *   @param _holder         address which the tokens will be issued tokens\n', '    *   @param _humanValue     number of Human tokens\n', '    */\n', '    function buy(address _holder, uint _humanValue) internal {\n', '        require(status == Status.firstStage || status == Status.secondStage);\n', '        if (status == Status.firstStage) {\n', '            require(firstStageRaised + _humanValue <= firstStageCap);\n', '            firstStageRaised = firstStageRaised.add(_humanValue);\n', '        } else {\n', '            require(secondStageRaised + _humanValue <= secondStageCap);\n', '            secondStageRaised = secondStageRaised.add(_humanValue);            \n', '        }\n', '        Human.mintTokens(_holder, _humanValue);\n', '    }\n', '\n', '\n', '  /**\n', '   * @dev Function to add an address to the controllers\n', '   * @param _controller         an address that will be added to managers list\n', '   */\n', '    function addController(address _controller) onlyOwner external {\n', '        require(!isController[_controller]);\n', '        isController[_controller] = true;\n', '        ControllerAdded(_controller);\n', '    }\n', '\n', '  /**\n', '   * @dev Function to remove an address to the controllers\n', '   * @param _controller         an address that will be removed from managers list\n', '   */\n', '    function removeController(address _controller) onlyOwner external {\n', '        require(isController[_controller]);\n', '        isController[_controller] = false;\n', '        ControllerRemoved(_controller);\n', '    }\n', '\n', ' /**\n', '   * @dev Function to start the first stage of human token allocation\n', '   *      and to issue human token for team fund\n', '   */\n', '    function startFirstStage() public onlyOwner {\n', '        require(status == Status.Created);\n', '        Human.mintTokens(teamFund, teamPart);\n', '        status = Status.firstStage;\n', '        FirstStageStarted(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to start the second stage of human token allocation\n', '   */\n', '    function startSecondStage() public onlyOwner {\n', '        require(status == Status.firstStage);\n', '        status = Status.secondStage;\n', '        SecondStageStarted(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to finish human token allocation and to finish token issue\n', '   */\n', '    function finish() public onlyOwner {\n', '        require (status == Status.secondStage);\n', '        status = Status.Finished;\n', '        AllocationFinished(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to enable public token allocation\n', '   */\n', '    function enable() public onlyOwner {\n', '        publicAllocationEnabled = true;\n', '        PublicAllocationEnabled(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to disable public token allocation\n', '   */\n', '    function disable() public onlyOwner {\n', '        publicAllocationEnabled = false;\n', '        PublicAllocationDisabled(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to withdraw ether\n', '   */    \n', '    function withdraw() external onlyOwner {\n', '        company.transfer(address(this).balance);\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner\n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }      \n', '}\n', '\n', '/**\n', ' *   @title HumanToken\n', ' *   @dev Human token smart-contract\n', ' */\n', 'contract HumanToken is ERC20 {\n', '    using SafeMath for uint;\n', '    string public name = "Human";\n', '    string public symbol = "Human";\n', '    uint public decimals = 18;\n', '    uint public voteCost = 10**18;\n', '\n', '    // Owner address\n', '    address public owner;\n', '    address public eventManager;\n', '\n', '    mapping (address => bool) isActiveEvent;\n', '            \n', '    //events        \n', '    event EventAdded(address _event);\n', '    event Contribute(address _event, address _contributor, uint _amount);\n', '    event Vote(address _event, address _contributor, bool _proposal);\n', '    \n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the event manager only\n', '    modifier onlyEventManager {\n', '        require(msg.sender == eventManager);\n', '        _;\n', '    }\n', '\n', '   // Allows contributing and voting only to human events \n', '    modifier onlyActive(address _event) {\n', '        require(isActiveEvent[_event]);\n', '        _;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets owner address\n', '    *   @param _owner        owner address\n', '    */\n', '    function HumanToken(address _owner, address _eventManager) public {\n', '       owner = _owner;\n', '       eventManager = _eventManager;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Function to add a new event from TheHuman team\n', '    *   @param _event       a new event address\n', '    */   \n', '    function  addEvent(address _event) external onlyEventManager {\n', '        require (!isActiveEvent[_event]);\n', '        isActiveEvent[_event] = true;\n', '        EventAdded(_event);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to change vote cost, by default vote cost equals 1 Human token\n', '    *   @param _voteCost     a new vote cost\n', '    */\n', '    function setVoteCost(uint _voteCost) external onlyEventManager {\n', '        voteCost = _voteCost;\n', '    }\n', '    \n', '   /**\n', '    *   @dev Function to donate for event\n', '    *   @param _event     address of event\n', '    *   @param _amount    donation amount    \n', '    */\n', '    function donate(address _event, uint _amount) public onlyActive(_event) {\n', '        require (transfer(_event, _amount));\n', '        require (HumanEvent(_event).contribute(msg.sender, _amount));\n', '        Contribute(_event, msg.sender, _amount);\n', '        \n', '    }\n', '\n', '   /**\n', '    *   @dev Function voting for the success of the event\n', '    *   @param _event     address of event\n', '    *   @param _proposal  true - event completed successfully, false - otherwise\n', '    */\n', '    function vote(address _event, bool _proposal) public onlyActive(_event) {\n', '        require(transfer(_event, voteCost));\n', '        require(HumanEvent(_event).vote(msg.sender, _proposal));\n', '        Vote(_event, msg.sender, _proposal);\n', '    }\n', '    \n', '    \n', '\n', '\n', '   /**\n', '    *   @dev Function to mint tokens\n', '    *   @param _holder       beneficiary address the tokens will be issued to\n', '    *   @param _value        number of tokens to issue\n', '    */\n', '    function mintTokens(address _holder, uint _value) external onlyOwner {\n', '       require(_value > 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '  \n', '   /**\n', '    *   @dev Get balance of tokens holder\n', '    *   @param _holder        holder&#39;s address\n', '    *   @return               balance of investor\n', '    */\n', '    function balanceOf(address _holder) constant returns (uint) {\n', '         return balances[_holder];\n', '    }\n', '\n', '   /**\n', '    *   @dev Send coins\n', '    *   throws on any error rather then return a false flag to minimize\n', '    *   user errors\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev An account/contract attempts to get the coins\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   @param _from         source address\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Allows another account/contract to spend some tokens on its behalf\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   also, to minimize the risk of the approve/transferFrom attack vector\n', '    *   approve has to be called twice in 2 separate transactions - once to\n', '    *   change the allowance to 0 and secondly to change it to the new allowance\n', '    *   value\n', '    *\n', '    *   @param _spender      approved address\n', '    *   @param _amount       allowance amount\n', '    *\n', '    *   @return true if the approval was successful\n', '    */\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    *   @param _owner        the address which owns the funds\n', '    *   @param _spender      the address which will spend the funds\n', '    *\n', '    *   @return              the amount of tokens still avaible for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner \n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', ' contract HumanEvent {\n', '    using SafeMath for uint;    \n', '    uint public totalRaised;\n', '    uint public softCap;\n', '    uint public positiveVotes;\n', '    uint public negativeVotes;\n', '\n', '    address public alternative;\n', '    address public owner;\n', '    HumanToken public human;\n', '\n', '    mapping (address => uint) public contributions;\n', '    mapping (address => bool) public voted;\n', '    mapping (address => bool) public claimed;\n', '    \n', '\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyHuman {\n', '        require(msg.sender == address(human));\n', '        _;\n', '    }\n', '\n', '\n', '    // Possible Event statuses\n', '    enum StatusEvent {\n', '        Created,\n', '        Fundraising,\n', '        Failed,\n', '        Evaluating,\n', '        Voting,\n', '        Finished\n', '    }\n', '    StatusEvent public statusEvent = StatusEvent.Created;\n', '\n', '    \n', '    function HumanEvent(\n', '        address _owner, \n', '        uint _softCap,\n', '        address _alternative,\n', '        address _human\n', '    ) public {\n', '        owner = _owner;\n', '        softCap = _softCap;\n', '        alternative = _alternative;\n', '        human = HumanToken(_human);\n', '    }\n', '\n', '    function startFundraising() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Created);\n', '        statusEvent = StatusEvent.Fundraising;\n', '        \n', '    }\n', '    \n', '\n', '    function startEvaluating() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Fundraising);\n', '        \n', '        if (totalRaised >= softCap) {\n', '            statusEvent = StatusEvent.Evaluating;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '\n', '    function startVoting() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Evaluating);\n', '        statusEvent = StatusEvent.Voting;\n', '    }\n', '\n', '    function finish() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Voting);\n', '        if (positiveVotes >= negativeVotes) {\n', '            statusEvent = StatusEvent.Finished;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '    \n', '    \n', '    function claim() public {\n', '        require(!claimed[msg.sender]);        \n', '        claimed[msg.sender] = true;\n', '        uint contribution;\n', '\n', '        if (statusEvent == StatusEvent.Failed) {\n', '            contribution = contribution.add(contributions[msg.sender]);\n', '            contributions[msg.sender] = 0;\n', '        }\n', '\n', '        if(voted[msg.sender] && statusEvent != StatusEvent.Voting) {\n', '            uint _voteCost = human.voteCost();\n', '            contribution = contribution.add(_voteCost);\n', '        }\n', '        require(contribution > 0);\n', '        require(human.transfer(msg.sender, contribution));\n', '    }\n', '\n', '    \n', '    function vote(address _voter, bool _proposal) external onlyHuman returns (bool) {\n', '        require(!voted[_voter] && statusEvent == StatusEvent.Voting);\n', '        voted[_voter] = true;\n', '        \n', '        if (_proposal) {\n', '            positiveVotes++;\n', '        } else {\n', '            negativeVotes++;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function contribute(address _contributor, uint _amount) external onlyHuman returns(bool) {\n', '        require (statusEvent == StatusEvent.Fundraising);\n', '        contributions[_contributor] =  contributions[_contributor].add(_amount);\n', '        totalRaised = totalRaised.add(_amount);\n', '        return true;\n', '    }\n', '    \n', '    function  withdraw() external onlyOwner {\n', '        require (statusEvent == StatusEvent.Finished);\n', '        require (human.transfer(alternative, totalRaised));\n', '    }\n', '\n', '}']
['// Human token smart contract.\n', '// Developed by Phenom.Team <info@phenom.team>\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' *   @title SafeMath\n', ' *   @dev Math operations with safety checks that throw on error\n', ' */\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal constant returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal constant returns(uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal constant returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal constant returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' *   @title ERC20\n', ' *   @dev Standart ERC20 token interface\n', ' */\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '}\n', '\n', ' /**\n', ' *   @title HumanTokenAllocator contract  -  issues Human tokens\n', ' */\n', 'contract HumanTokenAllocator {\n', '    using SafeMath for uint;\n', '    HumanToken public Human;\n', '    uint public rateEth = 700; // Rate USD per ETH\n', '    uint public tokenPerUsdNumerator = 1;\n', '    uint public tokenPerUsdDenominator = 1;\n', '    uint public firstStageRaised;\n', '    uint public secondStageRaised;\n', '    uint public firstStageCap = 7*10**24;\n', '    uint public secondStageCap = 32*10**24;\n', '    uint public FIFTY_THOUSANDS_LIMIT = 5*10**22;\n', '    uint teamPart = 7*10**24;\n', '\n', '    bool public publicAllocationEnabled;\n', '\n', '    address public teamFund;\n', '    address public owner;\n', '    address public oracle; // Oracle address\n', '    address public company;\n', '\n', '    event LogBuyForInvestor(address investor, uint humanValue, string txHash);\n', '    event ControllerAdded(address _controller);\n', '    event ControllerRemoved(address _controller);\n', '    event FirstStageStarted(uint _timestamp);\n', '    event SecondStageStarted(uint _timestamp);\n', '    event AllocationFinished(uint _timestamp);\n', '    event PublicAllocationEnabled(uint _timestamp);\n', '    event PublicAllocationDisabled(uint _timestamp);\n', '\n', '    mapping(address => bool) public isController;\n', '\n', '    // Allows execution by the owner only     \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the oracle only\n', '    modifier onlyOracle { \n', '        require(msg.sender == oracle);\n', '        _; \n', '    }\n', '\n', '    // Allows execution by the controllers only\n', '    modifier onlyControllers { \n', '        require(isController[msg.sender]);\n', '        _; \n', '    }\n', '\n', '    // Possible statuses\n', '    enum Status {\n', '        Created,\n', '        firstStage,\n', '        secondStage,\n', '        Finished\n', '    }\n', '\n', '    Status public status = Status.Created;\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets outside addresses\n', '    */\n', '    function HumanTokenAllocator(\n', '        address _owner,\n', '        address _oracle,\n', '        address _company,\n', '        address _teamFund,\n', '        address _eventManager\n', '    ) public {\n', '        owner = _owner;\n', '        oracle = _oracle;\n', '        company = _company;\n', '        teamFund = _teamFund;\n', '        Human = new HumanToken(address(this), _eventManager);\n', '    }   \n', '\n', '   /**\n', '    *   @dev Fallback function calls buy(address _holder, uint _humanValue) function to issue tokens\n', '    */\n', '    function() external payable {\n', '        require(publicAllocationEnabled);\n', '        uint humanValue = msg.value.mul(rateEth).mul(tokenPerUsdNumerator).div(tokenPerUsdDenominator);\n', '        if (status == Status.secondStage) {\n', '            require(humanValue >= FIFTY_THOUSANDS_LIMIT);\n', '        } \n', '        buy(msg.sender, humanValue);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to set rate of ETH\n', '    *   @param _rateEth       current ETH rate\n', '    */\n', '    function setRate(uint _rateEth) external onlyOracle {\n', '        rateEth = _rateEth;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to set current token price\n', '    *   @param _numerator       human token per usd numerator\n', '    *   @param _denominator     human token per usd denominator\n', '    */\n', '    function setPrice(uint _numerator, uint _denominator) external onlyOracle {\n', '        tokenPerUsdNumerator = _numerator;\n', '        tokenPerUsdDenominator = _denominator;\n', '    }\n', '    \n', '\n', '   /**\n', '    *   @dev Function to issues tokens for investors who made purchases in other cryptocurrencies\n', '    *   @param _holder        address the tokens will be issued to\n', '    *   @param _humanValue    number of Human tokens\n', "    *   @param _txHash        transaction hash of investor's payment\n", '    */\n', '\n', '    function buyForInvestor(\n', '        address _holder, \n', '        uint _humanValue, \n', '        string _txHash\n', '    ) \n', '        external \n', '        onlyControllers {\n', '        buy(_holder, _humanValue);\n', '        LogBuyForInvestor(_holder, _humanValue, _txHash);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to issue tokens for investors who paid in ether\n', '    *   @param _holder         address which the tokens will be issued tokens\n', '    *   @param _humanValue     number of Human tokens\n', '    */\n', '    function buy(address _holder, uint _humanValue) internal {\n', '        require(status == Status.firstStage || status == Status.secondStage);\n', '        if (status == Status.firstStage) {\n', '            require(firstStageRaised + _humanValue <= firstStageCap);\n', '            firstStageRaised = firstStageRaised.add(_humanValue);\n', '        } else {\n', '            require(secondStageRaised + _humanValue <= secondStageCap);\n', '            secondStageRaised = secondStageRaised.add(_humanValue);            \n', '        }\n', '        Human.mintTokens(_holder, _humanValue);\n', '    }\n', '\n', '\n', '  /**\n', '   * @dev Function to add an address to the controllers\n', '   * @param _controller         an address that will be added to managers list\n', '   */\n', '    function addController(address _controller) onlyOwner external {\n', '        require(!isController[_controller]);\n', '        isController[_controller] = true;\n', '        ControllerAdded(_controller);\n', '    }\n', '\n', '  /**\n', '   * @dev Function to remove an address to the controllers\n', '   * @param _controller         an address that will be removed from managers list\n', '   */\n', '    function removeController(address _controller) onlyOwner external {\n', '        require(isController[_controller]);\n', '        isController[_controller] = false;\n', '        ControllerRemoved(_controller);\n', '    }\n', '\n', ' /**\n', '   * @dev Function to start the first stage of human token allocation\n', '   *      and to issue human token for team fund\n', '   */\n', '    function startFirstStage() public onlyOwner {\n', '        require(status == Status.Created);\n', '        Human.mintTokens(teamFund, teamPart);\n', '        status = Status.firstStage;\n', '        FirstStageStarted(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to start the second stage of human token allocation\n', '   */\n', '    function startSecondStage() public onlyOwner {\n', '        require(status == Status.firstStage);\n', '        status = Status.secondStage;\n', '        SecondStageStarted(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to finish human token allocation and to finish token issue\n', '   */\n', '    function finish() public onlyOwner {\n', '        require (status == Status.secondStage);\n', '        status = Status.Finished;\n', '        AllocationFinished(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to enable public token allocation\n', '   */\n', '    function enable() public onlyOwner {\n', '        publicAllocationEnabled = true;\n', '        PublicAllocationEnabled(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to disable public token allocation\n', '   */\n', '    function disable() public onlyOwner {\n', '        publicAllocationEnabled = false;\n', '        PublicAllocationDisabled(now);\n', '    }\n', '\n', '  /**  \n', '   * @dev Function to withdraw ether\n', '   */    \n', '    function withdraw() external onlyOwner {\n', '        company.transfer(address(this).balance);\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner\n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }      \n', '}\n', '\n', '/**\n', ' *   @title HumanToken\n', ' *   @dev Human token smart-contract\n', ' */\n', 'contract HumanToken is ERC20 {\n', '    using SafeMath for uint;\n', '    string public name = "Human";\n', '    string public symbol = "Human";\n', '    uint public decimals = 18;\n', '    uint public voteCost = 10**18;\n', '\n', '    // Owner address\n', '    address public owner;\n', '    address public eventManager;\n', '\n', '    mapping (address => bool) isActiveEvent;\n', '            \n', '    //events        \n', '    event EventAdded(address _event);\n', '    event Contribute(address _event, address _contributor, uint _amount);\n', '    event Vote(address _event, address _contributor, bool _proposal);\n', '    \n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the event manager only\n', '    modifier onlyEventManager {\n', '        require(msg.sender == eventManager);\n', '        _;\n', '    }\n', '\n', '   // Allows contributing and voting only to human events \n', '    modifier onlyActive(address _event) {\n', '        require(isActiveEvent[_event]);\n', '        _;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets owner address\n', '    *   @param _owner        owner address\n', '    */\n', '    function HumanToken(address _owner, address _eventManager) public {\n', '       owner = _owner;\n', '       eventManager = _eventManager;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Function to add a new event from TheHuman team\n', '    *   @param _event       a new event address\n', '    */   \n', '    function  addEvent(address _event) external onlyEventManager {\n', '        require (!isActiveEvent[_event]);\n', '        isActiveEvent[_event] = true;\n', '        EventAdded(_event);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to change vote cost, by default vote cost equals 1 Human token\n', '    *   @param _voteCost     a new vote cost\n', '    */\n', '    function setVoteCost(uint _voteCost) external onlyEventManager {\n', '        voteCost = _voteCost;\n', '    }\n', '    \n', '   /**\n', '    *   @dev Function to donate for event\n', '    *   @param _event     address of event\n', '    *   @param _amount    donation amount    \n', '    */\n', '    function donate(address _event, uint _amount) public onlyActive(_event) {\n', '        require (transfer(_event, _amount));\n', '        require (HumanEvent(_event).contribute(msg.sender, _amount));\n', '        Contribute(_event, msg.sender, _amount);\n', '        \n', '    }\n', '\n', '   /**\n', '    *   @dev Function voting for the success of the event\n', '    *   @param _event     address of event\n', '    *   @param _proposal  true - event completed successfully, false - otherwise\n', '    */\n', '    function vote(address _event, bool _proposal) public onlyActive(_event) {\n', '        require(transfer(_event, voteCost));\n', '        require(HumanEvent(_event).vote(msg.sender, _proposal));\n', '        Vote(_event, msg.sender, _proposal);\n', '    }\n', '    \n', '    \n', '\n', '\n', '   /**\n', '    *   @dev Function to mint tokens\n', '    *   @param _holder       beneficiary address the tokens will be issued to\n', '    *   @param _value        number of tokens to issue\n', '    */\n', '    function mintTokens(address _holder, uint _value) external onlyOwner {\n', '       require(_value > 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '  \n', '   /**\n', '    *   @dev Get balance of tokens holder\n', "    *   @param _holder        holder's address\n", '    *   @return               balance of investor\n', '    */\n', '    function balanceOf(address _holder) constant returns (uint) {\n', '         return balances[_holder];\n', '    }\n', '\n', '   /**\n', '    *   @dev Send coins\n', '    *   throws on any error rather then return a false flag to minimize\n', '    *   user errors\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev An account/contract attempts to get the coins\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   @param _from         source address\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Allows another account/contract to spend some tokens on its behalf\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   also, to minimize the risk of the approve/transferFrom attack vector\n', '    *   approve has to be called twice in 2 separate transactions - once to\n', '    *   change the allowance to 0 and secondly to change it to the new allowance\n', '    *   value\n', '    *\n', '    *   @param _spender      approved address\n', '    *   @param _amount       allowance amount\n', '    *\n', '    *   @return true if the approval was successful\n', '    */\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    *   @param _owner        the address which owns the funds\n', '    *   @param _spender      the address which will spend the funds\n', '    *\n', '    *   @return              the amount of tokens still avaible for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner \n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', ' contract HumanEvent {\n', '    using SafeMath for uint;    \n', '    uint public totalRaised;\n', '    uint public softCap;\n', '    uint public positiveVotes;\n', '    uint public negativeVotes;\n', '\n', '    address public alternative;\n', '    address public owner;\n', '    HumanToken public human;\n', '\n', '    mapping (address => uint) public contributions;\n', '    mapping (address => bool) public voted;\n', '    mapping (address => bool) public claimed;\n', '    \n', '\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyHuman {\n', '        require(msg.sender == address(human));\n', '        _;\n', '    }\n', '\n', '\n', '    // Possible Event statuses\n', '    enum StatusEvent {\n', '        Created,\n', '        Fundraising,\n', '        Failed,\n', '        Evaluating,\n', '        Voting,\n', '        Finished\n', '    }\n', '    StatusEvent public statusEvent = StatusEvent.Created;\n', '\n', '    \n', '    function HumanEvent(\n', '        address _owner, \n', '        uint _softCap,\n', '        address _alternative,\n', '        address _human\n', '    ) public {\n', '        owner = _owner;\n', '        softCap = _softCap;\n', '        alternative = _alternative;\n', '        human = HumanToken(_human);\n', '    }\n', '\n', '    function startFundraising() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Created);\n', '        statusEvent = StatusEvent.Fundraising;\n', '        \n', '    }\n', '    \n', '\n', '    function startEvaluating() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Fundraising);\n', '        \n', '        if (totalRaised >= softCap) {\n', '            statusEvent = StatusEvent.Evaluating;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '\n', '    function startVoting() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Evaluating);\n', '        statusEvent = StatusEvent.Voting;\n', '    }\n', '\n', '    function finish() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Voting);\n', '        if (positiveVotes >= negativeVotes) {\n', '            statusEvent = StatusEvent.Finished;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '    \n', '    \n', '    function claim() public {\n', '        require(!claimed[msg.sender]);        \n', '        claimed[msg.sender] = true;\n', '        uint contribution;\n', '\n', '        if (statusEvent == StatusEvent.Failed) {\n', '            contribution = contribution.add(contributions[msg.sender]);\n', '            contributions[msg.sender] = 0;\n', '        }\n', '\n', '        if(voted[msg.sender] && statusEvent != StatusEvent.Voting) {\n', '            uint _voteCost = human.voteCost();\n', '            contribution = contribution.add(_voteCost);\n', '        }\n', '        require(contribution > 0);\n', '        require(human.transfer(msg.sender, contribution));\n', '    }\n', '\n', '    \n', '    function vote(address _voter, bool _proposal) external onlyHuman returns (bool) {\n', '        require(!voted[_voter] && statusEvent == StatusEvent.Voting);\n', '        voted[_voter] = true;\n', '        \n', '        if (_proposal) {\n', '            positiveVotes++;\n', '        } else {\n', '            negativeVotes++;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function contribute(address _contributor, uint _amount) external onlyHuman returns(bool) {\n', '        require (statusEvent == StatusEvent.Fundraising);\n', '        contributions[_contributor] =  contributions[_contributor].add(_amount);\n', '        totalRaised = totalRaised.add(_amount);\n', '        return true;\n', '    }\n', '    \n', '    function  withdraw() external onlyOwner {\n', '        require (statusEvent == StatusEvent.Finished);\n', '        require (human.transfer(alternative, totalRaised));\n', '    }\n', '\n', '}']
