['pragma solidity ^0.4.18;\n', '\n', '/**\n', '* A contract that pays off, if a user is able to produce a valid solution\n', "* for the Fermat's last theorem\n", '*/\n', '\n', 'contract Fermat {\n', '\n', '    /**\n', '    *  The owner is the creator of the contract.\n', '\n', '    *  The owner will be able to withdraw the\n', '    *  bounty after the releaseTime has passed.\n', '\n', '    *  The release time is set to 17280000 seconds (= 200 days)\n', '    *  in the future from the timestamp of the contract creation\n', '    */\n', '    address public owner = msg.sender;\n', '    uint releaseTime = now + 17280000;\n', '\n', '    /**\n', '    * This function is used to increase the bounty\n', '    */\n', '    function addBalance() public payable {\n', '\n', '    }\n', '\n', '    function getOwner() view public returns (address)  {\n', '        return owner;\n', '    }\n', '\n', '    /*\n', '    * Returns the time when it is possible for the owner\n', '    * to withdraw the deposited funds from the contract.\n', '    */\n', '    function getReleaseTime() view public returns (uint)  {\n', '        return releaseTime;\n', '    }\n', '\n', '    /**\n', '     * Allow the owner of the contract to\n', '     * withdraw the bounty after the release time has passed\n', '     */\n', '    function withdraw() public {\n', '        require(msg.sender == owner);\n', '        require(now >= releaseTime);\n', '\n', '        msg.sender.transfer(this.balance);\n', '    }\n', '\n', '    function getBalance() view public returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    /**\n', '     * The function that is used to claim the bounty.\n', '     * If the caller is able to provide satisfying values for a,b,c and n\n', '     * the balance of the contract (the bounty) is transferred to the caller\n', '    */\n', '    function claim(int256 a, int256 b, int256 c, int256 n) public {\n', '        uint256 value = solve(a, b, c, n);\n', '        if (value == 0) {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    /*\n', '     * The "core" logic of the smart contract.\n', "     * Calculates the equation with provided values for Fermat's last theorem.\n", '     * Returns the value of a^n + b^n - c^n, n > 2\n', '     */\n', '    function solve(int256 a, int256 b, int256 c, int256 n) pure public returns (uint256) {\n', '        assert(n > 2);\n', '        assert(a > 0);\n', '        assert(b > 0);\n', '        assert(c > 0);\n', '        uint256 aExp = power(a, n);\n', '        uint256 bExp = power(b, n);\n', '        uint256 cExp = power(c, n);\n', '\n', '        uint256 sum = add(aExp, bExp);\n', '        uint256 difference = sub(sum, cExp);\n', '        return difference;\n', '    }\n', '\n', '    /*\n', '     A safe way to handle exponentiation. Throws error on overflow.\n', '    */\n', '    function power(int256 a, int256 pow)  pure public returns (uint256) {\n', '        assert(a >= 0);\n', '        assert(pow >= 0);\n', '        int256 result = 1;\n', '        if(a == 0) {\n', '            return 1;\n', '        }\n', '        for (int256 i = 0; i < pow; i++) {\n', '            result = result * a;\n', '            assert(result >= a);\n', '        }\n', '        return uint256(result);\n', '    }\n', '\n', '    /*\n', '     A safe way to handle addition. Throws error on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /*\n', '     A safe way to handle subtraction. Throws error on underflow.\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '}']