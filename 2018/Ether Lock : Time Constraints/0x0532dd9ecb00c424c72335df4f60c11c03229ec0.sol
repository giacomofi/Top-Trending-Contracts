['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract token {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function setStartTime(uint _startTime) external;\n', '}\n', '\n', '/**\n', ' * @title Obirum Crowdsale\n', ' */\n', 'contract ObirumCrowdsale{\n', '    using SafeMath for uint256;\n', '\n', '    /** Constants\n', '    * ----------\n', '    * kRate - Ether to Obirum rate. 1 ether is 20000 tokens.\n', '    * kMinStake - Min amount of Ether that can be contributed.\n', '    * kMaxStake - Max amount of Ether that can be contributed.\n', '    */\n', '    uint256 public constant kRate = 20000;\n', '    uint256 public constant kMinStake = 0.1 ether;\n', '    uint256 public constant kMaxStake = 200 ether;\n', '\n', '    uint256[9] internal stageLimits = [\n', '        100 ether,\n', '        300 ether,\n', '        1050 ether,\n', '        3050 ether,\n', '        8050 ether,\n', '        18050 ether,\n', '        28050 ether,\n', '        38050 ether,\n', '        48050 ether\n', '    ];\n', '    uint128[9] internal stageDiscounts = [\n', '        300,\n', '        250,\n', '        200,\n', '        150,\n', '        135,\n', '        125,\n', '        115,\n', '        110,\n', '        105\n', '    ];\n', '\n', '    // Investor contributions\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 public weiRaised;\n', '    uint8 public currentStage = 0;\n', '\n', '    // The token being sold\n', '    token public reward;\n', '\n', '    // Owner of the token\n', '    address public owner;\n', '\n', '    // Start and end timestamps\n', '    uint public startTime;\n', '    uint public endTime;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // Amount of tokens that were sold\n', '    uint256 public tokensSold;\n', '\n', '    // Soft cap in OBR tokens\n', '    uint256 constant public softCap = 106000000 * (10**18);\n', '\n', '    // Hard cap in OBR tokens\n', '    uint256 constant public hardCap = 1151000000 * (10**18);\n', '\n', '    // Switched to true once token contract is notified of when to enable token transfers\n', '    bool private isStartTimeSet = false;\n', '\n', '    /**\n', '     * @dev Event for token purchase logging\n', '     * @param purchaser Address that paid for the tokens\n', '     * @param beneficiary Address that got the tokens\n', '     * @param value The amount that was paid (in wei)\n', '     * @param amount The amount of tokens that were bought\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    /**\n', '     * @dev Event for refund logging\n', '     * @param receiver The address that received the refund\n', '     * @param amount The amount that is being refunded (in wei)\n', '     */\n', '    event Refund(address indexed receiver, uint256 amount);\n', '\n', '    /**\n', '     * @param _startTime Unix timestamp for the start of the token sale\n', '     * @param _endTime Unix timestamp for the end of the token sale\n', '     * @param _wallet Ethereum address to which the invested funds are forwarded\n', '     * @param _token Address of the token that will be rewarded for the investors\n', '     * @param _owner Address of the owner of the smart contract who can execute restricted functions\n', '     */\n', '    function ObirumCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _owner)  public {\n', '        require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '        require(_owner != address(0));\n', '\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        wallet = _wallet;\n', '        owner = _owner;\n', '        reward = token(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function that can be used to buy tokens. Or in case of the owner, return ether to allow refunds.\n', '     */\n', '    function () external payable {\n', '        if(msg.sender == wallet) {\n', '            require(hasEnded() && tokensSold < softCap);\n', '        } else {\n', '            buyTokens(msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function for buying tokens\n', '     * @param beneficiary The address that should receive bought tokens\n', '     */\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != address(0));\n', '        require(validPurchase());\n', '        require(currentStage < getStageCount());\n', '        \n', '        uint256 value = msg.value;\n', '        weiRaised = weiRaised.add(value);\n', '        uint256 limit = getStageLimit(currentStage);\n', '        uint256 dif = 0;\n', '        uint256 returnToSender = 0;\n', '    \n', '        if(weiRaised > limit){\n', '            dif = weiRaised.sub(limit);\n', '            value = value.sub(dif);\n', '            \n', '            if(currentStage == getStageCount() - 1){\n', '                returnToSender = dif;\n', '                weiRaised = weiRaised.sub(dif);\n', '                dif = 0;\n', '            }\n', '        }\n', '        \n', '        mintTokens(value, beneficiary);\n', '        \n', '        if(dif > 0){\n', '            currentStage = currentStage + 1;\n', '            mintTokens(dif, beneficiary);\n', '        }\n', '\n', '        // Allow transfers 2 weeks after hard cap is reached\n', '        if(tokensSold == hardCap) {\n', '            reward.setStartTime(now + 2 weeks);\n', '        }\n', '\n', '        // // Return funds that are over hard cap\n', '        if(returnToSender > 0) {\n', '            msg.sender.transfer(returnToSender);\n', '        }\n', '    }\n', '    \n', '    function mintTokens(uint256 value, address sender) private{\n', '        uint256 tokens = value.mul(kRate).mul(getStageDiscount(currentStage)).div(100);\n', '        \n', '        // update state\n', '        tokensSold = tokensSold.add(tokens);\n', '        \n', '        // update balance\n', '        balances[sender] = balances[sender].add(value);\n', '        reward.transferFrom(owner, sender, tokens);\n', '        \n', '        TokenPurchase(msg.sender, sender, value, tokens);\n', '        \n', '        // Forward funds\n', '        wallet.transfer(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that is used to check if the incoming purchase should be accepted.\n', '     * @return True if the transaction can buy tokens\n', '     */\n', '    function validPurchase() internal constant returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0 && msg.value >= kMinStake && msg.value <= kMaxStake;\n', '        bool hardCapNotReached = tokensSold < hardCap;\n', '        return withinPeriod && nonZeroPurchase && hardCapNotReached;\n', '    }\n', '\n', '    /**\n', '     * @return True if crowdsale event has ended\n', '     */\n', '    function hasEnded() public constant returns (bool) {\n', '        return now > endTime || tokensSold >= hardCap;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns ether to token holders in case soft cap is not reached.\n', '     */\n', '    function claimRefund() external {\n', '        require(hasEnded());\n', '        require(tokensSold < softCap);\n', '\n', '        uint256 amount = balances[msg.sender];\n', '\n', '        if(address(this).balance >= amount) {\n', '            balances[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                msg.sender.transfer(amount);\n', '                Refund(msg.sender, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function getStageLimit(uint8 _stage) public view returns (uint256) {\n', '        return stageLimits[_stage];\n', '    }\n', '\n', '    function getStageDiscount(uint8 _stage) public view returns (uint128) {\n', '        return stageDiscounts[_stage];\n', '    }\n', '\n', '    function getStageCount() public view returns (uint8) {\n', '        return uint8(stageLimits.length);\n', '    }\n', '}']