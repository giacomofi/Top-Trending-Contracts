['pragma solidity ^0.5.1;\n', '\n', '/**\n', ' *  X3ProfitInMonthV4 contract (300% per 33 day, 99% per 11 day, 9% per day, in first iteration)\n', ' *  This percent will decrease every restart of system to lowest value of 0.9% per day\n', ' *\n', ' *  Improved, no bugs and backdoors! Your investments are safe!\n', ' *\n', ' *  LOW RISK! You can take your deposit back ANY TIME!\n', ' *     - Send 0.00000112 ETH to contract address\n', ' *\n', ' *  NO DEPOSIT FEES! All the money go to contract!\n', ' *\n', ' *  LOW WITHDRAWAL FEES! Advertising 10% to OUR MAIN CONTRACT 0xf85D337017D9e6600a433c5036E0D18EdD0380f3\n', ' *\n', ' *  HAVE COMMAND PREPARATION TIME DURING IT WILL BE RETURN ONLY INVESTED AMOUNT AND NOT MORE!\n', ' *  Only special command will run X3 MODE!\n', ' * \n', ' *  After restart system automaticaly make deposits for damage users in damaged part, \n', ' *   but before it users must self make promotion deposit by any amount first.\n', ' *\n', ' *  INSTRUCTIONS:\n', ' *\n', ' *  TO INVEST: send ETH to contract address.\n', ' *  TO WITHDRAW INTEREST: send 0 ETH to contract address.\n', ' *  TO REINVEST AND WITHDRAW INTEREST: send ETH to contract address.\n', ' *  TO GET BACK YOUR DEPOSIT: send 0.00000112 ETH to contract address.\n', ' *  TO START X3 WORK, ANY MEMBER CAN VOTE 0.00000111 ETH to contract address.\n', ' *     While X3 not started investors can return only their deposits and no profit.\n', ' *     Admin voice power is equal 10 simple participants.\n', ' *  TO RESTART, ANY MEMBER CAN VOTE 0.00000101 ETH to contract address.\n', ' *     Admin voice power is equal 10 simple participants.\n', ' *  TO VOICE FOR SEAL/UNSEAL CONTRACT, ADMIN CAN VOTE 0.00000102 ETH \n', ' *     to contract address.\n', ' * \n', ' *  Minimal investment is more than 0.000000001 ether, else if equal or smaller \n', ' *  then only withdrawn will performed\n', ' *\n', ' *  RECOMMENDED GAS LIMIT 350000\n', ' */\n', ' \n', 'contract X3ProfitInMonthV4 {\n', '\n', '\tstruct Investor {\n', '\t      // Restart iteration index\n', '\t\tint iteration;\n', '          // array containing information about beneficiaries\n', '\t\tuint deposit;\n', '\t\t  // sum locked to remove in predstart period, gived by contract for \n', '\t\t  // compensation of previous iteration restart\n', '\t\tuint lockedDeposit;\n', '           //array containing information about the time of payment\n', '\t\tuint time;\n', '          //array containing information on interest paid\n', '\t\tuint withdrawn;\n', '           //array containing information on interest paid (without tax)\n', '\t\tuint withdrawnPure;\n', '\t\t   // Vote system for start iteration\n', '\t\tbool isVoteProfit;\n', '\t\t   // Vote system for restart iteration\n', '\t\tbool isVoteRestart;\n', '           // Default at any deposit we debt to user\n', '        bool isWeHaveDebt;\n', '\t}\n', '\n', '    mapping(address => Investor) public investors;\n', '\t\n', '    //fund to transfer percent for MAIN OUR CONTRACT EasyInvestForeverProtected2\n', '    address payable public constant ADDRESS_MAIN_FUND = 0x3Bd33FF04e1F2BF01C8BF15C395D607100b7E116;\n', '    address payable public constant ADDRESS_ADMIN =     0x6249046Af9FB588bb4E70e62d9403DD69239bdF5;\n', '    //time through which you can take dividends\n', '    uint private constant TIME_QUANT = 1 days;\n', '\t\n', '    //start percent 10% per day\n', '    uint private constant PERCENT_DAY = 10;\n', '    uint private constant PERCENT_DECREASE_PER_ITERATION = 1;\n', '    uint private constant PERCENT_DECREASE_MINIMUM = 1;\n', '\n', '    //Adv tax for withdrawal 10%\n', '    uint private constant PERCENT_MAIN_FUND = 10;\n', '\n', '    //All percent should be divided by this\n', '    uint private constant PERCENT_DIVIDER = 100;\n', '\n', '    uint public countOfInvestors = 0;\n', '    uint public countOfAdvTax = 0;\n', '\tuint public countStartVoices = 0;\n', '\tuint public countReStartVoices = 0;\n', '\tint  public iterationIndex = 1;\n', '\tint  private undoDecreaseIteration = 0;\n', '\tuint public countOfReturnDebt = 0;\n', '\n', '\tuint public amountDebt = 0;\n', '\tuint public amountReturnDebt = 0;\n', '\tuint public amountOfCharity = 0;\n', '\n', '    // max contract balance in ether for overflow protection in calculations only\n', '    // 340 quintillion 282 quadrillion 366 trillion 920 billion 938 million 463 thousand 463\n', '\tuint public constant maxBalance = 340282366920938463463374607431768211456 wei; //(2^128) \n', '\tuint public constant maxDeposit = maxBalance / 1000; \n', '\t\n', '\t// X3 Mode status\n', '    bool public isProfitStarted = false; \n', '    bool public isContractSealed = false;\n', '\n', '    modifier isUserExists() {\n', '        require(investors[msg.sender].iteration == iterationIndex, "Deposit not found");\n', '        _;\n', '    }\n', '\n', '    modifier timePayment() {\n', '        require(isContractSealed || now >= investors[msg.sender].time + TIME_QUANT, "Too fast payout request");\n', '        _;\n', '    }\n', '\n', '    //return of interest on the deposit\n', '    function collectPercent() isUserExists timePayment internal {\n', '        uint payout = payoutAmount(msg.sender);\n', '        _payout(msg.sender, payout, false);\n', '    }\n', '    function dailyPercent() public view returns(uint) {\n', '        uint percent = PERCENT_DAY;\n', '\t\tint delta = 1 + undoDecreaseIteration;\n', '\t\tif (delta > iterationIndex) delta = iterationIndex;\n', '        uint decrease = PERCENT_DECREASE_PER_ITERATION * (uint)(iterationIndex - delta);\n', '        if(decrease > percent - PERCENT_DECREASE_MINIMUM)\n', '            decrease = percent - PERCENT_DECREASE_MINIMUM;\n', '        percent -= decrease;\n', '        return percent;\n', '    }\n', '\n', '    //calculate the amount available for withdrawal on deposit\n', '    function payoutAmount(address addr) public view returns(uint) {\n', '        Investor storage inv = investors[addr];\n', '        if(inv.iteration != iterationIndex)\n', '            return 0;\n', '        if (isContractSealed)\n', '        {\n', '            if(inv.withdrawnPure >= inv.deposit) {\n', '                uint delta = 0;\n', '                if(amountReturnDebt < amountDebt) delta = amountDebt - amountReturnDebt;\n', '                \n', '                // Sealed contract must transfer funds despite of complete debt payed\n', '                if(address(this).balance > delta) \n', '                    return address(this).balance - delta;\n', '                return 0;\n', '            }\n', '            uint amount = inv.deposit - inv.withdrawnPure;\n', '            return PERCENT_DIVIDER * amount / (PERCENT_DIVIDER - PERCENT_MAIN_FUND) + 1;\n', '        }\n', '        uint varTime = inv.time;\n', '        uint varNow = now;\n', '        if(varTime > varNow) varTime = varNow;\n', '        uint percent = dailyPercent();\n', '        uint rate = inv.deposit * percent / PERCENT_DIVIDER;\n', '        uint fraction = 100;\n', '        uint interestRate = fraction * (varNow  - varTime) / 1 days;\n', '        uint withdrawalAmount = rate * interestRate / fraction;\n', '        if(interestRate < fraction) withdrawalAmount = 0;\n', '        return withdrawalAmount;\n', '    }\n', '\n', '    //make a deposit\n', '    function makeDeposit() private {\n', '        if (msg.value > 0.000000001 ether) {\n', '            Investor storage inv = investors[msg.sender];\n', '            if (inv.iteration != iterationIndex) {\n', '\t\t\t    inv.iteration = iterationIndex;\n', '                countOfInvestors ++;\n', '                if(inv.deposit > inv.withdrawnPure)\n', '\t\t\t        inv.deposit -= inv.withdrawnPure;\n', '\t\t        else\n', '\t\t            inv.deposit = 0;\n', '\t\t        if(inv.deposit + msg.value > maxDeposit) \n', '\t\t            inv.deposit = maxDeposit - msg.value;\n', '\t\t\t\tinv.withdrawn = 0;\n', '\t\t\t\tinv.withdrawnPure = 0;\n', '\t\t\t\tinv.time = now;\n', '\t\t\t\tinv.lockedDeposit = inv.deposit;\n', '\t\t\t    amountDebt += inv.lockedDeposit;\n', '\t\t\t\t\n', '\t\t\t\tinv.isVoteProfit = false;\n', '\t\t\t\tinv.isVoteRestart = false;\n', '                inv.isWeHaveDebt = true;\n', '            }\n', '            if (!isContractSealed && now >= inv.time + TIME_QUANT) {\n', '                collectPercent();\n', '            }\n', '            if (!inv.isWeHaveDebt)\n', '            {\n', '                inv.isWeHaveDebt = true;\n', '                countOfReturnDebt--;\n', '                amountReturnDebt -= inv.deposit;\n', '            }\n', '            inv.deposit += msg.value;\n', '            amountDebt += msg.value;\n', '            \n', '        } else {\n', '            collectPercent();\n', '        }\n', '    }\n', '\n', '    //return of deposit balance\n', '    function returnDeposit() isUserExists private {\n', '        if(isContractSealed)return;\n', '        Investor storage inv = investors[msg.sender];\n', '        uint withdrawalAmount = 0;\n', '        uint activDep = inv.deposit - inv.lockedDeposit;\n', '        if(activDep > inv.withdrawn)\n', '            withdrawalAmount = activDep - inv.withdrawn;\n', '\n', '        if(withdrawalAmount > address(this).balance){\n', '            withdrawalAmount = address(this).balance;\n', '        }\n', '        //Pay the rest of deposit and take taxes\n', '        _payout(msg.sender, withdrawalAmount, true);\n', '\n', '        //delete user record\n', '        _delete(msg.sender);\n', '    }\n', '    function charityToContract() external payable {\n', '\t    amountOfCharity += msg.value;\n', '    }    \n', '    function() external payable {\n', '        if(msg.data.length > 0){\n', '    \t    amountOfCharity += msg.value;\n', '            return;        \n', '        }\n', '        require(msg.value <= maxDeposit, "Deposit overflow");\n', '        \n', '        //refund of remaining funds when transferring to a contract 0.00000112 ether\n', '        Investor storage inv = investors[msg.sender];\n', '        if (!isContractSealed &&\n', '            msg.value == 0.00000112 ether && inv.iteration == iterationIndex) {\n', '            inv.deposit += msg.value;\n', '            if(inv.deposit > maxDeposit) inv.deposit = maxDeposit;\n', '            returnDeposit();\n', '        } else {\n', '            //start/restart X3 Mode on 0.00000111 ether / 0.00000101 ether\n', '            if ((!isContractSealed &&\n', '                (msg.value == 0.00000111 ether || msg.value == 0.00000101 ether)) ||\n', '                (msg.value == 0.00000102 ether&&msg.sender == ADDRESS_ADMIN)) \n', '            {\n', '                if(inv.iteration != iterationIndex)\n', '                    makeDeposit();\n', '                else\n', '                    inv.deposit += msg.value;\n', '                if(inv.deposit > maxDeposit) inv.deposit = maxDeposit;\n', '                if(msg.value == 0.00000102 ether){\n', '                    isContractSealed = !isContractSealed;\n', '                    if (!isContractSealed)\n', '                    {\n', '                        undoDecreaseIteration++;\n', '                        restart();\n', '                    }\n', '                }\n', '                else\n', '                if(msg.value == 0.00000101 ether)\n', '                {\n', '                    if(!inv.isVoteRestart)\n', '                    {\n', '                        countReStartVoices++;\n', '                        inv.isVoteRestart = true;\n', '                    }\n', '                    else{\n', '                        countReStartVoices--;\n', '                        inv.isVoteRestart = false;\n', '                    }\n', '                    if((countReStartVoices > 10 &&\n', '                        countReStartVoices > countOfInvestors / 2) || \n', '                        msg.sender == ADDRESS_ADMIN)\n', '                    {\n', '        \t\t\t    undoDecreaseIteration++;\n', '        \t\t\t    restart();\n', '                    }\n', '                }\n', '                else\n', '                if(!isProfitStarted)\n', '                {\n', '                    if(!inv.isVoteProfit)\n', '                    {\n', '                        countStartVoices++;\n', '                        inv.isVoteProfit = true;\n', '                    }\n', '                    else{\n', '                        countStartVoices--;\n', '                        inv.isVoteProfit = false;\n', '                    }\n', '                    if((countStartVoices > 10 &&\n', '                        countStartVoices > countOfInvestors / 2) || \n', '                        msg.sender == ADDRESS_ADMIN)\n', '                        start(msg.sender);        \t\t\t    \n', '                }\n', '            } \n', '            else\n', '            {\n', '                require(        \n', '                    msg.value <= 0.000000001 ether ||\n', '                    address(this).balance <= maxBalance, \n', '                    "Contract balance overflow");\n', '                makeDeposit();\n', '                require(inv.deposit <= maxDeposit, "Deposit overflow");\n', '            }\n', '        }\n', '    }\n', '    \n', '    function start(address payable addr) private {\n', '        if (isContractSealed) return;\n', '\t    isProfitStarted = true;\n', '        uint payout = payoutAmount(ADDRESS_ADMIN);\n', '        _payout(ADDRESS_ADMIN, payout, false);\n', '        if(addr != ADDRESS_ADMIN){\n', '            payout = payoutAmount(addr);\n', '            _payout(addr, payout, false);\n', '        }\n', '    }\n', '    \n', '    function restart() private {\n', '        if (isContractSealed) return;\n', '        if(dailyPercent() == PERCENT_DECREASE_MINIMUM)\n', '        {\n', '            isContractSealed = true;\n', '            return;\n', '        }\n', '\t\tcountOfInvestors = 0;\n', '\t\titerationIndex++;\n', '\t\tcountStartVoices = 0;\n', '\t\tcountReStartVoices = 0;\n', '\t\tisProfitStarted = false;\n', '\t\tamountDebt = 0;\n', '\t\tamountReturnDebt = 0;\n', '\t\tcountOfReturnDebt = 0;\n', '\t}\n', '\t\n', '    //Pays out, takes taxes according to holding time\n', '    function _payout(address payable addr, uint amount, bool retDep) private {\n', '        if(amount == 0)\n', '            return;\n', '\t\tif(amount > address(this).balance) amount = address(this).balance;\n', '\t\tif(amount == 0){\n', '\t\t\trestart();\n', '\t\t\treturn;\n', '\t\t}\n', '\t\tInvestor storage inv = investors[addr];\n', '        //Calculate pure payout that user receives\n', '        uint activDep = inv.deposit - inv.lockedDeposit;\n', '        bool isDeleteNeed = false;\n', '\t\tif(!isContractSealed && !retDep && !isProfitStarted && amount + inv.withdrawn > activDep / 2 )\n', '\t\t{\n', '\t\t\tif(inv.withdrawn < activDep / 2)\n', '    \t\t\tamount = (activDep/2) - inv.withdrawn;\n', '\t\t\telse{\n', '    \t\t\tif(inv.withdrawn >= activDep)\n', '    \t\t\t{\n', '    \t\t\t\t_delete(addr);\n', '    \t\t\t\treturn;\n', '    \t\t\t}\n', '    \t\t\tamount = activDep - inv.withdrawn;\n', '    \t\t\tisDeleteNeed = true;\n', '\t\t\t}\n', '\t\t}\n', '        uint interestPure = amount * (PERCENT_DIVIDER - PERCENT_MAIN_FUND) / PERCENT_DIVIDER;\n', '\n', '        //calculate money to charity\n', '        uint advTax = amount - interestPure;\n', '        \n', '\t\tinv.withdrawnPure += interestPure;\n', '\t\tinv.withdrawn += amount;\n', '\t\tinv.time = now;\n', '\n', '        //send money\n', '        if(advTax > 0)\n', '        {\n', '            (bool success, bytes memory data) = ADDRESS_MAIN_FUND.call.value(advTax)("");\n', '            if(success) \n', '                countOfAdvTax += advTax;\n', '            else\n', '                inv.withdrawn -= advTax;\n', '        }\n', '        if(interestPure > 0) addr.transfer(interestPure);\n', '        \n', '        if(inv.isWeHaveDebt && inv.withdrawnPure >= inv.deposit)\n', '        {\n', '            amountReturnDebt += inv.deposit;\n', '            countOfReturnDebt++;\n', '            inv.isWeHaveDebt = false;\n', '        }\n', '        \n', '        if(isDeleteNeed)\n', '\t\t\t_delete(addr);\n', '\n', '\t\tif(address(this).balance == 0)\n', '\t\t\trestart();\n', '    }\n', '\n', '    //Clears user from registry\n', '    function _delete(address addr) private {\n', '        Investor storage inv = investors[addr];\n', '        if(inv.iteration != iterationIndex)\n', '            return;\n', '        amountDebt -= inv.deposit;\n', '        if(!inv.isWeHaveDebt){\n', '            countOfReturnDebt--;\n', '            amountReturnDebt-=inv.deposit;\n', '            inv.isWeHaveDebt = true;\n', '        }\n', '        inv.iteration = -1;\n', '        countOfInvestors--;\n', '    }\n', '}']