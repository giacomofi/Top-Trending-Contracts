['/*\n', '    xgr_deposits.sol\n', '    2.0.3\n', '    \n', "    Rajci 'iFA' Andor @ ifa@fusionwallet.io\n", '*/\n', 'pragma solidity 0.4.18;\n', '\n', 'contract Owned {\n', '    /* Variables */\n', '    address public owner = msg.sender;\n', '    /* Externals */\n', '    function replaceOwner(address newOwner) external returns(bool success) {\n', '        require( isOwner() );\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '    /* Internals */\n', '    function isOwner() internal view returns(bool) {\n', '        return owner == msg.sender;\n', '    }\n', '    /* Modifiers */\n', '    modifier onlyForOwner {\n', '        require( isOwner() );\n', '        _;\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    /* Internals */\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if ( b > 0 ) {\n', '            assert( a + b > a );\n', '        }\n', '        return a + b;\n', '    }\n', '    function safeSub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if ( b > 0 ) {\n', '            assert( a - b < a );\n', '        }\n', '        return a - b;\n', '    }\n', '    function safeMul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a / b;\n', '    }\n', '}\n', '\n', 'contract TokenDB is SafeMath, Owned {\n', '    /*\n', '        This is just an abstract contract with the necessary functions\n', '    */\n', '    /* Structures */\n', '    /* Variables */\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => uint256) public lockedBalances;\n', '    address public tokenAddress;\n', '    address public depositsAddress;\n', '    /* Constructor */\n', '    /* Externals */\n', '    function openDeposit(address addr, uint256 amount, uint256 end, uint256 interestOnEnd,\n', '        uint256 interestBeforeEnd, uint256 interestFee, uint256 multiplier, bool closeable) external returns(bool success, uint256 DID) {}\n', '    function closeDeposit(uint256 DID) external returns (bool success) {}\n', '    /* Constants */\n', '    function getDeposit(uint256 UID) public constant returns(address addr, uint256 amount, uint256 start,\n', '        uint256 end, uint256 interestOnEnd, uint256 interestBeforeEnd, uint256 interestFee, uint256 interestMultiplier, bool closeable, bool valid) {}\n', '}\n', '\n', 'contract Token {\n', '    /*\n', '        This is just an abstract contract with the necessary functions\n', '    */\n', '    function mint(address owner, uint256 value) external returns (bool success) {}\n', '}\n', '\n', 'contract Deposits is Owned, SafeMath {\n', '    /* Structures */\n', '    struct depositTypes_s {\n', '        uint256 blockDelay;\n', '        uint256 baseFunds;\n', '        uint256 interestRateOnEnd;\n', '        uint256 interestRateBeforeEnd;\n', '        uint256 interestFee;\n', '        bool closeable;\n', '        bool valid;\n', '    }\n', '    struct deposits_s {\n', '        address addr;\n', '        uint256 amount;\n', '        uint256 start;\n', '        uint256 end;\n', '        uint256 interestOnEnd;\n', '        uint256 interestBeforeEnd;\n', '        uint256 interestFee;\n', '        uint256 interestMultiplier;\n', '        bool    closeable;\n', '        bool    valid;\n', '    }\n', '    /* Variables */\n', '    mapping(uint256 => depositTypes_s) public depositTypes;\n', '    uint256 public depositTypesCounter;\n', '    address public tokenAddress;\n', '    address public databaseAddress;\n', '    address public founderAddress;\n', '    uint256 public interestMultiplier = 1e3;\n', '    /* Constructor */\n', '    function Deposits(address TokenAddress, address DatabaseAddress, address FounderAddress) {\n', '        tokenAddress = TokenAddress;\n', '        databaseAddress = DatabaseAddress;\n', '        founderAddress = FounderAddress;\n', '    }\n', '    /* Externals */\n', '    function changeDataBaseAddress(address newDatabaseAddress) external onlyForOwner {\n', '        databaseAddress = newDatabaseAddress;\n', '    }\n', '    function changeTokenAddress(address newTokenAddress) external onlyForOwner {\n', '        tokenAddress = newTokenAddress;\n', '    }\n', '    function changeFounderAddresss(address newFounderAddress) external onlyForOwner {\n', '        founderAddress = newFounderAddress;\n', '    }\n', '    function addDepositType(uint256 blockDelay, uint256 baseFunds, uint256 interestRateOnEnd,\n', '        uint256 interestRateBeforeEnd, uint256 interestFee, bool closeable) external onlyForOwner {\n', '        depositTypesCounter += 1;\n', '        uint256 DTID = depositTypesCounter;\n', '        depositTypes[DTID] = depositTypes_s(\n', '            blockDelay,\n', '            baseFunds,\n', '            interestRateOnEnd,\n', '            interestRateBeforeEnd,\n', '            interestFee,\n', '            closeable,\n', '            true\n', '        );\n', '        EventNewDepositType(\n', '            DTID,\n', '            blockDelay,\n', '            baseFunds,\n', '            interestRateOnEnd,\n', '            interestRateBeforeEnd,\n', '            interestFee,\n', '            interestMultiplier,\n', '            closeable\n', '        );\n', '    }\n', '    function rekoveDepositType(uint256 DTID) external onlyForOwner {\n', '        delete depositTypes[DTID].valid;\n', '        EventRevokeDepositType(DTID);\n', '    }\n', '    function placeDeposit(uint256 amount, uint256 depositType) external checkSelf {\n', '        require( depositTypes[depositType].valid );\n', '        require( depositTypes[depositType].baseFunds <= amount );\n', '        uint256 balance = TokenDB(databaseAddress).balanceOf(msg.sender);\n', '        uint256 locked = TokenDB(databaseAddress).lockedBalances(msg.sender);\n', '        require( safeSub(balance, locked) >= amount );\n', '        var (success, DID) = TokenDB(databaseAddress).openDeposit(\n', '            msg.sender,\n', '            amount,\n', '            safeAdd(block.number, depositTypes[depositType].blockDelay),\n', '            depositTypes[depositType].interestRateOnEnd,\n', '            depositTypes[depositType].interestRateBeforeEnd,\n', '            depositTypes[depositType].interestFee,\n', '            interestMultiplier,\n', '            depositTypes[depositType].closeable\n', '        );\n', '        require( success );\n', '        EventNewDeposit(DID, msg.sender);\n', '    }\n', '    function closeDeposit(address beneficary, uint256 DID) external checkSelf {\n', '        address _beneficary = beneficary;\n', '        if ( _beneficary == 0x00 ) {\n', '            _beneficary = msg.sender;\n', '        }\n', '        var (addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee,\n', '            interestM, closeable, valid) = TokenDB(databaseAddress).getDeposit(DID);\n', '        _closeDeposit(_beneficary, DID, deposits_s(addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee, interestM, closeable, valid));\n', '    }\n', '    /* Internals */\n', '    function _closeDeposit(address beneficary, uint256 DID, deposits_s data) internal {\n', '        require( data.valid && data.addr == msg.sender );\n', '        var (interest, interestFee) = _calculateInterest(data);\n', '        if ( interest > 0 ) {\n', '            require( Token(tokenAddress).mint(beneficary, interest) );\n', '        }\n', '        if ( interestFee > 0 ) {\n', '            require( Token(tokenAddress).mint(founderAddress, interestFee) );\n', '        }\n', '        require( TokenDB(databaseAddress).closeDeposit(DID) );\n', '        EventDepositClosed(DID, msg.sender, beneficary, interest, interestFee);\n', '    }\n', '    function _calculateInterest(deposits_s data) internal view returns (uint256 interest, uint256 interestFee) {\n', '        if ( ! data.valid || data.amount <= 0 || data.end <= data.start || block.number <= data.start ) { return (0, 0); }\n', '        uint256 rate;\n', '        uint256 delay;\n', '        if ( data.end <= block.number ) {\n', '            rate = data.interestOnEnd;\n', '            delay = safeSub(data.end, data.start);\n', '        } else {\n', '            require( data.closeable );\n', '            rate = data.interestBeforeEnd;\n', '            delay = safeSub(block.number, data.start);\n', '        }\n', '        if ( rate == 0 ) { return (0, 0); }\n', '        interest = safeDiv(safeMul(safeDiv(safeDiv(safeMul(data.amount, rate), 100), data.interestMultiplier), delay), safeSub(data.end, data.start));\n', '        if ( data.interestFee > 0 && interest > 0) {\n', '            interestFee = safeDiv(safeDiv(safeMul(interest, data.interestFee), 100), data.interestMultiplier);\n', '        }\n', '        if ( interestFee > 0 ) {\n', '            interest = safeSub(interest, interestFee);\n', '        }\n', '    }\n', '    /* Constants */\n', '    function calculateInterest(uint256 DID) public view returns(uint256, uint256) {\n', '        var (addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee,\n', '            interestM, closeable, valid) = TokenDB(databaseAddress).getDeposit(DID);\n', '        return _calculateInterest(deposits_s(addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee, interestM, closeable, valid));\n', '    }\n', '    /* Modifiers */\n', '    modifier checkSelf {\n', '        require( TokenDB(databaseAddress).tokenAddress() == tokenAddress );\n', '        require( TokenDB(databaseAddress).depositsAddress() == address(this) );\n', '        _;\n', '    }\n', '    /* Events */\n', '    event EventNewDepositType(uint256 indexed DTID, uint256 blockDelay, uint256 baseFunds,\n', '        uint256 interestRateOnEnd, uint256 interestRateBeforeEnd, uint256 interestFee, uint256 interestMultiplier, bool closeable);\n', '    event EventRevokeDepositType(uint256 indexed DTID);\n', '    event EventNewDeposit(uint256 indexed DID, address owner);\n', '    event EventDepositClosed(uint256 indexed DID, address owner, address beneficary, uint256 interest, uint256 interestFee);\n', '}']