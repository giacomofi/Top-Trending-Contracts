['pragma solidity ^ 0.4.21;\n', '\n', '/**\n', ' *   @title SafeMath\n', ' *   @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' *   @title ERC20\n', ' *   @dev Standart ERC20 token interface\n', ' */\n', 'contract ERC20 {\n', '    function balanceOf(address _owner) public constant returns(uint256);\n', '    function transfer(address _to, uint256 _value) public returns(bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '    function approve(address _spender, uint256 _value) public returns(bool);\n', '    function allowance(address _owner, address _spender) public constant returns(uint256);\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/**\n', ' *   @dev CRET token contract\n', ' */\n', 'contract WbcToken is ERC20 {\n', '    using SafeMath for uint256;\n', '    string public name = "WhizBizCoin";\n', '    string public symbol = "WB";\n', '    uint256 public decimals = 18;\n', '    uint256 public totalSupply = 888000000 * 1e18;\n', '    uint256 public timeStamp = 0;\n', '    uint256 constant fundPartYear = 44400000 * 1e18; \n', '    uint256 constant trioPartYear = 8880000 * 1e18; //1% of tokens for CrowdSale, Film Comany and Investors in one year for 6 years\n', '    uint256 constant minimumAge = 30 days; // minimum age for coins\n', '    uint256 constant oneYear = 360 days;\n', '    uint256 public minted = 0;\n', '    address public teamCSN;\n', '    address public teamFilmCompany;\n', '    address public teamInvestors;\n', '    address public teamFund;\n', '    address public manager;\n', '    address public reserveFund;\n', '    \n', '    struct transferStruct{\n', '    uint128 amount;\n', '    uint64 time;\n', '    }\n', '    \n', '    mapping(uint8 => bool) trioChecker;\n', '    mapping(uint8 => bool) fundChecker;\n', '    mapping(uint256 => bool) priceChecker;\n', '    mapping(address => transferStruct[]) transferSt;\n', '    mapping(uint256 => uint256) coinPriceNow;\n', '\n', '    // Ico contract address\n', '    address public owner;\n', '\n', '    // Allows execution by the owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyManager {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '    \n', '    \n', '    \n', '    constructor (address _owner, address _teamCSN, address _teamFilmCompany, address _teamInvestors, address _fund, address _manager, address _reserveFund) public {\n', '        owner = _owner;\n', '        teamCSN = _teamCSN;\n', '        teamFilmCompany = _teamFilmCompany;\n', '        teamInvestors = _teamInvestors;\n', '        teamFund = _fund;\n', '        manager = _manager;\n', '        reserveFund = _reserveFund;\n', '\n', '    }\n', '    \n', '    \n', '    function doTimeStamp(uint256 _value) external onlyOwner {\n', '        timeStamp = _value;\n', '    }\n', '    \n', '    \n', '\n', '   /**\n', '    *   @dev Mint tokens\n', '    *   @param _investor     address the tokens will be issued to\n', '    *   @param _value        number of tokens\n', '    */\n', '    function mintTokens(address _investor, uint256 _value) external onlyOwner {\n', '        require(_value > 0);\n', '        require(minted.add(_value) <= totalSupply);\n', '        balances[_investor] = balances[_investor].add(_value);\n', '        minted = minted.add(_value);\n', '        transferSt[_investor].push(transferStruct(uint128(_value),uint64(now)));\n', '        emit Transfer(0x0, _investor, _value);\n', '    }\n', '    \n', '    \n', '    \n', '    function mintTrio() external onlyManager {\n', '        require(now > (timeStamp + 360 days));\n', '        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\n', '            require(trioChecker[1] != true);\n', '            partingTrio(1);\n', '        }\n', '        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\n', '            require(trioChecker[2] != true);\n', '            partingTrio(2);\n', '        }\n', '        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\n', '            require(trioChecker[3] != true);\n', '            partingTrio(3);\n', '        }\n', '        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\n', '            require(trioChecker[4] != true);\n', '            partingTrio(4);\n', '        }\n', '        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\n', '            require(trioChecker[5] != true);\n', '            partingTrio(5);\n', '        }\n', '        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\n', '            require(trioChecker[6] != true);\n', '            partingTrio(6);\n', '        }\n', '    }\n', '    \n', '    \n', '    function mintFund() external onlyManager {\n', '        require(now > (timeStamp + 360 days));\n', '        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\n', '            require(fundChecker[1] != true);\n', '            partingFund(1);\n', '        }\n', '        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\n', '            require(fundChecker[2] != true);\n', '            partingFund(2);\n', '        }\n', '        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\n', '            require(fundChecker[3] != true);\n', '            partingFund(3);\n', '        }\n', '        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\n', '            require(fundChecker[4] != true);\n', '            partingFund(4);\n', '        }\n', '        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\n', '            require(fundChecker[5] != true);\n', '            partingFund(5);\n', '        }\n', '        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\n', '            require(fundChecker[6] != true);\n', '            partingFund(6);\n', '        }\n', '        if(now > (timeStamp + 2520 days) && now <= (timeStamp + 2880 days)){\n', '            require(fundChecker[7] != true);\n', '            partingFund(7);\n', '        }\n', '    \n', '    }\n', '    \n', '    \n', '    function partingFund(uint8 _x) internal {\n', '        require(_x > 0 && _x <= 7);\n', '        balances[teamFund] = balances[teamFund].add(fundPartYear);\n', '        fundChecker[_x] = true;\n', '        minted = minted.add(fundPartYear);\n', '        transferSt[teamFund].push(transferStruct(uint128(fundPartYear),uint64(now)));\n', '            \n', '        emit Transfer(0x0, teamFund, fundPartYear);\n', '    }\n', '    \n', '    \n', '    function partingTrio(uint8 _x) internal {\n', '        require(_x > 0 && _x <= 6);\n', '        balances[teamCSN] = balances[teamCSN].add(trioPartYear);\n', '        balances[teamFilmCompany] = balances[teamFilmCompany].add(trioPartYear);\n', '        balances[teamInvestors] = balances[teamInvestors].add(trioPartYear);\n', '        trioChecker[_x] = true;\n', '        minted = minted.add(trioPartYear.mul(3));\n', '        transferSt[teamCSN].push(transferStruct(uint128(trioPartYear),uint64(now)));\n', '        transferSt[teamFilmCompany].push(transferStruct(uint128(trioPartYear),uint64(now)));\n', '        transferSt[teamInvestors].push(transferStruct(uint128(trioPartYear),uint64(now)));\n', '            \n', '        emit Transfer(0x0, teamCSN, trioPartYear);\n', '        emit Transfer(0x0, teamFilmCompany, trioPartYear);\n', '        emit Transfer(0x0, teamInvestors, trioPartYear);\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Get balance of investor\n', "    *   @param _owner        investor's address\n", '    *   @return              balance of investor\n', '    */\n', '    function balanceOf(address _owner) public constant returns(uint256) {\n', '      return balances[_owner];\n', '    }\n', '\n', '   /**\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transfer(address _to, uint256 _amount) public returns(bool) {\n', '        if(msg.sender == _to) {return POSMint();}\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        if(transferSt[msg.sender].length > 0) {delete transferSt[msg.sender];}\n', '        uint64 _now = uint64(now);\n', '        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),_now));\n', '        transferSt[_to].push(transferStruct(uint128(_amount),_now));\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '        require(_amount <= balances[_from]);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        if(transferSt[_from].length > 0) {delete transferSt[_from];}\n', '        uint64 _now = uint64(now);\n', '        transferSt[_from].push(transferStruct(uint128(balances[_from]),_now));\n', '        transferSt[_to].push(transferStruct(uint128(_amount),_now));\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function POSMint() internal returns (bool) {\n', '        require(now > (timeStamp + minimumAge));\n', '        if(balances[msg.sender] <= 0) {return false;}\n', '        if(transferSt[msg.sender].length <= 0) {return false;}\n', '\n', '        uint256 _now = now;\n', '        uint256 _year = getYear();\n', '        uint256 _phase = getPhase(_year);\n', '        uint256 _coinsAmount = getCoinsAmount(msg.sender, _now);\n', '        if(_coinsAmount <= 0) {return false;}\n', '        uint256 _coinsPrice = getCoinPrice(_year, _phase);\n', '        if(_coinsPrice <= 0) {return false;}\n', '        uint256 reward = (_coinsAmount.mul(_coinsPrice)).div(100000);\n', '        if(reward <= 0) {return false;}\n', '        if(reward > 0) {require(minted.add(reward) <= totalSupply);}\n', '        minted = minted.add(reward);\n', '        balances[msg.sender] = balances[msg.sender].add(reward);\n', '        delete transferSt[msg.sender];\n', '        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),uint64(now)));\n', '\n', '        emit Transfer(0x0, msg.sender, reward);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function getCoinsAmount(address _address, uint _now) internal view returns (uint256) {\n', '        if(transferSt[_address].length <= 0) {return 0;}\n', '        uint256 Coins = 0;\n', '        for (uint256 i = 0; i < transferSt[_address].length; i++){\n', '            if( _now < uint(transferSt[_address][i].time).add(minimumAge) ) {return Coins;}\n', '            Coins = Coins.add(uint256(transferSt[_address][i].amount));\n', '        }\n', '        return Coins;\n', '    }\n', '    \n', '    \n', '    function getYear() internal view returns (uint256) {\n', '        require(timeStamp > 0);\n', '        for(uint256 i = 0; i <= 99; i++) {\n', '        if(now >= ((timeStamp + minimumAge).add((i.mul(oneYear)))) && now < ((timeStamp + minimumAge).add(((i+1).mul(oneYear))))) {\n', '            return (i);    // how many years gone\n', '            }\n', '        }\n', '        if(now >= ((timeStamp + minimumAge).add((oneYear.mul(100))))) {return (100);}\n', '    \n', '    }\n', '\n', '\n', '    function getPhase(uint256 _x) internal pure returns (uint256) {\n', '        require(_x >= 0);\n', '        if(_x >= 0 && _x < 3) {return 1;}\n', '        if(_x >= 3 && _x < 6) {return 2;}\n', '        if(_x >= 6 && _x < 9) {return 3;}\n', '        if(_x >= 9 && _x < 12) {return 4;}\n', '        if(_x >= 12) {return 5;}        // last phase which include 18*3 years\n', '    \n', '    }\n', '    \n', '    \n', '    function getMonthLimit(uint256 _x) internal pure returns (uint256) {\n', '        require(_x > 0 && _x <=5);\n', '        if(_x == 1) {return (2220000 * 1e18);} //limit in month in this phase for all\n', '        if(_x == 2) {return (1480000 * 1e18);}\n', '        if(_x == 3) {return (740000 * 1e18);}\n', '        if(_x == 4) {return (370000 * 1e18);}\n', '        if(_x == 5) {return (185000 * 1e18);}\n', '    }\n', '    \n', ' \n', '\n', '    \n', '    function getCoinPrice(uint256 _year, uint256 _phase) internal returns (uint256) {\n', '    require(_year >= 0);\n', '    uint256 _monthLimit = getMonthLimit(_phase);\n', '    uint256 _sumToAdd = _year.mul(oneYear);\n', '    uint256 _monthInYear = _year.mul(12);\n', '\n', '    for(uint256 i = 0; i <= 11; i++) {\n', '    if(now >= (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i)) && now < (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i+1))) {\n', '        uint256 _num = _monthInYear.add(i);\n', '        if(priceChecker[_num] != true) {\n', '            coinPriceNow[_num] = minted;\n', '            priceChecker[_num] = true;\n', '            return (_monthLimit.mul(100000)).div(minted);} \n', '        if(priceChecker[_num] == true) {\n', '            return (_monthLimit.mul(100000)).div(coinPriceNow[_num]);}\n', '    }\n', '    }\n', '}\n', '\n', '   /**\n', '    *   @dev Allows another account/contract to spend some tokens on its behalf\n', '    * approve has to be called twice in 2 separate transactions - once to\n', '    *   change the allowance to 0 and secondly to change it to the new allowance value\n', '    *   @param _spender      approved address\n', '    *   @param _amount       allowance amount\n', '    *\n', '    *   @return true if the approval was successful\n', '    */\n', '    function approve(address _spender, uint256 _amount) public returns(bool) {\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    *   @param _owner        the address which owns the funds\n', '    *   @param _spender      the address which will spend the funds\n', '    *\n', '    *   @return              the amount of tokens still avaible for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) public constant returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']