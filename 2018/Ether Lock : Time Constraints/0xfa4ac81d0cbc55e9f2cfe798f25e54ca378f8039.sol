['pragma solidity ^0.4.13;\n', '\n', 'contract Escrow {\n', '  address public owner;\n', '  uint public fee;\n', '  mapping (address =>  mapping (address => uint)) public balances;\n', '\n', '  function Escrow() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function setFee(uint price) onlyOwner external {\n', '    fee = price;\n', '  }\n', '\n', '  function start(address payee) payable external {\n', '    balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;\n', '  }\n', '\n', '  function end(address payer, address payee) onlyOwner external returns(bool){\n', '    uint value = balances[payer][payee];\n', '    uint paidFee = value / (1000000 / fee);\n', '    uint payment = value - paidFee;\n', '    balances[payer][payee] = 0;\n', '    payee.transfer(payment);\n', '    owner.transfer(paidFee);\n', '    return true;\n', '  }\n', '  \n', '  function refund(address payer, address payee) onlyOwner external returns(bool){\n', '    uint value = balances[payer][payee];\n', '    balances[payer][payee] = 0;\n', '    payer.transfer(value);\n', '    return true;\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Escrow {\n', '  address public owner;\n', '  uint public fee;\n', '  mapping (address =>  mapping (address => uint)) public balances;\n', '\n', '  function Escrow() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function setFee(uint price) onlyOwner external {\n', '    fee = price;\n', '  }\n', '\n', '  function start(address payee) payable external {\n', '    balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;\n', '  }\n', '\n', '  function end(address payer, address payee) onlyOwner external returns(bool){\n', '    uint value = balances[payer][payee];\n', '    uint paidFee = value / (1000000 / fee);\n', '    uint payment = value - paidFee;\n', '    balances[payer][payee] = 0;\n', '    payee.transfer(payment);\n', '    owner.transfer(paidFee);\n', '    return true;\n', '  }\n', '  \n', '  function refund(address payer, address payee) onlyOwner external returns(bool){\n', '    uint value = balances[payer][payee];\n', '    balances[payer][payee] = 0;\n', '    payer.transfer(value);\n', '    return true;\n', '  }\n', '}']
