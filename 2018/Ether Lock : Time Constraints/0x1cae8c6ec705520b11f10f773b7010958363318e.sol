['pragma solidity ^ 0.4 .24;\n', 'library MathForInterset {\n', '    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '        return c;\n', '    }\n', '}\n', 'contract Hermes {\n', '    using MathForInterset\n', '    for uint;\n', '    uint constant public MINIMUM_INVEST = 10000000000000000 wei;\n', '    uint public DAY_VALUE = 0;\n', '    uint public DAY_LIMIT = 200 ether;//first limit\n', '    uint public DEPOSIT_AMOUNT;\n', '    uint public PERCENT_FOR_MARKETING = 1500000000;\n', '    address[] public ADDRESSES;\n', '    mapping(address => Investor) public INVESTORS;\n', '    address public ADMIN_ADDR;\n', '    struct Investor {\n', '        uint id;\n', '        uint percentCount;\n', '        uint deposit;\n', '        uint date;\n', '        address referrer;\n', '        uint reinvestID;\n', '        uint actualValue;\n', '        uint stage;\n', '        uint startReinvestDate;\n', '        uint dayLimitValue;\n', '    }\n', '    event reinvest(address addr, uint active);\n', '    event payout(address addr, uint amount, string eventType);\n', '    constructor() public {\n', '        ADMIN_ADDR = msg.sender;\n', '    }\n', '\n', '    function Invest(address _referrer) private {\n', '        if (msg.value == 0 ether) {\n', '\n', '            if (msg.sender == ADMIN_ADDR) {\n', '                payAll();\n', '            } else {\n', '                paySelfByAddress(msg.sender);\n', '            }\n', '        } else {\n', '            if (INVESTORS[msg.sender].deposit == 0) {\n', '                require(DAY_VALUE + msg.value < DAY_LIMIT, "DAY LIMIT!!!");\n', '                require(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2, "DAY LIMIT!!!");\n', '                INVESTORS[msg.sender].dayLimitValue += msg.value;\n', '                DAY_VALUE += msg.value;\n', '                ADDRESSES.push(msg.sender);\n', '                uint id = ADDRESSES.length;\n', '                ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1));\n', '                DEPOSIT_AMOUNT += msg.value;\n', '                if (msg.value >= MINIMUM_INVEST) {\n', '                    if (INVESTORS[_referrer].deposit != 0) {\n', '                        if (INVESTORS[_referrer].deposit >= 3 ether) {\n', '                            uint value = (msg.value.mul(200000000).div(10000000000));\n', '                            msg.sender.transfer(value);\n', '                            value = (msg.value.mul(250000000).div(10000000000));\n', '                            _referrer.transfer(value);\n', '                            if (INVESTORS[_referrer].stage < 1) {\n', '\n', '                                INVESTORS[_referrer].stage = 1;\n', '                            }\n', '                        }\n', '                        address nextReferrer = _referrer;\n', '                        for (uint i = 0; i < 4; i++) {\n', '                            if (INVESTORS[nextReferrer].referrer == address(0x0)) {\n', '                                break;\n', '                            }\n', '                            if (INVESTORS[INVESTORS[nextReferrer].referrer].reinvestID != 3) {\n', '                                if (INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 3 ether) {\n', '                                    if (INVESTORS[INVESTORS[nextReferrer].referrer].stage <= 2) {\n', '                                        if (INVESTORS[INVESTORS[nextReferrer].referrer].stage <= i + 2) {\n', '                                            value = (msg.value.mul(100000000).div(10000000000));\n', '                                            INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2;\n', '                                            INVESTORS[nextReferrer].referrer.transfer(value);\n', '                                        }\n', '                                    }\n', '                                }\n', '                                if (INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 5 ether) {\n', '                                    if (INVESTORS[INVESTORS[nextReferrer].referrer].stage < i + 2) {\n', '                                        INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2;\n', '                                    }\n', '                                    if (i + 2 == 2) {\n', '                                        value = (msg.value.mul(150000000).div(10000000000));\n', '                                    }\n', '                                    if (i + 2 == 3) {\n', '                                        value = (msg.value.mul(75000000).div(10000000000));\n', '                                    }\n', '                                    if (i + 2 == 4) {\n', '                                        value = (msg.value.mul(50000000).div(10000000000));\n', '                                    }\n', '                                    if (i + 2 == 5) {\n', '                                        value = (msg.value.mul(25000000).div(10000000000));\n', '                                    }\n', '                                    INVESTORS[nextReferrer].referrer.transfer(value);\n', '                                }\n', '                            }\n', '                            nextReferrer = INVESTORS[nextReferrer].referrer;\n', '                            if (nextReferrer == address(0x0)) {\n', '                                break;\n', '                            }\n', '                        }\n', '                    } else {\n', '                        _referrer = address(0x0);\n', '                    }\n', '                } else {\n', '                    _referrer = address(0x0);\n', '                }\n', '                INVESTORS[msg.sender] = Investor(id, 0, msg.value, now, _referrer, 0, msg.value, 0, 0, msg.value);\n', '            } else {\n', '                require(DAY_VALUE + msg.value < DAY_LIMIT, "DAY LIMIT!!!");\n', '                require(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2, "DAY LIMIT!!!");\n', '                INVESTORS[msg.sender].dayLimitValue += msg.value;\n', '                DAY_VALUE += msg.value;\n', '                if (INVESTORS[msg.sender].reinvestID == 3) {\n', '                    INVESTORS[msg.sender].reinvestID = 0;\n', '                }\n', '                INVESTORS[msg.sender].deposit += msg.value;\n', '                INVESTORS[msg.sender].actualValue += msg.value;\n', '                DEPOSIT_AMOUNT += msg.value;\n', '                ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1));\n', '                if (msg.value == 0.000012 ether) {\n', '                    require(INVESTORS[msg.sender].reinvestID == 0, "REINVEST BLOCK");\n', '                    INVESTORS[msg.sender].reinvestID = 1;\n', '                    INVESTORS[msg.sender].startReinvestDate = now;\n', '                    emit reinvest(msg.sender, 1);\n', '                }\n', '                if (msg.value == 0.000013 ether) {\n', '                    uint interval = 0;\n', '                    uint interest = 0;\n', '                    require(INVESTORS[msg.sender].reinvestID == 1, "REINVEST BLOCK");\n', '\n', '                    if ((DEPOSIT_AMOUNT >= 0 ether) && (DEPOSIT_AMOUNT < 1000 ether)) {\n', '                        interest = 125000000; //1.25\n', '                    }\n', '                    if ((DEPOSIT_AMOUNT >= 1000 ether) && (DEPOSIT_AMOUNT <= 2000 ether)) {\n', '                        interest = 100000000; //1\n', '                    }\n', '                    if ((DEPOSIT_AMOUNT >= 2000 ether) && (DEPOSIT_AMOUNT <= 3000 ether)) {\n', '                        interest = 75000000; //0.75\n', '                    }\n', '                    if (DEPOSIT_AMOUNT > 3000 ether) {\n', '                        interest = 60000000; //0.6\n', '                    }\n', '                    ////\n', '                    interval = (now - INVESTORS[msg.sender].startReinvestDate) / 1 days;\n', '                    interest = (interest + INVESTORS[msg.sender].stage * 10000000) * interval;\n', '                    value = (INVESTORS[msg.sender].deposit.mul(interest).div(10000000000)).mul(1);\n', '                    INVESTORS[msg.sender].percentCount += interest;\n', '                    INVESTORS[msg.sender].deposit += value;\n', '                    INVESTORS[msg.sender].actualValue = INVESTORS[msg.sender].deposit;\n', '                    INVESTORS[msg.sender].reinvestID = 0;\n', '                    emit reinvest(msg.sender, 0);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function() payable public {\n', '        require(msg.value >= MINIMUM_INVEST || msg.value == 0.000012 ether || msg.value == 0 ether || msg.value == 0.000013 ether, "Too small amount, minimum 0.01 ether");\n', '        require(INVESTORS[msg.sender].percentCount < 10000000000, "You can\'t invest");\n', '        require(INVESTORS[msg.sender].reinvestID != 1 || msg.value == 0.000013 ether, "You can\'t invest");\n', '        Invest(bytesToAddress(msg.data));\n', '    }\n', '\n', '\n', '\n', '    function paySelfByAddress(address addr) public {\n', '\n', '        uint interest = 0;\n', '        if ((DEPOSIT_AMOUNT >= 0) && (DEPOSIT_AMOUNT < 1000 ether)) {\n', '            interest = 125000000; //1.25\n', '        }\n', '        if ((DEPOSIT_AMOUNT >= 1000 ether) && (DEPOSIT_AMOUNT <= 2000 ether)) {\n', '            interest = 100000000; //1\n', '        }\n', '        if ((DEPOSIT_AMOUNT >= 2000 ether) && (DEPOSIT_AMOUNT <= 3000 ether)) {\n', '            interest = 75000000; //0.75\n', '        }\n', '        if (DEPOSIT_AMOUNT >= 3000 ether) {\n', '            interest = 60000000; //0.6\n', '        }\n', '        Investor storage stackObject = INVESTORS[addr];\n', '        uint value = 0;\n', '        uint interval = (now - INVESTORS[addr].date) / 1 days;\n', '        if (interval > 0) {\n', '            interest = ((INVESTORS[addr].stage * 10000000) + interest) * interval;\n', '            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '            if (INVESTORS[addr].reinvestID == 1) {\n', '                uint residualInterest = 0;\n', '                value = (stackObject.actualValue.mul(interest).div(10000000000));\n', '                residualInterest = (((stackObject.actualValue + value) - stackObject.deposit).mul(10000000000)).div(stackObject.deposit);\n', '                if (INVESTORS[addr].percentCount + residualInterest >= 10000000000) {\n', '\n', '                    value = (stackObject.deposit * 2) - INVESTORS[addr].actualValue;\n', '                    INVESTORS[addr].reinvestID = 2;\n', '                    INVESTORS[addr].percentCount = 10000000000;\n', '                }\n', '                INVESTORS[addr].actualValue += value;\n', '                INVESTORS[addr].date = now;\n', '            }\n', '            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '            if (INVESTORS[addr].reinvestID == 0 || INVESTORS[addr].reinvestID == 2) {\n', '                if (INVESTORS[addr].percentCount != 10000000000) {\n', '                    if (INVESTORS[addr].percentCount + interest >= 10000000000) {\n', '                        interest = 10000000000 - INVESTORS[addr].percentCount;\n', '\n', '                    }\n', '                    INVESTORS[addr].percentCount += interest;\n', '                    value = (stackObject.deposit.mul(interest).div(10000000000));\n', '                    addr.transfer(value);\n', '                    emit payout(addr, value, "Interest payment");\n', '                    INVESTORS[addr].date = now;\n', '                } else {\n', '                    if (INVESTORS[addr].reinvestID == 2) {\n', '                        interest = 2000000000 * interval;\n', '                    }\n', '                    value = (stackObject.deposit.mul(interest).div(10000000000));\n', '                    if (INVESTORS[addr].actualValue < value) {\n', '                        value = INVESTORS[addr].actualValue;\n', '                    }\n', '                    INVESTORS[addr].actualValue -= value;\n', '                    addr.transfer(value);\n', '                    emit payout(addr, value, "Body payout");\n', '                    INVESTORS[addr].date = now;\n', '                    if (INVESTORS[addr].actualValue == 0) {\n', '                        INVESTORS[addr].reinvestID = 3;\n', '                        INVESTORS[addr].deposit = 0;\n', '                        INVESTORS[addr].percentCount = 0;\n', '                        INVESTORS[addr].actualValue = 0;\n', '                    }\n', '                }\n', '            }\n', '            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '        }\n', '    }\n', '\n', '\n', '    function payAll() private {\n', '        DAY_VALUE = 0;\n', '        //////////////////////////////////////////////\n', '        for (uint i = 0; i < ADDRESSES.length; i++) {\n', '            INVESTORS[ADDRESSES[i]].dayLimitValue = 0;\n', '            paySelfByAddress(ADDRESSES[i]);\n', '        }\n', '\n', '        if (address(this).balance < 1000 ether) {\n', '            DAY_LIMIT = 200 ether;\n', '        }\n', '        if (address(this).balance >= 1000 ether && address(this).balance < 2000 ether) {\n', '            DAY_LIMIT = 400 ether;\n', '        }\n', '        if (address(this).balance >= 2000 && address(this).balance < 4000 ether) {\n', '            DAY_LIMIT = 600 ether;\n', '        }\n', '        if (address(this).balance >= 4000 ether) {\n', '            DAY_LIMIT = 1000000000 ether;\n', '        }\n', '    }\n', '\n', '    function bytesToAddress(bytes bys) private pure returns(address addr) {\n', '        assembly {\n', '            addr: = mload(add(bys, 20))\n', '        }\n', '    }\n', '}']