['pragma solidity ^0.4.18;\n', '\n', 'contract EtherTower {\n', '  using SafeMath for uint256;\n', '\n', '  // Contract owner address\n', '  address public owner;\n', '\n', '  // Game constants\n', '  uint256 private constant TOWER_BOSS_TOKEN_ID = 0;\n', '  uint256 private constant APARTMENT_MANAGER_ID = 1;\n', '  uint256 private constant HOTEL_MANAGER_ID = 2;\n', '  uint256 private constant CONDO_MANAGER_ID = 3;\n', '\n', '  uint256 private constant BOTTOM_FLOOR_ID = 4;\n', '  uint256 private constant APARTMENT_INDEX_MIN = 4;\n', '  uint256 private constant APARTMENT_INDEX_MAX = 9;\n', '  uint256 private constant HOTEL_INDEX_MIN = 10;\n', '  uint256 private constant HOTEL_INDEX_MAX = 15;\n', '  uint256 private constant CONDO_INDEX_MIN = 16;\n', '  uint256 private constant CONDO_INDEX_MAX = 21;\n', '\n', '  uint256 private firstStepLimit = 0.04 ether;\n', '  uint256 private secondStepLimit = 0.2 ether;\n', '\n', '  // Game start time\n', '  uint256 public gameStartTime = 1520647080;\n', '\n', '  // Tokens\n', '  struct Token {\n', '    uint256 price;\n', '    address owner;\n', '  }\n', '\n', '  mapping (uint256 => Token) public tokens;\n', '\n', '  // Player earnings\n', '  mapping (address => uint256) public earnings;\n', '\n', '  event TokenPurchased(\n', '    uint256 tokenId,\n', '    address oldOwner,\n', '    address newOwner,\n', '    uint256 oldPrice,\n', '    uint256 newPrice,\n', '    uint256 timestamp\n', '  );\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyGameStarted {\n', '    require(now >= gameStartTime);\n', '    _;\n', '  }\n', '\n', '  function EtherTower() public {\n', '    owner = msg.sender;\n', '    createToken(0, 2 ether); // Tower Boss\n', '    createToken(1, 0.5 ether); // Apartment Manager\n', '    createToken(2, 0.5 ether); // Hotel Manager\n', '    createToken(3, 0.5 ether); // Condo Manager\n', '\n', '    // Apartments\n', '    createToken(4, 0.05 ether);\n', '    createToken(5, 0.005 ether);\n', '    createToken(6, 0.005 ether);\n', '    createToken(7, 0.005 ether);\n', '    createToken(8, 0.005 ether);\n', '    createToken(9, 0.05 ether);\n', '\n', '    // Hotel\n', '    createToken(10, 0.05 ether);\n', '    createToken(11, 0.005 ether);\n', '    createToken(12, 0.005 ether);\n', '    createToken(13, 0.005 ether);\n', '    createToken(14, 0.005 ether);\n', '    createToken(15, 0.05 ether);\n', '\n', '    // Condos\n', '    createToken(16, 0.05 ether);\n', '    createToken(17, 0.005 ether);\n', '    createToken(18, 0.005 ether);\n', '    createToken(19, 0.005 ether);\n', '    createToken(20, 0.005 ether);\n', '    createToken(21, 0.1 ether); // Penthouse\n', '  }\n', '\n', '  // PUBLIC\n', '\n', '  function createToken(uint256 _tokenId, uint256 _startingPrice) public onlyOwner {\n', '    Token memory token = Token({\n', '      price: _startingPrice,\n', '      owner: owner\n', '    });\n', '\n', '    tokens[_tokenId] = token;\n', '  }\n', '\n', '  function getToken(uint256 _tokenId) public view returns (\n', '    uint256 _price,\n', '    uint256 _nextPrice,\n', '    address _owner\n', '  ) {\n', '    Token memory token = tokens[_tokenId];\n', '    _price = token.price;\n', '    _nextPrice = getNextPrice(token.price);\n', '    _owner = token.owner;\n', '  }\n', '\n', '  function setGameStartTime(uint256 _gameStartTime) public onlyOwner {\n', '    gameStartTime = _gameStartTime;\n', '  }\n', '\n', '  function purchase(uint256 _tokenId) public payable onlyGameStarted {\n', '    Token storage token = tokens[_tokenId];\n', '\n', '    // Value must be greater than or equal to the token price\n', '    require(msg.value >= token.price);\n', '\n', '    // Prevent user from buying their own token\n', '    require(msg.sender != token.owner);\n', '\n', '    uint256 purchaseExcess = msg.value.sub(token.price);\n', '\n', '    address newOwner = msg.sender;\n', '    address oldOwner = token.owner;\n', '\n', '    uint256 devCut = token.price.mul(4).div(100); // 4%\n', '    uint256 towerBossCut = token.price.mul(3).div(100); // 3%\n', '    uint256 managerCut = getManagerCut(_tokenId, token.price); // 0% - 3%\n', '    uint256 oldOwnerProfit = token.price.sub(devCut).sub(towerBossCut).sub(managerCut);\n', '\n', '    // Update token\n', '    uint256 oldPrice = token.price;\n', '    token.owner = newOwner;\n', '    token.price = getNextPrice(token.price);\n', '\n', '    // send funds to the dev\n', '    earnings[owner] = earnings[owner].add(devCut);\n', '\n', '    // send funds to the big boss\n', '    earnings[tokens[TOWER_BOSS_TOKEN_ID].owner] = earnings[tokens[TOWER_BOSS_TOKEN_ID].owner].add(towerBossCut);\n', '\n', '    // send funds to the manager (if applicable)\n', '    if (managerCut > 0) {\n', '      address managerAddress = getManagerAddress(_tokenId);\n', '      earnings[managerAddress] = earnings[managerAddress].add(managerCut);\n', '    }\n', '\n', '    // send profit to the previous owner\n', '    sendFunds(oldOwner, oldOwnerProfit);\n', '\n', '    // refund any excess to the sender\n', '    if (purchaseExcess > 0) {\n', '      sendFunds(newOwner, purchaseExcess);\n', '    }\n', '\n', '    TokenPurchased(_tokenId, oldOwner, newOwner, oldPrice, token.price, now);\n', '  }\n', '\n', '  function withdrawEarnings() public {\n', '    uint256 amount = earnings[msg.sender];\n', '    earnings[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '  /// PRIVATE\n', '\n', '  /// @dev Managers only get a cut of floor sales\n', '  function getManagerCut(uint256 _tokenId, uint256 _price) private pure returns (uint256) {\n', '    if (_tokenId >= BOTTOM_FLOOR_ID) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function getManagerAddress(uint256 _tokenId) private view returns (address) {\n', '    if (_tokenId >= APARTMENT_INDEX_MIN && _tokenId <= APARTMENT_INDEX_MAX) {\n', '      return tokens[APARTMENT_MANAGER_ID].owner;\n', '    } else if (_tokenId >= HOTEL_INDEX_MIN && _tokenId <= HOTEL_INDEX_MAX) {\n', '      return tokens[HOTEL_MANAGER_ID].owner;\n', '    } else if (_tokenId >= CONDO_INDEX_MIN && _tokenId <= CONDO_INDEX_MAX) {\n', '      return tokens[CONDO_MANAGER_ID].owner;\n', '    } else {\n', '      // This should never happen\n', '      return owner;\n', '    }\n', '  }\n', '\n', '  function getNextPrice(uint256 _price) private view returns (uint256) {\n', '    if (_price <= firstStepLimit) {\n', '      return _price.mul(2); // increase by 100%\n', '    } else if (_price <= secondStepLimit) {\n', '      return _price.mul(125).div(100); // increase by 25%\n', '    } else {\n', '      return _price.mul(118).div(100); // increase by 18%\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @dev Attempt to send the funds immediately.\n', '    * If that fails for any reason, force the user\n', '    * to manually withdraw.\n', '    */\n', '  function sendFunds(address _recipient, uint256 _amount) private {\n', '    if (!_recipient.send(_amount)) {\n', '      earnings[_recipient] = earnings[_recipient].add(_amount);\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract EtherTower {\n', '  using SafeMath for uint256;\n', '\n', '  // Contract owner address\n', '  address public owner;\n', '\n', '  // Game constants\n', '  uint256 private constant TOWER_BOSS_TOKEN_ID = 0;\n', '  uint256 private constant APARTMENT_MANAGER_ID = 1;\n', '  uint256 private constant HOTEL_MANAGER_ID = 2;\n', '  uint256 private constant CONDO_MANAGER_ID = 3;\n', '\n', '  uint256 private constant BOTTOM_FLOOR_ID = 4;\n', '  uint256 private constant APARTMENT_INDEX_MIN = 4;\n', '  uint256 private constant APARTMENT_INDEX_MAX = 9;\n', '  uint256 private constant HOTEL_INDEX_MIN = 10;\n', '  uint256 private constant HOTEL_INDEX_MAX = 15;\n', '  uint256 private constant CONDO_INDEX_MIN = 16;\n', '  uint256 private constant CONDO_INDEX_MAX = 21;\n', '\n', '  uint256 private firstStepLimit = 0.04 ether;\n', '  uint256 private secondStepLimit = 0.2 ether;\n', '\n', '  // Game start time\n', '  uint256 public gameStartTime = 1520647080;\n', '\n', '  // Tokens\n', '  struct Token {\n', '    uint256 price;\n', '    address owner;\n', '  }\n', '\n', '  mapping (uint256 => Token) public tokens;\n', '\n', '  // Player earnings\n', '  mapping (address => uint256) public earnings;\n', '\n', '  event TokenPurchased(\n', '    uint256 tokenId,\n', '    address oldOwner,\n', '    address newOwner,\n', '    uint256 oldPrice,\n', '    uint256 newPrice,\n', '    uint256 timestamp\n', '  );\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyGameStarted {\n', '    require(now >= gameStartTime);\n', '    _;\n', '  }\n', '\n', '  function EtherTower() public {\n', '    owner = msg.sender;\n', '    createToken(0, 2 ether); // Tower Boss\n', '    createToken(1, 0.5 ether); // Apartment Manager\n', '    createToken(2, 0.5 ether); // Hotel Manager\n', '    createToken(3, 0.5 ether); // Condo Manager\n', '\n', '    // Apartments\n', '    createToken(4, 0.05 ether);\n', '    createToken(5, 0.005 ether);\n', '    createToken(6, 0.005 ether);\n', '    createToken(7, 0.005 ether);\n', '    createToken(8, 0.005 ether);\n', '    createToken(9, 0.05 ether);\n', '\n', '    // Hotel\n', '    createToken(10, 0.05 ether);\n', '    createToken(11, 0.005 ether);\n', '    createToken(12, 0.005 ether);\n', '    createToken(13, 0.005 ether);\n', '    createToken(14, 0.005 ether);\n', '    createToken(15, 0.05 ether);\n', '\n', '    // Condos\n', '    createToken(16, 0.05 ether);\n', '    createToken(17, 0.005 ether);\n', '    createToken(18, 0.005 ether);\n', '    createToken(19, 0.005 ether);\n', '    createToken(20, 0.005 ether);\n', '    createToken(21, 0.1 ether); // Penthouse\n', '  }\n', '\n', '  // PUBLIC\n', '\n', '  function createToken(uint256 _tokenId, uint256 _startingPrice) public onlyOwner {\n', '    Token memory token = Token({\n', '      price: _startingPrice,\n', '      owner: owner\n', '    });\n', '\n', '    tokens[_tokenId] = token;\n', '  }\n', '\n', '  function getToken(uint256 _tokenId) public view returns (\n', '    uint256 _price,\n', '    uint256 _nextPrice,\n', '    address _owner\n', '  ) {\n', '    Token memory token = tokens[_tokenId];\n', '    _price = token.price;\n', '    _nextPrice = getNextPrice(token.price);\n', '    _owner = token.owner;\n', '  }\n', '\n', '  function setGameStartTime(uint256 _gameStartTime) public onlyOwner {\n', '    gameStartTime = _gameStartTime;\n', '  }\n', '\n', '  function purchase(uint256 _tokenId) public payable onlyGameStarted {\n', '    Token storage token = tokens[_tokenId];\n', '\n', '    // Value must be greater than or equal to the token price\n', '    require(msg.value >= token.price);\n', '\n', '    // Prevent user from buying their own token\n', '    require(msg.sender != token.owner);\n', '\n', '    uint256 purchaseExcess = msg.value.sub(token.price);\n', '\n', '    address newOwner = msg.sender;\n', '    address oldOwner = token.owner;\n', '\n', '    uint256 devCut = token.price.mul(4).div(100); // 4%\n', '    uint256 towerBossCut = token.price.mul(3).div(100); // 3%\n', '    uint256 managerCut = getManagerCut(_tokenId, token.price); // 0% - 3%\n', '    uint256 oldOwnerProfit = token.price.sub(devCut).sub(towerBossCut).sub(managerCut);\n', '\n', '    // Update token\n', '    uint256 oldPrice = token.price;\n', '    token.owner = newOwner;\n', '    token.price = getNextPrice(token.price);\n', '\n', '    // send funds to the dev\n', '    earnings[owner] = earnings[owner].add(devCut);\n', '\n', '    // send funds to the big boss\n', '    earnings[tokens[TOWER_BOSS_TOKEN_ID].owner] = earnings[tokens[TOWER_BOSS_TOKEN_ID].owner].add(towerBossCut);\n', '\n', '    // send funds to the manager (if applicable)\n', '    if (managerCut > 0) {\n', '      address managerAddress = getManagerAddress(_tokenId);\n', '      earnings[managerAddress] = earnings[managerAddress].add(managerCut);\n', '    }\n', '\n', '    // send profit to the previous owner\n', '    sendFunds(oldOwner, oldOwnerProfit);\n', '\n', '    // refund any excess to the sender\n', '    if (purchaseExcess > 0) {\n', '      sendFunds(newOwner, purchaseExcess);\n', '    }\n', '\n', '    TokenPurchased(_tokenId, oldOwner, newOwner, oldPrice, token.price, now);\n', '  }\n', '\n', '  function withdrawEarnings() public {\n', '    uint256 amount = earnings[msg.sender];\n', '    earnings[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '  /// PRIVATE\n', '\n', '  /// @dev Managers only get a cut of floor sales\n', '  function getManagerCut(uint256 _tokenId, uint256 _price) private pure returns (uint256) {\n', '    if (_tokenId >= BOTTOM_FLOOR_ID) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function getManagerAddress(uint256 _tokenId) private view returns (address) {\n', '    if (_tokenId >= APARTMENT_INDEX_MIN && _tokenId <= APARTMENT_INDEX_MAX) {\n', '      return tokens[APARTMENT_MANAGER_ID].owner;\n', '    } else if (_tokenId >= HOTEL_INDEX_MIN && _tokenId <= HOTEL_INDEX_MAX) {\n', '      return tokens[HOTEL_MANAGER_ID].owner;\n', '    } else if (_tokenId >= CONDO_INDEX_MIN && _tokenId <= CONDO_INDEX_MAX) {\n', '      return tokens[CONDO_MANAGER_ID].owner;\n', '    } else {\n', '      // This should never happen\n', '      return owner;\n', '    }\n', '  }\n', '\n', '  function getNextPrice(uint256 _price) private view returns (uint256) {\n', '    if (_price <= firstStepLimit) {\n', '      return _price.mul(2); // increase by 100%\n', '    } else if (_price <= secondStepLimit) {\n', '      return _price.mul(125).div(100); // increase by 25%\n', '    } else {\n', '      return _price.mul(118).div(100); // increase by 18%\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @dev Attempt to send the funds immediately.\n', '    * If that fails for any reason, force the user\n', '    * to manually withdraw.\n', '    */\n', '  function sendFunds(address _recipient, uint256 _amount) private {\n', '    if (!_recipient.send(_amount)) {\n', '      earnings[_recipient] = earnings[_recipient].add(_amount);\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
