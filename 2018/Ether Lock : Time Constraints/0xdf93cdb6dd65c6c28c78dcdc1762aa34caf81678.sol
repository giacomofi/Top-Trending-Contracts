['pragma solidity 0.4.25;\n', '\n', '\n', 'library SafeMath {\n', '\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract GreenEthereus {\n', '    using SafeMath for uint;\n', '\n', '    address public owner;\n', '    address marketing;\n', '    address admin;\n', '\n', '    mapping (address => uint) index;\n', '    mapping (address => mapping (uint => uint)) deposit;\n', '    mapping (address => mapping (uint => uint)) finish;\n', '    mapping (address => uint) checkpoint;\n', '\n', '    mapping (address => address) referrers;\n', '    mapping (address => uint) refBonus;\n', '\n', '    event LogInvestment(address _addr, uint _value);\n', '    event LogPayment(address _addr, uint _value);\n', '    event LogNewReferrer(address _referral, address _referrer);\n', '    event LogReferralInvestment(address _referral, uint _value);\n', '\n', '    constructor(address _marketing, address _admin) public {\n', '        owner = msg.sender;\n', '        marketing = _marketing;\n', '        admin = _admin;\n', '    }\n', '\n', '    function renounceOwnership() external {\n', '        require(msg.sender == owner);\n', '        owner = 0x0;\n', '    }\n', '\n', '    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\n', '        assembly {\n', '            parsedreferrer := mload(add(_source,0x14))\n', '        }\n', '        return parsedreferrer;\n', '    }\n', '\n', '    function setRef(uint _value) internal {\n', '        address _referrer = bytesToAddress(bytes(msg.data));\n', '        if (_referrer != msg.sender) {\n', '            referrers[msg.sender] = _referrer;\n', '            refBonus[msg.sender] += _value * 3 / 100;\n', '            refBonus[_referrer] += _value / 10;\n', '\n', '            emit LogNewReferrer(msg.sender, _referrer);\n', '            emit LogReferralInvestment(msg.sender, msg.value);\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value == 0) {\n', '            withdraw();\n', '        } else {\n', '            invest();\n', '        }\n', '    }\n', '\n', '    function invest() public payable {\n', '\n', '        require(msg.value >= 50000000000000000);\n', '        admin.transfer(msg.value * 3 / 100);\n', '\n', '        if (deposit[msg.sender][0] > 0 || refBonus[msg.sender] > 0) {\n', '            withdraw();\n', '            if (deposit[msg.sender][0] > 0) {\n', '                index[msg.sender] += 1;\n', '            }\n', '        }\n', '\n', '        checkpoint[msg.sender] = block.timestamp;\n', '        finish[msg.sender][index[msg.sender]] = block.timestamp + (50 * 1 days);\n', '        deposit[msg.sender][index[msg.sender]] = msg.value;\n', '\n', '        if (referrers[msg.sender] != 0x0) {\n', '            marketing.transfer(msg.value * 7 / 50);\n', '            refBonus[referrers[msg.sender]] += msg.value / 10;\n', '            emit LogReferralInvestment(msg.sender, msg.value);\n', '        } else if (msg.data.length == 20) {\n', '            marketing.transfer(msg.value * 7 / 50);\n', '            setRef(msg.value);\n', '        } else {\n', '            marketing.transfer(msg.value * 6 / 25);\n', '        }\n', '\n', '        emit LogInvestment(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw() public {\n', '\n', '        uint _payout = refBonus[msg.sender];\n', '        refBonus[msg.sender] = 0;\n', '\n', '        for (uint i = 0; i <= index[msg.sender]; i++) {\n', '            if (checkpoint[msg.sender] < finish[msg.sender][i]) {\n', '                if (block.timestamp > finish[msg.sender][i]) {\n', '                    _payout = _payout.add((deposit[msg.sender][i].div(25)).mul(finish[msg.sender][i].sub(checkpoint[msg.sender])).div(1 days));\n', '                    checkpoint[msg.sender] = block.timestamp;\n', '                } else {\n', '                    _payout = _payout.add((deposit[msg.sender][i].div(25)).mul(block.timestamp.sub(checkpoint[msg.sender])).div(1 days));\n', '                    checkpoint[msg.sender] = block.timestamp;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (_payout > 0) {\n', '            msg.sender.transfer(_payout);\n', '\n', '            emit LogPayment(msg.sender, _payout);\n', '        }\n', '    }\n', '\n', '    function getInfo1(address _address) public view returns(uint Invested) {\n', '        uint _sum;\n', '        for (uint i = 0; i <= index[_address]; i++) {\n', '            if (block.timestamp < finish[_address][i]) {\n', '                _sum += deposit[_address][i];\n', '            }\n', '        }\n', '        Invested = _sum;\n', '    }\n', '\n', '    function getInfo2(address _address, uint _number) public view returns(uint Deposit_N) {\n', '        if (block.timestamp < finish[_address][_number - 1]) {\n', '            Deposit_N = deposit[_address][_number - 1];\n', '        } else {\n', '            Deposit_N = 0;\n', '        }\n', '    }\n', '\n', '    function getInfo3(address _address) public view returns(uint Dividends, uint Bonuses) {\n', '        uint _payout;\n', '        for (uint i = 0; i <= index[_address]; i++) {\n', '            if (checkpoint[_address] < finish[_address][i]) {\n', '                if (block.timestamp > finish[_address][i]) {\n', '                    _payout = _payout.add((deposit[_address][i].div(25)).mul(finish[_address][i].sub(checkpoint[_address])).div(1 days));\n', '                } else {\n', '                    _payout = _payout.add((deposit[_address][i].div(25)).mul(block.timestamp.sub(checkpoint[_address])).div(1 days));\n', '                }\n', '            }\n', '        }\n', '        Dividends = _payout;\n', '        Bonuses = refBonus[_address];\n', '    }\n', '}']
['pragma solidity 0.4.25;\n', '\n', '\n', 'library SafeMath {\n', '\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract GreenEthereus {\n', '    using SafeMath for uint;\n', '\n', '    address public owner;\n', '    address marketing;\n', '    address admin;\n', '\n', '    mapping (address => uint) index;\n', '    mapping (address => mapping (uint => uint)) deposit;\n', '    mapping (address => mapping (uint => uint)) finish;\n', '    mapping (address => uint) checkpoint;\n', '\n', '    mapping (address => address) referrers;\n', '    mapping (address => uint) refBonus;\n', '\n', '    event LogInvestment(address _addr, uint _value);\n', '    event LogPayment(address _addr, uint _value);\n', '    event LogNewReferrer(address _referral, address _referrer);\n', '    event LogReferralInvestment(address _referral, uint _value);\n', '\n', '    constructor(address _marketing, address _admin) public {\n', '        owner = msg.sender;\n', '        marketing = _marketing;\n', '        admin = _admin;\n', '    }\n', '\n', '    function renounceOwnership() external {\n', '        require(msg.sender == owner);\n', '        owner = 0x0;\n', '    }\n', '\n', '    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\n', '        assembly {\n', '            parsedreferrer := mload(add(_source,0x14))\n', '        }\n', '        return parsedreferrer;\n', '    }\n', '\n', '    function setRef(uint _value) internal {\n', '        address _referrer = bytesToAddress(bytes(msg.data));\n', '        if (_referrer != msg.sender) {\n', '            referrers[msg.sender] = _referrer;\n', '            refBonus[msg.sender] += _value * 3 / 100;\n', '            refBonus[_referrer] += _value / 10;\n', '\n', '            emit LogNewReferrer(msg.sender, _referrer);\n', '            emit LogReferralInvestment(msg.sender, msg.value);\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value == 0) {\n', '            withdraw();\n', '        } else {\n', '            invest();\n', '        }\n', '    }\n', '\n', '    function invest() public payable {\n', '\n', '        require(msg.value >= 50000000000000000);\n', '        admin.transfer(msg.value * 3 / 100);\n', '\n', '        if (deposit[msg.sender][0] > 0 || refBonus[msg.sender] > 0) {\n', '            withdraw();\n', '            if (deposit[msg.sender][0] > 0) {\n', '                index[msg.sender] += 1;\n', '            }\n', '        }\n', '\n', '        checkpoint[msg.sender] = block.timestamp;\n', '        finish[msg.sender][index[msg.sender]] = block.timestamp + (50 * 1 days);\n', '        deposit[msg.sender][index[msg.sender]] = msg.value;\n', '\n', '        if (referrers[msg.sender] != 0x0) {\n', '            marketing.transfer(msg.value * 7 / 50);\n', '            refBonus[referrers[msg.sender]] += msg.value / 10;\n', '            emit LogReferralInvestment(msg.sender, msg.value);\n', '        } else if (msg.data.length == 20) {\n', '            marketing.transfer(msg.value * 7 / 50);\n', '            setRef(msg.value);\n', '        } else {\n', '            marketing.transfer(msg.value * 6 / 25);\n', '        }\n', '\n', '        emit LogInvestment(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw() public {\n', '\n', '        uint _payout = refBonus[msg.sender];\n', '        refBonus[msg.sender] = 0;\n', '\n', '        for (uint i = 0; i <= index[msg.sender]; i++) {\n', '            if (checkpoint[msg.sender] < finish[msg.sender][i]) {\n', '                if (block.timestamp > finish[msg.sender][i]) {\n', '                    _payout = _payout.add((deposit[msg.sender][i].div(25)).mul(finish[msg.sender][i].sub(checkpoint[msg.sender])).div(1 days));\n', '                    checkpoint[msg.sender] = block.timestamp;\n', '                } else {\n', '                    _payout = _payout.add((deposit[msg.sender][i].div(25)).mul(block.timestamp.sub(checkpoint[msg.sender])).div(1 days));\n', '                    checkpoint[msg.sender] = block.timestamp;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (_payout > 0) {\n', '            msg.sender.transfer(_payout);\n', '\n', '            emit LogPayment(msg.sender, _payout);\n', '        }\n', '    }\n', '\n', '    function getInfo1(address _address) public view returns(uint Invested) {\n', '        uint _sum;\n', '        for (uint i = 0; i <= index[_address]; i++) {\n', '            if (block.timestamp < finish[_address][i]) {\n', '                _sum += deposit[_address][i];\n', '            }\n', '        }\n', '        Invested = _sum;\n', '    }\n', '\n', '    function getInfo2(address _address, uint _number) public view returns(uint Deposit_N) {\n', '        if (block.timestamp < finish[_address][_number - 1]) {\n', '            Deposit_N = deposit[_address][_number - 1];\n', '        } else {\n', '            Deposit_N = 0;\n', '        }\n', '    }\n', '\n', '    function getInfo3(address _address) public view returns(uint Dividends, uint Bonuses) {\n', '        uint _payout;\n', '        for (uint i = 0; i <= index[_address]; i++) {\n', '            if (checkpoint[_address] < finish[_address][i]) {\n', '                if (block.timestamp > finish[_address][i]) {\n', '                    _payout = _payout.add((deposit[_address][i].div(25)).mul(finish[_address][i].sub(checkpoint[_address])).div(1 days));\n', '                } else {\n', '                    _payout = _payout.add((deposit[_address][i].div(25)).mul(block.timestamp.sub(checkpoint[_address])).div(1 days));\n', '                }\n', '            }\n', '        }\n', '        Dividends = _payout;\n', '        Bonuses = refBonus[_address];\n', '    }\n', '}']
