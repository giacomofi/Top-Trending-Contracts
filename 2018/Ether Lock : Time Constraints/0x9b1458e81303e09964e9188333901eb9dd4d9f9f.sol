['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract NoboToken is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 totalSupply_;\n', '\n', '    constructor() public {\n', '        name = "Nobotoken";\n', '        symbol = "NBX";\n', '        decimals = 18;\n', '        totalSupply_ = 0;\n', '    }\n', '\n', '    // -----------------------------------------------------------------------\n', '    // ------------------------- GENERAL ERC20 -------------------------------\n', '    // -----------------------------------------------------------------------\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _value\n', '    );\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _value\n', '    );\n', '\n', '    /*\n', '    * @dev tracks token balances of users\n', '    */\n', '    mapping (address => uint256) balances;\n', '\n', '    /*\n', '    * @dev transfer token for a specified address\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '    /*\n', '    * @dev gets the balance of the specified address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '\n', '    // -----------------------------------------------------------------------\n', '    // ------------------------- ALLOWANCE RELEATED --------------------------\n', '    // -----------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev tracks the allowance an address has from another one\n', '    */\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    /*\n', '    * @dev transfers token from one address to another, must have allowance\n', '    */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev gives allowance to spender, works together with transferFrom\n', '    */\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev used to increase the allowance a spender has\n', '    */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint _addedValue\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        allowed[msg.sender][_spender] =\n', '            allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev used to decrease the allowance a spender has\n', '    */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint _subtractedValue\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev used to check what allowance a spender has from the owner\n', '    */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 remaining)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // -----------------------------------------------------------------------\n', '    //--------------------------- MINTING RELEATED ---------------------------\n', '    // -----------------------------------------------------------------------\n', '    /*\n', '    * @title Mintable token\n', '    * @dev instead of another contract, all mintable functionality goes here\n', '    */\n', '    event Mint(\n', '        address indexed to,\n', '        uint256 amount\n', '    );\n', '    event MintFinished();\n', '\n', '    /*\n', '    * @dev signifies whether or not minting process is over\n', '    */\n', '    bool public mintingFinished = false;\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '\n', '    /*\n', '    * @dev minting of tokens, restricted to owner address (crowdsale)\n', '    */\n', '    function mint(\n', '        address _to,\n', '        uint256 _amount\n', '    )\n', '        public\n', '        onlyOwner\n', '        canMint\n', '        returns (bool success)\n', '    {\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Function to stop minting new tokens.\n', '    */\n', '    function finishMinting() onlyOwner canMint public returns (bool success) {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract RefundVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Closed }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    /**\n', '   * @param _wallet Vault address\n', '   */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    /**\n', '   * @param investor Investor address\n', '   */\n', '    function deposit(address investor) onlyOwner public payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    function close() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        emit Closed();\n', '        wallet.transfer(address(this).balance);\n', '    }\n', '\n', '    function enableRefunds() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '\n', '    /**\n', '   * @param investor Investor address\n', '   */\n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        emit Refunded(investor, depositedValue);\n', '    }\n', '\n', '    function batchRefund(address[] _investors) public {\n', '        require(state == State.Refunding);\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '           require(_investors[i] != address(0));\n', '           uint256 _depositedValue = deposited[_investors[i]];\n', '           require(_depositedValue > 0);\n', '           deposited[_investors[i]] = 0;\n', '           _investors[i].transfer(_depositedValue);\n', '           emit Refunded(_investors[i], _depositedValue);\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TimedAccess is Ownable {\n', '   /*\n', '    * @dev Requires msg.sender to have valid access message.\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    * @param _blockNum used to limit access time, will be checked if signed\n', '    * @param _etherPrice must be checked to ensure no tampering\n', '    */\n', '    address public signer;\n', '\n', '    function _setSigner(address _signer) internal {\n', '        require(_signer != address(0));\n', '        signer = _signer;\n', '    }\n', '\n', '    modifier onlyWithValidCode(\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _v,\n', '        uint256 _blockNum,\n', '        uint256 _etherPrice\n', '    )\n', '    {\n', '        require(\n', '            isValidAccessMessage(\n', '                _r,\n', '                _s,\n', '                _v,\n', '                _blockNum,\n', '                _etherPrice,\n', '                msg.sender\n', '            ),\n', '            "Access code is incorrect or expired."\n', '        );\n', '        _;\n', '    }\n', '\n', '\n', '    /*\n', '    * @dev Verifies if message was signed by owner to give access to\n', '    *      _add for this contract.\n', '    *      Assumes Geth signature prefix (\\x19Ethereum Signed Message:\\n32).\n', '    * @param _sender Address of agent with access\n', '    * @return Validity of access message for a given address.\n', '    */\n', '    function isValidAccessMessage(\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _v,\n', '        uint256 _blockNum,\n', '        uint256 _etherPrice,\n', '        address _sender\n', '    )\n', '        view\n', '        public\n', '        returns (bool)\n', '    {\n', '        bytes32 hash = keccak256(\n', '            abi.encodePacked(\n', '                _blockNum,\n', '                _etherPrice,\n', '                _sender\n', '            )\n', '        );\n', '        bool isValid = (\n', '            signer == ecrecover(\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        "\\x19Ethereum Signed Message:\\n32",\n', '                        hash\n', '                    )\n', '                ),\n', '                _v,\n', '                _r,\n', '                _s\n', '            )\n', '        );\n', '\n', '        // after 123 blocks have passed, no purchase is possible\n', '        // (roughly 30 minutes)\n', '        bool isStillTime = (_blockNum + 123 > block.number);\n', '\n', '        return (isValid && isStillTime);\n', '    }\n', '}\n', '\n', 'contract NoboCrowdsale is TimedAccess {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '    * @dev TokenAmountGetter: a library to calculate appropiate token amount\n', '    */\n', '    using TokenAmountGetter for uint256;\n', '\n', '    // -----------------------------------------------------------------------\n', '    // ---------------------------- VARIABLES --------------------------------\n', '    // -----------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev the supervisor can prevent the owner from having control\n', '    */\n', '    address public supervisor;\n', '\n', '    /*\n', '    * @dev wallet = where the ether goes to in a successful crowdsale\n', '    */\n', '    address public wallet;\n', '\n', '    /*\n', '    * @dev token is the actual ERC20 token contract\n', '    */\n', '    NoboToken public token;\n', '\n', '    /*\n', '    * @dev RefundVault: where the ether is stored, used to enable refunds\n', '    */\n', '    RefundVault public vault;\n', '\n', '    /*\n', '    * @dev the base rate for NBX, without any bonuses\n', '    */\n', '    uint256  public baseRate;\n', '\n', '   /*\n', '    * @dev startTime regulates the time bonuses, set when crowdsale begins\n', '    */\n', '    uint256  public startTime;\n', '\n', '    /*\n', '    * @dev softCap = goal of our crowdsale, if it is not reached,\n', '    *   customers can be refunded\n', '    */\n', '    uint256 public softCap;\n', '\n', '    /*\n', '    * @dev maximum amount of ether we can collect in this crowdsale\n', '    */\n', '    uint256 public hardCap;\n', '\n', '    /*\n', '    * @dev the status controls the accessibilty of certain functions, e.g. the\n', '    *   purchase token function (in combination with the modifier onlyDuring)\n', '    */\n', '    enum Status { unstarted, started, ended, paused }\n', '    Status public status;\n', '\n', '    /*\n', '    * @dev balances stores the balances an investor is eligible to\n', '    */\n', '    mapping(address => uint256) public balances;\n', '\n', '    /*\n', '    * @dev accessAllowed-bit needs to be true for certain functions,\n', '    *   can only be switched by supervisor\n', '    */\n', '    bool public accessAllowed;\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // ------------------------------ EVENTS ----------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev NoAccessCode emitted when tx is made without data field\n', '    */\n', '    event NoAccessCode(address indexed sender);\n', '\n', '    /*\n', '    * @dev CapReached signals the end of the crowdsale to us\n', '    */\n', '    event CapReached(address indexed sender, uint256 indexed etherAmount);\n', '\n', '    /*\n', '    * @dev PurchaseTooSmall is emitted when tx with less than 0.1 ETH is made\n', '    */\n', '    event PurchaseTooSmall(address indexed sender, uint256 indexed etherAmount);\n', '\n', '    /*\n', '    * @dev TokenPurchase is the general log for a legit purchase\n', '    */\n', '    event TokenPurchase(\n', '        address indexed investor,\n', '        uint256 indexed etherAmount,\n', '        uint256 indexed etherPrice,\n', '        uint256 tokenAmount\n', '    );\n', '\n', '    /*\n', '    * @dev AccessChanged is emitted when the supervisor dis-/allows functions\n', '    */\n', '    event AccessChanged(bool indexed accessAllowed);\n', '\n', '    /*\n', '    * @dev SignerChanged signals the change of the signer address,\n', '    *   the one against whcih the signature of the access code is compared to\n', '    */\n', '    event SignerChanged(address indexed previousSigner, address indexed newSigner);\n', '\n', '    /*\n', '    * @dev StatusChanged signals the change of crowdsale stages\n', '    */\n', '    event StatusChanged(\n', '        Status indexed previousStatus,\n', '        Status indexed newStatus\n', '    );\n', '\n', '    // ------------------------------------------------------------------------\n', '    // --------------------------- MODIFIER -----------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev restricts functions to certain crowdsale stages\n', '    */\n', '    modifier onlyDuring(Status _status) {\n', '        require (status == _status);\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * @dev akin to onlyOwner\n', '    */\n', '    modifier onlySupervisor() {\n', '        require(supervisor == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * @dev certain functions need permission from the supervisor\n', '    */\n', '    modifier whenAccessAllowed() {\n', '        require(accessAllowed);\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // --------------------------- CONSTRUCTOR --------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev the constructor needs the token contract address\n', '    * @dev the crowdsale contract needs to be made owner of the token contract\n', '    */\n', '    constructor (\n', '        address _tokenAddress,\n', '        address _signer,\n', '        address _supervisor,\n', '        address _wallet\n', '    )\n', '        public\n', '    {\n', '        require(_tokenAddress != address(0));\n', '        require(_signer != address(0));\n', '        require(_supervisor!= address(0));\n', '        require(_wallet != address(0));\n', '        signer = _signer;\n', '        supervisor = _supervisor;\n', '        wallet = _wallet;\n', '        token = NoboToken(_tokenAddress);\n', '        vault = new RefundVault(wallet);\n', '        baseRate = 500;\n', '        softCap = 25000 ether;\n', '        hardCap = 250000 ether;\n', '        status = Status.unstarted;\n', '        accessAllowed = false;\n', '    }\n', '\n', '    /*\n', '    * @dev send ether back to sender when no access code is specified\n', '    */\n', '    function() public payable {\n', '        emit NoAccessCode(msg.sender);\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // -------------------------- MAIN PURCHASE -------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev called by users to buy token, whilst providing their access code\n', '    *   for more information about v, r and as see TimedAccess contract\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    * @param _blockNum used to make sure the user has only a certain timeperiod\n', '    *   to buy the tokens (after a set amount of blocks the function will\n', '    *   not execute anymore. Checked in TimedAccess\n', '    * @param _etherPrice used to get the bonus for the user\n', '    */\n', '    function purchaseTokens(\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _v,\n', '        uint256 _blockNum,\n', '        uint256 _etherPrice\n', '    )\n', '        public\n', '        payable\n', '        onlyDuring(Status.started)\n', '        onlyWithValidCode( _r, _s, _v, _blockNum, _etherPrice)\n', '    {\n', '        if (_isPurchaseValid(msg.sender, msg.value)) {\n', '            uint256 _etherAmount = msg.value;\n', '            uint256 _tokenAmount = _etherAmount.getTokenAmount(\n', '                _etherPrice,\n', '                startTime,\n', '                baseRate\n', '            );\n', '            emit TokenPurchase(msg.sender, _etherAmount, _etherPrice, _tokenAmount);\n', '            // registering purchase in a balance mapping\n', '            _registerPurchase(msg.sender, _tokenAmount);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev checks if ether Amount is sufficient (measured in Euro)\n', '    *   and if the hardcap would be reached\n', '    */\n', '    function _isPurchaseValid(\n', '        address _sender,\n', '        uint256 _etherAmount\n', '    )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        // if raised ether would be more than hardcap, revert\n', '        if (getEtherRaised().add(_etherAmount) > hardCap) {\n', '            _sender.transfer(_etherAmount);\n', '            emit CapReached(_sender, getEtherRaised()); // for testing\n', '            return false;\n', '        }\n', '        if(_etherAmount <  0.1 ether) {\n', '            _sender.transfer(_etherAmount);\n', '            emit PurchaseTooSmall(_sender, _etherAmount);\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Overrides parent by storing balances instead of issuing tokens right away.\n', '    * @param _investor Token purchaser\n', '    * @param _tokenAmount Amount of tokens purchased\n', '    */\n', '    function _registerPurchase(\n', '        address _investor,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        // registering balance of tokens in mapping for the customer\n', '        balances[_investor] = balances[_investor].add(_tokenAmount);\n', '        // and registering in the refundvault\n', '        vault.deposit.value(msg.value)(_investor);\n', '    }\n', '\n', '    /*\n', '    * @dev used to check if refunds need to be enabled\n', '    */\n', '    function _isGoalReached() internal view returns (bool) {\n', '\t    return (getEtherRaised() >= softCap);\n', '    }\n', '\n', '    /*\n', '    * @dev used to check how much ether is in the refundvault\n', '    */\n', '    function getEtherRaised() public view returns (uint256) {\n', '        return address(vault).balance;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // ------------------------- STAGE MANAGEMENT -----------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev used to start Crowdsale, sets the starttime for bonuses\n', '    */\n', '    function startCrowdsale()\n', '        external\n', '        whenAccessAllowed\n', '        onlyOwner\n', '        onlyDuring(Status.unstarted)\n', '    {\n', '        emit StatusChanged(status, Status.started);\n', '        status = Status.started;\n', '        startTime = now;\n', '    }\n', '\n', '    /*\n', '    * @dev ends Crowdsale, enables refunding of contracts\n', '    */\n', '    function endCrowdsale()\n', '        external\n', '        whenAccessAllowed\n', '        onlyOwner\n', '        onlyDuring(Status.started)\n', '    {\n', '        emit StatusChanged(status, Status.ended);\n', '        status = Status.ended;\n', '        if(_isGoalReached()) {\n', '            vault.close();\n', '        } else {\n', '            vault.enableRefunds();\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev can be called in ongoing Crowdsale\n', '    */\n', '    function pauseCrowdsale()\n', '        external\n', '        onlySupervisor\n', '        onlyDuring(Status.started)\n', '    {\n', '        emit StatusChanged(status, Status.paused);\n', '        status = Status.paused;\n', '    }\n', '\n', '    /*\n', '    * @dev if problem was fixed, Crowdsale can resume\n', '    */\n', '    function resumeCrowdsale()\n', '        external\n', '        onlySupervisor\n', '        onlyDuring(Status.paused)\n', '    {\n', '        emit StatusChanged(status, Status.started);\n', '        status = Status.started;\n', '    }\n', '\n', '    /*\n', '    * @dev if problem cant be resolved, cancel the crowdsale\n', '    */\n', '    function cancelCrowdsale()\n', '        external\n', '        onlySupervisor\n', '        onlyDuring(Status.paused)\n', '    {\n', '        emit StatusChanged(status, Status.ended);\n', '        status = Status.ended;\n', '        vault.enableRefunds();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // --------------------------- POSTCROWDSALE ------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '\n', '    /**\n', '    * @dev validate a customer and send the tokens\n', '    */\n', '    function approveInvestor(\n', '        address _beneficiary\n', '    )\n', '        external\n', '        whenAccessAllowed\n', '        onlyOwner\n', '    {\n', '        uint256 _amount = balances[_beneficiary];\n', '        require(_amount > 0);\n', '        balances[_beneficiary] = 0;\n', '        _deliverTokens(_beneficiary, _amount);\n', '    }\n', '\n', '    /*\n', '    * @dev mint tokens using an array to reduce transaction costs\n', '    */\n', '    function approveInvestors(\n', '        address[] _beneficiaries\n', '    )\n', '        external\n', '        whenAccessAllowed\n', '        onlyOwner\n', '    {\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '           require(_beneficiaries[i] != address(0));\n', '           uint256 _amount = balances[_beneficiaries[i]];\n', '           require(_amount > 0);\n', '           balances[_beneficiaries[i]] = 0;\n', '            _deliverTokens(_beneficiaries[i], _amount);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev minting 49 percent for the platform and finishing minting\n', '    */\n', '    function mintForPlatform()\n', '        external\n', '        whenAccessAllowed\n', '        onlyOwner\n', '        onlyDuring(Status.ended)\n', '    {\n', '        uint256 _tokensForPlatform = token.totalSupply().mul(49).div(51);\n', '        require(token.mint(wallet, _tokensForPlatform));\n', '        require(token.finishMinting());\n', '    }\n', '\n', '    /*\n', '    * @dev delivers token to a certain address\n', '    */\n', '    function _deliverTokens(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        require(token.mint(_beneficiary, _tokenAmount));\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // --------------------------- SUPERVISOR ---------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev change signer if account there is problem with the account\n', '    */\n', '    function changeSigner(\n', '        address _newSigner\n', '    )\n', '        external\n', '        onlySupervisor\n', '        onlyDuring(Status.paused)\n', '    {\n', '        require(_newSigner != address(0));\n', '        emit SignerChanged(signer, _newSigner);\n', '        signer = _newSigner;\n', '    }\n', '\n', '    /*\n', '    * @dev change the state of accessAllowed bit, thus locking or freeing functions\n', '    */\n', '    function setAccess(bool value) public onlySupervisor {\n', '        require(accessAllowed != value);\n', '        emit AccessChanged(value);\n', '        accessAllowed = value;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // ----------------------- Expired Crowdsale ------------------------------\n', '    // ------------------------------------------------------------------------\n', '\n', '    /*\n', '    * @dev function for everyone to enable refunds after certain time\n', '    */\n', '    function endExpiredCrowdsale() public {\n', '        require(status != Status.unstarted);\n', '        require(now > startTime + 365 days);\n', '        status = Status.ended;\n', '        if(_isGoalReached()) {\n', '            vault.close();\n', '        } else {\n', '            vault.enableRefunds();\n', '        }\n', '    }\n', '}\n', '\n', 'library TokenAmountGetter {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '    * @dev get the amount of tokens corresponding to the ether amount\n', '    * @param _etherAmount amount of ether the user has invested\n', '    * @param _etherPrice price of ether in euro ca at the time of purchase\n', '    * @param _startTime starting time of the ICO\n', '    * @param _baseRate the base rate of token to ether, constant\n', '    */\n', '    function getTokenAmount(\n', '        uint256 _etherAmount,\n', '        uint256 _etherPrice,\n', '        uint256 _startTime,\n', '        uint256 _baseRate\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _baseTokenAmount = _etherAmount.mul(_baseRate);\n', '        uint256 _timeBonus = _getTimeBonus(_baseTokenAmount, _startTime);\n', '        uint256 _amountBonus = _getAmountBonus(\n', '            _etherAmount,\n', '            _etherPrice,\n', '            _baseTokenAmount\n', '        );\n', '        uint256 _totalBonus = _timeBonus.add(_amountBonus);\n', '\n', '        uint256 _totalAmount = _baseTokenAmount.add(_totalBonus);\n', '\n', '        // another 2% on top if tokens bought in the first 24 hours\n', '        if(_startTime + 1 days > now)\n', '            _totalAmount = _totalAmount.add(_totalAmount.mul(2).div(100));\n', '\n', '        return _totalAmount;\n', '    }\n', '\n', '    /*\n', '    * @dev get time bonus for base amount, does not include 24H 2% on top\n', '    */\n', '    function _getTimeBonus(\n', '        uint256 _baseTokenAmount,\n', '        uint256 _startTime\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (now <= (_startTime + 1 weeks))\n', '            return (_baseTokenAmount.mul(20).div(100));\n', '        if (now <= (_startTime + 2 weeks))\n', '            return (_baseTokenAmount.mul(18).div(100));\n', '        if (now <= (_startTime + 3 weeks))\n', '            return (_baseTokenAmount.mul(16).div(100));\n', '        if (now <= (_startTime + 4 weeks))\n', '            return (_baseTokenAmount.mul(14).div(100));\n', '        if (now <= (_startTime + 5 weeks))\n', '            return (_baseTokenAmount.mul(12).div(100));\n', '        if (now <= (_startTime + 6 weeks))\n', '            return (_baseTokenAmount.mul(10).div(100));\n', '        if (now <= (_startTime + 7 weeks))\n', '            return (_baseTokenAmount.mul(8).div(100));\n', '        if (now <= (_startTime + 8 weeks))\n', '            return (_baseTokenAmount.mul(6).div(100));\n', '        if (now <= (_startTime + 9 weeks))\n', '            return (_baseTokenAmount.mul(4).div(100));\n', '        if (now <= (_startTime + 10 weeks))\n', '            return (_baseTokenAmount.mul(2).div(100));\n', '        return 0;\n', '    }\n', '\n', '    /*\n', '    * @dev get amount bonus for amount measured in euro, which is\n', '    *   determined by the current price and amount\n', '    */\n', '    function _getAmountBonus(\n', '        uint256 _etherAmount,\n', '        uint256 _etherPrice,\n', '        uint256 _baseTokenAmount\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 _etherAmountInEuro = _etherAmount.mul(_etherPrice).div(1 ether);\n', '        if (_etherAmountInEuro < 100000)\n', '            return 0;\n', '        if (_etherAmountInEuro >= 100000 && _etherAmountInEuro < 150000)\n', '            return (_baseTokenAmount.mul(3)).div(100);\n', '        if (_etherAmountInEuro >= 150000 && _etherAmountInEuro < 200000)\n', '            return (_baseTokenAmount.mul(6)).div(100);\n', '        if (_etherAmountInEuro >= 200000 && _etherAmountInEuro < 300000)\n', '            return (_baseTokenAmount.mul(9)).div(100);\n', '        if (_etherAmountInEuro >= 300000 && _etherAmountInEuro < 1000000)\n', '            return (_baseTokenAmount.mul(12)).div(100);\n', '        if (_etherAmountInEuro >= 1000000 && _etherAmountInEuro < 1500000)\n', '            return (_baseTokenAmount.mul(15)).div(100);\n', '        if (_etherAmountInEuro >= 1500000)\n', '            return (_baseTokenAmount.mul(20)).div(100);\n', '    }\n', '}']