['pragma solidity ^0.4.16;\n', '\n', '// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dab9b5b4aebbb9ae9a9faeb2bfa8bfb7b5b4f4b9b5b7">[email&#160;protected]</a>\n', '\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT,\n', '        ERROR_OBJ_NOT_FOUND,\n', '        ERROR_OBJ_INVALID_OWNERSHIP\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n', '    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n', '    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\n', '    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\n', '    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\n', '    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n', '    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n', '    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n', '    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\n', '    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\n', '    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\n', '    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n', '    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n', '    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;\n', '    \n', '    // read\n', '    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\n', '    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant public returns(string name);\n', '    function getExtraBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant public returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '}\n', '\n', 'contract EtheremonTransformData {\n', '    uint64 public totalEgg = 0;\n', '    function getHatchingEggId(address _trainer) constant external returns(uint64);\n', '    function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64);\n', '    function getTranformedId(uint64 _objId) constant external returns(uint64);\n', '    function countEgg(uint64 _objId) constant external returns(uint);\n', '    \n', '    function setHatchTime(uint64 _eggId, uint _hatchTime) external;\n', '    function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external;\n', '    function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64);\n', '    function setTranformed(uint64 _objId, uint64 _newObjId) external;\n', '}\n', '\n', 'contract EtheremonWorld is EtheremonEnum {\n', '    \n', '    function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32);\n', '    function getTrainerEarn(address _trainer) constant public returns(uint256);\n', '    function getReturnFromMonster(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '    function getClassPropertyValue(uint32 _classId, PropertyType _type, uint index) constant external returns(uint32);\n', '    function getClassPropertySize(uint32 _classId, PropertyType _type) constant external returns(uint);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '    function getMonsterLevel(uint64 _objId) constant public returns(uint8);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'contract EtheremonTransform is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '    uint8 constant public GEN0_NO = 24;\n', '    \n', '    struct MonsterClassAcc {\n', '        uint32 classId;\n', '        uint256 price;\n', '        uint256 returnPrice;\n', '        uint32 total;\n', '        bool catchable;\n', '    }\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '    \n', '    struct MonsterEgg {\n', '        uint64 eggId;\n', '        uint64 objId;\n', '        uint32 classId;\n', '        address trainer;\n', '        uint hatchTime;\n', '        uint64 newObjId;\n', '    }\n', '    \n', '    struct BasicObjInfo {\n', '        uint32 classId;\n', '        address owner;\n', '        uint8 level;\n', '    }\n', '    \n', '    // Gen0 has return price & no longer can be caught when this contract is deployed\n', '    struct Gen0Config {\n', '        uint32 classId;\n', '        uint256 originalPrice;\n', '        uint256 returnPrice;\n', '        uint32 total; // total caught (not count those from eggs)\n', '    }\n', '    \n', '    // hatching range\n', '    uint16 public hatchStartTime = 2; // hour\n', '    uint16 public hatchMaxTime = 46; // hour\n', '    uint public removeHatchingTimeFee = 0.05 ether; // ETH\n', '    uint public buyEggFee = 0.06 ether; // ETH\n', '    \n', '    uint32[] public randomClassIds;\n', '    mapping(uint32 => uint8) public layingEggLevels;\n', '    mapping(uint32 => uint8) public layingEggDeductions;\n', '    mapping(uint32 => uint8) public transformLevels;\n', '    mapping(uint32 => uint32) public transformClasses;\n', '\n', '    mapping(uint8 => uint32) public levelExps;\n', '    address private lastHatchingAddress;\n', '    \n', '    mapping(uint32 => Gen0Config) public gen0Config;\n', '    \n', '    // linked smart contract\n', '    address public dataContract;\n', '    address public worldContract;\n', '    address public transformDataContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    \n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event EventLayEgg(address indexed trainer, uint64 objId, uint64 eggId);\n', '    \n', '    // modifier\n', '    \n', '    modifier requireDataContract {\n', '        require(dataContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireTransformDataContract {\n', '        require(transformDataContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireBattleContract {\n', '        require(battleContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireTradeContract {\n', '        require(tradeContract != address(0));\n', '        _;        \n', '    }\n', '    \n', '    \n', '    // constructor\n', '    function EtheremonTransform(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) public {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '    \n', '    // helper\n', '    function getRandom(uint16 maxRan, uint8 index, address priAddress) constant public returns(uint8) {\n', '        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(priAddress);\n', '        for (uint8 i = 0; i < index && i < 6; i ++) {\n', '            genNum /= 256;\n', '        }\n', '        return uint8(genNum % maxRan);\n', '    }\n', '    \n', '    function addNewObj(address _trainer, uint32 _classId) private returns(uint64) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        uint64 objId = data.addMonsterObj(_classId, _trainer, "..name me...");\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            uint8 value = getRandom(STAT_MAX, uint8(i), lastHatchingAddress) + data.getElementInArrayType(ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        return objId;\n', '    }\n', '    \n', '    // admin & moderators\n', '    function setContract(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '\n', '    function setOriginalPriceGen0() onlyModerators external {\n', '        gen0Config[1] = Gen0Config(1, 0.3 ether, 0.003 ether, 374);\n', '        gen0Config[2] = Gen0Config(2, 0.3 ether, 0.003 ether, 408);\n', '        gen0Config[3] = Gen0Config(3, 0.3 ether, 0.003 ether, 373);\n', '        gen0Config[4] = Gen0Config(4, 0.2 ether, 0.002 ether, 437);\n', '        gen0Config[5] = Gen0Config(5, 0.1 ether, 0.001 ether, 497);\n', '        gen0Config[6] = Gen0Config(6, 0.3 ether, 0.003 ether, 380); \n', '        gen0Config[7] = Gen0Config(7, 0.2 ether, 0.002 ether, 345);\n', '        gen0Config[8] = Gen0Config(8, 0.1 ether, 0.001 ether, 518); \n', '        gen0Config[9] = Gen0Config(9, 0.1 ether, 0.001 ether, 447);\n', '        gen0Config[10] = Gen0Config(10, 0.2 ether, 0.002 ether, 380); \n', '        gen0Config[11] = Gen0Config(11, 0.2 ether, 0.002 ether, 354);\n', '        gen0Config[12] = Gen0Config(12, 0.2 ether, 0.002 ether, 346);\n', '        gen0Config[13] = Gen0Config(13, 0.2 ether, 0.002 ether, 351); \n', '        gen0Config[14] = Gen0Config(14, 0.2 ether, 0.002 ether, 338);\n', '        gen0Config[15] = Gen0Config(15, 0.2 ether, 0.002 ether, 341);\n', '        gen0Config[16] = Gen0Config(16, 0.35 ether, 0.0035 ether, 384);\n', '        gen0Config[17] = Gen0Config(17, 1 ether, 0.01 ether, 305); \n', '        gen0Config[18] = Gen0Config(18, 0.1 ether, 0.001 ether, 427);\n', '        gen0Config[19] = Gen0Config(19, 1 ether, 0.01 ether, 304);\n', '        gen0Config[20] = Gen0Config(20, 0.4 ether, 0.05 ether, 82);\n', '        gen0Config[21] = Gen0Config(21, 1, 1, 123);\n', '        gen0Config[22] = Gen0Config(22, 0.2 ether, 0.001 ether, 468);\n', '        gen0Config[23] = Gen0Config(23, 0.5 ether, 0.0025 ether, 302);\n', '        gen0Config[24] = Gen0Config(24, 1 ether, 0.005 ether, 195);\n', '    }    \n', '\n', '    function updateHatchingRange(uint16 _start, uint16 _max) onlyModerators external {\n', '        hatchStartTime = _start;\n', '        hatchMaxTime = _max;\n', '    }\n', '\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        // no user money is kept in this contract, only trasaction fee\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '\n', '    function setConfigClass(uint32 _classId, uint8 _layingLevel, uint8 _layingCost, uint8 _transformLevel, uint32 _tranformClass) onlyModerators external {\n', '        layingEggLevels[_classId] = _layingLevel;\n', '        layingEggDeductions[_classId] = _layingCost;\n', '        transformLevels[_classId] = _transformLevel;\n', '        transformClasses[_classId] = _tranformClass;\n', '    }\n', '    \n', '    function setConfig(uint _removeHatchingTimeFee, uint _buyEggFee) onlyModerators external {\n', '        removeHatchingTimeFee = _removeHatchingTimeFee;\n', '        buyEggFee = _buyEggFee;\n', '    }\n', '\n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function addRandomClass(uint32 _newClassId) onlyModerators public {\n', '        if (_newClassId > 0) {\n', '            for (uint index = 0; index < randomClassIds.length; index++) {\n', '                if (randomClassIds[index] == _newClassId) {\n', '                    return;\n', '                }\n', '            }\n', '            randomClassIds.push(_newClassId);\n', '        }\n', '    }\n', '    \n', '    function removeRandomClass(uint32 _oldClassId) onlyModerators public {\n', '        uint foundIndex = 0;\n', '        for (; foundIndex < randomClassIds.length; foundIndex++) {\n', '            if (randomClassIds[foundIndex] == _oldClassId) {\n', '                break;\n', '            }\n', '        }\n', '        if (foundIndex < randomClassIds.length) {\n', '            randomClassIds[foundIndex] = randomClassIds[randomClassIds.length-1];\n', '            delete randomClassIds[randomClassIds.length-1];\n', '            randomClassIds.length--;\n', '        }\n', '    }\n', '    \n', '    function removeHatchingTimeWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(_trainer);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != _trainer || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        transformData.setHatchTime(egg.eggId, 0);\n', '    }    \n', '    \n', '    function buyEggWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\n', '        if (randomClassIds.length == 0) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(_trainer) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\n', '        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], _trainer, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // public\n', '\n', '    function ceil(uint a, uint m) pure public returns (uint) {\n', '        return ((a + m - 1) / m) * m;\n', '    }\n', '\n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '\n', '    function getGen0ObjInfo(uint64 _objId) constant public returns(uint32, uint32, uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        \n', '        Gen0Config memory gen0 = gen0Config[obj.classId];\n', '        if (gen0.classId != obj.classId) {\n', '            return (gen0.classId, obj.createIndex, 0);\n', '        }\n', '        \n', '        uint32 totalGap = 0;\n', '        if (obj.createIndex < gen0.total)\n', '            totalGap = gen0.total - obj.createIndex;\n', '        \n', '        return (obj.classId, obj.createIndex, safeMult(totalGap, gen0.returnPrice));\n', '    }\n', '    \n', '    function getObjClassId(uint64 _objId) requireDataContract constant public returns(uint32, address, uint8) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        return (obj.classId, obj.trainer, getLevel(obj.exp));\n', '    }\n', '    \n', '    function getClassCheckOwner(uint64 _objId, address _trainer) requireDataContract constant public returns(uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (_trainer != obj.trainer)\n', '            return 0;\n', '        return obj.classId;\n', '    }\n', '\n', '    function calculateMaxEggG0(uint64 _objId) constant public returns(uint) {\n', '        uint32 classId;\n', '        uint32 createIndex; \n', '        uint256 totalEarn;\n', '        (classId, createIndex, totalEarn) = getGen0ObjInfo(_objId);\n', '        if (classId > GEN0_NO || classId == 20 || classId == 21)\n', '            return 0;\n', '        \n', '        Gen0Config memory config = gen0Config[classId];\n', '        // the one from egg can not lay\n', '        if (createIndex > config.total)\n', '            return 0;\n', '\n', '        // calculate agv price\n', '        uint256 avgPrice = config.originalPrice;\n', '        uint rate = config.originalPrice/config.returnPrice;\n', '        if (config.total > rate) {\n', '            uint k = config.total - rate;\n', '            avgPrice = (config.total * config.originalPrice + config.returnPrice * k * (k+1) / 2) / config.total;\n', '        }\n', '        uint256 catchPrice = config.originalPrice;            \n', '        if (createIndex > rate) {\n', '            catchPrice += config.returnPrice * safeSubtract(createIndex, rate);\n', '        }\n', '        if (totalEarn >= catchPrice) {\n', '            return 0;\n', '        }\n', '        return ceil((catchPrice - totalEarn)*15*1000/avgPrice, 10000)/10000;\n', '    }\n', '    \n', '    function canLayEgg(uint64 _objId, uint32 _classId, uint32 _level) constant public returns(bool) {\n', '        if (_classId <= GEN0_NO) {\n', '            EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '            // legends\n', '            if (transformData.countEgg(_objId) >= calculateMaxEggG0(_objId))\n', '                return false;\n', '            return true;\n', '        } else {\n', '            if (layingEggLevels[_classId] == 0 || _level < layingEggLevels[_classId])\n', '                return false;\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function layEgg(uint64 _objId) isActive requireDataContract requireTransformDataContract external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // can not lay egg when trading\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        // check obj \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (obj.monsterId != _objId || obj.trainer != msg.sender) {\n', '            revert();\n', '        }\n', '        \n', '        // check lay egg condition\n', '        uint8 currentLevel = getLevel(obj.exp);\n', '        uint8 afterLevel = 0;\n', '        if (!canLayEgg(_objId, obj.classId, currentLevel))\n', '            revert();\n', '        if (layingEggDeductions[obj.classId] >= currentLevel)\n', '            revert();\n', '        afterLevel = currentLevel - layingEggDeductions[obj.classId];\n', '\n', '        // add egg \n', '        uint64 eggId = transformData.addEgg(obj.monsterId, obj.classId, msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        \n', '        // deduct exp \n', '        if (afterLevel < currentLevel)\n', '            data.decreaseMonsterExp(_objId, obj.exp - levelExps[afterLevel-1]);\n', '        EventLayEgg(msg.sender, _objId, eggId);\n', '    }\n', '    \n', '    function hatchEgg() isActive requireDataContract requireTransformDataContract external {\n', '        // use as a seed for random\n', '        lastHatchingAddress = msg.sender;\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender)\n', '            revert();\n', '        // need more time\n', '        if (egg.newObjId > 0 || egg.hatchTime > block.timestamp) {\n', '            revert();\n', '        }\n', '        \n', '        uint64 objId = addNewObj(msg.sender, egg.classId);\n', '        transformData.setHatchedEgg(egg.eggId, objId);\n', '        \n', '        Transfer(address(0), msg.sender, objId);\n', '    }\n', '    \n', '    function removeHatchingTime() isActive requireDataContract requireTransformDataContract external payable  {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        if (msg.value != removeHatchingTimeFee) {\n', '            revert();\n', '        }\n', '        transformData.setHatchTime(egg.eggId, 0);\n', '    }\n', '\n', '    \n', '    function checkAncestors(uint32 _classId, address _trainer, uint64 _a1, uint64 _a2, uint64 _a3) constant public returns(bool) {\n', '        EtheremonWorld world = EtheremonWorld(worldContract);\n', '        uint index = 0;\n', '        uint32 temp = 0;\n', '        // check ancestor\n', '        uint32[3] memory ancestors;\n', '        uint32[3] memory requestAncestors;\n', '        index = world.getClassPropertySize(_classId, PropertyType.ANCESTOR);\n', '        while (index > 0) {\n', '            index -= 1;\n', '            ancestors[index] = world.getClassPropertyValue(_classId, PropertyType.ANCESTOR, index);\n', '        }\n', '            \n', '        if (_a1 > 0) {\n', '            temp = getClassCheckOwner(_a1, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[0] = temp;\n', '        }\n', '        if (_a2 > 0) {\n', '            temp = getClassCheckOwner(_a2, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[1] = temp;\n', '        }\n', '        if (_a3 > 0) {\n', '            temp = getClassCheckOwner(_a3, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[2] = temp;\n', '        }\n', '            \n', '        if (requestAncestors[0] > 0 && (requestAncestors[0] == requestAncestors[1] || requestAncestors[0] == requestAncestors[2]))\n', '            return false;\n', '        if (requestAncestors[1] > 0 && (requestAncestors[1] == requestAncestors[2]))\n', '            return false;\n', '                \n', '        for (index = 0; index < ancestors.length; index++) {\n', '            temp = ancestors[index];\n', '            if (temp > 0 && temp != requestAncestors[0]  && temp != requestAncestors[1] && temp != requestAncestors[2])\n', '                return false;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transform(uint64 _objId, uint64 _a1, uint64 _a2, uint64 _a3) isActive requireDataContract requireTransformDataContract external payable {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        if (transformData.getTranformedId(_objId) > 0)\n', '            revert();\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (battle.isOnBattle(_objId) || trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        BasicObjInfo memory objInfo;\n', '        (objInfo.classId, objInfo.owner, objInfo.level) = getObjClassId(_objId);\n', '        uint32 transformClass = transformClasses[objInfo.classId];\n', '        if (objInfo.classId == 0 || objInfo.owner != msg.sender)\n', '            revert();\n', '        if (transformLevels[objInfo.classId] == 0 || objInfo.level < transformLevels[objInfo.classId])\n', '            revert();\n', '        if (transformClass == 0)\n', '            revert();\n', '        \n', '        \n', '        // gen0 - can not transform if it has bonus egg \n', '        if (objInfo.classId <= GEN0_NO) {\n', '            // legends\n', '            if (getBonusEgg(_objId) > 0)\n', '                revert();\n', '        } else {\n', '            if (!checkAncestors(objInfo.classId, msg.sender, _a1, _a2, _a3))\n', '                revert();\n', '        }\n', '        \n', '        uint64 newObjId = addNewObj(msg.sender, transformClass);\n', '        // remove old one\n', '        data.removeMonsterIdMapping(msg.sender, _objId);\n', '        transformData.setTranformed(_objId, newObjId);\n', '        \n', '        Transfer(msg.sender, address(0), _objId);\n', '        Transfer(address(0), msg.sender, newObjId);\n', '    }\n', '    \n', '    function buyEgg() isActive requireDataContract requireTransformDataContract external payable {\n', '        if (msg.value != buyEggFee) {\n', '            revert();\n', '        }\n', '        \n', '        if (randomClassIds.length == 0) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\n', '        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // read\n', '    function getBonusEgg(uint64 _objId) constant public returns(uint) {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        uint totalBonusEgg = calculateMaxEggG0(_objId);\n', '        if (totalBonusEgg > 0) {\n', '            return (totalBonusEgg - transformData.countEgg(_objId));\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.16;\n', '\n', '// copyright contact@Etheremon.com\n', '\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT,\n', '        ERROR_OBJ_NOT_FOUND,\n', '        ERROR_OBJ_INVALID_OWNERSHIP\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n', '    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n', '    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\n', '    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\n', '    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\n', '    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n', '    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n', '    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n', '    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\n', '    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\n', '    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\n', '    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n', '    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n', '    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;\n', '    \n', '    // read\n', '    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\n', '    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant public returns(string name);\n', '    function getExtraBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant public returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '}\n', '\n', 'contract EtheremonTransformData {\n', '    uint64 public totalEgg = 0;\n', '    function getHatchingEggId(address _trainer) constant external returns(uint64);\n', '    function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64);\n', '    function getTranformedId(uint64 _objId) constant external returns(uint64);\n', '    function countEgg(uint64 _objId) constant external returns(uint);\n', '    \n', '    function setHatchTime(uint64 _eggId, uint _hatchTime) external;\n', '    function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external;\n', '    function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64);\n', '    function setTranformed(uint64 _objId, uint64 _newObjId) external;\n', '}\n', '\n', 'contract EtheremonWorld is EtheremonEnum {\n', '    \n', '    function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32);\n', '    function getTrainerEarn(address _trainer) constant public returns(uint256);\n', '    function getReturnFromMonster(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '    function getClassPropertyValue(uint32 _classId, PropertyType _type, uint index) constant external returns(uint32);\n', '    function getClassPropertySize(uint32 _classId, PropertyType _type) constant external returns(uint);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '    function getMonsterLevel(uint64 _objId) constant public returns(uint8);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'contract EtheremonTransform is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '    uint8 constant public GEN0_NO = 24;\n', '    \n', '    struct MonsterClassAcc {\n', '        uint32 classId;\n', '        uint256 price;\n', '        uint256 returnPrice;\n', '        uint32 total;\n', '        bool catchable;\n', '    }\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '    \n', '    struct MonsterEgg {\n', '        uint64 eggId;\n', '        uint64 objId;\n', '        uint32 classId;\n', '        address trainer;\n', '        uint hatchTime;\n', '        uint64 newObjId;\n', '    }\n', '    \n', '    struct BasicObjInfo {\n', '        uint32 classId;\n', '        address owner;\n', '        uint8 level;\n', '    }\n', '    \n', '    // Gen0 has return price & no longer can be caught when this contract is deployed\n', '    struct Gen0Config {\n', '        uint32 classId;\n', '        uint256 originalPrice;\n', '        uint256 returnPrice;\n', '        uint32 total; // total caught (not count those from eggs)\n', '    }\n', '    \n', '    // hatching range\n', '    uint16 public hatchStartTime = 2; // hour\n', '    uint16 public hatchMaxTime = 46; // hour\n', '    uint public removeHatchingTimeFee = 0.05 ether; // ETH\n', '    uint public buyEggFee = 0.06 ether; // ETH\n', '    \n', '    uint32[] public randomClassIds;\n', '    mapping(uint32 => uint8) public layingEggLevels;\n', '    mapping(uint32 => uint8) public layingEggDeductions;\n', '    mapping(uint32 => uint8) public transformLevels;\n', '    mapping(uint32 => uint32) public transformClasses;\n', '\n', '    mapping(uint8 => uint32) public levelExps;\n', '    address private lastHatchingAddress;\n', '    \n', '    mapping(uint32 => Gen0Config) public gen0Config;\n', '    \n', '    // linked smart contract\n', '    address public dataContract;\n', '    address public worldContract;\n', '    address public transformDataContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    \n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event EventLayEgg(address indexed trainer, uint64 objId, uint64 eggId);\n', '    \n', '    // modifier\n', '    \n', '    modifier requireDataContract {\n', '        require(dataContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireTransformDataContract {\n', '        require(transformDataContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireBattleContract {\n', '        require(battleContract != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier requireTradeContract {\n', '        require(tradeContract != address(0));\n', '        _;        \n', '    }\n', '    \n', '    \n', '    // constructor\n', '    function EtheremonTransform(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) public {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '    \n', '    // helper\n', '    function getRandom(uint16 maxRan, uint8 index, address priAddress) constant public returns(uint8) {\n', '        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(priAddress);\n', '        for (uint8 i = 0; i < index && i < 6; i ++) {\n', '            genNum /= 256;\n', '        }\n', '        return uint8(genNum % maxRan);\n', '    }\n', '    \n', '    function addNewObj(address _trainer, uint32 _classId) private returns(uint64) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        uint64 objId = data.addMonsterObj(_classId, _trainer, "..name me...");\n', '        for (uint i=0; i < STAT_COUNT; i+= 1) {\n', '            uint8 value = getRandom(STAT_MAX, uint8(i), lastHatchingAddress) + data.getElementInArrayType(ArrayType.STAT_START, uint64(_classId), i);\n', '            data.addElementToArrayType(ArrayType.STAT_BASE, objId, value);\n', '        }\n', '        return objId;\n', '    }\n', '    \n', '    // admin & moderators\n', '    function setContract(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '\n', '    function setOriginalPriceGen0() onlyModerators external {\n', '        gen0Config[1] = Gen0Config(1, 0.3 ether, 0.003 ether, 374);\n', '        gen0Config[2] = Gen0Config(2, 0.3 ether, 0.003 ether, 408);\n', '        gen0Config[3] = Gen0Config(3, 0.3 ether, 0.003 ether, 373);\n', '        gen0Config[4] = Gen0Config(4, 0.2 ether, 0.002 ether, 437);\n', '        gen0Config[5] = Gen0Config(5, 0.1 ether, 0.001 ether, 497);\n', '        gen0Config[6] = Gen0Config(6, 0.3 ether, 0.003 ether, 380); \n', '        gen0Config[7] = Gen0Config(7, 0.2 ether, 0.002 ether, 345);\n', '        gen0Config[8] = Gen0Config(8, 0.1 ether, 0.001 ether, 518); \n', '        gen0Config[9] = Gen0Config(9, 0.1 ether, 0.001 ether, 447);\n', '        gen0Config[10] = Gen0Config(10, 0.2 ether, 0.002 ether, 380); \n', '        gen0Config[11] = Gen0Config(11, 0.2 ether, 0.002 ether, 354);\n', '        gen0Config[12] = Gen0Config(12, 0.2 ether, 0.002 ether, 346);\n', '        gen0Config[13] = Gen0Config(13, 0.2 ether, 0.002 ether, 351); \n', '        gen0Config[14] = Gen0Config(14, 0.2 ether, 0.002 ether, 338);\n', '        gen0Config[15] = Gen0Config(15, 0.2 ether, 0.002 ether, 341);\n', '        gen0Config[16] = Gen0Config(16, 0.35 ether, 0.0035 ether, 384);\n', '        gen0Config[17] = Gen0Config(17, 1 ether, 0.01 ether, 305); \n', '        gen0Config[18] = Gen0Config(18, 0.1 ether, 0.001 ether, 427);\n', '        gen0Config[19] = Gen0Config(19, 1 ether, 0.01 ether, 304);\n', '        gen0Config[20] = Gen0Config(20, 0.4 ether, 0.05 ether, 82);\n', '        gen0Config[21] = Gen0Config(21, 1, 1, 123);\n', '        gen0Config[22] = Gen0Config(22, 0.2 ether, 0.001 ether, 468);\n', '        gen0Config[23] = Gen0Config(23, 0.5 ether, 0.0025 ether, 302);\n', '        gen0Config[24] = Gen0Config(24, 1 ether, 0.005 ether, 195);\n', '    }    \n', '\n', '    function updateHatchingRange(uint16 _start, uint16 _max) onlyModerators external {\n', '        hatchStartTime = _start;\n', '        hatchMaxTime = _max;\n', '    }\n', '\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        // no user money is kept in this contract, only trasaction fee\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '\n', '    function setConfigClass(uint32 _classId, uint8 _layingLevel, uint8 _layingCost, uint8 _transformLevel, uint32 _tranformClass) onlyModerators external {\n', '        layingEggLevels[_classId] = _layingLevel;\n', '        layingEggDeductions[_classId] = _layingCost;\n', '        transformLevels[_classId] = _transformLevel;\n', '        transformClasses[_classId] = _tranformClass;\n', '    }\n', '    \n', '    function setConfig(uint _removeHatchingTimeFee, uint _buyEggFee) onlyModerators external {\n', '        removeHatchingTimeFee = _removeHatchingTimeFee;\n', '        buyEggFee = _buyEggFee;\n', '    }\n', '\n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function addRandomClass(uint32 _newClassId) onlyModerators public {\n', '        if (_newClassId > 0) {\n', '            for (uint index = 0; index < randomClassIds.length; index++) {\n', '                if (randomClassIds[index] == _newClassId) {\n', '                    return;\n', '                }\n', '            }\n', '            randomClassIds.push(_newClassId);\n', '        }\n', '    }\n', '    \n', '    function removeRandomClass(uint32 _oldClassId) onlyModerators public {\n', '        uint foundIndex = 0;\n', '        for (; foundIndex < randomClassIds.length; foundIndex++) {\n', '            if (randomClassIds[foundIndex] == _oldClassId) {\n', '                break;\n', '            }\n', '        }\n', '        if (foundIndex < randomClassIds.length) {\n', '            randomClassIds[foundIndex] = randomClassIds[randomClassIds.length-1];\n', '            delete randomClassIds[randomClassIds.length-1];\n', '            randomClassIds.length--;\n', '        }\n', '    }\n', '    \n', '    function removeHatchingTimeWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(_trainer);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != _trainer || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        transformData.setHatchTime(egg.eggId, 0);\n', '    }    \n', '    \n', '    function buyEggWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\n', '        if (randomClassIds.length == 0) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(_trainer) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\n', '        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], _trainer, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // public\n', '\n', '    function ceil(uint a, uint m) pure public returns (uint) {\n', '        return ((a + m - 1) / m) * m;\n', '    }\n', '\n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '\n', '    function getGen0ObjInfo(uint64 _objId) constant public returns(uint32, uint32, uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        \n', '        Gen0Config memory gen0 = gen0Config[obj.classId];\n', '        if (gen0.classId != obj.classId) {\n', '            return (gen0.classId, obj.createIndex, 0);\n', '        }\n', '        \n', '        uint32 totalGap = 0;\n', '        if (obj.createIndex < gen0.total)\n', '            totalGap = gen0.total - obj.createIndex;\n', '        \n', '        return (obj.classId, obj.createIndex, safeMult(totalGap, gen0.returnPrice));\n', '    }\n', '    \n', '    function getObjClassId(uint64 _objId) requireDataContract constant public returns(uint32, address, uint8) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        return (obj.classId, obj.trainer, getLevel(obj.exp));\n', '    }\n', '    \n', '    function getClassCheckOwner(uint64 _objId, address _trainer) requireDataContract constant public returns(uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (_trainer != obj.trainer)\n', '            return 0;\n', '        return obj.classId;\n', '    }\n', '\n', '    function calculateMaxEggG0(uint64 _objId) constant public returns(uint) {\n', '        uint32 classId;\n', '        uint32 createIndex; \n', '        uint256 totalEarn;\n', '        (classId, createIndex, totalEarn) = getGen0ObjInfo(_objId);\n', '        if (classId > GEN0_NO || classId == 20 || classId == 21)\n', '            return 0;\n', '        \n', '        Gen0Config memory config = gen0Config[classId];\n', '        // the one from egg can not lay\n', '        if (createIndex > config.total)\n', '            return 0;\n', '\n', '        // calculate agv price\n', '        uint256 avgPrice = config.originalPrice;\n', '        uint rate = config.originalPrice/config.returnPrice;\n', '        if (config.total > rate) {\n', '            uint k = config.total - rate;\n', '            avgPrice = (config.total * config.originalPrice + config.returnPrice * k * (k+1) / 2) / config.total;\n', '        }\n', '        uint256 catchPrice = config.originalPrice;            \n', '        if (createIndex > rate) {\n', '            catchPrice += config.returnPrice * safeSubtract(createIndex, rate);\n', '        }\n', '        if (totalEarn >= catchPrice) {\n', '            return 0;\n', '        }\n', '        return ceil((catchPrice - totalEarn)*15*1000/avgPrice, 10000)/10000;\n', '    }\n', '    \n', '    function canLayEgg(uint64 _objId, uint32 _classId, uint32 _level) constant public returns(bool) {\n', '        if (_classId <= GEN0_NO) {\n', '            EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '            // legends\n', '            if (transformData.countEgg(_objId) >= calculateMaxEggG0(_objId))\n', '                return false;\n', '            return true;\n', '        } else {\n', '            if (layingEggLevels[_classId] == 0 || _level < layingEggLevels[_classId])\n', '                return false;\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function layEgg(uint64 _objId) isActive requireDataContract requireTransformDataContract external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // can not lay egg when trading\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        // check obj \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (obj.monsterId != _objId || obj.trainer != msg.sender) {\n', '            revert();\n', '        }\n', '        \n', '        // check lay egg condition\n', '        uint8 currentLevel = getLevel(obj.exp);\n', '        uint8 afterLevel = 0;\n', '        if (!canLayEgg(_objId, obj.classId, currentLevel))\n', '            revert();\n', '        if (layingEggDeductions[obj.classId] >= currentLevel)\n', '            revert();\n', '        afterLevel = currentLevel - layingEggDeductions[obj.classId];\n', '\n', '        // add egg \n', '        uint64 eggId = transformData.addEgg(obj.monsterId, obj.classId, msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        \n', '        // deduct exp \n', '        if (afterLevel < currentLevel)\n', '            data.decreaseMonsterExp(_objId, obj.exp - levelExps[afterLevel-1]);\n', '        EventLayEgg(msg.sender, _objId, eggId);\n', '    }\n', '    \n', '    function hatchEgg() isActive requireDataContract requireTransformDataContract external {\n', '        // use as a seed for random\n', '        lastHatchingAddress = msg.sender;\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender)\n', '            revert();\n', '        // need more time\n', '        if (egg.newObjId > 0 || egg.hatchTime > block.timestamp) {\n', '            revert();\n', '        }\n', '        \n', '        uint64 objId = addNewObj(msg.sender, egg.classId);\n', '        transformData.setHatchedEgg(egg.eggId, objId);\n', '        \n', '        Transfer(address(0), msg.sender, objId);\n', '    }\n', '    \n', '    function removeHatchingTime() isActive requireDataContract requireTransformDataContract external payable  {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        if (msg.value != removeHatchingTimeFee) {\n', '            revert();\n', '        }\n', '        transformData.setHatchTime(egg.eggId, 0);\n', '    }\n', '\n', '    \n', '    function checkAncestors(uint32 _classId, address _trainer, uint64 _a1, uint64 _a2, uint64 _a3) constant public returns(bool) {\n', '        EtheremonWorld world = EtheremonWorld(worldContract);\n', '        uint index = 0;\n', '        uint32 temp = 0;\n', '        // check ancestor\n', '        uint32[3] memory ancestors;\n', '        uint32[3] memory requestAncestors;\n', '        index = world.getClassPropertySize(_classId, PropertyType.ANCESTOR);\n', '        while (index > 0) {\n', '            index -= 1;\n', '            ancestors[index] = world.getClassPropertyValue(_classId, PropertyType.ANCESTOR, index);\n', '        }\n', '            \n', '        if (_a1 > 0) {\n', '            temp = getClassCheckOwner(_a1, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[0] = temp;\n', '        }\n', '        if (_a2 > 0) {\n', '            temp = getClassCheckOwner(_a2, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[1] = temp;\n', '        }\n', '        if (_a3 > 0) {\n', '            temp = getClassCheckOwner(_a3, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[2] = temp;\n', '        }\n', '            \n', '        if (requestAncestors[0] > 0 && (requestAncestors[0] == requestAncestors[1] || requestAncestors[0] == requestAncestors[2]))\n', '            return false;\n', '        if (requestAncestors[1] > 0 && (requestAncestors[1] == requestAncestors[2]))\n', '            return false;\n', '                \n', '        for (index = 0; index < ancestors.length; index++) {\n', '            temp = ancestors[index];\n', '            if (temp > 0 && temp != requestAncestors[0]  && temp != requestAncestors[1] && temp != requestAncestors[2])\n', '                return false;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transform(uint64 _objId, uint64 _a1, uint64 _a2, uint64 _a3) isActive requireDataContract requireTransformDataContract external payable {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        if (transformData.getTranformedId(_objId) > 0)\n', '            revert();\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (battle.isOnBattle(_objId) || trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        BasicObjInfo memory objInfo;\n', '        (objInfo.classId, objInfo.owner, objInfo.level) = getObjClassId(_objId);\n', '        uint32 transformClass = transformClasses[objInfo.classId];\n', '        if (objInfo.classId == 0 || objInfo.owner != msg.sender)\n', '            revert();\n', '        if (transformLevels[objInfo.classId] == 0 || objInfo.level < transformLevels[objInfo.classId])\n', '            revert();\n', '        if (transformClass == 0)\n', '            revert();\n', '        \n', '        \n', '        // gen0 - can not transform if it has bonus egg \n', '        if (objInfo.classId <= GEN0_NO) {\n', '            // legends\n', '            if (getBonusEgg(_objId) > 0)\n', '                revert();\n', '        } else {\n', '            if (!checkAncestors(objInfo.classId, msg.sender, _a1, _a2, _a3))\n', '                revert();\n', '        }\n', '        \n', '        uint64 newObjId = addNewObj(msg.sender, transformClass);\n', '        // remove old one\n', '        data.removeMonsterIdMapping(msg.sender, _objId);\n', '        transformData.setTranformed(_objId, newObjId);\n', '        \n', '        Transfer(msg.sender, address(0), _objId);\n', '        Transfer(address(0), msg.sender, newObjId);\n', '    }\n', '    \n', '    function buyEgg() isActive requireDataContract requireTransformDataContract external payable {\n', '        if (msg.value != buyEggFee) {\n', '            revert();\n', '        }\n', '        \n', '        if (randomClassIds.length == 0) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\n', '        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // read\n', '    function getBonusEgg(uint64 _objId) constant public returns(uint) {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        uint totalBonusEgg = calculateMaxEggG0(_objId);\n', '        if (totalBonusEgg > 0) {\n', '            return (totalBonusEgg - transformData.countEgg(_objId));\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '}']
