['pragma solidity ^0.4.25;\n', '\n', 'contract Formula1Game {\n', '\n', '    address public support;\n', '\n', '\tuint constant public PRIZE_PERCENT = 5;\n', '    uint constant public SUPPORT_PERCENT = 2;\n', '    \n', '    uint constant public MAX_INVESTMENT =  0.1 ether;\n', '    uint constant public MIN_INVESTMENT = 0.01 ether;\n', '    uint constant public MIN_INVESTMENT_FOR_PRIZE = 0.01 ether;\n', '    uint constant public GAS_PRICE_MAX = 14; \n', '    uint constant public MAX_IDLE_TIME = 10 minutes; \n', '\n', '    uint constant public SIZE_TO_SAVE_INVEST = 10; \n', '    uint constant public TIME_TO_SAVE_INVEST = 5 minutes; \n', '    \n', '    uint8[] MULTIPLIERS = [\n', '        125, \n', '        135, \n', '        145 \n', '    ];\n', '\n', '    struct Deposit {\n', '        address depositor; \n', '        uint128 deposit;  \n', '        uint128 expect;    \n', '    }\n', '\n', '    struct DepositCount {\n', '        int128 stage;\n', '        uint128 count;\n', '    }\n', '\n', '    struct LastDepositInfo {\n', '        uint128 index;\n', '        uint128 time;\n', '    }\n', '\n', '    Deposit[] private queue;  \n', '\n', '    uint public currentReceiverIndex = 0; \n', '    uint public currentQueueSize = 0; \n', '    LastDepositInfo public lastDepositInfoForPrize; \n', '    LastDepositInfo public previosDepositInfoForPrize; \n', '\n', '    uint public prizeAmount = 0; \n', '    uint public prizeStageAmount = 0; \n', '    int public stage = 0; \n', '    uint128 public lastDepositTime = 0; \n', '    \n', '    mapping(address => DepositCount) public depositsMade; \n', '\n', '    constructor() public {\n', '        support = msg.sender; \n', '        proceedToNewStage(getCurrentStageByTime() + 1);\n', '    }\n', '    \n', '    function () public payable {\n', '        require(tx.gasprice <= GAS_PRICE_MAX * 1000000000);\n', '        require(gasleft() >= 250000, "We require more gas!"); \n', '        \n', '        checkAndUpdateStage();\n', '        \n', '        if(msg.value > 0){\n', '            require(msg.value >= MIN_INVESTMENT && msg.value <= MAX_INVESTMENT); \n', '            require(lastDepositInfoForPrize.time <= now + MAX_IDLE_TIME); \n', '            \n', '            require(getNextStageStartTime() >= now + MAX_IDLE_TIME + 10 minutes);\n', '            \n', '            if(currentQueueSize < SIZE_TO_SAVE_INVEST){ \n', '                \n', '                addDeposit(msg.sender, msg.value);\n', '                \n', '            } else {\n', '                \n', '                addDeposit(msg.sender, msg.value);\n', '                pay(); \n', '                \n', '            }\n', '            \n', '        } else if(msg.value == 0 && currentQueueSize > SIZE_TO_SAVE_INVEST){\n', '            \n', '            withdrawPrize(); \n', '            \n', '        } else if(msg.value == 0){\n', '            \n', '            require(currentQueueSize <= SIZE_TO_SAVE_INVEST); \n', '            require(lastDepositTime > 0 && (now - lastDepositTime) >= TIME_TO_SAVE_INVEST); \n', '            \n', '            returnPays(); \n', '            \n', '        } \n', '    }\n', '\n', '    function pay() private {\n', '        \n', '        uint balance = address(this).balance;\n', '        uint128 money = 0;\n', '        \n', '        if(balance > prizeStageAmount) \n', '            money = uint128(balance - prizeStageAmount);\n', '        \n', '        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);\n', '        support.send(moneyS);\n', '        money -= moneyS;\n', '        \n', '        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\n', '\n', '            Deposit storage dep = queue[i]; \n', '\n', '            if(money >= dep.expect){  \n', '                    \n', '                dep.depositor.send(dep.expect); \n', '                money -= dep.expect;          \n', '                \n', '                delete queue[i];\n', '                \n', '            }else{\n', '                \n', '                dep.depositor.send(money);      \n', '                money -= dep.expect;            \n', '                break;                     \n', '            }\n', '\n', '            if(gasleft() <= 50000)         \n', '                break;                     \n', '        }\n', '\n', '        currentReceiverIndex = i; \n', '    }\n', '    \n', '    function returnPays() private {\n', '        \n', '        uint balance = address(this).balance;\n', '        uint128 money = 0;\n', '        \n', '        if(balance > prizeAmount) \n', '            money = uint128(balance - prizeAmount);\n', '        \n', '        \n', '        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\n', '\n', '            Deposit storage dep = queue[i]; \n', '\n', '                dep.depositor.send(dep.deposit); \n', '                money -= dep.deposit;            \n', '                \n', '                \n', '                delete queue[i];\n', '\n', '        }\n', '\n', '        prizeStageAmount = 0; \n', '        proceedToNewStage(getCurrentStageByTime() + 1);\n', '    }\n', '\n', '    function addDeposit(address depositor, uint value) private {\n', '        \n', '        DepositCount storage c = depositsMade[depositor];\n', '        if(c.stage != stage){\n', '            c.stage = int128(stage);\n', '            c.count = 0;\n', '        }\n', '\n', '        \n', '        if(value >= MIN_INVESTMENT_FOR_PRIZE){\n', '            previosDepositInfoForPrize = lastDepositInfoForPrize;\n', '            lastDepositInfoForPrize = LastDepositInfo(uint128(currentQueueSize), uint128(now));\n', '        }\n', '\n', '        \n', '        uint multiplier = getDepositorMultiplier(depositor);\n', '        \n', '        push(depositor, value, value*multiplier/100);\n', '\n', '        \n', '        c.count++;\n', '\n', '        lastDepositTime = uint128(now);\n', '        \n', '        \n', '        prizeStageAmount += value*PRIZE_PERCENT/100;\n', '    }\n', '\n', '    function checkAndUpdateStage() private {\n', '        int _stage = getCurrentStageByTime();\n', '\n', '        require(_stage >= stage); \n', '\n', '        if(_stage != stage){\n', '            proceedToNewStage(_stage);\n', '        }\n', '    }\n', '\n', '    function proceedToNewStage(int _stage) private {\n', '        \n', '        stage = _stage;\n', '        currentQueueSize = 0; \n', '        currentReceiverIndex = 0;\n', '        lastDepositTime = 0;\n', '        prizeAmount += prizeStageAmount; \n', '        prizeStageAmount = 0;\n', '        delete queue;\n', '        delete previosDepositInfoForPrize;\n', '        delete lastDepositInfoForPrize;\n', '    }\n', '\n', '    function withdrawPrize() private {\n', '        \n', '        require(lastDepositInfoForPrize.time > 0 && lastDepositInfoForPrize.time <= now - MAX_IDLE_TIME, "The last depositor is not confirmed yet");\n', '        \n', '        require(currentReceiverIndex <= lastDepositInfoForPrize.index, "The last depositor should still be in queue");\n', '\n', '        uint balance = address(this).balance;\n', '        \n', '        uint prize = balance;\n', '        if(previosDepositInfoForPrize.index > 0){\n', '            uint prizePrevios = prize*10/100;\n', '            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);\n', '            prize -= prizePrevios;\n', '        }\n', '\n', '        queue[lastDepositInfoForPrize.index].depositor.send(prize);\n', '        \n', '        proceedToNewStage(getCurrentStageByTime() + 1);\n', '    }\n', '\n', '    function push(address depositor, uint deposit, uint expect) private {\n', '        \n', '        Deposit memory dep = Deposit(depositor, uint128(deposit), uint128(expect));\n', '        assert(currentQueueSize <= queue.length); \n', '        if(queue.length == currentQueueSize)\n', '            queue.push(dep);\n', '        else\n', '            queue[currentQueueSize] = dep;\n', '\n', '        currentQueueSize++;\n', '    }\n', '\n', '    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n', '        Deposit storage dep = queue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expect);\n', '    }\n', '\n', '    function getDepositsCount(address depositor) public view returns (uint) {\n', '        uint c = 0;\n', '        for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\n', '            if(queue[i].depositor == depositor)\n', '                c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    function getQueueLength() public view returns (uint) {\n', '        return currentQueueSize - currentReceiverIndex;\n', '    }\n', '\n', '    function getDepositorMultiplier(address depositor) public view returns (uint) {\n', '        DepositCount storage c = depositsMade[depositor];\n', '        uint count = 0;\n', '        if(c.stage == getCurrentStageByTime())\n', '            count = c.count;\n', '        if(count < MULTIPLIERS.length)\n', '            return MULTIPLIERS[count];\n', '\n', '        return MULTIPLIERS[MULTIPLIERS.length - 1];\n', '    }\n', '\n', '    function getCurrentStageByTime() public view returns (int) {\n', '        return int(now - 17847 * 86400 - 9 * 3600) / (24 * 60 * 60);\n', '    }\n', '\n', '    function getNextStageStartTime() public view returns (uint) {\n', '        return 17847 * 86400 + 9 * 3600 + uint((getCurrentStageByTime() + 1) * 24 * 60 * 60); \n', '    }\n', '\n', '    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\n', '        if(currentReceiverIndex <= lastDepositInfoForPrize.index && lastDepositInfoForPrize.index < currentQueueSize){\n', '            Deposit storage d = queue[lastDepositInfoForPrize.index];\n', '            addr = d.depositor;\n', '            timeLeft = int(lastDepositInfoForPrize.time + MAX_IDLE_TIME) - int(now);\n', '        }\n', '    }\n', '}']