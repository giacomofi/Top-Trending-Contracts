['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract MultiOwnable {\n', '\n', '    mapping (address => bool) public isOwner;\n', '    address[] public ownerHistory;\n', '\n', '    event OwnerAddedEvent(address indexed _newOwner);\n', '    event OwnerRemovedEvent(address indexed _oldOwner);\n', '\n', '    constructor() {\n', '        // Add default owner\n', '        address owner = msg.sender;\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function ownerHistoryCount() public view returns (uint) {\n', '        return ownerHistory.length;\n', '    }\n', '\n', '    /** Add extra owner. */\n', '    function addOwner(address owner) onlyOwner public {\n', '        require(owner != address(0));\n', '        require(!isOwner[owner]);\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '        emit OwnerAddedEvent(owner);\n', '    }\n', '\n', '    /** Remove extra owner. */\n', '    function removeOwner(address owner) onlyOwner public {\n', '        require(isOwner[owner]);\n', '        isOwner[owner] = false;\n', '        emit OwnerRemovedEvent(owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Pausable is MultiOwnable {\n', '\n', '    bool public paused;\n', '\n', '    modifier ifNotPaused {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier ifPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    // Called by the owner on emergency, triggers paused state\n', '    function pause() external onlyOwner ifNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    // Called by the owner on end of emergency, returns to normal state\n', '    function resume() external onlyOwner ifPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract CommonToken is StandardToken, MultiOwnable {\n', '\n', '    string public constant name   = &#39;TMSY&#39;;\n', '    string public constant symbol = &#39;TMSY&#39;;\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public saleLimit;   // 85% of tokens for sale.\n', '    uint256 public teamTokens;  // 7% of tokens goes to the team and will be locked for 1 year.\n', '    uint256 public partnersTokens;\n', '    uint256 public advisorsTokens;\n', '    uint256 public reservaTokens;\n', '\n', '    // 7% of team tokens will be locked at this address for 1 year.\n', '    address public teamWallet; // Team address.\n', '    address public partnersWallet; // bountry address.\n', '    address public advisorsWallet; // Team address.\n', '    address public reservaWallet;\n', '\n', '    uint public unlockTeamTokensTime = now + 365 days;\n', '\n', '    // The main account that holds all tokens at the beginning and during tokensale.\n', '    address public seller; // Seller address (main holder of tokens)\n', '\n', '    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\n', '    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\n', '\n', '    // Lock the transfer functions during tokensales to prevent price speculations.\n', '    bool public locked = true;\n', '    mapping (address => bool) public walletsNotLocked;\n', '\n', '    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\n', '    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\n', '    event Burn(address indexed _burner, uint256 _value);\n', '    event Unlock();\n', '\n', '    constructor (\n', '        address _seller,\n', '        address _teamWallet,\n', '        address _partnersWallet,\n', '        address _advisorsWallet,\n', '        address _reservaWallet\n', '    ) MultiOwnable() public {\n', '\n', '        totalSupply    = 600000000 ether;\n', '        saleLimit      = 390000000 ether;\n', '        teamTokens     = 120000000 ether;\n', '        partnersTokens =  30000000 ether;\n', '        reservaTokens  =  30000000 ether;\n', '        advisorsTokens =  30000000 ether;\n', '\n', '        seller         = _seller;\n', '        teamWallet     = _teamWallet;\n', '        partnersWallet = _partnersWallet;\n', '        advisorsWallet = _advisorsWallet;\n', '        reservaWallet  = _reservaWallet;\n', '\n', '        uint sellerTokens = totalSupply - teamTokens - partnersTokens - advisorsTokens - reservaTokens;\n', '        balances[seller] = sellerTokens;\n', '        emit Transfer(0x0, seller, sellerTokens);\n', '\n', '        balances[teamWallet] = teamTokens;\n', '        emit Transfer(0x0, teamWallet, teamTokens);\n', '\n', '        balances[partnersWallet] = partnersTokens;\n', '        emit Transfer(0x0, partnersWallet, partnersTokens);\n', '\n', '        balances[reservaWallet] = reservaTokens;\n', '        emit Transfer(0x0, reservaWallet, reservaTokens);\n', '\n', '        balances[advisorsWallet] = advisorsTokens;\n', '        emit Transfer(0x0, advisorsWallet, advisorsTokens);\n', '    }\n', '\n', '    modifier ifUnlocked(address _from, address _to) {\n', '        //TODO: lockup excepto para direcciones concretas... pago de servicio, conversion fase 2\n', '        //TODO: Hacer funcion que a&#241;ada direcciones de excepcion\n', '        //TODO: Para el team hacer las exceptions\n', '        require(walletsNotLocked[_to]);\n', '\n', '        require(!locked);\n', '\n', '        // If requested a transfer from the team wallet:\n', '        // TODO: fecha cada 6 meses 25% de desbloqueo\n', '        /*if (_from == teamWallet) {\n', '            require(now >= unlockTeamTokensTime);\n', '        }*/\n', '        // Advisors: 25% cada 3 meses\n', '\n', '        // Reserva: 25% cada 6 meses\n', '\n', '        // Partners: El bloqueo de todos... no pueden hacer nada\n', '\n', '        _;\n', '    }\n', '\n', '    /** Can be called once by super owner. */\n', '    function unlock() onlyOwner public {\n', '        require(locked);\n', '        locked = false;\n', '        emit Unlock();\n', '    }\n', '\n', '    function walletLocked(address _wallet) onlyOwner public {\n', '      walletsNotLocked[_wallet] = false;\n', '    }\n', '\n', '    function walletNotLocked(address _wallet) onlyOwner public {\n', '      walletsNotLocked[_wallet] = true;\n', '    }\n', '\n', '    /**\n', '     * An address can become a new seller only in case it has no tokens.\n', '     * This is required to prevent stealing of tokens  from newSeller via\n', '     * 2 calls of this function.\n', '     */\n', '    function changeSeller(address newSeller) onlyOwner public returns (bool) {\n', '        require(newSeller != address(0));\n', '        require(seller != newSeller);\n', '\n', '        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\n', '        require(balances[newSeller] == 0);\n', '\n', '        address oldSeller = seller;\n', '        uint256 unsoldTokens = balances[oldSeller];\n', '        balances[oldSeller] = 0;\n', '        balances[newSeller] = unsoldTokens;\n', '        emit Transfer(oldSeller, newSeller, unsoldTokens);\n', '\n', '        seller = newSeller;\n', '        emit ChangeSellerEvent(oldSeller, newSeller);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * User-friendly alternative to sell() function.\n', '     */\n', '    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\n', '        return sell(_to, _value * 1e18);\n', '    }\n', '\n', '    function sell(address _to, uint256 _value)  public returns (bool) {\n', '        // Check that we are not out of limit and still can sell tokens:\n', '        // Cambiar a hardcap en usd\n', '        //require(tokensSold.add(_value) <= saleLimit);\n', '        require(msg.sender == seller, "User not authorized");\n', '\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        require(_value <= balances[seller]);\n', '\n', '        balances[seller] = balances[seller].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(seller, _to, _value);\n', '\n', '        totalSales++;\n', '        tokensSold = tokensSold.add(_value);\n', '        emit SellEvent(seller, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Until all tokens are sold, tokens can be transfered to/from owner&#39;s accounts.\n', '     */\n', '    function transfer(address _to, uint256 _value) ifUnlocked(msg.sender, _to) public returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * Until all tokens are sold, tokens can be transfered to/from owner&#39;s accounts.\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked(_from, _to) public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool) {\n', '        require(_value > 0, &#39;Value is zero&#39;);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Transfer(msg.sender, 0x0, _value);\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract CommonTokensale is MultiOwnable, Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public beneficiary;\n', '    uint public refundDeadlineTime;\n', '\n', '    // Balances of beneficiaries:\n', '    uint public balance;\n', '    uint public balanceComision;\n', '    uint public balanceComisionHold;\n', '    uint public balanceComisionDone;\n', '\n', '    // Token contract reference.\n', '    CommonToken public token;\n', '\n', '    uint public minPaymentUSD = 250;\n', '\n', '    uint public minCapWei;\n', '    uint public maxCapWei;\n', '\n', '    uint public minCapUSD;\n', '    uint public maxCapUSD;\n', '\n', '    uint public startTime;\n', '    uint public endTime;\n', '\n', '    // Stats for current tokensale:\n', '\n', '    uint public totalTokensSold;  // Total amount of tokens sold during this tokensale.\n', '    uint public totalWeiReceived; // Total amount of wei received during this tokensale.\n', '    uint public totalUSDReceived; // Total amount of wei received during this tokensale.\n', '\n', '    // This mapping stores info on how many ETH (wei) have been sent to this tokensale from specific address.\n', '    mapping (address => uint256) public buyerToSentWei;\n', '    mapping (address => uint256) public sponsorToComisionDone;\n', '    mapping (address => uint256) public sponsorToComision;\n', '    mapping (address => uint256) public sponsorToComisionHold;\n', '    mapping (address => uint256) public sponsorToComisionFromInversor;\n', '    mapping (address => bool) public kicInversor;\n', '    mapping (address => bool) public validateKYC;\n', '    mapping (address => bool) public comisionInTokens;\n', '\n', '    address[] public sponsorToComisionList;\n', '\n', '    // TODO: realizar opcion de que el inversor quiera cobrar en ETH o TMSY\n', '\n', '    event ReceiveEthEvent(address indexed _buyer, uint256 _amountWei);\n', '    event NewInverstEvent(address indexed _child, address indexed _sponsor);\n', '    event ComisionEvent(address indexed _sponsor, address indexed _child, uint256 _value, uint256 _comision);\n', '    event ComisionPayEvent(address indexed _sponsor, uint256 _value, uint256 _comision);\n', '    event ComisionInversorInTokensEvent(address indexed _sponsor, bool status);\n', '    event ChangeEndTimeEvent(address _sender, uint _date);\n', '    event verifyKycEvent(address _sender, uint _date, bool _status);\n', '    event payComisionSponsorTMSY(address _sponsor, uint _date, uint _value);\n', '    event payComisionSponsorETH(address _sponsor, uint _date, uint _value);\n', '    event withdrawEvent(address _sender, address _to, uint value, uint _date);\n', '    // ratio USD-ETH\n', '    uint public rateUSDETH;\n', '\n', '    bool public isSoftCapComplete = false;\n', '\n', '    // Array para almacenar los inversores\n', '    mapping(address => bool) public inversors;\n', '    address[] public inversorsList;\n', '\n', '    // Array para almacenar los sponsors para hacer reparto de comisiones\n', '    mapping(address => address) public inversorToSponsor;\n', '\n', '    constructor (\n', '        address _token,\n', '        address _beneficiary,\n', '        uint _startTime,\n', '        uint _endTime\n', '    ) MultiOwnable() public {\n', '\n', '        require(_token != address(0));\n', '        token = CommonToken(_token);\n', '\n', '        beneficiary = _beneficiary;\n', '\n', '        startTime = _startTime;\n', '        endTime   = _endTime;\n', '\n', '\n', '        minCapUSD = 400000;\n', '        maxCapUSD = 4000000;\n', '    }\n', '\n', '    function setRatio(uint _rate) onlyOwner public returns (bool) {\n', '      rateUSDETH = _rate;\n', '      return true;\n', '    }\n', '\n', '    //TODO: validateKYC\n', '    //En el momento que validan el KYC se les entregan los tokens\n', '\n', '    function burn(uint _value) onlyOwner public returns (bool) {\n', '      return token.burn(_value);\n', '    }\n', '\n', '    function newInversor(address _newInversor, address _sponsor) onlyOwner public returns (bool) {\n', '      inversors[_newInversor] = true;\n', '      inversorsList.push(_newInversor);\n', '      inversorToSponsor[_newInversor] = _sponsor;\n', '      emit NewInverstEvent(_newInversor,_sponsor);\n', '      return inversors[_newInversor];\n', '    }\n', '    function setComisionInvesorInTokens(address _inversor, bool _inTokens) onlyOwner public returns (bool) {\n', '      comisionInTokens[_inversor] = _inTokens;\n', '      emit ComisionInversorInTokensEvent(_inversor, _inTokens);\n', '      return true;\n', '    }\n', '    function setComisionInTokens() public returns (bool) {\n', '      comisionInTokens[msg.sender] = true;\n', '      emit ComisionInversorInTokensEvent(msg.sender, true);\n', '      return true;\n', '    }\n', '    function setComisionInETH() public returns (bool) {\n', '      comisionInTokens[msg.sender] = false;\n', '      emit ComisionInversorInTokensEvent(msg.sender, false);\n', '\n', '      return true;\n', '    }\n', '    function inversorIsKyc(address who) public returns (bool) {\n', '      return validateKYC[who];\n', '    }\n', '    function unVerifyKyc(address _inversor) onlyOwner public returns (bool) {\n', '      require(!isSoftCapComplete);\n', '\n', '      validateKYC[_inversor] = false;\n', '\n', '      address sponsor = inversorToSponsor[_inversor];\n', '      uint balanceHold = sponsorToComisionFromInversor[_inversor];\n', '\n', '      //Actualizamos contadores globales\n', '      balanceComision = balanceComision.sub(balanceHold);\n', '      balanceComisionHold = balanceComisionHold.add(balanceHold);\n', '\n', '      //Actualizamos contadores del sponsor\n', '      sponsorToComision[sponsor] = sponsorToComision[sponsor].sub(balanceHold);\n', '      sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].add(balanceHold);\n', '\n', '      //Actualizamos contador comision por inversor\n', '    //  sponsorToComisionFromInversor[_inversor] = sponsorToComisionFromInversor[_inversor].sub(balanceHold);\n', '      emit verifyKycEvent(_inversor, now, false);\n', '    }\n', '    function verifyKyc(address _inversor) onlyOwner public returns (bool) {\n', '      validateKYC[_inversor] = true;\n', '\n', '      address sponsor = inversorToSponsor[_inversor];\n', '      uint balanceHold = sponsorToComisionFromInversor[_inversor];\n', '\n', '      //Actualizamos contadores globales\n', '      balanceComision = balanceComision.add(balanceHold);\n', '      balanceComisionHold = balanceComisionHold.sub(balanceHold);\n', '\n', '      //Actualizamos contadores del sponsor\n', '      sponsorToComision[sponsor] = sponsorToComision[sponsor].add(balanceHold);\n', '      sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].sub(balanceHold);\n', '\n', '      //Actualizamos contador comision por inversor\n', '      //sponsorToComisionFromInversor[_inversor] = sponsorToComisionFromInversor[_inversor].sub(balanceHold);\n', '      emit verifyKycEvent(_inversor, now, true);\n', '      //Enviamos comisiones en caso de tener\n', '      /*uint256 value = sponsorToComision[_inversor];\n', '      sponsorToComision[_inversor] = sponsorToComision[_inversor].sub(value);\n', '      _inversor.transfer(value);*/\n', '      return true;\n', '    }\n', '    function buyerToSentWeiOf(address who) public view returns (uint256) {\n', '      return buyerToSentWei[who];\n', '    }\n', '    function balanceOf(address who) public view returns (uint256) {\n', '      return token.balanceOf(who);\n', '    }\n', '    function balanceOfComision(address who)  public view returns (uint256) {\n', '      return sponsorToComision[who];\n', '    }\n', '    function balanceOfComisionHold(address who)  public view returns (uint256) {\n', '      return sponsorToComisionHold[who];\n', '    }\n', '    function balanceOfComisionDone(address who)  public view returns (uint256) {\n', '      return sponsorToComisionDone[who];\n', '    }\n', '\n', '    function isInversor(address who) public view returns (bool) {\n', '      return inversors[who];\n', '    }\n', '    function payComisionSponsor(address _inversor) private {\n', '      //comprobamos que el inversor quiera cobrar en tokens...\n', '      //si es as&#237; le pagamos directo y a&#241;adimos los tokens a su cuenta\n', '      if(comisionInTokens[_inversor]) {\n', '        uint256 val = 0;\n', '        uint256 valueHold = sponsorToComisionHold[_inversor];\n', '        uint256 valueReady = sponsorToComision[_inversor];\n', '\n', '        val = valueReady.add(valueHold);\n', '        //comprobamos que tenga comisiones a cobrar\n', '        if(val > 0) {\n', '          require(balanceComision >= valueReady);\n', '          require(balanceComisionHold >= valueHold);\n', '         uint256 comisionTokens = weiToTokens(val);\n', '\n', '          sponsorToComision[_inversor] = 0;\n', '          sponsorToComisionHold[_inversor] = 0;\n', '\n', '          balanceComision = balanceComision.sub(valueReady);\n', '          balanceComisionDone = balanceComisionDone.add(val);\n', '          balanceComisionHold = balanceComisionHold.sub(valueHold);\n', '\n', '          balance = balance.add(val);\n', '\n', '          token.sell(_inversor, comisionTokens);\n', '          emit payComisionSponsorTMSY(_inversor, now, val); //TYPO TMSY\n', '        }\n', '      } else {\n', '        uint256 value = sponsorToComision[_inversor];\n', '\n', '        //comprobamos que tenga comisiones a cobrar\n', '        if(value > 0) {\n', '          require(balanceComision >= value);\n', '\n', '          //Si lo quiere en ETH\n', '          //comprobamos que hayamos alcanzado el softCap\n', '          assert(isSoftCapComplete);\n', '\n', '          //Comprobamos que el KYC est&#233; validado\n', '          assert(validateKYC[_inversor]);\n', '\n', '          sponsorToComision[_inversor] = sponsorToComision[_inversor].sub(value);\n', '          balanceComision = balanceComision.sub(value);\n', '          balanceComisionDone = balanceComisionDone.add(value);\n', '\n', '          _inversor.transfer(value);\n', '          emit payComisionSponsorETH(_inversor, now, value); //TYPO TMSY\n', '\n', '        }\n', '\n', '      }\n', '    }\n', '    function payComision() public {\n', '      address _inversor = msg.sender;\n', '      payComisionSponsor(_inversor);\n', '    }\n', '    //Enviamos las comisiones que se han congelado o por no tener kyc o por ser en softcap\n', '    /*function sendHoldComisions() onlyOwner public returns (bool) {\n', '      //repartimos todas las comisiones congeladas hasta ahora\n', '      uint arrayLength = sponsorToComisionList.length;\n', '      for (uint i=0; i<arrayLength; i++) {\n', '        // do something\n', '        address sponsor = sponsorToComisionList[i];\n', '\n', '        if(validateKYC[sponsor]) {\n', '          uint256 value = sponsorToComision[sponsor];\n', '          sponsorToComision[sponsor] = sponsorToComision[sponsor].sub(value);\n', '          sponsor.transfer(value);\n', '        }\n', '      }\n', '      return true;\n', '    }*/\n', '    function isSoftCapCompleted() public view returns (bool) {\n', '      return isSoftCapComplete;\n', '    }\n', '    function softCapCompleted() public {\n', '      uint totalBalanceUSD = weiToUSD(balance.div(1e18));\n', '      if(totalBalanceUSD >= minCapUSD) isSoftCapComplete = true;\n', '    }\n', '\n', '    function balanceComisionOf(address who) public view returns (uint256) {\n', '      return sponsorToComision[who];\n', '    }\n', '\n', '    /** The fallback function corresponds to a donation in ETH. */\n', '    function() public payable {\n', '        //sellTokensForEth(msg.sender, msg.value);\n', '\n', '        uint256 _amountWei = msg.value;\n', '        address _buyer = msg.sender;\n', '        uint valueUSD = weiToUSD(_amountWei);\n', '\n', '        //require(startTime <= now && now <= endTime);\n', '        require(inversors[_buyer] != false);\n', '        require(valueUSD >= minPaymentUSD);\n', '        //require(totalUSDReceived.add(valueUSD) <= maxCapUSD);\n', '\n', '        uint tokensE18SinBono = weiToTokens(msg.value);\n', '        uint tokensE18Bono = weiToTokensBono(msg.value);\n', '        uint tokensE18 = tokensE18SinBono.add(tokensE18Bono);\n', '\n', '        //Ejecutamos la transferencia de tokens y paramos si ha fallado\n', '        require(token.sell(_buyer, tokensE18SinBono), "Falla la venta");\n', '        if(tokensE18Bono > 0)\n', '          assert(token.sell(_buyer, tokensE18Bono));\n', '\n', '        //repartimos al sponsor su parte 10%\n', '        uint256 _amountSponsor = (_amountWei * 10) / 100;\n', '        uint256 _amountBeneficiary = (_amountWei * 90) / 100;\n', '\n', '        totalTokensSold = totalTokensSold.add(tokensE18);\n', '        totalWeiReceived = totalWeiReceived.add(_amountWei);\n', '        buyerToSentWei[_buyer] = buyerToSentWei[_buyer].add(_amountWei);\n', '        emit ReceiveEthEvent(_buyer, _amountWei);\n', '\n', '        //por cada compra miramos cual es la cantidad actual de USD... si hemos llegado al softcap lo activamos\n', '        if(!isSoftCapComplete) {\n', '          uint256 totalBalanceUSD = weiToUSD(balance);\n', '          if(totalBalanceUSD >= minCapUSD) {\n', '            softCapCompleted();\n', '          }\n', '        }\n', '        address sponsor = inversorToSponsor[_buyer];\n', '        sponsorToComisionList.push(sponsor);\n', '\n', '        if(validateKYC[_buyer]) {\n', '          //A&#241;adimos el saldo al sponsor\n', '          balanceComision = balanceComision.add(_amountSponsor);\n', '          sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '\n', '        } else {\n', '          //A&#241;adimos el saldo al sponsor\n', '          balanceComisionHold = balanceComisionHold.add(_amountSponsor);\n', '          sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].add(_amountSponsor);\n', '          sponsorToComisionFromInversor[_buyer] = sponsorToComisionFromInversor[_buyer].add(_amountSponsor);\n', '        }\n', '\n', '\n', '        payComisionSponsor(sponsor);\n', '\n', '        // si hemos alcanzado el softcap repartimos comisiones\n', '      /*  if(isSoftCapComplete) {\n', '          // si el sponsor ha realizado inversi&#243;n se le da la comision en caso contratio se le asigna al beneficiario\n', '          if(balanceOf(sponsor) > 0)\n', '            if(validateKYC[sponsor])\n', '              sponsor.transfer(_amountSponsor);\n', '            else {\n', '              sponsorToComisionList.push(sponsor);\n', '              sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '            }\n', '          else\n', '            _amountBeneficiary = _amountSponsor + _amountBeneficiary;\n', '        } else { //en caso contrario no repartimos y lo almacenamos para enviarlo una vez alcanzado el softcap\n', '          if(balanceOf(sponsor) > 0) {\n', '            sponsorToComisionList.push(sponsor);\n', '            sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '          }\n', '          else\n', '            _amountBeneficiary = _amountSponsor + _amountBeneficiary;\n', '        }*/\n', '\n', '        balance = balance.add(_amountBeneficiary);\n', '    }\n', '\n', '    function weiToUSD(uint _amountWei) public view returns (uint256) {\n', '      uint256 ethers = _amountWei;\n', '\n', '      uint256 valueUSD = rateUSDETH.mul(ethers);\n', '\n', '      return valueUSD;\n', '    }\n', '\n', '    function weiToTokensBono(uint _amountWei) public view returns (uint256) {\n', '      uint bono = 0;\n', '\n', '      uint256 valueUSD = weiToUSD(_amountWei);\n', '\n', '      // Calculamos bono\n', '      //Tablas de bonos\n', '      if(valueUSD >= uint(500 * 1e18))   bono = 10;\n', '      if(valueUSD >= uint(1000 * 1e18))  bono = 20;\n', '      if(valueUSD >= uint(2500 * 1e18))  bono = 30;\n', '      if(valueUSD >= uint(5000 * 1e18))  bono = 40;\n', '      if(valueUSD >= uint(10000 * 1e18)) bono = 50;\n', '\n', '\n', '      uint256 bonoUsd = valueUSD.mul(bono).div(100);\n', '      uint256 tokens = bonoUsd.mul(tokensPerUSD());\n', '\n', '      return tokens;\n', '    }\n', '    /** Calc how much tokens you can buy at current time. */\n', '    function weiToTokens(uint _amountWei) public view returns (uint256) {\n', '\n', '        uint256 valueUSD = weiToUSD(_amountWei);\n', '\n', '        uint256 tokens = valueUSD.mul(tokensPerUSD());\n', '\n', '        return tokens;\n', '    }\n', '\n', '    function tokensPerUSD() public pure returns (uint256) {\n', '        return 65; // Default token price with no bonuses.\n', '    }\n', '\n', '    function canWithdraw() public view returns (bool);\n', '\n', '    function withdraw(address _to, uint value) public returns (uint) {\n', '        require(canWithdraw(), &#39;No es posible retirar&#39;);\n', '        require(msg.sender == beneficiary, &#39;S&#243;lo puede solicitar el beneficiario los fondos&#39;);\n', '        require(balance > 0, &#39;Sin fondos&#39;);\n', '        require(balance >= value, &#39;No hay suficientes fondos&#39;);\n', '        require(_to.call.value(value).gas(1)(), &#39;No se que es&#39;);\n', '\n', '        balance = balance.sub(value);\n', '        emit withdrawEvent(msg.sender, _to, value,now);\n', '      return balance;\n', '    }\n', '\n', '    //Manage timelimit. For exception\n', '    function changeEndTime(uint _date) onlyOwner public returns (bool) {\n', '      //TODO; quitar comentarios para el lanzamiento\n', '      require(endTime < _date);\n', '      endTime = _date;\n', '      refundDeadlineTime = endTime + 3 * 30 days;\n', '      emit ChangeEndTimeEvent(msg.sender,_date);\n', '      return true;\n', '    }\n', '}\n', '\n', '\n', 'contract Presale is CommonTokensale {\n', '\n', '    // In case min (soft) cap is not reached, token buyers will be able to\n', '    // refund their contributions during 3 months after presale is finished.\n', '\n', '    // Total amount of wei refunded if min (soft) cap is not reached.\n', '    uint public totalWeiRefunded;\n', '\n', '    event RefundEthEvent(address indexed _buyer, uint256 _amountWei);\n', '\n', '    constructor(\n', '        address _token,\n', '        address _beneficiary,\n', '        uint _startTime,\n', '        uint _endTime\n', '    ) CommonTokensale(\n', '        _token,\n', '        _beneficiary,\n', '        _startTime,\n', '        _endTime\n', '    ) public {\n', '      refundDeadlineTime = _endTime + 3 * 30 days;\n', '    }\n', '\n', '    /**\n', '     * During presale it will be possible to withdraw only in two cases:\n', '     * min cap reached OR refund period expired.\n', '     */\n', '    function canWithdraw() public view returns (bool) {\n', '        return isSoftCapComplete;\n', '    }\n', '\n', '    /**\n', '     * It will be possible to refund only if min (soft) cap is not reached and\n', '     * refund requested during 3 months after presale finished.\n', '     */\n', '    function canRefund() public view returns (bool) {\n', '        return !isSoftCapComplete && endTime < now && now <= refundDeadlineTime;\n', '    }\n', '\n', '    function refund() public {\n', '        require(canRefund());\n', '\n', '        address buyer = msg.sender;\n', '        uint amount = buyerToSentWei[buyer];\n', '        require(amount > 0);\n', '\n', '        // Redistribute left balance between three beneficiaries.\n', '        uint newBal = balance.sub(amount);\n', '        balance = newBal;\n', '\n', '        emit RefundEthEvent(buyer, amount);\n', '        buyerToSentWei[buyer] = 0;\n', '        totalWeiRefunded = totalWeiRefunded.add(amount);\n', '        buyer.transfer(amount);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract MultiOwnable {\n', '\n', '    mapping (address => bool) public isOwner;\n', '    address[] public ownerHistory;\n', '\n', '    event OwnerAddedEvent(address indexed _newOwner);\n', '    event OwnerRemovedEvent(address indexed _oldOwner);\n', '\n', '    constructor() {\n', '        // Add default owner\n', '        address owner = msg.sender;\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function ownerHistoryCount() public view returns (uint) {\n', '        return ownerHistory.length;\n', '    }\n', '\n', '    /** Add extra owner. */\n', '    function addOwner(address owner) onlyOwner public {\n', '        require(owner != address(0));\n', '        require(!isOwner[owner]);\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '        emit OwnerAddedEvent(owner);\n', '    }\n', '\n', '    /** Remove extra owner. */\n', '    function removeOwner(address owner) onlyOwner public {\n', '        require(isOwner[owner]);\n', '        isOwner[owner] = false;\n', '        emit OwnerRemovedEvent(owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Pausable is MultiOwnable {\n', '\n', '    bool public paused;\n', '\n', '    modifier ifNotPaused {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier ifPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    // Called by the owner on emergency, triggers paused state\n', '    function pause() external onlyOwner ifNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    // Called by the owner on end of emergency, returns to normal state\n', '    function resume() external onlyOwner ifPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract CommonToken is StandardToken, MultiOwnable {\n', '\n', "    string public constant name   = 'TMSY';\n", "    string public constant symbol = 'TMSY';\n", '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public saleLimit;   // 85% of tokens for sale.\n', '    uint256 public teamTokens;  // 7% of tokens goes to the team and will be locked for 1 year.\n', '    uint256 public partnersTokens;\n', '    uint256 public advisorsTokens;\n', '    uint256 public reservaTokens;\n', '\n', '    // 7% of team tokens will be locked at this address for 1 year.\n', '    address public teamWallet; // Team address.\n', '    address public partnersWallet; // bountry address.\n', '    address public advisorsWallet; // Team address.\n', '    address public reservaWallet;\n', '\n', '    uint public unlockTeamTokensTime = now + 365 days;\n', '\n', '    // The main account that holds all tokens at the beginning and during tokensale.\n', '    address public seller; // Seller address (main holder of tokens)\n', '\n', '    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\n', '    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\n', '\n', '    // Lock the transfer functions during tokensales to prevent price speculations.\n', '    bool public locked = true;\n', '    mapping (address => bool) public walletsNotLocked;\n', '\n', '    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\n', '    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\n', '    event Burn(address indexed _burner, uint256 _value);\n', '    event Unlock();\n', '\n', '    constructor (\n', '        address _seller,\n', '        address _teamWallet,\n', '        address _partnersWallet,\n', '        address _advisorsWallet,\n', '        address _reservaWallet\n', '    ) MultiOwnable() public {\n', '\n', '        totalSupply    = 600000000 ether;\n', '        saleLimit      = 390000000 ether;\n', '        teamTokens     = 120000000 ether;\n', '        partnersTokens =  30000000 ether;\n', '        reservaTokens  =  30000000 ether;\n', '        advisorsTokens =  30000000 ether;\n', '\n', '        seller         = _seller;\n', '        teamWallet     = _teamWallet;\n', '        partnersWallet = _partnersWallet;\n', '        advisorsWallet = _advisorsWallet;\n', '        reservaWallet  = _reservaWallet;\n', '\n', '        uint sellerTokens = totalSupply - teamTokens - partnersTokens - advisorsTokens - reservaTokens;\n', '        balances[seller] = sellerTokens;\n', '        emit Transfer(0x0, seller, sellerTokens);\n', '\n', '        balances[teamWallet] = teamTokens;\n', '        emit Transfer(0x0, teamWallet, teamTokens);\n', '\n', '        balances[partnersWallet] = partnersTokens;\n', '        emit Transfer(0x0, partnersWallet, partnersTokens);\n', '\n', '        balances[reservaWallet] = reservaTokens;\n', '        emit Transfer(0x0, reservaWallet, reservaTokens);\n', '\n', '        balances[advisorsWallet] = advisorsTokens;\n', '        emit Transfer(0x0, advisorsWallet, advisorsTokens);\n', '    }\n', '\n', '    modifier ifUnlocked(address _from, address _to) {\n', '        //TODO: lockup excepto para direcciones concretas... pago de servicio, conversion fase 2\n', '        //TODO: Hacer funcion que añada direcciones de excepcion\n', '        //TODO: Para el team hacer las exceptions\n', '        require(walletsNotLocked[_to]);\n', '\n', '        require(!locked);\n', '\n', '        // If requested a transfer from the team wallet:\n', '        // TODO: fecha cada 6 meses 25% de desbloqueo\n', '        /*if (_from == teamWallet) {\n', '            require(now >= unlockTeamTokensTime);\n', '        }*/\n', '        // Advisors: 25% cada 3 meses\n', '\n', '        // Reserva: 25% cada 6 meses\n', '\n', '        // Partners: El bloqueo de todos... no pueden hacer nada\n', '\n', '        _;\n', '    }\n', '\n', '    /** Can be called once by super owner. */\n', '    function unlock() onlyOwner public {\n', '        require(locked);\n', '        locked = false;\n', '        emit Unlock();\n', '    }\n', '\n', '    function walletLocked(address _wallet) onlyOwner public {\n', '      walletsNotLocked[_wallet] = false;\n', '    }\n', '\n', '    function walletNotLocked(address _wallet) onlyOwner public {\n', '      walletsNotLocked[_wallet] = true;\n', '    }\n', '\n', '    /**\n', '     * An address can become a new seller only in case it has no tokens.\n', '     * This is required to prevent stealing of tokens  from newSeller via\n', '     * 2 calls of this function.\n', '     */\n', '    function changeSeller(address newSeller) onlyOwner public returns (bool) {\n', '        require(newSeller != address(0));\n', '        require(seller != newSeller);\n', '\n', '        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\n', '        require(balances[newSeller] == 0);\n', '\n', '        address oldSeller = seller;\n', '        uint256 unsoldTokens = balances[oldSeller];\n', '        balances[oldSeller] = 0;\n', '        balances[newSeller] = unsoldTokens;\n', '        emit Transfer(oldSeller, newSeller, unsoldTokens);\n', '\n', '        seller = newSeller;\n', '        emit ChangeSellerEvent(oldSeller, newSeller);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * User-friendly alternative to sell() function.\n', '     */\n', '    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\n', '        return sell(_to, _value * 1e18);\n', '    }\n', '\n', '    function sell(address _to, uint256 _value)  public returns (bool) {\n', '        // Check that we are not out of limit and still can sell tokens:\n', '        // Cambiar a hardcap en usd\n', '        //require(tokensSold.add(_value) <= saleLimit);\n', '        require(msg.sender == seller, "User not authorized");\n', '\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        require(_value <= balances[seller]);\n', '\n', '        balances[seller] = balances[seller].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(seller, _to, _value);\n', '\n', '        totalSales++;\n', '        tokensSold = tokensSold.add(_value);\n', '        emit SellEvent(seller, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\n", '     */\n', '    function transfer(address _to, uint256 _value) ifUnlocked(msg.sender, _to) public returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', "     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\n", '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked(_from, _to) public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool) {\n', "        require(_value > 0, 'Value is zero');\n", '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Transfer(msg.sender, 0x0, _value);\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract CommonTokensale is MultiOwnable, Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public beneficiary;\n', '    uint public refundDeadlineTime;\n', '\n', '    // Balances of beneficiaries:\n', '    uint public balance;\n', '    uint public balanceComision;\n', '    uint public balanceComisionHold;\n', '    uint public balanceComisionDone;\n', '\n', '    // Token contract reference.\n', '    CommonToken public token;\n', '\n', '    uint public minPaymentUSD = 250;\n', '\n', '    uint public minCapWei;\n', '    uint public maxCapWei;\n', '\n', '    uint public minCapUSD;\n', '    uint public maxCapUSD;\n', '\n', '    uint public startTime;\n', '    uint public endTime;\n', '\n', '    // Stats for current tokensale:\n', '\n', '    uint public totalTokensSold;  // Total amount of tokens sold during this tokensale.\n', '    uint public totalWeiReceived; // Total amount of wei received during this tokensale.\n', '    uint public totalUSDReceived; // Total amount of wei received during this tokensale.\n', '\n', '    // This mapping stores info on how many ETH (wei) have been sent to this tokensale from specific address.\n', '    mapping (address => uint256) public buyerToSentWei;\n', '    mapping (address => uint256) public sponsorToComisionDone;\n', '    mapping (address => uint256) public sponsorToComision;\n', '    mapping (address => uint256) public sponsorToComisionHold;\n', '    mapping (address => uint256) public sponsorToComisionFromInversor;\n', '    mapping (address => bool) public kicInversor;\n', '    mapping (address => bool) public validateKYC;\n', '    mapping (address => bool) public comisionInTokens;\n', '\n', '    address[] public sponsorToComisionList;\n', '\n', '    // TODO: realizar opcion de que el inversor quiera cobrar en ETH o TMSY\n', '\n', '    event ReceiveEthEvent(address indexed _buyer, uint256 _amountWei);\n', '    event NewInverstEvent(address indexed _child, address indexed _sponsor);\n', '    event ComisionEvent(address indexed _sponsor, address indexed _child, uint256 _value, uint256 _comision);\n', '    event ComisionPayEvent(address indexed _sponsor, uint256 _value, uint256 _comision);\n', '    event ComisionInversorInTokensEvent(address indexed _sponsor, bool status);\n', '    event ChangeEndTimeEvent(address _sender, uint _date);\n', '    event verifyKycEvent(address _sender, uint _date, bool _status);\n', '    event payComisionSponsorTMSY(address _sponsor, uint _date, uint _value);\n', '    event payComisionSponsorETH(address _sponsor, uint _date, uint _value);\n', '    event withdrawEvent(address _sender, address _to, uint value, uint _date);\n', '    // ratio USD-ETH\n', '    uint public rateUSDETH;\n', '\n', '    bool public isSoftCapComplete = false;\n', '\n', '    // Array para almacenar los inversores\n', '    mapping(address => bool) public inversors;\n', '    address[] public inversorsList;\n', '\n', '    // Array para almacenar los sponsors para hacer reparto de comisiones\n', '    mapping(address => address) public inversorToSponsor;\n', '\n', '    constructor (\n', '        address _token,\n', '        address _beneficiary,\n', '        uint _startTime,\n', '        uint _endTime\n', '    ) MultiOwnable() public {\n', '\n', '        require(_token != address(0));\n', '        token = CommonToken(_token);\n', '\n', '        beneficiary = _beneficiary;\n', '\n', '        startTime = _startTime;\n', '        endTime   = _endTime;\n', '\n', '\n', '        minCapUSD = 400000;\n', '        maxCapUSD = 4000000;\n', '    }\n', '\n', '    function setRatio(uint _rate) onlyOwner public returns (bool) {\n', '      rateUSDETH = _rate;\n', '      return true;\n', '    }\n', '\n', '    //TODO: validateKYC\n', '    //En el momento que validan el KYC se les entregan los tokens\n', '\n', '    function burn(uint _value) onlyOwner public returns (bool) {\n', '      return token.burn(_value);\n', '    }\n', '\n', '    function newInversor(address _newInversor, address _sponsor) onlyOwner public returns (bool) {\n', '      inversors[_newInversor] = true;\n', '      inversorsList.push(_newInversor);\n', '      inversorToSponsor[_newInversor] = _sponsor;\n', '      emit NewInverstEvent(_newInversor,_sponsor);\n', '      return inversors[_newInversor];\n', '    }\n', '    function setComisionInvesorInTokens(address _inversor, bool _inTokens) onlyOwner public returns (bool) {\n', '      comisionInTokens[_inversor] = _inTokens;\n', '      emit ComisionInversorInTokensEvent(_inversor, _inTokens);\n', '      return true;\n', '    }\n', '    function setComisionInTokens() public returns (bool) {\n', '      comisionInTokens[msg.sender] = true;\n', '      emit ComisionInversorInTokensEvent(msg.sender, true);\n', '      return true;\n', '    }\n', '    function setComisionInETH() public returns (bool) {\n', '      comisionInTokens[msg.sender] = false;\n', '      emit ComisionInversorInTokensEvent(msg.sender, false);\n', '\n', '      return true;\n', '    }\n', '    function inversorIsKyc(address who) public returns (bool) {\n', '      return validateKYC[who];\n', '    }\n', '    function unVerifyKyc(address _inversor) onlyOwner public returns (bool) {\n', '      require(!isSoftCapComplete);\n', '\n', '      validateKYC[_inversor] = false;\n', '\n', '      address sponsor = inversorToSponsor[_inversor];\n', '      uint balanceHold = sponsorToComisionFromInversor[_inversor];\n', '\n', '      //Actualizamos contadores globales\n', '      balanceComision = balanceComision.sub(balanceHold);\n', '      balanceComisionHold = balanceComisionHold.add(balanceHold);\n', '\n', '      //Actualizamos contadores del sponsor\n', '      sponsorToComision[sponsor] = sponsorToComision[sponsor].sub(balanceHold);\n', '      sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].add(balanceHold);\n', '\n', '      //Actualizamos contador comision por inversor\n', '    //  sponsorToComisionFromInversor[_inversor] = sponsorToComisionFromInversor[_inversor].sub(balanceHold);\n', '      emit verifyKycEvent(_inversor, now, false);\n', '    }\n', '    function verifyKyc(address _inversor) onlyOwner public returns (bool) {\n', '      validateKYC[_inversor] = true;\n', '\n', '      address sponsor = inversorToSponsor[_inversor];\n', '      uint balanceHold = sponsorToComisionFromInversor[_inversor];\n', '\n', '      //Actualizamos contadores globales\n', '      balanceComision = balanceComision.add(balanceHold);\n', '      balanceComisionHold = balanceComisionHold.sub(balanceHold);\n', '\n', '      //Actualizamos contadores del sponsor\n', '      sponsorToComision[sponsor] = sponsorToComision[sponsor].add(balanceHold);\n', '      sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].sub(balanceHold);\n', '\n', '      //Actualizamos contador comision por inversor\n', '      //sponsorToComisionFromInversor[_inversor] = sponsorToComisionFromInversor[_inversor].sub(balanceHold);\n', '      emit verifyKycEvent(_inversor, now, true);\n', '      //Enviamos comisiones en caso de tener\n', '      /*uint256 value = sponsorToComision[_inversor];\n', '      sponsorToComision[_inversor] = sponsorToComision[_inversor].sub(value);\n', '      _inversor.transfer(value);*/\n', '      return true;\n', '    }\n', '    function buyerToSentWeiOf(address who) public view returns (uint256) {\n', '      return buyerToSentWei[who];\n', '    }\n', '    function balanceOf(address who) public view returns (uint256) {\n', '      return token.balanceOf(who);\n', '    }\n', '    function balanceOfComision(address who)  public view returns (uint256) {\n', '      return sponsorToComision[who];\n', '    }\n', '    function balanceOfComisionHold(address who)  public view returns (uint256) {\n', '      return sponsorToComisionHold[who];\n', '    }\n', '    function balanceOfComisionDone(address who)  public view returns (uint256) {\n', '      return sponsorToComisionDone[who];\n', '    }\n', '\n', '    function isInversor(address who) public view returns (bool) {\n', '      return inversors[who];\n', '    }\n', '    function payComisionSponsor(address _inversor) private {\n', '      //comprobamos que el inversor quiera cobrar en tokens...\n', '      //si es así le pagamos directo y añadimos los tokens a su cuenta\n', '      if(comisionInTokens[_inversor]) {\n', '        uint256 val = 0;\n', '        uint256 valueHold = sponsorToComisionHold[_inversor];\n', '        uint256 valueReady = sponsorToComision[_inversor];\n', '\n', '        val = valueReady.add(valueHold);\n', '        //comprobamos que tenga comisiones a cobrar\n', '        if(val > 0) {\n', '          require(balanceComision >= valueReady);\n', '          require(balanceComisionHold >= valueHold);\n', '         uint256 comisionTokens = weiToTokens(val);\n', '\n', '          sponsorToComision[_inversor] = 0;\n', '          sponsorToComisionHold[_inversor] = 0;\n', '\n', '          balanceComision = balanceComision.sub(valueReady);\n', '          balanceComisionDone = balanceComisionDone.add(val);\n', '          balanceComisionHold = balanceComisionHold.sub(valueHold);\n', '\n', '          balance = balance.add(val);\n', '\n', '          token.sell(_inversor, comisionTokens);\n', '          emit payComisionSponsorTMSY(_inversor, now, val); //TYPO TMSY\n', '        }\n', '      } else {\n', '        uint256 value = sponsorToComision[_inversor];\n', '\n', '        //comprobamos que tenga comisiones a cobrar\n', '        if(value > 0) {\n', '          require(balanceComision >= value);\n', '\n', '          //Si lo quiere en ETH\n', '          //comprobamos que hayamos alcanzado el softCap\n', '          assert(isSoftCapComplete);\n', '\n', '          //Comprobamos que el KYC esté validado\n', '          assert(validateKYC[_inversor]);\n', '\n', '          sponsorToComision[_inversor] = sponsorToComision[_inversor].sub(value);\n', '          balanceComision = balanceComision.sub(value);\n', '          balanceComisionDone = balanceComisionDone.add(value);\n', '\n', '          _inversor.transfer(value);\n', '          emit payComisionSponsorETH(_inversor, now, value); //TYPO TMSY\n', '\n', '        }\n', '\n', '      }\n', '    }\n', '    function payComision() public {\n', '      address _inversor = msg.sender;\n', '      payComisionSponsor(_inversor);\n', '    }\n', '    //Enviamos las comisiones que se han congelado o por no tener kyc o por ser en softcap\n', '    /*function sendHoldComisions() onlyOwner public returns (bool) {\n', '      //repartimos todas las comisiones congeladas hasta ahora\n', '      uint arrayLength = sponsorToComisionList.length;\n', '      for (uint i=0; i<arrayLength; i++) {\n', '        // do something\n', '        address sponsor = sponsorToComisionList[i];\n', '\n', '        if(validateKYC[sponsor]) {\n', '          uint256 value = sponsorToComision[sponsor];\n', '          sponsorToComision[sponsor] = sponsorToComision[sponsor].sub(value);\n', '          sponsor.transfer(value);\n', '        }\n', '      }\n', '      return true;\n', '    }*/\n', '    function isSoftCapCompleted() public view returns (bool) {\n', '      return isSoftCapComplete;\n', '    }\n', '    function softCapCompleted() public {\n', '      uint totalBalanceUSD = weiToUSD(balance.div(1e18));\n', '      if(totalBalanceUSD >= minCapUSD) isSoftCapComplete = true;\n', '    }\n', '\n', '    function balanceComisionOf(address who) public view returns (uint256) {\n', '      return sponsorToComision[who];\n', '    }\n', '\n', '    /** The fallback function corresponds to a donation in ETH. */\n', '    function() public payable {\n', '        //sellTokensForEth(msg.sender, msg.value);\n', '\n', '        uint256 _amountWei = msg.value;\n', '        address _buyer = msg.sender;\n', '        uint valueUSD = weiToUSD(_amountWei);\n', '\n', '        //require(startTime <= now && now <= endTime);\n', '        require(inversors[_buyer] != false);\n', '        require(valueUSD >= minPaymentUSD);\n', '        //require(totalUSDReceived.add(valueUSD) <= maxCapUSD);\n', '\n', '        uint tokensE18SinBono = weiToTokens(msg.value);\n', '        uint tokensE18Bono = weiToTokensBono(msg.value);\n', '        uint tokensE18 = tokensE18SinBono.add(tokensE18Bono);\n', '\n', '        //Ejecutamos la transferencia de tokens y paramos si ha fallado\n', '        require(token.sell(_buyer, tokensE18SinBono), "Falla la venta");\n', '        if(tokensE18Bono > 0)\n', '          assert(token.sell(_buyer, tokensE18Bono));\n', '\n', '        //repartimos al sponsor su parte 10%\n', '        uint256 _amountSponsor = (_amountWei * 10) / 100;\n', '        uint256 _amountBeneficiary = (_amountWei * 90) / 100;\n', '\n', '        totalTokensSold = totalTokensSold.add(tokensE18);\n', '        totalWeiReceived = totalWeiReceived.add(_amountWei);\n', '        buyerToSentWei[_buyer] = buyerToSentWei[_buyer].add(_amountWei);\n', '        emit ReceiveEthEvent(_buyer, _amountWei);\n', '\n', '        //por cada compra miramos cual es la cantidad actual de USD... si hemos llegado al softcap lo activamos\n', '        if(!isSoftCapComplete) {\n', '          uint256 totalBalanceUSD = weiToUSD(balance);\n', '          if(totalBalanceUSD >= minCapUSD) {\n', '            softCapCompleted();\n', '          }\n', '        }\n', '        address sponsor = inversorToSponsor[_buyer];\n', '        sponsorToComisionList.push(sponsor);\n', '\n', '        if(validateKYC[_buyer]) {\n', '          //Añadimos el saldo al sponsor\n', '          balanceComision = balanceComision.add(_amountSponsor);\n', '          sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '\n', '        } else {\n', '          //Añadimos el saldo al sponsor\n', '          balanceComisionHold = balanceComisionHold.add(_amountSponsor);\n', '          sponsorToComisionHold[sponsor] = sponsorToComisionHold[sponsor].add(_amountSponsor);\n', '          sponsorToComisionFromInversor[_buyer] = sponsorToComisionFromInversor[_buyer].add(_amountSponsor);\n', '        }\n', '\n', '\n', '        payComisionSponsor(sponsor);\n', '\n', '        // si hemos alcanzado el softcap repartimos comisiones\n', '      /*  if(isSoftCapComplete) {\n', '          // si el sponsor ha realizado inversión se le da la comision en caso contratio se le asigna al beneficiario\n', '          if(balanceOf(sponsor) > 0)\n', '            if(validateKYC[sponsor])\n', '              sponsor.transfer(_amountSponsor);\n', '            else {\n', '              sponsorToComisionList.push(sponsor);\n', '              sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '            }\n', '          else\n', '            _amountBeneficiary = _amountSponsor + _amountBeneficiary;\n', '        } else { //en caso contrario no repartimos y lo almacenamos para enviarlo una vez alcanzado el softcap\n', '          if(balanceOf(sponsor) > 0) {\n', '            sponsorToComisionList.push(sponsor);\n', '            sponsorToComision[sponsor] = sponsorToComision[sponsor].add(_amountSponsor);\n', '          }\n', '          else\n', '            _amountBeneficiary = _amountSponsor + _amountBeneficiary;\n', '        }*/\n', '\n', '        balance = balance.add(_amountBeneficiary);\n', '    }\n', '\n', '    function weiToUSD(uint _amountWei) public view returns (uint256) {\n', '      uint256 ethers = _amountWei;\n', '\n', '      uint256 valueUSD = rateUSDETH.mul(ethers);\n', '\n', '      return valueUSD;\n', '    }\n', '\n', '    function weiToTokensBono(uint _amountWei) public view returns (uint256) {\n', '      uint bono = 0;\n', '\n', '      uint256 valueUSD = weiToUSD(_amountWei);\n', '\n', '      // Calculamos bono\n', '      //Tablas de bonos\n', '      if(valueUSD >= uint(500 * 1e18))   bono = 10;\n', '      if(valueUSD >= uint(1000 * 1e18))  bono = 20;\n', '      if(valueUSD >= uint(2500 * 1e18))  bono = 30;\n', '      if(valueUSD >= uint(5000 * 1e18))  bono = 40;\n', '      if(valueUSD >= uint(10000 * 1e18)) bono = 50;\n', '\n', '\n', '      uint256 bonoUsd = valueUSD.mul(bono).div(100);\n', '      uint256 tokens = bonoUsd.mul(tokensPerUSD());\n', '\n', '      return tokens;\n', '    }\n', '    /** Calc how much tokens you can buy at current time. */\n', '    function weiToTokens(uint _amountWei) public view returns (uint256) {\n', '\n', '        uint256 valueUSD = weiToUSD(_amountWei);\n', '\n', '        uint256 tokens = valueUSD.mul(tokensPerUSD());\n', '\n', '        return tokens;\n', '    }\n', '\n', '    function tokensPerUSD() public pure returns (uint256) {\n', '        return 65; // Default token price with no bonuses.\n', '    }\n', '\n', '    function canWithdraw() public view returns (bool);\n', '\n', '    function withdraw(address _to, uint value) public returns (uint) {\n', "        require(canWithdraw(), 'No es posible retirar');\n", "        require(msg.sender == beneficiary, 'Sólo puede solicitar el beneficiario los fondos');\n", "        require(balance > 0, 'Sin fondos');\n", "        require(balance >= value, 'No hay suficientes fondos');\n", "        require(_to.call.value(value).gas(1)(), 'No se que es');\n", '\n', '        balance = balance.sub(value);\n', '        emit withdrawEvent(msg.sender, _to, value,now);\n', '      return balance;\n', '    }\n', '\n', '    //Manage timelimit. For exception\n', '    function changeEndTime(uint _date) onlyOwner public returns (bool) {\n', '      //TODO; quitar comentarios para el lanzamiento\n', '      require(endTime < _date);\n', '      endTime = _date;\n', '      refundDeadlineTime = endTime + 3 * 30 days;\n', '      emit ChangeEndTimeEvent(msg.sender,_date);\n', '      return true;\n', '    }\n', '}\n', '\n', '\n', 'contract Presale is CommonTokensale {\n', '\n', '    // In case min (soft) cap is not reached, token buyers will be able to\n', '    // refund their contributions during 3 months after presale is finished.\n', '\n', '    // Total amount of wei refunded if min (soft) cap is not reached.\n', '    uint public totalWeiRefunded;\n', '\n', '    event RefundEthEvent(address indexed _buyer, uint256 _amountWei);\n', '\n', '    constructor(\n', '        address _token,\n', '        address _beneficiary,\n', '        uint _startTime,\n', '        uint _endTime\n', '    ) CommonTokensale(\n', '        _token,\n', '        _beneficiary,\n', '        _startTime,\n', '        _endTime\n', '    ) public {\n', '      refundDeadlineTime = _endTime + 3 * 30 days;\n', '    }\n', '\n', '    /**\n', '     * During presale it will be possible to withdraw only in two cases:\n', '     * min cap reached OR refund period expired.\n', '     */\n', '    function canWithdraw() public view returns (bool) {\n', '        return isSoftCapComplete;\n', '    }\n', '\n', '    /**\n', '     * It will be possible to refund only if min (soft) cap is not reached and\n', '     * refund requested during 3 months after presale finished.\n', '     */\n', '    function canRefund() public view returns (bool) {\n', '        return !isSoftCapComplete && endTime < now && now <= refundDeadlineTime;\n', '    }\n', '\n', '    function refund() public {\n', '        require(canRefund());\n', '\n', '        address buyer = msg.sender;\n', '        uint amount = buyerToSentWei[buyer];\n', '        require(amount > 0);\n', '\n', '        // Redistribute left balance between three beneficiaries.\n', '        uint newBal = balance.sub(amount);\n', '        balance = newBal;\n', '\n', '        emit RefundEthEvent(buyer, amount);\n', '        buyerToSentWei[buyer] = 0;\n', '        totalWeiRefunded = totalWeiRefunded.add(amount);\n', '        buyer.transfer(amount);\n', '    }\n', '}']
