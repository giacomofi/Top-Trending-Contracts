['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * RECOMMENDED GAS LIMIT: 250000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' * The contract has been tested for vulnerabilities!\n', ' *\n', ' */ \n', '\n', 'contract ZzzInvest{\n', '\n', '    mapping (address => uint256) public invested;\n', '\n', '    mapping (address => uint256) public payments; \n', '     \n', '    mapping (address => address) public investedRef;\n', '    \n', '    mapping (address => uint256) public atBlock;\n', '\t\n', '\tmapping (address => uint256) public regBlock;\n', '\t\n', '\tmapping (address => uint256) public remaining;\n', '\t\n', '\tmapping (address => uint256) public remday;\n', '    \n', '    mapping (address => uint256) public cashBack;\n', '    \n', '    mapping (address => uint256) public cashRef;\n', '    \n', '    mapping (address => uint256) public admComiss;\n', '    \n', '    using SafeMath for uint;\n', '    using ToAddress for *;\n', '    using Zero for *;\n', '    \n', '    address private adm_addr; //NB!\n', '    uint256 private start_block;\n', '    uint256 private constant dividends = 2000;           \t// 20.00%\n', '    uint256 private constant adm_comission = 15;        \t// 15%\n', '    uint256 private constant ref_bonus = 10;            \t// 10%\n', '    uint256 private constant ref_cashback = 3;          \t// 3%\n', '    uint256 private constant block_of_24h = 5900;       \t// ~24 hour\n', '\tuint256 private constant block_of_contract = 23600;   // ~24 hour * 365 * 2 4307000\n', '    uint256 private constant min_invesment = 10 finney; // 0.01 eth\n', '    \n', '    //Statistics\n', '    uint256 private all_invest_users_count = 0;\n', '    uint256 private all_invest = 0;\n', '    uint256 private all_payments = 0;\n', '    uint256 private all_cash_back_payments = 0;\n', '    uint256 private all_ref_payments = 0;\n', '    uint256 private all_adm_payments = 0;\n', '    uint256 private all_reinvest = 0;\n', '    address private last_invest_addr = 0;\n', '    uint256 private last_invest_amount = 0;\n', '    uint256 private last_invest_block = 0;\n', '    \n', '    constructor() public {\n', '    adm_addr = msg.sender;\n', '    start_block = block.number;\n', '    }\n', '    \n', '    // this function called every time anyone sends a transaction to this contract\n', '    function() public payable {\n', '        \n', '        uint256 amount = 0;\n', '\t\t\n', '\t\t\t\n', '\t\t\t\t// Block Registration\n', '            if (regBlock[msg.sender] == 0){\n', '                regBlock[msg.sender] = block.number; \n', '\t\t\t\tremaining[msg.sender] = block_of_contract;\n', '\t\t\t\tremday[msg.sender] = remaining[msg.sender].div(block_of_24h);\n', '            }\t\n', '            else\n', '                 {\n', '                   remaining[msg.sender] = block_of_contract.sub(block.number).sub(regBlock[msg.sender]);\n', '\t\t\t\t   remday[msg.sender] = remaining[msg.sender].div(block_of_24h);\n', '\t\t\t\t   \n', '                 }\n', '\t\t\t\n', '\t\t\t\n', '\t\t\tif (remaining[msg.sender] == 0){\n', '                invested[msg.sender] = 0; \n', '                regBlock[msg.sender] = block.number; \n', '\t\t\t\tremaining[msg.sender] = block_of_contract;\n', '\t\t\t\tremday[msg.sender] = remaining[msg.sender].div(block_of_24h);\n', '            }\n', '\t\t\t\n', '\t\t\t\n', '        \n', '        // if sender is invested more than 0 ether\n', '        if (invested[msg.sender] != 0 && remaining[msg.sender] != 0){\n', '\t\t\n', '            // calculate profit:\n', '//amount = (amount invested) * 20.00% * (blocks since last transaction) / 5900\n', '//amount = invested[msg.sender] * dividends / 10000 * (block.number - atBlock[msg.sender]) / block_of_24h;\n', 'amount = invested[msg.sender].mul(dividends).div(10000).mul(block.number.sub(atBlock[msg.sender])).div(block_of_24h);\n', '        }\n', '        \n', '        if (msg.value == 0) {\n', '           \n', '            // Commission payment\n', '            if (admComiss[adm_addr] != 0 && msg.sender == adm_addr){\n', '                amount = amount.add(admComiss[adm_addr]);\n', '                admComiss[adm_addr] = 0;\n', '                all_adm_payments += amount;\n', '               }\n', '           \n', '            // Payment of referral fees\n', '            if (cashRef[msg.sender] != 0){\n', '                amount = amount.add(cashRef[msg.sender]);\n', '                cashRef[msg.sender] = 0;\n', '                all_ref_payments += amount;\n', '            }\n', '            \n', '            // Payment of cashback\n', '            if (cashBack[msg.sender] != 0){\n', '                amount = amount.add(cashBack[msg.sender]);\n', '                cashBack[msg.sender] = 0;\n', '                all_cash_back_payments += amount;\n', '               }\n', '           }\n', '        else\n', '           {\n', '            \n', '            // Minimum payment\n', '            require(msg.value >= min_invesment, "msg.value must be >= 0.01 ether (10 finney)");\n', '               \n', '            // Enrollment fees\n', '            admComiss[adm_addr] += msg.value.mul(adm_comission).div(100);\n', '             \n', '            address ref_addr = msg.data.toAddr();\n', '            \n', '              if (ref_addr.notZero()) {\n', '                  \n', '                 //Anti-Cheat mode\n', '                 require(msg.sender != ref_addr, "referal must be != msg.sender");\n', '                  \n', '                 // Referral enrollment\n', '                 cashRef[ref_addr] += msg.value.mul(ref_bonus).div(100);\n', '                 \n', '                 // Securing the referral for the investor\n', '                 investedRef[msg.sender] = ref_addr;\n', '                 \n', '                 // Cashback Enrollment\n', '                 if (invested[msg.sender] == 0)\n', '                     cashBack[msg.sender] += msg.value.mul(ref_cashback).div(100);\n', '                 \n', '                 }\n', '                 else\n', '                 {\n', '                 // Referral enrollment\n', '                   if (investedRef[msg.sender].notZero())\n', '                      cashRef[investedRef[msg.sender]] += msg.value.mul(ref_bonus).div(100);    \n', '                 }\n', '                 \n', '                 \n', '            if (invested[msg.sender] == 0) all_invest_users_count++;   \n', '               \n', '            // investment accounting\n', '            invested[msg.sender] += msg.value;  \n', '            atBlock[msg.sender] = block.number;\n', '\t\t\t\n', '            // statistics\n', '            all_invest += msg.value;\n', '            if (invested[msg.sender] > 0) all_reinvest += msg.value;\n', '            last_invest_addr = msg.sender;\n', '            last_invest_amount = msg.value;\n', '            last_invest_block = block.number;\n', '            \n', '           }\n', '           \n', '         // record block number and invested amount (msg.value) of this transaction\n', '         atBlock[msg.sender] = block.number;    \n', '           \n', '         if (amount != 0)\n', '            {\n', '            // send calculated amount of ether directly to sender (aka YOU)\n', '            address sender = msg.sender;\n', '            \n', '            all_payments += amount;\n', '            payments[sender] += amount;\n', '            \n', '            sender.transfer(amount);\n', '            }\n', '\t\t\n', '\t\t\n', '\t\t\t\n', '\t\t\t\n', '   }\n', '   \n', '    \n', '    //Stat\n', '    //getFundStatsMap\n', '    function getFundStatsMap() public view returns (uint256[7]){\n', '    uint256[7] memory stateMap; \n', '    stateMap[0] = all_invest_users_count;\n', '    stateMap[1] = all_invest;\n', '    stateMap[2] = all_payments;\n', '    stateMap[3] = all_cash_back_payments;\n', '    stateMap[4] = all_ref_payments;\n', '    stateMap[5] = all_adm_payments;\n', '    stateMap[6] = all_reinvest;\n', '    return (stateMap); \n', '    }\n', '    \n', '    //getUserStats\n', '    function getUserStats(address addr) public view returns (uint256,uint256,uint256,uint256,uint256,uint256,address){\n', '    return (invested[addr],cashBack[addr],cashRef[addr],atBlock[addr],block.number,payments[addr],investedRef[addr]); \n', '    }\n', '\t\n', '\t//getRemainingDays\n', '    function getRemainingDays(address addr) public view returns (uint256,uint256,uint256){\n', '    return (remaining[addr],remday[addr],regBlock[addr]); \n', '    }\n', '    \n', '    //getWebStats\n', '    function getWebStats() public view returns (uint256,uint256,uint256,uint256,address,uint256,uint256){\n', '    return (all_invest_users_count,address(this).balance,all_invest,all_payments,last_invest_addr,last_invest_amount,last_invest_block); \n', '    }\n', '  \n', '}   \n', '    \n', '\n', 'library SafeMath {\n', ' \n', '\n', '/**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}']