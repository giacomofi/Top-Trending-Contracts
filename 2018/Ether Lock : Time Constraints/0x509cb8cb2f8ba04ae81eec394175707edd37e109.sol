['pragma solidity ^0.4.21;\n', '\n', 'contract TwoXJackpot {\n', '  using SafeMath for uint256;\n', '  address public contractOwner;  // Address of the contract creator\n', '\n', '  // BuyIn Object, holding information of each Buy In\n', '  // Also used to store information about winners in each game\n', '  struct BuyIn {\n', '    uint256 value;\n', '    address owner;\n', '  }\n', '\n', '  // Game Object, holding information of each Game played\n', '  struct Game {\n', '    BuyIn[] buyIns;            // FIFO queue\n', '    address[] winners;         // Jackpot Winners addresses\n', '    uint256[] winnerPayouts;   // Jackpot Winner Payouts\n', '    uint256 gameTotalInvested; // Total Invested in game\n', '    uint256 gameTotalPaidOut;  // Total Paid Out in game\n', '    uint256 gameTotalBacklog;  // Total Amount waiting to payout\n', '    uint256 index;             // The current BuyIn queue index\n', '\n', '    mapping (address => uint256) totalInvested; // Total invested for a given address\n', '    mapping (address => uint256) totalValue;    // Total value for a given address\n', '    mapping (address => uint256) totalPaidOut;  // Total paid out for a given address\n', '  }\n', '\n', '  mapping (uint256 => Game) public games;  // Map game index to the game\n', '  uint256 public gameIndex;    // The current Game Index\n', '\n', '  // Timestamp of the last action.\n', '\n', '  // Jackpot\n', '  uint256 public jackpotBalance;        // Total balance of Jackpot (before re-seed deduction)\n', '  address public jackpotLastQualified;  // Last Purchaser, in running for Jackpot claim\n', '  address public jackpotLastWinner;     // Last Winner Address\n', '  uint256 public jackpotLastPayout;     // Last Payout Amount (after re-seed deduction)\n', '  uint256 public jackpotCount;          // Number of jackpots for sliding payout.\n', '\n', '\n', '  // Timestamp of Game Start\n', '  uint256 public gameStartTime;     // Game Start Time\n', '  uint256 public roundStartTime;    // Round Start Time, used to pause the game\n', '  uint256 public lastAction;        // Last Action Timestamp\n', '  uint256 public timeBetweenGames = 24 hours;       // Time between games (4 Jackpots hit = 1 game)\n', '  uint256 public timeBeforeJackpot = 30 minutes;    // Time between last purchase and jackpot payout (increases)\n', '  uint256 public timeBeforeJackpotReset = timeBeforeJackpot; // To reset the jackpot timer\n', '  uint256 public timeIncreasePerTx = 1 minutes;     // How much time to increment the jackpot for each buy\n', '  uint256 public timeBetweenRounds = 5 minutes;  // Time between rounds (each Round has 5 minute timeout)\n', '\n', '\n', '  // Buy In configuration logic\n', '  uint256 public buyFee = 90;       // This ends up being a 10% fee towards Jackpot\n', '  uint256 public minBuy = 50;       // Jackpot / 50 = 2% Min buy\n', '  uint256 public maxBuy = 2;        // Jackpot / 2 = 50% Max buy\n', '  uint256 public minMinBuyETH = 0.02 ether; // Min buy in should be more then 0.02 ETH\n', '  uint256 public minMaxBuyETH = 0.5 ether; // Max buy in should be more then 0.5 ETH\n', '  uint256[] public gameReseeds = [90, 80, 60, 20]; // How much money reseeds to the next round\n', '\n', '\n', '  modifier onlyContractOwner() {\n', '    require(msg.sender == contractOwner);\n', '    _;\n', '  }\n', '\n', '  modifier isStarted() {\n', '      require(now >= gameStartTime); // Check game started\n', '      require(now >= roundStartTime); // Check round started\n', '      _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event Purchase(uint256 amount, address depositer);\n', '  event Seed(uint256 amount, address seeder);\n', '\n', '  function TwoXJackpot() public {\n', '    contractOwner = msg.sender;\n', '    gameStartTime = now + timeBetweenGames;\n', '    lastAction = gameStartTime;\n', '  }\n', '\n', '  //                 //\n', '  // ADMIN FUNCTIONS //\n', '  //                 //\n', '\n', '  // Change the start time for fair launch\n', '  function changeStartTime(uint256 _time) public onlyContractOwner {\n', '    require(now < _time); // only allow changing it to something in the future\n', '    gameStartTime = _time;\n', '    lastAction = gameStartTime; // Don&#39;t forget to update last action too :)\n', '  }\n', '\n', '  // Change the start time for fair launch\n', '  function updateTimeBetweenGames(uint256 _time) public onlyContractOwner {\n', '    timeBetweenGames = _time; // Time after Jackpot claim we allow new buys.\n', '  }\n', '\n', '  //                //\n', '  // User Functions //\n', '  //                //\n', '\n', '  // Anyone can seed the jackpot, since its non-refundable. It will pay 10% forward to next game.\n', '  // Beware, there is no way to get your seed back unless you win the jackpot.\n', '  function seed() public payable {\n', '    jackpotBalance += msg.value; // Increase the value of the jackpot by this much.\n', '    //emit Seed event\n', '    emit Seed(msg.value, msg.sender);\n', '  }\n', '\n', '  function purchase() public payable isStarted  {\n', '    // Check if the game is still running\n', '    if (now > lastAction + timeBeforeJackpot &&\n', '      jackpotLastQualified != 0x0) {\n', '      claim();\n', '      // Next game/round will start, return back money to user\n', '      if (msg.value > 0) {\n', '        msg.sender.transfer(msg.value);\n', '      }\n', '      return;\n', '    }\n', '\n', '    // Check if JackPot is less then 1 ETH, then\n', '    // use predefined minimum and maximum buy in values\n', '    if (jackpotBalance <= 1 ether) {\n', '      require(msg.value >= minMinBuyETH); // >= 0.02 ETH\n', '      require(msg.value <= minMaxBuyETH); // <= 0.5 ETH\n', '    } else {\n', '      uint256 purchaseMin = SafeMath.mul(msg.value, minBuy);\n', '      uint256 purchaseMax = SafeMath.mul(msg.value, maxBuy);\n', '      require(purchaseMin >= jackpotBalance);\n', '      require(purchaseMax <= jackpotBalance);\n', '    }\n', '\n', '    uint256 valueAfterTax = SafeMath.div(SafeMath.mul(msg.value, buyFee), 100);     // Take a 10% fee for Jackpot, example on 1ETH Buy:  0.9 = (1.0 * 90) / 100\n', '    uint256 potFee = SafeMath.sub(msg.value, valueAfterTax);                        // Calculate the absolute number to put into pot.\n', '\n', '\n', '    jackpotBalance += potFee;           // Add it to the jackpot\n', '    jackpotLastQualified = msg.sender;  // You are now the rightly heir to the Jackpot...for now...\n', '    lastAction = now;                   //  Reset jackpot timer\n', '    timeBeforeJackpot += timeIncreasePerTx;                // Increase Jackpot Timer by 1 minute.\n', '    uint256 valueMultiplied = SafeMath.mul(msg.value, 2);  // Double it\n', '\n', '    // Update Global Investing Information\n', '    games[gameIndex].gameTotalInvested += msg.value;\n', '    games[gameIndex].gameTotalBacklog += valueMultiplied;\n', '\n', '    // Update Game Investing Information\n', '    games[gameIndex].totalInvested[msg.sender] += msg.value;\n', '    games[gameIndex].totalValue[msg.sender] += valueMultiplied;\n', '\n', '    // Push new Buy In information in our game list of buy ins\n', '    games[gameIndex].buyIns.push(BuyIn({\n', '      value: valueMultiplied,\n', '      owner: msg.sender\n', '    }));\n', '    //Emit a deposit event.\n', '    emit Purchase(msg.value, msg.sender);\n', '\n', '    while (games[gameIndex].index < games[gameIndex].buyIns.length\n', '            && valueAfterTax > 0) {\n', '\n', '      BuyIn storage buyIn = games[gameIndex].buyIns[games[gameIndex].index];\n', '\n', '      if (valueAfterTax < buyIn.value) {\n', '        buyIn.owner.transfer(valueAfterTax);\n', '\n', '        // Update game information\n', '        games[gameIndex].gameTotalBacklog -= valueAfterTax;\n', '        games[gameIndex].gameTotalPaidOut += valueAfterTax;\n', '\n', '        // game paid out and value update\n', '        games[gameIndex].totalPaidOut[buyIn.owner] += valueAfterTax;\n', '        games[gameIndex].totalValue[buyIn.owner] -= valueAfterTax;\n', '        buyIn.value -= valueAfterTax;\n', '        valueAfterTax = 0;\n', '      } else {\n', '        buyIn.owner.transfer(buyIn.value);\n', '\n', '        // Update game information\n', '        games[gameIndex].gameTotalBacklog -= buyIn.value;\n', '        games[gameIndex].gameTotalPaidOut += buyIn.value;\n', '\n', '        // game paid out and value update\n', '        games[gameIndex].totalPaidOut[buyIn.owner] += buyIn.value;\n', '        games[gameIndex].totalValue[buyIn.owner] -= buyIn.value;\n', '        valueAfterTax -= buyIn.value;\n', '        buyIn.value = 0;\n', '        games[gameIndex].index++;\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  // Claim the Jackpot\n', '  function claim() public payable isStarted {\n', '    require(now > lastAction + timeBeforeJackpot);\n', '    require(jackpotLastQualified != 0x0); // make sure last jackpotLastQualified is not 0x0\n', '\n', '    // Each game has 4 Jackpot payouts, increasing in payout percentage.\n', '    // Funds owed to you do not reset between Jackpots, but will reset after 1 game (4 Jackpots)\n', '    uint256 reseed = SafeMath.div(SafeMath.mul(jackpotBalance, gameReseeds[jackpotCount]), 100);\n', '    uint256 payout = jackpotBalance - reseed;\n', '\n', '\n', '    jackpotLastQualified.transfer(payout); // payout entire jackpot minus seed.\n', '    jackpotBalance = reseed;\n', '    jackpotLastWinner = jackpotLastQualified;\n', '    jackpotLastPayout = payout;\n', '\n', '    // Let&#39;s store now new winner in list of game winners\n', '    games[gameIndex].winners.push(jackpotLastQualified);\n', '    games[gameIndex].winnerPayouts.push(payout);\n', '\n', '    // RESET all the settings\n', '    timeBeforeJackpot = timeBeforeJackpotReset; // reset to 30 min on each round timer\n', '    jackpotLastQualified = 0x0; // set last qualified to 0x0\n', '\n', '    if(jackpotCount == gameReseeds.length - 1){\n', '      // Reset all outstanding owed money after 4 claimed jackpots to officially restart the game.\n', '      gameStartTime = now + timeBetweenGames;    // Restart the game in a specified period (24h)\n', '      lastAction = gameStartTime; // Reset last action to the start of the game\n', '      gameIndex += 1; // Next Game!\n', '      jackpotCount = 0;  // Reset Jackpots back to 0 after game end.\n', '\n', '    } else {\n', '      lastAction = now + timeBetweenRounds;\n', '      roundStartTime = lastAction;\n', '      jackpotCount += 1;\n', '    }\n', '  }\n', '\n', '  // Fallback, sending any ether will call purchase()\n', '  function () public payable {\n', '    purchase();\n', '  }\n', '\n', '  // PUBLIC METHODS TO RETRIEVE DATA IN UI\n', '  // Return Current Jackpot Info\n', '  // [ JackPotBalance, jackpotLastQualified, jackpotLastWinner, jackpotLastPayout,\n', '  //  jackpotCount, gameIndex, gameStartTime, timeTillRoundEnd, roundStartTime]\n', '  function getJackpotInfo() public view returns (uint256, address, address, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '    return (\n', '        jackpotBalance,\n', '        jackpotLastQualified,\n', '        jackpotLastWinner,\n', '        jackpotLastPayout,\n', '        jackpotCount,\n', '        gameIndex,\n', '        gameStartTime,\n', '        lastAction + timeBeforeJackpot,\n', '        roundStartTime\n', '      );\n', '  }\n', '\n', '  // Return player game info based on game index and player address\n', '  // [ totalInvested, totalValue, totalPaidOut]\n', '  function getPlayerGameInfo(uint256 _gameIndex, address _player) public view returns (uint256, uint256, uint256) {\n', '    return (\n', '        games[_gameIndex].totalInvested[_player],\n', '        games[_gameIndex].totalValue[_player],\n', '        games[_gameIndex].totalPaidOut[_player]\n', '      );\n', '  }\n', '\n', '  // Get user game info connected to current game\n', '  function getMyGameInfo() public view returns (uint256, uint256, uint256) {\n', '    return getPlayerGameInfo(gameIndex, msg.sender);\n', '  }\n', '\n', '  // Return all the game constants, setting the game\n', '  function getGameConstants() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256[]) {\n', '    return (\n', '        timeBetweenGames,\n', '        timeBeforeJackpot,\n', '        minMinBuyETH,\n', '        minMaxBuyETH,\n', '        minBuy,\n', '        maxBuy,\n', '        gameReseeds\n', '      );\n', '  }\n', '\n', '  // Return game information based on game index\n', '  function getGameInfo(uint256 _gameIndex) public view returns (uint256, uint256, uint256, address[], uint256[]) {\n', '    return (\n', '        games[_gameIndex].gameTotalInvested,\n', '        games[_gameIndex].gameTotalPaidOut,\n', '        games[_gameIndex].gameTotalBacklog,\n', '        games[_gameIndex].winners,\n', '        games[_gameIndex].winnerPayouts\n', '      );\n', '  }\n', '\n', '  // Return current running game info\n', '  function getCurrentGameInfo() public view returns (uint256, uint256, uint256, address[], uint256[]) {\n', '    return getGameInfo(gameIndex);\n', '  }\n', '\n', '  // Return time when next game will start\n', '  function getGameStartTime() public view returns (uint256) {\n', '    return gameStartTime;\n', '  }\n', '\n', '  // Return end time for the jackpot round\n', '  function getJackpotRoundEndTime() public view returns (uint256) {\n', '    return lastAction + timeBeforeJackpot;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract TwoXJackpot {\n', '  using SafeMath for uint256;\n', '  address public contractOwner;  // Address of the contract creator\n', '\n', '  // BuyIn Object, holding information of each Buy In\n', '  // Also used to store information about winners in each game\n', '  struct BuyIn {\n', '    uint256 value;\n', '    address owner;\n', '  }\n', '\n', '  // Game Object, holding information of each Game played\n', '  struct Game {\n', '    BuyIn[] buyIns;            // FIFO queue\n', '    address[] winners;         // Jackpot Winners addresses\n', '    uint256[] winnerPayouts;   // Jackpot Winner Payouts\n', '    uint256 gameTotalInvested; // Total Invested in game\n', '    uint256 gameTotalPaidOut;  // Total Paid Out in game\n', '    uint256 gameTotalBacklog;  // Total Amount waiting to payout\n', '    uint256 index;             // The current BuyIn queue index\n', '\n', '    mapping (address => uint256) totalInvested; // Total invested for a given address\n', '    mapping (address => uint256) totalValue;    // Total value for a given address\n', '    mapping (address => uint256) totalPaidOut;  // Total paid out for a given address\n', '  }\n', '\n', '  mapping (uint256 => Game) public games;  // Map game index to the game\n', '  uint256 public gameIndex;    // The current Game Index\n', '\n', '  // Timestamp of the last action.\n', '\n', '  // Jackpot\n', '  uint256 public jackpotBalance;        // Total balance of Jackpot (before re-seed deduction)\n', '  address public jackpotLastQualified;  // Last Purchaser, in running for Jackpot claim\n', '  address public jackpotLastWinner;     // Last Winner Address\n', '  uint256 public jackpotLastPayout;     // Last Payout Amount (after re-seed deduction)\n', '  uint256 public jackpotCount;          // Number of jackpots for sliding payout.\n', '\n', '\n', '  // Timestamp of Game Start\n', '  uint256 public gameStartTime;     // Game Start Time\n', '  uint256 public roundStartTime;    // Round Start Time, used to pause the game\n', '  uint256 public lastAction;        // Last Action Timestamp\n', '  uint256 public timeBetweenGames = 24 hours;       // Time between games (4 Jackpots hit = 1 game)\n', '  uint256 public timeBeforeJackpot = 30 minutes;    // Time between last purchase and jackpot payout (increases)\n', '  uint256 public timeBeforeJackpotReset = timeBeforeJackpot; // To reset the jackpot timer\n', '  uint256 public timeIncreasePerTx = 1 minutes;     // How much time to increment the jackpot for each buy\n', '  uint256 public timeBetweenRounds = 5 minutes;  // Time between rounds (each Round has 5 minute timeout)\n', '\n', '\n', '  // Buy In configuration logic\n', '  uint256 public buyFee = 90;       // This ends up being a 10% fee towards Jackpot\n', '  uint256 public minBuy = 50;       // Jackpot / 50 = 2% Min buy\n', '  uint256 public maxBuy = 2;        // Jackpot / 2 = 50% Max buy\n', '  uint256 public minMinBuyETH = 0.02 ether; // Min buy in should be more then 0.02 ETH\n', '  uint256 public minMaxBuyETH = 0.5 ether; // Max buy in should be more then 0.5 ETH\n', '  uint256[] public gameReseeds = [90, 80, 60, 20]; // How much money reseeds to the next round\n', '\n', '\n', '  modifier onlyContractOwner() {\n', '    require(msg.sender == contractOwner);\n', '    _;\n', '  }\n', '\n', '  modifier isStarted() {\n', '      require(now >= gameStartTime); // Check game started\n', '      require(now >= roundStartTime); // Check round started\n', '      _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event Purchase(uint256 amount, address depositer);\n', '  event Seed(uint256 amount, address seeder);\n', '\n', '  function TwoXJackpot() public {\n', '    contractOwner = msg.sender;\n', '    gameStartTime = now + timeBetweenGames;\n', '    lastAction = gameStartTime;\n', '  }\n', '\n', '  //                 //\n', '  // ADMIN FUNCTIONS //\n', '  //                 //\n', '\n', '  // Change the start time for fair launch\n', '  function changeStartTime(uint256 _time) public onlyContractOwner {\n', '    require(now < _time); // only allow changing it to something in the future\n', '    gameStartTime = _time;\n', "    lastAction = gameStartTime; // Don't forget to update last action too :)\n", '  }\n', '\n', '  // Change the start time for fair launch\n', '  function updateTimeBetweenGames(uint256 _time) public onlyContractOwner {\n', '    timeBetweenGames = _time; // Time after Jackpot claim we allow new buys.\n', '  }\n', '\n', '  //                //\n', '  // User Functions //\n', '  //                //\n', '\n', '  // Anyone can seed the jackpot, since its non-refundable. It will pay 10% forward to next game.\n', '  // Beware, there is no way to get your seed back unless you win the jackpot.\n', '  function seed() public payable {\n', '    jackpotBalance += msg.value; // Increase the value of the jackpot by this much.\n', '    //emit Seed event\n', '    emit Seed(msg.value, msg.sender);\n', '  }\n', '\n', '  function purchase() public payable isStarted  {\n', '    // Check if the game is still running\n', '    if (now > lastAction + timeBeforeJackpot &&\n', '      jackpotLastQualified != 0x0) {\n', '      claim();\n', '      // Next game/round will start, return back money to user\n', '      if (msg.value > 0) {\n', '        msg.sender.transfer(msg.value);\n', '      }\n', '      return;\n', '    }\n', '\n', '    // Check if JackPot is less then 1 ETH, then\n', '    // use predefined minimum and maximum buy in values\n', '    if (jackpotBalance <= 1 ether) {\n', '      require(msg.value >= minMinBuyETH); // >= 0.02 ETH\n', '      require(msg.value <= minMaxBuyETH); // <= 0.5 ETH\n', '    } else {\n', '      uint256 purchaseMin = SafeMath.mul(msg.value, minBuy);\n', '      uint256 purchaseMax = SafeMath.mul(msg.value, maxBuy);\n', '      require(purchaseMin >= jackpotBalance);\n', '      require(purchaseMax <= jackpotBalance);\n', '    }\n', '\n', '    uint256 valueAfterTax = SafeMath.div(SafeMath.mul(msg.value, buyFee), 100);     // Take a 10% fee for Jackpot, example on 1ETH Buy:  0.9 = (1.0 * 90) / 100\n', '    uint256 potFee = SafeMath.sub(msg.value, valueAfterTax);                        // Calculate the absolute number to put into pot.\n', '\n', '\n', '    jackpotBalance += potFee;           // Add it to the jackpot\n', '    jackpotLastQualified = msg.sender;  // You are now the rightly heir to the Jackpot...for now...\n', '    lastAction = now;                   //  Reset jackpot timer\n', '    timeBeforeJackpot += timeIncreasePerTx;                // Increase Jackpot Timer by 1 minute.\n', '    uint256 valueMultiplied = SafeMath.mul(msg.value, 2);  // Double it\n', '\n', '    // Update Global Investing Information\n', '    games[gameIndex].gameTotalInvested += msg.value;\n', '    games[gameIndex].gameTotalBacklog += valueMultiplied;\n', '\n', '    // Update Game Investing Information\n', '    games[gameIndex].totalInvested[msg.sender] += msg.value;\n', '    games[gameIndex].totalValue[msg.sender] += valueMultiplied;\n', '\n', '    // Push new Buy In information in our game list of buy ins\n', '    games[gameIndex].buyIns.push(BuyIn({\n', '      value: valueMultiplied,\n', '      owner: msg.sender\n', '    }));\n', '    //Emit a deposit event.\n', '    emit Purchase(msg.value, msg.sender);\n', '\n', '    while (games[gameIndex].index < games[gameIndex].buyIns.length\n', '            && valueAfterTax > 0) {\n', '\n', '      BuyIn storage buyIn = games[gameIndex].buyIns[games[gameIndex].index];\n', '\n', '      if (valueAfterTax < buyIn.value) {\n', '        buyIn.owner.transfer(valueAfterTax);\n', '\n', '        // Update game information\n', '        games[gameIndex].gameTotalBacklog -= valueAfterTax;\n', '        games[gameIndex].gameTotalPaidOut += valueAfterTax;\n', '\n', '        // game paid out and value update\n', '        games[gameIndex].totalPaidOut[buyIn.owner] += valueAfterTax;\n', '        games[gameIndex].totalValue[buyIn.owner] -= valueAfterTax;\n', '        buyIn.value -= valueAfterTax;\n', '        valueAfterTax = 0;\n', '      } else {\n', '        buyIn.owner.transfer(buyIn.value);\n', '\n', '        // Update game information\n', '        games[gameIndex].gameTotalBacklog -= buyIn.value;\n', '        games[gameIndex].gameTotalPaidOut += buyIn.value;\n', '\n', '        // game paid out and value update\n', '        games[gameIndex].totalPaidOut[buyIn.owner] += buyIn.value;\n', '        games[gameIndex].totalValue[buyIn.owner] -= buyIn.value;\n', '        valueAfterTax -= buyIn.value;\n', '        buyIn.value = 0;\n', '        games[gameIndex].index++;\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  // Claim the Jackpot\n', '  function claim() public payable isStarted {\n', '    require(now > lastAction + timeBeforeJackpot);\n', '    require(jackpotLastQualified != 0x0); // make sure last jackpotLastQualified is not 0x0\n', '\n', '    // Each game has 4 Jackpot payouts, increasing in payout percentage.\n', '    // Funds owed to you do not reset between Jackpots, but will reset after 1 game (4 Jackpots)\n', '    uint256 reseed = SafeMath.div(SafeMath.mul(jackpotBalance, gameReseeds[jackpotCount]), 100);\n', '    uint256 payout = jackpotBalance - reseed;\n', '\n', '\n', '    jackpotLastQualified.transfer(payout); // payout entire jackpot minus seed.\n', '    jackpotBalance = reseed;\n', '    jackpotLastWinner = jackpotLastQualified;\n', '    jackpotLastPayout = payout;\n', '\n', "    // Let's store now new winner in list of game winners\n", '    games[gameIndex].winners.push(jackpotLastQualified);\n', '    games[gameIndex].winnerPayouts.push(payout);\n', '\n', '    // RESET all the settings\n', '    timeBeforeJackpot = timeBeforeJackpotReset; // reset to 30 min on each round timer\n', '    jackpotLastQualified = 0x0; // set last qualified to 0x0\n', '\n', '    if(jackpotCount == gameReseeds.length - 1){\n', '      // Reset all outstanding owed money after 4 claimed jackpots to officially restart the game.\n', '      gameStartTime = now + timeBetweenGames;    // Restart the game in a specified period (24h)\n', '      lastAction = gameStartTime; // Reset last action to the start of the game\n', '      gameIndex += 1; // Next Game!\n', '      jackpotCount = 0;  // Reset Jackpots back to 0 after game end.\n', '\n', '    } else {\n', '      lastAction = now + timeBetweenRounds;\n', '      roundStartTime = lastAction;\n', '      jackpotCount += 1;\n', '    }\n', '  }\n', '\n', '  // Fallback, sending any ether will call purchase()\n', '  function () public payable {\n', '    purchase();\n', '  }\n', '\n', '  // PUBLIC METHODS TO RETRIEVE DATA IN UI\n', '  // Return Current Jackpot Info\n', '  // [ JackPotBalance, jackpotLastQualified, jackpotLastWinner, jackpotLastPayout,\n', '  //  jackpotCount, gameIndex, gameStartTime, timeTillRoundEnd, roundStartTime]\n', '  function getJackpotInfo() public view returns (uint256, address, address, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '    return (\n', '        jackpotBalance,\n', '        jackpotLastQualified,\n', '        jackpotLastWinner,\n', '        jackpotLastPayout,\n', '        jackpotCount,\n', '        gameIndex,\n', '        gameStartTime,\n', '        lastAction + timeBeforeJackpot,\n', '        roundStartTime\n', '      );\n', '  }\n', '\n', '  // Return player game info based on game index and player address\n', '  // [ totalInvested, totalValue, totalPaidOut]\n', '  function getPlayerGameInfo(uint256 _gameIndex, address _player) public view returns (uint256, uint256, uint256) {\n', '    return (\n', '        games[_gameIndex].totalInvested[_player],\n', '        games[_gameIndex].totalValue[_player],\n', '        games[_gameIndex].totalPaidOut[_player]\n', '      );\n', '  }\n', '\n', '  // Get user game info connected to current game\n', '  function getMyGameInfo() public view returns (uint256, uint256, uint256) {\n', '    return getPlayerGameInfo(gameIndex, msg.sender);\n', '  }\n', '\n', '  // Return all the game constants, setting the game\n', '  function getGameConstants() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256[]) {\n', '    return (\n', '        timeBetweenGames,\n', '        timeBeforeJackpot,\n', '        minMinBuyETH,\n', '        minMaxBuyETH,\n', '        minBuy,\n', '        maxBuy,\n', '        gameReseeds\n', '      );\n', '  }\n', '\n', '  // Return game information based on game index\n', '  function getGameInfo(uint256 _gameIndex) public view returns (uint256, uint256, uint256, address[], uint256[]) {\n', '    return (\n', '        games[_gameIndex].gameTotalInvested,\n', '        games[_gameIndex].gameTotalPaidOut,\n', '        games[_gameIndex].gameTotalBacklog,\n', '        games[_gameIndex].winners,\n', '        games[_gameIndex].winnerPayouts\n', '      );\n', '  }\n', '\n', '  // Return current running game info\n', '  function getCurrentGameInfo() public view returns (uint256, uint256, uint256, address[], uint256[]) {\n', '    return getGameInfo(gameIndex);\n', '  }\n', '\n', '  // Return time when next game will start\n', '  function getGameStartTime() public view returns (uint256) {\n', '    return gameStartTime;\n', '  }\n', '\n', '  // Return end time for the jackpot round\n', '  function getJackpotRoundEndTime() public view returns (uint256) {\n', '    return lastAction + timeBeforeJackpot;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
