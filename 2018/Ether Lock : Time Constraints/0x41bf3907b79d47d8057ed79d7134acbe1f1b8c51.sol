['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    if (_a == 0) { return 0; }\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a / _b;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20 _token, address _to, uint256 _value) internal {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) internal {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '}\n', '\n', 'interface ERC20 {\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '  constructor() public { owner = msg.sender; }\n', '\n', '  function renounceOwnership() public onlyOwner() {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner() {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract BitSongCrowdsale is Ownable{\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for ERC20;\n', '\n', '  ERC20 public token;\n', '  address public wallet;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  address public kycAdmin;\n', '  uint256 public hardCap;\n', '  uint256 public tokensAllocated;\n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '  uint256 public duration;\n', '\n', '  mapping(address => bool) public approvals;\n', '  mapping(address => uint256) public balances;\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '  event KycApproved(address indexed beneficiary, address indexed admin, bool status);\n', '  event KycRefused(address indexed beneficiary, address indexed admin, bool status);\n', '\n', '  modifier onlyKycAdmin() { require(msg.sender == kycAdmin); _; }\n', '  modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; }\n', '\n', '  constructor(uint256 _rate, address _wallet, uint256 _duration, uint256 _hardCap, ERC20 _tokenAddress) public {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_tokenAddress != address(0));\n', '\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    token = _tokenAddress;\n', '    hardCap = _hardCap * 10**18;\n', '    duration = _duration * 1 days;\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens();\n', '  }\n', '\n', '  function buyTokens() public onlyWhileOpen() payable {\n', '    require(msg.value > 0);\n', '    require(approvals[msg.sender] == true);\n', '    uint256 weiAmount = msg.value;\n', '    uint256 tokenAmount = weiAmount.mul(rate);\n', '    tokensAllocated = tokensAllocated.add(tokenAmount);\n', '    assert(tokensAllocated <= hardCap);\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '    emit TokenPurchase(msg.sender, weiAmount, tokenAmount);\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '  function withdrawTokens() external {\n', '    require(hasClosed());\n', '    uint256 amount = balances[msg.sender];\n', '    require(amount > 0);\n', '    balances[msg.sender] = 0;\n', '    token.safeTransferFrom(wallet, msg.sender, amount);\n', '  }\n', '\n', '  function withdrawTokensFor(address _beneficiary) external {\n', '    require(hasClosed());\n', '    uint256 amount = balances[_beneficiary];\n', '    require(amount > 0);\n', '    balances[_beneficiary] = 0;\n', '    token.safeTransferFrom(wallet, _beneficiary, amount);\n', '  }\n', '\n', '  function hasClosed() public view returns (bool) {\n', '    return block.timestamp > closingTime;\n', '  }\n', '\n', '  function approveAddress(address _beneficiary) external onlyKycAdmin() {\n', '    approvals[_beneficiary] = true;\n', '    emit KycApproved(_beneficiary, kycAdmin, true);\n', '  }\n', '\n', '  function refuseAddress(address _beneficiary) external onlyKycAdmin() {\n', '    approvals[_beneficiary] = false;\n', '    emit KycRefused(_beneficiary, kycAdmin, false);\n', '  }\n', '\n', '  function rewardManual(address _beneficiary, uint256 _amount) external onlyOwner() {\n', '    require(_amount > 0);\n', '    require(_beneficiary != address(0));\n', '    tokensAllocated = tokensAllocated.add(_amount);\n', '    assert(tokensAllocated <= hardCap);\n', '    balances[_beneficiary] = balances[_beneficiary].add(_amount);\n', '  }\n', '\n', '  function transfer(address _beneficiary, uint256 _amount) external onlyOwner() {\n', '    require(_amount > 0);\n', '    require(_beneficiary != address(0));\n', '    token.safeTransfer(_beneficiary, _amount);\n', '  }\n', '\n', '  function setKycAdmin(address _newAdmin) external onlyOwner() {\n', '    kycAdmin = _newAdmin;\n', '  }\n', '\n', '  function startDistribution() external onlyOwner() {\n', '    require(openingTime == 0);\n', '    openingTime = block.timestamp;\n', '    closingTime = openingTime.add(duration);\n', '  }\n', '\n', '  function setRate(uint256 _newRate) external onlyOwner() {\n', '    rate = _newRate;\n', '  }\n', '\n', '  function setClosingTime(uint256 _newTime) external onlyOwner() {\n', '    closingTime = _newTime;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    if (_a == 0) { return 0; }\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a / _b;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20 _token, address _to, uint256 _value) internal {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) internal {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '}\n', '\n', 'interface ERC20 {\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '  constructor() public { owner = msg.sender; }\n', '\n', '  function renounceOwnership() public onlyOwner() {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner() {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract BitSongCrowdsale is Ownable{\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for ERC20;\n', '\n', '  ERC20 public token;\n', '  address public wallet;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  address public kycAdmin;\n', '  uint256 public hardCap;\n', '  uint256 public tokensAllocated;\n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '  uint256 public duration;\n', '\n', '  mapping(address => bool) public approvals;\n', '  mapping(address => uint256) public balances;\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '  event KycApproved(address indexed beneficiary, address indexed admin, bool status);\n', '  event KycRefused(address indexed beneficiary, address indexed admin, bool status);\n', '\n', '  modifier onlyKycAdmin() { require(msg.sender == kycAdmin); _; }\n', '  modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; }\n', '\n', '  constructor(uint256 _rate, address _wallet, uint256 _duration, uint256 _hardCap, ERC20 _tokenAddress) public {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_tokenAddress != address(0));\n', '\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    token = _tokenAddress;\n', '    hardCap = _hardCap * 10**18;\n', '    duration = _duration * 1 days;\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens();\n', '  }\n', '\n', '  function buyTokens() public onlyWhileOpen() payable {\n', '    require(msg.value > 0);\n', '    require(approvals[msg.sender] == true);\n', '    uint256 weiAmount = msg.value;\n', '    uint256 tokenAmount = weiAmount.mul(rate);\n', '    tokensAllocated = tokensAllocated.add(tokenAmount);\n', '    assert(tokensAllocated <= hardCap);\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '    emit TokenPurchase(msg.sender, weiAmount, tokenAmount);\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '  function withdrawTokens() external {\n', '    require(hasClosed());\n', '    uint256 amount = balances[msg.sender];\n', '    require(amount > 0);\n', '    balances[msg.sender] = 0;\n', '    token.safeTransferFrom(wallet, msg.sender, amount);\n', '  }\n', '\n', '  function withdrawTokensFor(address _beneficiary) external {\n', '    require(hasClosed());\n', '    uint256 amount = balances[_beneficiary];\n', '    require(amount > 0);\n', '    balances[_beneficiary] = 0;\n', '    token.safeTransferFrom(wallet, _beneficiary, amount);\n', '  }\n', '\n', '  function hasClosed() public view returns (bool) {\n', '    return block.timestamp > closingTime;\n', '  }\n', '\n', '  function approveAddress(address _beneficiary) external onlyKycAdmin() {\n', '    approvals[_beneficiary] = true;\n', '    emit KycApproved(_beneficiary, kycAdmin, true);\n', '  }\n', '\n', '  function refuseAddress(address _beneficiary) external onlyKycAdmin() {\n', '    approvals[_beneficiary] = false;\n', '    emit KycRefused(_beneficiary, kycAdmin, false);\n', '  }\n', '\n', '  function rewardManual(address _beneficiary, uint256 _amount) external onlyOwner() {\n', '    require(_amount > 0);\n', '    require(_beneficiary != address(0));\n', '    tokensAllocated = tokensAllocated.add(_amount);\n', '    assert(tokensAllocated <= hardCap);\n', '    balances[_beneficiary] = balances[_beneficiary].add(_amount);\n', '  }\n', '\n', '  function transfer(address _beneficiary, uint256 _amount) external onlyOwner() {\n', '    require(_amount > 0);\n', '    require(_beneficiary != address(0));\n', '    token.safeTransfer(_beneficiary, _amount);\n', '  }\n', '\n', '  function setKycAdmin(address _newAdmin) external onlyOwner() {\n', '    kycAdmin = _newAdmin;\n', '  }\n', '\n', '  function startDistribution() external onlyOwner() {\n', '    require(openingTime == 0);\n', '    openingTime = block.timestamp;\n', '    closingTime = openingTime.add(duration);\n', '  }\n', '\n', '  function setRate(uint256 _newRate) external onlyOwner() {\n', '    rate = _newRate;\n', '  }\n', '\n', '  function setClosingTime(uint256 _newTime) external onlyOwner() {\n', '    closingTime = _newTime;\n', '  }\n', '}']
