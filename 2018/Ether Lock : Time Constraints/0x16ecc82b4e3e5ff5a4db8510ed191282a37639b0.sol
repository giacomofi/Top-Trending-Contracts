['pragma solidity ^0.4.16;\n', '\n', '// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ccafa3a2b8adafb88c89b8a4a9bea9a1a3a2e2afa3a1">[email&#160;protected]</a>\n', '\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT,\n', '        ERROR_OBJ_NOT_FOUND,\n', '        ERROR_OBJ_INVALID_OWNERSHIP\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase is EtheremonEnum, BasicAccessControl {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    \n', '    // read\n', '    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\n', '    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant public returns(string name);\n', '    function getExtraBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant public returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '}\n', '\n', 'contract EtheremonTransformData {\n', '    uint64 public totalEgg = 0;\n', '    function getHatchingEggId(address _trainer) constant external returns(uint64);\n', '    function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64);\n', '    function getTranformedId(uint64 _objId) constant external returns(uint64);\n', '    function countEgg(uint64 _objId) constant external returns(uint);\n', '    \n', '    function setHatchTime(uint64 _eggId, uint _hatchTime) external;\n', '    function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external;\n', '    function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64);\n', '    function setTranformed(uint64 _objId, uint64 _newObjId) external;\n', '}\n', '\n', 'contract EtheremonWorld {\n', '    function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32);\n', '    function getTrainerEarn(address _trainer) constant public returns(uint256);\n', '    function getReturnFromMonster(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '    function getClassPropertyValue(uint32 _classId, EtheremonEnum.PropertyType _type, uint index) constant external returns(uint32);\n', '    function getClassPropertySize(uint32 _classId, EtheremonEnum.PropertyType _type) constant external returns(uint);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '    function getMonsterLevel(uint64 _objId) constant public returns(uint8);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'interface EtheremonMonsterNFTInterface {\n', '    function mintMonster(uint32 _classId, address _trainer, string _name) external returns(uint);\n', '    function burnMonster(uint64 _tokenId) external;\n', '}\n', '\n', 'interface EtheremonTransformSettingInterface {\n', '    function getRandomClassId(uint _seed) constant external returns(uint32);\n', '    function getLayEggInfo(uint32 _classId) constant external returns(uint8 layingLevel, uint8 layingCost);\n', '    function getTransformInfo(uint32 _classId) constant external returns(uint32 transformClassId, uint8 level);\n', '    function getClassTransformInfo(uint32 _classId) constant external returns(uint8 layingLevel, uint8 layingCost, uint8 transformLevel, uint32 transformCLassId);\n', '}\n', '\n', 'contract EtheremonTransform is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '    uint8 constant public GEN0_NO = 24;\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '    \n', '    struct MonsterEgg {\n', '        uint64 eggId;\n', '        uint64 objId;\n', '        uint32 classId;\n', '        address trainer;\n', '        uint hatchTime;\n', '        uint64 newObjId;\n', '    }\n', '    \n', '    struct BasicObjInfo {\n', '        uint32 classId;\n', '        address owner;\n', '        uint8 level;\n', '        uint32 exp;\n', '    }\n', '    \n', '    // Gen0 has return price & no longer can be caught when this contract is deployed\n', '    struct Gen0Config {\n', '        uint32 classId;\n', '        uint256 originalPrice;\n', '        uint256 returnPrice;\n', '        uint32 total; // total caught (not count those from eggs)\n', '    }\n', '    \n', '    // hatching range\n', '    uint public hatchStartTime = 2; // hour\n', '    uint public hatchMaxTime = 46; // hour\n', '    uint public removeHatchingTimeFee = 0.05 ether; // ETH\n', '    uint public buyEggFee = 0.09 ether; // ETH\n', '\n', '    mapping(uint8 => uint32) public levelExps;\n', '    mapping(uint32 => Gen0Config) public gen0Config;\n', '    \n', '    // linked smart contract\n', '    address public dataContract;\n', '    address public worldContract;\n', '    address public transformDataContract;\n', '    address public transformSettingContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    address public monsterNFTContract;\n', '    \n', '    // events\n', '    event EventLayEgg(address indexed trainer, uint objId, uint eggId);\n', '    event EventHatchEgg(address indexed trainer, uint eggId, uint objId);\n', '    event EventTransform(address indexed trainer, uint oldObjId, uint newObjId);\n', '    \n', '    // constructor\n', '    function EtheremonTransform(address _dataContract, address _worldContract, address _transformDataContract, address _transformSettingContract,\n', '        address _battleContract, address _tradeContract, address _monsterNFTContract) public {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        transformSettingContract = _transformSettingContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '        monsterNFTContract = _monsterNFTContract;\n', '    }\n', '    \n', '    // helper\n', '    function getRandom(address _player, uint _block, uint64 _count) constant public returns(uint) {\n', '        return uint(keccak256(block.blockhash(_block), _player, _count));\n', '    }\n', '    \n', '    // admin & moderators\n', '    function setContract(address _dataContract, address _worldContract, address _transformDataContract, address _transformSettingContract,\n', '        address _battleContract, address _tradeContract, address _monsterNFTContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        transformSettingContract = _transformSettingContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '        monsterNFTContract = _monsterNFTContract;\n', '    }\n', '\n', '    function setOriginalPriceGen0() onlyModerators external {\n', '        gen0Config[1] = Gen0Config(1, 0.3 ether, 0.003 ether, 374);\n', '        gen0Config[2] = Gen0Config(2, 0.3 ether, 0.003 ether, 408);\n', '        gen0Config[3] = Gen0Config(3, 0.3 ether, 0.003 ether, 373);\n', '        gen0Config[4] = Gen0Config(4, 0.2 ether, 0.002 ether, 437);\n', '        gen0Config[5] = Gen0Config(5, 0.1 ether, 0.001 ether, 497);\n', '        gen0Config[6] = Gen0Config(6, 0.3 ether, 0.003 ether, 380); \n', '        gen0Config[7] = Gen0Config(7, 0.2 ether, 0.002 ether, 345);\n', '        gen0Config[8] = Gen0Config(8, 0.1 ether, 0.001 ether, 518); \n', '        gen0Config[9] = Gen0Config(9, 0.1 ether, 0.001 ether, 447);\n', '        gen0Config[10] = Gen0Config(10, 0.2 ether, 0.002 ether, 380); \n', '        gen0Config[11] = Gen0Config(11, 0.2 ether, 0.002 ether, 354);\n', '        gen0Config[12] = Gen0Config(12, 0.2 ether, 0.002 ether, 346);\n', '        gen0Config[13] = Gen0Config(13, 0.2 ether, 0.002 ether, 351); \n', '        gen0Config[14] = Gen0Config(14, 0.2 ether, 0.002 ether, 338);\n', '        gen0Config[15] = Gen0Config(15, 0.2 ether, 0.002 ether, 341);\n', '        gen0Config[16] = Gen0Config(16, 0.35 ether, 0.0035 ether, 384);\n', '        gen0Config[17] = Gen0Config(17, 1 ether, 0.01 ether, 305); \n', '        gen0Config[18] = Gen0Config(18, 0.1 ether, 0.001 ether, 427);\n', '        gen0Config[19] = Gen0Config(19, 1 ether, 0.01 ether, 304);\n', '        gen0Config[20] = Gen0Config(20, 0.4 ether, 0.05 ether, 82);\n', '        gen0Config[21] = Gen0Config(21, 1, 1, 123);\n', '        gen0Config[22] = Gen0Config(22, 0.2 ether, 0.001 ether, 468);\n', '        gen0Config[23] = Gen0Config(23, 0.5 ether, 0.0025 ether, 302);\n', '        gen0Config[24] = Gen0Config(24, 1 ether, 0.005 ether, 195);\n', '    } \n', '\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        // no user money is kept in this contract, only trasaction fee\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '    \n', '    function setConfig(uint _removeHatchingTimeFee, uint _buyEggFee, uint _hatchStartTime, uint _hatchMaxTime) onlyModerators external {\n', '        removeHatchingTimeFee = _removeHatchingTimeFee;\n', '        buyEggFee = _buyEggFee;\n', '        hatchStartTime = _hatchStartTime;\n', '        hatchMaxTime = _hatchMaxTime;\n', '    }\n', '\n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function removeHatchingTimeWithToken(address _trainer) isActive onlyModerators external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(_trainer);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != _trainer || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }    \n', '    \n', '    function buyEggWithToken(address _trainer) isActive onlyModerators external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(_trainer) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint seed = getRandom(_trainer, block.number - 1, transformData.totalEgg());\n', '        uint32 classId = EtheremonTransformSettingInterface(transformSettingContract).getRandomClassId(seed);\n', '        if (classId == 0) revert();\n', '        uint64 eggId = transformData.addEgg(0, classId, _trainer, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(_trainer, 0, eggId);\n', '    }\n', '    \n', '    // public\n', '\n', '    function ceil(uint a, uint m) pure public returns (uint) {\n', '        return ((a + m - 1) / m) * m;\n', '    }\n', '\n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '\n', '    function getGen0ObjInfo(uint64 _objId) constant public returns(uint32, uint32, uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        \n', '        Gen0Config memory gen0 = gen0Config[obj.classId];\n', '        if (gen0.classId != obj.classId) {\n', '            return (gen0.classId, obj.createIndex, 0);\n', '        }\n', '        \n', '        uint32 totalGap = 0;\n', '        if (obj.createIndex < gen0.total)\n', '            totalGap = gen0.total - obj.createIndex;\n', '        \n', '        return (obj.classId, obj.createIndex, safeMult(totalGap, gen0.returnPrice));\n', '    }\n', '    \n', '    function getObjClassExp(uint64 _objId) constant public returns(uint32, address, uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        return (obj.classId, obj.trainer, obj.exp);\n', '    }\n', '    \n', '    function getClassCheckOwner(uint64 _objId, address _trainer) constant public returns(uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (_trainer != obj.trainer)\n', '            return 0;\n', '        return obj.classId;\n', '    }\n', '\n', '    function calculateMaxEggG0(uint64 _objId) constant public returns(uint) {\n', '        uint32 classId;\n', '        uint32 createIndex; \n', '        uint256 totalEarn;\n', '        (classId, createIndex, totalEarn) = getGen0ObjInfo(_objId);\n', '        if (classId > GEN0_NO || classId == 20 || classId == 21)\n', '            return 0;\n', '        \n', '        Gen0Config memory config = gen0Config[classId];\n', '        // the one from egg can not lay\n', '        if (createIndex > config.total)\n', '            return 0;\n', '\n', '        // calculate agv price\n', '        uint256 avgPrice = config.originalPrice;\n', '        uint rate = config.originalPrice/config.returnPrice;\n', '        if (config.total > rate) {\n', '            uint k = config.total - rate;\n', '            avgPrice = (config.total * config.originalPrice + config.returnPrice * k * (k+1) / 2) / config.total;\n', '        }\n', '        uint256 catchPrice = config.originalPrice;            \n', '        if (createIndex > rate) {\n', '            catchPrice += config.returnPrice * safeSubtract(createIndex, rate);\n', '        }\n', '        if (totalEarn >= catchPrice) {\n', '            return 0;\n', '        }\n', '        return ceil((catchPrice - totalEarn)*15*1000/avgPrice, 10000)/10000;\n', '    }\n', '    \n', '    function layEgg(uint64 _objId) isActive external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // can not lay egg when trading\n', '        if (EtheremonTradeInterface(tradeContract).isOnTrading(_objId))\n', '            revert();\n', '        \n', '        // check obj \n', '        uint32 classId;\n', '        address owner;\n', '        uint32 exp;\n', '        uint8 currentLevel;\n', '        (classId, owner, exp) = getObjClassExp(_objId);\n', '        currentLevel = getLevel(exp);\n', '        if (classId == 0 || owner != msg.sender) {\n', '            revert();\n', '        }\n', '        \n', '        // check lay egg condition\n', '        uint8 temp = 0;\n', '        \n', '        if (classId <= GEN0_NO) {\n', '            // legends\n', '            if (transformData.countEgg(_objId) >= calculateMaxEggG0(_objId))\n', '                revert();\n', '            temp = currentLevel;\n', '        } else {\n', '            uint8 layingLevel;\n', '            (layingLevel, temp) = EtheremonTransformSettingInterface(transformSettingContract).getLayEggInfo(classId);\n', '            if (layingLevel == 0 || currentLevel < layingLevel || currentLevel < temp)\n', '                revert();\n', '            temp = currentLevel - temp;\n', '        }\n', '        \n', '        // add egg \n', '        uint seed = getRandom(msg.sender, block.number - 1, transformData.totalEgg());\n', '        uint64 eggId = transformData.addEgg(_objId, classId, msg.sender, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        \n', '        // deduct exp \n', '        if (temp < currentLevel) {\n', '            EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '            data.decreaseMonsterExp(_objId, exp - levelExps[temp-1]);\n', '        }\n', '        EventLayEgg(msg.sender, _objId, eggId);\n', '    }\n', '    \n', '    function hatchEgg() isActive external {\n', '        // use as a seed for random\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender)\n', '            revert();\n', '        // need more time\n', '        if (egg.newObjId > 0 || egg.hatchTime > block.timestamp) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }\n', '    \n', '    function removeHatchingTime() isActive external payable  {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        if (msg.value != removeHatchingTimeFee) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }\n', '\n', '    \n', '    function checkAncestors(uint32 _classId, address _trainer, uint64 _a1, uint64 _a2, uint64 _a3) constant public returns(bool) {\n', '        EtheremonWorld world = EtheremonWorld(worldContract);\n', '        uint index = 0;\n', '        uint32 temp = 0;\n', '        // check ancestor\n', '        uint32[3] memory ancestors;\n', '        uint32[3] memory requestAncestors;\n', '        index = world.getClassPropertySize(_classId, PropertyType.ANCESTOR);\n', '        while (index > 0) {\n', '            index -= 1;\n', '            ancestors[index] = world.getClassPropertyValue(_classId, PropertyType.ANCESTOR, index);\n', '        }\n', '            \n', '        if (_a1 > 0) {\n', '            temp = getClassCheckOwner(_a1, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[0] = temp;\n', '        }\n', '        if (_a2 > 0) {\n', '            temp = getClassCheckOwner(_a2, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[1] = temp;\n', '        }\n', '        if (_a3 > 0) {\n', '            temp = getClassCheckOwner(_a3, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[2] = temp;\n', '        }\n', '            \n', '        if (requestAncestors[0] > 0 && (requestAncestors[0] == requestAncestors[1] || requestAncestors[0] == requestAncestors[2]))\n', '            return false;\n', '        if (requestAncestors[1] > 0 && (requestAncestors[1] == requestAncestors[2]))\n', '            return false;\n', '                \n', '        for (index = 0; index < ancestors.length; index++) {\n', '            temp = ancestors[index];\n', '            if (temp > 0 && temp != requestAncestors[0]  && temp != requestAncestors[1] && temp != requestAncestors[2])\n', '                return false;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transform(uint64 _objId, uint64 _a1, uint64 _a2, uint64 _a3) isActive external payable {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        if (transformData.getTranformedId(_objId) > 0)\n', '            revert();\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (battle.isOnBattle(_objId) || trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        BasicObjInfo memory objInfo;\n', '        (objInfo.classId, objInfo.owner, objInfo.exp) = getObjClassExp(_objId);\n', '        objInfo.level = getLevel(objInfo.exp);\n', '        if (objInfo.classId == 0 || objInfo.owner != msg.sender)\n', '            revert();\n', '        \n', '        uint32 transformClass;\n', '        uint8 transformLevel;\n', '        (transformClass, transformLevel) = EtheremonTransformSettingInterface(transformSettingContract).getTransformInfo(objInfo.classId);\n', '        if (transformClass == 0 || transformLevel == 0) revert();\n', '        if (objInfo.level < transformLevel) revert();\n', '        \n', '        // gen0 - can not transform if it has bonus egg \n', '        if (objInfo.classId <= GEN0_NO) {\n', '            // legends\n', '            if (getBonusEgg(_objId) > 0)\n', '                revert();\n', '        } else {\n', '            if (!checkAncestors(objInfo.classId, msg.sender, _a1, _a2, _a3))\n', '                revert();\n', '        }\n', '        \n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint newObjId = monsterNFT.mintMonster(transformClass, msg.sender, "..name me...");\n', '        monsterNFT.burnMonster(_objId);\n', '\n', '        transformData.setTranformed(_objId, uint64(newObjId));\n', '        EventTransform(msg.sender, _objId, newObjId);\n', '    }\n', '    \n', '    function buyEgg() isActive external payable {\n', '        if (msg.value != buyEggFee) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // add random egg\n', '        uint seed = getRandom(msg.sender, block.number - 1, transformData.totalEgg());\n', '        uint32 classId = EtheremonTransformSettingInterface(transformSettingContract).getRandomClassId(seed);\n', '        if (classId == 0) revert();\n', '        uint64 eggId = transformData.addEgg(0, classId, msg.sender, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // read\n', '    function getBonusEgg(uint64 _objId) constant public returns(uint) {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        uint totalBonusEgg = calculateMaxEggG0(_objId);\n', '        if (totalBonusEgg > 0) {\n', '            return (totalBonusEgg - transformData.countEgg(_objId));\n', '        }\n', '        return 0;\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '// copyright contact@Etheremon.com\n', '\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'contract EtheremonEnum {\n', '\n', '    enum ResultCode {\n', '        SUCCESS,\n', '        ERROR_CLASS_NOT_FOUND,\n', '        ERROR_LOW_BALANCE,\n', '        ERROR_SEND_FAIL,\n', '        ERROR_NOT_TRAINER,\n', '        ERROR_NOT_ENOUGH_MONEY,\n', '        ERROR_INVALID_AMOUNT,\n', '        ERROR_OBJ_NOT_FOUND,\n', '        ERROR_OBJ_INVALID_OWNERSHIP\n', '    }\n', '    \n', '    enum ArrayType {\n', '        CLASS_TYPE,\n', '        STAT_STEP,\n', '        STAT_START,\n', '        STAT_BASE,\n', '        OBJ_SKILL\n', '    }\n', '    \n', '    enum PropertyType {\n', '        ANCESTOR,\n', '        XFACTOR\n', '    }\n', '}\n', '\n', 'contract EtheremonDataBase is EtheremonEnum, BasicAccessControl {\n', '    \n', '    uint64 public totalMonster;\n', '    uint32 public totalClass;\n', '    \n', '    // write\n', '    function decreaseMonsterExp(uint64 _objId, uint32 amount) external;\n', '    \n', '    // read\n', '    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\n', '    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\n', '    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\n', '    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '    function getMonsterName(uint64 _objId) constant public returns(string name);\n', '    function getExtraBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterDexSize(address _trainer) constant public returns(uint);\n', '    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\n', '    function getExpectedBalance(address _trainer) constant public returns(uint256);\n', '    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '}\n', '\n', 'contract EtheremonTransformData {\n', '    uint64 public totalEgg = 0;\n', '    function getHatchingEggId(address _trainer) constant external returns(uint64);\n', '    function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64);\n', '    function getTranformedId(uint64 _objId) constant external returns(uint64);\n', '    function countEgg(uint64 _objId) constant external returns(uint);\n', '    \n', '    function setHatchTime(uint64 _eggId, uint _hatchTime) external;\n', '    function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external;\n', '    function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64);\n', '    function setTranformed(uint64 _objId, uint64 _newObjId) external;\n', '}\n', '\n', 'contract EtheremonWorld {\n', '    function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32);\n', '    function getTrainerEarn(address _trainer) constant public returns(uint256);\n', '    function getReturnFromMonster(uint64 _objId) constant public returns(uint256 current, uint256 total);\n', '    function getClassPropertyValue(uint32 _classId, EtheremonEnum.PropertyType _type, uint index) constant external returns(uint32);\n', '    function getClassPropertySize(uint32 _classId, EtheremonEnum.PropertyType _type) constant external returns(uint);\n', '}\n', '\n', 'interface EtheremonBattle {\n', '    function isOnBattle(uint64 _objId) constant external returns(bool);\n', '    function getMonsterLevel(uint64 _objId) constant public returns(uint8);\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'interface EtheremonMonsterNFTInterface {\n', '    function mintMonster(uint32 _classId, address _trainer, string _name) external returns(uint);\n', '    function burnMonster(uint64 _tokenId) external;\n', '}\n', '\n', 'interface EtheremonTransformSettingInterface {\n', '    function getRandomClassId(uint _seed) constant external returns(uint32);\n', '    function getLayEggInfo(uint32 _classId) constant external returns(uint8 layingLevel, uint8 layingCost);\n', '    function getTransformInfo(uint32 _classId) constant external returns(uint32 transformClassId, uint8 level);\n', '    function getClassTransformInfo(uint32 _classId) constant external returns(uint8 layingLevel, uint8 layingCost, uint8 transformLevel, uint32 transformCLassId);\n', '}\n', '\n', 'contract EtheremonTransform is EtheremonEnum, BasicAccessControl, SafeMath {\n', '    uint8 constant public STAT_COUNT = 6;\n', '    uint8 constant public STAT_MAX = 32;\n', '    uint8 constant public GEN0_NO = 24;\n', '\n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '    \n', '    struct MonsterEgg {\n', '        uint64 eggId;\n', '        uint64 objId;\n', '        uint32 classId;\n', '        address trainer;\n', '        uint hatchTime;\n', '        uint64 newObjId;\n', '    }\n', '    \n', '    struct BasicObjInfo {\n', '        uint32 classId;\n', '        address owner;\n', '        uint8 level;\n', '        uint32 exp;\n', '    }\n', '    \n', '    // Gen0 has return price & no longer can be caught when this contract is deployed\n', '    struct Gen0Config {\n', '        uint32 classId;\n', '        uint256 originalPrice;\n', '        uint256 returnPrice;\n', '        uint32 total; // total caught (not count those from eggs)\n', '    }\n', '    \n', '    // hatching range\n', '    uint public hatchStartTime = 2; // hour\n', '    uint public hatchMaxTime = 46; // hour\n', '    uint public removeHatchingTimeFee = 0.05 ether; // ETH\n', '    uint public buyEggFee = 0.09 ether; // ETH\n', '\n', '    mapping(uint8 => uint32) public levelExps;\n', '    mapping(uint32 => Gen0Config) public gen0Config;\n', '    \n', '    // linked smart contract\n', '    address public dataContract;\n', '    address public worldContract;\n', '    address public transformDataContract;\n', '    address public transformSettingContract;\n', '    address public battleContract;\n', '    address public tradeContract;\n', '    address public monsterNFTContract;\n', '    \n', '    // events\n', '    event EventLayEgg(address indexed trainer, uint objId, uint eggId);\n', '    event EventHatchEgg(address indexed trainer, uint eggId, uint objId);\n', '    event EventTransform(address indexed trainer, uint oldObjId, uint newObjId);\n', '    \n', '    // constructor\n', '    function EtheremonTransform(address _dataContract, address _worldContract, address _transformDataContract, address _transformSettingContract,\n', '        address _battleContract, address _tradeContract, address _monsterNFTContract) public {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        transformSettingContract = _transformSettingContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '        monsterNFTContract = _monsterNFTContract;\n', '    }\n', '    \n', '    // helper\n', '    function getRandom(address _player, uint _block, uint64 _count) constant public returns(uint) {\n', '        return uint(keccak256(block.blockhash(_block), _player, _count));\n', '    }\n', '    \n', '    // admin & moderators\n', '    function setContract(address _dataContract, address _worldContract, address _transformDataContract, address _transformSettingContract,\n', '        address _battleContract, address _tradeContract, address _monsterNFTContract) onlyModerators external {\n', '        dataContract = _dataContract;\n', '        worldContract = _worldContract;\n', '        transformDataContract = _transformDataContract;\n', '        transformSettingContract = _transformSettingContract;\n', '        battleContract = _battleContract;\n', '        tradeContract = _tradeContract;\n', '        monsterNFTContract = _monsterNFTContract;\n', '    }\n', '\n', '    function setOriginalPriceGen0() onlyModerators external {\n', '        gen0Config[1] = Gen0Config(1, 0.3 ether, 0.003 ether, 374);\n', '        gen0Config[2] = Gen0Config(2, 0.3 ether, 0.003 ether, 408);\n', '        gen0Config[3] = Gen0Config(3, 0.3 ether, 0.003 ether, 373);\n', '        gen0Config[4] = Gen0Config(4, 0.2 ether, 0.002 ether, 437);\n', '        gen0Config[5] = Gen0Config(5, 0.1 ether, 0.001 ether, 497);\n', '        gen0Config[6] = Gen0Config(6, 0.3 ether, 0.003 ether, 380); \n', '        gen0Config[7] = Gen0Config(7, 0.2 ether, 0.002 ether, 345);\n', '        gen0Config[8] = Gen0Config(8, 0.1 ether, 0.001 ether, 518); \n', '        gen0Config[9] = Gen0Config(9, 0.1 ether, 0.001 ether, 447);\n', '        gen0Config[10] = Gen0Config(10, 0.2 ether, 0.002 ether, 380); \n', '        gen0Config[11] = Gen0Config(11, 0.2 ether, 0.002 ether, 354);\n', '        gen0Config[12] = Gen0Config(12, 0.2 ether, 0.002 ether, 346);\n', '        gen0Config[13] = Gen0Config(13, 0.2 ether, 0.002 ether, 351); \n', '        gen0Config[14] = Gen0Config(14, 0.2 ether, 0.002 ether, 338);\n', '        gen0Config[15] = Gen0Config(15, 0.2 ether, 0.002 ether, 341);\n', '        gen0Config[16] = Gen0Config(16, 0.35 ether, 0.0035 ether, 384);\n', '        gen0Config[17] = Gen0Config(17, 1 ether, 0.01 ether, 305); \n', '        gen0Config[18] = Gen0Config(18, 0.1 ether, 0.001 ether, 427);\n', '        gen0Config[19] = Gen0Config(19, 1 ether, 0.01 ether, 304);\n', '        gen0Config[20] = Gen0Config(20, 0.4 ether, 0.05 ether, 82);\n', '        gen0Config[21] = Gen0Config(21, 1, 1, 123);\n', '        gen0Config[22] = Gen0Config(22, 0.2 ether, 0.001 ether, 468);\n', '        gen0Config[23] = Gen0Config(23, 0.5 ether, 0.0025 ether, 302);\n', '        gen0Config[24] = Gen0Config(24, 1 ether, 0.005 ether, 195);\n', '    } \n', '\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        // no user money is kept in this contract, only trasaction fee\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '    \n', '    function setConfig(uint _removeHatchingTimeFee, uint _buyEggFee, uint _hatchStartTime, uint _hatchMaxTime) onlyModerators external {\n', '        removeHatchingTimeFee = _removeHatchingTimeFee;\n', '        buyEggFee = _buyEggFee;\n', '        hatchStartTime = _hatchStartTime;\n', '        hatchMaxTime = _hatchMaxTime;\n', '    }\n', '\n', '    function genLevelExp() onlyModerators external {\n', '        uint8 level = 1;\n', '        uint32 requirement = 100;\n', '        uint32 sum = requirement;\n', '        while(level <= 100) {\n', '            levelExps[level] = sum;\n', '            level += 1;\n', '            requirement = (requirement * 11) / 10 + 5;\n', '            sum += requirement;\n', '        }\n', '    }\n', '    \n', '    function removeHatchingTimeWithToken(address _trainer) isActive onlyModerators external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(_trainer);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != _trainer || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }    \n', '    \n', '    function buyEggWithToken(address _trainer) isActive onlyModerators external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(_trainer) > 0) {\n', '            revert();\n', '        }\n', '\n', '        // add random egg\n', '        uint seed = getRandom(_trainer, block.number - 1, transformData.totalEgg());\n', '        uint32 classId = EtheremonTransformSettingInterface(transformSettingContract).getRandomClassId(seed);\n', '        if (classId == 0) revert();\n', '        uint64 eggId = transformData.addEgg(0, classId, _trainer, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(_trainer, 0, eggId);\n', '    }\n', '    \n', '    // public\n', '\n', '    function ceil(uint a, uint m) pure public returns (uint) {\n', '        return ((a + m - 1) / m) * m;\n', '    }\n', '\n', '    function getLevel(uint32 exp) view public returns (uint8) {\n', '        uint8 minIndex = 1;\n', '        uint8 maxIndex = 100;\n', '        uint8 currentIndex;\n', '     \n', '        while (minIndex < maxIndex) {\n', '            currentIndex = (minIndex + maxIndex) / 2;\n', '            if (exp < levelExps[currentIndex])\n', '                maxIndex = currentIndex;\n', '            else\n', '                minIndex = currentIndex + 1;\n', '        }\n', '\n', '        return minIndex;\n', '    }\n', '\n', '    function getGen0ObjInfo(uint64 _objId) constant public returns(uint32, uint32, uint256) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        \n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        \n', '        Gen0Config memory gen0 = gen0Config[obj.classId];\n', '        if (gen0.classId != obj.classId) {\n', '            return (gen0.classId, obj.createIndex, 0);\n', '        }\n', '        \n', '        uint32 totalGap = 0;\n', '        if (obj.createIndex < gen0.total)\n', '            totalGap = gen0.total - obj.createIndex;\n', '        \n', '        return (obj.classId, obj.createIndex, safeMult(totalGap, gen0.returnPrice));\n', '    }\n', '    \n', '    function getObjClassExp(uint64 _objId) constant public returns(uint32, address, uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n', '        return (obj.classId, obj.trainer, obj.exp);\n', '    }\n', '    \n', '    function getClassCheckOwner(uint64 _objId, address _trainer) constant public returns(uint32) {\n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        uint32 _ = 0;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\n', '        if (_trainer != obj.trainer)\n', '            return 0;\n', '        return obj.classId;\n', '    }\n', '\n', '    function calculateMaxEggG0(uint64 _objId) constant public returns(uint) {\n', '        uint32 classId;\n', '        uint32 createIndex; \n', '        uint256 totalEarn;\n', '        (classId, createIndex, totalEarn) = getGen0ObjInfo(_objId);\n', '        if (classId > GEN0_NO || classId == 20 || classId == 21)\n', '            return 0;\n', '        \n', '        Gen0Config memory config = gen0Config[classId];\n', '        // the one from egg can not lay\n', '        if (createIndex > config.total)\n', '            return 0;\n', '\n', '        // calculate agv price\n', '        uint256 avgPrice = config.originalPrice;\n', '        uint rate = config.originalPrice/config.returnPrice;\n', '        if (config.total > rate) {\n', '            uint k = config.total - rate;\n', '            avgPrice = (config.total * config.originalPrice + config.returnPrice * k * (k+1) / 2) / config.total;\n', '        }\n', '        uint256 catchPrice = config.originalPrice;            \n', '        if (createIndex > rate) {\n', '            catchPrice += config.returnPrice * safeSubtract(createIndex, rate);\n', '        }\n', '        if (totalEarn >= catchPrice) {\n', '            return 0;\n', '        }\n', '        return ceil((catchPrice - totalEarn)*15*1000/avgPrice, 10000)/10000;\n', '    }\n', '    \n', '    function layEgg(uint64 _objId) isActive external {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // can not lay egg when trading\n', '        if (EtheremonTradeInterface(tradeContract).isOnTrading(_objId))\n', '            revert();\n', '        \n', '        // check obj \n', '        uint32 classId;\n', '        address owner;\n', '        uint32 exp;\n', '        uint8 currentLevel;\n', '        (classId, owner, exp) = getObjClassExp(_objId);\n', '        currentLevel = getLevel(exp);\n', '        if (classId == 0 || owner != msg.sender) {\n', '            revert();\n', '        }\n', '        \n', '        // check lay egg condition\n', '        uint8 temp = 0;\n', '        \n', '        if (classId <= GEN0_NO) {\n', '            // legends\n', '            if (transformData.countEgg(_objId) >= calculateMaxEggG0(_objId))\n', '                revert();\n', '            temp = currentLevel;\n', '        } else {\n', '            uint8 layingLevel;\n', '            (layingLevel, temp) = EtheremonTransformSettingInterface(transformSettingContract).getLayEggInfo(classId);\n', '            if (layingLevel == 0 || currentLevel < layingLevel || currentLevel < temp)\n', '                revert();\n', '            temp = currentLevel - temp;\n', '        }\n', '        \n', '        // add egg \n', '        uint seed = getRandom(msg.sender, block.number - 1, transformData.totalEgg());\n', '        uint64 eggId = transformData.addEgg(_objId, classId, msg.sender, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        \n', '        // deduct exp \n', '        if (temp < currentLevel) {\n', '            EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '            data.decreaseMonsterExp(_objId, exp - levelExps[temp-1]);\n', '        }\n', '        EventLayEgg(msg.sender, _objId, eggId);\n', '    }\n', '    \n', '    function hatchEgg() isActive external {\n', '        // use as a seed for random\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender)\n', '            revert();\n', '        // need more time\n', '        if (egg.newObjId > 0 || egg.hatchTime > block.timestamp) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }\n', '    \n', '    function removeHatchingTime() isActive external payable  {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        MonsterEgg memory egg;\n', '        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\n', '        // not hatching any egg\n', '        if (egg.eggId == 0 || egg.trainer != msg.sender || egg.newObjId > 0)\n', '            revert();\n', '        \n', '        if (msg.value != removeHatchingTimeFee) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint objId = monsterNFT.mintMonster(egg.classId, egg.trainer, "..name me...");\n', '        transformData.setHatchedEgg(egg.eggId, uint64(objId));\n', '        EventHatchEgg(egg.trainer, egg.eggId, objId);\n', '    }\n', '\n', '    \n', '    function checkAncestors(uint32 _classId, address _trainer, uint64 _a1, uint64 _a2, uint64 _a3) constant public returns(bool) {\n', '        EtheremonWorld world = EtheremonWorld(worldContract);\n', '        uint index = 0;\n', '        uint32 temp = 0;\n', '        // check ancestor\n', '        uint32[3] memory ancestors;\n', '        uint32[3] memory requestAncestors;\n', '        index = world.getClassPropertySize(_classId, PropertyType.ANCESTOR);\n', '        while (index > 0) {\n', '            index -= 1;\n', '            ancestors[index] = world.getClassPropertyValue(_classId, PropertyType.ANCESTOR, index);\n', '        }\n', '            \n', '        if (_a1 > 0) {\n', '            temp = getClassCheckOwner(_a1, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[0] = temp;\n', '        }\n', '        if (_a2 > 0) {\n', '            temp = getClassCheckOwner(_a2, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[1] = temp;\n', '        }\n', '        if (_a3 > 0) {\n', '            temp = getClassCheckOwner(_a3, _trainer);\n', '            if (temp == 0)\n', '                return false;\n', '            requestAncestors[2] = temp;\n', '        }\n', '            \n', '        if (requestAncestors[0] > 0 && (requestAncestors[0] == requestAncestors[1] || requestAncestors[0] == requestAncestors[2]))\n', '            return false;\n', '        if (requestAncestors[1] > 0 && (requestAncestors[1] == requestAncestors[2]))\n', '            return false;\n', '                \n', '        for (index = 0; index < ancestors.length; index++) {\n', '            temp = ancestors[index];\n', '            if (temp > 0 && temp != requestAncestors[0]  && temp != requestAncestors[1] && temp != requestAncestors[2])\n', '                return false;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transform(uint64 _objId, uint64 _a1, uint64 _a2, uint64 _a3) isActive external payable {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        if (transformData.getTranformedId(_objId) > 0)\n', '            revert();\n', '        \n', '        EtheremonBattle battle = EtheremonBattle(battleContract);\n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (battle.isOnBattle(_objId) || trade.isOnTrading(_objId))\n', '            revert();\n', '        \n', '        BasicObjInfo memory objInfo;\n', '        (objInfo.classId, objInfo.owner, objInfo.exp) = getObjClassExp(_objId);\n', '        objInfo.level = getLevel(objInfo.exp);\n', '        if (objInfo.classId == 0 || objInfo.owner != msg.sender)\n', '            revert();\n', '        \n', '        uint32 transformClass;\n', '        uint8 transformLevel;\n', '        (transformClass, transformLevel) = EtheremonTransformSettingInterface(transformSettingContract).getTransformInfo(objInfo.classId);\n', '        if (transformClass == 0 || transformLevel == 0) revert();\n', '        if (objInfo.level < transformLevel) revert();\n', '        \n', '        // gen0 - can not transform if it has bonus egg \n', '        if (objInfo.classId <= GEN0_NO) {\n', '            // legends\n', '            if (getBonusEgg(_objId) > 0)\n', '                revert();\n', '        } else {\n', '            if (!checkAncestors(objInfo.classId, msg.sender, _a1, _a2, _a3))\n', '                revert();\n', '        }\n', '        \n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        uint newObjId = monsterNFT.mintMonster(transformClass, msg.sender, "..name me...");\n', '        monsterNFT.burnMonster(_objId);\n', '\n', '        transformData.setTranformed(_objId, uint64(newObjId));\n', '        EventTransform(msg.sender, _objId, newObjId);\n', '    }\n', '    \n', '    function buyEgg() isActive external payable {\n', '        if (msg.value != buyEggFee) {\n', '            revert();\n', '        }\n', '        \n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        // make sure no hatching egg at the same time\n', '        if (transformData.getHatchingEggId(msg.sender) > 0) {\n', '            revert();\n', '        }\n', '        \n', '        // add random egg\n', '        uint seed = getRandom(msg.sender, block.number - 1, transformData.totalEgg());\n', '        uint32 classId = EtheremonTransformSettingInterface(transformSettingContract).getRandomClassId(seed);\n', '        if (classId == 0) revert();\n', '        uint64 eggId = transformData.addEgg(0, classId, msg.sender, block.timestamp + (hatchStartTime + seed % hatchMaxTime) * 3600);\n', '        // deduct exp\n', '        EventLayEgg(msg.sender, 0, eggId);\n', '    }\n', '    \n', '    // read\n', '    function getBonusEgg(uint64 _objId) constant public returns(uint) {\n', '        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\n', '        uint totalBonusEgg = calculateMaxEggG0(_objId);\n', '        if (totalBonusEgg > 0) {\n', '            return (totalBonusEgg - transformData.countEgg(_objId));\n', '        }\n', '        return 0;\n', '    }\n', '}']
