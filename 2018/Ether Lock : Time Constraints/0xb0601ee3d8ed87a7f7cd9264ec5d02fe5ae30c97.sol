['pragma solidity ^0.4.25;\n', '\n', '//This smart-contract was developed exclusively for kassa.network\n', '//if you need smart-contracts like this, more complicated or more simple, please contact vijaya108@pm.me\n', '\n', 'contract Ownable\n', '{\n', '    address public laxmi;\n', '    address public newLaxmi;\n', '\n', '    constructor() public\n', '    {\n', '        laxmi = msg.sender;\n', '    }\n', '\n', '    modifier onlyLaxmi()\n', '    {\n', '        require(msg.sender == laxmi, "Can used only by owner");\n', '        _;\n', '    }\n', '\n', '    function changeLaxmi(address _laxmi) onlyLaxmi public\n', '    {\n', '        require(_laxmi != 0, "Please provide new owner address");\n', '        newLaxmi = _laxmi;\n', '    }\n', '\n', '    function confirmLaxmi() public\n', '    {\n', '        require(newLaxmi == msg.sender, "Please call from new owner");\n', '        laxmi = newLaxmi;\n', '        delete newLaxmi;\n', '    }\n', '}\n', '\n', 'library SafeMath\n', '{\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c)\n', '    {\n', '        if (_a == 0) { return 0; }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256)\n', '    {\n', '        return _a / _b;\n', '    }\n', '\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256)\n', '    {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c)\n', '    {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract KassaNetwork is Ownable\n', '{\n', '    using SafeMath for uint;\n', '\n', "    string  public constant name    = 'Kassa 100/30';\n", '    uint public startTimestamp = now;\n', '\n', '    uint public constant procKoef = 10000;\n', '    uint public constant perDay = 130;\n', '    uint public constant ownerFee = 800;\n', '    uint[1] public bonusReferrer = [700];\n', '\n', '    uint public constant procReturn = 9000;\n', '\n', '\n', '    uint public constant maxDepositDays = 100;\n', '\n', '\n', '    uint public constant minimalDeposit = 0.25 ether;\n', '    uint public constant maximalDepositStart = 15 ether;\n', '    uint public constant maximalDepositFinish = 100 ether;\n', '\n', '    uint public constant minimalDepositForBonusReferrer = 0.015 ether;\n', '\n', '    uint public constant dayLimitStart = 50 ether;\n', '\n', '\n', '    uint public constant progressProcKoef = 100;\n', '    uint public constant dayLimitProgressProc = 2;\n', '    uint public constant maxDepositProgressProc = 1;\n', '\n', '    uint public countInvestors = 0;\n', '    uint public totalInvest = 0;\n', '    uint public totalPenalty = 0;\n', '    uint public totalSelfInvest = 0;\n', '    uint public totalPaid = 0;\n', '    uint public unlimitedInvest = 3000 ether;\n', '    bool public isUnlimitedContractInvest = false;\n', '    bool public isUnlimitedDayInvest = false;\n', '\n', '    event LogInvestment(address _addr, uint _value, bytes _refData);\n', '    event LogTransfer(address _addr, uint _amount, uint _contactBalance);\n', '    event LogSelfInvestment(uint _value);\n', '\n', '    event LogPreparePayment(address _addr, uint _totalInteres, uint _paidInteres, uint _amount);\n', '    event LogSkipPreparePayment(address _addr, uint _totalInteres, uint _paidInteres);\n', '\n', '    event LogPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals, uint _amount);\n', '    event LogSkipPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals);\n', '\n', '    event LogMinimalDepositPayment(address _addr, uint _money, uint _totalPenalty);\n', '    event LogPenaltyPayment(address _addr, uint currentSenderDeposit, uint referrerAdressLength, address _referrer, uint currentReferrerDeposit, uint _money, uint _sendBackAmount, uint _totalPenalty);\n', '    event LogExceededRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _badDeposit, uint _sendBackAmount, uint _totalPenalty, uint _willDeposit);\n', '\n', '    event LogUsedRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _realDeposit, uint _usedDepositPerDay);\n', '    event LogCalcBonusReferrer(address _referrer, uint _money, uint _index, uint _bonusReferrer, uint _amountReferrer, address _nextReferrer);\n', '\n', '\n', '    struct User\n', '    {\n', '        uint balance;\n', '        uint paidInteres;\n', '        uint timestamp;\n', '        uint countReferrals;\n', '        uint earnOnReferrals;\n', '        uint paidReferrals;\n', '        address referrer;\n', '    }\n', '\n', '    mapping (address => User) private user;\n', '\n', '    mapping (uint => uint) private usedDeposit;\n', '\n', '    function getInteres(address addr) private view returns(uint interes)\n', '    {\n', '        uint diffDays = getNDay(user[addr].timestamp);\n', '\n', '        if( diffDays > maxDepositDays ) diffDays = maxDepositDays;\n', '\n', '        interes = user[addr].balance.mul(perDay).mul(diffDays).div(procKoef);\n', '    }\n', '\n', '    function getUser(address addr) public view returns(uint balance, uint timestamp, uint paidInteres, uint totalInteres, uint countReferrals, uint earnOnReferrals, uint paidReferrals, address referrer)\n', '    {\n', '        address a = addr;\n', '        return (\n', '        user[a].balance,\n', '        user[a].timestamp,\n', '        user[a].paidInteres,\n', '        getInteres(a),\n', '        user[a].countReferrals,\n', '        user[a].earnOnReferrals,\n', '        user[a].paidReferrals,\n', '        user[a].referrer\n', '        );\n', '    }\n', '\n', '    function getCurrentDay() public view returns(uint nday)\n', '    {\n', '        nday = getNDay(startTimestamp);\n', '    }\n', '\n', '    function getNDay(uint date) public view returns(uint nday)\n', '    {\n', '        uint diffTime = date > 0 ? now.sub(date) : 0;\n', '\n', '        nday = diffTime.div(24 hours);\n', '    }\n', '\n', '    function getCurrentDayDepositLimit() public view returns(uint limit)\n', '    {\n', '        if (isUnlimitedDayInvest) {\n', '            limit = maximalDepositFinish;\n', '            return limit;\n', '        }\n', '\n', '        uint nDay = getCurrentDay();\n', '\n', '        uint dayDepositLimit = getDayDepositLimit(nDay);\n', '\n', '        if (dayDepositLimit <= maximalDepositFinish)\n', '        {\n', '            limit = dayDepositLimit;\n', '        }\n', '        else\n', '        {\n', '            limit = maximalDepositFinish;\n', '        }\n', '\n', '    }\n', '\n', '    function calcProgress(uint start, uint proc, uint nDay) public pure returns(uint res)\n', '    {\n', '        uint s = start;\n', '\n', '        uint base = 1 ether;\n', '\n', '        if (proc == 1)\n', '        {\n', '            s = s + base.mul(nDay.mul(nDay).mul(35).div(10000)) + base.mul(nDay.mul(4589).div(10000));\n', '        }\n', '        else\n', '        {\n', '            s = s + base.mul(nDay.mul(nDay).mul(141).div(10000)) + base.mul(nDay.mul(8960).div(10000));\n', '        }\n', '\n', '        return s;\n', '    }\n', '\n', '    function getDayDepositLimit(uint nDay) public pure returns(uint limit)\n', '    {\n', '        return calcProgress(dayLimitStart, dayLimitProgressProc, nDay );\n', '    }\n', '\n', '    function getMaximalDeposit(uint nDay) public pure returns(uint limit)\n', '    {\n', '        return calcProgress(maximalDepositStart, maxDepositProgressProc, nDay );\n', '    }\n', '\n', '    function getCurrentDayRestDepositLimit() public view returns(uint restLimit)\n', '    {\n', '        uint nDay = getCurrentDay();\n', '\n', '        restLimit = getDayRestDepositLimit(nDay);\n', '    }\n', '\n', '    function getDayRestDepositLimit(uint nDay) public view returns(uint restLimit)\n', '    {\n', '        restLimit = getCurrentDayDepositLimit().sub(usedDeposit[nDay]);\n', '    }\n', '\n', '    function getCurrentMaximalDeposit() public view returns(uint maximalDeposit)\n', '    {\n', '        uint nDay = getCurrentDay();\n', '\n', '        if (isUnlimitedContractInvest)\n', '        {\n', '            maximalDeposit = 0;\n', '        }\n', '        else\n', '        {\n', '            maximalDeposit = getMaximalDeposit(nDay);\n', '        }\n', '    }\n', '\n', '    function() external payable\n', '    {\n', '        emit LogInvestment(msg.sender, msg.value, msg.data);\n', '        processPayment(msg.value, msg.data);\n', '    }\n', '\n', '    function processPayment(uint moneyValue, bytes refData) private\n', '    {\n', '        if (msg.sender == laxmi)\n', '        {\n', '            totalSelfInvest = totalSelfInvest.add(moneyValue);\n', '            emit LogSelfInvestment(moneyValue);\n', '            return;\n', '        }\n', '\n', '        if (moneyValue == 0)\n', '        {\n', '            preparePayment();\n', '            return;\n', '        }\n', '\n', '        if (moneyValue < minimalDeposit)\n', '        {\n', '            totalPenalty = totalPenalty.add(moneyValue);\n', '            emit LogMinimalDepositPayment(msg.sender, moneyValue, totalPenalty);\n', '\n', '            return;\n', '        }\n', '\n', '        checkLimits(moneyValue);\n', '\n', '        address referrer = bytesToAddress(refData);\n', '\n', '        if (user[msg.sender].balance > 0 ||\n', '        refData.length != 20 ||\n', '        (!isUnlimitedContractInvest && moneyValue > getCurrentMaximalDeposit()) ||\n', '        referrer != laxmi &&\n', '        (\n', '        user[referrer].balance <= 0 ||\n', '        referrer == msg.sender)\n', '        )\n', '        {\n', '            uint amount = moneyValue.mul(procReturn).div(procKoef);\n', '\n', '            totalPenalty = totalPenalty.add(moneyValue.sub(amount));\n', '\n', '            emit LogPenaltyPayment(msg.sender, user[msg.sender].balance, refData.length, referrer, user[referrer].balance, moneyValue, amount, totalPenalty);\n', '\n', '            msg.sender.transfer(amount);\n', '\n', '            return;\n', '        }\n', '\n', '\n', '\n', '        uint nDay = getCurrentDay();\n', '\n', '        uint restDepositPerDay = getDayRestDepositLimit(nDay);\n', '\n', '        uint addDeposit = moneyValue;\n', '\n', '\n', '        if (!isUnlimitedDayInvest && moneyValue > restDepositPerDay)\n', '        {\n', '            uint returnDeposit = moneyValue.sub(restDepositPerDay);\n', '\n', '            uint returnAmount = returnDeposit.mul(procReturn).div(procKoef);\n', '\n', '            addDeposit = addDeposit.sub(returnDeposit);\n', '\n', '            totalPenalty = totalPenalty.add(returnDeposit.sub(returnAmount));\n', '\n', '            emit LogExceededRestDepositPerDay(msg.sender, referrer, moneyValue, nDay, restDepositPerDay, returnDeposit, returnAmount, totalPenalty, addDeposit);\n', '\n', '            msg.sender.transfer(returnAmount);\n', '        }\n', '\n', '        usedDeposit[nDay] = usedDeposit[nDay].add(addDeposit);\n', '\n', '        emit LogUsedRestDepositPerDay(msg.sender, referrer, moneyValue, nDay, restDepositPerDay, addDeposit, usedDeposit[nDay]);\n', '\n', '\n', '        registerInvestor(referrer);\n', '        sendOwnerFee(addDeposit);\n', '        calcBonusReferrers(referrer, addDeposit);\n', '        updateInvestBalance(addDeposit);\n', '    }\n', '\n', '\n', '    function registerInvestor(address referrer) private\n', '    {\n', '        user[msg.sender].timestamp = now;\n', '        countInvestors++;\n', '\n', '        user[msg.sender].referrer = referrer;\n', '        user[referrer].countReferrals++;\n', '    }\n', '\n', '    function sendOwnerFee(uint addDeposit) private\n', '    {\n', '        transfer(laxmi, addDeposit.mul(ownerFee).div(procKoef));\n', '    }\n', '\n', '    function calcBonusReferrers(address referrer, uint addDeposit) private\n', '    {\n', '        address r = referrer;\n', '\n', '        for (uint i = 0; i < bonusReferrer.length && r != 0; i++)\n', '        {\n', '            uint amountReferrer = addDeposit.mul(bonusReferrer[i]).div(procKoef);\n', '\n', '            address nextReferrer = user[r].referrer;\n', '\n', '            emit LogCalcBonusReferrer(r, addDeposit, i, bonusReferrer[i], amountReferrer, nextReferrer);\n', '\n', '            preparePaymentReferrer(r, amountReferrer);\n', '\n', '            r = nextReferrer;\n', '        }\n', '    }\n', '\n', '    function checkLimits(uint value) private\n', '    {\n', '        if (totalInvest + value > unlimitedInvest)\n', '        {\n', '            isUnlimitedContractInvest = true;\n', '        }\n', '\n', '        uint nDay = getCurrentDay();\n', '\n', '        uint dayDepositLimit = getDayDepositLimit(nDay);\n', '\n', '        if (dayDepositLimit > maximalDepositFinish)\n', '        {\n', '            isUnlimitedDayInvest = true;\n', '        }\n', '\n', '    }\n', '\n', '    function preparePaymentReferrer(address referrer, uint amountReferrer) private\n', '    {\n', '        user[referrer].earnOnReferrals = user[referrer].earnOnReferrals.add(amountReferrer);\n', '\n', '        uint totalReferrals = user[referrer].earnOnReferrals;\n', '        uint paidReferrals = user[referrer].paidReferrals;\n', '\n', '\n', '        if (totalReferrals >= paidReferrals.add(minimalDepositForBonusReferrer))\n', '        {\n', '            uint amount = totalReferrals.sub(paidReferrals);\n', '\n', '            user[referrer].paidReferrals = user[referrer].paidReferrals.add(amount);\n', '\n', '            emit LogPreparePaymentReferrer(referrer, totalReferrals, paidReferrals, amount);\n', '\n', '            transfer(referrer, amount);\n', '        }\n', '        else\n', '        {\n', '            emit LogSkipPreparePaymentReferrer(referrer, totalReferrals, paidReferrals);\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function preparePayment() public\n', '    {\n', '        uint totalInteres = getInteres(msg.sender);\n', '        uint paidInteres = user[msg.sender].paidInteres;\n', '        if (totalInteres > paidInteres)\n', '        {\n', '            uint amount = totalInteres.sub(paidInteres);\n', '\n', '            emit LogPreparePayment(msg.sender, totalInteres, paidInteres, amount);\n', '\n', '            user[msg.sender].paidInteres = user[msg.sender].paidInteres.add(amount);\n', '            transfer(msg.sender, amount);\n', '        }\n', '        else\n', '        {\n', '            emit LogSkipPreparePayment(msg.sender, totalInteres, paidInteres);\n', '        }\n', '    }\n', '\n', '    function updateInvestBalance(uint addDeposit) private\n', '    {\n', '        user[msg.sender].balance = user[msg.sender].balance.add(addDeposit);\n', '        totalInvest = totalInvest.add(addDeposit);\n', '    }\n', '\n', '    function transfer(address receiver, uint amount) private\n', '    {\n', '        if (amount > 0)\n', '        {\n', '            if (receiver != laxmi) { totalPaid = totalPaid.add(amount); }\n', '\n', '            uint balance = address(this).balance;\n', '\n', '            emit LogTransfer(receiver, amount, balance);\n', '\n', '            require(amount < balance, "Not enough balance. Please retry later.");\n', '\n', '            receiver.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function bytesToAddress(bytes source) private pure returns(address addr)\n', '    {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function getTotals() public view returns(uint _maxDepositDays,\n', '        uint _perDay,\n', '        uint _startTimestamp,\n', '\n', '        uint _minimalDeposit,\n', '        uint _maximalDeposit,\n', '        uint[1] _bonusReferrer,\n', '        uint _minimalDepositForBonusReferrer,\n', '        uint _ownerFee,\n', '\n', '        uint _countInvestors,\n', '        uint _totalInvest,\n', '        uint _totalPenalty,\n', '    //                                             uint _totalSelfInvest,\n', '        uint _totalPaid,\n', '\n', '        uint _currentDayDepositLimit,\n', '        uint _currentDayRestDepositLimit)\n', '    {\n', '        return (\n', '        maxDepositDays,\n', '        perDay,\n', '        startTimestamp,\n', '\n', '        minimalDeposit,\n', '        getCurrentMaximalDeposit(),\n', '        bonusReferrer,\n', '        minimalDepositForBonusReferrer,\n', '        ownerFee,\n', '\n', '        countInvestors,\n', '        totalInvest,\n', '        totalPenalty,\n', '        //                 totalSelfInvest,\n', '        totalPaid,\n', '\n', '        getCurrentDayDepositLimit(),\n', '        getCurrentDayRestDepositLimit()\n', '        );\n', '    }\n', '\n', '}']