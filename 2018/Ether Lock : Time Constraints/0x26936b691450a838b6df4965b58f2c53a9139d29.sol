['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' *\n', ' *  https://fairdapp.com/bankfomo/  https://fairdapp.com/bankfomo/   https://fairdapp.com/bankfomo/\n', ' *   \n', ' *       _______     _       ______  _______ ______ ______  \n', ' *      (_______)   (_)     (______)(_______|_____ (_____ \\ \n', ' *       _____ _____ _  ____ _     _ _______ _____) )____) )\n', ' *      |  ___|____ | |/ ___) |   | |  ___  |  ____/  ____/ \n', ' *      | |   / ___ | | |   | |__/ /| |   | | |    | |      \n', ' *      |_|   \\_____|_|_|   |_____/ |_|   |_|_|    |_|      \n', ' *                                                     \n', ' *               ______              _                              \n', ' *              (____  \\            | |                             \n', ' *               ____)  )_____ ____ | |  _                          \n', ' *              |  __  ((____ |  _ \\| |_/ )                         \n', ' *              | |__)  ) ___ | | | |  _ (                          \n', ' *              |______/\\_____|_| |_|_| \\_)                         \n', ' *                                                    \n', ' * \t\t\t\t  _______                \n', ' * \t\t\t\t (_______)               \n', ' * \t\t\t\t  _____ ___  ____   ___  \n', ' * \t\t\t\t |  ___) _ \\|    \\ / _ \\ \n', ' * \t\t\t\t | |  | |_| | | | | |_| |\n', ' * \t\t\t\t |_|   \\___/|_|_|_|\\___/\n', ' *   \n', ' *  Warning:\n', ' *     \n', ' *  FairDAPP – Bank Fomo is a re-release of the original game FairDAPP - Bank Simulator.\n', ' *  This version ties into the FairExchange and has about 3x more aggressive scaling. \n', ' *  This contract may only be used internally for study purposes and all could be \n', ' *  lost by sending anything to this contract address. \n', ' *  All users are prohibited to interact with this contract if this \n', ' *  contract is in conflict with user’s local regulations or laws.\n', ' * \n', ' *  -Original Contract built by the FairDAPP Community\n', ' *  -Code Audited by 8Bit & Etherguy (formula calculations are excluded from the audit)\n', ' *  \n', ' *  -The resetTime and reduceTime functions have an on and off switch which the developer owner can control.\n', ' *  -No one can change anything else once the contract has been deployed.\n', ' *  \n', ' *  -The contract is fully solvent in any event (assuming there are no bugs).\n', ' *  -ie. The contract will always payout what it owes. \n', ' *\n', '**/\n', '\n', '\n', 'contract ERC721{\n', '    \n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function takeOwnership(uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    \n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '}\n', '\n', 'contract FairBankFomo is ERC721{\n', '    using SafeMath for uint256;\n', '       \n', '    address public developerAddr = 0xbC817A495f0114755Da5305c5AA84fc5ca7ebaBd;\n', '    address public fairProfitContract = 0x53a39eeF083c4A91e36145176Cc9f52bE29B7288;\n', '\n', '    string public name = "FairDAPP - Bank Simulator - Fomo";\n', '    string public symbol = "FBankFomo";\n', '    \n', '    uint256 public stageDuration = 3600;\n', '    uint256 public standardProtectRatio = 57;\n', '    bool public modifyCountdown = false;\n', '    uint256 public startTime = 1539997200;\n', '    uint256 public cardTime = 1539993600;\n', '    \n', '    uint256 public rId = 1;\n', '    uint256 public sId = 1;\n', '    \n', '    mapping (uint256 => FBankdatasets.Round) public round;\n', '    mapping (uint256 => mapping (uint256 => FBankdatasets.Stage)) public stage;\n', '    \n', '    mapping (address => bool) public player;\n', '    mapping (address => uint256[]) public playerGoodsList;\n', '    mapping (address => uint256[]) public playerWithdrawList;\n', '    \n', '    /**\n', '     * Anti clone protection.\n', '     * Do not clone this contract without permission even if you manage to break the conceal. \n', '     * The concealed code contains core calculations necessary for this contract to function, read line 1058. \n', '     * This contract can be licensed for a fee, contact us instead of cloning!\n', '     */ \n', '    FairBankCompute constant private bankCompute = FairBankCompute(0xdd033Ff7e98792694F6b358DaEB065d4FF01Bd5A);\n', '    \n', '    FBankdatasets.Goods[] public goodsList;\n', '    \n', '    FBankdatasets.Card[6] public cardList;\n', '    mapping (uint256 => address) public cardIndexToApproved;\n', '    \n', '    modifier isDeveloperAddr() {\n', '        require(msg.sender == developerAddr, "Permission denied");\n', '        _;\n', '    }\n', '    \n', '    modifier startTimeVerify() {\n', '        require(now >= startTime); \n', '        _;\n', '    }\n', '    \n', '    modifier cardTimeVerify() {\n', '        require(now >= cardTime); \n', '        _;\n', '    }\n', '    \n', '    modifier modifyCountdownVerify() {\n', '        require(modifyCountdown == true, "this feature is not turned on or has been turned off"); \n', '        require(now >= stage[rId][sId].start, "Can only use the addtime/reduce time functions when game has started");  \n', '        _;\n', '    }\n', '     \n', '    modifier senderVerify() {\n', '        require (msg.sender == tx.origin, "sender does not meet the rules");\n', '        if(!player[msg.sender])\n', '            player[msg.sender] = true;\n', '        _;\n', '    }\n', '    \n', '    /**\n', "     * Don't toy or spam the contract, it may raise the gas cost for everyone else.\n", '     * The scientists will take anything below 0.001 ETH sent to the contract.\n', '     * Also added antiwhale settings. \t \n', '     * Thank you for your donation.\n', '     */\n', '    modifier buyVerify() {\n', '          \n', '        if(msg.value < 1000000000000000){\n', '            developerAddr.send(msg.value);\n', '        }else{\n', '            require(msg.value >= 1000000000000000, "minimum amount is 0.001 ether");\n', '            \n', '            if(sId < 25)\n', '                require(tx.gasprice <= 25000000000);\n', '                \n', '            if(sId < 25)\n', '                require(msg.value <= 10 ether);\n', '         _;\n', '        }\n', '    }\n', '    \n', '    modifier withdrawVerify() {\n', '        require(playerGoodsList[msg.sender].length > 0, "user has not purchased the product or has completed the withdrawal");\n', '        _;\n', '    }\n', '    \n', '    modifier stepSizeVerify(uint256 _stepSize) {\n', '        require(_stepSize <= 1000000, "step size must not exceed 1000000");\n', '        _;\n', '    }\n', '    \n', '    constructor()\n', '        public\n', '    {\n', '        round[rId].start = startTime;\n', '        stage[rId][sId].start = startTime;\n', '        uint256 i;\n', '        while(i < cardList.length){\n', '            cardList[i].playerAddress = fairProfitContract;\n', '            cardList[i].amount = 1 ether; \n', '            i++;\n', '        }\n', '    }\n', '    \n', '    function openModifyCountdown()\n', '        senderVerify()\n', '        isDeveloperAddr()\n', '        public\n', '    {\n', '        require(modifyCountdown == false, "Time service is already open");\n', '        \n', '        modifyCountdown = true;\n', '        \n', '    }\n', '    \n', '    function closeModifyCountdown()\n', '        senderVerify()\n', '        isDeveloperAddr()\n', '        public\n', '    {\n', '        require(modifyCountdown == true, "Time service is already open");\n', '        \n', '        modifyCountdown = false;\n', '        \n', '    }\n', '    \n', '    function purchaseCard(uint256 _cId)\n', '        cardTimeVerify()\n', '        senderVerify()\n', '        payable\n', '        public\n', '    {\n', '        \n', '        address _player = msg.sender;\n', '        uint256 _amount = msg.value;\n', '        uint256 _purchasePrice = cardList[_cId].amount.mul(110) / 100;\n', '        \n', '        require(\n', '            cardList[_cId].playerAddress != address(0) \n', '            && cardList[_cId].playerAddress != _player \n', '            && _amount >= _purchasePrice, \n', '            "Failed purchase"\n', '        );\n', '        \n', '        if(cardIndexToApproved[_cId] != address(0)){\n', '            cardIndexToApproved[_cId].send(\n', '                cardList[_cId].amount.mul(105) / 100\n', '                );\n', '            delete cardIndexToApproved[_cId];\n', '        }else\n', '            cardList[_cId].playerAddress.send(\n', '                cardList[_cId].amount.mul(105) / 100\n', '                );\n', '        \n', '        fairProfitContract.send(cardList[_cId].amount.mul(5) / 100);\n', '        if(_amount > _purchasePrice)\n', '            _player.send(_amount.sub(_purchasePrice));\n', '            \n', '        cardList[_cId].amount = _purchasePrice;\n', '        cardList[_cId].playerAddress = _player;\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function()\n', '        startTimeVerify()\n', '        senderVerify()\n', '        buyVerify()\n', '        payable\n', '        public\n', '    {\n', '        buyAnalysis(100, standardProtectRatio);\n', '    }\n', '\n', '    function buy(uint256 _stepSize, uint256 _protectRatio)\n', '        startTimeVerify()\n', '        senderVerify()\n', '        buyVerify()\n', '        stepSizeVerify(_stepSize)\n', '        public\n', '        payable\n', '    {\n', '        buyAnalysis(\n', '            _stepSize <= 0 ? 100 : _stepSize, \n', '            _protectRatio <= 100 ? _protectRatio : standardProtectRatio\n', '            );\n', '    }\n', '    \n', '    /**\n', '     * Standard withdraw function.\n', '     */\n', '    function withdraw()\n', '        startTimeVerify()\n', '        senderVerify()\n', '        withdrawVerify()\n', '        public\n', '    {\n', '        \n', '        address _player = msg.sender;\n', '        uint256[] memory _playerGoodsList = playerGoodsList[_player];\n', '        uint256 length = _playerGoodsList.length;\n', '        uint256 _totalAmount;\n', '        uint256 _amount;\n', '        uint256 _withdrawSid;\n', '        uint256 _reachAmount;\n', '        bool _finish;\n', '        uint256 i;\n', '        \n', '        delete playerGoodsList[_player];\n', '        while(i < length){\n', '            \n', '            (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_playerGoodsList[i]);\n', '            \n', '            if(_finish == true){\n', '                playerWithdrawList[_player].push(_playerGoodsList[i]);\n', '            }else{\n', '                goodsList[_playerGoodsList[i]].withdrawSid = _withdrawSid;\n', '                goodsList[_playerGoodsList[i]].reachAmount = _reachAmount;\n', '                playerGoodsList[_player].push(_playerGoodsList[i]);\n', '            }\n', '            \n', '            _totalAmount = _totalAmount.add(_amount);\n', '            i++;\n', '        }\n', '        _player.transfer(_totalAmount);\n', '    }\n', '     \n', '     /**\n', '     * Backup withdraw function in case gas is too high to use standard withdraw.\n', '     */\n', '    function withdrawByGid(uint256 _gId)\n', '        startTimeVerify()\n', '        senderVerify()\n', '        withdrawVerify()\n', '        public\n', '    {\n', '        address _player = msg.sender;\n', '        uint256 _amount;\n', '        uint256 _withdrawSid;\n', '        uint256 _reachAmount;\n', '        bool _finish;\n', '        \n', '        (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_gId);\n', '            \n', '        if(_finish == true){\n', '            \n', '            for(uint256 i = 0; i < playerGoodsList[_player].length; i++){\n', '                if(playerGoodsList[_player][i] == _gId)\n', '                    break;\n', '            }\n', '            require(i < playerGoodsList[_player].length, "gid is wrong");\n', '            \n', '            playerWithdrawList[_player].push(_gId);\n', '            playerGoodsList[_player][i] = playerGoodsList[_player][playerGoodsList[_player].length - 1];\n', '            playerGoodsList[_player].length--;\n', '        }else{\n', '            goodsList[_gId].withdrawSid = _withdrawSid;\n', '            goodsList[_gId].reachAmount = _reachAmount;\n', '        }\n', '        \n', '        _player.transfer(_amount);\n', '    }\n', '    \n', '    function resetTime()\n', '        modifyCountdownVerify()\n', '        senderVerify()\n', '        public\n', '        payable\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount = msg.value;\n', '        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\n', '        uint256 _targetAmount = \n', '            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \n', '            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\n', '            _targetAmount = _targetAmount.mul(100) / 88;\n', '        uint256 _costAmount = _targetAmount.mul(20) / 100;\n', '        \n', '        if(_costAmount > 3 ether)\n', '            _costAmount = 3 ether;\n', '        require(_amount >= _costAmount, "Not enough price");\n', '        \n', '        stage[_rId][_sId].start = now;\n', '        \n', '        cardList[5].playerAddress.send(_costAmount / 2);\n', '        developerAddr.send(_costAmount / 2);\n', '        \n', '        if(_amount > _costAmount)\n', '            msg.sender.send(_amount.sub(_costAmount));\n', '        \n', '    }\n', '    \n', '    function reduceTime()\n', '        modifyCountdownVerify()\n', '        senderVerify()\n', '        public\n', '        payable\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount = msg.value;\n', '        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\n', '        uint256 _targetAmount = \n', '            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?\n', '            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\n', '            _targetAmount = _targetAmount.mul(100) / 88;\n', '        uint256 _costAmount = _targetAmount.mul(30) / 100;\n', '        \n', '        if(_costAmount > 3 ether)\n', '            _costAmount = 3 ether;\n', '        require(_amount >= _costAmount, "Not enough price");\n', '        \n', '        stage[_rId][_sId].start = now - stageDuration + 900;\n', '        \n', '        cardList[5].playerAddress.send(_costAmount / 2);\n', '        developerAddr.send(_costAmount / 2);\n', '        \n', '        if(_amount > _costAmount)\n', '            msg.sender.send(_amount.sub(_costAmount));\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Core logic to analyse buy behaviour. \n', '     */\n', '    function buyAnalysis(uint256 _stepSize, uint256 _protectRatio)\n', '        private\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\n', '        uint256 _targetAmount = \n', '            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \n', '            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\n', '            _targetAmount = _targetAmount.mul(100) / 88;\n', '        uint256 _stageTargetBalance = \n', '            stage[_rId][_sId].amount > 0 ? \n', '            _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;\n', '        \n', '        if(now > stage[_rId][_sId].start.add(stageDuration) \n', '            && _targetAmount > stage[_rId][_sId].amount\n', '        ){\n', '            \n', '            endRound(_rId, _sId);\n', '            \n', '            _rId = rId;\n', '            _sId = sId;\n', '            stage[_rId][_sId].start = now;\n', '            \n', '            _targetExpectedAmount = getStageTargetAmount(_sId);\n', '            _targetAmount = \n', '                stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \n', '                _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\n', '            _targetAmount = _targetAmount.mul(100) / 88;\n', '            _stageTargetBalance = \n', '                stage[_rId][_sId].amount > 0 ? \n', '                _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;\n', '        }\n', '        if(_stageTargetBalance > msg.value)\n', '            buyDataRecord(\n', '                _rId, \n', '                _sId, \n', '                _targetAmount, \n', '                msg.value, \n', '                _stepSize, \n', '                _protectRatio\n', '                );\n', '        else\n', '            multiStake(\n', '                msg.value, \n', '                _stepSize, \n', '                _protectRatio, \n', '                _targetAmount, \n', '                _stageTargetBalance\n', '                );\n', '        /* This is a backstop check to ensure that the contract will always be solvent.\n', '        It would reject any stakes with a protection ratio that the contract may not be able to repay.\n', '        This backstop should never be needed under current settings. */\n', '        require(\n', '            (\n', '                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\n', '                .sub(round[_rId].protectAmount)\n', '                .sub(round[_rId].dividendAmount)\n', '            ) > 0, "data error"\n', '        );    \n', '        bankerFeeDataRecord(msg.value, _protectRatio);    \n', '    }\n', '    \n', '    function multiStake(uint256 _amount, uint256 _stepSize, uint256 _protectRatio, uint256 _targetAmount, uint256 _stageTargetBalance)\n', '        private\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _crossStageNum = 1;\n', '        uint256 _protectTotalAmount;\n', '        uint256 _dividendTotalAmount;\n', '            \n', '        while(true){\n', '\n', '            if(_crossStageNum == 1){\n', '                playerDataRecord(\n', '                    _rId, \n', '                    _sId, \n', '                    _amount, \n', '                    _stageTargetBalance, \n', '                    _stepSize, \n', '                    _protectRatio, \n', '                    _crossStageNum\n', '                    );\n', '                round[_rId].amount = round[_rId].amount.add(_amount);\n', '                round[_rId].protectAmount = round[_rId].protectAmount.add(\n', '                    _amount.mul(_protectRatio.mul(88)) / 10000);    \n', '            }\n', '                \n', '            buyStageDataRecord(\n', '                _rId, \n', '                _sId, \n', '                _targetAmount, \n', '                _stageTargetBalance, \n', '                _sId.\n', '                add(_stepSize), \n', '                _protectRatio\n', '                );\n', '            _dividendTotalAmount = _dividendTotalAmount.add(stage[_rId][_sId].dividendAmount);\n', '            _protectTotalAmount = _protectTotalAmount.add(stage[_rId][_sId].protectAmount);\n', '            \n', '            _sId++;\n', '            _amount = _amount.sub(_stageTargetBalance);\n', '            _targetAmount = \n', '                stage[_rId][_sId].dividendAmount <= getStageTargetAmount(_sId) ? \n', '                getStageTargetAmount(_sId) : stage[_rId][_sId].dividendAmount;\n', '            _targetAmount = _targetAmount.mul(100) / 88;\n', '            _stageTargetBalance = _targetAmount;\n', '            _crossStageNum++;\n', '            if(_stageTargetBalance >= _amount){\n', '                buyStageDataRecord(\n', '                    _rId, \n', '                    _sId, \n', '                    _targetAmount, \n', '                    _amount, \n', '                    _sId.add(_stepSize), \n', '                    _protectRatio\n', '                    );\n', '                playerDataRecord(\n', '                    _rId, \n', '                    _sId, \n', '                    0, \n', '                    _amount, \n', '                    _stepSize, \n', '                    _protectRatio, \n', '                    _crossStageNum\n', '                    );\n', '                    \n', '                if(_targetAmount == _amount)\n', '                    _sId++;\n', '                    \n', '                stage[_rId][_sId].start = now;\n', '                sId = _sId;\n', '                \n', '                round[_rId].protectAmount = round[_rId].protectAmount.sub(_protectTotalAmount);\n', '                round[_rId].dividendAmount = round[_rId].dividendAmount.add(_dividendTotalAmount);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Records all data.\n', '     */\n', '    function buyDataRecord(uint256 _rId, uint256 _sId, uint256 _targetAmount, uint256 _amount, uint256 _stepSize, uint256 _protectRatio)\n', '        private\n', '    {\n', '        uint256 _expectEndSid = _sId.add(_stepSize);\n', '        uint256 _protectAmount = _amount.mul(_protectRatio.mul(88)) / 10000;\n', '        \n', '        round[_rId].amount = round[_rId].amount.add(_amount);\n', '        round[_rId].protectAmount = round[_rId].protectAmount.add(_protectAmount);\n', '        \n', '        stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\n', '        stage[_rId][_expectEndSid].protectAmount = stage[_rId][_expectEndSid].protectAmount.add(_protectAmount);\n', '        stage[_rId][_expectEndSid].dividendAmount = \n', '            stage[_rId][_expectEndSid].dividendAmount.add(\n', '                computeEarningsAmount(_sId, \n', '                _amount, \n', '                _targetAmount, \n', '                _expectEndSid, \n', '                100 - _protectRatio\n', '                )\n', '                );\n', '                \n', '        FBankdatasets.Goods memory _goods;\n', '        _goods.rId = _rId;\n', '        _goods.startSid = _sId;\n', '        _goods.amount = _amount;\n', '        _goods.endSid = _expectEndSid;\n', '        _goods.protectRatio = _protectRatio;\n', '        playerGoodsList[msg.sender].push(goodsList.push(_goods) - 1);\n', '    }\n', '    \n', '    /**\n', '     * Records the stage data.\n', '     */\n', '    function buyStageDataRecord(uint256 _rId, uint256 _sId, uint256 _targetAmount, uint256 _amount, uint256 _expectEndSid, uint256 _protectRatio)\n', '        private\n', '    {\n', '        uint256 _protectAmount = _amount.mul(_protectRatio.mul(88)) / 10000;\n', '        \n', '        if(_targetAmount != _amount)\n', '            stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\n', '        stage[_rId][_expectEndSid].protectAmount = stage[_rId][_expectEndSid].protectAmount.add(_protectAmount);\n', '        stage[_rId][_expectEndSid].dividendAmount = \n', '            stage[_rId][_expectEndSid].dividendAmount.add(\n', '                computeEarningsAmount(\n', '                    _sId, \n', '                    _amount, \n', '                    _targetAmount, \n', '                    _expectEndSid, \n', '                    100 - _protectRatio\n', '                    )\n', '                );\n', '    }\n', '    \n', '    /**\n', '     * Records the player data.\n', '     */\n', '    function playerDataRecord(uint256 _rId, uint256 _sId, uint256 _totalAmount, uint256 _stageBuyAmount, uint256 _stepSize, uint256 _protectRatio, uint256 _crossStageNum)\n', '        private\n', '    {    \n', '        if(_crossStageNum <= 1){\n', '            FBankdatasets.Goods memory _goods;\n', '            _goods.rId = _rId;\n', '            _goods.startSid = _sId;\n', '            _goods.amount = _totalAmount;\n', '            _goods.stepSize = _stepSize;\n', '            _goods.protectRatio = _protectRatio;\n', '            if(_crossStageNum == 1)\n', '                _goods.startAmount = _stageBuyAmount;\n', '            playerGoodsList[msg.sender].push(goodsList.push(_goods) - 1);\n', '        }\n', '        else{\n', '            uint256 _goodsIndex = goodsList.length - 1;\n', '            goodsList[_goodsIndex].endAmount = _stageBuyAmount;\n', '            goodsList[_goodsIndex].endSid = _sId;\n', '        }\n', '        \n', '    }\n', '    \n', '    function bankerFeeDataRecord(uint256 _amount, uint256 _protectRatio)\n', '        private\n', '    {\n', '        round[rId].jackpotAmount = round[rId].jackpotAmount.add(_amount.mul(9).div(100));\n', '\n', '        uint256 _cardAmount = _amount / 100;\n', '        if(_protectRatio == 0)\n', '            cardList[0].playerAddress.send(_cardAmount);\n', '        else if(_protectRatio > 0 && _protectRatio < 57)\n', '            cardList[1].playerAddress.send(_cardAmount);   \n', '        else if(_protectRatio == 57)\n', '            cardList[2].playerAddress.send(_cardAmount);   \n', '        else if(_protectRatio > 57 && _protectRatio < 100)\n', '            cardList[3].playerAddress.send(_cardAmount);   \n', '        else if(_protectRatio == 100)\n', '            cardList[4].playerAddress.send(_cardAmount);   \n', '        \n', '        fairProfitContract.send(_amount.div(50));\n', '    }\n', '    \n', '    function endRound(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        round[_rId].end = now;\n', '        round[_rId].ended = true;\n', '        round[_rId].endSid = _sId;\n', '        \n', '        if(stage[_rId][_sId].amount > 0)\n', '            round[_rId + 1].jackpotAmount = (\n', '                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\n', '                .sub(round[_rId].protectAmount)\n', '                .sub(round[_rId].dividendAmount)\n', '            ).mul(20).div(100);\n', '        else\n', '            round[_rId + 1].jackpotAmount = (\n', '                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\n', '                .sub(round[_rId].protectAmount)\n', '                .sub(round[_rId].dividendAmount)\n', '            );\n', '        \n', '        round[_rId + 1].start = now;\n', '        rId++;\n', '        sId = 1;\n', '    }\n', '    \n', '    function getStageTargetAmount(uint256 _sId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return bankCompute.getStageTargetAmount(_sId);\n', '    }\n', '    \n', '    function computeEarningsAmount(uint256 _sId, uint256 _amount, uint256 _currentTargetAmount, uint256 _expectEndSid, uint256 _ratio)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return bankCompute.computeEarningsAmount(_sId, _amount, _currentTargetAmount, _expectEndSid, _ratio);\n', '    }\n', '    \n', '    function getEarningsAmountByGoodsIndex(uint256 _goodsIndex)\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256, bool)\n', '    {\n', '        FBankdatasets.Goods memory _goods = goodsList[_goodsIndex];\n', '        uint256 _sId = sId;\n', '        uint256 _amount;\n', '        uint256 _targetExpectedAmount;\n', '        uint256 _targetAmount;\n', '        if(_goods.stepSize == 0){\n', '            if(round[_goods.rId].ended == true){\n', '                if(round[_goods.rId].endSid > _goods.endSid){\n', '                    _targetExpectedAmount = getStageTargetAmount(_goods.startSid);\n', '                    _targetAmount = \n', '                        stage[_goods.rId][_goods.startSid].dividendAmount <= _targetExpectedAmount ? \n', '                        _targetExpectedAmount : stage[_goods.rId][_goods.startSid].dividendAmount;\n', '                    _targetAmount = _targetAmount.mul(100) / 88;\n', '                    _amount = computeEarningsAmount(\n', '                        _goods.startSid, \n', '                        _goods.amount, \n', '                        _targetAmount, \n', '                        _goods.endSid, \n', '                        100 - _goods.protectRatio\n', '                        );\n', '                    \n', '                }else\n', '                    _amount = _goods.amount.mul(_goods.protectRatio.mul(88)) / 10000;\n', '                    \n', '                if(round[_goods.rId].endSid == _goods.startSid)\n', '                    _amount = _amount.add(\n', '                        _goods.amount.mul(\n', '                            getRoundJackpot(_goods.rId)\n', '                            ).div(stage[_goods.rId][_goods.startSid].amount)\n', '                            );\n', '                \n', '                return (_amount, 0, 0, true);\n', '            }else{\n', '                if(_sId > _goods.endSid){\n', '                    _targetExpectedAmount = getStageTargetAmount(_goods.startSid);\n', '                    _targetAmount = \n', '                        stage[_goods.rId][_goods.startSid].dividendAmount <= _targetExpectedAmount ?\n', '                        _targetExpectedAmount : stage[_goods.rId][_goods.startSid].dividendAmount;\n', '                    _targetAmount = _targetAmount.mul(100) / 88;\n', '                    _amount = computeEarningsAmount(\n', '                        _goods.startSid, \n', '                        _goods.amount, \n', '                        _targetAmount, \n', '                        _goods.endSid, \n', '                        100 - _goods.protectRatio\n', '                        );\n', '                }else\n', '                    return (0, 0, 0, false);\n', '            }\n', '            return (_amount, 0, 0, true);\n', '            \n', '        }else{\n', '            \n', '            uint256 _startSid = _goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid;\n', '            uint256 _ratio = 100 - _goods.protectRatio;\n', '            uint256 _reachAmount = _goods.reachAmount;\n', '            if(round[_goods.rId].ended == true){\n', '                \n', '                while(true){\n', '                    \n', '                    if(_startSid - (_goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid) > 100){\n', '                        return (_amount, _startSid, _reachAmount, false);\n', '                    }\n', '                    \n', '                    if(round[_goods.rId].endSid > _startSid.add(_goods.stepSize)){\n', '                        _targetExpectedAmount = getStageTargetAmount(_startSid);\n', '                        _targetAmount = \n', '                            stage[_goods.rId][_startSid].dividendAmount <= _targetExpectedAmount ? \n', '                            _targetExpectedAmount : stage[_goods.rId][_startSid].dividendAmount;\n', '                        _targetAmount = _targetAmount.mul(100) / 88;\n', '                        if(_startSid == _goods.endSid){\n', '                            _amount = _amount.add(\n', '                                computeEarningsAmount(\n', '                                    _startSid, \n', '                                    _goods.endAmount, \n', '                                    _targetAmount, \n', '                                    _startSid.add(_goods.stepSize), \n', '                                    _ratio\n', '                                    )\n', '                                );\n', '                            return (_amount, _goods.endSid, 0, true);\n', '                        }\n', '                        _amount = _amount.add(\n', '                            computeEarningsAmount(\n', '                                _startSid, \n', '                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount, \n', '                                _targetAmount, \n', '                                _startSid.add(_goods.stepSize), \n', '                                _ratio\n', '                                )\n', '                            );\n', '                        _reachAmount = \n', '                            _reachAmount.add(\n', '                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount\n', '                            );\n', '                    }else{\n', '                        \n', '                        _amount = _amount.add(\n', '                            (_goods.amount.sub(_reachAmount))\n', '                            .mul(_goods.protectRatio.mul(88)) / 10000\n', '                            );\n', '                        \n', '                        if(round[_goods.rId].endSid == _goods.endSid)\n', '                            _amount = _amount.add(\n', '                                _goods.endAmount.mul(getRoundJackpot(_goods.rId))\n', '                                .div(stage[_goods.rId][_goods.endSid].amount)\n', '                                );\n', '                        \n', '                        return (_amount, _goods.endSid, 0, true);\n', '                    }\n', '                    \n', '                    _startSid++;\n', '                }\n', '                \n', '            }else{\n', '                while(true){\n', '                    \n', '                    if(_startSid - (_goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid) > 100){\n', '                        return (_amount, _startSid, _reachAmount, false);\n', '                    }\n', '                    \n', '                    if(_sId > _startSid.add(_goods.stepSize)){\n', '                        _targetExpectedAmount = getStageTargetAmount(_startSid);\n', '                        _targetAmount = \n', '                            stage[_goods.rId][_startSid].dividendAmount <= _targetExpectedAmount ? \n', '                            _targetExpectedAmount : stage[_goods.rId][_startSid].dividendAmount;\n', '                        _targetAmount = _targetAmount.mul(100) / 88;\n', '                        if(_startSid == _goods.endSid){\n', '                            _amount = _amount.add(\n', '                                computeEarningsAmount(\n', '                                    _startSid, \n', '                                    _goods.endAmount, \n', '                                    _targetAmount, \n', '                                    _startSid.add(_goods.stepSize), \n', '                                    _ratio\n', '                                    )\n', '                                );\n', '                            return (_amount, _goods.endSid, 0, true);\n', '                        }\n', '                        _amount = _amount.add(\n', '                            computeEarningsAmount(\n', '                                _startSid, \n', '                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount, \n', '                                _targetAmount, \n', '                                _startSid.add(_goods.stepSize), \n', '                                _ratio\n', '                                )\n', '                            );\n', '                        _reachAmount = \n', '                            _reachAmount.add(\n', '                                _startSid == _goods.startSid ? \n', '                                _goods.startAmount : _targetAmount\n', '                            );\n', '                    }else    \n', '                        return (_amount, _startSid, _reachAmount, false);\n', '                    \n', '                    _startSid++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getRoundJackpot(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (\n', '            (\n', '                round[_rId].jackpotAmount\n', '                .add(round[_rId].amount.mul(88) / 100))\n', '                .sub(round[_rId].protectAmount)\n', '                .sub(round[_rId].dividendAmount)\n', '            ).mul(80).div(100);\n', '    }\n', '    \n', '    function getHeadInfo()\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256)\n', '    {\n', '        uint256 _targetExpectedAmount = getStageTargetAmount(sId);\n', '        \n', '        return\n', '            (\n', '                rId,\n', '                sId,\n', '                startTime,\n', '                stage[rId][sId].start.add(stageDuration),\n', '                stage[rId][sId].amount,\n', '                (\n', '                    stage[rId][sId].dividendAmount <= _targetExpectedAmount ? \n', '                    _targetExpectedAmount : stage[rId][sId].dividendAmount\n', '                ).mul(100) / 88,\n', '                round[rId].jackpotAmount.add(round[rId].amount.mul(88) / 100)\n', '                .sub(round[rId].protectAmount)\n', '                .sub(round[rId].dividendAmount)\n', '            );\n', '    }\n', '    \n', '    function getPlayerGoodList(address _player)\n', '        public\n', '        view\n', '        returns(uint256[])\n', '    {\n', '        return playerGoodsList[_player];\n', '    }\n', '\n', '    function totalSupply() \n', '        public \n', '        view \n', '        returns (uint256 total)\n', '    {\n', '        return cardList.length;\n', '    }\n', '    \n', '    function balanceOf(address _owner) \n', '        public \n', '        view \n', '        returns (uint256 balance)\n', '    {\n', '        uint256 _length = cardList.length;\n', '        uint256 _count;\n', '        for(uint256 i = 0; i < _length; i++){\n', '            if(cardList[i].playerAddress == _owner)\n', '                _count++;\n', '        }\n', '        \n', '        return _count;\n', '    }\n', '    \n', '    function ownerOf(uint256 _tokenId) \n', '        public \n', '        view \n', '        returns (address owner)\n', '    {\n', '        require(cardList.length > _tokenId, "tokenId error");\n', '        owner = cardList[_tokenId].playerAddress;\n', '        require(owner != address(0), "No owner");\n', '    }\n', '    \n', '    function approve(address _to, uint256 _tokenId)\n', '        senderVerify()\n', '        public\n', '    {\n', '        require (player[_to], "Not a registered user");\n', '        require (msg.sender == cardList[_tokenId].playerAddress, "The card does not belong to you");\n', '        require (cardList.length > _tokenId, "tokenId error");\n', '        require (cardIndexToApproved[_tokenId] == address(0), "Approved");\n', '        \n', '        cardIndexToApproved[_tokenId] = _to;\n', '        \n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function takeOwnership(uint256 _tokenId)\n', '        senderVerify()\n', '        public\n', '    {\n', '        address _newOwner = msg.sender;\n', '        address _oldOwner = cardList[_tokenId].playerAddress;\n', '        \n', '        require(_newOwner != address(0), "Address error");\n', '        require(_newOwner == cardIndexToApproved[_tokenId], "Without permission");\n', '        \n', '        cardList[_tokenId].playerAddress = _newOwner;\n', '        delete cardIndexToApproved[_tokenId];\n', '        \n', '        emit Transfer(_oldOwner, _newOwner, _tokenId);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _tokenId) \n', '        senderVerify()\n', '        public\n', '    {\n', '        require (msg.sender == cardList[_tokenId].playerAddress, "The card does not belong to you");\n', '        require(_to != address(0), "Address error");\n', '        require(_to == cardIndexToApproved[_tokenId], "Without permission");\n', '        \n', '        cardList[_tokenId].playerAddress = _to;\n', '        \n', '        if(cardIndexToApproved[_tokenId] != address(0))\n', '            delete cardIndexToApproved[_tokenId];\n', '        \n', '        emit Transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        senderVerify()\n', '        public\n', '    {\n', '        require (_from == cardList[_tokenId].playerAddress, "Owner error");\n', '        require(_to != address(0), "Address error");\n', '        require(_to == cardIndexToApproved[_tokenId], "Without permission");\n', '        \n', '        cardList[_tokenId].playerAddress = _to;\n', '        delete cardIndexToApproved[_tokenId];\n', '        \n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '}\n', '\n', 'library FBankdatasets {\n', '    \n', '    struct Round {\n', '        uint256 start;\n', '        uint256 end;\n', '        bool ended;\n', '        uint256 endSid;\n', '        uint256 amount;\n', '        uint256 protectAmount;\n', '        uint256 dividendAmount;\n', '        uint256 jackpotAmount;\n', '    }\n', '    \n', '    struct Stage {\n', '        uint256 start;\n', '        uint256 amount;\n', '        uint256 protectAmount;\n', '        uint256 dividendAmount;\n', '    }\n', '    \n', '    struct Goods {\n', '        uint256 rId;\n', '        uint256 startSid;\n', '        uint256 endSid;\n', '        uint256 withdrawSid;\n', '        uint256 amount;\n', '        uint256 startAmount;\n', '        uint256 endAmount;\n', '        uint256 reachAmount;\n', '        uint256 stepSize;\n', '        uint256 protectRatio;\n', '    }\n', '    \n', '    struct Card {\n', '        address playerAddress;\n', '        uint256 amount;\n', '    }\n', '}\n', '\n', '/**\n', ' * Anti clone protection.\n', ' * Do not clone this contract without permission even if you manage to break the conceal. \n', ' * The concealed code contains core calculations necessary for this contract to function. \n', ' * This contract can be licensed for a fee, contact us instead of cloning!\n', ' */ \n', 'interface FairBankCompute {\n', '    function getStageTargetAmount(uint256 _sId) external view returns(uint256);\n', '    function computeEarningsAmount(uint256 _sId, uint256 _amount, uint256 _currentTargetAmount, uint256 _expectEndSid, uint256 _ratio) external view returns(uint256);\n', '}\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256) \n', '    {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}']