['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Acceptable.sol\n', '\n', '// @title Acceptable\n', '// @author Takayuki Jimba\n', '// @dev Provide basic access control.\n', 'contract Acceptable is Ownable {\n', '    address public sender;\n', '\n', '    // @dev Throws if called by any address other than the sender.\n', '    modifier onlyAcceptable {\n', '        require(msg.sender == sender);\n', '        _;\n', '    }\n', '\n', '    // @dev Change acceptable address\n', '    // @param _sender The address to new sender\n', '    function setAcceptable(address _sender) public onlyOwner {\n', '        sender = _sender;\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);  \n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '  \n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '  \n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;  \n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/CrystalBaseIF.sol\n', '\n', '// @title CrystalBaseIF\n', '// @author Takayuki Jimba\n', 'contract CrystalBaseIF is ERC721 {\n', '    function mint(address _owner, uint256 _gene, uint256 _kind, uint256 _weight) public returns(uint256);\n', '    function burn(address _owner, uint256 _tokenId) public;\n', '    function _transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function getCrystalKindWeight(uint256 _tokenId) public view returns(uint256 kind, uint256 weight);\n', '    function getCrystalGeneKindWeight(uint256 _tokenId) public view returns(uint256 gene, uint256 kind, uint256 weight);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/MiningSupplier.sol\n', '\n', '// @title MiningSupplier\n', '// @author Takayuki Jimba\n', 'contract MiningSupplier {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant secondsPerYear = 1 years * 1 seconds;\n', '    uint256 public constant secondsPerDay = 1 days * 1 seconds;\n', '\n', '    // @dev Number of blocks per year\n', '    function _getBlocksPerYear(\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        return secondsPerYear.div(_secondsPerBlock);\n', '    }\n', '\n', '    // @dev 0-based block number index\n', '    //      First block number index of every years is 0\n', '    function _getBlockIndexAtYear(\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        //require(_currentBlockNumber >= _initialBlockNumber, "current is large than or equal to initial");\n', '        require(_currentBlockNumber >= _initialBlockNumber);\n', '        uint256 _blockIndex = _currentBlockNumber.sub(_initialBlockNumber);\n', '        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\n', '        return _blockIndex.sub(_blockIndex.div(_blocksPerYear).mul(_blocksPerYear));\n', '    }\n', '\n', '    // @dev Map block number to block index.\n', '    //      First block is number 0.\n', '    function _getBlockIndex(\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber\n', '    ) public pure returns(uint256) {\n', '        //require(_currentBlockNumber >= _initialBlockNumber, "current is large than or equal to initial");\n', '        require(_currentBlockNumber >= _initialBlockNumber);\n', '        return _currentBlockNumber.sub(_initialBlockNumber);\n', '    }\n', '\n', '    // @dev Map block number to year index.\n', '    //      First (blocksPerYear - 1) blocks are number 0.\n', '    function _getYearIndex(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber\n', '    ) public pure returns(uint256) {\n', '        uint256 _blockIndex =  _getBlockIndex(_initialBlockNumber, _currentBlockNumber);\n', '        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\n', '        return _blockIndex.div(_blocksPerYear);\n', '    }\n', '\n', '    // @dev\n', '    function _getWaitingBlocks(\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        return secondsPerDay.div(_secondsPerBlock);\n', '    }\n', '\n', '    function _getWeightUntil(\n', '        uint256 _totalWeight,\n', '        uint256 _yearIndex\n', '    ) public pure returns(uint256) {\n', '        uint256 _sum = 0;\n', '        for(uint256 i = 0; i < _yearIndex; i++) {\n', '            _sum = _sum.add(_totalWeight / (2 ** (i + 1)));\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    function _estimateSupply(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _totalWeight\n', '    ) public pure returns(uint256){\n', '        uint256 _yearIndex = _getYearIndex(_secondsPerBlock, _initialBlockNumber, _currentBlockNumber); // 0-based\n', '        uint256 _blockIndex = _getBlockIndexAtYear(_initialBlockNumber, _currentBlockNumber, _secondsPerBlock) + 1;\n', '        uint256 _numerator = _totalWeight.mul(_secondsPerBlock).mul(_blockIndex);\n', '        uint256 _yearFactor = 2 ** (_yearIndex + 1);\n', '        uint256 _denominator =  _yearFactor.mul(secondsPerYear);\n', '        uint256 _supply = _numerator.div(_denominator).add(_getWeightUntil(_totalWeight, _yearIndex));\n', '        return _supply; // mg\n', '    }\n', '\n', '    function _estimateWeight(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _totalWeight,\n', '        uint256 _currentWeight\n', '    ) public pure returns(uint256) {\n', '        uint256 _supply = _estimateSupply(\n', '            _secondsPerBlock,\n', '            _initialBlockNumber,\n', '            _currentBlockNumber,\n', '            _totalWeight\n', '        );\n', '        uint256 _yearIndex = _getYearIndex(\n', '            _secondsPerBlock,\n', '            _initialBlockNumber,\n', '            _currentBlockNumber\n', '        ); // 0-based\n', '        uint256 _yearFactor = 2 ** _yearIndex;\n', '        uint256 _defaultWeight = 10000; // mg\n', '\n', '        if(_currentWeight > _supply) {\n', '            // (_supply / _currentWeight) * _defaultWeight / _yearFactor\n', '            return _supply.mul(_defaultWeight).div(_currentWeight).div(_yearFactor);\n', '        } else {\n', '            // _defaultWeight / _yearFactor\n', '            return _defaultWeight.div(_yearFactor);\n', '        }\n', '    }\n', '\n', '    function _updateNeeded(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _blockNumberUpdated\n', '    ) public pure returns(bool) {\n', '        if (_blockNumberUpdated == 0) {\n', '            return true;\n', '        }\n', '        uint256 _waitingBlocks = _getWaitingBlocks(_secondsPerBlock);\n', '        return _currentBlockNumber >= _blockNumberUpdated + _waitingBlocks;\n', '    }\n', '}\n', '\n', '// File: contracts/CrystalWeightManager.sol\n', '\n', '// @title CrystalWeightManager\n', '// @author Takayuki Jimba\n', 'contract CrystalWeightManager is MiningSupplier {\n', '    // Amounts of deposit of all crystals.\n', '    // Each unit of weight is milligrams\n', '    // e.g. 50000000000 means 50t.\n', '    uint256[100] crystalWeights = [\n', '        50000000000,226800000000,1312500000000,31500000000,235830000000,\n', '        151200000000,655200000000,829500000000,7177734375,762300000000,\n', '        684600000000,676200000000,5037226562,30761718750,102539062500,\n', '        102539062500,102539062500,5126953125,31500000000,5040000000,\n', '        20507812500,20507812500,10253906250,5024414062,6300000000,\n', '        20507812500,102539062500,102539062500,102539062500,102539062500,\n', '        102539062500,7690429687,15380859375,69300000000,10253906250,\n', '        547050000000,15380859375,20507812500,15380859375,15380859375,\n', '        20507812500,15380859375,7690429687,153808593750,92285156250,\n', '        102539062500,71777343750,82031250000,256347656250,1384277343750,\n', '        820312500000,743408203125,461425781250,563964843750,538330078125,\n', '        358886718750,256347656250,358886718750,102539062500,307617187500,\n', '        256347656250,51269531250,41015625000,307617187500,307617187500,\n', '        2050781250,3588867187,2563476562,5126953125,399902343750,\n', '        615234375000,563964843750,461425781250,358886718750,717773437500,\n', '        41015625000,41015625000,2050781250,102539062500,102539062500,\n', '        51269531250,102539062500,30761718750,41015625000,102539062500,\n', '        102539062500,102539062500,205078125000,205078125000,556500000000,\n', '        657300000000,41015625000,102539062500,30761718750,102539062500,\n', '        20507812500,20507812500,20507812500,20507812500,82031250000\n', '    ];\n', '\n', '    uint256 public secondsPerBlock = 12;\n', '    uint256 public initialBlockNumber = block.number;\n', '    uint256 public constant originalTotalWeight = 21 * 10**13; // mg\n', '    uint256 public currentWeight = 0;\n', '    uint256 public estimatedWeight = 0;\n', '    uint256 public blockNumberUpdated = 0;\n', '\n', '    event UpdateEstimatedWeight(uint256 weight, uint256 nextUpdateBlockNumber);\n', '\n', '    function setEstimatedWeight(uint256 _minedWeight) internal {\n', '        currentWeight = currentWeight.add(_minedWeight);\n', '\n', '        uint256 _currentBlockNumber = block.number;\n', '\n', '        bool _isUpdate = _updateNeeded(\n', '            secondsPerBlock,\n', '            _currentBlockNumber,\n', '            blockNumberUpdated\n', '        );\n', '\n', '        if(_isUpdate) {\n', '            estimatedWeight = _estimateWeight(\n', '                secondsPerBlock,\n', '                initialBlockNumber,\n', '                _currentBlockNumber,\n', '                originalTotalWeight,\n', '                currentWeight\n', '            );\n', '            blockNumberUpdated = _currentBlockNumber;\n', '\n', '            emit UpdateEstimatedWeight(estimatedWeight, _currentBlockNumber);\n', '        }\n', '    }\n', '\n', '    function getCrystalWeights() external view returns(uint256[100]) {\n', '        return crystalWeights;\n', '    }\n', '}\n', '\n', '// File: contracts/EOACallable.sol\n', '\n', '// @title EOACallable\n', '// @author Takayuki Jimba\n', 'contract EOACallable {\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    modifier onlyEOA {\n', '        require(!isContract(msg.sender));\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/ExchangeBaseIF.sol\n', '\n', '// @title ExchangeBaseIF\n', '// @author Takayuki Jimba\n', 'contract ExchangeBaseIF {\n', '    function create(\n', '        address _owner,\n', '        uint256 _ownerTokenId,\n', '        uint256 _ownerTokenGene,\n', '        uint256 _ownerTokenKind,\n', '        uint256 _ownerTokenWeight,\n', '        uint256 _kind,\n', '        uint256 _weight,\n', '        uint256 _createdAt\n', '    ) public returns(uint256);\n', '    function remove(uint256 _id) public;\n', '    function getExchange(uint256 _id) public view returns(\n', '        address owner,\n', '        uint256 tokenId,\n', '        uint256 kind,\n', '        uint256 weight,\n', '        uint256 createdAt\n', '    );\n', '    function getTokenId(uint256 _id) public view returns(uint256);\n', '    function ownerOf(uint256 _id) public view returns(address);\n', '    function isOnExchange(uint256 _tokenId) public view returns(bool);\n', '    function isOnExchangeById(uint256 _id) public view returns(bool);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/PickaxeIF.sol\n', '\n', '// @title PickaxeIF\n', '// @author Takayuki Jimba\n', 'contract PickaxeIF is ERC20 {\n', '    function transferFromOwner(address _to, uint256 _amount) public;\n', '    function burn(address _from, uint256 _amount) public;\n', '}\n', '\n', '// File: contracts/RandomGeneratorIF.sol\n', '\n', '// @title RandomGeneratorIF\n', '// @author Takayuki Jimba\n', 'contract RandomGeneratorIF {\n', '    function generate() public returns(uint64);\n', '}\n', '\n', '// File: contracts/Sellable.sol\n', '\n', '// @title Sellable\n', '// @author Takayuki Jimba\n', '// @dev Sell tokens.\n', '//      Token is supposed to be Pickaxe contract in our contracts.\n', '//      Actual transferring tokens operation is to be implemented in inherited contract.\n', 'contract Sellable is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    address public wallet;\n', '    uint256 public rate;\n', '\n', '    address public donationWallet;\n', '    uint256 public donationRate;\n', '\n', '    uint256 public constant MIN_WEI_AMOUNT = 5 * 10**15;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event ForwardFunds(address sender, uint256 value, uint256 deposit);\n', '    event Donation(address sender, uint256 value);\n', '\n', '    constructor(address _wallet, address _donationWallet, uint256 _donationRate) public {\n', '        // 1 token = 0.005 ETH\n', '        rate = 200;\n', '        wallet = _wallet;\n', '        donationWallet = _donationWallet;\n', '        donationRate = _donationRate;\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function setEthereumWallet(address _donationWallet) external onlyOwner {\n', '        donationWallet = _donationWallet;\n', '    }\n', '\n', '    function () external payable {\n', '        require(msg.value >= MIN_WEI_AMOUNT);\n', '        buyPickaxes(msg.sender);\n', '    }\n', '\n', '    function buyPickaxes(address _beneficiary) public payable {\n', '        require(msg.value >= MIN_WEI_AMOUNT);\n', '\n', '        uint256 _weiAmount = msg.value;\n', '        uint256 _tokens = _weiAmount.mul(rate).div(1 ether);\n', '\n', '        require(_tokens.mul(1 ether).div(rate) == _weiAmount);\n', '\n', '        _transferFromOwner(msg.sender, _tokens);\n', '        emit TokenPurchase(msg.sender, _beneficiary, _weiAmount, _tokens);\n', '        _forwardFunds();\n', '    }\n', '\n', '    function _transferFromOwner(address _to, uint256 _value) internal {\n', '        /* MUST override */\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        uint256 donation = msg.value.div(donationRate); // 2%\n', '        uint256 value = msg.value - donation;\n', '\n', '        wallet.transfer(value);\n', '\n', '        emit ForwardFunds(msg.sender, value, donation);\n', '\n', '        uint256 donationEth = 2014000000000000000; // 2.014 ether\n', '        if(address(this).balance >= donationEth) {\n', '            donationWallet.transfer(donationEth);\n', '            emit Donation(msg.sender, donationEth);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/CryptoCrystal.sol\n', '\n', '// @title CryptoCrystal\n', '// @author Takayuki Jimba\n', '// @dev Almost all application specific logic is in this contract.\n', '//      CryptoCrystal acts as a facade to Pixaxe(ERC20), CrystalBase(ERC721), ExchangeBase as to transactions.\n', 'contract CryptoCrystal is Sellable, EOACallable, CrystalWeightManager {\n', '    PickaxeIF public pickaxe;\n', '    CrystalBaseIF public crystal;\n', '    ExchangeBaseIF public exchange;\n', '    RandomGeneratorIF public generator;\n', '\n', '    //event RandomGenerated(uint256 number);\n', '\n', '    event MineCrystals(\n', '        // miner of the crystal\n', '        address indexed owner,\n', '        // time of mining\n', '        uint256 indexed minedAt,\n', '        // tokenIds of mined crystals\n', '        uint256[] tokenIds,\n', '        // kinds of mined crystals\n', '        uint256[] kinds,\n', '        // weights of mined crystals\n', '        uint256[] weights,\n', '        // genes of mined crystals\n', '        uint256[] genes\n', '    );\n', '\n', '    event MeltCrystals(\n', '        // melter of the crystals\n', '        address indexed owner,\n', '        // time of melting\n', '        uint256 indexed meltedAt,\n', '        // tokenIds of melted crystals\n', '        uint256[] meltedTokenIds,\n', '        // tokenId of newly generated crystal\n', '        uint256 tokenId,\n', '        // kind of newly generated crystal\n', '        uint256 kind,\n', '        // weight of newly generated crystal\n', '        uint256 weight,\n', '        // gene of newly generated crystal\n', '        uint256 gene\n', '    );\n', '\n', '    event CreateExchange(\n', '        // id of exchange\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // gene of exhibited crystal\n', '        uint256 ownerTokenGene,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // kind of condition for exchange\n', '        uint256 kind,\n', '        // weight of condition for exchange\n', '        uint256 weight,\n', '        // time of exchange creation\n', '        uint256 createdAt\n', '    );\n', '\n', '    event CancelExchange(\n', '        // id of excahnge\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // time of exchange cancelling\n', '        uint256 cancelledAt\n', '    );\n', '\n', '    event BidExchange(\n', '        // id of exchange\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // gene of exhibited crystal\n', '        uint256 ownerTokenGene,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // exchanger who bid to exchange\n', '        address exchanger,\n', '        // tokenId of crystal to exchange\n', '        uint256 exchangerTokenId,\n', '        // kind of crystal to exchange\n', '        uint256 exchangerTokenKind,\n', '        // weight of crystal to exchange (may not be the same to weight condition)\n', '        uint256 exchangerTokenWeight,\n', '        // time of bidding\n', '        uint256 bidAt\n', '    );\n', '\n', '    struct ExchangeWrapper {\n', '        uint256 id;\n', '        address owner;\n', '        uint256 tokenId;\n', '        uint256 kind;\n', '        uint256 weight;\n', '        uint256 createdAt;\n', '    }\n', '\n', '    struct CrystalWrapper {\n', '        address owner;\n', '        uint256 tokenId;\n', '        uint256 gene;\n', '        uint256 kind;\n', '        uint256 weight;\n', '    }\n', '\n', '    constructor(\n', '        PickaxeIF _pickaxe,\n', '        CrystalBaseIF _crystal,\n', '        ExchangeBaseIF _exchange,\n', '        RandomGeneratorIF _generator,\n', '        address _wallet,\n', '        address _donationWallet,\n', '        uint256 _donationRate\n', '    ) Sellable(_wallet, _donationWallet, _donationRate) public {\n', '        pickaxe = _pickaxe;\n', '        crystal = _crystal;\n', '        exchange = _exchange;\n', '        generator = _generator;\n', '        setEstimatedWeight(0);\n', '    }\n', '\n', '    // @dev mineCrystals consists of two basic operations that burn pickaxes and mint crystals.\n', '    // @param _pkxAmount uint256 the amount of tokens to be burned\n', '    function mineCrystals(uint256 _pkxAmount) external onlyEOA {\n', '        address _owner = msg.sender;\n', '        require(pickaxe.balanceOf(msg.sender) >= _pkxAmount);\n', '        require(0 < _pkxAmount && _pkxAmount <= 100);\n', '\n', '        uint256 _crystalAmount = _getRandom(5);\n', '\n', '        uint256[] memory _tokenIds = new uint256[](_crystalAmount);\n', '        uint256[] memory _kinds = new uint256[](_crystalAmount);\n', '        uint256[] memory _weights = new uint256[](_crystalAmount);\n', '        uint256[] memory _genes = new uint256[](_crystalAmount);\n', '\n', '        uint256[] memory _crystalWeightsCumsum = new uint256[](100);\n', '        _crystalWeightsCumsum[0] = crystalWeights[0];\n', '        for(uint256 i = 1; i < 100; i++) {\n', '            _crystalWeightsCumsum[i] = _crystalWeightsCumsum[i - 1].add(crystalWeights[i]);\n', '        }\n', '        uint256 _totalWeight = _crystalWeightsCumsum[_crystalWeightsCumsum.length - 1];\n', '        uint256 _weightRandomSum = 0;\n', '        uint256 _weightSum = 0;\n', '\n', '        for(i = 0; i < _crystalAmount; i++) {\n', '            _weights[i] = _getRandom(100);\n', '            _weightRandomSum = _weightRandomSum.add(_weights[i]);\n', '        }\n', '\n', '        for(i = 0; i < _crystalAmount; i++) {\n', '            // Kind is decided randomly according to remaining crystal weights.\n', '            // That means crystals of large quantity are chosen with high probability.\n', '            _kinds[i] = _getFirstIndex(_getRandom(_totalWeight), _crystalWeightsCumsum);\n', '\n', '            // Weight is decided randomly according to estimatedWeight.\n', '            // EstimatedWeight is fixed (calculated in advance) in one mining.\n', '            // EstimatedWeight is randomly divided into each of weight.\n', '            // That means sum of weights is equal to EstimatedWeight.\n', '            uint256 actualWeight = estimatedWeight.mul(_pkxAmount);\n', '            _weights[i] = _weights[i].mul(actualWeight).div(_weightRandomSum);\n', '\n', '            // Gene is decided randomly.\n', '            _genes[i] = _generateGene();\n', '\n', '            require(_weights[i] > 0);\n', '\n', '            _tokenIds[i] = crystal.mint(_owner, _genes[i], _kinds[i], _weights[i]);\n', '\n', '            crystalWeights[_kinds[i]] = crystalWeights[_kinds[i]].sub(_weights[i]);\n', '\n', '            _weightSum = _weightSum.add(_weights[i]);\n', '        }\n', '\n', '        setEstimatedWeight(_weightSum);\n', '        pickaxe.burn(msg.sender, _pkxAmount);\n', '\n', '        emit MineCrystals(\n', '        _owner,\n', '        now,\n', '        _tokenIds,\n', '        _kinds,\n', '        _weights,\n', '        _genes\n', '        );\n', '    }\n', '\n', '    // @dev meltCrystals consists of two basic operations.\n', '    //      It burns old crystals and mint new crystal.\n', '    //      The weight of new crystal is the same to total weight of bunred crystals.\n', '    // @notice meltCrystals may have bugs. We will fix later.\n', '    // @param uint256[] _tokenIds the token ids of crystals to be melt\n', '    function meltCrystals(uint256[] _tokenIds) external onlyEOA {\n', '        uint256 _length = _tokenIds.length;\n', '        address _owner = msg.sender;\n', '\n', '        require(2 <= _length && _length <= 10);\n', '\n', '        uint256[] memory _kinds = new uint256[](_length);\n', '        uint256 _weight;\n', '        uint256 _totalWeight = 0;\n', '\n', '        for(uint256 i = 0; i < _length; i++) {\n', '            require(crystal.ownerOf(_tokenIds[i]) == _owner);\n', '            (_kinds[i], _weight) = crystal.getCrystalKindWeight(_tokenIds[i]);\n', '            if (i != 0) {\n', '                require(_kinds[i] == _kinds[i - 1]);\n', '            }\n', '\n', '            _totalWeight = _totalWeight.add(_weight);\n', '            crystal.burn(_owner, _tokenIds[i]);\n', '        }\n', '\n', '        uint256 _gene = _generateGene();\n', '        uint256 _tokenId = crystal.mint(_owner, _gene, _kinds[0], _totalWeight);\n', '\n', '        emit MeltCrystals(_owner, now, _tokenIds, _tokenId, _kinds[0], _totalWeight, _gene);\n', '    }\n', '\n', '    // @dev create exchange\n', '    // @param uint256 _tokenId tokenId you want to exchange\n', '    // @param uint256 _kind crystal kind you want to get\n', '    // @param uint256 _weight minimum crystal weight you want to get\n', '    function createExchange(uint256 _tokenId, uint256 _kind, uint256 _weight) external onlyEOA {\n', '        ExchangeWrapper memory _ew = ExchangeWrapper({\n', '            id: 0, // specify after\n', '            owner: msg.sender,\n', '            tokenId: _tokenId,\n', '            kind: _kind,\n', '            weight: _weight,\n', '            createdAt: 0\n', '            });\n', '\n', '        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        require(crystal.ownerOf(_tokenId) == _cw.owner);\n', '        require(_kind < 100);\n', '\n', '        // escrow crystal to exchange contract\n', '        crystal._transferFrom(_cw.owner, exchange, _tokenId);\n', '\n', '        _ew.id = exchange.create(_ew.owner, _tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\n', '\n', '        emit CreateExchange(_ew.id, _ew.owner, _ew.tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\n', '    }\n', '\n', '    function getCrystalWrapper(address _owner, uint256 _tokenId) internal returns(CrystalWrapper) {\n', '        CrystalWrapper memory _cw;\n', '        _cw.owner = _owner;\n', '        _cw.tokenId = _tokenId;\n', '        (_cw.gene, _cw.kind, _cw.weight) = crystal.getCrystalGeneKindWeight(_tokenId);\n', '        return _cw;\n', '    }\n', '\n', '    // @dev cancel exchange\n', '    // @param uint256 _id exchangeId you want to cancel\n', '    function cancelExchange(uint256 _id) external onlyEOA {\n', '        require(exchange.ownerOf(_id) == msg.sender);\n', '\n', '        uint256 _tokenId = exchange.getTokenId(_id);\n', '\n', '        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        // withdraw crystal from exchange contract\n', '        crystal._transferFrom(exchange, _cw.owner, _cw.tokenId);\n', '\n', '        exchange.remove(_id);\n', '\n', '        emit CancelExchange(_id, _cw.owner, _cw.tokenId, _cw.kind, _cw.weight, now);\n', '    }\n', '\n', '    // @dev bid exchange\n', '    // @param uint256 _exchangeId exchange id you want to bid\n', '    // @param uint256 _tokenId token id of your crystal to be exchanged\n', '    function bidExchange(uint256 _exchangeId, uint256 _tokenId) external onlyEOA {\n', '        // exchange\n', '        ExchangeWrapper memory _ew;\n', '        _ew.id = _exchangeId;\n', '        (_ew.owner, _ew.tokenId, _ew.kind, _ew.weight, _ew.createdAt) = exchange.getExchange(_ew.id); // check existence\n', '\n', '        // crystal of exchanger\n', '        CrystalWrapper memory _cwe = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        // crystal of creator of exchange\n', '        CrystalWrapper memory _cwo = getCrystalWrapper(_ew.owner, _ew.tokenId);\n', '\n', '        require(_cwe.owner != _ew.owner);\n', '        require(_cwe.kind == _ew.kind);\n', '        require(_cwe.weight >= _ew.weight);\n', '\n', '        // transfer my crystal to owner of exchange\n', '        crystal._transferFrom(_cwe.owner, _ew.owner, _cwe.tokenId);\n', '\n', '        // transfer escrowed crystal to me.\n', '        crystal._transferFrom(exchange, _cwe.owner, _ew.tokenId);\n', '\n', '        exchange.remove(_ew.id);\n', '\n', '        emit BidExchange(_ew.id, _ew.owner, _ew.tokenId, _cwo.gene, _cwo.kind, _cwo.weight, _cwe.owner, _cwe.tokenId, _cwe.kind, _cwe.weight, now);\n', '    }\n', '\n', '    // @dev get index when cumsum[i] exceeds _in first.\n', '    // @param uint256 _min\n', '    // @param uint256[] _sorted array is required to be sorted by ascending order\n', '    function _getFirstIndex(uint256 _min, uint256[] _sorted) public pure returns(uint256) {\n', '        for(uint256 i = 0; i < _sorted.length; i++) {\n', '            if(_min < _sorted[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return _sorted.length - 1;\n', '    }\n', '\n', '    function _transferFromOwner(address _to, uint256 _value) internal {\n', '        pickaxe.transferFromOwner(_to, _value);\n', '    }\n', '\n', '    function _generateGene() internal returns(uint256) {\n', '        return _getRandom(~uint256(0));\n', '    }\n', '\n', '    function _getRandom(uint256 _max) public returns(uint256){\n', '        bytes32 hash = keccak256(generator.generate());\n', '        uint256 number = (uint256(hash) % _max) + 1;\n', '        //emit RandomGenerated(number);\n', '        return number;\n', '    }\n', '\n', '    // @dev change random generator\n', '    // @param RandomGeneratorIF randomGenerator contract address\n', '    function setRandomGenerator(RandomGeneratorIF _generator) external onlyOwner {\n', '        generator = _generator;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Acceptable.sol\n', '\n', '// @title Acceptable\n', '// @author Takayuki Jimba\n', '// @dev Provide basic access control.\n', 'contract Acceptable is Ownable {\n', '    address public sender;\n', '\n', '    // @dev Throws if called by any address other than the sender.\n', '    modifier onlyAcceptable {\n', '        require(msg.sender == sender);\n', '        _;\n', '    }\n', '\n', '    // @dev Change acceptable address\n', '    // @param _sender The address to new sender\n', '    function setAcceptable(address _sender) public onlyOwner {\n', '        sender = _sender;\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);  \n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '  \n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '  \n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;  \n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/CrystalBaseIF.sol\n', '\n', '// @title CrystalBaseIF\n', '// @author Takayuki Jimba\n', 'contract CrystalBaseIF is ERC721 {\n', '    function mint(address _owner, uint256 _gene, uint256 _kind, uint256 _weight) public returns(uint256);\n', '    function burn(address _owner, uint256 _tokenId) public;\n', '    function _transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function getCrystalKindWeight(uint256 _tokenId) public view returns(uint256 kind, uint256 weight);\n', '    function getCrystalGeneKindWeight(uint256 _tokenId) public view returns(uint256 gene, uint256 kind, uint256 weight);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/MiningSupplier.sol\n', '\n', '// @title MiningSupplier\n', '// @author Takayuki Jimba\n', 'contract MiningSupplier {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant secondsPerYear = 1 years * 1 seconds;\n', '    uint256 public constant secondsPerDay = 1 days * 1 seconds;\n', '\n', '    // @dev Number of blocks per year\n', '    function _getBlocksPerYear(\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        return secondsPerYear.div(_secondsPerBlock);\n', '    }\n', '\n', '    // @dev 0-based block number index\n', '    //      First block number index of every years is 0\n', '    function _getBlockIndexAtYear(\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        //require(_currentBlockNumber >= _initialBlockNumber, "current is large than or equal to initial");\n', '        require(_currentBlockNumber >= _initialBlockNumber);\n', '        uint256 _blockIndex = _currentBlockNumber.sub(_initialBlockNumber);\n', '        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\n', '        return _blockIndex.sub(_blockIndex.div(_blocksPerYear).mul(_blocksPerYear));\n', '    }\n', '\n', '    // @dev Map block number to block index.\n', '    //      First block is number 0.\n', '    function _getBlockIndex(\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber\n', '    ) public pure returns(uint256) {\n', '        //require(_currentBlockNumber >= _initialBlockNumber, "current is large than or equal to initial");\n', '        require(_currentBlockNumber >= _initialBlockNumber);\n', '        return _currentBlockNumber.sub(_initialBlockNumber);\n', '    }\n', '\n', '    // @dev Map block number to year index.\n', '    //      First (blocksPerYear - 1) blocks are number 0.\n', '    function _getYearIndex(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber\n', '    ) public pure returns(uint256) {\n', '        uint256 _blockIndex =  _getBlockIndex(_initialBlockNumber, _currentBlockNumber);\n', '        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\n', '        return _blockIndex.div(_blocksPerYear);\n', '    }\n', '\n', '    // @dev\n', '    function _getWaitingBlocks(\n', '        uint256 _secondsPerBlock\n', '    ) public pure returns(uint256) {\n', '        return secondsPerDay.div(_secondsPerBlock);\n', '    }\n', '\n', '    function _getWeightUntil(\n', '        uint256 _totalWeight,\n', '        uint256 _yearIndex\n', '    ) public pure returns(uint256) {\n', '        uint256 _sum = 0;\n', '        for(uint256 i = 0; i < _yearIndex; i++) {\n', '            _sum = _sum.add(_totalWeight / (2 ** (i + 1)));\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    function _estimateSupply(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _totalWeight\n', '    ) public pure returns(uint256){\n', '        uint256 _yearIndex = _getYearIndex(_secondsPerBlock, _initialBlockNumber, _currentBlockNumber); // 0-based\n', '        uint256 _blockIndex = _getBlockIndexAtYear(_initialBlockNumber, _currentBlockNumber, _secondsPerBlock) + 1;\n', '        uint256 _numerator = _totalWeight.mul(_secondsPerBlock).mul(_blockIndex);\n', '        uint256 _yearFactor = 2 ** (_yearIndex + 1);\n', '        uint256 _denominator =  _yearFactor.mul(secondsPerYear);\n', '        uint256 _supply = _numerator.div(_denominator).add(_getWeightUntil(_totalWeight, _yearIndex));\n', '        return _supply; // mg\n', '    }\n', '\n', '    function _estimateWeight(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _initialBlockNumber,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _totalWeight,\n', '        uint256 _currentWeight\n', '    ) public pure returns(uint256) {\n', '        uint256 _supply = _estimateSupply(\n', '            _secondsPerBlock,\n', '            _initialBlockNumber,\n', '            _currentBlockNumber,\n', '            _totalWeight\n', '        );\n', '        uint256 _yearIndex = _getYearIndex(\n', '            _secondsPerBlock,\n', '            _initialBlockNumber,\n', '            _currentBlockNumber\n', '        ); // 0-based\n', '        uint256 _yearFactor = 2 ** _yearIndex;\n', '        uint256 _defaultWeight = 10000; // mg\n', '\n', '        if(_currentWeight > _supply) {\n', '            // (_supply / _currentWeight) * _defaultWeight / _yearFactor\n', '            return _supply.mul(_defaultWeight).div(_currentWeight).div(_yearFactor);\n', '        } else {\n', '            // _defaultWeight / _yearFactor\n', '            return _defaultWeight.div(_yearFactor);\n', '        }\n', '    }\n', '\n', '    function _updateNeeded(\n', '        uint256 _secondsPerBlock,\n', '        uint256 _currentBlockNumber,\n', '        uint256 _blockNumberUpdated\n', '    ) public pure returns(bool) {\n', '        if (_blockNumberUpdated == 0) {\n', '            return true;\n', '        }\n', '        uint256 _waitingBlocks = _getWaitingBlocks(_secondsPerBlock);\n', '        return _currentBlockNumber >= _blockNumberUpdated + _waitingBlocks;\n', '    }\n', '}\n', '\n', '// File: contracts/CrystalWeightManager.sol\n', '\n', '// @title CrystalWeightManager\n', '// @author Takayuki Jimba\n', 'contract CrystalWeightManager is MiningSupplier {\n', '    // Amounts of deposit of all crystals.\n', '    // Each unit of weight is milligrams\n', '    // e.g. 50000000000 means 50t.\n', '    uint256[100] crystalWeights = [\n', '        50000000000,226800000000,1312500000000,31500000000,235830000000,\n', '        151200000000,655200000000,829500000000,7177734375,762300000000,\n', '        684600000000,676200000000,5037226562,30761718750,102539062500,\n', '        102539062500,102539062500,5126953125,31500000000,5040000000,\n', '        20507812500,20507812500,10253906250,5024414062,6300000000,\n', '        20507812500,102539062500,102539062500,102539062500,102539062500,\n', '        102539062500,7690429687,15380859375,69300000000,10253906250,\n', '        547050000000,15380859375,20507812500,15380859375,15380859375,\n', '        20507812500,15380859375,7690429687,153808593750,92285156250,\n', '        102539062500,71777343750,82031250000,256347656250,1384277343750,\n', '        820312500000,743408203125,461425781250,563964843750,538330078125,\n', '        358886718750,256347656250,358886718750,102539062500,307617187500,\n', '        256347656250,51269531250,41015625000,307617187500,307617187500,\n', '        2050781250,3588867187,2563476562,5126953125,399902343750,\n', '        615234375000,563964843750,461425781250,358886718750,717773437500,\n', '        41015625000,41015625000,2050781250,102539062500,102539062500,\n', '        51269531250,102539062500,30761718750,41015625000,102539062500,\n', '        102539062500,102539062500,205078125000,205078125000,556500000000,\n', '        657300000000,41015625000,102539062500,30761718750,102539062500,\n', '        20507812500,20507812500,20507812500,20507812500,82031250000\n', '    ];\n', '\n', '    uint256 public secondsPerBlock = 12;\n', '    uint256 public initialBlockNumber = block.number;\n', '    uint256 public constant originalTotalWeight = 21 * 10**13; // mg\n', '    uint256 public currentWeight = 0;\n', '    uint256 public estimatedWeight = 0;\n', '    uint256 public blockNumberUpdated = 0;\n', '\n', '    event UpdateEstimatedWeight(uint256 weight, uint256 nextUpdateBlockNumber);\n', '\n', '    function setEstimatedWeight(uint256 _minedWeight) internal {\n', '        currentWeight = currentWeight.add(_minedWeight);\n', '\n', '        uint256 _currentBlockNumber = block.number;\n', '\n', '        bool _isUpdate = _updateNeeded(\n', '            secondsPerBlock,\n', '            _currentBlockNumber,\n', '            blockNumberUpdated\n', '        );\n', '\n', '        if(_isUpdate) {\n', '            estimatedWeight = _estimateWeight(\n', '                secondsPerBlock,\n', '                initialBlockNumber,\n', '                _currentBlockNumber,\n', '                originalTotalWeight,\n', '                currentWeight\n', '            );\n', '            blockNumberUpdated = _currentBlockNumber;\n', '\n', '            emit UpdateEstimatedWeight(estimatedWeight, _currentBlockNumber);\n', '        }\n', '    }\n', '\n', '    function getCrystalWeights() external view returns(uint256[100]) {\n', '        return crystalWeights;\n', '    }\n', '}\n', '\n', '// File: contracts/EOACallable.sol\n', '\n', '// @title EOACallable\n', '// @author Takayuki Jimba\n', 'contract EOACallable {\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    modifier onlyEOA {\n', '        require(!isContract(msg.sender));\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/ExchangeBaseIF.sol\n', '\n', '// @title ExchangeBaseIF\n', '// @author Takayuki Jimba\n', 'contract ExchangeBaseIF {\n', '    function create(\n', '        address _owner,\n', '        uint256 _ownerTokenId,\n', '        uint256 _ownerTokenGene,\n', '        uint256 _ownerTokenKind,\n', '        uint256 _ownerTokenWeight,\n', '        uint256 _kind,\n', '        uint256 _weight,\n', '        uint256 _createdAt\n', '    ) public returns(uint256);\n', '    function remove(uint256 _id) public;\n', '    function getExchange(uint256 _id) public view returns(\n', '        address owner,\n', '        uint256 tokenId,\n', '        uint256 kind,\n', '        uint256 weight,\n', '        uint256 createdAt\n', '    );\n', '    function getTokenId(uint256 _id) public view returns(uint256);\n', '    function ownerOf(uint256 _id) public view returns(address);\n', '    function isOnExchange(uint256 _tokenId) public view returns(bool);\n', '    function isOnExchangeById(uint256 _id) public view returns(bool);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/PickaxeIF.sol\n', '\n', '// @title PickaxeIF\n', '// @author Takayuki Jimba\n', 'contract PickaxeIF is ERC20 {\n', '    function transferFromOwner(address _to, uint256 _amount) public;\n', '    function burn(address _from, uint256 _amount) public;\n', '}\n', '\n', '// File: contracts/RandomGeneratorIF.sol\n', '\n', '// @title RandomGeneratorIF\n', '// @author Takayuki Jimba\n', 'contract RandomGeneratorIF {\n', '    function generate() public returns(uint64);\n', '}\n', '\n', '// File: contracts/Sellable.sol\n', '\n', '// @title Sellable\n', '// @author Takayuki Jimba\n', '// @dev Sell tokens.\n', '//      Token is supposed to be Pickaxe contract in our contracts.\n', '//      Actual transferring tokens operation is to be implemented in inherited contract.\n', 'contract Sellable is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    address public wallet;\n', '    uint256 public rate;\n', '\n', '    address public donationWallet;\n', '    uint256 public donationRate;\n', '\n', '    uint256 public constant MIN_WEI_AMOUNT = 5 * 10**15;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event ForwardFunds(address sender, uint256 value, uint256 deposit);\n', '    event Donation(address sender, uint256 value);\n', '\n', '    constructor(address _wallet, address _donationWallet, uint256 _donationRate) public {\n', '        // 1 token = 0.005 ETH\n', '        rate = 200;\n', '        wallet = _wallet;\n', '        donationWallet = _donationWallet;\n', '        donationRate = _donationRate;\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function setEthereumWallet(address _donationWallet) external onlyOwner {\n', '        donationWallet = _donationWallet;\n', '    }\n', '\n', '    function () external payable {\n', '        require(msg.value >= MIN_WEI_AMOUNT);\n', '        buyPickaxes(msg.sender);\n', '    }\n', '\n', '    function buyPickaxes(address _beneficiary) public payable {\n', '        require(msg.value >= MIN_WEI_AMOUNT);\n', '\n', '        uint256 _weiAmount = msg.value;\n', '        uint256 _tokens = _weiAmount.mul(rate).div(1 ether);\n', '\n', '        require(_tokens.mul(1 ether).div(rate) == _weiAmount);\n', '\n', '        _transferFromOwner(msg.sender, _tokens);\n', '        emit TokenPurchase(msg.sender, _beneficiary, _weiAmount, _tokens);\n', '        _forwardFunds();\n', '    }\n', '\n', '    function _transferFromOwner(address _to, uint256 _value) internal {\n', '        /* MUST override */\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        uint256 donation = msg.value.div(donationRate); // 2%\n', '        uint256 value = msg.value - donation;\n', '\n', '        wallet.transfer(value);\n', '\n', '        emit ForwardFunds(msg.sender, value, donation);\n', '\n', '        uint256 donationEth = 2014000000000000000; // 2.014 ether\n', '        if(address(this).balance >= donationEth) {\n', '            donationWallet.transfer(donationEth);\n', '            emit Donation(msg.sender, donationEth);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/CryptoCrystal.sol\n', '\n', '// @title CryptoCrystal\n', '// @author Takayuki Jimba\n', '// @dev Almost all application specific logic is in this contract.\n', '//      CryptoCrystal acts as a facade to Pixaxe(ERC20), CrystalBase(ERC721), ExchangeBase as to transactions.\n', 'contract CryptoCrystal is Sellable, EOACallable, CrystalWeightManager {\n', '    PickaxeIF public pickaxe;\n', '    CrystalBaseIF public crystal;\n', '    ExchangeBaseIF public exchange;\n', '    RandomGeneratorIF public generator;\n', '\n', '    //event RandomGenerated(uint256 number);\n', '\n', '    event MineCrystals(\n', '        // miner of the crystal\n', '        address indexed owner,\n', '        // time of mining\n', '        uint256 indexed minedAt,\n', '        // tokenIds of mined crystals\n', '        uint256[] tokenIds,\n', '        // kinds of mined crystals\n', '        uint256[] kinds,\n', '        // weights of mined crystals\n', '        uint256[] weights,\n', '        // genes of mined crystals\n', '        uint256[] genes\n', '    );\n', '\n', '    event MeltCrystals(\n', '        // melter of the crystals\n', '        address indexed owner,\n', '        // time of melting\n', '        uint256 indexed meltedAt,\n', '        // tokenIds of melted crystals\n', '        uint256[] meltedTokenIds,\n', '        // tokenId of newly generated crystal\n', '        uint256 tokenId,\n', '        // kind of newly generated crystal\n', '        uint256 kind,\n', '        // weight of newly generated crystal\n', '        uint256 weight,\n', '        // gene of newly generated crystal\n', '        uint256 gene\n', '    );\n', '\n', '    event CreateExchange(\n', '        // id of exchange\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // gene of exhibited crystal\n', '        uint256 ownerTokenGene,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // kind of condition for exchange\n', '        uint256 kind,\n', '        // weight of condition for exchange\n', '        uint256 weight,\n', '        // time of exchange creation\n', '        uint256 createdAt\n', '    );\n', '\n', '    event CancelExchange(\n', '        // id of excahnge\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // time of exchange cancelling\n', '        uint256 cancelledAt\n', '    );\n', '\n', '    event BidExchange(\n', '        // id of exchange\n', '        uint256 indexed id,\n', '        // creator of the exchange\n', '        address owner,\n', '        // tokenId of exhibited crystal\n', '        uint256 ownerTokenId,\n', '        // gene of exhibited crystal\n', '        uint256 ownerTokenGene,\n', '        // kind of exhibited crystal\n', '        uint256 ownerTokenKind,\n', '        // weight of exhibited crystal\n', '        uint256 ownerTokenWeight,\n', '        // exchanger who bid to exchange\n', '        address exchanger,\n', '        // tokenId of crystal to exchange\n', '        uint256 exchangerTokenId,\n', '        // kind of crystal to exchange\n', '        uint256 exchangerTokenKind,\n', '        // weight of crystal to exchange (may not be the same to weight condition)\n', '        uint256 exchangerTokenWeight,\n', '        // time of bidding\n', '        uint256 bidAt\n', '    );\n', '\n', '    struct ExchangeWrapper {\n', '        uint256 id;\n', '        address owner;\n', '        uint256 tokenId;\n', '        uint256 kind;\n', '        uint256 weight;\n', '        uint256 createdAt;\n', '    }\n', '\n', '    struct CrystalWrapper {\n', '        address owner;\n', '        uint256 tokenId;\n', '        uint256 gene;\n', '        uint256 kind;\n', '        uint256 weight;\n', '    }\n', '\n', '    constructor(\n', '        PickaxeIF _pickaxe,\n', '        CrystalBaseIF _crystal,\n', '        ExchangeBaseIF _exchange,\n', '        RandomGeneratorIF _generator,\n', '        address _wallet,\n', '        address _donationWallet,\n', '        uint256 _donationRate\n', '    ) Sellable(_wallet, _donationWallet, _donationRate) public {\n', '        pickaxe = _pickaxe;\n', '        crystal = _crystal;\n', '        exchange = _exchange;\n', '        generator = _generator;\n', '        setEstimatedWeight(0);\n', '    }\n', '\n', '    // @dev mineCrystals consists of two basic operations that burn pickaxes and mint crystals.\n', '    // @param _pkxAmount uint256 the amount of tokens to be burned\n', '    function mineCrystals(uint256 _pkxAmount) external onlyEOA {\n', '        address _owner = msg.sender;\n', '        require(pickaxe.balanceOf(msg.sender) >= _pkxAmount);\n', '        require(0 < _pkxAmount && _pkxAmount <= 100);\n', '\n', '        uint256 _crystalAmount = _getRandom(5);\n', '\n', '        uint256[] memory _tokenIds = new uint256[](_crystalAmount);\n', '        uint256[] memory _kinds = new uint256[](_crystalAmount);\n', '        uint256[] memory _weights = new uint256[](_crystalAmount);\n', '        uint256[] memory _genes = new uint256[](_crystalAmount);\n', '\n', '        uint256[] memory _crystalWeightsCumsum = new uint256[](100);\n', '        _crystalWeightsCumsum[0] = crystalWeights[0];\n', '        for(uint256 i = 1; i < 100; i++) {\n', '            _crystalWeightsCumsum[i] = _crystalWeightsCumsum[i - 1].add(crystalWeights[i]);\n', '        }\n', '        uint256 _totalWeight = _crystalWeightsCumsum[_crystalWeightsCumsum.length - 1];\n', '        uint256 _weightRandomSum = 0;\n', '        uint256 _weightSum = 0;\n', '\n', '        for(i = 0; i < _crystalAmount; i++) {\n', '            _weights[i] = _getRandom(100);\n', '            _weightRandomSum = _weightRandomSum.add(_weights[i]);\n', '        }\n', '\n', '        for(i = 0; i < _crystalAmount; i++) {\n', '            // Kind is decided randomly according to remaining crystal weights.\n', '            // That means crystals of large quantity are chosen with high probability.\n', '            _kinds[i] = _getFirstIndex(_getRandom(_totalWeight), _crystalWeightsCumsum);\n', '\n', '            // Weight is decided randomly according to estimatedWeight.\n', '            // EstimatedWeight is fixed (calculated in advance) in one mining.\n', '            // EstimatedWeight is randomly divided into each of weight.\n', '            // That means sum of weights is equal to EstimatedWeight.\n', '            uint256 actualWeight = estimatedWeight.mul(_pkxAmount);\n', '            _weights[i] = _weights[i].mul(actualWeight).div(_weightRandomSum);\n', '\n', '            // Gene is decided randomly.\n', '            _genes[i] = _generateGene();\n', '\n', '            require(_weights[i] > 0);\n', '\n', '            _tokenIds[i] = crystal.mint(_owner, _genes[i], _kinds[i], _weights[i]);\n', '\n', '            crystalWeights[_kinds[i]] = crystalWeights[_kinds[i]].sub(_weights[i]);\n', '\n', '            _weightSum = _weightSum.add(_weights[i]);\n', '        }\n', '\n', '        setEstimatedWeight(_weightSum);\n', '        pickaxe.burn(msg.sender, _pkxAmount);\n', '\n', '        emit MineCrystals(\n', '        _owner,\n', '        now,\n', '        _tokenIds,\n', '        _kinds,\n', '        _weights,\n', '        _genes\n', '        );\n', '    }\n', '\n', '    // @dev meltCrystals consists of two basic operations.\n', '    //      It burns old crystals and mint new crystal.\n', '    //      The weight of new crystal is the same to total weight of bunred crystals.\n', '    // @notice meltCrystals may have bugs. We will fix later.\n', '    // @param uint256[] _tokenIds the token ids of crystals to be melt\n', '    function meltCrystals(uint256[] _tokenIds) external onlyEOA {\n', '        uint256 _length = _tokenIds.length;\n', '        address _owner = msg.sender;\n', '\n', '        require(2 <= _length && _length <= 10);\n', '\n', '        uint256[] memory _kinds = new uint256[](_length);\n', '        uint256 _weight;\n', '        uint256 _totalWeight = 0;\n', '\n', '        for(uint256 i = 0; i < _length; i++) {\n', '            require(crystal.ownerOf(_tokenIds[i]) == _owner);\n', '            (_kinds[i], _weight) = crystal.getCrystalKindWeight(_tokenIds[i]);\n', '            if (i != 0) {\n', '                require(_kinds[i] == _kinds[i - 1]);\n', '            }\n', '\n', '            _totalWeight = _totalWeight.add(_weight);\n', '            crystal.burn(_owner, _tokenIds[i]);\n', '        }\n', '\n', '        uint256 _gene = _generateGene();\n', '        uint256 _tokenId = crystal.mint(_owner, _gene, _kinds[0], _totalWeight);\n', '\n', '        emit MeltCrystals(_owner, now, _tokenIds, _tokenId, _kinds[0], _totalWeight, _gene);\n', '    }\n', '\n', '    // @dev create exchange\n', '    // @param uint256 _tokenId tokenId you want to exchange\n', '    // @param uint256 _kind crystal kind you want to get\n', '    // @param uint256 _weight minimum crystal weight you want to get\n', '    function createExchange(uint256 _tokenId, uint256 _kind, uint256 _weight) external onlyEOA {\n', '        ExchangeWrapper memory _ew = ExchangeWrapper({\n', '            id: 0, // specify after\n', '            owner: msg.sender,\n', '            tokenId: _tokenId,\n', '            kind: _kind,\n', '            weight: _weight,\n', '            createdAt: 0\n', '            });\n', '\n', '        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        require(crystal.ownerOf(_tokenId) == _cw.owner);\n', '        require(_kind < 100);\n', '\n', '        // escrow crystal to exchange contract\n', '        crystal._transferFrom(_cw.owner, exchange, _tokenId);\n', '\n', '        _ew.id = exchange.create(_ew.owner, _tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\n', '\n', '        emit CreateExchange(_ew.id, _ew.owner, _ew.tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\n', '    }\n', '\n', '    function getCrystalWrapper(address _owner, uint256 _tokenId) internal returns(CrystalWrapper) {\n', '        CrystalWrapper memory _cw;\n', '        _cw.owner = _owner;\n', '        _cw.tokenId = _tokenId;\n', '        (_cw.gene, _cw.kind, _cw.weight) = crystal.getCrystalGeneKindWeight(_tokenId);\n', '        return _cw;\n', '    }\n', '\n', '    // @dev cancel exchange\n', '    // @param uint256 _id exchangeId you want to cancel\n', '    function cancelExchange(uint256 _id) external onlyEOA {\n', '        require(exchange.ownerOf(_id) == msg.sender);\n', '\n', '        uint256 _tokenId = exchange.getTokenId(_id);\n', '\n', '        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        // withdraw crystal from exchange contract\n', '        crystal._transferFrom(exchange, _cw.owner, _cw.tokenId);\n', '\n', '        exchange.remove(_id);\n', '\n', '        emit CancelExchange(_id, _cw.owner, _cw.tokenId, _cw.kind, _cw.weight, now);\n', '    }\n', '\n', '    // @dev bid exchange\n', '    // @param uint256 _exchangeId exchange id you want to bid\n', '    // @param uint256 _tokenId token id of your crystal to be exchanged\n', '    function bidExchange(uint256 _exchangeId, uint256 _tokenId) external onlyEOA {\n', '        // exchange\n', '        ExchangeWrapper memory _ew;\n', '        _ew.id = _exchangeId;\n', '        (_ew.owner, _ew.tokenId, _ew.kind, _ew.weight, _ew.createdAt) = exchange.getExchange(_ew.id); // check existence\n', '\n', '        // crystal of exchanger\n', '        CrystalWrapper memory _cwe = getCrystalWrapper(msg.sender, _tokenId);\n', '\n', '        // crystal of creator of exchange\n', '        CrystalWrapper memory _cwo = getCrystalWrapper(_ew.owner, _ew.tokenId);\n', '\n', '        require(_cwe.owner != _ew.owner);\n', '        require(_cwe.kind == _ew.kind);\n', '        require(_cwe.weight >= _ew.weight);\n', '\n', '        // transfer my crystal to owner of exchange\n', '        crystal._transferFrom(_cwe.owner, _ew.owner, _cwe.tokenId);\n', '\n', '        // transfer escrowed crystal to me.\n', '        crystal._transferFrom(exchange, _cwe.owner, _ew.tokenId);\n', '\n', '        exchange.remove(_ew.id);\n', '\n', '        emit BidExchange(_ew.id, _ew.owner, _ew.tokenId, _cwo.gene, _cwo.kind, _cwo.weight, _cwe.owner, _cwe.tokenId, _cwe.kind, _cwe.weight, now);\n', '    }\n', '\n', '    // @dev get index when cumsum[i] exceeds _in first.\n', '    // @param uint256 _min\n', '    // @param uint256[] _sorted array is required to be sorted by ascending order\n', '    function _getFirstIndex(uint256 _min, uint256[] _sorted) public pure returns(uint256) {\n', '        for(uint256 i = 0; i < _sorted.length; i++) {\n', '            if(_min < _sorted[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return _sorted.length - 1;\n', '    }\n', '\n', '    function _transferFromOwner(address _to, uint256 _value) internal {\n', '        pickaxe.transferFromOwner(_to, _value);\n', '    }\n', '\n', '    function _generateGene() internal returns(uint256) {\n', '        return _getRandom(~uint256(0));\n', '    }\n', '\n', '    function _getRandom(uint256 _max) public returns(uint256){\n', '        bytes32 hash = keccak256(generator.generate());\n', '        uint256 number = (uint256(hash) % _max) + 1;\n', '        //emit RandomGenerated(number);\n', '        return number;\n', '    }\n', '\n', '    // @dev change random generator\n', '    // @param RandomGeneratorIF randomGenerator contract address\n', '    function setRandomGenerator(RandomGeneratorIF _generator) external onlyOwner {\n', '        generator = _generator;\n', '    }\n', '}']
