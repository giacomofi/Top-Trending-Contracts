['pragma solidity 0.4.19;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function decimals()public view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner once sale ends\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Closed }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed();\n', '    event withdrawn(address _wallet);\n', '    function Vault(address _wallet) public {\n', '        require(_wallet != 0x0);\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    function close() public onlyOwner {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        Closed();\n', '    }\n', '\n', '    function withdrawToWallet() onlyOwner public{\n', '    require(state == State.Closed);\n', '    wallet.transfer(this.balance);\n', '    withdrawn(wallet);\n', '  }\n', '}\n', '\n', '\n', 'contract TRANXCrowdsales is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '      \n', '      //Total tokens which is on for sale\n', '      uint256 public crowdSaleHardCap;\n', '      \n', '      \n', '      //There can be 5 tiers and it will contain info about each tier\n', '      struct TierInfo{\n', '          uint256 hardcap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint256 rate;\n', '          uint8 bonusPercentage;\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '      //info of each tier\n', '      TierInfo[] public tiers;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '      \n', '      uint8 public noOfTiers;\n', '      \n', '      uint256 public tokensSold;\n', '    \n', '      //Keep track whether sales is active or not\n', '      bool public salesActive;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '      \n', '      bool public unspentCreditsWithdrawn;\n', '      \n', '      //to make sure contract is poweredup only once\n', '      bool contractPoweredUp = false;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event Finalized(address _owner, uint256 time);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _saleActive(){\n', '        require(salesActive);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != 0x0);\n', '        _;\n', '    }\n', '    \n', '    modifier nonZeroEth() {\n', '        require(msg.value > 0);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier tiersEmpty(){\n', '        require(noOfTiers==0);\n', '        _;\n', '    }\n', '    \n', '    function TRANXCrowdsales(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '    }\n', '    \n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        \n', '        require(!contractPoweredUp);\n', '        \n', '        // Contract should not be powered up previously\n', '        require(!salesActive);\n', '\n', '        // Contract should have enough Parsec credits\n', '        require(token.balanceOf(this) >= crowdSaleHardCap);\n', '        \n', '        //check whether tier information has been entered\n', '        require(noOfTiers>0 && tiers.length==noOfTiers);\n', '      \n', '        //activate the sale process\n', '        salesActive=true;\n', '        \n', '        contractPoweredUp = true;\n', '    }\n', '    \n', '    //for Emergency stop of the sale\n', '    function emergencyStop() public onlyOwner _saleActive{\n', '        salesActive = false;\n', '        saleEnded = true;    \n', '        vault.close();\n', '        SaleStopped(msg.sender, now);\n', '    }\n', '    \n', '    /**\n', '   * @dev Must be called after sale ends, to do some extra finalization\n', "   * work. Calls the contract's finalization function.\n", '   */\n', '    function finalize()public onlyOwner _saleActive{\n', '        require(saleTimeOver());\n', '        salesActive = false;\n', '        saleEnded = true;\n', '        vault.close();\n', '        Finalized(msg.sender, now);\n', '    }\n', '    \n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '      if(noOfTiers==0){\n', '          //since no tiers has been provided yet, hence sales has not started to end\n', '          return false;\n', '      }\n', '      //If last tier has ended, it mean all tiers are finished\n', '    return now > tiers[noOfTiers-1].endTime;\n', '  }\n', '  \n', '    //if crowdsales is over, the money rasied should be transferred to the wallet address\n', '  function withdrawFunds() public onlyOwner _saleEnded{\n', '  \n', '      vault.withdrawToWallet();\n', '  }\n', '  \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfTiers The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _hardCaps The array containing hard cap for each tier\n', '  * @param _rates The array containing number of tokens per ether for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3,4 and 5.\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfTiers, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps, uint256[] _rates, uint8[] _bonusPercentages)public onlyOwner tiersEmpty{\n', '    \n', '    //Minimu number of tiers should be 1 and less than or equal to 5\n', '    require(_noOfTiers>=1 && _noOfTiers<=5);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length == _noOfTiers);\n', '    require(_endTimes.length==_noOfTiers);\n', '    require(_hardCaps.length==_noOfTiers);\n', '    require(_rates.length==_noOfTiers);\n', '    require(_bonusPercentages.length==_noOfTiers);\n', '    \n', '    noOfTiers = _noOfTiers;\n', '    \n', '    for(uint8 i=0;i<noOfTiers;i++){\n', '        require(_hardCaps[i]>0);\n', '        require(_endTimes[i]>_startTimes[i]);\n', '        require(_rates[i]>0);\n', '        require(_bonusPercentages[i]>0);\n', '        if(i>0){\n', '            \n', '            //check hard cap for this tier should be greater than the previous tier\n', '            require(_hardCaps[i] > _hardCaps[i-1]);\n', '            \n', '            //start time of this tier should be greater than previous tier\n', '            require(_startTimes[i]>_endTimes[i-1]);\n', '            \n', '            tiers.push(TierInfo({\n', '                hardcap:_hardCaps[i].mul( 10 ** uint256(token.decimals())),\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                rate:_rates[i],\n', '                bonusPercentage:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i]>now);\n', '          \n', '            tiers.push(TierInfo({\n', '                hardcap:_hardCaps[i].mul( 10 ** uint256(token.decimals())), //multiplying with decimal places. So if hard cap is set to 1 it is actually set to 1 * 10^decimals\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                rate:_rates[i],\n', '                bonusPercentage:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '    crowdSaleHardCap = _hardCaps[noOfTiers-1].mul( 10 ** uint256(token.decimals()));\n', '  }\n', '    \n', '    /**\n', '    * @dev Allows owner to transfer unsold tokens to his/her address\n', '    * This method should only be called once the sale has been stopped/ended\n', '    */\n', '   function ownerWithdrawUnspentCredits()public onlyOwner _saleEnded{\n', '        require(!unspentCreditsWithdrawn);\n', '        unspentCreditsWithdrawn = true;\n', '        token.transfer(owner, token.balanceOf(this));\n', '   }\n', '   \n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _saleActive nonZeroEth nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       int8 currentTierIndex = getCurrentlyRunningTier();\n', '       assert(currentTierIndex>=0);\n', '       \n', '       TierInfo storage currentlyRunningTier = tiers[uint256(currentTierIndex)];\n', '       \n', '       //hard cap for this tier has not been reached\n', '       require(tokensSold < currentlyRunningTier.hardcap);\n', '       \n', '       uint256 weiAmount = msg.value;\n', '       \n', '       uint256 tokens = weiAmount.mul(currentlyRunningTier.rate);\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningTier.bonusPercentage);\n', '       \n', '       //Total tokens sold including current sale should be less than hard cap of this tier\n', '       assert(tokensSold.add(bonusedTokens) <= currentlyRunningTier.hardcap);\n', '       \n', '       tokensSold = tokensSold.add(bonusedTokens);\n', '       \n', '       totalFunding = totalFunding.add(weiAmount);\n', '       \n', '       currentlyRunningTier.weiRaised = currentlyRunningTier.weiRaised.add(weiAmount);\n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       token.transfer(beneficiary, bonusedTokens);\n', '       TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '       \n', '   }\n', '   \n', '     function applyBonus(uint256 tokens, uint8 percent) internal pure returns  (uint256 bonusedTokens) {\n', '        uint256 tokensToAdd = tokens.mul(percent).div(100);\n', '        return tokens.add(tokensToAdd);\n', '    }\n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningTier()public view returns(int8){\n', '      for(uint8 i=0;i<noOfTiers;i++){\n', '          if(now>=tiers[i].startTime && now<tiers[i].endTime){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   /**\n', '   * @dev Get functing info of user/address. It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '   \n', '      \n', '}']