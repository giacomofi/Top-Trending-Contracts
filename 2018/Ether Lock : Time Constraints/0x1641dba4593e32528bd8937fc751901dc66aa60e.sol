['/*\n', 'This file is part of the eHealth First Contract.\n', '\n', 'www.ehfirst.io\n', '\n', 'An IT-platform for Personalized Health and Longevity Management\n', 'based on Blockchain, Artificial Intelligence,\n', 'Machine Learning and Natural Language Processing\n', '\n', 'The eHealth First Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The eHealth First Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the eHealth First Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <<span class="__cf_email__" data-cfemail="b6df98c5c0dfc4dfd8f6c6c4d9c0d3c498c4c3">[email&#160;protected]</span>>\n', '\n', 'IF YOU ARE ENJOYED IT DONATE TO 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B ! :)\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '  function owned() public payable {\n', '         owner = msg.sender;\n', '     }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public;\n', '    function approve(address spender, uint value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract Token is owned, ERC20 {\n', '\n', '    string  public standard    = &#39;Token 0.1&#39;;\n', '    string  public name        = &#39;eHealth First&#39;;\n', '    string  public symbol      = "EHF";\n', '    uint8   public decimals    = 8;\n', '\n', '    uint    public freezedMoment;\n', '\n', '    struct TokenHolder {\n', '        uint balance;\n', '        uint balanceBeforeUpdate;\n', '        uint balanceUpdateTime;\n', '    }\n', '    mapping (address => TokenHolder) public holders;\n', '    mapping (address => uint) public vesting;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    address public vestingManager;\n', '\n', '    function setVestingManager(address _vestingManager) public onlyOwner {\n', '        vestingManager = _vestingManager;\n', '    }\n', '\n', '    function beforeBalanceChanges(address _who) internal {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            holders[_who].balanceUpdateTime = now;\n', '            holders[_who].balanceBeforeUpdate = holders[_who].balance;\n', '        }\n', '    }\n', '\n', '    event Burned(address indexed owner, uint256 value);\n', '\n', '    function Token() public owned() {}\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return holders[_who].balance;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(now > vesting[msg.sender] || msg.sender == vestingManager);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(_to);\n', '        holders[msg.sender].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        if (vesting[_to] < vesting[msg.sender]) {\n', '            vesting[_to] = vesting[msg.sender];\n', '        }\n', '        emit Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public {\n', '        require(now > vesting[_from]);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        beforeBalanceChanges(_from);\n', '        beforeBalanceChanges(_to);\n', '        holders[_from].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant\n', '        returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function burn(uint256 _value) public {\n', '        require(holders[msg.sender].balance >= _value);\n', '        beforeBalanceChanges(msg.sender);\n', '        holders[msg.sender].balance -= _value;\n', '        totalSupply -= _value;\n', '        emit Burned(msg.sender, _value);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is Token {\n', '\n', '    address public backend;\n', '\n', '    uint public stage;\n', '    bool public started;\n', '    uint public startTokenPriceWei;\n', '    uint public tokensForSale;\n', '    uint public startTime;\n', '    uint public lastTokenPriceWei;\n', '    uint public milliPercent; // "25" means 0.25%\n', '    uint public paymentsCount; // restart on each stage\n', '    bool public sealed;\n', '    modifier notSealed {\n', '        require(sealed == false);\n', '        _;\n', '    }\n', '\n', '    event Mint(address indexed _who, uint _tokens, uint _coinType, bytes32 _txHash);\n', '    event Stage(uint _stage, bool startNotFinish);\n', '\n', '    function Crowdsale() public Token() {\n', '        totalSupply = 100000000*100000000;\n', '        holders[this].balance = totalSupply;\n', '    }\n', '\n', '    function startStage(uint _startTokenPriceWei, uint _tokensForSale, uint _milliPercent) public onlyOwner notSealed {\n', '        require(!started);\n', '        require(_startTokenPriceWei >= lastTokenPriceWei);\n', '        startTokenPriceWei = _startTokenPriceWei;\n', '        tokensForSale = _tokensForSale * 100000000;\n', '        if(tokensForSale > holders[this].balance) {\n', '            tokensForSale = holders[this].balance;\n', '        }\n', '        milliPercent = _milliPercent;\n', '        startTime = now;\n', '        started = true;\n', '        paymentsCount = 0;\n', '        emit Stage(stage, started);\n', '    }\n', '    \n', '    function currentTokenPrice() public constant returns(uint) {\n', '        uint price;\n', '        if(!sealed && started) {\n', '            uint d = (now - startTime) / 1 days;\n', '            price = startTokenPriceWei;\n', '            price += startTokenPriceWei * d * milliPercent / 100;\n', '        }\n', '        return price;\n', '    }\n', '    \n', '    function stopStage() public onlyOwner notSealed {\n', '        require(started);\n', '        started = false;\n', '        lastTokenPriceWei = currentTokenPrice();\n', '        emit Stage(stage, started);\n', '        ++stage;\n', '    }\n', '    \n', '    function () payable public notSealed {\n', '        require(started);\n', '        uint price = currentTokenPrice();\n', '        if(paymentsCount < 100) {\n', '            price = price * 90 / 100;\n', '        }\n', '        ++paymentsCount;\n', '        uint tokens = 100000000 * msg.value / price;\n', '        if(tokens > tokensForSale) {\n', '            tokens = tokensForSale;\n', '            uint sumWei = tokens * lastTokenPriceWei / 100000000;\n', '            require(msg.sender.call.gas(3000000).value(msg.value - sumWei)());\n', '        }\n', '        require(tokens > 0);\n', '        require(holders[msg.sender].balance + tokens > holders[msg.sender].balance); // overflow\n', '        tokensForSale -= tokens;\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(this);\n', '        holders[msg.sender].balance += tokens;\n', '        holders[this].balance -= tokens;\n', '        emit Transfer(this, msg.sender, tokens);\n', '    }\n', '\n', '    function mintTokens1(address _who, uint _tokens, uint _coinType, bytes32 _txHash) public notSealed {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        require(started);\n', '        _tokens *= 100000000;\n', '        if(_tokens > tokensForSale) {\n', '            _tokens = tokensForSale;\n', '        }\n', '        require(_tokens > 0);\n', '        require(holders[_who].balance + _tokens > holders[_who].balance); // overflow\n', '        tokensForSale -= _tokens;\n', '        beforeBalanceChanges(_who);\n', '        beforeBalanceChanges(this);\n', '        holders[_who].balance += _tokens;\n', '        holders[this].balance -= _tokens;\n', '        emit Mint(_who, _tokens, _coinType, _txHash);\n', '        emit Transfer(this, _who, _tokens);\n', '    }\n', '    \n', '    // must be called by owners only out of stage\n', '    function mintTokens2(address _who, uint _tokens, uint _vesting) public notSealed {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        require(!started);\n', '        require(_tokens > 0);\n', '        _tokens *= 100000000;\n', '        require(_tokens <= holders[this].balance);\n', '        require(holders[_who].balance + _tokens > holders[_who].balance); // overflow\n', '        if(_vesting != 0) {\n', '            vesting[_who] = _vesting;\n', '        }\n', '        beforeBalanceChanges(_who);\n', '        beforeBalanceChanges(this);\n', '        holders[_who].balance += _tokens;\n', '        holders[this].balance -= _tokens;\n', '        emit Mint(_who, _tokens, 0, 0);\n', '        emit Transfer(this, _who, _tokens);\n', '    }\n', '\n', '    // need to seal Crowdsale when it is finished completely\n', '    function seal() public onlyOwner {\n', '        sealed = true;\n', '    }\n', '}\n', '\n', 'contract Ehfirst is Crowdsale {\n', '\n', '   function Ehfirst() payable public Crowdsale() {}\n', '\n', '    function setBackend(address _backend) public onlyOwner {\n', '        backend = _backend;\n', '    }\n', '    \n', '    function withdraw() public onlyOwner {\n', '        require(owner.call.gas(3000000).value(address(this).balance)());\n', '    }\n', '    \n', '    function freezeTheMoment() public onlyOwner {\n', '        freezedMoment = now;\n', '    }\n', '\n', '    /** Get balance of _who for freezed moment\n', '     *  freezeTheMoment()\n', '     */\n', '    function freezedBalanceOf(address _who) constant public returns(uint) {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            return holders[_who].balance;\n', '        } else {\n', '            return holders[_who].balanceBeforeUpdate;\n', '        }\n', '    }\n', '}']
['/*\n', 'This file is part of the eHealth First Contract.\n', '\n', 'www.ehfirst.io\n', '\n', 'An IT-platform for Personalized Health and Longevity Management\n', 'based on Blockchain, Artificial Intelligence,\n', 'Machine Learning and Natural Language Processing\n', '\n', 'The eHealth First Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The eHealth First Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the eHealth First Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@prover.ru>\n', '\n', 'IF YOU ARE ENJOYED IT DONATE TO 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B ! :)\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '  function owned() public payable {\n', '         owner = msg.sender;\n', '     }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public;\n', '    function approve(address spender, uint value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract Token is owned, ERC20 {\n', '\n', "    string  public standard    = 'Token 0.1';\n", "    string  public name        = 'eHealth First';\n", '    string  public symbol      = "EHF";\n', '    uint8   public decimals    = 8;\n', '\n', '    uint    public freezedMoment;\n', '\n', '    struct TokenHolder {\n', '        uint balance;\n', '        uint balanceBeforeUpdate;\n', '        uint balanceUpdateTime;\n', '    }\n', '    mapping (address => TokenHolder) public holders;\n', '    mapping (address => uint) public vesting;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    address public vestingManager;\n', '\n', '    function setVestingManager(address _vestingManager) public onlyOwner {\n', '        vestingManager = _vestingManager;\n', '    }\n', '\n', '    function beforeBalanceChanges(address _who) internal {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            holders[_who].balanceUpdateTime = now;\n', '            holders[_who].balanceBeforeUpdate = holders[_who].balance;\n', '        }\n', '    }\n', '\n', '    event Burned(address indexed owner, uint256 value);\n', '\n', '    function Token() public owned() {}\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return holders[_who].balance;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(now > vesting[msg.sender] || msg.sender == vestingManager);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(_to);\n', '        holders[msg.sender].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        if (vesting[_to] < vesting[msg.sender]) {\n', '            vesting[_to] = vesting[msg.sender];\n', '        }\n', '        emit Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public {\n', '        require(now > vesting[_from]);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        beforeBalanceChanges(_from);\n', '        beforeBalanceChanges(_to);\n', '        holders[_from].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant\n', '        returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function burn(uint256 _value) public {\n', '        require(holders[msg.sender].balance >= _value);\n', '        beforeBalanceChanges(msg.sender);\n', '        holders[msg.sender].balance -= _value;\n', '        totalSupply -= _value;\n', '        emit Burned(msg.sender, _value);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is Token {\n', '\n', '    address public backend;\n', '\n', '    uint public stage;\n', '    bool public started;\n', '    uint public startTokenPriceWei;\n', '    uint public tokensForSale;\n', '    uint public startTime;\n', '    uint public lastTokenPriceWei;\n', '    uint public milliPercent; // "25" means 0.25%\n', '    uint public paymentsCount; // restart on each stage\n', '    bool public sealed;\n', '    modifier notSealed {\n', '        require(sealed == false);\n', '        _;\n', '    }\n', '\n', '    event Mint(address indexed _who, uint _tokens, uint _coinType, bytes32 _txHash);\n', '    event Stage(uint _stage, bool startNotFinish);\n', '\n', '    function Crowdsale() public Token() {\n', '        totalSupply = 100000000*100000000;\n', '        holders[this].balance = totalSupply;\n', '    }\n', '\n', '    function startStage(uint _startTokenPriceWei, uint _tokensForSale, uint _milliPercent) public onlyOwner notSealed {\n', '        require(!started);\n', '        require(_startTokenPriceWei >= lastTokenPriceWei);\n', '        startTokenPriceWei = _startTokenPriceWei;\n', '        tokensForSale = _tokensForSale * 100000000;\n', '        if(tokensForSale > holders[this].balance) {\n', '            tokensForSale = holders[this].balance;\n', '        }\n', '        milliPercent = _milliPercent;\n', '        startTime = now;\n', '        started = true;\n', '        paymentsCount = 0;\n', '        emit Stage(stage, started);\n', '    }\n', '    \n', '    function currentTokenPrice() public constant returns(uint) {\n', '        uint price;\n', '        if(!sealed && started) {\n', '            uint d = (now - startTime) / 1 days;\n', '            price = startTokenPriceWei;\n', '            price += startTokenPriceWei * d * milliPercent / 100;\n', '        }\n', '        return price;\n', '    }\n', '    \n', '    function stopStage() public onlyOwner notSealed {\n', '        require(started);\n', '        started = false;\n', '        lastTokenPriceWei = currentTokenPrice();\n', '        emit Stage(stage, started);\n', '        ++stage;\n', '    }\n', '    \n', '    function () payable public notSealed {\n', '        require(started);\n', '        uint price = currentTokenPrice();\n', '        if(paymentsCount < 100) {\n', '            price = price * 90 / 100;\n', '        }\n', '        ++paymentsCount;\n', '        uint tokens = 100000000 * msg.value / price;\n', '        if(tokens > tokensForSale) {\n', '            tokens = tokensForSale;\n', '            uint sumWei = tokens * lastTokenPriceWei / 100000000;\n', '            require(msg.sender.call.gas(3000000).value(msg.value - sumWei)());\n', '        }\n', '        require(tokens > 0);\n', '        require(holders[msg.sender].balance + tokens > holders[msg.sender].balance); // overflow\n', '        tokensForSale -= tokens;\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(this);\n', '        holders[msg.sender].balance += tokens;\n', '        holders[this].balance -= tokens;\n', '        emit Transfer(this, msg.sender, tokens);\n', '    }\n', '\n', '    function mintTokens1(address _who, uint _tokens, uint _coinType, bytes32 _txHash) public notSealed {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        require(started);\n', '        _tokens *= 100000000;\n', '        if(_tokens > tokensForSale) {\n', '            _tokens = tokensForSale;\n', '        }\n', '        require(_tokens > 0);\n', '        require(holders[_who].balance + _tokens > holders[_who].balance); // overflow\n', '        tokensForSale -= _tokens;\n', '        beforeBalanceChanges(_who);\n', '        beforeBalanceChanges(this);\n', '        holders[_who].balance += _tokens;\n', '        holders[this].balance -= _tokens;\n', '        emit Mint(_who, _tokens, _coinType, _txHash);\n', '        emit Transfer(this, _who, _tokens);\n', '    }\n', '    \n', '    // must be called by owners only out of stage\n', '    function mintTokens2(address _who, uint _tokens, uint _vesting) public notSealed {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        require(!started);\n', '        require(_tokens > 0);\n', '        _tokens *= 100000000;\n', '        require(_tokens <= holders[this].balance);\n', '        require(holders[_who].balance + _tokens > holders[_who].balance); // overflow\n', '        if(_vesting != 0) {\n', '            vesting[_who] = _vesting;\n', '        }\n', '        beforeBalanceChanges(_who);\n', '        beforeBalanceChanges(this);\n', '        holders[_who].balance += _tokens;\n', '        holders[this].balance -= _tokens;\n', '        emit Mint(_who, _tokens, 0, 0);\n', '        emit Transfer(this, _who, _tokens);\n', '    }\n', '\n', '    // need to seal Crowdsale when it is finished completely\n', '    function seal() public onlyOwner {\n', '        sealed = true;\n', '    }\n', '}\n', '\n', 'contract Ehfirst is Crowdsale {\n', '\n', '   function Ehfirst() payable public Crowdsale() {}\n', '\n', '    function setBackend(address _backend) public onlyOwner {\n', '        backend = _backend;\n', '    }\n', '    \n', '    function withdraw() public onlyOwner {\n', '        require(owner.call.gas(3000000).value(address(this).balance)());\n', '    }\n', '    \n', '    function freezeTheMoment() public onlyOwner {\n', '        freezedMoment = now;\n', '    }\n', '\n', '    /** Get balance of _who for freezed moment\n', '     *  freezeTheMoment()\n', '     */\n', '    function freezedBalanceOf(address _who) constant public returns(uint) {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            return holders[_who].balance;\n', '        } else {\n', '            return holders[_who].balanceBeforeUpdate;\n', '        }\n', '    }\n', '}']
