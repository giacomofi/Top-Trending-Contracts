['pragma solidity ^0.4.23;\n', '\n', '/**\n', 'A PennyAuction-like game to win a prize.\n', '\n', 'UI: https://www.pennyether.com\n', '\n', 'How it works:\n', '    - An initial prize is held in the Contract\n', '    - Anyone may overthrow the Monarch by paying a small fee.\n', '        - They become the Monarch\n', '        - The "reign" timer is reset to N.\n', '        - The prize may be increased or decreased\n', '    - If nobody overthrows the new Monarch in N blocks, the Monarch wins.\n', '\n', 'For fairness, an "overthrow" is refunded if:\n', '    - The incorrect amount is sent.\n', '    - The game is already over.\n', '    - The overthrower is already the Monarch.\n', '    - Another overthrow occurred in the same block\n', '        - Note: Here, default gas is used for refund. On failure, fee is kept.\n', '\n', 'Other notes:\n', '    - .sendFees(): Sends accrued fees to "collector", at any time.\n', '    - .sendPrize(): If game is ended, sends prize to the Monarch.\n', '*/\n', 'contract MonarchyGame {\n', '    // We store values as GWei to reduce storage to 64 bits.\n', '    // int64: 2^63 GWei is ~ 9 billion Ether, so no overflow risk.\n', '    //\n', '    // For blocks, we use uint32, which has a max value of 4.3 billion\n', '    // At a 1 second block time, there&#39;s a risk of overflow in 120 years.\n', '    //\n', '    // We put these variables together because they are all written to\n', '    // on each bid. This should save some gas when we write.\n', '    struct Vars {\n', '        // [first 256-bit segment]\n', '        address monarch;        // address of monarch\n', '        uint64 prizeGwei;       // (Gwei) the current prize\n', '        uint32 numOverthrows;   // total number of overthrows\n', '\n', '        // [second 256-bit segment]\n', '        uint32 blockEnded;      // the time at which no further overthrows can occur  \n', '        uint32 prevBlock;       // block of the most recent overthrow\n', '        bool isPaid;            // whether or not the winner has been paid\n', '        bytes23 decree;         // 23 leftover bytes for decree\n', '    }\n', '\n', '    // These values are set on construction and don&#39;t change.\n', '    // We store in a struct for gas-efficient reading/writing.\n', '    struct Settings {\n', '        // [first 256-bit segment]\n', '        address collector;       // address that fees get sent to\n', '        uint64 initialPrizeGwei; // (Gwei > 0) amt initially staked\n', '        // [second 256-bit segment]\n', '        uint64 feeGwei;          // (Gwei > 0) cost to become the Monarch\n', '        int64 prizeIncrGwei;     // amount added/removed to prize on overthrow\n', '        uint32 reignBlocks;      // number of blocks Monarch must reign to win\n', '    }\n', '\n', '    Vars vars;\n', '    Settings settings;\n', '    uint constant version = 1;\n', '\n', '    event SendPrizeError(uint time, string msg);\n', '    event Started(uint time, uint initialBlocks);\n', '    event OverthrowOccurred(uint time, address indexed newMonarch, bytes23 decree, address indexed prevMonarch, uint fee);\n', '    event OverthrowRefundSuccess(uint time, string msg, address indexed recipient, uint amount);\n', '    event OverthrowRefundFailure(uint time, string msg, address indexed recipient, uint amount);\n', '    event SendPrizeSuccess(uint time, address indexed redeemer, address indexed recipient, uint amount, uint gasLimit);\n', '    event SendPrizeFailure(uint time, address indexed redeemer, address indexed recipient, uint amount, uint gasLimit);\n', '    event FeesSent(uint time, address indexed collector, uint amount);\n', '\n', '    constructor(\n', '        address _collector,\n', '        uint _initialPrize,\n', '        uint _fee,\n', '        int _prizeIncr,\n', '        uint _reignBlocks,\n', '        uint _initialBlocks\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        require(_initialPrize >= 1e9);                // min value of 1 GWei\n', '        require(_initialPrize < 1e6 * 1e18);          // max value of a million ether\n', '        require(_initialPrize % 1e9 == 0);            // even amount of GWei\n', '        require(_fee >= 1e6);                         // min value of 1 GWei\n', '        require(_fee < 1e6 * 1e18);                   // max value of a million ether\n', '        require(_fee % 1e9 == 0);                     // even amount of GWei\n', '        require(_prizeIncr <= int(_fee));             // max value of _bidPrice\n', '        require(_prizeIncr >= -1*int(_initialPrize)); // min value of -1*initialPrize\n', '        require(_prizeIncr % 1e9 == 0);               // even amount of GWei\n', '        require(_reignBlocks >= 1);                   // minimum of 1 block\n', '        require(_initialBlocks >= 1);                 // minimum of 1 block\n', '        require(msg.value == _initialPrize);          // must&#39;ve sent the prize amount\n', '\n', '        // Set instance variables. these never change.\n', '        // These can be safely cast to int64 because they are each < 1e24 (see above),\n', '        // 1e24 divided by 1e9 is 1e15. Max int64 val is ~1e19, so plenty of room.\n', '        // For block numbers, uint32 is good up to ~4e12, a long time from now.\n', '        settings.collector = _collector;\n', '        settings.initialPrizeGwei = uint64(_initialPrize / 1e9);\n', '        settings.feeGwei = uint64(_fee / 1e9);\n', '        settings.prizeIncrGwei = int64(_prizeIncr / 1e9);\n', '        settings.reignBlocks = uint32(_reignBlocks);\n', '\n', '        // Initialize the game variables.\n', '        vars.prizeGwei = settings.initialPrizeGwei;\n', '        vars.monarch = _collector;\n', '        vars.prevBlock = uint32(block.number);\n', '        vars.blockEnded = uint32(block.number + _initialBlocks);\n', '\n', '        emit Started(now, _initialBlocks);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** OVERTHROWING *************************************/\n', '    /*************************************************************/\n', '    //\n', '    // Upon new bid, adds fees and increments time and prize.\n', '    //  - Refunds if overthrow is too late, user is already monarch, or incorrect value passed.\n', '    //  - Upon an overthrow-in-same-block, refends previous monarch.\n', '    //\n', '    // Gas Cost: 34k - 50k\n', '    //     Overhead: 25k\n', '    //       - 23k: tx overhead\n', '    //       -  2k: SLOADs, execution\n', '    //     Failure: 34k\n', '    //       - 25k: overhead\n', '    //       -  7k: send refund\n', '    //       -  2k: event: OverthrowRefundSuccess\n', '    //     Clean: 37k\n', '    //       - 25k: overhead\n', '    //       - 10k: update Vars (monarch, numOverthrows, prize, blockEnded, prevBlock, decree)\n', '    //       -  2k: event: OverthrowOccurred\n', '    //     Refund Success: 46k\n', '    //       - 25k: overhead\n', '    //       -  7k: send\n', '    //       - 10k: update Vars (monarch, decree)\n', '    //       -  2k: event: OverthrowRefundSuccess\n', '    //       -  2k: event: OverthrowOccurred\n', '    //     Refund Failure: 50k\n', '    //       - 25k: overhead\n', '    //       - 11k: send failure\n', '    //       - 10k: update Vars (monarch, numOverthrows, prize, decree)\n', '    //       -  2k: event: OverthrowRefundFailure\n', '    //       -  2k: event: OverthrowOccurred\n', '    function()\n', '        public\n', '        payable\n', '    {\n', '        overthrow(0);\n', '    }\n', '\n', '    function overthrow(bytes23 _decree)\n', '        public\n', '        payable\n', '    {\n', '        if (isEnded())\n', '            return errorAndRefund("Game has already ended.");\n', '        if (msg.sender == vars.monarch)\n', '            return errorAndRefund("You are already the Monarch.");\n', '        if (msg.value != fee())\n', '            return errorAndRefund("Value sent must match fee.");\n', '\n', '        // compute new values. hopefully optimizer reads from vars/settings just once.\n', '        int _newPrizeGwei = int(vars.prizeGwei) + settings.prizeIncrGwei;\n', '        uint32 _newBlockEnded = uint32(block.number) + settings.reignBlocks;\n', '        uint32 _newNumOverthrows = vars.numOverthrows + 1;\n', '        address _prevMonarch = vars.monarch;\n', '        bool _isClean = (block.number != vars.prevBlock);\n', '\n', '        // Refund if _newPrize would end up being < 0.\n', '        if (_newPrizeGwei < 0)\n', '            return errorAndRefund("Overthrowing would result in a negative prize.");\n', '\n', '        // Attempt refund, if necessary. Use minimum gas.\n', '        bool _wasRefundSuccess;\n', '        if (!_isClean) {\n', '            _wasRefundSuccess = _prevMonarch.send(msg.value);   \n', '        }\n', '\n', '        // These blocks can be made nicer, but optimizer will\n', '        //  sometimes do two updates instead of one. Seems it is\n', '        //  best to keep if/else trees flat.\n', '        if (_isClean) {\n', '            vars.monarch = msg.sender;\n', '            vars.numOverthrows = _newNumOverthrows;\n', '            vars.prizeGwei = uint64(_newPrizeGwei);\n', '            vars.blockEnded = _newBlockEnded;\n', '            vars.prevBlock = uint32(block.number);\n', '            vars.decree = _decree;\n', '        }\n', '        if (!_isClean && _wasRefundSuccess){\n', '            // when a refund occurs, we just swap winners.\n', '            // overthrow count and prize do not get reset.\n', '            vars.monarch = msg.sender;\n', '            vars.decree = _decree;\n', '        }\n', '        if (!_isClean && !_wasRefundSuccess){\n', '            vars.monarch = msg.sender;   \n', '            vars.prizeGwei = uint64(_newPrizeGwei);\n', '            vars.numOverthrows = _newNumOverthrows;\n', '            vars.decree = _decree;\n', '        }\n', '\n', '        // Emit the proper events.\n', '        if (!_isClean){\n', '            if (_wasRefundSuccess)\n', '                emit OverthrowRefundSuccess(now, "Another overthrow occurred on the same block.", _prevMonarch, msg.value);\n', '            else\n', '                emit OverthrowRefundFailure(now, ".send() failed.", _prevMonarch, msg.value);\n', '        }\n', '        emit OverthrowOccurred(now, msg.sender, _decree, _prevMonarch, msg.value);\n', '    }\n', '        // called from the bidding function above.\n', '        // refunds sender, or throws to revert entire tx.\n', '        function errorAndRefund(string _msg)\n', '            private\n', '        {\n', '            require(msg.sender.call.value(msg.value)());\n', '            emit OverthrowRefundSuccess(now, _msg, msg.sender, msg.value);\n', '        }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** PUBLIC FUNCTIONS *********************************/\n', '    /*************************************************************/\n', '\n', '    // Sends prize to the current winner using _gasLimit (0 is unlimited)\n', '    function sendPrize(uint _gasLimit)\n', '        public\n', '        returns (bool _success, uint _prizeSent)\n', '    {\n', '        // make sure game has ended, and is not paid\n', '        if (!isEnded()) {\n', '            emit SendPrizeError(now, "The game has not ended.");\n', '            return (false, 0);\n', '        }\n', '        if (vars.isPaid) {\n', '            emit SendPrizeError(now, "The prize has already been paid.");\n', '            return (false, 0);\n', '        }\n', '\n', '        address _winner = vars.monarch;\n', '        uint _prize = prize();\n', '        bool _paySuccessful = false;\n', '\n', '        // attempt to pay winner (use full gas if _gasLimit is 0)\n', '        vars.isPaid = true;\n', '        if (_gasLimit == 0) {\n', '            _paySuccessful = _winner.call.value(_prize)();\n', '        } else {\n', '            _paySuccessful = _winner.call.value(_prize).gas(_gasLimit)();\n', '        }\n', '\n', '        // emit proper event. rollback .isPaid on failure.\n', '        if (_paySuccessful) {\n', '            emit SendPrizeSuccess({\n', '                time: now,\n', '                redeemer: msg.sender,\n', '                recipient: _winner,\n', '                amount: _prize,\n', '                gasLimit: _gasLimit\n', '            });\n', '            return (true, _prize);\n', '        } else {\n', '            vars.isPaid = false;\n', '            emit SendPrizeFailure({\n', '                time: now,\n', '                redeemer: msg.sender,\n', '                recipient: _winner,\n', '                amount: _prize,\n', '                gasLimit: _gasLimit\n', '            });\n', '            return (false, 0);          \n', '        }\n', '    }\n', '    \n', '    // Sends accrued fees to the collector. Callable by anyone.\n', '    function sendFees()\n', '        public\n', '        returns (uint _feesSent)\n', '    {\n', '        _feesSent = fees();\n', '        if (_feesSent == 0) return;\n', '        require(settings.collector.call.value(_feesSent)());\n', '        emit FeesSent(now, settings.collector, _feesSent);\n', '    }\n', '\n', '\n', '\n', '    /*************************************************************/\n', '    /********** PUBLIC VIEWS *************************************/\n', '    /*************************************************************/\n', '\n', '    // Expose all Vars ////////////////////////////////////////\n', '    function monarch() public view returns (address) {\n', '        return vars.monarch;\n', '    }\n', '    function prize() public view returns (uint) {\n', '        return uint(vars.prizeGwei) * 1e9;\n', '    }\n', '    function numOverthrows() public view returns (uint) {\n', '        return vars.numOverthrows;\n', '    }\n', '    function blockEnded() public view returns (uint) {\n', '        return vars.blockEnded;\n', '    }\n', '    function prevBlock() public view returns (uint) {\n', '        return vars.prevBlock;\n', '    }\n', '    function isPaid() public view returns (bool) {\n', '        return vars.isPaid;\n', '    }\n', '    function decree() public view returns (bytes23) {\n', '        return vars.decree;\n', '    }\n', '    ///////////////////////////////////////////////////////////\n', '\n', '    // Expose all Settings //////////////////////////////////////\n', '    function collector() public view returns (address) {\n', '        return settings.collector;\n', '    }\n', '    function initialPrize() public view returns (uint){\n', '        return uint(settings.initialPrizeGwei) * 1e9;\n', '    }\n', '    function fee() public view returns (uint) {\n', '        return uint(settings.feeGwei) * 1e9;\n', '    }\n', '    function prizeIncr() public view returns (int) {\n', '        return int(settings.prizeIncrGwei) * 1e9;\n', '    }\n', '    function reignBlocks() public view returns (uint) {\n', '        return settings.reignBlocks;\n', '    }\n', '    ///////////////////////////////////////////////////////////\n', '\n', '    // The following are computed /////////////////////////////\n', '    function isEnded() public view returns (bool) {\n', '        return block.number > vars.blockEnded;\n', '    }\n', '    function getBlocksRemaining() public view returns (uint) {\n', '        if (isEnded()) return 0;\n', '        return (vars.blockEnded - block.number) + 1;\n', '    }\n', '    function fees() public view returns (uint) {\n', '        uint _balance = address(this).balance;\n', '        return vars.isPaid ? _balance : _balance - prize();\n', '    }\n', '    function totalFees() public view returns (uint) {\n', '        int _feePerOverthrowGwei = int(settings.feeGwei) - settings.prizeIncrGwei;\n', '        return uint(_feePerOverthrowGwei * vars.numOverthrows * 1e9);\n', '    }\n', '    ///////////////////////////////////////////////////////////\n', '}']