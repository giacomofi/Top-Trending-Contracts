['pragma solidity ^0.4.24;\n', '\n', 'contract ETHerNity {\n', '    \n', '    struct Tx {\n', '        address user;\n', '        uint value;\n', '    }\n', '    \n', '    address public owner;\n', '    Tx[] public txs;\n', '    bool blocking;\n', '    \n', '    uint constant MIN_ETHER = 0.01 ether;\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier mutex() {\n', '        blocking = true;\n', '        _;\n', '        blocking = false;\n', '    }\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function() payable public {\n', '        withReferrer(owner);\n', '        \n', '        if (msg.sender == owner) {\n', '            dispatch();\n', '        }\n', '    }\n', '    \n', '    function withReferrer(address referrar) payable public {\n', '        if (blocking) return;\n', '        \n', '        owner.send(msg.value / 10);\n', '        referrar.send(msg.value / 10);\n', '        \n', '        if (msg.value < MIN_ETHER)\n', '            return;\n', '\n', '        txs.push(Tx({\n', '           user: msg.sender,\n', '           value: msg.value / 30\n', '        }));\n', '    }\n', '    \n', '    function dispatch() onlyOwner mutex public {\n', '        for(uint i = 0; i < txs.length; i++) {\n', '            if (address(this).balance >= txs[i].value)\n', '                txs[i].user.send(txs[i].value);\n', '        }\n', '            \n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ETHerNity {\n', '    \n', '    struct Tx {\n', '        address user;\n', '        uint value;\n', '    }\n', '    \n', '    address public owner;\n', '    Tx[] public txs;\n', '    bool blocking;\n', '    \n', '    uint constant MIN_ETHER = 0.01 ether;\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier mutex() {\n', '        blocking = true;\n', '        _;\n', '        blocking = false;\n', '    }\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function() payable public {\n', '        withReferrer(owner);\n', '        \n', '        if (msg.sender == owner) {\n', '            dispatch();\n', '        }\n', '    }\n', '    \n', '    function withReferrer(address referrar) payable public {\n', '        if (blocking) return;\n', '        \n', '        owner.send(msg.value / 10);\n', '        referrar.send(msg.value / 10);\n', '        \n', '        if (msg.value < MIN_ETHER)\n', '            return;\n', '\n', '        txs.push(Tx({\n', '           user: msg.sender,\n', '           value: msg.value / 30\n', '        }));\n', '    }\n', '    \n', '    function dispatch() onlyOwner mutex public {\n', '        for(uint i = 0; i < txs.length; i++) {\n', '            if (address(this).balance >= txs[i].value)\n', '                txs[i].user.send(txs[i].value);\n', '        }\n', '            \n', '    }\n', '\n', '}']
