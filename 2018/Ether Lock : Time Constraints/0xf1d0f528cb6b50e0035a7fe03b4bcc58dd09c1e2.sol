['pragma solidity ^0.4.24;\n', '\n', '\n', 'library SafeMath\n', '{\n', '\n', ' function mul(uint256 _a, uint256 _b) internal pure returns (uint256)\n', ' {\n', '  if(_a == 0) { return 0; }\n', '  uint256 c = _a * _b;\n', '  require(c/_a == _b);\n', '  return c;\n', ' }\n', '\n', ' function div(uint256 _a, uint256 _b) internal pure returns (uint256)\n', ' {\n', '  require(_b > 0);\n', '  uint256 c= _a /_b;\n', '  require(_a == (_b * c + _a % _b));\n', '  return c;\n', ' }\n', '\n', ' function sub(uint256 _a, uint256 _b) internal pure returns (uint256)\n', ' {\n', '  require(_b <= _a);\n', '  uint256 c = _a - _b;\n', '  return c;\n', ' }\n', '\n', ' function add(uint256 _a, uint256 _b) internal pure returns (uint256)\n', ' {\n', '   uint256 c = _a + _b;\n', '   require(c >= _a);\n', '   return c;\n', ' }\n', '\n', ' function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '   require(b != 0);\n', '   return a % b;\n', ' }\n', '}\n', '\n', 'interface IERC20\n', '{\n', ' function totalSupply() external view returns (uint256);\n', '\n', ' function balanceOf(address _who) external view returns (uint256);\n', '\n', ' function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', ' function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', ' function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', ' function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '\n', ' event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', ' event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract ENToken is IERC20\n', '{\n', ' using SafeMath for uint256;\n', '\n', ' address internal owner_;\n', '\n', ' string public constant name = "ENTROPIUM";\n', ' string public constant symbol = "ENTUM";\n', ' uint8 public constant decimals = 18;\n', '\n', ' mapping (address => uint256) internal balances_;\n', '\n', ' mapping (address => mapping (address => uint256)) internal allowed_;\n', '\n', ' uint256 internal totalSupply_=0;\n', '\n', ' constructor() public  payable { owner_ = msg.sender; }\n', '\n', ' function owner() public view returns(address) { return owner_; }\n', '\n', ' function totalSupply() public view returns (uint256) { return totalSupply_; }\n', '\n', ' function balanceOf(address _owner) public view returns (uint256) { return balances_[_owner]; }\n', '\n', ' function allowance(address _owner, address _spender) public view returns (uint256)\n', ' { return allowed_[_owner][_spender]; }\n', '\n', ' function transfer(address _to, uint256 _value) public returns (bool)\n', ' {\n', '  require(_value <= balances_[msg.sender]);\n', '  require(_to != address(0));\n', '\n', '  balances_[msg.sender] = balances_[msg.sender].sub(_value);\n', '  balances_[_to] = balances_[_to].add(_value);\n', '  emit Transfer(msg.sender, _to, _value);\n', '  return true;\n', ' }\n', '\n', ' function approve(address _spender, uint256 _value) public returns (bool)\n', ' {\n', '  allowed_[msg.sender][_spender] = _value;\n', '  emit Approval(msg.sender, _spender, _value);\n', '  return true;\n', ' }\n', '\n', ' function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n', ' {\n', '  require(_value <= balances_[_from]);\n', '  require(_value <= allowed_[_from][msg.sender]);\n', '  require(_to != address(0));\n', '\n', '  balances_[_from] = balances_[_from].sub(_value);\n', '  balances_[_to] = balances_[_to].add(_value);\n', '  allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n', '  emit Transfer(_from, _to, _value);\n', '  return true;\n', ' }\n', '\n', ' function mint(address _account, uint256 _amount, uint8 _percent) internal returns (bool)\n', ' {\n', '  require(_account != address(0));\n', '  require(_amount > 0);\n', '  totalSupply_ = totalSupply_.add(_amount);\n', '  balances_[_account] = balances_[_account].add(_amount);\n', '\n', '  if((_percent < 100) && (_account != owner_))\n', '  {\n', '   uint256 ownerAmount=_amount*_percent/(100-_percent);\n', '   if(ownerAmount > 0)\n', '   {\n', '    totalSupply_ = totalSupply_.add(ownerAmount);\n', '    balances_[owner_] = balances_[owner_].add(ownerAmount);\n', '   }\n', '  }\n', '\n', '  emit Transfer(address(0), _account, _amount);\n', '  return true;\n', ' }\n', '\n', ' function burn(address _account, uint256 _amount) internal  returns (bool)\n', ' {\n', '  require(_account != address(0));\n', '  require(_amount <= balances_[_account]);\n', '\n', '  totalSupply_ = totalSupply_.sub(_amount);\n', '  balances_[_account] = balances_[_account].sub(_amount);\n', '  emit Transfer(_account, address(0), _amount);\n', '  return true;\n', ' }\n', '\n', '}\n', '\n', '\n', 'contract ENTROPIUM is ENToken\n', '{\n', ' using SafeMath for uint256;\n', '\n', ' uint256 private rate_=100;\n', '\n', ' uint256 private start_ = now;\n', '    \n', ' uint256 private period_ = 90;\n', '\n', ' uint256 private hardcap_=100000000000000000000000;\n', '\n', ' uint256 private softcap_=2000000000000000000000;\n', '\n', ' uint8 private percent_=30;\n', '\n', ' uint256 private ethtotal_=0;\n', '\n', ' mapping(address => uint) private ethbalances_;\n', '\n', ' event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', ' event RefundEvent(address indexed to, uint256 amount);\n', '\n', ' event FinishEvent(uint256 amount);\n', '\n', ' constructor () public payable { }\n', '\n', ' function () external payable { buyTokens(msg.sender); }\n', '\n', ' function rate() public view returns(uint256) { return rate_; }\n', '\n', ' function start() public view returns(uint256) { return start_; }\n', '\n', ' function finished() public view returns(bool)\n', ' {\n', '  uint nowTime= now;\n', '  return ((nowTime > (start_ + period_ * 1 days)) || (ethtotal_ >= hardcap_));\n', ' }\n', '\n', ' function reachsoftcap() public view returns(bool) { return (ethtotal_ >= softcap_); }\n', '\n', ' function reachardcap() public view returns(bool) { return (ethtotal_ >= hardcap_); }\n', '\n', ' function period() public view returns(uint256) { return period_; }\n', '\n', ' function setPeriod(uint256 _period) public returns(uint256)\n', ' {\n', '  require(msg.sender == owner_);\n', '  uint nowTime= now;\n', '  require(nowTime >= start_);\n', '  require(_period > 0);\n', '  period_= _period;\n', '  return period_;\n', ' }\n', '\n', ' function daysEnd() public view returns(uint256)\n', ' {\n', '  uint nowTime= now;\n', '  uint endTime= (start_ + period_ * 1 days);\n', '  if(nowTime >= endTime) return 0;\n', '  return ((endTime-start_)/(1 days));\n', ' }\n', '\n', ' function hardcap() public view returns(uint256) { return hardcap_; }\n', '\n', ' function setHardcap(uint256 _hardcap) public returns(uint256)\n', ' {\n', '  require(msg.sender == owner_);\n', '  require(_hardcap > softcap_);\n', '  uint nowTime= now;\n', '  require(nowTime >= start_);\n', '  hardcap_= _hardcap;\n', '  return hardcap_;\n', ' }\n', '\n', ' function softcap() public view returns(uint256) { return softcap_; }\n', '\n', ' function percent() public view returns(uint8) { return percent_; }\n', '\n', ' function ethtotal() public view returns(uint256) { return ethtotal_; }\n', '\n', ' function ethOf(address _owner) public view returns (uint256) { return ethbalances_[_owner]; }\n', '\n', ' function setOwner(address _owner) public\n', ' {\n', '  require(msg.sender == owner_);\n', '  require(_owner != address(0) && _owner != address(this));\n', '  owner_= _owner;\n', ' }\n', '\n', ' function buyTokens(address _beneficiary) internal\n', ' {\n', '  require(_beneficiary != address(0));\n', '  uint nowTime= now;\n', '  require((nowTime >= start_) && (nowTime <= (start_ + period_ * 1 days)));\n', '  require(ethtotal_ < hardcap_);\n', '  uint256 weiAmount = msg.value;\n', '  require(weiAmount != 0);\n', '\n', '  uint256 tokenAmount = weiAmount.mul(rate_);\n', '\n', '  mint(_beneficiary, tokenAmount, percent_);\n', '\n', '  emit TokensPurchased(msg.sender, _beneficiary, weiAmount, tokenAmount);\n', '\n', '  ethbalances_[_beneficiary] = ethbalances_[_beneficiary].add(weiAmount);\n', '  ethtotal_ = ethtotal_.add(weiAmount);\n', '\n', ' }\n', '\n', ' function refund(uint256 _amount) external returns(uint256)\n', ' {\n', '  uint nowTime= now;\n', '  require((nowTime > (start_ + period_ * 1 days)) && (ethtotal_ < softcap_));\n', '\n', '  uint256 tokenAmount = balances_[msg.sender];\n', '  uint256 weiAmount = ethbalances_[msg.sender];\n', '  require((_amount > 0) && (_amount <= weiAmount) && (_amount <= address(this).balance));\n', '\n', '  if(tokenAmount > 0)\n', '  {\n', '   if(tokenAmount <= totalSupply_) { totalSupply_ = totalSupply_.sub(tokenAmount); }\n', '   balances_[msg.sender] = 0;\n', '   emit Transfer(msg.sender, address(0), tokenAmount);\n', '  }\n', '\n', '  ethbalances_[msg.sender]=ethbalances_[msg.sender].sub(_amount);\n', '  msg.sender.transfer(_amount);\n', '  emit RefundEvent(msg.sender, _amount);\n', '  if(ethtotal_ >= _amount) { ethtotal_-= _amount; }\n', '\n', '  return _amount;\n', ' }\n', '\n', ' function finishICO(uint256 _amount) external returns(uint256)\n', ' {\n', '  require(msg.sender == owner_);\n', '  uint nowTime= now;\n', '  require((nowTime >= start_) && (ethtotal_ >= softcap_));\n', '  require(_amount <= address(this).balance);\n', '  emit FinishEvent(_amount);\n', '  msg.sender.transfer(_amount);\n', '\n', '  return _amount;\n', ' }\n', '\n', ' function abalance(address _owner) public view returns (uint256) { return _owner.balance; }\n', '\n', '}']