['pragma solidity ^0.4.25;\n', '\n', 'contract ERC20 {\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '}\n', '\n', 'contract XEXHolder{\n', '    address private holder1_;\n', '    address private holder2_;\n', '    address private holder3_;\n', '    bool private holder1Reset_;\n', '    bool private holder2Reset_;\n', '    bool private holder3Reset_;\n', '    bool private holder1Transaction_;\n', '    bool private holder2Transaction_;\n', '    bool private holder3Transaction_;\n', '\n', '    address private token_;\n', '    uint256 private transactionNonce_;\n', '    address private transactionTo_;\n', '    uint256 private transactionValue_;\n', '\n', '    event HolderSetted(address indexed _address1,address indexed _address2,address indexed _address3);\n', '    event HolderReseted(bool _vote);\n', '    event TransactionStarted(address indexed _address,uint _value);\n', '    event TransactionConfirmed(address indexed _address,bool _vote);\n', '    event TransactionSubmitted(address indexed _address,uint _value);\n', '    \n', '    modifier onlyHolder() {\n', '        require(isHolder(msg.sender));\n', '        _;\n', '    }\n', '    \n', '    constructor(address _token) public{\n', '        token_=_token;\n', '        holder1_=msg.sender;\n', '        holder2_=address(0);\n', '        holder3_=address(0);\n', '        holder1Reset_=false;\n', '        holder2Reset_=false;\n', '        holder3Reset_=false;\n', '        holder1Transaction_=false;\n', '        holder2Transaction_=false;\n', '        holder3Transaction_=false;\n', '    }\n', '    \n', '    function isHolder(address _address) public view returns (bool) {\n', '        if(_address==address(0)){\n', '            return false;\n', '        }\n', '        return _address==holder1_ || _address==holder2_ || _address==holder3_;\n', '    }\n', '    \n', '    function setHolder(address _address1,address _address2,address _address3) public onlyHolder{\n', '        require(_address1!=address(0) && _address2!=address(0) && _address3!=address(0));\n', '        require(_address1!=_address2 && _address1!=_address3 && _address2!=_address3);\n', '        \n', '        uint _vote=0;\n', '        if(holder1_==address(0)||holder1Reset_){\n', '            _vote++;\n', '        }\n', '        if(holder2_==address(0)||holder2Reset_){\n', '            _vote++;\n', '        }\n', '        if(holder3_==address(0)||holder3Reset_){\n', '            _vote++;\n', '        }\n', '        require(_vote>=2);\n', '        \n', '        holder1_=_address1;\n', '        holder2_=_address2;\n', '        holder3_=_address3;\n', '        holder1Reset_=false;\n', '        holder2Reset_=false;\n', '        holder3Reset_=false;\n', '        clearTransaction();\n', '        \n', '        emit HolderSetted(holder1_,holder2_,holder3_);\n', '    }\n', '    \n', '    function resetHolder(bool _vote) public onlyHolder{\n', '        if(msg.sender==holder1_){\n', '            holder1Reset_=_vote;\n', '        }\n', '        if(msg.sender==holder2_){\n', '            holder2Reset_=_vote;\n', '        }\n', '        if(msg.sender==holder3_){\n', '            holder3Reset_=_vote;\n', '        }\n', '        emit HolderReseted(_vote);\n', '    }\n', '    \n', '    function startTransaction(address _address, uint256 _value) public onlyHolder{\n', '        require(_address != address(0) && _value > 0);\n', '\n', '        transactionNonce_ = uint256(keccak256(abi.encodePacked(block.difficulty,now)));\n', '        transactionTo_ = _address;\n', '        transactionValue_ = _value;\n', '        emit TransactionStarted(_address,_value);\n', '\n', '        confirmTransaction(transactionNonce_, true);\n', '    }\n', '    \n', '    function showTransaction() public onlyHolder view returns(address _address, uint256 _value,uint256 _nonce){\n', '        return (transactionTo_,transactionValue_,transactionNonce_);\n', '    }\n', '\n', '    function confirmTransaction(uint256 _nonce, bool _vote) public onlyHolder{\n', '        require(transactionNonce_==_nonce);\n', '        \n', '        if(msg.sender==holder1_){\n', '            holder1Transaction_=_vote;\n', '        }\n', '        if(msg.sender==holder2_){\n', '            holder2Transaction_=_vote;\n', '        }\n', '        if(msg.sender==holder3_){\n', '            holder3Transaction_=_vote;\n', '        }\n', '        emit TransactionConfirmed(msg.sender,_vote);\n', '    }\n', '\n', '    function submitTransaction() public onlyHolder{\n', '        require(transactionTo_ != address(0) && transactionValue_ > 0);\n', '        require(holder1Transaction_ && holder2Transaction_ && holder3Transaction_);\n', '        require(!holder1Reset_ && !holder2Reset_ && !holder3Reset_);\n', '        \n', '        ERC20 _token = ERC20(token_);\n', '        _token.approve(this, transactionValue_);\n', '        _token.transferFrom(this,transactionTo_,transactionValue_);\n', '        \n', '        emit TransactionSubmitted(transactionTo_,transactionValue_);\n', '        \n', '        clearTransaction();\n', '    }\n', '    \n', '    function clearTransaction() internal{\n', '        transactionNonce_=0;\n', '        transactionTo_=address(0);\n', '        transactionValue_=0;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract ERC20 {\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '}\n', '\n', 'contract XEXHolder{\n', '    address private holder1_;\n', '    address private holder2_;\n', '    address private holder3_;\n', '    bool private holder1Reset_;\n', '    bool private holder2Reset_;\n', '    bool private holder3Reset_;\n', '    bool private holder1Transaction_;\n', '    bool private holder2Transaction_;\n', '    bool private holder3Transaction_;\n', '\n', '    address private token_;\n', '    uint256 private transactionNonce_;\n', '    address private transactionTo_;\n', '    uint256 private transactionValue_;\n', '\n', '    event HolderSetted(address indexed _address1,address indexed _address2,address indexed _address3);\n', '    event HolderReseted(bool _vote);\n', '    event TransactionStarted(address indexed _address,uint _value);\n', '    event TransactionConfirmed(address indexed _address,bool _vote);\n', '    event TransactionSubmitted(address indexed _address,uint _value);\n', '    \n', '    modifier onlyHolder() {\n', '        require(isHolder(msg.sender));\n', '        _;\n', '    }\n', '    \n', '    constructor(address _token) public{\n', '        token_=_token;\n', '        holder1_=msg.sender;\n', '        holder2_=address(0);\n', '        holder3_=address(0);\n', '        holder1Reset_=false;\n', '        holder2Reset_=false;\n', '        holder3Reset_=false;\n', '        holder1Transaction_=false;\n', '        holder2Transaction_=false;\n', '        holder3Transaction_=false;\n', '    }\n', '    \n', '    function isHolder(address _address) public view returns (bool) {\n', '        if(_address==address(0)){\n', '            return false;\n', '        }\n', '        return _address==holder1_ || _address==holder2_ || _address==holder3_;\n', '    }\n', '    \n', '    function setHolder(address _address1,address _address2,address _address3) public onlyHolder{\n', '        require(_address1!=address(0) && _address2!=address(0) && _address3!=address(0));\n', '        require(_address1!=_address2 && _address1!=_address3 && _address2!=_address3);\n', '        \n', '        uint _vote=0;\n', '        if(holder1_==address(0)||holder1Reset_){\n', '            _vote++;\n', '        }\n', '        if(holder2_==address(0)||holder2Reset_){\n', '            _vote++;\n', '        }\n', '        if(holder3_==address(0)||holder3Reset_){\n', '            _vote++;\n', '        }\n', '        require(_vote>=2);\n', '        \n', '        holder1_=_address1;\n', '        holder2_=_address2;\n', '        holder3_=_address3;\n', '        holder1Reset_=false;\n', '        holder2Reset_=false;\n', '        holder3Reset_=false;\n', '        clearTransaction();\n', '        \n', '        emit HolderSetted(holder1_,holder2_,holder3_);\n', '    }\n', '    \n', '    function resetHolder(bool _vote) public onlyHolder{\n', '        if(msg.sender==holder1_){\n', '            holder1Reset_=_vote;\n', '        }\n', '        if(msg.sender==holder2_){\n', '            holder2Reset_=_vote;\n', '        }\n', '        if(msg.sender==holder3_){\n', '            holder3Reset_=_vote;\n', '        }\n', '        emit HolderReseted(_vote);\n', '    }\n', '    \n', '    function startTransaction(address _address, uint256 _value) public onlyHolder{\n', '        require(_address != address(0) && _value > 0);\n', '\n', '        transactionNonce_ = uint256(keccak256(abi.encodePacked(block.difficulty,now)));\n', '        transactionTo_ = _address;\n', '        transactionValue_ = _value;\n', '        emit TransactionStarted(_address,_value);\n', '\n', '        confirmTransaction(transactionNonce_, true);\n', '    }\n', '    \n', '    function showTransaction() public onlyHolder view returns(address _address, uint256 _value,uint256 _nonce){\n', '        return (transactionTo_,transactionValue_,transactionNonce_);\n', '    }\n', '\n', '    function confirmTransaction(uint256 _nonce, bool _vote) public onlyHolder{\n', '        require(transactionNonce_==_nonce);\n', '        \n', '        if(msg.sender==holder1_){\n', '            holder1Transaction_=_vote;\n', '        }\n', '        if(msg.sender==holder2_){\n', '            holder2Transaction_=_vote;\n', '        }\n', '        if(msg.sender==holder3_){\n', '            holder3Transaction_=_vote;\n', '        }\n', '        emit TransactionConfirmed(msg.sender,_vote);\n', '    }\n', '\n', '    function submitTransaction() public onlyHolder{\n', '        require(transactionTo_ != address(0) && transactionValue_ > 0);\n', '        require(holder1Transaction_ && holder2Transaction_ && holder3Transaction_);\n', '        require(!holder1Reset_ && !holder2Reset_ && !holder3Reset_);\n', '        \n', '        ERC20 _token = ERC20(token_);\n', '        _token.approve(this, transactionValue_);\n', '        _token.transferFrom(this,transactionTo_,transactionValue_);\n', '        \n', '        emit TransactionSubmitted(transactionTo_,transactionValue_);\n', '        \n', '        clearTransaction();\n', '    }\n', '    \n', '    function clearTransaction() internal{\n', '        transactionNonce_=0;\n', '        transactionTo_=address(0);\n', '        transactionValue_=0;\n', '    }\n', '}']
