['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BGAudit is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    event AddedAuditor(address indexed auditor);\n', '    event BannedAuditor(address indexed auditor);\n', '    event AllowedAuditor(address indexed auditor);\n', '\n', '    event CreatedAudit(uint indexed id);\n', '    event ReviewingAudit(uint indexed id);\n', '    event AuditorRewarded(uint indexed id, address indexed auditor, uint indexed reward);\n', '\n', '    event AuditorStaked(uint indexed id, address indexed auditor, uint indexed amount);\n', '    event WithdrawedStake(uint indexed id, address indexed auditor, uint indexed amount);\n', '    event SlashedStake(uint indexed id, address indexed auditor);\n', '\n', '    enum AuditStatus { New, InProgress, InReview, Completed }\n', '\n', '    struct Auditor {\n', '        bool banned;\n', '        address addr;\n', '        uint totalEarned;\n', '        uint completedAudits;\n', '        uint[] stakedAudits; // array of audit IDs they&#39;ve staked\n', '        mapping(uint => bool) stakedInAudit; // key is AuditID; useful so we don&#39;t need to loop through the audits array above\n', '        mapping(uint => bool) canWithdrawStake; // Audit ID => can withdraw stake or not\n', '    }\n', '\n', '    struct Audit {\n', '        AuditStatus status;\n', '        address owner;\n', '        uint id;\n', '        uint totalReward; // total reward shared b/w all auditors\n', '        uint remainingReward; // keep track of how much reward is left\n', '        uint stake; // required stake for each auditor in wei\n', '        uint endTime; // scheduled end time for the audit\n', '        uint maxAuditors; // max auditors allowed for this Audit\n', '        address[] participants; // array of auditor that have staked\n', '    }\n', '\n', '    //=== Storage\n', '    uint public stakePeriod = 90 days; // number of days to wait before stake can be withdrawn\n', '    uint public maxAuditDuration = 365 days; // max amount of time for a security audit\n', '    Audit[] public audits;\n', '    mapping(address => Auditor) public auditors;\n', '\n', '    //=== Owner related\n', '    function transfer(address _to, uint _amountInWei) external onlyOwner {\n', '        require(address(this).balance > _amountInWei);\n', '        _to.transfer(_amountInWei);\n', '    }\n', '\n', '    function setStakePeriod(uint _days) external onlyOwner {\n', '        stakePeriod = _days * 1 days;\n', '    }\n', '\n', '    function setMaxAuditDuration(uint _days) external onlyOwner {\n', '        maxAuditDuration = _days * 1 days;\n', '    }\n', '\n', '\n', '    //=== Auditors\n', '    function addAuditor(address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr == address(0)); // Only add if they&#39;re not already added\n', '\n', '        auditors[_auditor].banned = false;\n', '        auditors[_auditor].addr = _auditor;\n', '        auditors[_auditor].completedAudits = 0;\n', '        auditors[_auditor].totalEarned = 0;\n', '        emit AddedAuditor(_auditor);\n', '    }\n', '\n', '    function banAuditor(address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        auditors[_auditor].banned = true;\n', '        emit BannedAuditor(_auditor);\n', '    }\n', '\n', '    function allowAuditor(address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        auditors[_auditor].banned = false;\n', '        emit AllowedAuditor(_auditor);\n', '    }\n', '\n', '\n', '    //=== Audits and Rewards\n', '    function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {\n', '        uint endTime = _endTimeInDays * 1 days;\n', '        require(endTime < maxAuditDuration);\n', '        require(block.timestamp + endTime * 1 days > block.timestamp);\n', '        require(msg.value > 0 && _maxAuditors > 0 && _stake > 0);\n', '\n', '        Audit memory audit;\n', '        audit.status = AuditStatus.New;\n', '        audit.owner = msg.sender;\n', '        audit.id = audits.length;\n', '        audit.totalReward = msg.value;\n', '        audit.remainingReward = audit.totalReward;\n', '        audit.stake = _stake;\n', '        audit.endTime = block.timestamp + endTime;\n', '        audit.maxAuditors = _maxAuditors;\n', '\n', '        audits.push(audit); // push into storage\n', '        emit CreatedAudit(audit.id);\n', '    }\n', '\n', '    function reviewAudit(uint _id) external onlyOwner {\n', '        require(audits[_id].status == AuditStatus.InProgress);\n', '        require(block.timestamp >= audits[_id].endTime);\n', '        audits[_id].endTime = block.timestamp; // override the endTime to when it actually ended\n', '        audits[_id].status = AuditStatus.InReview;\n', '        emit ReviewingAudit(_id);\n', '    }\n', '\n', '    function rewardAuditor(uint _id, address _auditor, uint _reward) external onlyOwner {\n', '\n', '        audits[_id].remainingReward.sub(_reward);\n', '        audits[_id].status = AuditStatus.Completed;\n', '\n', '        auditors[_auditor].totalEarned.add(_reward);\n', '        auditors[_auditor].completedAudits.add(1);\n', '        auditors[_auditor].canWithdrawStake[_id] = true; // allow them to withdraw their stake after stakePeriod\n', '        _auditor.transfer(_reward);\n', '        emit AuditorRewarded(_id, _auditor, _reward);\n', '    }\n', '\n', '    function slashStake(uint _id, address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        require(auditors[_auditor].stakedInAudit[_id]); // participated in audit\n', '        auditors[_auditor].canWithdrawStake[_id] = false;\n', '        emit SlashedStake(_id, _auditor);\n', '    }\n', '\n', '    //=== User Actions\n', '    function stake(uint _id) public payable {\n', '        // Check conditions of the Audit\n', '        require(msg.value == audits[_id].stake);\n', '        require(block.timestamp < audits[_id].endTime);\n', '        require(audits[_id].participants.length < audits[_id].maxAuditors);\n', '        require(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);\n', '\n', '        // Check conditions of the Auditor\n', '        require(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned); // auditor is authorized\n', '        require(!auditors[msg.sender].stakedInAudit[_id]); //check if auditor has staked for this audit already\n', '\n', '        // Update audit&#39;s states\n', '        audits[_id].status = AuditStatus.InProgress;\n', '        audits[_id].participants.push(msg.sender);\n', '\n', '        // Update auditor&#39;s states\n', '        auditors[msg.sender].stakedInAudit[_id] = true;\n', '        auditors[msg.sender].stakedAudits.push(_id);\n', '        emit AuditorStaked(_id, msg.sender, msg.value);\n', '    }\n', '\n', '    function withdrawStake(uint _id) public {\n', '        require(audits[_id].status == AuditStatus.Completed);\n', '        require(auditors[msg.sender].canWithdrawStake[_id]);\n', '        require(block.timestamp >= audits[_id].endTime + stakePeriod);\n', '\n', '        auditors[msg.sender].canWithdrawStake[_id] = false; //prevent replay attack\n', '        address(msg.sender).transfer(audits[_id].stake); // do this last to prevent re-entrancy\n', '        emit WithdrawedStake(_id, msg.sender, audits[_id].stake);\n', '    }\n', '\n', '    //=== Getters\n', '    function auditorHasStaked(uint _id, address _auditor) public view returns(bool) {\n', '        return auditors[_auditor].stakedInAudit[_id];\n', '    }\n', '\n', '    function auditorCanWithdrawStake(uint _id, address _auditor) public view returns(bool) {\n', '        if(auditors[_auditor].stakedInAudit[_id] && auditors[_auditor].canWithdrawStake[_id]) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // return a list of ids that _auditor has staked in\n', '    function getStakedAudits(address _auditor) public view returns(uint[]) {\n', '        return auditors[_auditor].stakedAudits;\n', '    }\n', '\n', '    // return a list of auditors that participated in this audit\n', '    function getAuditors(uint _id) public view returns(address[]) {\n', '        return audits[_id].participants;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BGAudit is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    event AddedAuditor(address indexed auditor);\n', '    event BannedAuditor(address indexed auditor);\n', '    event AllowedAuditor(address indexed auditor);\n', '\n', '    event CreatedAudit(uint indexed id);\n', '    event ReviewingAudit(uint indexed id);\n', '    event AuditorRewarded(uint indexed id, address indexed auditor, uint indexed reward);\n', '\n', '    event AuditorStaked(uint indexed id, address indexed auditor, uint indexed amount);\n', '    event WithdrawedStake(uint indexed id, address indexed auditor, uint indexed amount);\n', '    event SlashedStake(uint indexed id, address indexed auditor);\n', '\n', '    enum AuditStatus { New, InProgress, InReview, Completed }\n', '\n', '    struct Auditor {\n', '        bool banned;\n', '        address addr;\n', '        uint totalEarned;\n', '        uint completedAudits;\n', "        uint[] stakedAudits; // array of audit IDs they've staked\n", "        mapping(uint => bool) stakedInAudit; // key is AuditID; useful so we don't need to loop through the audits array above\n", '        mapping(uint => bool) canWithdrawStake; // Audit ID => can withdraw stake or not\n', '    }\n', '\n', '    struct Audit {\n', '        AuditStatus status;\n', '        address owner;\n', '        uint id;\n', '        uint totalReward; // total reward shared b/w all auditors\n', '        uint remainingReward; // keep track of how much reward is left\n', '        uint stake; // required stake for each auditor in wei\n', '        uint endTime; // scheduled end time for the audit\n', '        uint maxAuditors; // max auditors allowed for this Audit\n', '        address[] participants; // array of auditor that have staked\n', '    }\n', '\n', '    //=== Storage\n', '    uint public stakePeriod = 90 days; // number of days to wait before stake can be withdrawn\n', '    uint public maxAuditDuration = 365 days; // max amount of time for a security audit\n', '    Audit[] public audits;\n', '    mapping(address => Auditor) public auditors;\n', '\n', '    //=== Owner related\n', '    function transfer(address _to, uint _amountInWei) external onlyOwner {\n', '        require(address(this).balance > _amountInWei);\n', '        _to.transfer(_amountInWei);\n', '    }\n', '\n', '    function setStakePeriod(uint _days) external onlyOwner {\n', '        stakePeriod = _days * 1 days;\n', '    }\n', '\n', '    function setMaxAuditDuration(uint _days) external onlyOwner {\n', '        maxAuditDuration = _days * 1 days;\n', '    }\n', '\n', '\n', '    //=== Auditors\n', '    function addAuditor(address _auditor) external onlyOwner {\n', "        require(auditors[_auditor].addr == address(0)); // Only add if they're not already added\n", '\n', '        auditors[_auditor].banned = false;\n', '        auditors[_auditor].addr = _auditor;\n', '        auditors[_auditor].completedAudits = 0;\n', '        auditors[_auditor].totalEarned = 0;\n', '        emit AddedAuditor(_auditor);\n', '    }\n', '\n', '    function banAuditor(address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        auditors[_auditor].banned = true;\n', '        emit BannedAuditor(_auditor);\n', '    }\n', '\n', '    function allowAuditor(address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        auditors[_auditor].banned = false;\n', '        emit AllowedAuditor(_auditor);\n', '    }\n', '\n', '\n', '    //=== Audits and Rewards\n', '    function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {\n', '        uint endTime = _endTimeInDays * 1 days;\n', '        require(endTime < maxAuditDuration);\n', '        require(block.timestamp + endTime * 1 days > block.timestamp);\n', '        require(msg.value > 0 && _maxAuditors > 0 && _stake > 0);\n', '\n', '        Audit memory audit;\n', '        audit.status = AuditStatus.New;\n', '        audit.owner = msg.sender;\n', '        audit.id = audits.length;\n', '        audit.totalReward = msg.value;\n', '        audit.remainingReward = audit.totalReward;\n', '        audit.stake = _stake;\n', '        audit.endTime = block.timestamp + endTime;\n', '        audit.maxAuditors = _maxAuditors;\n', '\n', '        audits.push(audit); // push into storage\n', '        emit CreatedAudit(audit.id);\n', '    }\n', '\n', '    function reviewAudit(uint _id) external onlyOwner {\n', '        require(audits[_id].status == AuditStatus.InProgress);\n', '        require(block.timestamp >= audits[_id].endTime);\n', '        audits[_id].endTime = block.timestamp; // override the endTime to when it actually ended\n', '        audits[_id].status = AuditStatus.InReview;\n', '        emit ReviewingAudit(_id);\n', '    }\n', '\n', '    function rewardAuditor(uint _id, address _auditor, uint _reward) external onlyOwner {\n', '\n', '        audits[_id].remainingReward.sub(_reward);\n', '        audits[_id].status = AuditStatus.Completed;\n', '\n', '        auditors[_auditor].totalEarned.add(_reward);\n', '        auditors[_auditor].completedAudits.add(1);\n', '        auditors[_auditor].canWithdrawStake[_id] = true; // allow them to withdraw their stake after stakePeriod\n', '        _auditor.transfer(_reward);\n', '        emit AuditorRewarded(_id, _auditor, _reward);\n', '    }\n', '\n', '    function slashStake(uint _id, address _auditor) external onlyOwner {\n', '        require(auditors[_auditor].addr != address(0));\n', '        require(auditors[_auditor].stakedInAudit[_id]); // participated in audit\n', '        auditors[_auditor].canWithdrawStake[_id] = false;\n', '        emit SlashedStake(_id, _auditor);\n', '    }\n', '\n', '    //=== User Actions\n', '    function stake(uint _id) public payable {\n', '        // Check conditions of the Audit\n', '        require(msg.value == audits[_id].stake);\n', '        require(block.timestamp < audits[_id].endTime);\n', '        require(audits[_id].participants.length < audits[_id].maxAuditors);\n', '        require(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);\n', '\n', '        // Check conditions of the Auditor\n', '        require(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned); // auditor is authorized\n', '        require(!auditors[msg.sender].stakedInAudit[_id]); //check if auditor has staked for this audit already\n', '\n', "        // Update audit's states\n", '        audits[_id].status = AuditStatus.InProgress;\n', '        audits[_id].participants.push(msg.sender);\n', '\n', "        // Update auditor's states\n", '        auditors[msg.sender].stakedInAudit[_id] = true;\n', '        auditors[msg.sender].stakedAudits.push(_id);\n', '        emit AuditorStaked(_id, msg.sender, msg.value);\n', '    }\n', '\n', '    function withdrawStake(uint _id) public {\n', '        require(audits[_id].status == AuditStatus.Completed);\n', '        require(auditors[msg.sender].canWithdrawStake[_id]);\n', '        require(block.timestamp >= audits[_id].endTime + stakePeriod);\n', '\n', '        auditors[msg.sender].canWithdrawStake[_id] = false; //prevent replay attack\n', '        address(msg.sender).transfer(audits[_id].stake); // do this last to prevent re-entrancy\n', '        emit WithdrawedStake(_id, msg.sender, audits[_id].stake);\n', '    }\n', '\n', '    //=== Getters\n', '    function auditorHasStaked(uint _id, address _auditor) public view returns(bool) {\n', '        return auditors[_auditor].stakedInAudit[_id];\n', '    }\n', '\n', '    function auditorCanWithdrawStake(uint _id, address _auditor) public view returns(bool) {\n', '        if(auditors[_auditor].stakedInAudit[_id] && auditors[_auditor].canWithdrawStake[_id]) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // return a list of ids that _auditor has staked in\n', '    function getStakedAudits(address _auditor) public view returns(uint[]) {\n', '        return auditors[_auditor].stakedAudits;\n', '    }\n', '\n', '    // return a list of auditors that participated in this audit\n', '    function getAuditors(uint _id) public view returns(address[]) {\n', '        return audits[_id].participants;\n', '    }\n', '}']
