['pragma solidity 0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath64 {\n', '  function mul(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    uint64 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint64 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    uint64 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title VestingERC20\n', ' * @dev VestingERC20 is a contract for managing vesting of ERC20 Token.\n', ' * @dev The tokens are unlocked continuously to the vester.\n', ' * @dev The contract host the tokens that are locked for the vester.\n', ' */\n', 'contract VestingERC20 {\n', '    using SafeMath for uint256;\n', '    using SafeMath64 for uint64;\n', '\n', '    struct Grant {\n', '        uint256 vestedAmount;\n', '        uint64 startTime;\n', '        uint64 cliffTime;\n', '        uint64 endTime;\n', '        uint256 withdrawnAmount;\n', '    }\n', '\n', '    // list of the grants (token => granter => vester => Grant).\n', '    mapping(address => mapping(address => mapping(address => Grant))) public grantPerTokenGranterVester;\n', '\n', '    // Ledger of the tokens hodled (this not a typo ;) ) in this contract (token => user => balance).\n', '    mapping(address => mapping(address => uint256)) private balancePerPersonPerToken;\n', '\n', '\n', '    event NewGrant(address granter, address vester, address token, uint256 vestedAmount, uint64 startTime, uint64 cliffTime, uint64 endTime);\n', '    event GrantRevoked(address granter, address vester, address token);\n', '    event Deposit(address token, address granter, uint amount, uint balance);\n', '    event TokenReleased(address token, address granter, address vester, uint amount);\n', '    event Withdraw(address token, address user, uint amount);\n', '\n', '    /**\n', '     * @dev Create a vesting to an ethereum address.\n', '     *\n', '     * If there is not enough tokens available on the contract, an exception is thrown.\n', '     *\n', '     * @param _token The ERC20 token contract address.\n', '     * @param _vester The address where the token will be sent.\n', '     * @param _vestedAmount The amount of tokens to be sent during the vesting period.\n', '     * @param _startTime The time when the vesting starts.\n', '     * @param _grantPeriod The period of the grant in sec.\n', '     * @param _cliffPeriod The period in sec during which time the tokens cannot be withraw.\n', '     */\n', '    function createVesting(\n', '        address _token, \n', '        address _vester,  \n', '        uint256 _vestedAmount,\n', '        uint64 _startTime,\n', '        uint64 _grantPeriod,\n', '        uint64 _cliffPeriod) \n', '        external\n', '    {\n', '        require(_token != 0);\n', '        require(_vester != 0);\n', '        require(_cliffPeriod <= _grantPeriod);\n', '        require(_vestedAmount != 0);\n', '        require(_grantPeriod==0 || _vestedAmount * _grantPeriod >= _vestedAmount); // no overflow allow here! (to make getBalanceVestingInternal safe).\n', '\n', '        // verify that there is not already a grant between the addresses for this specific contract.\n', '        require(grantPerTokenGranterVester[_token][msg.sender][_vester].vestedAmount==0);\n', '\n', '        var cliffTime = _startTime.add(_cliffPeriod);\n', '        var endTime = _startTime.add(_grantPeriod);\n', '\n', '        grantPerTokenGranterVester[_token][msg.sender][_vester] = Grant(_vestedAmount, _startTime, cliffTime, endTime, 0);\n', '\n', '        // update the balance\n', '        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].sub(_vestedAmount);\n', '\n', '        NewGrant(msg.sender, _vester, _token, _vestedAmount, _startTime, cliffTime, endTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke a vesting\n', '     *\n', '     * The vesting is deleted and the tokens already released are sent to the vester.\n', '     *\n', '     * @param _token The address of the token.\n', '     * @param _vester The address of the vester.\n', '     */\n', '    function revokeVesting(address _token, address _vester) \n', '        external\n', '    {\n', '        require(_token != 0);\n', '        require(_vester != 0);\n', '\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][msg.sender][_vester];\n', '\n', '        // verify if the grant exists\n', '        require(_grant.vestedAmount!=0);\n', '\n', '        // send token available\n', '        sendTokenReleasedToBalanceInternal(_token, msg.sender, _vester);\n', '\n', '        // unlock the tokens reserved for this grant\n', '        balancePerPersonPerToken[_token][msg.sender] = \n', '            balancePerPersonPerToken[_token][msg.sender].add(\n', '                _grant.vestedAmount.sub(_grant.withdrawnAmount)\n', '            );\n', '\n', '        // delete the grants\n', '        delete grantPerTokenGranterVester[_token][msg.sender][_vester];\n', '\n', '        GrantRevoked(msg.sender, _vester, _token);\n', '    }\n', '\n', '    /**\n', '     * @dev Send the released token to the user balance and eventually withdraw\n', '     *\n', '     * Put the tokens released to the user balance.\n', '     * If _doWithdraw is true, send the whole balance to the user.\n', '\n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _doWithdraw bool, true to withdraw in the same time.\n', '     */\n', '    function releaseGrant(address _token, address _granter, bool _doWithdraw) \n', '        external\n', '    {\n', '        // send token to the vester\n', '        sendTokenReleasedToBalanceInternal(_token, _granter, msg.sender);\n', '\n', '        if(_doWithdraw) {\n', '            withdraw(_token);           \n', '        }\n', '\n', '        // delete grant if fully withdrawn\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][msg.sender];\n', '        if(_grant.vestedAmount == _grant.withdrawnAmount) \n', '        {\n', '            delete grantPerTokenGranterVester[_token][_granter][msg.sender];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw tokens avaibable\n', '     *\n', '     * The tokens are sent to msg.sender and his balancePerPersonPerToken is updated to zero.\n', '     * If there is the token transfer fail, the transaction is revert.\n', '     *\n', '     * @param _token The address of the token.\n', '     */\n', '    function withdraw(address _token) \n', '        public\n', '    {\n', '        uint amountToSend = balancePerPersonPerToken[_token][msg.sender];\n', '        balancePerPersonPerToken[_token][msg.sender] = 0;\n', '        Withdraw(_token, msg.sender, amountToSend);\n', '        require(ERC20(_token).transfer(msg.sender, amountToSend));\n', '    }\n', '\n', '    /**\n', '     * @dev Send the token released to the balance address\n', '     *\n', '     * The token released for the address are sent and his withdrawnAmount are updated.\n', '     * If there is nothing the send, return false.\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _vester The address of the vester.\n', '     * @return true if tokens have been sent.\n', '     */\n', '    function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) \n', '        internal\n', '    {\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester];\n', '        uint256 amountToSend = getBalanceVestingInternal(_grant);\n', '\n', '        // update withdrawnAmount\n', '        _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend);\n', '\n', '        TokenReleased(_token, _granter, _vester, amountToSend);\n', '\n', '        // send tokens to the vester&#39;s balance\n', '        balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); \n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the amount of tokens released for a grant\n', '     * \n', '     * @param _grant Grant information.\n', '     * @return the number of tokens released.\n', '     */\n', '    function getBalanceVestingInternal(Grant _grant)\n', '        internal\n', '        constant\n', '        returns(uint256)\n', '    {\n', '        if(now < _grant.cliffTime) \n', '        {\n', '            // the grant didn&#39;t start \n', '            return 0;\n', '        }\n', '        else if(now >= _grant.endTime)\n', '        {\n', '            // after the end of the grant release everything\n', '            return _grant.vestedAmount.sub(_grant.withdrawnAmount);\n', '        }\n', '        else\n', '        {\n', '            //  token available = vestedAmount * (now - startTime) / (endTime - startTime)  - withdrawnAmount\n', '            //  => in other words : (number_of_token_granted_per_second * second_since_grant_started) - amount_already_withdraw\n', '            return _grant.vestedAmount.mul( \n', '                        now.sub(_grant.startTime)\n', '                    ).div(\n', '                        _grant.endTime.sub(_grant.startTime) \n', '                    ).sub(_grant.withdrawnAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the amount of tokens released for a vesting\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _vester The address of the vester.\n', '     * @return the number of tokens available.\n', '     */\n', '    function getVestingBalance(address _token, address _granter, address _vester) \n', '        external\n', '        constant \n', '        returns(uint256) \n', '    {\n', '        Grant memory _grant = grantPerTokenGranterVester[_token][_granter][_vester];\n', '        return getBalanceVestingInternal(_grant);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the token balance of the contract\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _user The address of the user.\n', '     * @return the balance of tokens on the contract for _user.\n', '     */\n', '    function getContractBalance(address _token, address _user) \n', '        external\n', '        constant \n', '        returns(uint256) \n', '    {\n', '        return balancePerPersonPerToken[_token][_user];\n', '    }\n', '\n', '    /**\n', '     * @dev Make a deposit of tokens on the contract\n', '     *\n', '     * Before using this function the user needs to do a token allowance from the user to the contract.\n', '     *\n', '     * @param _token The address of the token.\n', '     * @param _amount Amount of token to deposit.\n', '     * \n', '     * @return the balance of tokens on the contract for msg.sender.\n', '     */\n', '    function deposit(address _token, uint256 _amount) \n', '        external\n', '        returns(uint256) \n', '    {\n', '        require(_token!=0);\n', '        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\n', '        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].add(_amount);\n', '        Deposit(_token, msg.sender, _amount, balancePerPersonPerToken[_token][msg.sender]);\n', '\n', '        return balancePerPersonPerToken[_token][msg.sender];\n', '    }\n', '}']
['pragma solidity 0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath64 {\n', '  function mul(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    uint64 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint64 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    uint64 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title VestingERC20\n', ' * @dev VestingERC20 is a contract for managing vesting of ERC20 Token.\n', ' * @dev The tokens are unlocked continuously to the vester.\n', ' * @dev The contract host the tokens that are locked for the vester.\n', ' */\n', 'contract VestingERC20 {\n', '    using SafeMath for uint256;\n', '    using SafeMath64 for uint64;\n', '\n', '    struct Grant {\n', '        uint256 vestedAmount;\n', '        uint64 startTime;\n', '        uint64 cliffTime;\n', '        uint64 endTime;\n', '        uint256 withdrawnAmount;\n', '    }\n', '\n', '    // list of the grants (token => granter => vester => Grant).\n', '    mapping(address => mapping(address => mapping(address => Grant))) public grantPerTokenGranterVester;\n', '\n', '    // Ledger of the tokens hodled (this not a typo ;) ) in this contract (token => user => balance).\n', '    mapping(address => mapping(address => uint256)) private balancePerPersonPerToken;\n', '\n', '\n', '    event NewGrant(address granter, address vester, address token, uint256 vestedAmount, uint64 startTime, uint64 cliffTime, uint64 endTime);\n', '    event GrantRevoked(address granter, address vester, address token);\n', '    event Deposit(address token, address granter, uint amount, uint balance);\n', '    event TokenReleased(address token, address granter, address vester, uint amount);\n', '    event Withdraw(address token, address user, uint amount);\n', '\n', '    /**\n', '     * @dev Create a vesting to an ethereum address.\n', '     *\n', '     * If there is not enough tokens available on the contract, an exception is thrown.\n', '     *\n', '     * @param _token The ERC20 token contract address.\n', '     * @param _vester The address where the token will be sent.\n', '     * @param _vestedAmount The amount of tokens to be sent during the vesting period.\n', '     * @param _startTime The time when the vesting starts.\n', '     * @param _grantPeriod The period of the grant in sec.\n', '     * @param _cliffPeriod The period in sec during which time the tokens cannot be withraw.\n', '     */\n', '    function createVesting(\n', '        address _token, \n', '        address _vester,  \n', '        uint256 _vestedAmount,\n', '        uint64 _startTime,\n', '        uint64 _grantPeriod,\n', '        uint64 _cliffPeriod) \n', '        external\n', '    {\n', '        require(_token != 0);\n', '        require(_vester != 0);\n', '        require(_cliffPeriod <= _grantPeriod);\n', '        require(_vestedAmount != 0);\n', '        require(_grantPeriod==0 || _vestedAmount * _grantPeriod >= _vestedAmount); // no overflow allow here! (to make getBalanceVestingInternal safe).\n', '\n', '        // verify that there is not already a grant between the addresses for this specific contract.\n', '        require(grantPerTokenGranterVester[_token][msg.sender][_vester].vestedAmount==0);\n', '\n', '        var cliffTime = _startTime.add(_cliffPeriod);\n', '        var endTime = _startTime.add(_grantPeriod);\n', '\n', '        grantPerTokenGranterVester[_token][msg.sender][_vester] = Grant(_vestedAmount, _startTime, cliffTime, endTime, 0);\n', '\n', '        // update the balance\n', '        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].sub(_vestedAmount);\n', '\n', '        NewGrant(msg.sender, _vester, _token, _vestedAmount, _startTime, cliffTime, endTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke a vesting\n', '     *\n', '     * The vesting is deleted and the tokens already released are sent to the vester.\n', '     *\n', '     * @param _token The address of the token.\n', '     * @param _vester The address of the vester.\n', '     */\n', '    function revokeVesting(address _token, address _vester) \n', '        external\n', '    {\n', '        require(_token != 0);\n', '        require(_vester != 0);\n', '\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][msg.sender][_vester];\n', '\n', '        // verify if the grant exists\n', '        require(_grant.vestedAmount!=0);\n', '\n', '        // send token available\n', '        sendTokenReleasedToBalanceInternal(_token, msg.sender, _vester);\n', '\n', '        // unlock the tokens reserved for this grant\n', '        balancePerPersonPerToken[_token][msg.sender] = \n', '            balancePerPersonPerToken[_token][msg.sender].add(\n', '                _grant.vestedAmount.sub(_grant.withdrawnAmount)\n', '            );\n', '\n', '        // delete the grants\n', '        delete grantPerTokenGranterVester[_token][msg.sender][_vester];\n', '\n', '        GrantRevoked(msg.sender, _vester, _token);\n', '    }\n', '\n', '    /**\n', '     * @dev Send the released token to the user balance and eventually withdraw\n', '     *\n', '     * Put the tokens released to the user balance.\n', '     * If _doWithdraw is true, send the whole balance to the user.\n', '\n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _doWithdraw bool, true to withdraw in the same time.\n', '     */\n', '    function releaseGrant(address _token, address _granter, bool _doWithdraw) \n', '        external\n', '    {\n', '        // send token to the vester\n', '        sendTokenReleasedToBalanceInternal(_token, _granter, msg.sender);\n', '\n', '        if(_doWithdraw) {\n', '            withdraw(_token);           \n', '        }\n', '\n', '        // delete grant if fully withdrawn\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][msg.sender];\n', '        if(_grant.vestedAmount == _grant.withdrawnAmount) \n', '        {\n', '            delete grantPerTokenGranterVester[_token][_granter][msg.sender];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw tokens avaibable\n', '     *\n', '     * The tokens are sent to msg.sender and his balancePerPersonPerToken is updated to zero.\n', '     * If there is the token transfer fail, the transaction is revert.\n', '     *\n', '     * @param _token The address of the token.\n', '     */\n', '    function withdraw(address _token) \n', '        public\n', '    {\n', '        uint amountToSend = balancePerPersonPerToken[_token][msg.sender];\n', '        balancePerPersonPerToken[_token][msg.sender] = 0;\n', '        Withdraw(_token, msg.sender, amountToSend);\n', '        require(ERC20(_token).transfer(msg.sender, amountToSend));\n', '    }\n', '\n', '    /**\n', '     * @dev Send the token released to the balance address\n', '     *\n', '     * The token released for the address are sent and his withdrawnAmount are updated.\n', '     * If there is nothing the send, return false.\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _vester The address of the vester.\n', '     * @return true if tokens have been sent.\n', '     */\n', '    function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) \n', '        internal\n', '    {\n', '        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester];\n', '        uint256 amountToSend = getBalanceVestingInternal(_grant);\n', '\n', '        // update withdrawnAmount\n', '        _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend);\n', '\n', '        TokenReleased(_token, _granter, _vester, amountToSend);\n', '\n', "        // send tokens to the vester's balance\n", '        balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); \n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the amount of tokens released for a grant\n', '     * \n', '     * @param _grant Grant information.\n', '     * @return the number of tokens released.\n', '     */\n', '    function getBalanceVestingInternal(Grant _grant)\n', '        internal\n', '        constant\n', '        returns(uint256)\n', '    {\n', '        if(now < _grant.cliffTime) \n', '        {\n', "            // the grant didn't start \n", '            return 0;\n', '        }\n', '        else if(now >= _grant.endTime)\n', '        {\n', '            // after the end of the grant release everything\n', '            return _grant.vestedAmount.sub(_grant.withdrawnAmount);\n', '        }\n', '        else\n', '        {\n', '            //  token available = vestedAmount * (now - startTime) / (endTime - startTime)  - withdrawnAmount\n', '            //  => in other words : (number_of_token_granted_per_second * second_since_grant_started) - amount_already_withdraw\n', '            return _grant.vestedAmount.mul( \n', '                        now.sub(_grant.startTime)\n', '                    ).div(\n', '                        _grant.endTime.sub(_grant.startTime) \n', '                    ).sub(_grant.withdrawnAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the amount of tokens released for a vesting\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _granter The address of the granter.\n', '     * @param _vester The address of the vester.\n', '     * @return the number of tokens available.\n', '     */\n', '    function getVestingBalance(address _token, address _granter, address _vester) \n', '        external\n', '        constant \n', '        returns(uint256) \n', '    {\n', '        Grant memory _grant = grantPerTokenGranterVester[_token][_granter][_vester];\n', '        return getBalanceVestingInternal(_grant);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the token balance of the contract\n', '     * \n', '     * @param _token The address of the token.\n', '     * @param _user The address of the user.\n', '     * @return the balance of tokens on the contract for _user.\n', '     */\n', '    function getContractBalance(address _token, address _user) \n', '        external\n', '        constant \n', '        returns(uint256) \n', '    {\n', '        return balancePerPersonPerToken[_token][_user];\n', '    }\n', '\n', '    /**\n', '     * @dev Make a deposit of tokens on the contract\n', '     *\n', '     * Before using this function the user needs to do a token allowance from the user to the contract.\n', '     *\n', '     * @param _token The address of the token.\n', '     * @param _amount Amount of token to deposit.\n', '     * \n', '     * @return the balance of tokens on the contract for msg.sender.\n', '     */\n', '    function deposit(address _token, uint256 _amount) \n', '        external\n', '        returns(uint256) \n', '    {\n', '        require(_token!=0);\n', '        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\n', '        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].add(_amount);\n', '        Deposit(_token, msg.sender, _amount, balancePerPersonPerToken[_token][msg.sender]);\n', '\n', '        return balancePerPersonPerToken[_token][msg.sender];\n', '    }\n', '}']
