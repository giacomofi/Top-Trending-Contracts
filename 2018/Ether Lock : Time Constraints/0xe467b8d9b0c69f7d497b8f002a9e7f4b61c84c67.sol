['pragma solidity 0.4.24;\n', '\n', 'library SafeMathExt{\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (b == 0){\n', '      return 1;\n', '    }\n', '    if (b == 1){\n', '      return a;\n', '    }\n', '    uint256 c = a;\n', '    for(uint i = 1; i<b; i++){\n', '      c = mul(c, a);\n', '    }\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function roundUp(uint256 a, uint256 b) public pure returns(uint256){\n', '    // ((a + b - 1) / b) * b\n', '    uint256 c = (mul(div(sub(add(a, b), 1), b), b));\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BadgeFactoryInterface{\n', '\tfunction _initBadges(address admin_, uint256 badgeBasePrice_, uint256 badgeStartMultiplier_, uint256 badgeStartQuantity_) external;\n', '\tfunction _createNewBadge(address owner_, uint256 price_) external;\n', '\tfunction _setOwner(uint256 badgeID_, address owner_) external;\n', '\tfunction getOwner(uint256 badgeID_) public view returns(address);\n', '\tfunction _increasePrice(uint256 badgeID_) external;\n', '\tfunction getPrice(uint256 badgeID_) public view returns(uint256);\n', '\tfunction _increaseTotalDivis(uint256 badgeID_, uint256 divis_) external;\n', '\tfunction getTotalDivis(uint256 badgeID_) public view returns(uint256);\n', '\tfunction _setBuyTime(uint256 badgeID_, uint32 timeStamp_) external;\n', '\tfunction getBuyTime(uint256 badgeID_) public view returns(uint32);\n', '\tfunction getCreationTime(uint256 badgeID_) public view returns(uint32);\n', '\tfunction getChainLength() public view returns(uint256);\n', '\tfunction getRandomBadge(uint256 max_, uint256 i_) external view returns(uint256);\n', '    function getRandomFactor() external returns(uint256);\n', '}\n', '\n', 'contract TeamAmberInterface{\n', '    function distribute() public payable;\n', '}\n', '\n', 'contract Amber{\n', '\tusing SafeMathExt for uint256;\n', '    /*===============================================================================\n', '    =                      DATA SET                     DATA SET                    =\n', '    ===============================================================================*/\n', '    /*==============================\n', '    =          INTERFACES          =\n', '    ==============================*/\n', '    BadgeFactoryInterface internal _badgeFactory;\n', '    TeamAmberInterface internal _teamAmber;\n', '\n', '    /*==============================\n', '    =          CONSTANTS           =\n', '    ==============================*/\n', '    uint256 internal constant GWEI = 10**9;\n', '    uint256 internal constant FINNEY = 10**15;\n', '    uint256 internal constant ETH = 10**18;\n', '    uint256 internal constant _badgeBasePrice = 25 * FINNEY;\n', '    uint256 internal constant _luckyWinners = 5;\n', '    uint256 internal constant _sharePreviousOwnerRatio = 50;\n', '    uint256 internal constant _shareReferalRatio = 5;\n', '    uint256 internal constant _shareDistributionRatio = 45;\n', '\n', '    /*==============================\n', '    =          VARIABLES           =\n', '    ==============================*/\n', '    address internal _contractOwner;\n', '    address internal _admin;\n', '    uint256 internal _startTime;\n', '    uint256 internal _initCounter;\n', '\n', '    /*==============================\n', '    =            BADGES            =\n', '    ==============================*/\n', '    struct Badge{\n', '        address owner;\n', '        uint256 price;\n', '        uint256 totalDivis;\n', '    }\n', '\n', '    Badge[] private badges;\n', '\n', '    /*==============================\n', '    =        USER MAPPINGS         =\n', '    ==============================*/\n', '    mapping(address => uint256) private _splitProfit;\n', '    mapping(address => uint256) private _flipProfit;\n', '    mapping(address => uint256) private _waypointProfit;\n', '    mapping(address => address) private _referer;\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onContractStart(uint256 startTime_);\n', '    event onRefererSet(address indexed user_, address indexed referer_);\n', '    event onBadgeBuy(uint256 indexed badgeID_, address previousOwner_, address indexed buyer_, address indexed referer_, uint256 price_, uint256 newPrice_);\n', '    event onWithdraw(address indexed receiver_, uint256 splitProfit_, uint256 flipProfit_, uint256 waypointProfit_);\n', '\n', '    /*==============================\n', '    =          MODIFIERS           =\n', '    ==============================*/\n', '    modifier onlyContractOwner(){\n', "    \trequire(msg.sender == _contractOwner, 'Sender is not the contract owner.');\n", '    \t_;\n', '    }\n', '    modifier isNotAContract(){\n', "        require (msg.sender == tx.origin, 'Contracts are not allowed to interact.');\n", '        _;\n', '    }\n', '    modifier isRunning(){\n', "    \trequire(_startTime != 0 && _startTime <= now, 'The contract is not running yet.');\n", '    \t_;\n', '    }\n', '\n', '    /*===============================================================================\n', '    =                       PURE AMBER                       PURE AMBER             =\n', '    ===============================================================================*/\n', '    function isValidBuy(uint256 price_, uint256 msgValue_) public pure returns(bool){\n', '        return (price_ == msgValue_);\n', '    }\n', '\n', '    function refererAllowed(address msgSender_, address currentReferer_, address newReferer_) public pure returns(bool){\n', '        return (addressNotSet(currentReferer_) && isAddress(newReferer_) && isNotSelf(msgSender_, newReferer_));\n', '    }\n', '\n', '    function addressNotSet(address address_) public pure returns(bool){\n', '        return (address_ == 0x0);\n', '    }\n', '\n', '    function isAddress(address address_) public pure returns(bool){\n', '        return (address_ != 0x0);\n', '    }\n', '\n', '    function isNotSelf(address msgSender_, address compare_) public pure returns(bool){\n', '        return (msgSender_ != compare_);\n', '    }\n', '\n', '    function isFirstBadgeEle(uint256 badgeID_) public pure returns(bool){\n', '        return (badgeID_ == 0);\n', '    }\n', '\n', '    function isLastBadgeEle(uint256 badgeID_, uint256 badgeLength_) public pure returns(bool){\n', '        assert(badgeID_ <= SafeMathExt.sub(badgeLength_, 1));\n', '        return (badgeID_ == SafeMathExt.sub(badgeLength_, 1));\n', '    }\n', '\n', '    function calcShare(uint256 msgValue_, uint256 ratio_) public pure returns(uint256){\n', '        assert(ratio_ <= 100 && msgValue_ >= 0);\n', '        return (msgValue_ * ratio_) / 100;\n', '    }\n', '\n', '    /*===============================================================================\n', '    =                     BADGE FACTORY                     BADGE FACTORY           =\n', '    ===============================================================================*/\n', '    function _initBadges(address[] owner_, uint256[] price_, uint256[] totalDivis_) internal{\n', '        for (uint256 i = 0; i < owner_.length; i++) {\n', '            badges.push(Badge(owner_[i], price_[i], totalDivis_[i]));\n', '        }\n', '    }\n', '\n', '    function _createNewBadge(address owner_, uint256 price_) internal{\n', '        badges.push(Badge(owner_, price_, 0));\n', '    }\n', '\n', '    function _setOwner(uint256 badgeID_, address owner_) internal{\n', '        badges[badgeID_].owner = owner_;\n', '    }\n', '\n', '    function getOwner(uint256 badgeID_) public view returns(address){\n', '        return badges[badgeID_].owner;\n', '    }\n', '\n', '    function _increasePrice(uint256 badgeID_) internal{\n', '        uint256 newPrice = (badges[badgeID_].price * _badgeFactory.getRandomFactor()) / 100;\n', '        badges[badgeID_].price = SafeMathExt.roundUp(newPrice, 10000 * GWEI);\n', '    }\n', '\n', '    function getPrice(uint256 badgeID_) public view returns(uint256){\n', '        return badges[badgeID_].price;\n', '    }\n', '\n', '    function _increaseTotalDivis(uint256 badgeID_, uint256 divis_) internal{\n', '        badges[badgeID_].totalDivis += divis_;\n', '    }\n', '\n', '    function getTotalDivis(uint256 badgeID_) public view returns(uint256){\n', '        return badges[badgeID_].totalDivis;\n', '    }\n', '\n', '    function getChainLength() public view returns(uint256){\n', '        return badges.length;\n', '    }\n', '\n', '    /*===============================================================================\n', '    =                       FUNCTIONS                       FUNCTIONS               =\n', '    ===============================================================================*/\n', '    /*==============================\n', '    =           OWNER ONLY         =\n', '    ==============================*/\n', '    constructor(address admin_, address teamAmberAddress_) public{\n', '    \t_contractOwner = msg.sender;\n', '        _admin = admin_;\n', '        _teamAmber = TeamAmberInterface(teamAmberAddress_);\n', '    }\n', '\n', '    function initGame(address badgesFactoryAddress_, address[] owner_, uint256[] price_, uint256[] totalDivis_) external onlyContractOwner{\n', '        require(_startTime == 0);\n', '        assert(owner_.length == price_.length && price_.length == totalDivis_.length);\n', '\n', '        if(_badgeFactory == address(0x0)){\n', '            _badgeFactory = BadgeFactoryInterface(badgesFactoryAddress_);\n', '        }\n', '        _initBadges(owner_, price_, totalDivis_);\n', '    }\n', '\n', '    function initReferrals(address[] refArray_) external onlyContractOwner{\n', '        require(_startTime == 0);\n', '        for (uint256 i = 0; i < refArray_.length; i+=2) {\n', '            _refererUpdate(refArray_[i], refArray_[i+1]);\n', '        }\n', '    }\n', '\n', '    function _startContract(uint256 delay_) external onlyContractOwner{\n', '    \trequire(_startTime == 0);\n', '        _startTime = now + delay_;\n', '\n', '        emit onContractStart(_startTime);\n', '    }\n', '\n', '    /*==============================\n', '    =             BUY              =\n', '    ==============================*/\n', '    //Hex Data: 0x7deb6025\n', '    function buy(uint256 badgeID_, address newReferer_) public payable isNotAContract isRunning{\n', '    \t_refererUpdate(msg.sender, newReferer_);\n', '    \t_buy(badgeID_, newReferer_, msg.sender, msg.value);\n', '    }\n', '\n', '    function _buy(uint256 badgeID_, address newReferer_, address msgSender_, uint256 msgValue_) internal{\n', '        address previousOwner = getOwner(badgeID_);\n', "        require(isNotSelf(msgSender_, getOwner(badgeID_)), 'You can not buy from yourself.');\n", "        require(isValidBuy(getPrice(badgeID_), msgValue_), 'It is not a valid buy.');        \n", '\n', '        _diviSplit(badgeID_, previousOwner, msgSender_, msgValue_);\n', '        _extendBadges(badgeID_, msgSender_, _badgeBasePrice);\n', '        _badgeOwnerChange(badgeID_, msgSender_);\n', '        _increasePrice(badgeID_);\n', '\n', '        emit onBadgeBuy(badgeID_, previousOwner, msgSender_, newReferer_, msgValue_, getPrice(badgeID_));\n', '    }\n', '\n', '    function _refererUpdate(address user_, address newReferer_) internal{\n', '    \tif (refererAllowed(user_, _referer[user_], newReferer_)){\n', '    \t\t_referer[user_] = newReferer_;\n', '    \t\temit onRefererSet(user_, newReferer_);\n', '    \t}\n', '    }\n', '\n', '    /*==============================\n', '    =         BADGE SYSTEM         =\n', '    ==============================*/\n', '    function _extendBadges(uint256 badgeID_, address owner_, uint256 price_) internal{\n', '        if (isLastBadgeEle(badgeID_, getChainLength())){\n', '            _createNewBadge(owner_, price_);\n', '        }\n', '    }\n', '\n', '    function _badgeOwnerChange(uint256 badgeID_, address newOwner_) internal{\n', '        _setOwner(badgeID_, newOwner_);\n', '    }\n', '\n', '    /*==============================\n', '    =          DIVI SPLIT          =\n', '    ==============================*/\n', '    function _diviSplit(uint256 badgeID_, address previousOwner_, address msgSender_, uint256 msgValue_) internal{\n', '    \t_shareToDistribution(badgeID_, msgValue_, _shareDistributionRatio);\n', '        _shareToPreviousOwner(previousOwner_, msgValue_, _sharePreviousOwnerRatio);\n', '    \t_shareToReferer(_referer[msgSender_], msgValue_, _shareReferalRatio);\n', '    }\n', '\n', '    function _shareToDistribution(uint256 badgeID_, uint256 msgValue_, uint256 ratio_) internal{\n', '        uint256 share = calcShare(msgValue_, ratio_) / _luckyWinners;\n', '        uint256 idx;\n', '\n', '        for(uint256 i = 0; i < _luckyWinners; i++){\n', '            idx = _badgeFactory.getRandomBadge(badgeID_, i);\n', '            _increaseTotalDivis(idx, share);\n', '            _splitProfit[getOwner(idx)] += share;\n', '        }\n', '    }\n', '\n', '    function _shareToPreviousOwner(address previousOwner_, uint256 msgValue_, uint256 ratio_) internal{\n', '    \t_flipProfit[previousOwner_] += calcShare(msgValue_, ratio_);\n', '    }\n', '\n', '    function _shareToReferer(address referer_, uint256 msgValue_, uint256 ratio_) internal{\n', '    \tif (addressNotSet(referer_)){\n', '    \t\t_waypointProfit[_admin] += calcShare(msgValue_, ratio_);\n', '    \t} else {\n', '    \t\t_waypointProfit[referer_] += calcShare(msgValue_, ratio_);\n', '    \t}\n', '    }\n', '\n', '    /*==============================\n', '    =           WITHDRAW           =\n', '    ==============================*/\n', '    //Hex Data: 0x853828b6\n', '    function withdrawAll() public isNotAContract{\n', '        uint256 splitProfit = _splitProfit[msg.sender];\n', '        _splitProfit[msg.sender] = 0;\n', '\n', '        uint256 flipProfit = _flipProfit[msg.sender];\n', '        _flipProfit[msg.sender] = 0;\n', '\n', '        uint256 waypointProfit = _waypointProfit[msg.sender];\n', '        _waypointProfit[msg.sender] = 0;\n', '\n', '        _transferDivis(msg.sender, splitProfit + flipProfit + waypointProfit);\n', '        emit onWithdraw(msg.sender, splitProfit, flipProfit, waypointProfit);\n', '    }\n', '\n', '    function _transferDivis(address msgSender_, uint256 payout_) internal{\n', '        assert(address(this).balance >= payout_);\n', '        if(msgSender_ == _admin){\n', '            _teamAmber.distribute.value(payout_)();\n', '        } else {\n', '            msgSender_.transfer(payout_);       \n', '        }\n', '    }\n', '\n', '    /*==============================\n', '    =            HELPERS           =\n', '    ==============================*/\n', '    function getStartTime() public view returns (uint256){\n', '        return _startTime;\n', '    }\n', '\n', '    function getSplitProfit(address user_) public view returns(uint256){\n', '        return _splitProfit[user_];\n', '    }\n', '\n', '    function getFlipProfit(address user_) public view returns(uint256){\n', '        return _flipProfit[user_];\n', '    }\n', '\n', '    function getWaypointProfit(address user_) public view returns(uint256){\n', '        return _waypointProfit[user_];\n', '    }\n', '\n', '    function getReferer(address user_) public view returns(address){\n', '    \treturn _referer[user_];\n', '    }\n', '\n', '    function getBalanceContract() public view returns(uint256){\n', '    \treturn address(this).balance;\n', '    }\n', '\n', '    function getAllBadges() public view returns(address[], uint256[], uint256[]){\n', '        uint256 chainLength = getChainLength();\n', '        return (getBadges(0, chainLength-1));\n', '    }\n', '\n', '    function getBadges(uint256 _from, uint256 _to) public view returns(address[], uint256[], uint256[]){\n', "        require(_from <= _to, 'Index FROM needs to be smaller or same than index TO');\n", '\n', '        address[] memory owner = new address[](_to - _from + 1);\n', '        uint256[] memory price = new uint256[](_to - _from + 1);\n', '        uint256[] memory totalDivis = new uint256[](_to - _from + 1);\n', '\n', '        for (uint256 i = _from; i <= _to; i++) {\n', '            owner[i - _from] = getOwner(i);\n', '            price[i - _from] = getPrice(i);\n', '            totalDivis[i - _from] = getTotalDivis(i);\n', '        }\n', '        return (owner, price, totalDivis);\n', '    }\n', '}']