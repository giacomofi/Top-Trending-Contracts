['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender)\n', '        public view returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(\n', '            address indexed owner,\n', '            address indexed spender,\n', '            uint256 value\n', '            );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '            ERC20 token,\n', '            address from,\n', '            address to,\n', '            uint256 value\n', '            )\n', '        internal\n', '        {\n', '            require(token.transferFrom(from, to, value));\n', '        }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title TokenTimelock\n', ' * @dev TokenTimelock is a token holder contract that will allow a\n', ' * beneficiary to extract the tokens after a given release time\n', ' */\n', 'contract TokenTimelock {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    // ERC20 basic token contract being held\n', '    ERC20Basic public token;\n', '\n', '    // beneficiary of tokens after they are released\n', '    address public beneficiary = 0x2F1C2Fb4cf9b46172D59d8878Fc795277b8a2c9a;\n', '\n', '    // timestamp when token release is enabled\n', '    uint256 public firstTime = 1529942400;         //2018-06-26\n', '    uint256 public secondTime = 1532534400;        //2018-07-26\n', '    uint256 public thirdTime = 1535212800;         //2018-08-26\n', '\n', '    uint256 public firstPay = 900000000000000000000000000;    //900 million  FTI\n', '    uint256 public secondPay = 900000000000000000000000000;    //900 million  FTI\n', '    uint256 public thirdPay = 600000000000000000000000000;    //900 million  FTI\n', '\n', '    constructor(\n', '            ERC20Basic _token\n', '            )\n', '        public\n', '        {\n', '            token = _token;\n', '        }\n', '\n', '    /**\n', '     * @notice Transfers tokens held by timelock to beneficiary.\n', '     */\n', '    function release() public {\n', '        uint256 tmpPay = 0;\n', '        if(block.timestamp >= firstTime && firstPay > 0){\n', '            tmpPay = firstPay;\n', '            firstPay = 0;\n', '        }else if(block.timestamp >= secondTime && secondPay > 0 ){\n', '            tmpPay = secondPay;\n', '            secondPay = 0;\n', '        }else if (block.timestamp >= thirdTime && thirdPay > 0) {\n', '            tmpPay = token.balanceOf(this);\n', '            thirdPay = 0;\n', '        }\n', '        require(tmpPay > 0);\n', '        uint256 amount = token.balanceOf(this);\n', '        require(amount >= tmpPay);\n', '        token.safeTransfer(beneficiary, tmpPay);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender)\n', '        public view returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(\n', '            address indexed owner,\n', '            address indexed spender,\n', '            uint256 value\n', '            );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '            ERC20 token,\n', '            address from,\n', '            address to,\n', '            uint256 value\n', '            )\n', '        internal\n', '        {\n', '            require(token.transferFrom(from, to, value));\n', '        }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title TokenTimelock\n', ' * @dev TokenTimelock is a token holder contract that will allow a\n', ' * beneficiary to extract the tokens after a given release time\n', ' */\n', 'contract TokenTimelock {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    // ERC20 basic token contract being held\n', '    ERC20Basic public token;\n', '\n', '    // beneficiary of tokens after they are released\n', '    address public beneficiary = 0x2F1C2Fb4cf9b46172D59d8878Fc795277b8a2c9a;\n', '\n', '    // timestamp when token release is enabled\n', '    uint256 public firstTime = 1529942400;         //2018-06-26\n', '    uint256 public secondTime = 1532534400;        //2018-07-26\n', '    uint256 public thirdTime = 1535212800;         //2018-08-26\n', '\n', '    uint256 public firstPay = 900000000000000000000000000;    //900 million  FTI\n', '    uint256 public secondPay = 900000000000000000000000000;    //900 million  FTI\n', '    uint256 public thirdPay = 600000000000000000000000000;    //900 million  FTI\n', '\n', '    constructor(\n', '            ERC20Basic _token\n', '            )\n', '        public\n', '        {\n', '            token = _token;\n', '        }\n', '\n', '    /**\n', '     * @notice Transfers tokens held by timelock to beneficiary.\n', '     */\n', '    function release() public {\n', '        uint256 tmpPay = 0;\n', '        if(block.timestamp >= firstTime && firstPay > 0){\n', '            tmpPay = firstPay;\n', '            firstPay = 0;\n', '        }else if(block.timestamp >= secondTime && secondPay > 0 ){\n', '            tmpPay = secondPay;\n', '            secondPay = 0;\n', '        }else if (block.timestamp >= thirdTime && thirdPay > 0) {\n', '            tmpPay = token.balanceOf(this);\n', '            thirdPay = 0;\n', '        }\n', '        require(tmpPay > 0);\n', '        uint256 amount = token.balanceOf(this);\n', '        require(amount >= tmpPay);\n', '        token.safeTransfer(beneficiary, tmpPay);\n', '    }\n', '}']
