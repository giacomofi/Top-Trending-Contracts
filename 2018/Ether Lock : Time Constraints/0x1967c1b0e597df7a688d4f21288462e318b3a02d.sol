['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface \n', ' * \n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnableWithAdmin \n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableWithAdmin {\n', '  address public owner;\n', '  address public adminOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    adminOwner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the admin.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == adminOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or admin.\n', '   */\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == adminOwner || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current adminOwner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferAdminOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(adminOwner, newOwner);\n', '    adminOwner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string){\n', '      if (i == 0) return "0";\n', '      uint j = i;\n', '      uint length;\n', '      while (j != 0){\n', '          length++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(length);\n', '      uint k = length - 1;\n', '      while (i != 0){\n', '          bstr[k--] = byte(48 + i % 10);\n', '          i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', ' \n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title LockedPrivatesale\n', ' * @notice Contract is not payable.\n', ' * Owner or admin can allocate tokens.\n', ' * Tokens will be released in 3 steps / dates. \n', ' *\n', ' *\n', ' */\n', 'contract LockedPrivatesale is OwnableWithAdmin {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 private constant DECIMALFACTOR = 10**uint256(18);\n', '\n', '\n', '  event FundsBooked(address backer, uint256 amount, bool isContribution);\n', '  event LogTokenClaimed(address indexed _recipient, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n', '  event LogNewAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogRemoveAllocation(address indexed _recipient, uint256 _tokenAmountRemoved);\n', '  event LogOwnerAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '   \n', '\n', '  // Amount of tokens claimed\n', '  uint256 public grandTotalClaimed = 0;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Amount of tokens Raised\n', '  uint256 public tokensTotal = 0;\n', '\n', '  // Max token amount\n', '  uint256 public hardCap = 0;\n', '  \n', '\n', '  //Tokens will be released in 3 steps/dates\n', '  uint256 public step1;\n', '  uint256 public step2;\n', '  uint256 public step3;\n', '\n', '  // Buyers total allocation\n', '  mapping (address => uint256) public allocationsTotal;\n', '\n', '  // User total Claimed\n', '  mapping (address => uint256) public totalClaimed;\n', '\n', '  // List of allocation step 1\n', '  mapping (address => uint256) public allocations1;\n', '\n', '  // List of allocation step 2\n', '  mapping (address => uint256) public allocations2;\n', '\n', '  // List of allocation step 3\n', '  mapping (address => uint256) public allocations3;\n', '\n', '  //Buyers\n', '  mapping(address => bool) public buyers;\n', '\n', '  //Buyers who received all there tokens\n', '  mapping(address => bool) public buyersReceived;\n', '\n', '  //List of all addresses\n', '  address[] public addresses;\n', '  \n', ' \n', '  constructor(uint256 _step1, uint256 _step2, uint256 _step3, ERC20 _token) public {\n', '     \n', '    require(_token != address(0));\n', '\n', '    require(_step1 >= now);\n', '    require(_step2 >= _step1);\n', '    require(_step3 >= _step2);\n', '\n', '    step1       = _step1;\n', '    step2       = _step2;\n', '    step3       = _step3;\n', '\n', '    token = _token;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () public {\n', '    //Not payable\n', '  }\n', '\n', '\n', '\n', '  /**\n', '    * @dev Set allocation buy admin\n', '    * @param _recipient Users wallet\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setAllocation (address _recipient, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '      require(_tokenAmount > 0);      \n', '      require(_recipient != address(0)); \n', '\n', '      //Check hardCap \n', '      require(_validateHardCap(_tokenAmount));\n', '\n', '      //Allocate tokens\n', '      _setAllocation(_recipient, _tokenAmount);    \n', '\n', '      //Increese token amount\n', '      tokensTotal = tokensTotal.add(_tokenAmount);  \n', '\n', '      //Logg Allocation\n', '      emit LogOwnerAllocation(_recipient, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '    * @dev Remove allocation \n', '    * @param _recipient Users wallet\n', '    *  \n', '    */\n', '  function removeAllocation (address _recipient) onlyOwner  public{         \n', '      require(_recipient != address(0)); \n', '      require(totalClaimed[_recipient] == 0); //Check if user claimed tokens\n', '\n', '\n', '      //_recipient total amount\n', '      uint256 _tokenAmountRemoved = allocationsTotal[_recipient];\n', '\n', '      //Decreese token amount\n', '      tokensTotal = tokensTotal.sub(_tokenAmountRemoved);\n', '\n', '      //Reset allocations\n', '      allocations1[_recipient]      = 0; \n', '      allocations2[_recipient]      = 0; \n', '      allocations3[_recipient]      = 0;\n', '      allocationsTotal[_recipient]  = 0; // Remove  \n', '      \n', '      //Set buyer to false\n', '      buyers[_recipient] = false;\n', '\n', '      emit LogRemoveAllocation(_recipient, _tokenAmountRemoved);\n', '  }\n', '\n', '\n', ' /**\n', '   * @dev Set internal allocation \n', '   *  _buyer The adress of the buyer\n', '   *  _tokenAmount Amount Allocated tokens + 18 decimals\n', '   */\n', '  function _setAllocation (address _buyer, uint256 _tokenAmount) internal{\n', '\n', '      if(!buyers[_buyer]){\n', '        //Add buyer to buyers list \n', '        buyers[_buyer] = true;\n', '\n', '        //Add _buyer to addresses list\n', '        addresses.push(_buyer);\n', '\n', '        //Reset buyer allocation\n', '        allocationsTotal[_buyer] = 0;\n', '\n', '      }  \n', '\n', '      //Add tokens to buyers allocation\n', '      allocationsTotal[_buyer]  = allocationsTotal[_buyer].add(_tokenAmount); \n', '\n', '      //Spilt amount in 3\n', '      uint256 splitAmount = allocationsTotal[_buyer].div(3);\n', '      uint256 diff        = allocationsTotal[_buyer].sub(splitAmount+splitAmount+splitAmount);\n', '\n', '\n', '      //Sale steps\n', '      allocations1[_buyer]   = splitAmount;            // step 1 \n', '      allocations2[_buyer]   = splitAmount;            // step 2\n', '      allocations3[_buyer]   = splitAmount.add(diff);  // step 3 + diff\n', '\n', '\n', '      //Logg Allocation\n', '      emit LogNewAllocation(_buyer, _tokenAmount);\n', '\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Return address available allocation\n', '    * @param _recipient which address is applicable\n', '    */\n', '  function checkAvailableTokens (address _recipient) public view returns (uint256) {\n', '    //Check if user have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    uint256 _availableTokens = 0;\n', '\n', '    if(now >= step1){\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]);\n', '    }\n', '    if(now >= step2){\n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '    }\n', '    if(now >= step3){\n', '      _availableTokens = _availableTokens.add(allocations3[_recipient]);\n', '    }\n', '\n', '    return _availableTokens;\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to their address\n', '    * @param _recipients Array of addresses to withdraw tokens for\n', '    */\n', '  function distributeManyTokens(address[] _recipients) onlyOwnerOrAdmin public {\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '\n', '      //Check if address is buyer \n', '      //And if the buyer is not already received all the tokens\n', '      if(buyers[_recipients[i]] && !buyersReceived[_recipients[i]]){\n', '        distributeTokens( _recipients[i]);\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Loop address and distribute tokens\n', '    *\n', '    */\n', '  function distributeAllTokens() onlyOwner public {\n', '    for (uint256 i = 0; i < addresses.length; i++) {\n', '\n', '      //Check if address is buyer \n', '      //And if the buyer is not already received all the tokens\n', '      if(buyers[addresses[i]] && !buyersReceived[addresses[i]]){\n', '        distributeTokens( addresses[i]);\n', '      }\n', '            \n', '    }\n', '  }\n', '\n', '  /**\n', '    * @notice Withdraw available tokens\n', '    * \n', '    */\n', '  function withdrawTokens() public {\n', '    distributeTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to _recipient\n', '    *\n', '    */\n', '  function distributeTokens(address _recipient) public {\n', '    //Check date\n', '    require(now >= step1);\n', '    //Check have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    //\n', '    bool _lastWithdraw = false;\n', '\n', '    uint256 _availableTokens = 0;\n', '    \n', '    if(now >= step1  && now >= step2  && now >= step3 ){      \n', '\n', '      _availableTokens = _availableTokens.add(allocations3[_recipient]); \n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]);\n', '\n', '      //Reset all allocations\n', '      allocations3[_recipient] = 0;\n', '      allocations2[_recipient] = 0;\n', '      allocations1[_recipient] = 0;\n', '\n', '      //Step 3, all tokens should be received\n', '      _lastWithdraw = true;\n', '\n', '\n', '    } else if(now >= step1  && now >= step2 ){\n', '      \n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]); \n', '\n', '      //Reset step 1 & step 2 allocation\n', '      allocations2[_recipient] = 0;\n', '      allocations1[_recipient] = 0;\n', '\n', '\n', '    }else if(now >= step1){\n', '\n', '      _availableTokens = allocations1[_recipient];\n', '\n', '      //Reset step 1 allocation\n', '      allocations1[_recipient] = 0; \n', '\n', '\n', '    }\n', '\n', '    require(_availableTokens>0);    \n', '\n', '    //Check if contract has tokens\n', '    require(token.balanceOf(this)>=_availableTokens);\n', '\n', '    //Transfer tokens\n', '    require(token.transfer(_recipient, _availableTokens));\n', '\n', '    //Add claimed tokens to totalClaimed\n', '    totalClaimed[_recipient] = totalClaimed[_recipient].add(_availableTokens);\n', '\n', '    //Add claimed tokens to grandTotalClaimed\n', '    grandTotalClaimed = grandTotalClaimed.add(_availableTokens);\n', '\n', '    emit LogTokenClaimed(_recipient, _availableTokens, allocationsTotal[_recipient], grandTotalClaimed);\n', '\n', '    //If all tokens are received, add _recipient to buyersReceived\n', '    //To prevent the loop to fail if user allready used the withdrawTokens\n', '    if(_lastWithdraw){\n', '      buyersReceived[_recipient] = true;\n', '    }\n', '\n', '  }\n', '\n', '\n', '\n', '  function _validateHardCap(uint256 _tokenAmount) internal view returns (bool) {\n', '      return tokensTotal.add(_tokenAmount) <= hardCap;\n', '  }\n', '\n', '\n', '  function getListOfAddresses() public view returns (address[]) {    \n', '    return addresses;\n', '  }\n', '\n', '\n', '  // Allow transfer of tokens back to owner or reserve wallet\n', '  function returnTokens() public onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '  // Owner can transfer tokens that are sent here by mistake\n', '  function refundTokens(address _recipient, ERC20 _token) public onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    require(_token.transfer(_recipient, balance));\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title EDPrivateSale\n', ' * @dev Only owner or admin can allocate tokens. Tokens can be booked in advanced without the token contract.\n', ' * Tokens will be released in 3 steps / dates. \n', ' * A token needs to be attached to this contract and this contract needs to have balance to be able to send tokens to collector\n', ' * No whitelist in contract is requierd\n', ' *\n', '*/\n', 'contract EDPrivateSale is LockedPrivatesale {\n', '  constructor(\n', '    uint256 _step1, \n', '    uint256 _step2, \n', '    uint256 _step3,    \n', '    ERC20 _token\n', '  ) public LockedPrivatesale(_step1, _step2, _step3, _token) {\n', '\n', '    // 50,000,000 tokens\n', '    hardCap = 50000000 * (10**uint256(18)); \n', '\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface \n', ' * \n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnableWithAdmin \n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableWithAdmin {\n', '  address public owner;\n', '  address public adminOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    adminOwner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the admin.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == adminOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or admin.\n', '   */\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == adminOwner || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current adminOwner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferAdminOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(adminOwner, newOwner);\n', '    adminOwner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string){\n', '      if (i == 0) return "0";\n', '      uint j = i;\n', '      uint length;\n', '      while (j != 0){\n', '          length++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(length);\n', '      uint k = length - 1;\n', '      while (i != 0){\n', '          bstr[k--] = byte(48 + i % 10);\n', '          i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', ' \n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title LockedPrivatesale\n', ' * @notice Contract is not payable.\n', ' * Owner or admin can allocate tokens.\n', ' * Tokens will be released in 3 steps / dates. \n', ' *\n', ' *\n', ' */\n', 'contract LockedPrivatesale is OwnableWithAdmin {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 private constant DECIMALFACTOR = 10**uint256(18);\n', '\n', '\n', '  event FundsBooked(address backer, uint256 amount, bool isContribution);\n', '  event LogTokenClaimed(address indexed _recipient, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n', '  event LogNewAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogRemoveAllocation(address indexed _recipient, uint256 _tokenAmountRemoved);\n', '  event LogOwnerAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '   \n', '\n', '  // Amount of tokens claimed\n', '  uint256 public grandTotalClaimed = 0;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Amount of tokens Raised\n', '  uint256 public tokensTotal = 0;\n', '\n', '  // Max token amount\n', '  uint256 public hardCap = 0;\n', '  \n', '\n', '  //Tokens will be released in 3 steps/dates\n', '  uint256 public step1;\n', '  uint256 public step2;\n', '  uint256 public step3;\n', '\n', '  // Buyers total allocation\n', '  mapping (address => uint256) public allocationsTotal;\n', '\n', '  // User total Claimed\n', '  mapping (address => uint256) public totalClaimed;\n', '\n', '  // List of allocation step 1\n', '  mapping (address => uint256) public allocations1;\n', '\n', '  // List of allocation step 2\n', '  mapping (address => uint256) public allocations2;\n', '\n', '  // List of allocation step 3\n', '  mapping (address => uint256) public allocations3;\n', '\n', '  //Buyers\n', '  mapping(address => bool) public buyers;\n', '\n', '  //Buyers who received all there tokens\n', '  mapping(address => bool) public buyersReceived;\n', '\n', '  //List of all addresses\n', '  address[] public addresses;\n', '  \n', ' \n', '  constructor(uint256 _step1, uint256 _step2, uint256 _step3, ERC20 _token) public {\n', '     \n', '    require(_token != address(0));\n', '\n', '    require(_step1 >= now);\n', '    require(_step2 >= _step1);\n', '    require(_step3 >= _step2);\n', '\n', '    step1       = _step1;\n', '    step2       = _step2;\n', '    step3       = _step3;\n', '\n', '    token = _token;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () public {\n', '    //Not payable\n', '  }\n', '\n', '\n', '\n', '  /**\n', '    * @dev Set allocation buy admin\n', '    * @param _recipient Users wallet\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setAllocation (address _recipient, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '      require(_tokenAmount > 0);      \n', '      require(_recipient != address(0)); \n', '\n', '      //Check hardCap \n', '      require(_validateHardCap(_tokenAmount));\n', '\n', '      //Allocate tokens\n', '      _setAllocation(_recipient, _tokenAmount);    \n', '\n', '      //Increese token amount\n', '      tokensTotal = tokensTotal.add(_tokenAmount);  \n', '\n', '      //Logg Allocation\n', '      emit LogOwnerAllocation(_recipient, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '    * @dev Remove allocation \n', '    * @param _recipient Users wallet\n', '    *  \n', '    */\n', '  function removeAllocation (address _recipient) onlyOwner  public{         \n', '      require(_recipient != address(0)); \n', '      require(totalClaimed[_recipient] == 0); //Check if user claimed tokens\n', '\n', '\n', '      //_recipient total amount\n', '      uint256 _tokenAmountRemoved = allocationsTotal[_recipient];\n', '\n', '      //Decreese token amount\n', '      tokensTotal = tokensTotal.sub(_tokenAmountRemoved);\n', '\n', '      //Reset allocations\n', '      allocations1[_recipient]      = 0; \n', '      allocations2[_recipient]      = 0; \n', '      allocations3[_recipient]      = 0;\n', '      allocationsTotal[_recipient]  = 0; // Remove  \n', '      \n', '      //Set buyer to false\n', '      buyers[_recipient] = false;\n', '\n', '      emit LogRemoveAllocation(_recipient, _tokenAmountRemoved);\n', '  }\n', '\n', '\n', ' /**\n', '   * @dev Set internal allocation \n', '   *  _buyer The adress of the buyer\n', '   *  _tokenAmount Amount Allocated tokens + 18 decimals\n', '   */\n', '  function _setAllocation (address _buyer, uint256 _tokenAmount) internal{\n', '\n', '      if(!buyers[_buyer]){\n', '        //Add buyer to buyers list \n', '        buyers[_buyer] = true;\n', '\n', '        //Add _buyer to addresses list\n', '        addresses.push(_buyer);\n', '\n', '        //Reset buyer allocation\n', '        allocationsTotal[_buyer] = 0;\n', '\n', '      }  \n', '\n', '      //Add tokens to buyers allocation\n', '      allocationsTotal[_buyer]  = allocationsTotal[_buyer].add(_tokenAmount); \n', '\n', '      //Spilt amount in 3\n', '      uint256 splitAmount = allocationsTotal[_buyer].div(3);\n', '      uint256 diff        = allocationsTotal[_buyer].sub(splitAmount+splitAmount+splitAmount);\n', '\n', '\n', '      //Sale steps\n', '      allocations1[_buyer]   = splitAmount;            // step 1 \n', '      allocations2[_buyer]   = splitAmount;            // step 2\n', '      allocations3[_buyer]   = splitAmount.add(diff);  // step 3 + diff\n', '\n', '\n', '      //Logg Allocation\n', '      emit LogNewAllocation(_buyer, _tokenAmount);\n', '\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Return address available allocation\n', '    * @param _recipient which address is applicable\n', '    */\n', '  function checkAvailableTokens (address _recipient) public view returns (uint256) {\n', '    //Check if user have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    uint256 _availableTokens = 0;\n', '\n', '    if(now >= step1){\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]);\n', '    }\n', '    if(now >= step2){\n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '    }\n', '    if(now >= step3){\n', '      _availableTokens = _availableTokens.add(allocations3[_recipient]);\n', '    }\n', '\n', '    return _availableTokens;\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to their address\n', '    * @param _recipients Array of addresses to withdraw tokens for\n', '    */\n', '  function distributeManyTokens(address[] _recipients) onlyOwnerOrAdmin public {\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '\n', '      //Check if address is buyer \n', '      //And if the buyer is not already received all the tokens\n', '      if(buyers[_recipients[i]] && !buyersReceived[_recipients[i]]){\n', '        distributeTokens( _recipients[i]);\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Loop address and distribute tokens\n', '    *\n', '    */\n', '  function distributeAllTokens() onlyOwner public {\n', '    for (uint256 i = 0; i < addresses.length; i++) {\n', '\n', '      //Check if address is buyer \n', '      //And if the buyer is not already received all the tokens\n', '      if(buyers[addresses[i]] && !buyersReceived[addresses[i]]){\n', '        distributeTokens( addresses[i]);\n', '      }\n', '            \n', '    }\n', '  }\n', '\n', '  /**\n', '    * @notice Withdraw available tokens\n', '    * \n', '    */\n', '  function withdrawTokens() public {\n', '    distributeTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to _recipient\n', '    *\n', '    */\n', '  function distributeTokens(address _recipient) public {\n', '    //Check date\n', '    require(now >= step1);\n', '    //Check have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    //\n', '    bool _lastWithdraw = false;\n', '\n', '    uint256 _availableTokens = 0;\n', '    \n', '    if(now >= step1  && now >= step2  && now >= step3 ){      \n', '\n', '      _availableTokens = _availableTokens.add(allocations3[_recipient]); \n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]);\n', '\n', '      //Reset all allocations\n', '      allocations3[_recipient] = 0;\n', '      allocations2[_recipient] = 0;\n', '      allocations1[_recipient] = 0;\n', '\n', '      //Step 3, all tokens should be received\n', '      _lastWithdraw = true;\n', '\n', '\n', '    } else if(now >= step1  && now >= step2 ){\n', '      \n', '      _availableTokens = _availableTokens.add(allocations2[_recipient]);\n', '      _availableTokens = _availableTokens.add(allocations1[_recipient]); \n', '\n', '      //Reset step 1 & step 2 allocation\n', '      allocations2[_recipient] = 0;\n', '      allocations1[_recipient] = 0;\n', '\n', '\n', '    }else if(now >= step1){\n', '\n', '      _availableTokens = allocations1[_recipient];\n', '\n', '      //Reset step 1 allocation\n', '      allocations1[_recipient] = 0; \n', '\n', '\n', '    }\n', '\n', '    require(_availableTokens>0);    \n', '\n', '    //Check if contract has tokens\n', '    require(token.balanceOf(this)>=_availableTokens);\n', '\n', '    //Transfer tokens\n', '    require(token.transfer(_recipient, _availableTokens));\n', '\n', '    //Add claimed tokens to totalClaimed\n', '    totalClaimed[_recipient] = totalClaimed[_recipient].add(_availableTokens);\n', '\n', '    //Add claimed tokens to grandTotalClaimed\n', '    grandTotalClaimed = grandTotalClaimed.add(_availableTokens);\n', '\n', '    emit LogTokenClaimed(_recipient, _availableTokens, allocationsTotal[_recipient], grandTotalClaimed);\n', '\n', '    //If all tokens are received, add _recipient to buyersReceived\n', '    //To prevent the loop to fail if user allready used the withdrawTokens\n', '    if(_lastWithdraw){\n', '      buyersReceived[_recipient] = true;\n', '    }\n', '\n', '  }\n', '\n', '\n', '\n', '  function _validateHardCap(uint256 _tokenAmount) internal view returns (bool) {\n', '      return tokensTotal.add(_tokenAmount) <= hardCap;\n', '  }\n', '\n', '\n', '  function getListOfAddresses() public view returns (address[]) {    \n', '    return addresses;\n', '  }\n', '\n', '\n', '  // Allow transfer of tokens back to owner or reserve wallet\n', '  function returnTokens() public onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '  // Owner can transfer tokens that are sent here by mistake\n', '  function refundTokens(address _recipient, ERC20 _token) public onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    require(_token.transfer(_recipient, balance));\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title EDPrivateSale\n', ' * @dev Only owner or admin can allocate tokens. Tokens can be booked in advanced without the token contract.\n', ' * Tokens will be released in 3 steps / dates. \n', ' * A token needs to be attached to this contract and this contract needs to have balance to be able to send tokens to collector\n', ' * No whitelist in contract is requierd\n', ' *\n', '*/\n', 'contract EDPrivateSale is LockedPrivatesale {\n', '  constructor(\n', '    uint256 _step1, \n', '    uint256 _step2, \n', '    uint256 _step3,    \n', '    ERC20 _token\n', '  ) public LockedPrivatesale(_step1, _step2, _step3, _token) {\n', '\n', '    // 50,000,000 tokens\n', '    hardCap = 50000000 * (10**uint256(18)); \n', '\n', '  }\n', '}']
