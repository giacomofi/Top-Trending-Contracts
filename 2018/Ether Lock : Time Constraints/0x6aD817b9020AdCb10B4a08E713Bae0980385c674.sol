['pragma solidity ^0.4.20;\n', '//**양종만**정병두**//180419~\n', '/*모든 행위는 1wei단위로 되기때문에 주의해야됨\n', 'ex :\n', '총 발행 토큰 111\n', '소수점18자리로 했을때 토탈 토큰 111 000 000 000 000 000 000(wei단위임)\n', '1토큰 전송\n', '남은 토큰 110999999999999999999\n', '토큰Value * 10 ** uint256(소수점자리수)로 미리 계산하면 1토큰 전송시 110 000 000 000 000 000 000\n', '*/\n', '//기본 소수점 자리 18 / 변경되면 payable , transfer에서 달라질수 있으니 주의\n', '//들어오는 이더리움 단위는 1ETH=1000000000000000000Wei 이더 소수점 단위18이기 때문에 소수점 단위가18이 아니면 payable, transfer 함수 주의 해야됨\n', '//** public이 들어간 변수,함수는 일반 사용자들도 볼수있음**//\n', 'contract TokenERC20\n', '{\n', '  //토큰 이름\n', '  string public name;\n', '  //토큰 심볼(단위)\n', '  string public symbol;\n', '  //토큰 단위 소수점 표현\n', '  uint8 public decimals;\n', '  //wei 단위를 편하게 하기 위한 변수\n', '  uint256 _decimals;\n', '  //이더*2=토큰\n', '  uint256 public tokenReward;\n', '  //총 토큰 발행 갯수\n', '  uint256 public totalSupply;\n', '  //토큰 admin\n', '  address public owner;\n', '  //토큰 상태 (text로 보여주기 위한것) ex :  private ,  public , test , demo\n', '  string public status;\n', '  //이더 입금 제한 타임스탬프 (시작시간) // http://www.4webhelp.net/us/timestamp.php 에서 확인가능\n', '  uint256 public start_token_time;\n', '  //이더 입금 제한 타임스탬프 (종료시간)\n', '  uint256 public stop_token_time;\n', '  ///////GMB 토큰은 3자끼리 토큰 이동을 미지원 할것이기 때문에 추가함!!\n', '  uint256 public transferLock;\n', '\n', '  //owner인지 검사하는 부분\n', '  modifier isOwner\n', '  {\n', '    assert(owner == msg.sender);\n', '    _;\n', '  }\n', '\n', '  //외부에서 호출할수 있게 하는것(MIST UI로 확인가능)\n', '  mapping (address => uint256) public balanceOf;\n', '\n', '  //이벤트 기록을 위한것\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event token_Burn(address indexed from, uint256 value);\n', '  event token_Add(address indexed from, uint256 value);\n', '  event Deposit(address _sender, uint amount ,string status);\n', '  event change_Owner(string newOwner);\n', '  event change_Status(string newStatus);\n', '  event change_Name(string newName);\n', '  event change_Symbol(string newSymbol);\n', '  event change_TokenReward(uint256 newTokenReward);\n', '  event change_Time_Stamp(uint256 change_start_time_stamp,uint256 change_stop_time_stamp);\n', '\n', '  //토큰 초기화 함수\n', '  function TokenERC20() public\n', '  {\n', '    //토큰 이름 초기화\n', '    name = "GMB";\n', '    //토큰 심볼(단위) 초기화\n', '    symbol = "MAS";\n', '    //소수점 자리 초기화\n', '    decimals = 18;\n', '    //wei 단위를 편하게 하기 위한 변수\n', '    _decimals = 10 ** uint256(decimals);\n', '    //ETH , 토큰 환산비율\n', '    tokenReward = 0;\n', '    //토큰 발행 갯수 초기화\n', '    totalSupply =  _decimals * 10000000000; //1백억개\n', '    //토큰 상태 초기화\n', '    status = "Private";\n', '    //타임스탬프 초기화 (시작시간) 2018.1.1 00:00:00 (Gmt+9)\n', '    start_token_time = 1514732400;\n', '    //타임스탬프 초기화 (종료시간)  2018.12.31 23:59:59 (Gmt+9)\n', '    stop_token_time = 1546268399;\n', '    //토큰 관리자 지갑 주소 초기화\n', '    owner = msg.sender;\n', '    //발행된 토큰갯수를 토큰생성지갑에 입력\n', '    balanceOf[msg.sender] = totalSupply;\n', '    ///////GMB 토큰은 제3자끼리 토큰 이동을 미지원 할것이기 때문에 추가함!!\n', '    transferLock = 1; //0일때만 transfer 가능\n', '  }\n', '  //*이더 받으면 토큰 전송*//\n', '  function() payable public\n', '  {\n', '    //환산값 변수\n', '    uint256 cal;\n', '    //이더 입금 제한 타임스탬프 (시작시간)\n', '    require(start_token_time < block.timestamp);\n', '    //이더 입금 제한 타임스탬프 (종료시간)\n', '    require(stop_token_time > block.timestamp);\n', '    //ETH보낸사람,ETH코인수 이벤트에 기록\n', '    emit Deposit(msg.sender, msg.value, status);\n', '    //토큰=이더*2\n', '    cal = (msg.value)*tokenReward;\n', '    //토큰 지갑에서 남아있는 토큰수가 보내려는 토큰보다 많은지 검사\n', '    require(balanceOf[owner] >= cal);\n', '    //오버플로어 검사\n', '    require(balanceOf[msg.sender] + cal >= balanceOf[msg.sender]);\n', '    //토큰지갑에서 차감\n', '    balanceOf[owner] -= cal;\n', '    //받는 사람지갑에 토큰 저장\n', '    balanceOf[msg.sender] += cal;\n', '    //이벤트 기록을 남김\n', '    emit Transfer(owner, msg.sender, cal);\n', '  }\n', '  //*토큰 전송*// ex : 1토큰 추가시 1 000 000 000 000 000 000(Mist UI 관리자 페이지에서도 동일, Mist UI 일반 사용자 보내기에서는 1)\n', '  function transfer(address _to, uint256 _value) public\n', '  {\n', '    ///////GMB 토큰은 제3자끼리 토큰 이동을 미지원 할것이기 때문에 추가함!!\n', '    require(transferLock == 0); //0일때만 transfer 가능\n', '    //토큰 지갑에서 남아있는 토큰수가 보내려는 토큰보다 많은지 검사\n', '    require(balanceOf[msg.sender] >= _value);\n', '    //오버플로어 검사\n', '    require((balanceOf[_to] + _value) >= balanceOf[_to]);\n', '    //토큰지갑에서 차감\n', '    balanceOf[msg.sender] -= _value;\n', '    //받는 사람지갑에 토큰 저장\n', '    balanceOf[_to] += _value;\n', '    //이벤트 기록을 남김\n', '    emit Transfer(msg.sender, _to, _value);\n', '  }\n', '  //*토큰 전송 geth에서 편하게 보내기위해 __decimals을 붙여줌*// ex : 1토큰 전송시 1\n', '  function admin_transfer(address _to, uint256 _value) public isOwner\n', '  {\n', '    //tokenValue = _value;\n', '    //토큰 지갑에서 남아있는 토큰수가 보내려는 토큰보다 많은지 검사\n', '    require(balanceOf[msg.sender] >= _value*_decimals);\n', '    //오버플로어 검사\n', '    require(balanceOf[_to] + (_value *_decimals)>= balanceOf[_to]);\n', '    //토큰지갑에서 차감\n', '    balanceOf[msg.sender] -= _value*_decimals;\n', '    //받는 사람지갑에 토큰 저장\n', '    balanceOf[_to] += _value*_decimals;\n', '    //이벤트 기록을 남김\n', '    emit Transfer(msg.sender, _to, _value*_decimals);\n', '  }\n', '  //*지갑에서 지갑으로 토큰 이동* 회수용// ex : 1토큰 회수시 1\n', '  function admin_from_To_transfer(address _from, address _to, uint256 _value) public isOwner\n', '  {\n', '    //tokenValue = _value;\n', '    //토큰 지갑에서 남아있는 토큰수가 보내려는 토큰보다 많은지 검사\n', '    require(balanceOf[_from] >= _value*_decimals);\n', '    //오버플로어 검사\n', '    require(balanceOf[_to] + (_value *_decimals)>= balanceOf[_to]);\n', '    //토큰지갑에서 차감\n', '    balanceOf[_from] -= _value*_decimals;\n', '    //받는 사람지갑에 토큰 저장\n', '    balanceOf[_to] += _value*_decimals;\n', '    //이벤트 기록을 남김\n', '    emit Transfer(_from, _to, _value*_decimals);\n', '  }\n', '  //*총 발행 토큰 소각*// ex : 1토큰 소각시 1\n', '  function admin_token_burn(uint256 _value) public isOwner returns (bool success)\n', '  {\n', '    //남아있는 토큰수보다 소각하려는 토큰수가 많은지 검사\n', '    require(balanceOf[msg.sender] >= _value*_decimals);\n', '    //토큰 지갑에서 차감\n', '    balanceOf[msg.sender] -= _value*_decimals;\n', '    //총 발행 토큰에서 차감\n', '    totalSupply -= _value*_decimals;\n', '    //이벤트 기록을 남김\n', '    emit token_Burn(msg.sender, _value*_decimals);\n', '    return true;\n', '  }\n', '  //*총 발행 토큰 추가*// ex : 1토큰 추가시 1\n', '  function admin_token_add(uint256 _value) public  isOwner returns (bool success)\n', '  {\n', '    require(balanceOf[msg.sender] >= _value*_decimals);\n', '    //토큰 지갑에서 더함\n', '    balanceOf[msg.sender] += _value*_decimals;\n', '    //총 발행 토큰에서 더함\n', '    totalSupply += _value*_decimals;\n', '    //이벤트 기록을 남김\n', '    emit token_Add(msg.sender, _value*_decimals);\n', '    return true;\n', '  }\n', '  //*이름 변경*//  ***토큰으로 등록된 후에는 이더스캔에서 반영이 안됨(컨트랙트 등록 상태에서는 괜찮음)***\n', '  function change_name(string _tokenName) public isOwner returns (bool success)\n', '  {\n', '    //name 변경해준다\n', '    name = _tokenName;\n', '    //이벤트 기록을 남김\n', '    emit change_Name(name);\n', '    return true;\n', '  }\n', '  //*심볼 변경*//  ***토큰으로 등록된 후에는 이더스캔에서 반영이 안됨(컨트랙트 등록 상태에서는 괜찮음)***\n', '  function change_symbol(string _symbol) public isOwner returns (bool success)\n', '  {\n', '    //symbol 변경해준다\n', '    symbol = _symbol;\n', '    //이벤트 기록을 남김\n', '    emit change_Symbol(symbol);\n', '    return true;\n', '  }\n', '  //*status변경*//\n', '  function change_status(string _status) public isOwner returns (bool success)\n', '  {\n', '    //status 변경해준다\n', '    status = _status;\n', '    //이벤트 기록을 남김\n', '    emit change_Status(status);\n', '    return true;\n', '  }\n', '  //*배율 변경*//\n', '  function change_tokenReward(uint256 _tokenReward) public isOwner returns (bool success)\n', '  {\n', '    //tokenReward 변경해준다\n', '    tokenReward = _tokenReward;\n', '    //이벤트 기록을 남김\n', '    emit change_TokenReward(tokenReward);\n', '    return true;\n', '  }\n', '  //*ETH출금*//\n', '  function ETH_withdraw(uint256 amount) public isOwner returns(bool)\n', '  {\n', '    //소수점까지 출금해야되기 때문에 wei단위로 출금 //1ETH 출금시 1 000 000 000 000 000 000 입력 해야됨\n', '    owner.transfer(amount);\n', '    //출금하는건 일반 사용자가 알아야될 필요가 없기때문에 emit 이벤트를 실행하지 않음\n', '    return true;\n', '  }\n', '  //*time_stamp변경*//\n', '  function change_time_stamp(uint256 _start_token_time,uint256 _stop_token_time) public isOwner returns (bool success)\n', '  {\n', '    //start_token_time을 변경해준다\n', '    start_token_time = _start_token_time;\n', '    //stop_token_time을 변경해준다\n', '    stop_token_time = _stop_token_time;\n', '\n', '    //이벤트 기록을 남김\n', '    emit change_Time_Stamp(start_token_time,stop_token_time);\n', '    return true;\n', '  }\n', '  //*owner변경*//\n', '  function change_owner(address to_owner) public isOwner returns (bool success)\n', '  {\n', '    //owner를 변경해준다\n', '    owner = to_owner;\n', '    //이벤트 기록을 남김\n', '    emit change_Owner("Owner_change");\n', '    return true;\n', '  }\n', '  //*transferLock변경*// 0일때만 lock 풀림\n', '  function setTransferLock(uint256 transferLock_status) public isOwner returns (bool success)\n', '  {\n', '    //transferLock 변경해준다\n', '    transferLock = transferLock_status;\n', '    //transferLock은 일반 사용자가 알아야될 필요가 없기때문에 emit 이벤트를 실행하지 않음\n', '    return true;\n', '  }\n', '  //*time_stamp변경,status 변경*//\n', '  function change_time_stamp_status(uint256 _start_token_time,uint256 _stop_token_time,string _status) public isOwner returns (bool success)\n', '  {\n', '    //start_token_time을 변경해준다\n', '    start_token_time = _start_token_time;\n', '    //stop_token_time을 변경해준다\n', '    stop_token_time = _stop_token_time;\n', '    //status 변경해준다\n', '    status = _status;\n', '    //이벤트 기록을 남김\n', '    emit change_Time_Stamp(start_token_time,stop_token_time);\n', '    //이벤트 기록을 남김\n', '    emit change_Status(status);\n', '    return true;\n', '  }\n', '}']