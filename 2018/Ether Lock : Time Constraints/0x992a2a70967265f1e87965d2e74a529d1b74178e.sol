['pragma solidity ^0.4.25;\n', '\n', '/**\n', '    ================================\n', '    Disclaimer: Данный контракт - всего лишь игра и не является профессиональным инструментом заработка.\n', '    Отнеситесь к этому с забавой, пользуйтесь с умом и не забывайте, что вклад денег в фаст-контракты - это всегда крайне рисково. \n', '    Мы не призываем людей относится к данному контракту, как к инвестиционному проекту.\n', '    ================================\n', '\n', '  Gradual.pro - Плавно растущий и долго живущий умножитель КАЖДЫЙ ДЕНЬ с розыгрыванием ДЖЕКПОТА!, который возвращает 121% от вашего депозита!\n', '\n', '  Маленький лимит на депозит избавляет от проблем с КИТАМИ, которые очень сильно тормозили предыдущую версию контракта и значительно продлевает срок его жизни!\n', '\n', '  Автоматические выплаты!\n', '  Полные отчеты о потраченых на рекламу средствах в группе!\n', '  Без ошибок, дыр, автоматический - для выплат НЕ НУЖНА администрация!\n', '  Создан и проверен профессионалами!\n', '  Код полностью документирован на русском языке, каждая строчка понятна!\n', '\n', '  Вебсайт: http://gradual.pro/\n', '  Канал в телеграмме: https://t.me/gradualpro\n', '\n', '  1. Пошлите любую ненулевую сумму на адрес контракта\n', '     - сумма от 0.01 до 1 ETH\n', '     - gas limit минимум 250000\n', '     - вы встанете в очередь\n', '  2. Немного подождите\n', '  3. ...\n', '  4. PROFIT! Вам пришло 121% от вашего депозита.\n', '  5. После 21:00 МСК контракт выплачивает 25% от накопленного джекпота последнему вкладчику.\n', '  6. Остальной джекпот распределяется всем остальным в обратной очереди по 121% от каждого вклада.\n', '  7. Затем очередь обнуляется и запускается заново!\n', '\n', '\n', '  Как это возможно?\n', '  1. Первый инвестор в очереди (вы станете первым очень скоро) получает выплаты от\n', '     новых инвесторов до тех пор, пока не получит 121% от своего депозита\n', '  2. Выплаты могут приходить несколькими частями или все сразу\n', '  3. Как только вы получаете 121% от вашего депозита, вы удаляетесь из очереди\n', '  4. Вы можете делать несколько депозитов сразу\n', '  5. Баланс этого контракта состовляет сумму джекпота на данный момент!\n', '\n', '     Таким образом, последние платят первым, и инвесторы, достигшие выплат 121% от депозита,\n', '     удаляются из очереди, уступая место остальным\n', '\n', '              новый инвестор --|            совсем новый инвестор --|\n', '                 инвестор5     |                новый инвестор      |\n', '                 инвестор4     |     =======>      инвестор5        |\n', '                 инвестор3     |                   инвестор4        |\n', ' (част. выплата) инвестор2    <|                   инвестор3        |\n', '(полная выплата) инвестор1   <-|                   инвестор2   <----|  (доплата до 121%)\n', '\n', '*/\n', '\n', 'contract Restarter {\n', '    // Время отсроченного старта (timestamp)\n', '    uint constant public FIRST_START_TIMESTAMP = 1541008800;\n', '\n', '    // Интервал рестарта\n', '    uint constant public RESTART_INTERVAL = 24 hours; // 24 hours\n', '\n', '    // Адрес кошелька для оплаты рекламы\n', '    address constant private ADS_SUPPORT = 0x79C188C8d8c7dEc9110c340140F46bE10854E754;\n', '\n', '    // Адрес кошелька для оплаты технической поддержки информационных каналов\n', '    address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c;\n', '\n', '    // Процент депозита на рекламу 2%\n', '    uint constant public ADS_PERCENT = 2;\n', '\n', '    // Процент депозита на тех поддержку 1%\n', '    uint constant public TECH_PERCENT = 1;\n', '\n', '    // Процент депозита в Джекпот 3%\n', '    uint constant public JACKPOT_PERCENT = 3;\n', '\n', '    // Процент который перечислится победителю джекпота (последний вкладчик перед рестартом)\n', '    uint constant public JACKPOT_WINNER_PERCENT = 25;\n', '    \n', '    // Процент выплат всем участникам\n', '    uint constant public MULTIPLIER = 121;\n', '\n', '    // Максимальный размер депозита = 1 эфир, чтобы каждый смог учавстовать и киты не тормозили и не пугали вкладчиков\n', '    uint constant public MAX_LIMIT = 1 ether;\n', '\n', '    // Минимальный размер депозита = 0.01 эфира\n', '    uint constant public MIN_LIMIT = 0.01 ether;\n', '\n', '    // Минимальный лимит газа\n', '    uint constant public MINIMAL_GAS_LIMIT = 250000;\n', '\n', '    // Структура Deposit содержит информацию о депозите\n', '    struct Deposit {\n', '        address depositor; // Владелец депозита\n', '        uint128 deposit;   // Сумма депозита\n', '        uint128 expect;    // Сумма выплаты (моментально 121% от депозита)\n', '    }\n', '\n', '    // Событие, чтобы моментально показывать уведомления на сайте\n', '    event Restart(uint timestamp);\n', '\n', '    // Очередь\n', '    Deposit[] private _queue;\n', '\n', '    // Номер обрабатываемого депозита, можно следить в разделе Read contract\n', '    uint public currentReceiverIndex = 0;\n', '\n', '    // Сумма джекпота\n', '    uint public jackpotAmount = 0;\n', '\n', '    // Храним время последнего старта, чтобы знать когда делать рестарт\n', '    uint public lastStartTimestamp;\n', '\n', '    uint public queueCurrentLength = 0;\n', '\n', '    // При создании контракта\n', '    constructor() public {\n', '        // Записываем время первого старта\n', '        lastStartTimestamp = FIRST_START_TIMESTAMP;\n', '    }\n', '\n', '    // Данная функция получает все депозиты, сохраняет их и производит моментальные выплаты\n', '    function () public payable {\n', '        // Проверяем, если отсроченый старт начался\n', '        require(now >= FIRST_START_TIMESTAMP, "Not started yet!");\n', '\n', '        // Проверяем минимальный лимит газа, иначе отменяем депозит и возвращаем деньги вкладчику\n', '        require(gasleft() >= MINIMAL_GAS_LIMIT, "We require more gas!");\n', '\n', '        // Проверяем максимальную сумму вклада\n', '        require(msg.value <= MAX_LIMIT, "Deposit is too big!");\n', '\n', '        // Проверяем минимальную сумму вклада\n', '        require(msg.value >= MIN_LIMIT, "Deposit is too small!");\n', '\n', '        // Проверяем, если нужно сделать рестарт\n', '        if (now >= lastStartTimestamp + RESTART_INTERVAL) {\n', '            // Записываем время нового рестарта\n', '            lastStartTimestamp += (now - lastStartTimestamp) / RESTART_INTERVAL * RESTART_INTERVAL;\n', '            // Выплачиваем Джекпот\n', '            _payoutJackpot();\n', '            _clearQueue();\n', '            // Вызываем событие\n', '            emit Restart(now);\n', '        }\n', '\n', '        // Добавляем депозит в очередь, записываем что ему нужно выплатить % от суммы депозита\n', '        _insertQueue(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * MULTIPLIER / 100)));\n', '\n', '        // Увеличиваем Джекпот\n', '        jackpotAmount += msg.value * JACKPOT_PERCENT / 100;\n', '\n', '        // Отправляем процент на продвижение проекта\n', '        uint ads = msg.value * ADS_PERCENT / 100;\n', '        ADS_SUPPORT.transfer(ads);\n', '\n', '        // Отправляем процент на техническую поддержку проекта\n', '        uint tech = msg.value * TECH_PERCENT / 100;\n', '        TECH_SUPPORT.transfer(tech);\n', '\n', '        // Вызываем функцию оплаты первым в очереди депозитам\n', '        _pay();\n', '    }\n', '\n', '    // Функция используется для оплаты первым в очереди депозитам\n', '    // Каждая новая транзация обрабатывает от 1 до 4+ вкладчиков в начале очереди \n', '    // В зависимости от оставшегося газа\n', '    function _pay() private {\n', '        // Попытаемся послать все деньги имеющиеся на контракте первым в очереди вкладчикам за вычетом суммы Джекпота\n', '        uint128 money = uint128(address(this).balance) - uint128(jackpotAmount);\n', '\n', '        // Проходим по всей очереди\n', '        for (uint i = 0; i < queueCurrentLength; i++) {\n', '\n', '            // Достаем номер первого в очереди депозита\n', '            uint idx = currentReceiverIndex + i;\n', '\n', '            // Достаем информацию о первом депозите\n', '            Deposit storage dep = _queue[idx];\n', '\n', '            // Если у нас есть достаточно денег для полной выплаты, то выплачиваем ему все\n', '            if(money >= dep.expect) {\n', '                // Отправляем ему деньги\n', '                dep.depositor.transfer(dep.expect);\n', '                // Обновляем количество оставшихся денег\n', '                money -= dep.expect;\n', '            } else {\n', '                // Попадаем сюда, если у нас не достаточно денег выплатить все, а лишь часть\n', '                // Отправляем все оставшееся\n', '                dep.depositor.transfer(money);\n', '                // Обновляем количество оставшихся денег\n', '                dep.expect -= money;\n', '                // Выходим из цикла\n', '                break;\n', '            }\n', '\n', '            // Проверяем если еще остался газ, и если его нет, то выходим из цикла\n', '            if (gasleft() <= 50000) {\n', '                //  Следующий вкладчик осуществит выплату следующим в очереди\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Обновляем номер депозита ставшего первым в очереди\n', '        currentReceiverIndex += i;\n', '    }\n', '\n', '    function _payoutJackpot() private {\n', '        // Попытаемся послать все деньги имеющиеся на контракте первым в очереди вкладчикам за вычетом суммы Джекпота\n', '        uint128 money = uint128(jackpotAmount);\n', '\n', '        // Перечисляем 25% с джекпота победителю\n', '        Deposit storage dep = _queue[queueCurrentLength - 1];\n', '\n', '        dep.depositor.transfer(uint128(jackpotAmount * JACKPOT_WINNER_PERCENT / 100));\n', '        money -= uint128(jackpotAmount * JACKPOT_WINNER_PERCENT / 100);\n', '\n', '        // Проходим по всей очереди с конца\n', '        for (uint i = queueCurrentLength - 2; i < queueCurrentLength && i >= currentReceiverIndex; i--) {\n', '            // Достаем информацию о последнем депозите\n', '            dep = _queue[i];\n', '\n', '            // Если у нас есть достаточно денег для полной выплаты, то выплачиваем ему все\n', '            if(money >= dep.expect) {\n', '                // Отправляем ему деньги\n', '                dep.depositor.transfer(dep.expect);\n', '                // Обновляем количество оставшихся денег\n', '                money -= dep.expect;\n', '            } else if (money > 0) {\n', '                // Попадаем сюда, если у нас не достаточно денег выплатить все, а лишь часть\n', '                // Отправляем все оставшееся\n', '                dep.depositor.transfer(money);\n', '                // Обновляем количество оставшихся денег\n', '                dep.expect -= money;\n', '                money = 0;\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Обнуляем джекпот на новый раунд\n', '        jackpotAmount = 0;\n', '        // Обнуляем очередь\n', '        currentReceiverIndex = 0;\n', '    }\n', '\n', '    function _insertQueue(Deposit deposit) private {\n', '        if (queueCurrentLength == _queue.length) {\n', '            _queue.length += 1;\n', '        }\n', '        _queue[queueCurrentLength++] = deposit;\n', '    }\n', '\n', '    function _clearQueue() private {\n', '        queueCurrentLength = 0;\n', '    }\n', '\n', '    // Показывает информацию о депозите по его номеру (idx), можно следить в разделе Read contract\n', '    // Вы можете получить номер депозита  (idx) вызвав функцию getDeposits()\n', '    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n', '        Deposit storage dep = _queue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expect);\n', '    }\n', '\n', '    // Показывает количество вкладов определенного инвестора\n', '    function getDepositsCount(address depositor) public view returns (uint) {\n', '        uint c = 0;\n', '        for(uint i=currentReceiverIndex; i < queueCurrentLength; ++i){\n', '            if(_queue[i].depositor == depositor)\n', '                c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    // Показывает все депозиты (index, deposit, expect) определенного инвестора, можно следить в разделе Read contract\n', '    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\n', '        uint c = getDepositsCount(depositor);\n', '\n', '        idxs = new uint[](c);\n', '        deposits = new uint128[](c);\n', '        expects = new uint128[](c);\n', '\n', '        if(c > 0) {\n', '            uint j = 0;\n', '            for(uint i = currentReceiverIndex; i < queueCurrentLength; ++i){\n', '                Deposit storage dep = _queue[i];\n', '                if(dep.depositor == depositor){\n', '                    idxs[j] = i;\n', '                    deposits[j] = dep.deposit;\n', '                    expects[j] = dep.expect;\n', '                    j++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    // Показывает длинну очереди, можно следить в разделе Read contract\n', '    function getQueueLength() public view returns (uint) {\n', '        return queueCurrentLength - currentReceiverIndex;\n', '    }\n', '\n', '}']