['pragma solidity ^0.4.22;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address and\n', ' *      provides basic authorization control functions\n', ' */\n', 'contract Ownable {\n', '    // Public properties\n', '    address public owner;\n', '\n', '    // Log if ownership has been changed\n', '    event ChangeOwnership(address indexed _owner, address indexed _newOwner);\n', '\n', '    // Checks if address is an owner\n', '    modifier OnlyOwner() {\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '    }\n', '\n', '    // The Ownable constructor sets the owner address\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Transfer current ownership to the new account\n', '    function transferOwnership(address _newOwner) public OnlyOwner {\n', '        require(_newOwner != address(0x0));\n', '\n', '        owner = _newOwner;\n', '\n', '        emit ChangeOwnership(owner, _newOwner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    /*\n', '    * @dev Event to notify listeners about pause.\n', '    * @param pauseReason  string Reason the token was paused for.\n', '    */\n', '    event Pause(string pauseReason);\n', '    /*\n', '    * @dev Event to notify listeners about pause.\n', '    * @param unpauseReason  string Reason the token was unpaused for.\n', '    */\n', '    event Unpause(string unpauseReason);\n', '\n', '    bool public isPaused;\n', '    string public pauseNotice;\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier IsNotPaused() {\n', '        require(!isPaused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier IsPaused() {\n', '        require(isPaused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    * @param _reason string The reason for the pause.\n', '    */\n', '    function pause(string _reason) OnlyOwner IsNotPaused public {\n', '        isPaused = true;\n', '        pauseNotice = _reason;\n', '        emit Pause(_reason);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     * @param _reason string Reason for the un pause.\n', '     */\n', '    function unpause(string _reason) OnlyOwner IsPaused public {\n', '        isPaused = false;\n', '        pauseNotice = _reason;\n', '        emit Unpause(_reason);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint256 theBalance);\n', '    function transfer(address to, uint256 value) public returns(bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns(uint256 theAllowance);\n', '    function transferFrom(address from, address to, uint256 value) public returns(bool success);\n', '    function approve(address spender, uint256 value) public returns(bool success);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken without allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '    * @dev Get the token balance for account\n', '    * @param _address The address to query the balance of._address\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _address) public constant returns(uint256 theBalance){\n', '        return balances[_address];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer the balance from owner&#39;s account to another account\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    * @return Returns true if transfer has been successful\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns(bool success){\n', '        require(_to != address(0x0) && _value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens approved by the owner that can be transferred to the spender&#39;s account\n', '     * @param _owner The address which owns the funds.\n', '     * @param _spender The address which will spend the funds.\n', '     * @return An uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 theAllowance){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * To change the approve amount you first have to reduce the addresses`\n', '     * allowance to zero by calling `approve(_spender, 0)` if it is not\n', '     * already 0 to mitigate the race condition described here:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns(bool success){\n', '        require(allowed[msg.sender][_spender] == 0 || _value == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\n', '     *\n', '     * @param _from  Origin address\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '\n', '        emit Burn(msg.sender, _value);\n', '    }\n', '}\n', '\n', '/**\n', ' * CHERR.IO is a standard ERC20 token with some additional functionalities:\n', ' * - Transfers are only enabled after contract owner enables it (after the ICO)\n', ' * - Contract sets 60% of the total supply as allowance for ICO contract\n', ' */\n', 'contract Cherrio is StandardToken, BurnableToken, Ownable, Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    // Metadata\n', '    string  public constant name = "CHERR.IO";\n', '    string  public constant symbol = "CHR";\n', '    uint8   public constant decimals = 18;\n', '\n', '    // Token supplies\n', '    uint256 public constant INITIAL_SUPPLY =  200000000 * (10 ** uint256(decimals));\n', '    uint256 public constant ADMIN_ALLOWANCE =  80000000 * (10 ** uint256(decimals));\n', '    uint256 public constant CONTRACT_ALLOWANCE = INITIAL_SUPPLY - ADMIN_ALLOWANCE;\n', '\n', '    // Funding cap in ETH. Change to equal $12M at time of token offering\n', '    uint256 public constant FUNDING_ETH_HARD_CAP = 15000 ether;\n', '    // Minimum cap in ETH. Change to equal $3M at time of token offering\n', '    uint256 public constant MINIMUM_ETH_SOFT_CAP = 3750 ether;\n', '    // Min contribution is 0.1 ether\n', '    uint256 public constant MINIMUM_CONTRIBUTION = 100 finney;\n', '    // Price of the tokens as in tokens per ether\n', '    uint256 public constant RATE = 5333;\n', '    // Price of the tokens in tier 1\n', '    uint256 public constant RATE_TIER1 = 8743;\n', '    // Price of the tokens in tier 2\n', '    uint256 public constant RATE_TIER2 = 7306;\n', '    // Price of the tokens in tier 3\n', '    uint256 public constant RATE_TIER3 = 6584;\n', '    // Price of the tokens in public sale for limited timeline\n', '    uint256 public constant RATE_PUBLIC_SALE = 5926;\n', '    // Maximum cap for tier 1 (60M CHR tokens)\n', '    uint256 public constant TIER1_CAP = 60000000 * (10 ** uint256(decimals));\n', '    // Maximum cap for tier 2 (36M CHR tokens)\n', '    uint256 public constant TIER2_CAP = 36000000 * (10 ** uint256(decimals));\n', '\n', '    // Maximum cap for each contributor in tier 1\n', '    uint256 public participantCapTier1;\n', '    // Maximum cap for each contributor in tier 2\n', '    uint256 public participantCapTier2;\n', '\n', '    // ETH cap for pool addres only in tier 1\n', '    uint256 public poolAddressCapTier1;\n', '    // ETH cap for pool addres only in tier 2\n', '    uint256 public poolAddressCapTier2;\n', '\n', '    // The address of the token admin\n', '    address public adminAddress;\n', '    // The address where ETH funds are collected\n', '    address public beneficiaryAddress;\n', '    // The address of the contract\n', '    address public contractAddress;\n', '    // The address of the pool who can send unlimited ETH to the contract\n', '    address public poolAddress;\n', '\n', '    // Enable transfers after conclusion of the token offering\n', '    bool public transferIsEnabled;\n', '\n', '    // Amount of raised in Wei\n', '    uint256 public weiRaised;\n', '\n', '    // Amount of CHR tokens sent to participant for presale and public sale\n', '    uint256[4] public tokensSent;\n', '\n', '    // Start of public pre-sale in timestamp\n', '    uint256 startTimePresale;\n', '\n', '    // Start and end time of public sale in timestamp\n', '    uint256 startTime;\n', '    uint256 endTime;\n', '\n', '    // Discount period for public sale\n', '    uint256 publicSaleDiscountEndTime;\n', '\n', '    // End time limits in timestamp for each tier bonus\n', '    uint256[3] public tierEndTime;\n', '\n', '    //Check if contract address is already set\n', '    bool contractAddressIsSet;\n', '\n', '    struct Contributor {\n', '        bool canContribute;\n', '        uint8 tier;\n', '        uint256 contributionInWeiTier1;\n', '        uint256 contributionInWeiTier2;\n', '        uint256 contributionInWeiTier3;\n', '        uint256 contributionInWeiPublicSale;\n', '    }\n', '\n', '    struct Pool {\n', '        uint256 contributionInWei;\n', '    }\n', '\n', '    enum Stages {\n', '        Pending,\n', '        PreSale,\n', '        PublicSale,\n', '        Ended\n', '    }\n', '\n', '    // The current stage of the offering\n', '    Stages public stage;\n', '\n', '    mapping(address => Contributor) public contributors;\n', '    mapping(address => mapping(uint8 => Pool)) public pool;\n', '\n', '    // Check if transfer is enabled\n', '    modifier TransferIsEnabled {\n', '        require(transferIsEnabled || msg.sender == adminAddress || msg.sender == contractAddress);\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if address is a valid destination to transfer tokens to\n', '     * - must not be zero address\n', '     * - must not be the token address\n', '     * - must not be the owner&#39;s address\n', '     * - must not be the admin&#39;s address\n', '     * - must not be the token offering contract address\n', '     * - must not be the beneficiary address\n', '     */\n', '    modifier ValidDestination(address _to) {\n', '        require(_to != address(0x0));\n', '        require(_to != address(this));\n', '        require(_to != owner);\n', '        require(_to != address(adminAddress));\n', '        require(_to != address(contractAddress));\n', '        require(_to != address(beneficiaryAddress));\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Modifier that requires certain stage before executing the main function body\n', '     *\n', '     * @param _expectedStage Value that the current stage is required to match\n', '     */\n', '    modifier AtStage(Stages _expectedStage) {\n', '        require(stage == _expectedStage);\n', '\n', '        _;\n', '    }\n', '\n', '    // Check if ICO is live\n', '    modifier CheckIfICOIsLive() {\n', '        require(stage != Stages.Pending && stage != Stages.Ended);\n', '\n', '        if(stage == Stages.PreSale) {\n', '            require(\n', '                startTimePresale > 0 &&\n', '                now >= startTimePresale &&\n', '                now <= tierEndTime[2]\n', '            );\n', '        }\n', '        else {\n', '            require(\n', '                startTime > 0 &&\n', '                now >= startTime &&\n', '                now <= endTime\n', '            );\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    // Check if participant sent more then miniminum required contribution\n', '    modifier CheckPurchase() {\n', '        require(msg.value >= MINIMUM_CONTRIBUTION);\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     *\n', '     * @param _purchaser Participant who paid for CHR tokens\n', '     * @param _value     Amount in WEI paid for token\n', '     * @param _tokens    Amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed _purchaser, uint256 _value, uint256 _tokens);\n', '\n', '    /**\n', '     * Event when token offering started\n', '     *\n', '     * @param _msg       Message\n', '     * @param _startTime Start time in timestamp\n', '     * @param _endTime   End time in timestamp\n', '     */\n', '    event OfferingOpens(string _msg, uint256 _startTime, uint256 _endTime);\n', '\n', '    /**\n', '     * Event when token offering ended and how much has been raised in wei\n', '     *\n', '     * @param _endTime        End time in timestamp\n', '     * @param _totalWeiRaised Total raised funds in wei\n', '     */\n', '    event OfferingCloses(uint256 _endTime, uint256 _totalWeiRaised);\n', '\n', '    /**\n', '     * Cherrio constructor\n', '     */\n', '    function Cherrio() public {\n', '        totalSupply = INITIAL_SUPPLY;\n', '\n', '        // Mint tokens\n', '        balances[msg.sender] = totalSupply;\n', '        emit Transfer(address(0x0), msg.sender, totalSupply);\n', '\n', '        // Aprove an allowance for admin account\n', '        adminAddress = 0xe0509bB3921aacc433108D403f020a7c2f92e936;\n', '        approve(adminAddress, ADMIN_ALLOWANCE);\n', '\n', '        participantCapTier1 = 100 ether;\n', '        participantCapTier2 = 100 ether;\n', '        poolAddressCapTier1 = 2000 ether; \n', '        poolAddressCapTier2 = 2000 ether;\n', '\n', '        weiRaised = 0;\n', '        startTimePresale = 0;\n', '        startTime = 0;\n', '        endTime = 0;\n', '        publicSaleDiscountEndTime = 0;\n', '        transferIsEnabled = false;\n', '        contractAddressIsSet = false;\n', '    }\n', '\n', '    /**\n', '     * Add approved addresses\n', '     *\n', '     * @param _addresses Array of approved addresses\n', '     * @param _tier      Tier\n', '     */\n', '    function addApprovedAddresses(address[] _addresses, uint8 _tier) external OnlyOwner {\n', '        uint256 length = _addresses.length;\n', '\n', '        for(uint256 i = 0; i < length; i++) {\n', '            if(!contributors[_addresses[i]].canContribute) {\n', '                contributors[_addresses[i]].canContribute = true;\n', '                contributors[_addresses[i]].tier = _tier;\n', '                contributors[_addresses[i]].contributionInWeiTier1 = 0;\n', '                contributors[_addresses[i]].contributionInWeiTier2 = 0;\n', '                contributors[_addresses[i]].contributionInWeiTier3 = 0;\n', '                contributors[_addresses[i]].contributionInWeiPublicSale = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Add approved address\n', '     *\n', '     * @param _address Approved address\n', '     * @param _tier    Tier\n', '     */\n', '    function addSingleApprovedAddress(address _address, uint8 _tier) external OnlyOwner {\n', '        if(!contributors[_address].canContribute) {\n', '            contributors[_address].canContribute = true;\n', '            contributors[_address].tier = _tier;\n', '            contributors[_address].contributionInWeiTier1 = 0;\n', '            contributors[_address].contributionInWeiTier2 = 0;\n', '            contributors[_address].contributionInWeiTier3 = 0;\n', '            contributors[_address].contributionInWeiPublicSale = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Set token offering address to approve allowance for offering contract to distribute tokens\n', '     */\n', '    function setTokenOffering() external OnlyOwner{\n', '        require(!contractAddressIsSet);\n', '        require(!transferIsEnabled);\n', '\n', '        contractAddress = address(this);\n', '        approve(contractAddress, CONTRACT_ALLOWANCE);\n', '\n', '        beneficiaryAddress = 0xAec8c4242c8c2E532c6D6478A7de380263234845;\n', '        poolAddress = 0x1A2C916B640520E1e93A78fEa04A49D8345a5aa9;\n', '\n', '        pool[poolAddress][0].contributionInWei = 0;\n', '        pool[poolAddress][1].contributionInWei = 0;\n', '        pool[poolAddress][2].contributionInWei = 0;\n', '        pool[poolAddress][3].contributionInWei = 0;\n', '\n', '        tokensSent[0] = 0;\n', '        tokensSent[1] = 0;\n', '        tokensSent[2] = 0;\n', '        tokensSent[3] = 0;\n', '\n', '        stage = Stages.Pending;\n', '        contractAddressIsSet = true;\n', '    }\n', '\n', '    /**\n', '     * Set when presale starts\n', '     *\n', '     * @param _startTimePresale Start time of presale in timestamp\n', '     */\n', '    function startPresale(uint256 _startTimePresale) external OnlyOwner AtStage(Stages.Pending) {\n', '        if(_startTimePresale == 0) {\n', '            startTimePresale = now;\n', '        }\n', '        else {\n', '            startTimePresale = _startTimePresale;\n', '        }\n', '\n', '        setTierEndTime();\n', '\n', '        stage = Stages.PreSale;\n', '    }\n', '\n', '    /**\n', '     * Set when public sale starts\n', '     *\n', '     * @param _startTime Start time of public sale in timestamp\n', '     */\n', '    function startPublicSale(uint256 _startTime) external OnlyOwner AtStage(Stages.PreSale) {\n', '        if(_startTime == 0) {\n', '            startTime = now;\n', '        }\n', '        else {\n', '            startTime = _startTime;\n', '        }\n', '\n', '        endTime = startTime + 15 days;\n', '        publicSaleDiscountEndTime = startTime + 3 days;\n', '\n', '        stage = Stages.PublicSale;\n', '    }\n', '\n', '    // Fallback function can be used to buy CHR tokens\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    function buy() public payable IsNotPaused CheckIfICOIsLive returns(bool _success) {\n', '        uint8 currentTier = getCurrentTier();\n', '\n', '        if(currentTier > 3) {\n', '            revert();\n', '        }\n', '\n', '        if(!buyTokens(currentTier)) {\n', '            revert();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @param _tier Current Token Sale tier\n', '     */\n', '    function buyTokens(uint8 _tier) internal ValidDestination(msg.sender) CheckPurchase returns(bool _success) {\n', '        if(weiRaised.add(msg.value) > FUNDING_ETH_HARD_CAP) {\n', '            revert();\n', '        }\n', '\n', '        uint256 contributionInWei = msg.value;\n', '\n', '        if(!checkTierCap(_tier, contributionInWei)) {\n', '            revert();\n', '        }\n', '\n', '        uint256 rate = getTierTokens(_tier);\n', '        uint256 tokens = contributionInWei.mul(rate);\n', '\n', '        if(msg.sender != poolAddress) {\n', '            if(stage == Stages.PreSale) {\n', '                if(!checkAllowedTier(msg.sender, _tier)) {\n', '                    revert();\n', '                }\n', '            }\n', '\n', '            if(!checkAllowedContribution(msg.sender, contributionInWei, _tier)) {\n', '                revert();\n', '            }\n', '\n', '            if(!this.transferFrom(owner, msg.sender, tokens)) {\n', '                revert();\n', '            }\n', '\n', '            if(stage == Stages.PreSale) {\n', '                if(_tier == 0) {\n', '                    contributors[msg.sender].contributionInWeiTier1 = contributors[msg.sender].contributionInWeiTier1.add(contributionInWei);\n', '                }\n', '                else if(_tier == 1) {\n', '                    contributors[msg.sender].contributionInWeiTier2 = contributors[msg.sender].contributionInWeiTier2.add(contributionInWei);\n', '                }\n', '                else if(_tier == 2) {\n', '                    contributors[msg.sender].contributionInWeiTier3 = contributors[msg.sender].contributionInWeiTier3.add(contributionInWei);\n', '                }\n', '            }\n', '            else {\n', '                contributors[msg.sender].contributionInWeiPublicSale = contributors[msg.sender].contributionInWeiPublicSale.add(contributionInWei);\n', '            }\n', '        }\n', '        else {\n', '            if(!checkPoolAddressTierCap(_tier, contributionInWei)) {\n', '                revert();\n', '            }\n', '\n', '            if(!this.transferFrom(owner, msg.sender, tokens)) {\n', '                revert();\n', '            }\n', '\n', '            pool[poolAddress][_tier].contributionInWei = pool[poolAddress][_tier].contributionInWei.add(contributionInWei);\n', '        }\n', '\n', '        weiRaised = weiRaised.add(contributionInWei);\n', '        tokensSent[_tier] = tokensSent[_tier].add(tokens);\n', '\n', '        if(weiRaised >= FUNDING_ETH_HARD_CAP) {\n', '            offeringEnded();\n', '        }\n', '\n', '        beneficiaryAddress.transfer(address(this).balance);\n', '        emit TokenPurchase(msg.sender, contributionInWei, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Manually withdraw tokens to private investors\n', '     *\n', '     * @param _to    Address of private investor\n', '     * @param _value The number of tokens to send to private investor\n', '     */\n', '    function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) {\n', '        if(!this.transferFrom(owner, _to, _value)) {\n', '            revert();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer from sender to another account\n', '     *\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\n', '         return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\n', '     *\n', '     * @param _from  Origin address\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Check if participant is allowed to contribute in current tier\n', '     *\n', '     * @param _address Participant address\n', '     * @param _tier    Current tier\n', '     */\n', '    function checkAllowedTier(address _address, uint8 _tier) internal view returns (bool _allowed) {\n', '        if(contributors[_address].tier <= _tier) {\n', '            return true;\n', '        }\n', '        else{\n', '          return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Check contribution cap for only tier 1 and 2\n', '     *\n', '     * @param _tier  Current tier\n', '     * @param _value Participant contribution\n', '     */\n', '    function checkTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\n', '        uint256 currentlyTokensSent = tokensSent[_tier];\n', '        bool status = true;\n', '\n', '        if(_tier == 0) {\n', '            if(TIER1_CAP < currentlyTokensSent.add(_value)) {\n', '                status = false;\n', '            }\n', '        }\n', '        else if(_tier == 1) {\n', '            if(TIER2_CAP < currentlyTokensSent.add(_value)) {\n', '                status = false;\n', '            }\n', '        }\n', '\n', '        return status;\n', '    }\n', '    \n', '    /**\n', '     * Check cap for pool address in tier 1 and 2\n', '     *\n', '     * @param _tier  Current tier\n', '     * @param _value Pool contribution\n', '     */\n', '    function checkPoolAddressTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\n', '        uint256 currentContribution = pool[poolAddress][_tier].contributionInWei;\n', '\n', '        if((_tier == 0 && (poolAddressCapTier1 < currentContribution.add(_value))) || (_tier == 1 && (poolAddressCapTier2 < currentContribution.add(_value)))) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Check cap for pool address in tier 1 and 2\n', '     *\n', '     * @param _address  Participant address\n', '     * @param _value    Participant contribution\n', '     * @param _tier     Current tier\n', '     */\n', '    function checkAllowedContribution(address _address, uint256 _value, uint8 _tier) internal view returns (bool _success) {\n', '        bool status = false;\n', '\n', '        if(contributors[_address].canContribute) {\n', '            if(_tier == 0) {\n', '                if(participantCapTier1 >= contributors[_address].contributionInWeiTier1.add(_value)) {\n', '                    status = true;\n', '                }\n', '            }\n', '            else if(_tier == 1) {\n', '                if(participantCapTier2 >= contributors[_address].contributionInWeiTier2.add(_value)) {\n', '                    status = true;\n', '                }\n', '            }\n', '            else if(_tier == 2) {\n', '                status = true;\n', '            }\n', '            else {\n', '                status = true;\n', '            }\n', '        }\n', '\n', '        return status;\n', '    }\n', '    \n', '    /**\n', '     * Get current tier tokens rate\n', '     *\n', '     * @param _tier     Current tier\n', '     */\n', '    function getTierTokens(uint8 _tier) internal view returns(uint256 _tokens) {\n', '        uint256 tokens = RATE_TIER1;\n', '\n', '        if(_tier == 1) {\n', '            tokens = RATE_TIER2;\n', '        }\n', '        else if(_tier == 2) {\n', '            tokens = RATE_TIER3;\n', '        }\n', '        else if(_tier == 3) {\n', '            if(now <= publicSaleDiscountEndTime) {\n', '                tokens = RATE_PUBLIC_SALE;\n', '            }\n', '            else {\n', '                tokens = RATE;\n', '            }\n', '        }\n', '\n', '        return tokens;\n', '    }\n', '\n', '    // Get current tier\n', '    function getCurrentTier() public view returns(uint8 _tier) {\n', '        uint8 currentTier = 3; // 3 is public sale\n', '\n', '        if(stage == Stages.PreSale) {\n', '            if(now <= tierEndTime[0]) {\n', '                currentTier = 0;\n', '            }\n', '            else if(now <= tierEndTime[1]) {\n', '                currentTier = 1;\n', '            }\n', '            else if(now <= tierEndTime[2]) {\n', '                currentTier = 2;\n', '            }\n', '        }\n', '        else {\n', '            if(now > endTime) {\n', '                currentTier = 4; // Token offering ended\n', '            }\n', '        }\n', '\n', '        return currentTier;\n', '    }\n', '\n', '    // Set end time for each tier\n', '    function setTierEndTime() internal AtStage(Stages.Pending) {\n', '        tierEndTime[0] = startTimePresale + 1 days; \n', '        tierEndTime[1] = tierEndTime[0] + 2 days;   \n', '        tierEndTime[2] = tierEndTime[1] + 6 days;   \n', '    }\n', '\n', '    // End the token offering\n', '    function endOffering() public OnlyOwner {\n', '        offeringEnded();\n', '    }\n', '\n', '    // Token offering is ended\n', '    function offeringEnded() internal {\n', '        endTime = now;\n', '        stage = Stages.Ended;\n', '\n', '        emit OfferingCloses(endTime, weiRaised);\n', '    }\n', '\n', '    // Enable transfers, burn unsold tokens & set tokenOfferingAddress to 0\n', '    function enableTransfer() public OnlyOwner returns(bool _success){\n', '        transferIsEnabled = true;\n', '        uint256 tokensToBurn = allowed[msg.sender][contractAddress];\n', '\n', '        if(tokensToBurn != 0){\n', '            burn(tokensToBurn);\n', '            approve(contractAddress, 0);\n', '        }\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Extend end time\n', '     *\n', '     * @param _addedTime Addtional time in secods\n', '     */\n', '    function extendEndTime(uint256 _addedTime) external OnlyOwner {\n', '        endTime = endTime + _addedTime;\n', '    }\n', '    \n', '    /**\n', '     * Extend public sale discount time\n', '     *\n', '     * @param _addedPublicSaleDiscountEndTime Addtional time in secods\n', '     */\n', '    function extendPublicSaleDiscountEndTime(uint256 _addedPublicSaleDiscountEndTime) external OnlyOwner {\n', '        publicSaleDiscountEndTime = publicSaleDiscountEndTime + _addedPublicSaleDiscountEndTime;\n', '    }\n', '    \n', '    /**\n', '     * Update pool cap for tier 1\n', '     *\n', '     * @param _poolAddressCapTier1 Tier cap\n', '     */\n', '    function updatePoolAddressCapTier1(uint256 _poolAddressCapTier1) external OnlyOwner {\n', '        poolAddressCapTier1 = _poolAddressCapTier1;\n', '    }\n', '    \n', '    /**\n', '     * Update pool cap for tier 2\n', '     *\n', '     * @param _poolAddressCapTier2 Tier cap\n', '     */\n', '    function updatePoolAddressCapTier2(uint256 _poolAddressCapTier2) external OnlyOwner {\n', '        poolAddressCapTier2 = _poolAddressCapTier2;\n', '    }\n', '\n', '    //\n', '    \n', '    /**\n', '     * Update participant cap for tier 1\n', '     *\n', '     * @param _participantCapTier1 Tier cap\n', '     */\n', '    function updateParticipantCapTier1(uint256 _participantCapTier1) external OnlyOwner {\n', '        participantCapTier1 = _participantCapTier1;\n', '    }\n', '    \n', '    /**\n', '     * Update participant cap for tier 2\n', '     *\n', '     * @param _participantCapTier2 Tier cap\n', '     */\n', '    function updateParticipantCapTier2(uint256 _participantCapTier2) external OnlyOwner {\n', '        participantCapTier2 = _participantCapTier2;\n', '    }\n', '}']
['pragma solidity ^0.4.22;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address and\n', ' *      provides basic authorization control functions\n', ' */\n', 'contract Ownable {\n', '    // Public properties\n', '    address public owner;\n', '\n', '    // Log if ownership has been changed\n', '    event ChangeOwnership(address indexed _owner, address indexed _newOwner);\n', '\n', '    // Checks if address is an owner\n', '    modifier OnlyOwner() {\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '    }\n', '\n', '    // The Ownable constructor sets the owner address\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Transfer current ownership to the new account\n', '    function transferOwnership(address _newOwner) public OnlyOwner {\n', '        require(_newOwner != address(0x0));\n', '\n', '        owner = _newOwner;\n', '\n', '        emit ChangeOwnership(owner, _newOwner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    /*\n', '    * @dev Event to notify listeners about pause.\n', '    * @param pauseReason  string Reason the token was paused for.\n', '    */\n', '    event Pause(string pauseReason);\n', '    /*\n', '    * @dev Event to notify listeners about pause.\n', '    * @param unpauseReason  string Reason the token was unpaused for.\n', '    */\n', '    event Unpause(string unpauseReason);\n', '\n', '    bool public isPaused;\n', '    string public pauseNotice;\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier IsNotPaused() {\n', '        require(!isPaused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier IsPaused() {\n', '        require(isPaused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    * @param _reason string The reason for the pause.\n', '    */\n', '    function pause(string _reason) OnlyOwner IsNotPaused public {\n', '        isPaused = true;\n', '        pauseNotice = _reason;\n', '        emit Pause(_reason);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     * @param _reason string Reason for the un pause.\n', '     */\n', '    function unpause(string _reason) OnlyOwner IsPaused public {\n', '        isPaused = false;\n', '        pauseNotice = _reason;\n', '        emit Unpause(_reason);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint256 theBalance);\n', '    function transfer(address to, uint256 value) public returns(bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns(uint256 theAllowance);\n', '    function transferFrom(address from, address to, uint256 value) public returns(bool success);\n', '    function approve(address spender, uint256 value) public returns(bool success);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken without allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '    * @dev Get the token balance for account\n', '    * @param _address The address to query the balance of._address\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _address) public constant returns(uint256 theBalance){\n', '        return balances[_address];\n', '    }\n', '\n', '    /**\n', "    * @dev Transfer the balance from owner's account to another account\n", '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    * @return Returns true if transfer has been successful\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns(bool success){\n', '        require(_to != address(0x0) && _value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    /**\n', "     * @dev Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n", '     * @param _owner The address which owns the funds.\n', '     * @param _spender The address which will spend the funds.\n', '     * @return An uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 theAllowance){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * To change the approve amount you first have to reduce the addresses`\n', '     * allowance to zero by calling `approve(_spender, 0)` if it is not\n', '     * already 0 to mitigate the race condition described here:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns(bool success){\n', '        require(allowed[msg.sender][_spender] == 0 || _value == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\n', '     *\n', '     * @param _from  Origin address\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '\n', '        emit Burn(msg.sender, _value);\n', '    }\n', '}\n', '\n', '/**\n', ' * CHERR.IO is a standard ERC20 token with some additional functionalities:\n', ' * - Transfers are only enabled after contract owner enables it (after the ICO)\n', ' * - Contract sets 60% of the total supply as allowance for ICO contract\n', ' */\n', 'contract Cherrio is StandardToken, BurnableToken, Ownable, Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    // Metadata\n', '    string  public constant name = "CHERR.IO";\n', '    string  public constant symbol = "CHR";\n', '    uint8   public constant decimals = 18;\n', '\n', '    // Token supplies\n', '    uint256 public constant INITIAL_SUPPLY =  200000000 * (10 ** uint256(decimals));\n', '    uint256 public constant ADMIN_ALLOWANCE =  80000000 * (10 ** uint256(decimals));\n', '    uint256 public constant CONTRACT_ALLOWANCE = INITIAL_SUPPLY - ADMIN_ALLOWANCE;\n', '\n', '    // Funding cap in ETH. Change to equal $12M at time of token offering\n', '    uint256 public constant FUNDING_ETH_HARD_CAP = 15000 ether;\n', '    // Minimum cap in ETH. Change to equal $3M at time of token offering\n', '    uint256 public constant MINIMUM_ETH_SOFT_CAP = 3750 ether;\n', '    // Min contribution is 0.1 ether\n', '    uint256 public constant MINIMUM_CONTRIBUTION = 100 finney;\n', '    // Price of the tokens as in tokens per ether\n', '    uint256 public constant RATE = 5333;\n', '    // Price of the tokens in tier 1\n', '    uint256 public constant RATE_TIER1 = 8743;\n', '    // Price of the tokens in tier 2\n', '    uint256 public constant RATE_TIER2 = 7306;\n', '    // Price of the tokens in tier 3\n', '    uint256 public constant RATE_TIER3 = 6584;\n', '    // Price of the tokens in public sale for limited timeline\n', '    uint256 public constant RATE_PUBLIC_SALE = 5926;\n', '    // Maximum cap for tier 1 (60M CHR tokens)\n', '    uint256 public constant TIER1_CAP = 60000000 * (10 ** uint256(decimals));\n', '    // Maximum cap for tier 2 (36M CHR tokens)\n', '    uint256 public constant TIER2_CAP = 36000000 * (10 ** uint256(decimals));\n', '\n', '    // Maximum cap for each contributor in tier 1\n', '    uint256 public participantCapTier1;\n', '    // Maximum cap for each contributor in tier 2\n', '    uint256 public participantCapTier2;\n', '\n', '    // ETH cap for pool addres only in tier 1\n', '    uint256 public poolAddressCapTier1;\n', '    // ETH cap for pool addres only in tier 2\n', '    uint256 public poolAddressCapTier2;\n', '\n', '    // The address of the token admin\n', '    address public adminAddress;\n', '    // The address where ETH funds are collected\n', '    address public beneficiaryAddress;\n', '    // The address of the contract\n', '    address public contractAddress;\n', '    // The address of the pool who can send unlimited ETH to the contract\n', '    address public poolAddress;\n', '\n', '    // Enable transfers after conclusion of the token offering\n', '    bool public transferIsEnabled;\n', '\n', '    // Amount of raised in Wei\n', '    uint256 public weiRaised;\n', '\n', '    // Amount of CHR tokens sent to participant for presale and public sale\n', '    uint256[4] public tokensSent;\n', '\n', '    // Start of public pre-sale in timestamp\n', '    uint256 startTimePresale;\n', '\n', '    // Start and end time of public sale in timestamp\n', '    uint256 startTime;\n', '    uint256 endTime;\n', '\n', '    // Discount period for public sale\n', '    uint256 publicSaleDiscountEndTime;\n', '\n', '    // End time limits in timestamp for each tier bonus\n', '    uint256[3] public tierEndTime;\n', '\n', '    //Check if contract address is already set\n', '    bool contractAddressIsSet;\n', '\n', '    struct Contributor {\n', '        bool canContribute;\n', '        uint8 tier;\n', '        uint256 contributionInWeiTier1;\n', '        uint256 contributionInWeiTier2;\n', '        uint256 contributionInWeiTier3;\n', '        uint256 contributionInWeiPublicSale;\n', '    }\n', '\n', '    struct Pool {\n', '        uint256 contributionInWei;\n', '    }\n', '\n', '    enum Stages {\n', '        Pending,\n', '        PreSale,\n', '        PublicSale,\n', '        Ended\n', '    }\n', '\n', '    // The current stage of the offering\n', '    Stages public stage;\n', '\n', '    mapping(address => Contributor) public contributors;\n', '    mapping(address => mapping(uint8 => Pool)) public pool;\n', '\n', '    // Check if transfer is enabled\n', '    modifier TransferIsEnabled {\n', '        require(transferIsEnabled || msg.sender == adminAddress || msg.sender == contractAddress);\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if address is a valid destination to transfer tokens to\n', '     * - must not be zero address\n', '     * - must not be the token address\n', "     * - must not be the owner's address\n", "     * - must not be the admin's address\n", '     * - must not be the token offering contract address\n', '     * - must not be the beneficiary address\n', '     */\n', '    modifier ValidDestination(address _to) {\n', '        require(_to != address(0x0));\n', '        require(_to != address(this));\n', '        require(_to != owner);\n', '        require(_to != address(adminAddress));\n', '        require(_to != address(contractAddress));\n', '        require(_to != address(beneficiaryAddress));\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Modifier that requires certain stage before executing the main function body\n', '     *\n', '     * @param _expectedStage Value that the current stage is required to match\n', '     */\n', '    modifier AtStage(Stages _expectedStage) {\n', '        require(stage == _expectedStage);\n', '\n', '        _;\n', '    }\n', '\n', '    // Check if ICO is live\n', '    modifier CheckIfICOIsLive() {\n', '        require(stage != Stages.Pending && stage != Stages.Ended);\n', '\n', '        if(stage == Stages.PreSale) {\n', '            require(\n', '                startTimePresale > 0 &&\n', '                now >= startTimePresale &&\n', '                now <= tierEndTime[2]\n', '            );\n', '        }\n', '        else {\n', '            require(\n', '                startTime > 0 &&\n', '                now >= startTime &&\n', '                now <= endTime\n', '            );\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    // Check if participant sent more then miniminum required contribution\n', '    modifier CheckPurchase() {\n', '        require(msg.value >= MINIMUM_CONTRIBUTION);\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     *\n', '     * @param _purchaser Participant who paid for CHR tokens\n', '     * @param _value     Amount in WEI paid for token\n', '     * @param _tokens    Amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed _purchaser, uint256 _value, uint256 _tokens);\n', '\n', '    /**\n', '     * Event when token offering started\n', '     *\n', '     * @param _msg       Message\n', '     * @param _startTime Start time in timestamp\n', '     * @param _endTime   End time in timestamp\n', '     */\n', '    event OfferingOpens(string _msg, uint256 _startTime, uint256 _endTime);\n', '\n', '    /**\n', '     * Event when token offering ended and how much has been raised in wei\n', '     *\n', '     * @param _endTime        End time in timestamp\n', '     * @param _totalWeiRaised Total raised funds in wei\n', '     */\n', '    event OfferingCloses(uint256 _endTime, uint256 _totalWeiRaised);\n', '\n', '    /**\n', '     * Cherrio constructor\n', '     */\n', '    function Cherrio() public {\n', '        totalSupply = INITIAL_SUPPLY;\n', '\n', '        // Mint tokens\n', '        balances[msg.sender] = totalSupply;\n', '        emit Transfer(address(0x0), msg.sender, totalSupply);\n', '\n', '        // Aprove an allowance for admin account\n', '        adminAddress = 0xe0509bB3921aacc433108D403f020a7c2f92e936;\n', '        approve(adminAddress, ADMIN_ALLOWANCE);\n', '\n', '        participantCapTier1 = 100 ether;\n', '        participantCapTier2 = 100 ether;\n', '        poolAddressCapTier1 = 2000 ether; \n', '        poolAddressCapTier2 = 2000 ether;\n', '\n', '        weiRaised = 0;\n', '        startTimePresale = 0;\n', '        startTime = 0;\n', '        endTime = 0;\n', '        publicSaleDiscountEndTime = 0;\n', '        transferIsEnabled = false;\n', '        contractAddressIsSet = false;\n', '    }\n', '\n', '    /**\n', '     * Add approved addresses\n', '     *\n', '     * @param _addresses Array of approved addresses\n', '     * @param _tier      Tier\n', '     */\n', '    function addApprovedAddresses(address[] _addresses, uint8 _tier) external OnlyOwner {\n', '        uint256 length = _addresses.length;\n', '\n', '        for(uint256 i = 0; i < length; i++) {\n', '            if(!contributors[_addresses[i]].canContribute) {\n', '                contributors[_addresses[i]].canContribute = true;\n', '                contributors[_addresses[i]].tier = _tier;\n', '                contributors[_addresses[i]].contributionInWeiTier1 = 0;\n', '                contributors[_addresses[i]].contributionInWeiTier2 = 0;\n', '                contributors[_addresses[i]].contributionInWeiTier3 = 0;\n', '                contributors[_addresses[i]].contributionInWeiPublicSale = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Add approved address\n', '     *\n', '     * @param _address Approved address\n', '     * @param _tier    Tier\n', '     */\n', '    function addSingleApprovedAddress(address _address, uint8 _tier) external OnlyOwner {\n', '        if(!contributors[_address].canContribute) {\n', '            contributors[_address].canContribute = true;\n', '            contributors[_address].tier = _tier;\n', '            contributors[_address].contributionInWeiTier1 = 0;\n', '            contributors[_address].contributionInWeiTier2 = 0;\n', '            contributors[_address].contributionInWeiTier3 = 0;\n', '            contributors[_address].contributionInWeiPublicSale = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Set token offering address to approve allowance for offering contract to distribute tokens\n', '     */\n', '    function setTokenOffering() external OnlyOwner{\n', '        require(!contractAddressIsSet);\n', '        require(!transferIsEnabled);\n', '\n', '        contractAddress = address(this);\n', '        approve(contractAddress, CONTRACT_ALLOWANCE);\n', '\n', '        beneficiaryAddress = 0xAec8c4242c8c2E532c6D6478A7de380263234845;\n', '        poolAddress = 0x1A2C916B640520E1e93A78fEa04A49D8345a5aa9;\n', '\n', '        pool[poolAddress][0].contributionInWei = 0;\n', '        pool[poolAddress][1].contributionInWei = 0;\n', '        pool[poolAddress][2].contributionInWei = 0;\n', '        pool[poolAddress][3].contributionInWei = 0;\n', '\n', '        tokensSent[0] = 0;\n', '        tokensSent[1] = 0;\n', '        tokensSent[2] = 0;\n', '        tokensSent[3] = 0;\n', '\n', '        stage = Stages.Pending;\n', '        contractAddressIsSet = true;\n', '    }\n', '\n', '    /**\n', '     * Set when presale starts\n', '     *\n', '     * @param _startTimePresale Start time of presale in timestamp\n', '     */\n', '    function startPresale(uint256 _startTimePresale) external OnlyOwner AtStage(Stages.Pending) {\n', '        if(_startTimePresale == 0) {\n', '            startTimePresale = now;\n', '        }\n', '        else {\n', '            startTimePresale = _startTimePresale;\n', '        }\n', '\n', '        setTierEndTime();\n', '\n', '        stage = Stages.PreSale;\n', '    }\n', '\n', '    /**\n', '     * Set when public sale starts\n', '     *\n', '     * @param _startTime Start time of public sale in timestamp\n', '     */\n', '    function startPublicSale(uint256 _startTime) external OnlyOwner AtStage(Stages.PreSale) {\n', '        if(_startTime == 0) {\n', '            startTime = now;\n', '        }\n', '        else {\n', '            startTime = _startTime;\n', '        }\n', '\n', '        endTime = startTime + 15 days;\n', '        publicSaleDiscountEndTime = startTime + 3 days;\n', '\n', '        stage = Stages.PublicSale;\n', '    }\n', '\n', '    // Fallback function can be used to buy CHR tokens\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    function buy() public payable IsNotPaused CheckIfICOIsLive returns(bool _success) {\n', '        uint8 currentTier = getCurrentTier();\n', '\n', '        if(currentTier > 3) {\n', '            revert();\n', '        }\n', '\n', '        if(!buyTokens(currentTier)) {\n', '            revert();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @param _tier Current Token Sale tier\n', '     */\n', '    function buyTokens(uint8 _tier) internal ValidDestination(msg.sender) CheckPurchase returns(bool _success) {\n', '        if(weiRaised.add(msg.value) > FUNDING_ETH_HARD_CAP) {\n', '            revert();\n', '        }\n', '\n', '        uint256 contributionInWei = msg.value;\n', '\n', '        if(!checkTierCap(_tier, contributionInWei)) {\n', '            revert();\n', '        }\n', '\n', '        uint256 rate = getTierTokens(_tier);\n', '        uint256 tokens = contributionInWei.mul(rate);\n', '\n', '        if(msg.sender != poolAddress) {\n', '            if(stage == Stages.PreSale) {\n', '                if(!checkAllowedTier(msg.sender, _tier)) {\n', '                    revert();\n', '                }\n', '            }\n', '\n', '            if(!checkAllowedContribution(msg.sender, contributionInWei, _tier)) {\n', '                revert();\n', '            }\n', '\n', '            if(!this.transferFrom(owner, msg.sender, tokens)) {\n', '                revert();\n', '            }\n', '\n', '            if(stage == Stages.PreSale) {\n', '                if(_tier == 0) {\n', '                    contributors[msg.sender].contributionInWeiTier1 = contributors[msg.sender].contributionInWeiTier1.add(contributionInWei);\n', '                }\n', '                else if(_tier == 1) {\n', '                    contributors[msg.sender].contributionInWeiTier2 = contributors[msg.sender].contributionInWeiTier2.add(contributionInWei);\n', '                }\n', '                else if(_tier == 2) {\n', '                    contributors[msg.sender].contributionInWeiTier3 = contributors[msg.sender].contributionInWeiTier3.add(contributionInWei);\n', '                }\n', '            }\n', '            else {\n', '                contributors[msg.sender].contributionInWeiPublicSale = contributors[msg.sender].contributionInWeiPublicSale.add(contributionInWei);\n', '            }\n', '        }\n', '        else {\n', '            if(!checkPoolAddressTierCap(_tier, contributionInWei)) {\n', '                revert();\n', '            }\n', '\n', '            if(!this.transferFrom(owner, msg.sender, tokens)) {\n', '                revert();\n', '            }\n', '\n', '            pool[poolAddress][_tier].contributionInWei = pool[poolAddress][_tier].contributionInWei.add(contributionInWei);\n', '        }\n', '\n', '        weiRaised = weiRaised.add(contributionInWei);\n', '        tokensSent[_tier] = tokensSent[_tier].add(tokens);\n', '\n', '        if(weiRaised >= FUNDING_ETH_HARD_CAP) {\n', '            offeringEnded();\n', '        }\n', '\n', '        beneficiaryAddress.transfer(address(this).balance);\n', '        emit TokenPurchase(msg.sender, contributionInWei, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Manually withdraw tokens to private investors\n', '     *\n', '     * @param _to    Address of private investor\n', '     * @param _value The number of tokens to send to private investor\n', '     */\n', '    function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) {\n', '        if(!this.transferFrom(owner, _to, _value)) {\n', '            revert();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer from sender to another account\n', '     *\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\n', '         return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\n', '     *\n', '     * @param _from  Origin address\n', '     * @param _to    Destination address\n', '     * @param _value Amount of CHR tokens to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Check if participant is allowed to contribute in current tier\n', '     *\n', '     * @param _address Participant address\n', '     * @param _tier    Current tier\n', '     */\n', '    function checkAllowedTier(address _address, uint8 _tier) internal view returns (bool _allowed) {\n', '        if(contributors[_address].tier <= _tier) {\n', '            return true;\n', '        }\n', '        else{\n', '          return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Check contribution cap for only tier 1 and 2\n', '     *\n', '     * @param _tier  Current tier\n', '     * @param _value Participant contribution\n', '     */\n', '    function checkTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\n', '        uint256 currentlyTokensSent = tokensSent[_tier];\n', '        bool status = true;\n', '\n', '        if(_tier == 0) {\n', '            if(TIER1_CAP < currentlyTokensSent.add(_value)) {\n', '                status = false;\n', '            }\n', '        }\n', '        else if(_tier == 1) {\n', '            if(TIER2_CAP < currentlyTokensSent.add(_value)) {\n', '                status = false;\n', '            }\n', '        }\n', '\n', '        return status;\n', '    }\n', '    \n', '    /**\n', '     * Check cap for pool address in tier 1 and 2\n', '     *\n', '     * @param _tier  Current tier\n', '     * @param _value Pool contribution\n', '     */\n', '    function checkPoolAddressTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\n', '        uint256 currentContribution = pool[poolAddress][_tier].contributionInWei;\n', '\n', '        if((_tier == 0 && (poolAddressCapTier1 < currentContribution.add(_value))) || (_tier == 1 && (poolAddressCapTier2 < currentContribution.add(_value)))) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Check cap for pool address in tier 1 and 2\n', '     *\n', '     * @param _address  Participant address\n', '     * @param _value    Participant contribution\n', '     * @param _tier     Current tier\n', '     */\n', '    function checkAllowedContribution(address _address, uint256 _value, uint8 _tier) internal view returns (bool _success) {\n', '        bool status = false;\n', '\n', '        if(contributors[_address].canContribute) {\n', '            if(_tier == 0) {\n', '                if(participantCapTier1 >= contributors[_address].contributionInWeiTier1.add(_value)) {\n', '                    status = true;\n', '                }\n', '            }\n', '            else if(_tier == 1) {\n', '                if(participantCapTier2 >= contributors[_address].contributionInWeiTier2.add(_value)) {\n', '                    status = true;\n', '                }\n', '            }\n', '            else if(_tier == 2) {\n', '                status = true;\n', '            }\n', '            else {\n', '                status = true;\n', '            }\n', '        }\n', '\n', '        return status;\n', '    }\n', '    \n', '    /**\n', '     * Get current tier tokens rate\n', '     *\n', '     * @param _tier     Current tier\n', '     */\n', '    function getTierTokens(uint8 _tier) internal view returns(uint256 _tokens) {\n', '        uint256 tokens = RATE_TIER1;\n', '\n', '        if(_tier == 1) {\n', '            tokens = RATE_TIER2;\n', '        }\n', '        else if(_tier == 2) {\n', '            tokens = RATE_TIER3;\n', '        }\n', '        else if(_tier == 3) {\n', '            if(now <= publicSaleDiscountEndTime) {\n', '                tokens = RATE_PUBLIC_SALE;\n', '            }\n', '            else {\n', '                tokens = RATE;\n', '            }\n', '        }\n', '\n', '        return tokens;\n', '    }\n', '\n', '    // Get current tier\n', '    function getCurrentTier() public view returns(uint8 _tier) {\n', '        uint8 currentTier = 3; // 3 is public sale\n', '\n', '        if(stage == Stages.PreSale) {\n', '            if(now <= tierEndTime[0]) {\n', '                currentTier = 0;\n', '            }\n', '            else if(now <= tierEndTime[1]) {\n', '                currentTier = 1;\n', '            }\n', '            else if(now <= tierEndTime[2]) {\n', '                currentTier = 2;\n', '            }\n', '        }\n', '        else {\n', '            if(now > endTime) {\n', '                currentTier = 4; // Token offering ended\n', '            }\n', '        }\n', '\n', '        return currentTier;\n', '    }\n', '\n', '    // Set end time for each tier\n', '    function setTierEndTime() internal AtStage(Stages.Pending) {\n', '        tierEndTime[0] = startTimePresale + 1 days; \n', '        tierEndTime[1] = tierEndTime[0] + 2 days;   \n', '        tierEndTime[2] = tierEndTime[1] + 6 days;   \n', '    }\n', '\n', '    // End the token offering\n', '    function endOffering() public OnlyOwner {\n', '        offeringEnded();\n', '    }\n', '\n', '    // Token offering is ended\n', '    function offeringEnded() internal {\n', '        endTime = now;\n', '        stage = Stages.Ended;\n', '\n', '        emit OfferingCloses(endTime, weiRaised);\n', '    }\n', '\n', '    // Enable transfers, burn unsold tokens & set tokenOfferingAddress to 0\n', '    function enableTransfer() public OnlyOwner returns(bool _success){\n', '        transferIsEnabled = true;\n', '        uint256 tokensToBurn = allowed[msg.sender][contractAddress];\n', '\n', '        if(tokensToBurn != 0){\n', '            burn(tokensToBurn);\n', '            approve(contractAddress, 0);\n', '        }\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Extend end time\n', '     *\n', '     * @param _addedTime Addtional time in secods\n', '     */\n', '    function extendEndTime(uint256 _addedTime) external OnlyOwner {\n', '        endTime = endTime + _addedTime;\n', '    }\n', '    \n', '    /**\n', '     * Extend public sale discount time\n', '     *\n', '     * @param _addedPublicSaleDiscountEndTime Addtional time in secods\n', '     */\n', '    function extendPublicSaleDiscountEndTime(uint256 _addedPublicSaleDiscountEndTime) external OnlyOwner {\n', '        publicSaleDiscountEndTime = publicSaleDiscountEndTime + _addedPublicSaleDiscountEndTime;\n', '    }\n', '    \n', '    /**\n', '     * Update pool cap for tier 1\n', '     *\n', '     * @param _poolAddressCapTier1 Tier cap\n', '     */\n', '    function updatePoolAddressCapTier1(uint256 _poolAddressCapTier1) external OnlyOwner {\n', '        poolAddressCapTier1 = _poolAddressCapTier1;\n', '    }\n', '    \n', '    /**\n', '     * Update pool cap for tier 2\n', '     *\n', '     * @param _poolAddressCapTier2 Tier cap\n', '     */\n', '    function updatePoolAddressCapTier2(uint256 _poolAddressCapTier2) external OnlyOwner {\n', '        poolAddressCapTier2 = _poolAddressCapTier2;\n', '    }\n', '\n', '    //\n', '    \n', '    /**\n', '     * Update participant cap for tier 1\n', '     *\n', '     * @param _participantCapTier1 Tier cap\n', '     */\n', '    function updateParticipantCapTier1(uint256 _participantCapTier1) external OnlyOwner {\n', '        participantCapTier1 = _participantCapTier1;\n', '    }\n', '    \n', '    /**\n', '     * Update participant cap for tier 2\n', '     *\n', '     * @param _participantCapTier2 Tier cap\n', '     */\n', '    function updateParticipantCapTier2(uint256 _participantCapTier2) external OnlyOwner {\n', '        participantCapTier2 = _participantCapTier2;\n', '    }\n', '}']
