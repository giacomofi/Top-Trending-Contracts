['pragma solidity 0.4.18;\n', '\n', '// File: contracts/ERC20Interface.sol\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    function decimals() public view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/ConversionRatesInterface.sol\n', '\n', 'interface ConversionRatesInterface {\n', '\n', '    function recordImbalance(\n', '        ERC20 token,\n', '        int buyAmount,\n', '        uint rateUpdateBlock,\n', '        uint currentBlock\n', '    )\n', '        public;\n', '\n', '    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\n', '    function setQtyStepFunction(ERC20 token, int[] xBuy, int[] yBuy, int[] xSell, int[] ySell) public;\n', '    function setImbalanceStepFunction(ERC20 token, int[] xBuy, int[] yBuy, int[] xSell, int[] ySell) public;\n', '    function claimAdmin() public;\n', '    function addOperator(address newOperator) public;\n', '    function transferAdmin(address newAdmin) public;\n', '    function addToken(ERC20 token) public;\n', '    function setTokenControlInfo(\n', '        ERC20 token,\n', '        uint minimalRecordResolution,\n', '        uint maxPerBlockImbalance,\n', '        uint maxTotalImbalance\n', '    ) public;\n', '    function enableTokenTrade(ERC20 token) public;\n', '    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint);\n', '}\n', '\n', '// File: contracts/PermissionGroups.sol\n', '\n', 'contract PermissionGroups {\n', '\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    mapping(address=>bool) internal operators;\n', '    mapping(address=>bool) internal alerters;\n', '    address[] internal operatorsGroup;\n', '    address[] internal alertersGroup;\n', '    uint constant internal MAX_GROUP_SIZE = 50;\n', '\n', '    function PermissionGroups() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAlerter() {\n', '        require(alerters[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function getOperators () external view returns(address[]) {\n', '        return operatorsGroup;\n', '    }\n', '\n', '    function getAlerters () external view returns(address[]) {\n', '        return alertersGroup;\n', '    }\n', '\n', '    event TransferAdminPending(address pendingAdmin);\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the pendingAdmin address.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdmin(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        TransferAdminPending(pendingAdmin);\n', '        pendingAdmin = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        TransferAdminPending(newAdmin);\n', '        AdminClaimed(newAdmin, admin);\n', '        admin = newAdmin;\n', '    }\n', '\n', '    event AdminClaimed( address newAdmin, address previousAdmin);\n', '\n', '    /**\n', '     * @dev Allows the pendingAdmin address to finalize the change admin process.\n', '     */\n', '    function claimAdmin() public {\n', '        require(pendingAdmin == msg.sender);\n', '        AdminClaimed(pendingAdmin, admin);\n', '        admin = pendingAdmin;\n', '        pendingAdmin = address(0);\n', '    }\n', '\n', '    event AlerterAdded (address newAlerter, bool isAdd);\n', '\n', '    function addAlerter(address newAlerter) public onlyAdmin {\n', '        require(!alerters[newAlerter]); // prevent duplicates.\n', '        require(alertersGroup.length < MAX_GROUP_SIZE);\n', '\n', '        AlerterAdded(newAlerter, true);\n', '        alerters[newAlerter] = true;\n', '        alertersGroup.push(newAlerter);\n', '    }\n', '\n', '    function removeAlerter (address alerter) public onlyAdmin {\n', '        require(alerters[alerter]);\n', '        alerters[alerter] = false;\n', '\n', '        for (uint i = 0; i < alertersGroup.length; ++i) {\n', '            if (alertersGroup[i] == alerter) {\n', '                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n', '                alertersGroup.length--;\n', '                AlerterAdded(alerter, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    event OperatorAdded(address newOperator, bool isAdd);\n', '\n', '    function addOperator(address newOperator) public onlyAdmin {\n', '        require(!operators[newOperator]); // prevent duplicates.\n', '        require(operatorsGroup.length < MAX_GROUP_SIZE);\n', '\n', '        OperatorAdded(newOperator, true);\n', '        operators[newOperator] = true;\n', '        operatorsGroup.push(newOperator);\n', '    }\n', '\n', '    function removeOperator (address operator) public onlyAdmin {\n', '        require(operators[operator]);\n', '        operators[operator] = false;\n', '\n', '        for (uint i = 0; i < operatorsGroup.length; ++i) {\n', '            if (operatorsGroup[i] == operator) {\n', '                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n', '                operatorsGroup.length -= 1;\n', '                OperatorAdded(operator, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Withdrawable.sol\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens or ethers\n', ' * @author Ilan Doron\n', ' * @dev This allows to recover any tokens or Ethers received in a contract.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract Withdrawable is PermissionGroups {\n', '\n', '    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw all ERC20 compatible tokens\n', '     * @param token ERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n', '        require(token.transfer(sendTo, amount));\n', '        TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    event EtherWithdraw(uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n', '        sendTo.transfer(amount);\n', '        EtherWithdraw(amount, sendTo);\n', '    }\n', '}\n', '\n', '// File: contracts/wrapperContracts/WrapperBase.sol\n', '\n', 'contract WrapperBase is Withdrawable {\n', '\n', '    PermissionGroups wrappedContract;\n', '\n', '    struct DataTracker {\n', '        address [] approveSignatureArray;\n', '        uint lastSetNonce;\n', '    }\n', '\n', '    DataTracker[] internal dataInstances;\n', '\n', '    function WrapperBase(PermissionGroups _wrappedContract, address _admin) public {\n', '        require(_wrappedContract != address(0));\n', '        require(_admin != address(0));\n', '        wrappedContract = _wrappedContract;\n', '        admin = _admin;\n', '    }\n', '\n', '    function claimWrappedContractAdmin() public onlyAdmin {\n', '        wrappedContract.claimAdmin();\n', '    }\n', '\n', '    function transferWrappedContractAdmin (address newAdmin) public onlyAdmin {\n', '        wrappedContract.transferAdmin(newAdmin);\n', '    }\n', '\n', '    function addDataInstance() internal returns (uint) {\n', '        address[] memory add = new address[](0);\n', '        dataInstances.push(DataTracker(add, 0));\n', '        return(dataInstances.length - 1);\n', '    }\n', '\n', '    function setNewData(uint dataIndex) internal {\n', '        require(dataIndex < dataInstances.length);\n', '        dataInstances[dataIndex].lastSetNonce++;\n', '        dataInstances[dataIndex].approveSignatureArray.length = 0;\n', '    }\n', '\n', '    function addSignature(uint dataIndex, uint signedNonce, address signer) internal returns(bool allSigned) {\n', '        require(dataIndex < dataInstances.length);\n', '        require(dataInstances[dataIndex].lastSetNonce == signedNonce);\n', '\n', '        for(uint i = 0; i < dataInstances[dataIndex].approveSignatureArray.length; i++) {\n', '            if (signer == dataInstances[dataIndex].approveSignatureArray[i]) revert();\n', '        }\n', '        dataInstances[dataIndex].approveSignatureArray.push(signer);\n', '\n', '        if (dataInstances[dataIndex].approveSignatureArray.length == operatorsGroup.length) {\n', '            allSigned = true;\n', '        } else {\n', '            allSigned = false;\n', '        }\n', '    }\n', '\n', '    function getDataTrackingParameters(uint index) internal view returns (address[], uint) {\n', '        require(index < dataInstances.length);\n', '        return(dataInstances[index].approveSignatureArray, dataInstances[index].lastSetNonce);\n', '    }\n', '}\n', '\n', '// File: contracts/wrapperContracts/WrapConversionRate.sol\n', '\n', 'contract WrapConversionRate is WrapperBase {\n', '\n', '    ConversionRatesInterface conversionRates;\n', '\n', '    //add token parameters\n', '    ERC20     addTokenToken;\n', '    uint      addTokenMinimalResolution; // can be roughly 1 cent\n', '    uint      addTokenMaxPerBlockImbalance; // in twei resolution\n', '    uint      addTokenMaxTotalImbalance;\n', '    uint      addTokenDataIndex;\n', '\n', '    //set token control info parameters.\n', '    ERC20[]     tokenInfoTokenList;\n', '    uint[]      tokenInfoPerBlockImbalance; // in twei resolution\n', '    uint[]      tokenInfoMaxTotalImbalance;\n', '    uint        tokenInfoDataIndex;\n', '\n', '    //general functions\n', '    function WrapConversionRate(ConversionRatesInterface _conversionRates, address _admin) public\n', '        WrapperBase(PermissionGroups(address(_conversionRates)), _admin)\n', '    {\n', '        require (_conversionRates != address(0));\n', '        conversionRates = _conversionRates;\n', '        addTokenDataIndex = addDataInstance();\n', '        tokenInfoDataIndex = addDataInstance();\n', '    }\n', '\n', '    function getWrappedContract() public view returns (ConversionRatesInterface _conversionRates) {\n', '        _conversionRates = conversionRates;\n', '    }\n', '\n', '    // add token functions\n', '    //////////////////////\n', '    function setAddTokenData(ERC20 token, uint minimalRecordResolution, uint maxPerBlockImbalance, uint maxTotalImbalance) public onlyOperator {\n', '        require(minimalRecordResolution != 0);\n', '        require(maxPerBlockImbalance != 0);\n', '        require(maxTotalImbalance != 0);\n', '\n', '        //update data tracking\n', '        setNewData(addTokenDataIndex);\n', '\n', '        addTokenToken = token;\n', '        addTokenMinimalResolution = minimalRecordResolution; // can be roughly 1 cent\n', '        addTokenMaxPerBlockImbalance = maxPerBlockImbalance; // in twei resolution\n', '        addTokenMaxTotalImbalance = maxTotalImbalance;\n', '    }\n', '\n', '    function signToApproveAddTokenData(uint nonce) public onlyOperator {\n', '        if(addSignature(addTokenDataIndex, nonce, msg.sender)) {\n', '            // can perform operation.\n', '            performAddToken();\n', '        }\n', '    }\n', '\n', '    function performAddToken() internal {\n', '        conversionRates.addToken(addTokenToken);\n', '\n', '        //token control info\n', '        conversionRates.setTokenControlInfo(\n', '            addTokenToken,\n', '            addTokenMinimalResolution,\n', '            addTokenMaxPerBlockImbalance,\n', '            addTokenMaxTotalImbalance\n', '        );\n', '\n', '        //step functions\n', '        int[] memory zeroArr = new int[](1);\n', '        zeroArr[0] = 0;\n', '\n', '        conversionRates.setQtyStepFunction(addTokenToken, zeroArr, zeroArr, zeroArr, zeroArr);\n', '        conversionRates.setImbalanceStepFunction(addTokenToken, zeroArr, zeroArr, zeroArr, zeroArr);\n', '\n', '        conversionRates.enableTokenTrade(addTokenToken);\n', '    }\n', '\n', '    function getAddTokenParameters() public view\n', '        returns(ERC20 token, uint minimalRecordResolution, uint maxPerBlockImbalance, uint maxTotalImbalance)\n', '    {\n', '        token = addTokenToken;\n', '        minimalRecordResolution = addTokenMinimalResolution;\n', '        maxPerBlockImbalance = addTokenMaxPerBlockImbalance; // in twei resolution\n', '        maxTotalImbalance = addTokenMaxTotalImbalance;\n', '    }\n', '\n', '    function getAddTokenDataTracking() public view returns (address[] signatures, uint nonce) {\n', '        (signatures, nonce) = getDataTrackingParameters(addTokenDataIndex);\n', '        return(signatures, nonce);\n', '    }\n', '\n', '    //set token control info\n', '    ////////////////////////\n', '    function setTokenInfoData(ERC20 [] tokens, uint[] maxPerBlockImbalanceValues, uint[] maxTotalImbalanceValues)\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(maxPerBlockImbalanceValues.length == tokens.length);\n', '        require(maxTotalImbalanceValues.length == tokens.length);\n', '\n', '        //update data tracking\n', '        setNewData(tokenInfoDataIndex);\n', '\n', '        tokenInfoTokenList = tokens;\n', '        tokenInfoPerBlockImbalance = maxPerBlockImbalanceValues;\n', '        tokenInfoMaxTotalImbalance = maxTotalImbalanceValues;\n', '    }\n', '\n', '    function signToApproveTokenControlInfo(uint nonce) public onlyOperator {\n', '        if(addSignature(tokenInfoDataIndex, nonce, msg.sender)) {\n', '            // can perform operation.\n', '            performSetTokenControlInfo();\n', '        }\n', '    }\n', '\n', '    function performSetTokenControlInfo() internal {\n', '        require(tokenInfoTokenList.length == tokenInfoPerBlockImbalance.length);\n', '        require(tokenInfoTokenList.length == tokenInfoMaxTotalImbalance.length);\n', '\n', '        uint minimalRecordResolution;\n', '        uint rxMaxPerBlockImbalance;\n', '        uint rxMaxTotalImbalance;\n', '\n', '        for (uint i = 0; i < tokenInfoTokenList.length; i++) {\n', '            (minimalRecordResolution, rxMaxPerBlockImbalance, rxMaxTotalImbalance) =\n', '                conversionRates.getTokenControlInfo(tokenInfoTokenList[i]);\n', '            require(minimalRecordResolution != 0);\n', '\n', '            conversionRates.setTokenControlInfo(tokenInfoTokenList[i],\n', '                                                minimalRecordResolution,\n', '                                                tokenInfoPerBlockImbalance[i],\n', '                                                tokenInfoMaxTotalImbalance[i]);\n', '        }\n', '    }\n', '\n', '    function getControlInfoPerToken (uint index) public view returns(ERC20 token, uint _maxPerBlockImbalance, uint _maxTotalImbalance) {\n', '        require (tokenInfoTokenList.length > index);\n', '        require (tokenInfoPerBlockImbalance.length > index);\n', '        require (tokenInfoMaxTotalImbalance.length > index);\n', '\n', '        return(tokenInfoTokenList[index], tokenInfoPerBlockImbalance[index], tokenInfoMaxTotalImbalance[index]);\n', '    }\n', '\n', '    function getTokenInfoData() public view returns(ERC20[], uint[], uint[]) {\n', '        return(tokenInfoTokenList, tokenInfoPerBlockImbalance, tokenInfoMaxTotalImbalance);\n', '    }\n', '\n', '    function getTokenInfoTokenList() public view returns(ERC20[] tokens) {\n', '        return(tokenInfoTokenList);\n', '    }\n', '\n', '    function getTokenInfoMaxPerBlockImbalanceList() public view returns(uint[] maxPerBlockImbalanceValues) {\n', '        return (tokenInfoPerBlockImbalance);\n', '    }\n', '\n', '    function getTokenInfoMaxTotalImbalanceList() public view returns(uint[] maxTotalImbalanceValues) {\n', '        return(tokenInfoMaxTotalImbalance);\n', '    }\n', '\n', '    function getTokenInfoDataTracking() public view returns (address[] signatures, uint nonce) {\n', '        (signatures, nonce) = getDataTrackingParameters(tokenInfoDataIndex);\n', '        return(signatures, nonce);\n', '    }\n', '}']