['pragma solidity ^0.4.16;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title TenTimesToken\n', ' * @dev An ERC20 token which doubles the balance each 2 million blocks.\n', ' */\n', 'contract TenTimesToken is Ownable {\n', '    \n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) startBalances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    mapping(address => uint256) startBlocks;\n', '    \n', '    string public constant name = "Ten Times";\n', '    string public constant symbol = "TENT";\n', '    uint32 public constant decimals = 10;\n', '\n', '    function TenTimesToken() public {\n', '        totalSupply = 1000000 * 10**uint256(decimals);\n', '        startBalances[owner] = totalSupply;\n', '        startBlocks[owner] = block.number;\n', '        Transfer(address(0), owner, totalSupply);\n', '    }\n', '\n', '    /**\n', '     * @dev Computes `k * (1+1/q) ^ N`, with precision `p`. The higher\n', '     * the precision, the higher the gas cost. It should be\n', '     * something around the log of `n`. When `p == n`, the\n', '     * precision is absolute (sans possible integer overflows). <edit: NOT true, see comments>\n', '     * Much smaller values are sufficient to get a great approximation.\n', '     * from https://ethereum.stackexchange.com/questions/10425/is-there-any-efficient-way-to-compute-the-exponentiation-of-a-fraction-and-an-in\n', '     */\n', '    function fracExp(uint256 k, uint256 q, uint256 n, uint256 p) pure public returns (uint256) {\n', '        uint256 s = 0;\n', '        uint256 N = 1;\n', '        uint256 B = 1;\n', '        for (uint256 i = 0; i < p; ++i) {\n', '            s += k * N / B / (q**i);\n', '            N = N * (n-i);\n', '            B = B * (i+1);\n', '        }\n', '        return s;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Computes the compound interest for an account since the block stored in startBlock\n', '     * about factor 10 for 2 million blocks.\n', '     */\n', '    function compoundInterest(address tokenOwner) view public returns (uint256) {\n', '        require(startBlocks[tokenOwner] > 0);\n', '        uint256 start = startBlocks[tokenOwner];\n', '        uint256 current = block.number;\n', '        uint256 blockCount = current - start;\n', '        uint256 balance = startBalances[tokenOwner];\n', '        return fracExp(balance, 867598, blockCount, 8) - balance;\n', '    }\n', '\n', '\n', '    /**\n', "     * @dev Get the token balance for account 'tokenOwner'\n", '     */\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '        return startBalances[tokenOwner] + compoundInterest(tokenOwner);\n', '    }\n', '\n', '    \n', '    /**\n', '     * @dev Add the compound interest to the startBalance, update the start block,\n', '     * and update totalSupply\n', '     */\n', '    function updateBalance(address tokenOwner) private {\n', '        if (startBlocks[tokenOwner] == 0) {\n', '            startBlocks[tokenOwner] = block.number;\n', '        }\n', '        uint256 ci = compoundInterest(tokenOwner);\n', '        startBalances[tokenOwner] = startBalances[tokenOwner] + ci;\n', '        totalSupply = totalSupply + ci;\n', '        startBlocks[tokenOwner] = block.number;\n', '    }\n', '    \n', '\n', '    /**\n', "     * @dev Transfer the balance from token owner's account to `to` account\n", "     * - Owner's account must have sufficient balance to transfer\n", '     * - 0 value transfers are allowed\n', '     */\n', '    function transfer(address to, uint256 tokens) public returns (bool) {\n', '        updateBalance(msg.sender);\n', '        updateBalance(to);\n', '        require(tokens <= startBalances[msg.sender]);\n', '\n', '        startBalances[msg.sender] = startBalances[msg.sender] - tokens;\n', '        startBalances[to] = startBalances[to] + tokens;\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Transfer `tokens` from the `from` account to the `to` account\n', '     * \n', '     * The calling account must already have sufficient tokens approve(...)-d\n', '     * for spending from the `from` account and\n', '     * - From account must have sufficient balance to transfer\n', '     * - Spender must have sufficient allowance to transfer\n', '     * - 0 value transfers are allowed\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool) {\n', '        updateBalance(from);\n', '        updateBalance(to);\n', '        require(tokens <= startBalances[from]);\n', '\n', '        startBalances[from] = startBalances[from] - tokens;\n', '        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\n', '        startBalances[to] = startBalances[to] + tokens;\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev Allow `spender` to withdraw from your account, multiple times, up to the 'tokens' amount.\n", "     * If this function is called again it overwrites the current allowance with 'tokens'.\n", '     */\n', '    function approve(address spender, uint256 tokens) public returns (bool) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '   \n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 tokens);\n', '\n', '}']