['pragma solidity ^0.4.18;\n', 'library SafeMath { //standard library for uint\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0 || b == 0){\n', '        return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\n', '    if (b == 0){\n', '      return 1;\n', '    }\n', '    uint256 c = a**b;\n', '    assert (c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable { //standart contract to identify owner\n', '  address public owner;\n', '\n', '  address public newOwner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    newOwner = _newOwner;\n', '  }\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', 'contract SpyceToken{\n', '  function sendCrowdsaleTokens(address, uint256)  public;\n', '  function setCrowdsaleContract (address) public;\n', '  function burnContributorTokens (address _address) public;\n', '}\n', '\n', 'contract SpyceCrowdsale is Ownable{\n', '  using SafeMath for uint;\n', '\n', '  uint decimals = 18;\n', '\n', '  // Token contract address\n', '  SpyceToken public token;\n', '\n', '  function SpyceCrowdsale(address _tokenAddress) public{\n', '    token = SpyceToken(_tokenAddress);\n', '\n', '    owner = msg.sender;\n', '    token.setCrowdsaleContract(this);\n', '\n', '    stageStruct memory buffer;\n', '\n', '    buffer.startDate = 0; \n', '    \n', '    //1522195199 is equivalent to 03/27/2018 @ 11:59pm (UTC)\n', '    buffer.finishDate = 1522195199;\n', '    buffer.tokenPrice = 0.00016 ether;\n', '    buffer.minCap = 675000 ether;\n', '    buffer.maxCap = 150000000 ether;\n', '\n', '    stages.push(buffer);\n', '  }\n', '\n', '  /* Destribution addresses */\n', '  //All ether will be send to this address: 0x003b43733592eFa879B7154eDE5A4Eea47585f30\n', '  address distributionAddress = 0x003b43733592eFa879B7154eDE5A4Eea47585f30;\n', '\n', '  function () public payable {\n', '    require (buy(msg.sender, msg.value, now));\n', '  }\n', '\n', '\n', '  function buy (address _address, uint _value, uint _time) internal returns(bool) {\n', '\n', '    uint currentStage = getCurrentStage(_time);\n', '    \n', '    require(currentStage != 1000);\n', '\n', '    uint tokensToSend = _value.mul((uint)(10).pow(decimals))/stages[currentStage].tokenPrice;\n', '\n', '    require (tokensToSend.add(stages[currentStage].tokensSold) <= stages[currentStage].maxCap);\n', '\n', '    stages[currentStage].tokensSold = stages[currentStage].tokensSold.add(tokensToSend);\n', '\n', '    stages[currentStage].ethContributors[_address] = stages[currentStage].ethContributors[_address].add(_value);\n', '\n', '    stages[currentStage].ethCollected = stages[currentStage].ethCollected.add(_value);\n', '\n', '    token.sendCrowdsaleTokens(_address, tokensToSend);\n', '\n', '    autoDistribute(currentStage);\n', '\n', '    return true;\n', '  }\n', '\n', '  function autoDistribute (uint currentStage) internal {\n', '    if (stages[currentStage].minCap <= stages[currentStage].tokensSold){\n', '\n', '      distributionAddress.transfer(stages[currentStage].ethCollected.sub(stages[currentStage].ethSended));\n', '\n', '      stages[currentStage].ethSended = stages[currentStage].ethCollected;\n', '    }\n', '  }\n', '  \n', '  \n', 'function manualSendTokens (address _address, uint _value) public onlyOwner {\n', '\n', '    uint currentStage = getCurrentStage(now);\n', '    require(currentStage != 1000);\n', '\n', '    stages[currentStage].tokensSold = stages[currentStage].tokensSold.add(_value.mul((uint)(10).pow(decimals)));\n', '\n', '    token.sendCrowdsaleTokens(_address,_value.mul((uint)(10).pow(decimals)));\n', '\n', '    autoDistribute(currentStage);\n', '  }\n', '  \n', '  struct stageStruct {\n', '    uint startDate;\n', '    uint finishDate;\n', '    uint tokenPrice;\n', '    uint minCap;\n', '    uint maxCap;\n', '    uint tokensSold;\n', '\n', '    uint ethCollected;\n', '    uint ethSended;\n', '\n', '    mapping (address => uint) ethContributors; \n', '  }\n', '\n', '  stageStruct[] public stages;\n', '\n', '\n', '  function addNewStage (uint _start, uint _finish, uint _price, uint _mincap, uint _maxcap) public onlyOwner {\n', '    stageStruct memory buffer;\n', '\n', '    buffer.startDate = _start;\n', '    buffer.finishDate = _finish;\n', '    buffer.tokenPrice = _price;\n', '    buffer.minCap = _mincap.mul((uint)(10).pow(decimals));\n', '    buffer.maxCap = _maxcap.mul((uint)(10).pow(decimals));\n', '\n', '    stages.push(buffer);\n', '  }\n', '  \n', '  function getCurrentStage (uint _time) public view returns (uint) {\n', '    uint currentStage = 0;\n', '    for (uint i = 0; i < stages.length; i++){\n', '      if (stages[i].startDate < _time && _time <= stages[i].finishDate){\n', '        currentStage = i;\n', '        break;\n', '      }\n', '    }\n', '    if (stages[currentStage].startDate < _time && _time <= stages[currentStage].finishDate){\n', '      return currentStage;\n', '    }else{\n', '      return 1000; //NO ACTIVE STAGE\n', '    }\n', '  }\n', '  \n', '  \n', '  function refund () public {\n', '    uint currentStage = getCurrentStage(now);\n', '\n', '    for (uint i = 0; i < currentStage; i++){\n', '      if(stages[i].ethContributors[msg.sender] > 0 && stages[i].tokensSold < stages[i].minCap){\n', '        msg.sender.transfer(stages[i].ethContributors[msg.sender]);\n', '        stages[i].ethContributors[msg.sender] = 0;\n', '      }\n', '    }\n', '  }\n', '\n', '}']