['pragma solidity ^0.4.23;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/TokenDestructible.sol\n', '\n', '/**\n', ' * @title TokenDestructible:\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract including\n', ' * listed tokens will be sent to the owner.\n', ' */\n', 'contract TokenDestructible is Ownable {\n', '\n', '  function TokenDestructible() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\n', '   refund.\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy(address[] tokens) onlyOwner public {\n', '\n', '    // Transfer tokens to owner\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      ERC20Basic token = ERC20Basic(tokens[i]);\n', '      uint256 balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '    }\n', '\n', '    // Transfer Eth to owner and terminate contract\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', '// File: contracts/Atonomi.sol\n', '\n', '// solhint-disable-line\n', '\n', '\n', '\n', '\n', '/// @title ERC-20 Token Standard\n', '/// @author Fabian Vogelsteller <fabian@ethereum.org>, Vitalik Buterin <vitalik.buterin@ethereum.org>\n', '/// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'interface ERC20Interface {\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);   // solhint-disable-line\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '/// @title Safe Math library\n', '/// @dev Math operations with safety checks that throw on error\n', '/// @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '    /// @dev Multiplies two numbers, throws on overflow.\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /// @dev Integer division of two numbers, truncating the quotient.\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /// @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Adds two numbers, throws on overflow.\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/// @dev Interface for the Network Settings contract\n', 'interface SettingsInterface {\n', '    function registrationFee() external view returns (uint256);\n', '    function activationFee() external view returns (uint256);\n', '    function defaultReputationReward() external view returns (uint256);\n', '    function reputationIRNNodeShare() external view returns (uint256);\n', '    function blockThreshold() external view returns (uint256);\n', '}\n', '\n', '\n', '/// @title Atonomi Smart Contract\n', '/// @author Atonomi\n', '/// @notice Governs the activation, registration, and reputation of devices on the Atonomi network\n', '/// @dev Ownable: Owner governs the access of Atonomi Admins, Fees, and Rewards on the network\n', '/// @dev Pausable: Gives ability for Owner to pull emergency stop to prevent actions on the network\n', '/// @dev TokenDestructible: Gives owner ability to kill the contract and extract funds to a new contract\n', 'contract Atonomi is Pausable, TokenDestructible {\n', '    using SafeMath for uint256;\n', '\n', '    /// @title ATMI Token\n', '    /// @notice Standard ERC20 Token\n', '    /// @dev AMLToken source: https://github.com/TokenMarketNet/ico/blob/master/contracts/AMLToken.sol\n', '    ERC20Interface public token;\n', '\n', '    /// @title Network Settings\n', '    /// @notice Atonomi Owner controlled settings are governed in this contract\n', '    SettingsInterface public settings;\n', '\n', '    ///\n', '    /// STORAGE MAPPINGS \n', '    ///\n', '    /// @title Atonomi Devices registry\n', '    /// @notice Contains all devices participating in the Atonomi Network\n', '    /// @dev Key is a keccak256 hash of the device id\n', '    /// @dev Value is a struct that contains the device status and metadata\n', '    mapping (bytes32 => Device) public devices;\n', '\n', '    /// @title Atonomi Participant whitelist\n', '    /// @notice Contains all the network participants\n', '    /// @dev Atonomi Admins: Govern the access to manufacturers and IRN Nodes on the network\n', '    /// @dev IRN Nodes: Governs reputation score data of devices\n', '    /// @dev Manufacturers: Governs devices on the network\n', '    /// @dev Key is ethereum account of the participant\n', '    /// @dev Value is a struct that contains the role of the participant\n', '    mapping (address => NetworkMember) public network;\n', '\n', '    /// @title Token Pools\n', '    /// @notice each manufacturer will manage a pool of tokens for reputation rewards\n', '    /// @dev Key is ethereum account for pool owner\n', '    /// @dev Value is struct representing token pool attributes\n', '    /// @dev incoming tokens will come from registrations, activations, or public donations\n', '    /// @dev outgoing tokens will come from reputation rewards\n', '    mapping (address => TokenPool) public pools;\n', '\n', '    /// @title Reward Balances\n', '    /// @notice balances of rewards that are able to be claimed by participants\n', '    /// @dev Key is ethereum account of the owner of the tokens\n', '    /// @dev Value is tokens available for withdraw\n', '    mapping (address => uint256) public rewards;\n', '\n', '    /// @title Lookup by Manufacturer ID the wallet for reputation rewards\n', '    /// @dev Key is the manufacturer id\n', '    /// @dev Value is ethereum account to be rewarded\n', '    mapping (bytes32 => address) public manufacturerRewards;\n', '\n', '    /// @title Track last write by reputation author\n', '    /// @dev First key is the ethereum address of the reputation author\n', '    /// @dev Second key is the device id\n', '    /// @dev Value is the block number of the last time the author has submitted a score for the device\n', '    mapping (address => mapping (bytes32 => uint256)) public authorWrites;\n', '\n', '    /// @title Default Repuration score for manufacturers\n', '    /// @dev Key is the manufacturer id\n', '    /// @dev value is the score to use for newly registered devices\n', '    mapping (bytes32 => bytes32) public defaultManufacturerReputations;\n', '\n', '    ///\n', '    /// TYPES \n', '    ///\n', '    /// @title Atonomi Device\n', '    /// @notice Contains the device state on the Atonomi network\n', '    /// @dev manufacturerId is the manufacturer the device belongs to\n', '    /// @dev deviceType is the type of device categorized by the manufacturer\n', '    /// @dev registered is true when device is registered, otherwise false\n', '    /// @dev activated is true when device is activated, otherwise false\n', '    /// @dev reputationScore is official Atonomi Reputation score for the device\n', '    /// @dev devicePublicKey is public key used by IRN Nodes for validation\n', '    struct Device {\n', '        bytes32 manufacturerId;\n', '        bytes32 deviceType;\n', '        bool registered;\n', '        bool activated;\n', '        bytes32 reputationScore;\n', '        bytes32 devicePublicKey;\n', '    }\n', '\n', '    /// @title Token Pool\n', '    /// @notice Contains balance and reputation reward amounts for each token pool\n', '    /// @dev balance is total amount of tokens available in the pool\n', '    /// @dev rewardAmount is the total amount distributed between the manufacturer and reputation author\n', '    struct TokenPool {\n', '        uint256 balance;\n', '        uint256 rewardAmount;\n', '    }\n', '\n', '    /// @title Atonomi Network Participant\n', '    /// @notice Contains role information for a participant\n', '    /// @dev isIRNAdmin is true if participant is an IRN Admin, otherwise false\n', '    /// @dev isManufacturer is true if participant is a Manufacturer, otherwise false\n', '    /// @dev isIRNNode is true if participant is an IRN Node, otherwise false\n', '    /// @dev memberId is the manufacturer id, for all other participants this will be 0\n', '    struct NetworkMember {\n', '        bool isIRNAdmin;\n', '        bool isManufacturer;\n', '        bool isIRNNode;\n', '        bytes32 memberId;\n', '    }\n', '\n', '    ///\n', '    /// MODIFIERS\n', '    ///\n', '    /// @notice only manufacturers can call, otherwise throw\n', '    modifier onlyManufacturer() {\n', '        require(network[msg.sender].isManufacturer, "must be a manufacturer");\n', '        _;\n', '    }\n', '\n', '    /// @notice only IRNAdmins or Owner can call, otherwise throw\n', '    modifier onlyIRNorOwner() {\n', '        require(msg.sender == owner || network[msg.sender].isIRNAdmin, "must be owner or an irn admin");\n', '        _;\n', '    }\n', '\n', '    /// @notice only IRN Nodes can call, otherwise throw\n', '    modifier onlyIRNNode() {\n', '        require(network[msg.sender].isIRNNode, "must be an irn node");\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor sets the ERC Token contract and initial values for network fees\n', '    /// @param _token is the Atonomi Token contract address (must be ERC20)\n', '    /// @param _settings is the Atonomi Network Settings contract address\n', '    constructor (\n', '        address _token,\n', '        address _settings) public {\n', '        require(_token != address(0), "token address cannot be 0x0");\n', '        require(_settings != address(0), "settings address cannot be 0x0");\n', '        token = ERC20Interface(_token);\n', '        settings = SettingsInterface(_settings);\n', '    }\n', '\n', '    ///\n', '    /// EVENTS \n', '    ///\n', '    /// @notice emitted on successful device registration\n', '    /// @param _sender manufacturer paying for registration\n', '    /// @param _fee registration fee paid by manufacturer\n', '    /// @param _deviceHashKey keccak256 hash of device id used as the key in devices mapping\n', '    /// @param _manufacturerId of the manufacturer the device belongs to\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    event DeviceRegistered(\n', '        address indexed _sender,\n', '        uint256 _fee,\n', '        bytes32 indexed _deviceHashKey,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _deviceType\n', '    );\n', '\n', '    /// @notice emitted on successful device activation\n', '    /// @param _sender manufacturer or device owner paying for activation\n', '    /// @param _fee registration fee paid by manufacturer\n', '    /// @param _deviceId the real device id (only revealed after activation)\n', '    /// @param _manufacturerId of the manufacturer the device belongs to\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    event DeviceActivated(\n', '        address indexed _sender,\n', '        uint256 _fee,\n', '        bytes32 indexed _deviceId,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _deviceType\n', '    );\n', '\n', '    /// @notice emitted on reputation change for a device\n', '    /// @param _deviceId device id of the target device\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @param _newScore updated reputation score\n', '    /// @param _irnNode IRN node submitting the new reputation\n', '    /// @param _irnReward tokens awarded to irn node\n', '    /// @param _manufacturerWallet manufacturer associated with the device is rewared a share of tokens\n', '    /// @param _manufacturerReward tokens awarded to contributor\n', '    event ReputationScoreUpdated(\n', '        bytes32 indexed _deviceId,\n', '        bytes32 _deviceType,\n', '        bytes32 _newScore,\n', '        address indexed _irnNode,\n', '        uint256 _irnReward,\n', '        address indexed _manufacturerWallet,\n', '        uint256 _manufacturerReward\n', '    );\n', '\n', '    /// @notice emitted on successful addition of network member address\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _member address of added member\n', '    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\n', '    event NetworkMemberAdded(\n', '        address indexed _sender,\n', '        address indexed _member,\n', '        bytes32 indexed _memberId\n', '    );\n', '\n', '    /// @notice emitted on successful removal of network member address\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _member address of removed member\n', '    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\n', '    event NetworkMemberRemoved(\n', '        address indexed _sender,\n', '        address indexed _member,\n', '        bytes32 indexed _memberId\n', '    );\n', '\n', '    /// @notice emitted everytime a manufacturer changes their wallet for rewards\n', '    /// @param _old ethereum account\n', '    /// @param _new ethereum account\n', '    /// @param _manufacturerId that the member belongs to\n', '    event ManufacturerRewardWalletChanged(\n', '        address indexed _old,\n', '        address indexed _new,\n', '        bytes32 indexed _manufacturerId\n', '    );\n', '\n', '    /// @notice emitted everytime a token pool reward amount changes\n', '    /// @param _sender ethereum account of the token pool owner\n', '    /// @param _newReward new reward value in ATMI tokens\n', '    event TokenPoolRewardUpdated(\n', '        address indexed _sender,\n', '        uint256 _newReward\n', '    );\n', '\n', '    /// @notice emitted everytime someone donates tokens to a manufacturer\n', '    /// @param _sender ethereum account of the donater\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _manufacturer ethereum account\n', '    /// @param _amount of tokens deposited\n', '    event TokensDeposited(\n', '        address indexed _sender,\n', '        bytes32 indexed _manufacturerId,\n', '        address indexed _manufacturer,\n', '        uint256 _amount\n', '    );\n', '    \n', '    /// @notice emitted everytime a participant withdraws from token pool\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _amount tokens withdrawn\n', '    event TokensWithdrawn(\n', '        address indexed _sender,\n', '        uint256 _amount\n', '    );\n', '\n', '    /// @notice emitted everytime the default reputation for a manufacturer changes\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _newDefaultScore to use for newly registered devices\n', '    event DefaultReputationScoreChanged(\n', '        address indexed _sender,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _newDefaultScore\n', '    );\n', '\n', '    ///\n', '    /// DEVICE ONBOARDING\n', '    ///\n', '    /// @notice registers device on the Atonomi network\n', '    /// @param _deviceIdHash keccak256 hash of the device&#39;s id (needs to be hashed by caller)\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @dev devicePublicKey is public key used by IRN Nodes for validation\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerDevice(\n', '        bytes32 _deviceIdHash,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey)\n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        uint256 registrationFee = settings.registrationFee();\n', '        Device memory d = _registerDevice(msg.sender, _deviceIdHash, _deviceType, _devicePublicKey);\n', '        emit DeviceRegistered(\n', '            msg.sender,\n', '            registrationFee,\n', '            _deviceIdHash,\n', '            d.manufacturerId,\n', '            _deviceType);\n', '        _depositTokens(msg.sender, registrationFee);\n', '        require(token.transferFrom(msg.sender, address(this), registrationFee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice Activates the device\n', '    /// @param _deviceId id of the real device id to be activated (not the hash of the device id)\n', '    /// @return true if successful, otherwise false\n', '    /// @dev if the hash doesnt match, the device is considered not registered and will throw\n', '    /// @dev anyone with the device id (in hand) is considered the device owner\n', '    /// @dev tokens will be deducted from the device owner and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function activateDevice(bytes32 _deviceId) public whenNotPaused returns (bool) {\n', '        uint256 activationFee = settings.activationFee();\n', '        Device memory d = _activateDevice(_deviceId);\n', '        emit DeviceActivated(msg.sender, activationFee, _deviceId, d.manufacturerId, d.deviceType);\n', '        address manufacturer = manufacturerRewards[d.manufacturerId];\n', '        require(manufacturer != address(this), "manufacturer is unknown");\n', '        _depositTokens(manufacturer, activationFee);\n', '        require(token.transferFrom(msg.sender, address(this), activationFee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice Registers and immediately activates device, used by manufacturers to prepay activation\n', '    /// @param _deviceId id of the real device id to be activated (not the has of the device id)\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @return true if successful, otherwise false\n', '    /// @dev since the manufacturer is trusted, no need for the caller to hash the device id\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerAndActivateDevice(\n', '        bytes32 _deviceId,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey) \n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        uint256 registrationFee = settings.registrationFee();\n', '        uint256 activationFee = settings.activationFee();\n', '\n', '        bytes32 deviceIdHash = keccak256(_deviceId);\n', '        Device memory d = _registerDevice(msg.sender, deviceIdHash, _deviceType, _devicePublicKey);\n', '        bytes32 manufacturerId = d.manufacturerId;\n', '        emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, manufacturerId, _deviceType);\n', '\n', '        d = _activateDevice(_deviceId);\n', '        emit DeviceActivated(msg.sender, activationFee, _deviceId, manufacturerId, _deviceType);\n', '\n', '        uint256 fee = registrationFee.add(activationFee);\n', '        _depositTokens(msg.sender, fee);\n', '        require(token.transferFrom(msg.sender, address(this), fee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// REPUTATION MANAGEMENT\n', '    ///\n', '    /// @notice updates reputation for a device\n', '    /// @param _deviceId target device Id\n', '    /// @param _reputationScore updated reputation score computed by the author\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the reputation author (either irn node or the reputation auditor)\n', '    /// @dev tokens will be deducted from the contract pool\n', '    /// @dev author and manufacturer will be rewarded a split of the tokens\n', '    /// @dev owner has ability to pause this operation\n', '    function updateReputationScore(\n', '        bytes32 _deviceId,\n', '        bytes32 _reputationScore)\n', '        public onlyIRNNode whenNotPaused returns (bool)\n', '    {\n', '        Device memory d = _updateReputationScore(_deviceId, _reputationScore);\n', '\n', '        address _manufacturerWallet = manufacturerRewards[d.manufacturerId];\n', '        require(_manufacturerWallet != address(0), "_manufacturerWallet cannot be 0x0");\n', '        require(_manufacturerWallet != msg.sender, "manufacturers cannot collect the full reward");\n', '\n', '        uint256 irnReward;\n', '        uint256 manufacturerReward;\n', '        (irnReward, manufacturerReward) = getReputationRewards(msg.sender, _manufacturerWallet, _deviceId);\n', '        _distributeRewards(_manufacturerWallet, msg.sender, irnReward);\n', '        _distributeRewards(_manufacturerWallet, _manufacturerWallet, manufacturerReward);\n', '        emit ReputationScoreUpdated(\n', '            _deviceId,\n', '            d.deviceType,\n', '            _reputationScore,\n', '            msg.sender,\n', '            irnReward,\n', '            _manufacturerWallet,\n', '            manufacturerReward);\n', '        authorWrites[msg.sender][_deviceId] = block.number;\n', '        return true;\n', '    }\n', '\n', '    /// @notice computes the portion of the reputation reward allotted to the manufacturer and author\n', '    /// @param author is the reputation node submitting the score\n', '    /// @param manufacturer is the token pool owner\n', '    /// @param deviceId of the device being updated\n', '    /// @return irnReward and manufacturerReward\n', '    function getReputationRewards(\n', '        address author,\n', '        address manufacturer,\n', '        bytes32 deviceId)\n', '        public view returns (uint256 irnReward, uint256 manufacturerReward)\n', '    {\n', '        uint256 lastWrite = authorWrites[author][deviceId];\n', '        uint256 blocks = 0;\n', '        if (lastWrite > 0) {\n', '            blocks = block.number.sub(lastWrite);\n', '        }\n', '        uint256 totalRewards = calculateReward(pools[manufacturer].rewardAmount, blocks);\n', '        irnReward = totalRewards.mul(settings.reputationIRNNodeShare()).div(100);\n', '        manufacturerReward = totalRewards.sub(irnReward);\n', '    }\n', '\n', '    /// @notice computes total reward based on the authors last submission\n', '    /// @param rewardAmount total amount available for reward\n', '    /// @param blocksSinceLastWrite number of blocks since last write\n', '    /// @return actual reward available\n', '    function calculateReward(uint256 rewardAmount, uint256 blocksSinceLastWrite) public view returns (uint256) {\n', '        uint256 totalReward = rewardAmount;\n', '        uint256 blockThreshold = settings.blockThreshold();\n', '        if (blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold) {\n', '            uint256 multiplier = 10 ** uint256(token.decimals());\n', '            totalReward = rewardAmount.mul(blocksSinceLastWrite.mul(multiplier)).div(blockThreshold.mul(multiplier));\n', '        }\n', '        return totalReward;\n', '    }\n', '\n', '    ///\n', '    /// BULK OPERATIONS\n', '    ///\n', '    /// @notice registers multiple devices on the Atonomi network\n', '    /// @param _deviceIdHashes array of keccak256 hashed ID&#39;s of each device\n', '    /// @param _deviceTypes array of types of device categorized by the manufacturer\n', '    /// @param _devicePublicKeys array of public keys associated with the devices\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerDevices(\n', '        bytes32[] _deviceIdHashes,\n', '        bytes32[] _deviceTypes,\n', '        bytes32[] _devicePublicKeys)\n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        require(_deviceIdHashes.length > 0, "at least one device is required");\n', '        require(\n', '            _deviceIdHashes.length == _deviceTypes.length,\n', '            "device type array needs to be same size as devices"\n', '        );\n', '        require(\n', '            _deviceIdHashes.length == _devicePublicKeys.length,\n', '            "device public key array needs to be same size as devices"\n', '        );\n', '\n', '        uint256 runningBalance = 0;\n', '        uint256 registrationFee = settings.registrationFee();\n', '        for (uint256 i = 0; i < _deviceIdHashes.length; i++) {\n', '            bytes32 deviceIdHash = _deviceIdHashes[i];\n', '            bytes32 deviceType = _deviceTypes[i];\n', '            bytes32 devicePublicKey = _devicePublicKeys[i];\n', '            Device memory d = _registerDevice(msg.sender, deviceIdHash, deviceType, devicePublicKey);\n', '            emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, d.manufacturerId, deviceType);\n', '\n', '            runningBalance = runningBalance.add(registrationFee);\n', '        }\n', '\n', '        _depositTokens(msg.sender, runningBalance);\n', '        require(token.transferFrom(msg.sender, address(this), runningBalance), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// WHITELIST PARTICIPANT MANAGEMENT\n', '    ///\n', '    /// @notice add a member to the network\n', '    /// @param _member ethereum address of member to be added\n', '    /// @param _isIRNAdmin true if an irn admin, otherwise false\n', '    /// @param _isManufacturer true if an manufactuter, otherwise false\n', '    /// @param _memberId manufacturer id for manufacturers, otherwise 0x0\n', '    /// @return true if successful, otherwise false\n', '    /// @dev _memberId is only relevant for manufacturer, but is flexible to allow use for other purposes\n', '    /// @dev msg.sender is expected to be either owner or irn admin\n', '    function addNetworkMember(\n', '        address _member,\n', '        bool _isIRNAdmin,\n', '        bool _isManufacturer,\n', '        bool _isIRNNode,\n', '        bytes32 _memberId)\n', '        public onlyIRNorOwner returns(bool)\n', '    {\n', '        NetworkMember storage m = network[_member];\n', '        require(!m.isIRNAdmin, "already an irn admin");\n', '        require(!m.isManufacturer, "already a manufacturer");\n', '        require(!m.isIRNNode, "already an irn node");\n', '        require(m.memberId == 0, "already assigned a member id");\n', '\n', '        m.isIRNAdmin = _isIRNAdmin;\n', '        m.isManufacturer = _isManufacturer;\n', '        m.isIRNNode = _isIRNNode;\n', '        m.memberId = _memberId;\n', '\n', '        if (m.isManufacturer) {\n', '            require(_memberId != 0, "manufacturer id is required");\n', '\n', '            // keep lookup for rewards in sync\n', '            require(manufacturerRewards[m.memberId] == address(0), "manufacturer is already assigned");\n', '            manufacturerRewards[m.memberId] = _member;\n', '\n', '            // set reputation reward if token pool doesnt exist\n', '            if (pools[_member].rewardAmount == 0) {\n', '                pools[_member].rewardAmount = settings.defaultReputationReward();\n', '            }\n', '        }\n', '\n', '        emit NetworkMemberAdded(msg.sender, _member, _memberId);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice remove a member from the network\n', '    /// @param _member ethereum address of member to be removed\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be either owner or irn admin\n', '    function removeNetworkMember(address _member) public onlyIRNorOwner returns(bool) {\n', '        bytes32 memberId = network[_member].memberId;\n', '        if (network[_member].isManufacturer) {\n', '            // remove token pool if there is a zero balance\n', '            if (pools[_member].balance == 0) {\n', '                delete pools[_member];\n', '            }\n', '\n', '            // keep lookup with rewards in sync\n', '            delete manufacturerRewards[memberId];\n', '        }\n', '\n', '        delete network[_member];\n', '\n', '        emit NetworkMemberRemoved(msg.sender, _member, memberId);\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // TOKEN POOL MANAGEMENT\n', '    //\n', '    /// @notice changes the ethereum wallet for a manufacturer used in reputation rewards\n', '    /// @param _new new ethereum account\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be original manufacturer account\n', '    function changeManufacturerWallet(address _new) public onlyManufacturer returns (bool) {\n', '        require(_new != address(0), "new address cannot be 0x0");\n', '\n', '        NetworkMember memory old = network[msg.sender];\n', '        require(old.isManufacturer && old.memberId != 0, "must be a manufacturer");\n', '\n', '        // copy permissions\n', '        require(!network[_new].isIRNAdmin, "already an irn admin");\n', '        require(!network[_new].isManufacturer, "already a manufacturer");\n', '        require(!network[_new].isIRNNode, "already an irn node");\n', '        require(network[_new].memberId == 0, "memberId already exists");\n', '        network[_new] = NetworkMember(\n', '            old.isIRNAdmin,\n', '            old.isManufacturer,\n', '            old.isIRNNode,\n', '            old.memberId\n', '        );\n', '\n', '        // transfer balance from old pool to the new pool\n', '        require(pools[_new].balance == 0 && pools[_new].rewardAmount == 0, "new token pool already exists");\n', '        pools[_new].balance = pools[msg.sender].balance;\n', '        pools[_new].rewardAmount = pools[msg.sender].rewardAmount;\n', '        delete pools[msg.sender];\n', '\n', '        // update reward mapping\n', '        manufacturerRewards[old.memberId] = _new;\n', '\n', '        // delete old member\n', '        delete network[msg.sender];\n', '\n', '        emit ManufacturerRewardWalletChanged(msg.sender, _new, old.memberId);\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows a token pool owner to set a new reward amount\n', '    /// @param newReward new reputation reward amount\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender expected to be manufacturer\n', '    function setTokenPoolReward(uint256 newReward) public onlyManufacturer returns (bool) {\n', '        require(newReward != 0, "newReward is required");\n', '\n', '        TokenPool storage p = pools[msg.sender];\n', '        require(p.rewardAmount != newReward, "newReward should be different");\n', '\n', '        p.rewardAmount = newReward;\n', '        emit TokenPoolRewardUpdated(msg.sender, newReward);\n', '        return true;\n', '    }\n', '\n', '    /// @notice anyone can donate tokens to a manufacturer&#39;s pool\n', '    /// @param manufacturerId of the manufacturer to receive the tokens\n', '    /// @param amount of tokens to deposit\n', '    function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) {\n', '        require(manufacturerId != 0, "manufacturerId is required");\n', '        require(amount > 0, "amount is required");\n', '\n', '        address manufacturer = manufacturerRewards[manufacturerId];\n', '        require(manufacturer != address(0));\n', '\n', '        _depositTokens(manufacturer, amount);\n', '        emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount);\n', '\n', '        require(token.transferFrom(msg.sender, address(this), amount));\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows participants in the Atonomi network to claim their rewards\n', '    /// @return true if successful, otherwise false\n', '    /// @dev owner has ability to pause this operation\n', '    function withdrawTokens() public whenNotPaused returns (bool) {\n', '        uint256 amount = rewards[msg.sender];\n', '        require(amount > 0, "amount is zero");\n', '\n', '        rewards[msg.sender] = 0;\n', '        emit TokensWithdrawn(msg.sender, amount);\n', '\n', '        require(token.transfer(msg.sender, amount), "token transfer failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows the owner to change the default reputation for manufacturers\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _newDefaultScore to use for newly registered devices\n', '    /// @return true if successful, otherwise false\n', '    /// @dev owner is the only one with this feature\n', '    function setDefaultReputationForManufacturer(\n', '        bytes32 _manufacturerId,\n', '        bytes32 _newDefaultScore) public onlyOwner returns (bool) {\n', '        require(_manufacturerId != 0, "_manufacturerId is required");\n', '        require(\n', '            _newDefaultScore != defaultManufacturerReputations[_manufacturerId],\n', '            "_newDefaultScore should be different"\n', '        );\n', '\n', '        defaultManufacturerReputations[_manufacturerId] = _newDefaultScore;\n', '        emit DefaultReputationScoreChanged(msg.sender, _manufacturerId, _newDefaultScore);\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// INTERNAL FUNCTIONS\n', '    ///\n', '    /// @dev track balances of any deposits going into a token pool\n', '    function _depositTokens(address _owner, uint256 _amount) internal {\n', '        pools[_owner].balance = pools[_owner].balance.add(_amount);\n', '    }\n', '\n', '    /// @dev track balances of any rewards going out of the token pool\n', '    function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal {\n', '        require(_amount > 0, "_amount is required");\n', '        pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount);\n', '        rewards[_owner] = rewards[_owner].add(_amount);\n', '    }\n', '\n', '    /// @dev ensure a device is validated for registration\n', '    /// @dev updates device registry\n', '    function _registerDevice(\n', '        address _manufacturer,\n', '        bytes32 _deviceIdHash,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey) internal returns (Device) {\n', '        require(_manufacturer != address(0), "manufacturer is required");\n', '        require(_deviceIdHash != 0, "device id hash is required");\n', '        require(_deviceType != 0, "device type is required");\n', '        require(_devicePublicKey != 0, "device public key is required");\n', '\n', '        Device storage d = devices[_deviceIdHash];\n', '        require(!d.registered, "device is already registered");\n', '        require(!d.activated, "device is already activated");\n', '\n', '        bytes32 manufacturerId = network[_manufacturer].memberId;\n', '        require(manufacturerId != 0, "manufacturer id is unknown");\n', '\n', '        d.manufacturerId = manufacturerId;\n', '        d.deviceType = _deviceType;\n', '        d.registered = true;\n', '        d.activated = false;\n', '        d.reputationScore = defaultManufacturerReputations[manufacturerId];\n', '        d.devicePublicKey = _devicePublicKey;\n', '        return d;\n', '    }\n', '\n', '    /// @dev ensure a device is validated for activation\n', '    /// @dev updates device registry\n', '    function _activateDevice(bytes32 _deviceId) internal returns (Device) {\n', '        bytes32 deviceIdHash = keccak256(_deviceId);\n', '        Device storage d = devices[deviceIdHash];\n', '        require(d.registered, "not registered");\n', '        require(!d.activated, "already activated");\n', '        require(d.manufacturerId != 0, "no manufacturer id was found");\n', '\n', '        d.activated = true;\n', '        return d;\n', '    }\n', '\n', '    /// @dev ensure a device is validated for a new reputation score\n', '    /// @dev updates device registry\n', '    function _updateReputationScore(bytes32 _deviceId, bytes32 _reputationScore) internal returns (Device) {\n', '        require(_deviceId != 0, "device id is empty");\n', '\n', '        Device storage d = devices[keccak256(_deviceId)];\n', '        require(d.registered, "not registered");\n', '        require(d.activated, "not activated");\n', '        require(d.reputationScore != _reputationScore, "new score needs to be different");\n', '\n', '        d.reputationScore = _reputationScore;\n', '        return d;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/TokenDestructible.sol\n', '\n', '/**\n', ' * @title TokenDestructible:\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract including\n', ' * listed tokens will be sent to the owner.\n', ' */\n', 'contract TokenDestructible is Ownable {\n', '\n', '  function TokenDestructible() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\n', '   refund.\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy(address[] tokens) onlyOwner public {\n', '\n', '    // Transfer tokens to owner\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      ERC20Basic token = ERC20Basic(tokens[i]);\n', '      uint256 balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '    }\n', '\n', '    // Transfer Eth to owner and terminate contract\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', '// File: contracts/Atonomi.sol\n', '\n', '// solhint-disable-line\n', '\n', '\n', '\n', '\n', '/// @title ERC-20 Token Standard\n', '/// @author Fabian Vogelsteller <fabian@ethereum.org>, Vitalik Buterin <vitalik.buterin@ethereum.org>\n', '/// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'interface ERC20Interface {\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);   // solhint-disable-line\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '/// @title Safe Math library\n', '/// @dev Math operations with safety checks that throw on error\n', '/// @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '    /// @dev Multiplies two numbers, throws on overflow.\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /// @dev Integer division of two numbers, truncating the quotient.\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /// @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Adds two numbers, throws on overflow.\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/// @dev Interface for the Network Settings contract\n', 'interface SettingsInterface {\n', '    function registrationFee() external view returns (uint256);\n', '    function activationFee() external view returns (uint256);\n', '    function defaultReputationReward() external view returns (uint256);\n', '    function reputationIRNNodeShare() external view returns (uint256);\n', '    function blockThreshold() external view returns (uint256);\n', '}\n', '\n', '\n', '/// @title Atonomi Smart Contract\n', '/// @author Atonomi\n', '/// @notice Governs the activation, registration, and reputation of devices on the Atonomi network\n', '/// @dev Ownable: Owner governs the access of Atonomi Admins, Fees, and Rewards on the network\n', '/// @dev Pausable: Gives ability for Owner to pull emergency stop to prevent actions on the network\n', '/// @dev TokenDestructible: Gives owner ability to kill the contract and extract funds to a new contract\n', 'contract Atonomi is Pausable, TokenDestructible {\n', '    using SafeMath for uint256;\n', '\n', '    /// @title ATMI Token\n', '    /// @notice Standard ERC20 Token\n', '    /// @dev AMLToken source: https://github.com/TokenMarketNet/ico/blob/master/contracts/AMLToken.sol\n', '    ERC20Interface public token;\n', '\n', '    /// @title Network Settings\n', '    /// @notice Atonomi Owner controlled settings are governed in this contract\n', '    SettingsInterface public settings;\n', '\n', '    ///\n', '    /// STORAGE MAPPINGS \n', '    ///\n', '    /// @title Atonomi Devices registry\n', '    /// @notice Contains all devices participating in the Atonomi Network\n', '    /// @dev Key is a keccak256 hash of the device id\n', '    /// @dev Value is a struct that contains the device status and metadata\n', '    mapping (bytes32 => Device) public devices;\n', '\n', '    /// @title Atonomi Participant whitelist\n', '    /// @notice Contains all the network participants\n', '    /// @dev Atonomi Admins: Govern the access to manufacturers and IRN Nodes on the network\n', '    /// @dev IRN Nodes: Governs reputation score data of devices\n', '    /// @dev Manufacturers: Governs devices on the network\n', '    /// @dev Key is ethereum account of the participant\n', '    /// @dev Value is a struct that contains the role of the participant\n', '    mapping (address => NetworkMember) public network;\n', '\n', '    /// @title Token Pools\n', '    /// @notice each manufacturer will manage a pool of tokens for reputation rewards\n', '    /// @dev Key is ethereum account for pool owner\n', '    /// @dev Value is struct representing token pool attributes\n', '    /// @dev incoming tokens will come from registrations, activations, or public donations\n', '    /// @dev outgoing tokens will come from reputation rewards\n', '    mapping (address => TokenPool) public pools;\n', '\n', '    /// @title Reward Balances\n', '    /// @notice balances of rewards that are able to be claimed by participants\n', '    /// @dev Key is ethereum account of the owner of the tokens\n', '    /// @dev Value is tokens available for withdraw\n', '    mapping (address => uint256) public rewards;\n', '\n', '    /// @title Lookup by Manufacturer ID the wallet for reputation rewards\n', '    /// @dev Key is the manufacturer id\n', '    /// @dev Value is ethereum account to be rewarded\n', '    mapping (bytes32 => address) public manufacturerRewards;\n', '\n', '    /// @title Track last write by reputation author\n', '    /// @dev First key is the ethereum address of the reputation author\n', '    /// @dev Second key is the device id\n', '    /// @dev Value is the block number of the last time the author has submitted a score for the device\n', '    mapping (address => mapping (bytes32 => uint256)) public authorWrites;\n', '\n', '    /// @title Default Repuration score for manufacturers\n', '    /// @dev Key is the manufacturer id\n', '    /// @dev value is the score to use for newly registered devices\n', '    mapping (bytes32 => bytes32) public defaultManufacturerReputations;\n', '\n', '    ///\n', '    /// TYPES \n', '    ///\n', '    /// @title Atonomi Device\n', '    /// @notice Contains the device state on the Atonomi network\n', '    /// @dev manufacturerId is the manufacturer the device belongs to\n', '    /// @dev deviceType is the type of device categorized by the manufacturer\n', '    /// @dev registered is true when device is registered, otherwise false\n', '    /// @dev activated is true when device is activated, otherwise false\n', '    /// @dev reputationScore is official Atonomi Reputation score for the device\n', '    /// @dev devicePublicKey is public key used by IRN Nodes for validation\n', '    struct Device {\n', '        bytes32 manufacturerId;\n', '        bytes32 deviceType;\n', '        bool registered;\n', '        bool activated;\n', '        bytes32 reputationScore;\n', '        bytes32 devicePublicKey;\n', '    }\n', '\n', '    /// @title Token Pool\n', '    /// @notice Contains balance and reputation reward amounts for each token pool\n', '    /// @dev balance is total amount of tokens available in the pool\n', '    /// @dev rewardAmount is the total amount distributed between the manufacturer and reputation author\n', '    struct TokenPool {\n', '        uint256 balance;\n', '        uint256 rewardAmount;\n', '    }\n', '\n', '    /// @title Atonomi Network Participant\n', '    /// @notice Contains role information for a participant\n', '    /// @dev isIRNAdmin is true if participant is an IRN Admin, otherwise false\n', '    /// @dev isManufacturer is true if participant is a Manufacturer, otherwise false\n', '    /// @dev isIRNNode is true if participant is an IRN Node, otherwise false\n', '    /// @dev memberId is the manufacturer id, for all other participants this will be 0\n', '    struct NetworkMember {\n', '        bool isIRNAdmin;\n', '        bool isManufacturer;\n', '        bool isIRNNode;\n', '        bytes32 memberId;\n', '    }\n', '\n', '    ///\n', '    /// MODIFIERS\n', '    ///\n', '    /// @notice only manufacturers can call, otherwise throw\n', '    modifier onlyManufacturer() {\n', '        require(network[msg.sender].isManufacturer, "must be a manufacturer");\n', '        _;\n', '    }\n', '\n', '    /// @notice only IRNAdmins or Owner can call, otherwise throw\n', '    modifier onlyIRNorOwner() {\n', '        require(msg.sender == owner || network[msg.sender].isIRNAdmin, "must be owner or an irn admin");\n', '        _;\n', '    }\n', '\n', '    /// @notice only IRN Nodes can call, otherwise throw\n', '    modifier onlyIRNNode() {\n', '        require(network[msg.sender].isIRNNode, "must be an irn node");\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor sets the ERC Token contract and initial values for network fees\n', '    /// @param _token is the Atonomi Token contract address (must be ERC20)\n', '    /// @param _settings is the Atonomi Network Settings contract address\n', '    constructor (\n', '        address _token,\n', '        address _settings) public {\n', '        require(_token != address(0), "token address cannot be 0x0");\n', '        require(_settings != address(0), "settings address cannot be 0x0");\n', '        token = ERC20Interface(_token);\n', '        settings = SettingsInterface(_settings);\n', '    }\n', '\n', '    ///\n', '    /// EVENTS \n', '    ///\n', '    /// @notice emitted on successful device registration\n', '    /// @param _sender manufacturer paying for registration\n', '    /// @param _fee registration fee paid by manufacturer\n', '    /// @param _deviceHashKey keccak256 hash of device id used as the key in devices mapping\n', '    /// @param _manufacturerId of the manufacturer the device belongs to\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    event DeviceRegistered(\n', '        address indexed _sender,\n', '        uint256 _fee,\n', '        bytes32 indexed _deviceHashKey,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _deviceType\n', '    );\n', '\n', '    /// @notice emitted on successful device activation\n', '    /// @param _sender manufacturer or device owner paying for activation\n', '    /// @param _fee registration fee paid by manufacturer\n', '    /// @param _deviceId the real device id (only revealed after activation)\n', '    /// @param _manufacturerId of the manufacturer the device belongs to\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    event DeviceActivated(\n', '        address indexed _sender,\n', '        uint256 _fee,\n', '        bytes32 indexed _deviceId,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _deviceType\n', '    );\n', '\n', '    /// @notice emitted on reputation change for a device\n', '    /// @param _deviceId device id of the target device\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @param _newScore updated reputation score\n', '    /// @param _irnNode IRN node submitting the new reputation\n', '    /// @param _irnReward tokens awarded to irn node\n', '    /// @param _manufacturerWallet manufacturer associated with the device is rewared a share of tokens\n', '    /// @param _manufacturerReward tokens awarded to contributor\n', '    event ReputationScoreUpdated(\n', '        bytes32 indexed _deviceId,\n', '        bytes32 _deviceType,\n', '        bytes32 _newScore,\n', '        address indexed _irnNode,\n', '        uint256 _irnReward,\n', '        address indexed _manufacturerWallet,\n', '        uint256 _manufacturerReward\n', '    );\n', '\n', '    /// @notice emitted on successful addition of network member address\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _member address of added member\n', '    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\n', '    event NetworkMemberAdded(\n', '        address indexed _sender,\n', '        address indexed _member,\n', '        bytes32 indexed _memberId\n', '    );\n', '\n', '    /// @notice emitted on successful removal of network member address\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _member address of removed member\n', '    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\n', '    event NetworkMemberRemoved(\n', '        address indexed _sender,\n', '        address indexed _member,\n', '        bytes32 indexed _memberId\n', '    );\n', '\n', '    /// @notice emitted everytime a manufacturer changes their wallet for rewards\n', '    /// @param _old ethereum account\n', '    /// @param _new ethereum account\n', '    /// @param _manufacturerId that the member belongs to\n', '    event ManufacturerRewardWalletChanged(\n', '        address indexed _old,\n', '        address indexed _new,\n', '        bytes32 indexed _manufacturerId\n', '    );\n', '\n', '    /// @notice emitted everytime a token pool reward amount changes\n', '    /// @param _sender ethereum account of the token pool owner\n', '    /// @param _newReward new reward value in ATMI tokens\n', '    event TokenPoolRewardUpdated(\n', '        address indexed _sender,\n', '        uint256 _newReward\n', '    );\n', '\n', '    /// @notice emitted everytime someone donates tokens to a manufacturer\n', '    /// @param _sender ethereum account of the donater\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _manufacturer ethereum account\n', '    /// @param _amount of tokens deposited\n', '    event TokensDeposited(\n', '        address indexed _sender,\n', '        bytes32 indexed _manufacturerId,\n', '        address indexed _manufacturer,\n', '        uint256 _amount\n', '    );\n', '    \n', '    /// @notice emitted everytime a participant withdraws from token pool\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _amount tokens withdrawn\n', '    event TokensWithdrawn(\n', '        address indexed _sender,\n', '        uint256 _amount\n', '    );\n', '\n', '    /// @notice emitted everytime the default reputation for a manufacturer changes\n', '    /// @param _sender ethereum account of participant that made the change\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _newDefaultScore to use for newly registered devices\n', '    event DefaultReputationScoreChanged(\n', '        address indexed _sender,\n', '        bytes32 indexed _manufacturerId,\n', '        bytes32 _newDefaultScore\n', '    );\n', '\n', '    ///\n', '    /// DEVICE ONBOARDING\n', '    ///\n', '    /// @notice registers device on the Atonomi network\n', "    /// @param _deviceIdHash keccak256 hash of the device's id (needs to be hashed by caller)\n", '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @dev devicePublicKey is public key used by IRN Nodes for validation\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerDevice(\n', '        bytes32 _deviceIdHash,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey)\n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        uint256 registrationFee = settings.registrationFee();\n', '        Device memory d = _registerDevice(msg.sender, _deviceIdHash, _deviceType, _devicePublicKey);\n', '        emit DeviceRegistered(\n', '            msg.sender,\n', '            registrationFee,\n', '            _deviceIdHash,\n', '            d.manufacturerId,\n', '            _deviceType);\n', '        _depositTokens(msg.sender, registrationFee);\n', '        require(token.transferFrom(msg.sender, address(this), registrationFee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice Activates the device\n', '    /// @param _deviceId id of the real device id to be activated (not the hash of the device id)\n', '    /// @return true if successful, otherwise false\n', '    /// @dev if the hash doesnt match, the device is considered not registered and will throw\n', '    /// @dev anyone with the device id (in hand) is considered the device owner\n', '    /// @dev tokens will be deducted from the device owner and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function activateDevice(bytes32 _deviceId) public whenNotPaused returns (bool) {\n', '        uint256 activationFee = settings.activationFee();\n', '        Device memory d = _activateDevice(_deviceId);\n', '        emit DeviceActivated(msg.sender, activationFee, _deviceId, d.manufacturerId, d.deviceType);\n', '        address manufacturer = manufacturerRewards[d.manufacturerId];\n', '        require(manufacturer != address(this), "manufacturer is unknown");\n', '        _depositTokens(manufacturer, activationFee);\n', '        require(token.transferFrom(msg.sender, address(this), activationFee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice Registers and immediately activates device, used by manufacturers to prepay activation\n', '    /// @param _deviceId id of the real device id to be activated (not the has of the device id)\n', '    /// @param _deviceType is the type of device categorized by the manufacturer\n', '    /// @return true if successful, otherwise false\n', '    /// @dev since the manufacturer is trusted, no need for the caller to hash the device id\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerAndActivateDevice(\n', '        bytes32 _deviceId,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey) \n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        uint256 registrationFee = settings.registrationFee();\n', '        uint256 activationFee = settings.activationFee();\n', '\n', '        bytes32 deviceIdHash = keccak256(_deviceId);\n', '        Device memory d = _registerDevice(msg.sender, deviceIdHash, _deviceType, _devicePublicKey);\n', '        bytes32 manufacturerId = d.manufacturerId;\n', '        emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, manufacturerId, _deviceType);\n', '\n', '        d = _activateDevice(_deviceId);\n', '        emit DeviceActivated(msg.sender, activationFee, _deviceId, manufacturerId, _deviceType);\n', '\n', '        uint256 fee = registrationFee.add(activationFee);\n', '        _depositTokens(msg.sender, fee);\n', '        require(token.transferFrom(msg.sender, address(this), fee), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// REPUTATION MANAGEMENT\n', '    ///\n', '    /// @notice updates reputation for a device\n', '    /// @param _deviceId target device Id\n', '    /// @param _reputationScore updated reputation score computed by the author\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the reputation author (either irn node or the reputation auditor)\n', '    /// @dev tokens will be deducted from the contract pool\n', '    /// @dev author and manufacturer will be rewarded a split of the tokens\n', '    /// @dev owner has ability to pause this operation\n', '    function updateReputationScore(\n', '        bytes32 _deviceId,\n', '        bytes32 _reputationScore)\n', '        public onlyIRNNode whenNotPaused returns (bool)\n', '    {\n', '        Device memory d = _updateReputationScore(_deviceId, _reputationScore);\n', '\n', '        address _manufacturerWallet = manufacturerRewards[d.manufacturerId];\n', '        require(_manufacturerWallet != address(0), "_manufacturerWallet cannot be 0x0");\n', '        require(_manufacturerWallet != msg.sender, "manufacturers cannot collect the full reward");\n', '\n', '        uint256 irnReward;\n', '        uint256 manufacturerReward;\n', '        (irnReward, manufacturerReward) = getReputationRewards(msg.sender, _manufacturerWallet, _deviceId);\n', '        _distributeRewards(_manufacturerWallet, msg.sender, irnReward);\n', '        _distributeRewards(_manufacturerWallet, _manufacturerWallet, manufacturerReward);\n', '        emit ReputationScoreUpdated(\n', '            _deviceId,\n', '            d.deviceType,\n', '            _reputationScore,\n', '            msg.sender,\n', '            irnReward,\n', '            _manufacturerWallet,\n', '            manufacturerReward);\n', '        authorWrites[msg.sender][_deviceId] = block.number;\n', '        return true;\n', '    }\n', '\n', '    /// @notice computes the portion of the reputation reward allotted to the manufacturer and author\n', '    /// @param author is the reputation node submitting the score\n', '    /// @param manufacturer is the token pool owner\n', '    /// @param deviceId of the device being updated\n', '    /// @return irnReward and manufacturerReward\n', '    function getReputationRewards(\n', '        address author,\n', '        address manufacturer,\n', '        bytes32 deviceId)\n', '        public view returns (uint256 irnReward, uint256 manufacturerReward)\n', '    {\n', '        uint256 lastWrite = authorWrites[author][deviceId];\n', '        uint256 blocks = 0;\n', '        if (lastWrite > 0) {\n', '            blocks = block.number.sub(lastWrite);\n', '        }\n', '        uint256 totalRewards = calculateReward(pools[manufacturer].rewardAmount, blocks);\n', '        irnReward = totalRewards.mul(settings.reputationIRNNodeShare()).div(100);\n', '        manufacturerReward = totalRewards.sub(irnReward);\n', '    }\n', '\n', '    /// @notice computes total reward based on the authors last submission\n', '    /// @param rewardAmount total amount available for reward\n', '    /// @param blocksSinceLastWrite number of blocks since last write\n', '    /// @return actual reward available\n', '    function calculateReward(uint256 rewardAmount, uint256 blocksSinceLastWrite) public view returns (uint256) {\n', '        uint256 totalReward = rewardAmount;\n', '        uint256 blockThreshold = settings.blockThreshold();\n', '        if (blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold) {\n', '            uint256 multiplier = 10 ** uint256(token.decimals());\n', '            totalReward = rewardAmount.mul(blocksSinceLastWrite.mul(multiplier)).div(blockThreshold.mul(multiplier));\n', '        }\n', '        return totalReward;\n', '    }\n', '\n', '    ///\n', '    /// BULK OPERATIONS\n', '    ///\n', '    /// @notice registers multiple devices on the Atonomi network\n', "    /// @param _deviceIdHashes array of keccak256 hashed ID's of each device\n", '    /// @param _deviceTypes array of types of device categorized by the manufacturer\n', '    /// @param _devicePublicKeys array of public keys associated with the devices\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be the manufacturer\n', '    /// @dev tokens will be deducted from the manufacturer and added to the token pool\n', '    /// @dev owner has ability to pause this operation\n', '    function registerDevices(\n', '        bytes32[] _deviceIdHashes,\n', '        bytes32[] _deviceTypes,\n', '        bytes32[] _devicePublicKeys)\n', '        public onlyManufacturer whenNotPaused returns (bool)\n', '    {\n', '        require(_deviceIdHashes.length > 0, "at least one device is required");\n', '        require(\n', '            _deviceIdHashes.length == _deviceTypes.length,\n', '            "device type array needs to be same size as devices"\n', '        );\n', '        require(\n', '            _deviceIdHashes.length == _devicePublicKeys.length,\n', '            "device public key array needs to be same size as devices"\n', '        );\n', '\n', '        uint256 runningBalance = 0;\n', '        uint256 registrationFee = settings.registrationFee();\n', '        for (uint256 i = 0; i < _deviceIdHashes.length; i++) {\n', '            bytes32 deviceIdHash = _deviceIdHashes[i];\n', '            bytes32 deviceType = _deviceTypes[i];\n', '            bytes32 devicePublicKey = _devicePublicKeys[i];\n', '            Device memory d = _registerDevice(msg.sender, deviceIdHash, deviceType, devicePublicKey);\n', '            emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, d.manufacturerId, deviceType);\n', '\n', '            runningBalance = runningBalance.add(registrationFee);\n', '        }\n', '\n', '        _depositTokens(msg.sender, runningBalance);\n', '        require(token.transferFrom(msg.sender, address(this), runningBalance), "transferFrom failed");\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// WHITELIST PARTICIPANT MANAGEMENT\n', '    ///\n', '    /// @notice add a member to the network\n', '    /// @param _member ethereum address of member to be added\n', '    /// @param _isIRNAdmin true if an irn admin, otherwise false\n', '    /// @param _isManufacturer true if an manufactuter, otherwise false\n', '    /// @param _memberId manufacturer id for manufacturers, otherwise 0x0\n', '    /// @return true if successful, otherwise false\n', '    /// @dev _memberId is only relevant for manufacturer, but is flexible to allow use for other purposes\n', '    /// @dev msg.sender is expected to be either owner or irn admin\n', '    function addNetworkMember(\n', '        address _member,\n', '        bool _isIRNAdmin,\n', '        bool _isManufacturer,\n', '        bool _isIRNNode,\n', '        bytes32 _memberId)\n', '        public onlyIRNorOwner returns(bool)\n', '    {\n', '        NetworkMember storage m = network[_member];\n', '        require(!m.isIRNAdmin, "already an irn admin");\n', '        require(!m.isManufacturer, "already a manufacturer");\n', '        require(!m.isIRNNode, "already an irn node");\n', '        require(m.memberId == 0, "already assigned a member id");\n', '\n', '        m.isIRNAdmin = _isIRNAdmin;\n', '        m.isManufacturer = _isManufacturer;\n', '        m.isIRNNode = _isIRNNode;\n', '        m.memberId = _memberId;\n', '\n', '        if (m.isManufacturer) {\n', '            require(_memberId != 0, "manufacturer id is required");\n', '\n', '            // keep lookup for rewards in sync\n', '            require(manufacturerRewards[m.memberId] == address(0), "manufacturer is already assigned");\n', '            manufacturerRewards[m.memberId] = _member;\n', '\n', '            // set reputation reward if token pool doesnt exist\n', '            if (pools[_member].rewardAmount == 0) {\n', '                pools[_member].rewardAmount = settings.defaultReputationReward();\n', '            }\n', '        }\n', '\n', '        emit NetworkMemberAdded(msg.sender, _member, _memberId);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice remove a member from the network\n', '    /// @param _member ethereum address of member to be removed\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be either owner or irn admin\n', '    function removeNetworkMember(address _member) public onlyIRNorOwner returns(bool) {\n', '        bytes32 memberId = network[_member].memberId;\n', '        if (network[_member].isManufacturer) {\n', '            // remove token pool if there is a zero balance\n', '            if (pools[_member].balance == 0) {\n', '                delete pools[_member];\n', '            }\n', '\n', '            // keep lookup with rewards in sync\n', '            delete manufacturerRewards[memberId];\n', '        }\n', '\n', '        delete network[_member];\n', '\n', '        emit NetworkMemberRemoved(msg.sender, _member, memberId);\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // TOKEN POOL MANAGEMENT\n', '    //\n', '    /// @notice changes the ethereum wallet for a manufacturer used in reputation rewards\n', '    /// @param _new new ethereum account\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender is expected to be original manufacturer account\n', '    function changeManufacturerWallet(address _new) public onlyManufacturer returns (bool) {\n', '        require(_new != address(0), "new address cannot be 0x0");\n', '\n', '        NetworkMember memory old = network[msg.sender];\n', '        require(old.isManufacturer && old.memberId != 0, "must be a manufacturer");\n', '\n', '        // copy permissions\n', '        require(!network[_new].isIRNAdmin, "already an irn admin");\n', '        require(!network[_new].isManufacturer, "already a manufacturer");\n', '        require(!network[_new].isIRNNode, "already an irn node");\n', '        require(network[_new].memberId == 0, "memberId already exists");\n', '        network[_new] = NetworkMember(\n', '            old.isIRNAdmin,\n', '            old.isManufacturer,\n', '            old.isIRNNode,\n', '            old.memberId\n', '        );\n', '\n', '        // transfer balance from old pool to the new pool\n', '        require(pools[_new].balance == 0 && pools[_new].rewardAmount == 0, "new token pool already exists");\n', '        pools[_new].balance = pools[msg.sender].balance;\n', '        pools[_new].rewardAmount = pools[msg.sender].rewardAmount;\n', '        delete pools[msg.sender];\n', '\n', '        // update reward mapping\n', '        manufacturerRewards[old.memberId] = _new;\n', '\n', '        // delete old member\n', '        delete network[msg.sender];\n', '\n', '        emit ManufacturerRewardWalletChanged(msg.sender, _new, old.memberId);\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows a token pool owner to set a new reward amount\n', '    /// @param newReward new reputation reward amount\n', '    /// @return true if successful, otherwise false\n', '    /// @dev msg.sender expected to be manufacturer\n', '    function setTokenPoolReward(uint256 newReward) public onlyManufacturer returns (bool) {\n', '        require(newReward != 0, "newReward is required");\n', '\n', '        TokenPool storage p = pools[msg.sender];\n', '        require(p.rewardAmount != newReward, "newReward should be different");\n', '\n', '        p.rewardAmount = newReward;\n', '        emit TokenPoolRewardUpdated(msg.sender, newReward);\n', '        return true;\n', '    }\n', '\n', "    /// @notice anyone can donate tokens to a manufacturer's pool\n", '    /// @param manufacturerId of the manufacturer to receive the tokens\n', '    /// @param amount of tokens to deposit\n', '    function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) {\n', '        require(manufacturerId != 0, "manufacturerId is required");\n', '        require(amount > 0, "amount is required");\n', '\n', '        address manufacturer = manufacturerRewards[manufacturerId];\n', '        require(manufacturer != address(0));\n', '\n', '        _depositTokens(manufacturer, amount);\n', '        emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount);\n', '\n', '        require(token.transferFrom(msg.sender, address(this), amount));\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows participants in the Atonomi network to claim their rewards\n', '    /// @return true if successful, otherwise false\n', '    /// @dev owner has ability to pause this operation\n', '    function withdrawTokens() public whenNotPaused returns (bool) {\n', '        uint256 amount = rewards[msg.sender];\n', '        require(amount > 0, "amount is zero");\n', '\n', '        rewards[msg.sender] = 0;\n', '        emit TokensWithdrawn(msg.sender, amount);\n', '\n', '        require(token.transfer(msg.sender, amount), "token transfer failed");\n', '        return true;\n', '    }\n', '\n', '    /// @notice allows the owner to change the default reputation for manufacturers\n', '    /// @param _manufacturerId of the manufacturer\n', '    /// @param _newDefaultScore to use for newly registered devices\n', '    /// @return true if successful, otherwise false\n', '    /// @dev owner is the only one with this feature\n', '    function setDefaultReputationForManufacturer(\n', '        bytes32 _manufacturerId,\n', '        bytes32 _newDefaultScore) public onlyOwner returns (bool) {\n', '        require(_manufacturerId != 0, "_manufacturerId is required");\n', '        require(\n', '            _newDefaultScore != defaultManufacturerReputations[_manufacturerId],\n', '            "_newDefaultScore should be different"\n', '        );\n', '\n', '        defaultManufacturerReputations[_manufacturerId] = _newDefaultScore;\n', '        emit DefaultReputationScoreChanged(msg.sender, _manufacturerId, _newDefaultScore);\n', '        return true;\n', '    }\n', '\n', '    ///\n', '    /// INTERNAL FUNCTIONS\n', '    ///\n', '    /// @dev track balances of any deposits going into a token pool\n', '    function _depositTokens(address _owner, uint256 _amount) internal {\n', '        pools[_owner].balance = pools[_owner].balance.add(_amount);\n', '    }\n', '\n', '    /// @dev track balances of any rewards going out of the token pool\n', '    function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal {\n', '        require(_amount > 0, "_amount is required");\n', '        pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount);\n', '        rewards[_owner] = rewards[_owner].add(_amount);\n', '    }\n', '\n', '    /// @dev ensure a device is validated for registration\n', '    /// @dev updates device registry\n', '    function _registerDevice(\n', '        address _manufacturer,\n', '        bytes32 _deviceIdHash,\n', '        bytes32 _deviceType,\n', '        bytes32 _devicePublicKey) internal returns (Device) {\n', '        require(_manufacturer != address(0), "manufacturer is required");\n', '        require(_deviceIdHash != 0, "device id hash is required");\n', '        require(_deviceType != 0, "device type is required");\n', '        require(_devicePublicKey != 0, "device public key is required");\n', '\n', '        Device storage d = devices[_deviceIdHash];\n', '        require(!d.registered, "device is already registered");\n', '        require(!d.activated, "device is already activated");\n', '\n', '        bytes32 manufacturerId = network[_manufacturer].memberId;\n', '        require(manufacturerId != 0, "manufacturer id is unknown");\n', '\n', '        d.manufacturerId = manufacturerId;\n', '        d.deviceType = _deviceType;\n', '        d.registered = true;\n', '        d.activated = false;\n', '        d.reputationScore = defaultManufacturerReputations[manufacturerId];\n', '        d.devicePublicKey = _devicePublicKey;\n', '        return d;\n', '    }\n', '\n', '    /// @dev ensure a device is validated for activation\n', '    /// @dev updates device registry\n', '    function _activateDevice(bytes32 _deviceId) internal returns (Device) {\n', '        bytes32 deviceIdHash = keccak256(_deviceId);\n', '        Device storage d = devices[deviceIdHash];\n', '        require(d.registered, "not registered");\n', '        require(!d.activated, "already activated");\n', '        require(d.manufacturerId != 0, "no manufacturer id was found");\n', '\n', '        d.activated = true;\n', '        return d;\n', '    }\n', '\n', '    /// @dev ensure a device is validated for a new reputation score\n', '    /// @dev updates device registry\n', '    function _updateReputationScore(bytes32 _deviceId, bytes32 _reputationScore) internal returns (Device) {\n', '        require(_deviceId != 0, "device id is empty");\n', '\n', '        Device storage d = devices[keccak256(_deviceId)];\n', '        require(d.registered, "not registered");\n', '        require(d.activated, "not activated");\n', '        require(d.reputationScore != _reputationScore, "new score needs to be different");\n', '\n', '        d.reputationScore = _reputationScore;\n', '        return d;\n', '    }\n', '}']
