['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library utils{\n', '    function inArray(uint[] _arr,uint _val) internal pure returns(bool){\n', '        for(uint _i=0;_i< _arr.length;_i++){\n', '            if(_arr[_i]==_val){\n', '                return true;\n', '                break;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function inArray(address[] _arr,address _val) internal pure returns(bool){\n', '        for(uint _i=0;_i< _arr.length;_i++){\n', '            if(_arr[_i]==_val){\n', '                return true;\n', '                break;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '      /**\n', '       * @dev Throws if called by any account other than the owner.\n', '       */\n', '      modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '      }\n', '  \n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract GuessEthEvents{\n', '    event drawLog(uint,uint,uint);\n', '\n', '    event guessEvt(\n', '        address indexed playerAddr,\n', '        uint[] numbers, uint amount\n', '        );\n', '    event winnersEvt(\n', '        uint blockNumber,\n', '        address indexed playerAddr,\n', '        uint amount,\n', '        uint winAmount\n', '        );\n', '    event withdrawEvt(\n', '        address indexed to,\n', '        uint256 value\n', '        );\n', '    event drawEvt(\n', '        uint indexed blocknumberr,\n', '        uint number\n', '        );\n', '    \n', '    event sponseEvt(\n', '        address indexed addr,\n', '        uint amount\n', '        );\n', '\n', '    event pauseGameEvt(\n', '        bool pause\n', '        );\n', '    event setOddsEvt(\n', '        uint odds\n', '        );\n', '  \n', '}\n', '\n', 'contract GuessEth is Ownable,GuessEthEvents{\n', '    using SafeMath for uint;\n', '\n', '    /* Player Bets */\n', '\n', '    struct bnumber{\n', '        address addr;\n', '        uint number;\n', '        uint value;\n', '        int8 result;\n', '        uint prize;\n', '    }\n', '    mapping(uint => bnumber[]) public bets;\n', '    mapping(uint => address) public betNumber;\n', '    \n', '    /* player address => blockNumber[]*/\n', '    mapping(address => uint[]) private playerBetBNumber;\n', '    \n', '    /* Awards Records */\n', '    struct winner{\n', '        bool result;\n', '        uint prize;\n', '    }\n', '    \n', '    mapping(uint => winner[]) private winners;\n', '    mapping(uint => uint) private winResult;\n', '    \n', '    address private wallet1;\n', '    address private wallet2;\n', '    \n', '    uint private predictBlockInterval=3;\n', '    uint public odds=30;\n', '    uint public blockInterval=500;\n', '    uint public curOpenBNumber=0;\n', '    uint public numberRange=100;\n', '\n', '    bool public gamePaused=false;\n', '    \n', '\n', '    /* Sponsors */\n', '    mapping(address => uint) Sponsors;\n', '    uint public balanceOfSPS=0;\n', '    address[] public SponsorAddresses;\n', '    \n', '    uint reservefund=30 ether;\n', '   \n', '  \n', '    /**\n', '    * @dev prevents contracts from interacting with fomo3d\n', '    */\n', '    modifier isHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '    \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    constructor(address _wallet1,address _wallet2) public{\n', '        wallet1=_wallet1;\n', '        wallet2=_wallet2;\n', '        \n', '        curOpenBNumber=blockInterval*(block.number.div(blockInterval));\n', '    }\n', '    \n', '    function pauseGame(bool _status) public onlyOwner returns(bool){\n', '            gamePaused=_status;\n', '            emit pauseGameEvt(_status);\n', '    }\n', '    \n', '    function setOdds(uint _odds) isHuman() public onlyOwner returns(bool){\n', '            odds = _odds;\n', '            emit setOddsEvt(_odds);\n', '    }\n', '    function setReservefund(uint _reservefund) isHuman() public onlyOwner returns(bool){\n', '            reservefund = _reservefund * 1 ether;\n', '    }\n', '    \n', '    function getTargetBNumber() view isHuman() public returns(uint){\n', '        uint n;\n', '        n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n', '        return n;\n', '    }\n', '    \n', '    function guess(uint[] _numbers) payable isHuman() public returns(uint){\n', '        require(msg.value  >= _numbers.length * 0.05 ether);\n', '\n', '        uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n', '        \n', '        for(uint _i=0;_i < _numbers.length;_i++){\n', '            bnumber memory b;\n', '            \n', '            b.addr=msg.sender;\n', '            b.number=_numbers[_i];\n', '            b.value=msg.value/_numbers.length;\n', '            b.result=-1;\n', '            \n', '            bets[n].push(b);\n', '        }\n', '        \n', '        \n', '        if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\n', '            playerBetBNumber[msg.sender].push(n);\n', '        }\n', '        \n', '        emit guessEvt(msg.sender,_numbers, msg.value);\n', '        \n', '        return _numbers.length;\n', '    }\n', '    \n', '\n', '    function getPlayerGuessNumbers() view public returns (uint[],uint[],uint256[],int8[],uint[]){\n', '        uint _c=0;\n', '        uint _i=0;\n', '        uint _j=0;\n', '        uint _bnumber;\n', '        uint limitRows=100;\n', '        \n', '        while(_i < playerBetBNumber[msg.sender].length){\n', '            _bnumber=playerBetBNumber[msg.sender][_i];\n', '            for(_j=0 ; _j < bets[_bnumber].length && _c < limitRows ; _j++){\n', '                if(msg.sender==bets[_bnumber][_j].addr){\n', '                    _c++;\n', '                }\n', '            }\n', '            _i++;\n', '        }\n', '\n', '        uint[] memory _blockNumbers=new uint[](_c);\n', '        uint[] memory _numbers=new uint[](_c);\n', '        uint[] memory _values=new uint[](_c);\n', '        int8[] memory _result=new int8[](_c);\n', '        uint[] memory _prize=new uint[](_c);\n', '        \n', '        if(_c<=0){\n', '            return(_blockNumbers,_numbers,_values,_result,_prize);\n', '        }\n', '\n', '        //uint[] memory _b=new uint[](bettings[_blocknumber].length);\n', '\n', '        uint _count=0;\n', '        for(_i=0 ; _i < playerBetBNumber[msg.sender].length ; _i++){\n', '            _bnumber=playerBetBNumber[msg.sender][_i];\n', '            \n', '            for(_j=0 ; _j < bets[_bnumber].length && _count < limitRows ; _j++){\n', '                if(bets[_bnumber][_j].addr == msg.sender){\n', '                    _blockNumbers[_count] = _bnumber;\n', '                    _numbers[_count] =  bets[_bnumber][_j].number;\n', '                    _values[_count] =  bets[_bnumber][_j].value;\n', '                    _result[_count] =  bets[_bnumber][_j].result;\n', '                    _prize[_count] =  bets[_bnumber][_j].prize;\n', '                    \n', '                    _count++;\n', '                }\n', '            }\n', '        }\n', '\n', '\n', '        return(_blockNumbers,_numbers,_values,_result,_prize);\n', '    }\n', '    \n', '\n', '    function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\n', '        require(block.number >= curOpenBNumber + blockInterval);\n', '\n', '        /*Set open Result*/\n', '        curOpenBNumber=_blockNumber;\n', '        uint result=_blockTimestamp % numberRange;\n', '        winResult[_blockNumber]=result;\n', '\n', '        for(uint _i=0;_i < bets[_blockNumber].length;_i++){\n', '            //result+=1;\n', '            \n', '            \n', '            if(bets[_blockNumber][_i].number==result){\n', '                bets[_blockNumber][_i].result = 1;\n', '                bets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\n', '                \n', '                emit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\n', '\n', '                withdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n', '\n', '            }else{\n', '                bets[_blockNumber][_i].result = 0;\n', '                bets[_blockNumber][_i].prize = 0;\n', '            }\n', '        }\n', '        \n', '        emit drawEvt(_blockNumber,curOpenBNumber);\n', '        \n', '        return result;\n', '    }\n', '    \n', '    function getWinners(uint _blockNumber) view public returns(address[],uint[]){\n', '        uint _count=winners[_blockNumber].length;\n', '        \n', '        address[] memory _addresses = new address[](_count);\n', '        uint[] memory _prize = new uint[](_count);\n', '        \n', '        uint _i=0;\n', '        for(_i=0;_i<_count;_i++){\n', '            //_addresses[_i] = winners[_blockNumber][_i].addr;\n', '            _prize[_i] = winners[_blockNumber][_i].prize;\n', '        }\n', '\n', '        return (_addresses,_prize);\n', '    }\n', '\n', '    function getWinResults(uint _blockNumber) view public returns(uint){\n', '        return winResult[_blockNumber];\n', '    }\n', '    \n', '    function withdraw(address _to,uint amount) public onlyOwner returns(bool){\n', '        require(address(this).balance.sub(amount) > 0);\n', '        _to.transfer(amount);\n', '        \n', '        emit withdrawEvt(_to,amount);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function invest() isHuman payable public returns(uint){\n', '        require(msg.value >= 1 ether,"Minima amoun:1 ether");\n', '        \n', '        Sponsors[msg.sender] = Sponsors[msg.sender].add(msg.value);\n', '        balanceOfSPS = balanceOfSPS.add(msg.value);\n', '        \n', '        if(!utils.inArray(SponsorAddresses,msg.sender)){\n', '            SponsorAddresses.push(msg.sender);\n', '            emit sponseEvt(msg.sender,msg.value);\n', '        }\n', '\n', '        return Sponsors[msg.sender];\n', '    }\n', '    \n', '    function distribute() public onlyOwner{\n', '        if(address(this).balance < reservefund){\n', '            return;\n', '        }\n', '        \n', '        uint availableProfits=address(this).balance.sub(reservefund);\n', '        uint prft1=availableProfits.mul(3 ether).div(10 ether);\n', '        uint prft2=availableProfits.sub(prft1);\n', '        \n', '        uint _val=0;\n', '        uint _i=0;\n', '        \n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            _val = (prft1 * Sponsors[SponsorAddresses[_i]]) / (balanceOfSPS);\n', '            SponsorAddresses[_i].transfer(_val);\n', '        }\n', '        \n', '        uint w1p=prft2.mul(3 ether).div(10 ether);\n', '        \n', '        wallet1.transfer(w1p);\n', '        wallet2.transfer(prft2.sub(w1p));\n', '    }\n', '    \n', '    function sharesOfSPS() view public returns(uint,uint){\n', '        return (Sponsors[msg.sender],balanceOfSPS);\n', '    }\n', '    \n', '    function getAllSponsors() view public returns(address[],uint[],uint){\n', '        uint _i=0;\n', '        uint _c=0;\n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            _c+=1;\n', '        }\n', '        \n', '        address[] memory addrs=new address[](_c);\n', '        uint[] memory amounts=new uint[](_c);\n', '\n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            addrs[_i]=SponsorAddresses[_i];\n', '            amounts[_i]=Sponsors[SponsorAddresses[_i]];\n', '        }\n', '        \n', '        return(addrs,amounts,balanceOfSPS);\n', '    }\n', '\n', '    function() payable isHuman() public {\n', '    }\n', '    \n', '  \n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library utils{\n', '    function inArray(uint[] _arr,uint _val) internal pure returns(bool){\n', '        for(uint _i=0;_i< _arr.length;_i++){\n', '            if(_arr[_i]==_val){\n', '                return true;\n', '                break;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function inArray(address[] _arr,address _val) internal pure returns(bool){\n', '        for(uint _i=0;_i< _arr.length;_i++){\n', '            if(_arr[_i]==_val){\n', '                return true;\n', '                break;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '      /**\n', '       * @dev Throws if called by any account other than the owner.\n', '       */\n', '      modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '      }\n', '  \n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract GuessEthEvents{\n', '    event drawLog(uint,uint,uint);\n', '\n', '    event guessEvt(\n', '        address indexed playerAddr,\n', '        uint[] numbers, uint amount\n', '        );\n', '    event winnersEvt(\n', '        uint blockNumber,\n', '        address indexed playerAddr,\n', '        uint amount,\n', '        uint winAmount\n', '        );\n', '    event withdrawEvt(\n', '        address indexed to,\n', '        uint256 value\n', '        );\n', '    event drawEvt(\n', '        uint indexed blocknumberr,\n', '        uint number\n', '        );\n', '    \n', '    event sponseEvt(\n', '        address indexed addr,\n', '        uint amount\n', '        );\n', '\n', '    event pauseGameEvt(\n', '        bool pause\n', '        );\n', '    event setOddsEvt(\n', '        uint odds\n', '        );\n', '  \n', '}\n', '\n', 'contract GuessEth is Ownable,GuessEthEvents{\n', '    using SafeMath for uint;\n', '\n', '    /* Player Bets */\n', '\n', '    struct bnumber{\n', '        address addr;\n', '        uint number;\n', '        uint value;\n', '        int8 result;\n', '        uint prize;\n', '    }\n', '    mapping(uint => bnumber[]) public bets;\n', '    mapping(uint => address) public betNumber;\n', '    \n', '    /* player address => blockNumber[]*/\n', '    mapping(address => uint[]) private playerBetBNumber;\n', '    \n', '    /* Awards Records */\n', '    struct winner{\n', '        bool result;\n', '        uint prize;\n', '    }\n', '    \n', '    mapping(uint => winner[]) private winners;\n', '    mapping(uint => uint) private winResult;\n', '    \n', '    address private wallet1;\n', '    address private wallet2;\n', '    \n', '    uint private predictBlockInterval=3;\n', '    uint public odds=30;\n', '    uint public blockInterval=500;\n', '    uint public curOpenBNumber=0;\n', '    uint public numberRange=100;\n', '\n', '    bool public gamePaused=false;\n', '    \n', '\n', '    /* Sponsors */\n', '    mapping(address => uint) Sponsors;\n', '    uint public balanceOfSPS=0;\n', '    address[] public SponsorAddresses;\n', '    \n', '    uint reservefund=30 ether;\n', '   \n', '  \n', '    /**\n', '    * @dev prevents contracts from interacting with fomo3d\n', '    */\n', '    modifier isHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '    \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    constructor(address _wallet1,address _wallet2) public{\n', '        wallet1=_wallet1;\n', '        wallet2=_wallet2;\n', '        \n', '        curOpenBNumber=blockInterval*(block.number.div(blockInterval));\n', '    }\n', '    \n', '    function pauseGame(bool _status) public onlyOwner returns(bool){\n', '            gamePaused=_status;\n', '            emit pauseGameEvt(_status);\n', '    }\n', '    \n', '    function setOdds(uint _odds) isHuman() public onlyOwner returns(bool){\n', '            odds = _odds;\n', '            emit setOddsEvt(_odds);\n', '    }\n', '    function setReservefund(uint _reservefund) isHuman() public onlyOwner returns(bool){\n', '            reservefund = _reservefund * 1 ether;\n', '    }\n', '    \n', '    function getTargetBNumber() view isHuman() public returns(uint){\n', '        uint n;\n', '        n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n', '        return n;\n', '    }\n', '    \n', '    function guess(uint[] _numbers) payable isHuman() public returns(uint){\n', '        require(msg.value  >= _numbers.length * 0.05 ether);\n', '\n', '        uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n', '        \n', '        for(uint _i=0;_i < _numbers.length;_i++){\n', '            bnumber memory b;\n', '            \n', '            b.addr=msg.sender;\n', '            b.number=_numbers[_i];\n', '            b.value=msg.value/_numbers.length;\n', '            b.result=-1;\n', '            \n', '            bets[n].push(b);\n', '        }\n', '        \n', '        \n', '        if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\n', '            playerBetBNumber[msg.sender].push(n);\n', '        }\n', '        \n', '        emit guessEvt(msg.sender,_numbers, msg.value);\n', '        \n', '        return _numbers.length;\n', '    }\n', '    \n', '\n', '    function getPlayerGuessNumbers() view public returns (uint[],uint[],uint256[],int8[],uint[]){\n', '        uint _c=0;\n', '        uint _i=0;\n', '        uint _j=0;\n', '        uint _bnumber;\n', '        uint limitRows=100;\n', '        \n', '        while(_i < playerBetBNumber[msg.sender].length){\n', '            _bnumber=playerBetBNumber[msg.sender][_i];\n', '            for(_j=0 ; _j < bets[_bnumber].length && _c < limitRows ; _j++){\n', '                if(msg.sender==bets[_bnumber][_j].addr){\n', '                    _c++;\n', '                }\n', '            }\n', '            _i++;\n', '        }\n', '\n', '        uint[] memory _blockNumbers=new uint[](_c);\n', '        uint[] memory _numbers=new uint[](_c);\n', '        uint[] memory _values=new uint[](_c);\n', '        int8[] memory _result=new int8[](_c);\n', '        uint[] memory _prize=new uint[](_c);\n', '        \n', '        if(_c<=0){\n', '            return(_blockNumbers,_numbers,_values,_result,_prize);\n', '        }\n', '\n', '        //uint[] memory _b=new uint[](bettings[_blocknumber].length);\n', '\n', '        uint _count=0;\n', '        for(_i=0 ; _i < playerBetBNumber[msg.sender].length ; _i++){\n', '            _bnumber=playerBetBNumber[msg.sender][_i];\n', '            \n', '            for(_j=0 ; _j < bets[_bnumber].length && _count < limitRows ; _j++){\n', '                if(bets[_bnumber][_j].addr == msg.sender){\n', '                    _blockNumbers[_count] = _bnumber;\n', '                    _numbers[_count] =  bets[_bnumber][_j].number;\n', '                    _values[_count] =  bets[_bnumber][_j].value;\n', '                    _result[_count] =  bets[_bnumber][_j].result;\n', '                    _prize[_count] =  bets[_bnumber][_j].prize;\n', '                    \n', '                    _count++;\n', '                }\n', '            }\n', '        }\n', '\n', '\n', '        return(_blockNumbers,_numbers,_values,_result,_prize);\n', '    }\n', '    \n', '\n', '    function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\n', '        require(block.number >= curOpenBNumber + blockInterval);\n', '\n', '        /*Set open Result*/\n', '        curOpenBNumber=_blockNumber;\n', '        uint result=_blockTimestamp % numberRange;\n', '        winResult[_blockNumber]=result;\n', '\n', '        for(uint _i=0;_i < bets[_blockNumber].length;_i++){\n', '            //result+=1;\n', '            \n', '            \n', '            if(bets[_blockNumber][_i].number==result){\n', '                bets[_blockNumber][_i].result = 1;\n', '                bets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\n', '                \n', '                emit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\n', '\n', '                withdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n', '\n', '            }else{\n', '                bets[_blockNumber][_i].result = 0;\n', '                bets[_blockNumber][_i].prize = 0;\n', '            }\n', '        }\n', '        \n', '        emit drawEvt(_blockNumber,curOpenBNumber);\n', '        \n', '        return result;\n', '    }\n', '    \n', '    function getWinners(uint _blockNumber) view public returns(address[],uint[]){\n', '        uint _count=winners[_blockNumber].length;\n', '        \n', '        address[] memory _addresses = new address[](_count);\n', '        uint[] memory _prize = new uint[](_count);\n', '        \n', '        uint _i=0;\n', '        for(_i=0;_i<_count;_i++){\n', '            //_addresses[_i] = winners[_blockNumber][_i].addr;\n', '            _prize[_i] = winners[_blockNumber][_i].prize;\n', '        }\n', '\n', '        return (_addresses,_prize);\n', '    }\n', '\n', '    function getWinResults(uint _blockNumber) view public returns(uint){\n', '        return winResult[_blockNumber];\n', '    }\n', '    \n', '    function withdraw(address _to,uint amount) public onlyOwner returns(bool){\n', '        require(address(this).balance.sub(amount) > 0);\n', '        _to.transfer(amount);\n', '        \n', '        emit withdrawEvt(_to,amount);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function invest() isHuman payable public returns(uint){\n', '        require(msg.value >= 1 ether,"Minima amoun:1 ether");\n', '        \n', '        Sponsors[msg.sender] = Sponsors[msg.sender].add(msg.value);\n', '        balanceOfSPS = balanceOfSPS.add(msg.value);\n', '        \n', '        if(!utils.inArray(SponsorAddresses,msg.sender)){\n', '            SponsorAddresses.push(msg.sender);\n', '            emit sponseEvt(msg.sender,msg.value);\n', '        }\n', '\n', '        return Sponsors[msg.sender];\n', '    }\n', '    \n', '    function distribute() public onlyOwner{\n', '        if(address(this).balance < reservefund){\n', '            return;\n', '        }\n', '        \n', '        uint availableProfits=address(this).balance.sub(reservefund);\n', '        uint prft1=availableProfits.mul(3 ether).div(10 ether);\n', '        uint prft2=availableProfits.sub(prft1);\n', '        \n', '        uint _val=0;\n', '        uint _i=0;\n', '        \n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            _val = (prft1 * Sponsors[SponsorAddresses[_i]]) / (balanceOfSPS);\n', '            SponsorAddresses[_i].transfer(_val);\n', '        }\n', '        \n', '        uint w1p=prft2.mul(3 ether).div(10 ether);\n', '        \n', '        wallet1.transfer(w1p);\n', '        wallet2.transfer(prft2.sub(w1p));\n', '    }\n', '    \n', '    function sharesOfSPS() view public returns(uint,uint){\n', '        return (Sponsors[msg.sender],balanceOfSPS);\n', '    }\n', '    \n', '    function getAllSponsors() view public returns(address[],uint[],uint){\n', '        uint _i=0;\n', '        uint _c=0;\n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            _c+=1;\n', '        }\n', '        \n', '        address[] memory addrs=new address[](_c);\n', '        uint[] memory amounts=new uint[](_c);\n', '\n', '        for(_i=0;_i<SponsorAddresses.length;_i++){\n', '            addrs[_i]=SponsorAddresses[_i];\n', '            amounts[_i]=Sponsors[SponsorAddresses[_i]];\n', '        }\n', '        \n', '        return(addrs,amounts,balanceOfSPS);\n', '    }\n', '\n', '    function() payable isHuman() public {\n', '    }\n', '    \n', '  \n', '}']
