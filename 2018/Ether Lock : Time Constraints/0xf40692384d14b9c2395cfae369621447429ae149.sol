['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/SkrumbleStaking.sol\n', '\n', '// File: contracts/SkrumbleStaking.sol\n', '\n', '// Staking Contract for Skrumble Network - https://skrumble.network/\n', '// written by @iamdefinitelyahuman\n', '\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '  function balanceOf(address _owner) external returns (uint256);\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', '\n', 'contract SkrumbleStaking {\n', '\n', '  using SafeMath for uint;\n', '\n', '  bool public isLocked = true;\n', '  address owner;\n', '  address rewardWallet;\n', '  uint balance;\n', '  uint public count;\n', '  uint public limit;\n', '  ERC20 token;\n', '  \n', '  struct Reward {\n', '    uint stakedAmount;\n', '    uint lockupPeriod;\n', '    uint[] rewardAmounts;\n', '    uint[] rewardEpochStart;\n', '  }\n', '  mapping (uint => Reward) public rewardLevels;\n', '\n', '  struct Staker {\n', '    uint balance;\n', '    uint rewardLevel;\n', '    uint stakingSince;\n', '    uint lastClaim;\n', '  }\n', '  mapping (address => Staker) stakerMap;\n', '\n', '  event RewardLevel (uint level, uint amount, uint lockupPeriod, uint[] rewardAmounts, uint[] rewardEpochStart);\n', '  event NewStaker (address staker, uint rewardLevel, uint stakingSince);\n', '  event StakerCount (uint count, uint limit);\n', '  event RewardClaimed (address staker, uint rewardAmount);\n', '\n', '  modifier onlyOwner () {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyUnlocked () {\n', '    require (!isLocked);\n', '    _;\n', '  }\n', '\n', '  constructor (address _tokenContract, address _rewardWallet) public {\n', '    owner = msg.sender;\n', '    rewardWallet = _rewardWallet;\n', '    token = ERC20(_tokenContract);\n', '  }\n', '  \n', '  function min (uint a, uint b) pure internal returns (uint) {\n', '    if (a <= b) return a;\n', '    return b;\n', '  }\n', '  \n', '  function max (uint a, uint b) pure internal returns (uint) {\n', '    if (a >= b) return a;\n', '    return b;\n', '  }\n', '  \n', '  function lockContract () public onlyOwner {\n', '    isLocked = true;\n', '  }\n', '  \n', '  function unlockContract () public onlyOwner {\n', '    isLocked = false;\n', '  }\n', '  \n', '  function setRewardWallet (address _rewardWallet) public onlyOwner {\n', '    rewardWallet = _rewardWallet;\n', '  }\n', '  \n', '  function setRewardLevel (uint _level, uint _amount, uint _lockup, uint[] _reward, uint[] _period) public onlyOwner {\n', '    require (_reward.length == _period.length);\n', '    require (_period[_period.length.sub(1)] < 9999999999);\n', '    for (uint i = 1; i < _period.length; i++) {\n', '      require (_period[i] > _period[i.sub(1)]);\n', '    }\n', '    rewardLevels[_level] = Reward(_amount, _lockup, _reward, _period);\n', '    emit RewardLevel (_level, _amount, _lockup, _reward, _period);\n', '  }\n', '  \n', '  function modifyStakerLimit (uint _limit) public onlyOwner {\n', '    require (count <= _limit);\n', '    limit = _limit;\n', '  }\n', '  \n', '  function getAvailableReward (address _staker) view public returns (uint) {\n', '    Staker storage staker = stakerMap[_staker];\n', '    Reward storage reward = rewardLevels[staker.rewardLevel];\n', '    if (staker.balance == 0 || staker.lastClaim.add(86400) > now) {\n', '      return 0;\n', '    }\n', '    uint unclaimed = 0;\n', '    uint periodEnd = 9999999999;\n', '    for (uint i = reward.rewardEpochStart.length; i > 0; i--) {\n', '      uint start = staker.stakingSince.add(reward.rewardEpochStart[i.sub(1)]);\n', '      if (start >= now) {\n', '        continue;\n', '      }\n', '      uint length = min(now, periodEnd).sub(max(start, staker.lastClaim));\n', '      unclaimed = unclaimed.add(reward.rewardAmounts[i.sub(1)].mul(length).div(31622400));\n', '      if (staker.lastClaim >= start) {\n', '        break;\n', '      }\n', '      periodEnd = start;\n', '    }\n', '    return unclaimed;\n', '  }\n', '\n', '  function getStakerInfo (address _staker) view public returns (uint stakedBalance, uint lockedUntil, uint lastClaim) {\n', '    Staker storage staker = stakerMap[_staker];\n', '    Reward storage reward = rewardLevels[staker.rewardLevel];\n', '    return (staker.balance, staker.stakingSince.add(reward.lockupPeriod), staker.lastClaim);\n', '  }\n', '\n', '  function stakeTokens (uint _level) public onlyUnlocked {\n', '    Reward storage reward = rewardLevels[_level];\n', '    require (stakerMap[msg.sender].balance == 0);\n', '    require (count < limit);\n', '    require (token.transferFrom(msg.sender, address(this), reward.stakedAmount));\n', '    count = count.add(1);\n', '    balance = balance.add(reward.stakedAmount);\n', '    stakerMap[msg.sender] = Staker(reward.stakedAmount, _level, now, now);\n', '    emit NewStaker (msg.sender, _level, now);\n', '    emit StakerCount (count, limit);\n', '  }\n', '  \n', '  function unstakeTokens () public onlyUnlocked {\n', '    Staker storage staker = stakerMap[msg.sender];\n', '    Reward storage reward = rewardLevels[staker.rewardLevel];\n', '    require (staker.balance > 0);\n', '    require (staker.stakingSince.add(reward.lockupPeriod) < now);\n', '    if (getAvailableReward(msg.sender) > 0) {\n', '      claimReward();\n', '    }\n', '    require (token.transfer(msg.sender, staker.balance));\n', '    count = count.sub(1);\n', '    balance = balance.sub(staker.balance);\n', '    emit StakerCount (count, limit);\n', '  \tstakerMap[msg.sender] = Staker(0, 0, 0, 0);\n', '  }\n', '  \n', '  function claimReward () public onlyUnlocked {\n', '    uint amount = getAvailableReward(msg.sender);\n', '    require (amount > 0);\n', '    stakerMap[msg.sender].lastClaim = now;\n', '    require (token.transferFrom(rewardWallet, msg.sender, amount));\n', '    emit RewardClaimed (msg.sender, amount);\n', '  }\n', '  \n', '  function transferSKM () public onlyOwner {\n', '    uint fullBalance = token.balanceOf(address(this));\n', '    require (fullBalance > balance);\n', '    require (token.transfer(owner, fullBalance.sub(balance)));\n', '  }\n', '  \n', '  function transferOtherTokens (address _tokenAddr) public onlyOwner {\n', '    require (_tokenAddr != address(token));\n', '    ERC20 _token = ERC20(_tokenAddr);\n', '    require (_token.transfer(owner, _token.balanceOf(address(this))));\n', '  }\n', '\n', '  function claimRewardManually (address _staker) public onlyOwner {\n', '    uint amount = getAvailableReward(_staker);\n', '    require (amount > 0);\n', '    stakerMap[_staker].lastClaim = now;\n', '    require (token.transferFrom(rewardWallet, _staker, amount));\n', '    emit RewardClaimed (_staker, amount);\n', '  }\n', '\n', '  function unstakeTokensManually (address _staker) public onlyOwner {\n', '    Staker storage staker = stakerMap[_staker];\n', '    Reward storage reward = rewardLevels[staker.rewardLevel];\n', '    require (staker.balance > 0);\n', '    require (staker.stakingSince.add(reward.lockupPeriod) < now);\n', '    if (getAvailableReward(_staker) > 0) {\n', '      claimRewardManually(_staker);\n', '    }\n', '    require (token.transfer(_staker, staker.balance));\n', '    count = count.sub(1);\n', '    balance = balance.sub(staker.balance);\n', '    emit StakerCount (count, limit);\n', '  \tstakerMap[_staker] = Staker(0, 0, 0, 0);\n', '  }\n', '\n', '  function stakeTokensManually (address _staker, uint _level, uint time) public onlyUnlocked {\n', '    Reward storage reward = rewardLevels[_level];\n', '    require (stakerMap[_staker].balance == 0);\n', '    require (count < limit);\n', '    count = count.add(1);\n', '    balance = balance.add(reward.stakedAmount);\n', '    stakerMap[_staker] = Staker(reward.stakedAmount, _level, time, time);\n', '    emit NewStaker (_staker, _level, time);\n', '    emit StakerCount (count, limit);\n', '  }\n', '\n', '}']