['pragma solidity ^0.4.17;\n', '\n', 'interface ERC20Token {\n', '\tfunction balanceOf(address tokenOwner)\n', '\t\tpublic view returns (uint balance);\n', ' \tfunction transfer(address to, uint tokens)\n', '\t\tpublic returns (bool success);\n', '\tfunction symbol() public view returns (string);\n', '\tfunction name() public view returns (string);\n', '\tfunction decimals() public view returns (uint8);\n', '}\n', '\n', 'contract MultiKeyDailyLimitWallet {\n', '\tuint constant LIMIT_PRECISION = 1000000;\n', '\t// Fractional daily limits per key. In units of 1/LIMIT_PRECISION.\n', '\tmapping(address=>uint) public credentials;\n', '\t// Timestamp of last withdrawal, by token (0x0 is ether).\n', '\tmapping(address=>uint) public lastWithdrawalTime;\n', '\t// Total withdrawn in last 24-hours, by token (0x0 is ether).\n', '\t// Resets if 24 hours passes with no activity.\n', '\tmapping(address=>uint) public dailyCount;\n', '\tuint public nonce;\n', '\n', '\tevent OnWithdrawTo(\n', '\t\taddress indexed token,\n', '\t\taddress indexed from,\n', '\t\taddress indexed to,\n', '\t\tuint amount,\n', '\t\tuint64 timestamp);\n', '\n', '\tfunction MultiKeyDailyLimitWallet(address[] keys, uint[] limits)\n', '\t\t\tpayable public {\n', '\t\t\n', '\t\trequire(keys.length == limits.length);\n', '\t\tfor (uint i = 0; i < keys.length; i++) {\n', '\t\t\tvar limit = limits[i];\n', '\t\t\t// limit should be in range 1-LIMIT_PRECISION\n', '\t\t\trequire (limit > 0 && limit <= LIMIT_PRECISION);\n', '\t\t\tcredentials[keys[i]] = limit;\n', '\t\t}\n', '\t}\n', '\n', '\t/* #IF TESTING\n', '\tfunction setLastWithdrawalTime(address token, uint time) external {\n', '\t\tlastWithdrawalTime[token] = time;\n', '\t}\n', '\tfunction setDailyCount(address token, uint count) external {\n', '\t\tdailyCount[token] = count;\n', '\t}\n', '\t #FI */\n', '\n', '\tfunction getDailyCount(address token) public view returns (uint) {\n', '\t\tvar _dailyCount = dailyCount[token];\n', '\t\tif ((block.timestamp - lastWithdrawalTime[token]) >= 1 days)\n', '\t\t\t_dailyCount = 0;\n', '\t\treturn _dailyCount;\n', '\t}\n', '\n', '\tfunction getRemainingLimit(address token, address key)\n', '\t\t\tpublic view returns (uint) {\n', '\n', '\t\tvar pct = credentials[key];\n', '\t\tif (pct == 0)\n', '\t\t\treturn 0;\n', '\n', '\t\tvar _dailyCount = getDailyCount(token);\n', '\t\tvar balance = getBalance(token);\n', '\t\tvar amt = ((balance + _dailyCount) * pct) / LIMIT_PRECISION;\n', '\t\tif (amt == 0 && balance > 0)\n', '\t\t\tamt = 1;\n', '\t\tif (_dailyCount >= amt)\n', '\t\t\treturn 0;\n', '\t\treturn amt - _dailyCount;\n', '\t}\n', '\n', '\tfunction withdrawTo(\n', '\t\t\taddress token,\n', '\t\t\tuint amount,\n', '\t\t\taddress to,\n', '\t\t\tbytes signature) external {\n', '\n', '\t\trequire(amount > 0 && to != address(this));\n', '\t\tassert(block.timestamp >= lastWithdrawalTime[token]);\n', '\n', '\t\tvar limit = getSignatureRemainingLimit(\n', '\t\t\tsignature,\n', '\t\t\tkeccak256(address(this), token, nonce, amount, to),\n', '\t\t\ttoken);\n', '\n', '\t\trequire(limit >= amount);\n', '\t\trequire(getBalance(token) >= amount);\n', '\n', '\t\tdailyCount[token] = getDailyCount(token) + amount;\n', '\t\tlastWithdrawalTime[token] = block.timestamp;\n', '\t\tnonce++;\n', '\t\t_transfer(token, to, amount);\n', '\t\tOnWithdrawTo(token, msg.sender, to, amount, uint64(block.timestamp));\n', '\t}\n', '\n', '\tfunction getBalance(address token) public view returns (uint) {\n', '\t\tif (token != 0x0) {\n', '\t\t\t// Token.\n', '\t\t\treturn ERC20Token(token).balanceOf(address(this));\n', '\t\t}\n', '\t\treturn this.balance;\n', '\t}\n', '\n', '\tfunction _transfer(address token, address to, uint amount)\n', '\t \t\tprivate {\n', '\n', '\t\tif (token != 0x0) {\n', '\t\t\t// Transfering a token.\n', '\t\t\trequire(ERC20Token(token).transfer(to, amount));\n', '\t\t\treturn;\n', '\t\t}\n', '\t\tto.transfer(amount);\n', '\t}\n', '\n', '\tfunction getSignatureRemainingLimit(\n', '\t\t\tbytes signature,\n', '\t\t\tbytes32 payload,\n', '\t\t\taddress token)\n', '\t\t\tprivate view returns (uint) {\n', '\n', '\t\tvar addr = extractSignatureAddress(signature, payload);\n', '\t\treturn getRemainingLimit(token, addr);\n', '\t}\n', '\n', '\tfunction extractSignatureAddress(bytes signature, bytes32 payload)\n', '\t\t\tprivate pure returns (address) {\n', '\n', '\t\tpayload = keccak256("\\x19Ethereum Signed Message:\\n32", payload);\n', '\t\tbytes32 r;\n', '\t\tbytes32 s;\n', '\t\tuint8 v;\n', '\t\tassembly {\n', '\t\t\tr := mload(add(signature, 32))\n', '\t\t\ts := mload(add(signature, 64))\n', '\t\t\tv := and(mload(add(signature, 65)), 255)\n', '\t\t}\n', '\t\tif (v < 27)\n', '\t\t\tv += 27;\n', '\t\trequire(v == 27 || v == 28);\n', '\t\treturn ecrecover(payload, v, r, s);\n', '\t}\n', '\n', '\tfunction() public payable {}\n', '}']