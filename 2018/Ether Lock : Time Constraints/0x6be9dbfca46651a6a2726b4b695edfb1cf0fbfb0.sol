['pragma solidity ^0.4.23;\n', '\n', '\n', '\n', '\n', 'contract Escrow {\n', '    using SafeMath for uint256;\n', '    using ContentUtils for ContentUtils.ContentMapping;\n', '\n', '    ContentUtils.ContentMapping public content;\n', '    address escrowAddr = address(this);\n', '\n', '    uint256 public claimable = 0; \n', '    uint256 public currentBalance = 0; \n', '    mapping(bytes32 => uint256) public claimableRewards;\n', '\n', '    /// @notice valid reward and user has enough funds\n', '    modifier validReward(uint256 _reward) {\n', '        require(_reward > 0 && _depositEscrow(_reward));\n', '        _;\n', '    }\n', '\n', '    /// @notice complete deliverable by making reward amount claimable\n', '    function completeDeliverable(bytes32 _id, address _creator, address _brand) internal returns(bool) {\n', '        require(content.isFulfilled(_id, _creator, _brand));\n', '        content.completeDeliverable(_id);\n', '        return _approveEscrow(_id, content.rewardOf(_id));       \n', '    }\n', '\n', '    /// @notice update current balance, if proper token amount approved\n', '    function _depositEscrow(uint256 _amount) internal returns(bool) {\n', '        currentBalance = currentBalance.add(_amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice approve reward amount for transfer from escrow contract to creator\n', '    function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) {\n', '        claimable = claimable.add(_amount);\n', '        claimableRewards[_id] = _amount;\n', '        return true;\n', '    }\n', '\n', '    function getClaimableRewards(bytes32 _id) public returns(uint256) {\n', '        return claimableRewards[_id];\n', '    }\n', '\n', '    function getContentByName(string _name) public view returns(\n', '        string name,\n', '        string description,\n', '        uint reward,\n', '        uint addedOn) \n', '    {\n', '        var (_content, exist) = content.getContentByName(_name);\n', '        if (exist) {\n', '            return (_content.name, _content.description, _content.deliverable.reward, _content.addedOn);\n', '        } else {\n', '            return ("", "", 0, 0);\n', '        }\n', '    }\n', '\n', '    function currentFulfillment(string _name) public view returns(bool fulfillment) {\n', '        var (_content, exist) = content.getContentByName(_name);\n', '        if (exist) {\n', '            return _content.deliverable.fulfillment[msg.sender];\n', '        } else {\n', '            false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'library DeliverableUtils {\n', '\n', '    struct Deliverable {\n', '        uint256 reward;\n', '        mapping(address=>bool) fulfillment;\n', '        bool fulfilled;\n', '    }\n', '\n', '    /// @notice msg.sender can be creator or brand and mark their delivery or approval, returns check if completely Fulfilled\n', '    function fulfill(Deliverable storage self, address _creator, address _brand) internal returns(bool) {\n', '        require(msg.sender == _creator || msg.sender == _brand);\n', '        self.fulfillment[msg.sender] = true;\n', '        return self.fulfillment[_creator] && self.fulfillment[_brand];\n', '    }\n', '\n', '    /// @notice check if deliverable fulfilled completely\n', '    function isFulfilled(Deliverable storage self, address _creator, address _brand) internal view returns(bool) {\n', '        return self.fulfillment[_creator] && self.fulfillment[_brand];\n', '    }\n', '\n', '    /// @notice return new deliverable struct if reward greater than 0\n', '    function newDeliverable(uint256 _reward) internal pure returns(Deliverable _deliverable) {\n', '        require(_reward > 0);\n', '        return Deliverable(_reward, false);\n', '    }\n', '}\n', '\n', 'library ContentUtils {\n', '    using SafeMath for uint256;\n', '    using DeliverableUtils for DeliverableUtils.Deliverable;\n', '\n', '    struct Content {\n', '        bytes32 id;\n', '        string name;\n', '        string description;\n', '        uint addedOn;\n', '        DeliverableUtils.Deliverable deliverable;\n', '    }\n', '\n', '    /// @notice utility for mapping bytes32=>Content. Keys must be unique. It can be updated until it is locked.\n', '    struct ContentMapping {\n', '        mapping(bytes32=>Content) data;\n', '        bytes32[] keys;\n', '        bool locked;\n', '    }\n', '\n', '    string constant UNIQUE_KEY_ERR = "Content with ID already exists ";\n', '    string constant KEY_NOT_FOUND_ERR = "Key not found";\n', '\n', '    /// @notice put item into mapping\n', '    function put(ContentMapping storage self, \n', '        string _name, \n', '        string _description, \n', '        uint _reward) public returns (bool) \n', '    {\n', '            require(!self.locked);\n', '\n', '            bytes32 _id = generateContentID(_name);\n', '            require(self.data[_id].id == bytes32(0));\n', '\n', '            self.data[_id] = Content(_id, _name, _description, block.timestamp, DeliverableUtils.newDeliverable(_reward));\n', '            self.keys.push(_id);\n', '            return true;\n', '    }\n', '    \n', '    /// @notice get amount of items in mapping\n', '    function size(ContentMapping storage self) public view returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '\n', '    /// @notice return reward of content delivarable\n', '    function rewardOf(ContentMapping storage self, bytes32 _id) public view returns (uint256) {\n', '        return self.data[_id].deliverable.reward;\n', '    }\n', '\n', '    function getKey(ContentMapping storage self, uint _index) public view returns (bytes32) {\n', '        isValidIndex(_index, self.keys.length);\n', '        return self.keys[_index];\n', '    }\n', '\n', '    /// @notice get content by plain string name\n', '    function getContentByName(ContentMapping storage self, string _name) public view returns (Content storage _content, bool exists) {\n', '        bytes32 _hash = generateContentID(_name);\n', '        return (self.data[_hash], self.data[_hash].addedOn != 0);\n', '    }\n', '\n', '    /// @notice get content by sha3 ID hash\n', '    function getContentByID(ContentMapping storage self, bytes32 _id) public view returns (Content storage _content, bool exists) {\n', '        return (self.data[_id], self.data[_id].id == bytes32(0));\n', '    }\n', '\n', '    /// @notice get content by _index into key array \n', '    function getContentByKeyIndex(ContentMapping storage self, uint _index) public view returns (Content storage _content) {\n', '        isValidIndex(_index, self.keys.length);\n', '        return (self.data[self.keys[_index]]);\n', '    }\n', '\n', '    /// @notice wrapper around internal deliverable method\n', '    function fulfill(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public returns(bool) {\n', '        return self.data[_id].deliverable.fulfill(_creator, _brand);\n', '    }\n', '\n', '    /// @notice wrapper around internal deliverable method\n', '    function isFulfilled(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public view returns(bool) {\n', '        return self.data[_id].deliverable.isFulfilled(_creator, _brand);\n', '    }\n', '\n', '    /// @notice marks deliverable as fulfilled\n', '    function completeDeliverable(ContentMapping storage self, bytes32 _id) internal returns(bool) {\n', '        self.data[_id].deliverable.fulfilled = true;\n', '        return true;\n', '    }\n', '\n', '    /// @notice get sha256 hash of name for content ID\n', '    function generateContentID(string _name) public pure returns (bytes32) {\n', '        return keccak256(_name);\n', '    }\n', '\n', '    /// @notice index not out of bounds\n', '    function isValidIndex(uint _index, uint _size) public pure {\n', '        require(_index < _size, KEY_NOT_FOUND_ERR);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Agreement is Escrow {\n', '    \n', '    bool public locked;\n', '    uint  public createdOn;\n', '    uint public expiration;\n', '    uint public startTime;\n', '    address public brand;\n', '    address public creator;\n', '    \n', '    constructor(address _creator, uint _expiration, address _token) public {\n', '        brand = msg.sender;\n', '        creator = _creator;\n', '        expiration = _expiration;\n', '    }\n', '\n', '    /// @notice only brand is authorized\n', '    modifier onlyBrand() {\n', '        require(msg.sender == brand);\n', '        _;\n', '    }\n', '\n', '    /// @notice only creator is authorized\n', '    modifier onlyCreator() {\n', '        require(msg.sender == creator);\n', '        _;\n', '    }\n', '\n', '    /// @notice deliverable fulfilled\n', '    modifier fulfilled(bytes32 _id) {\n', '        require(content.isFulfilled(_id, creator, brand));\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement expired, refunds remaining balance in escrow\n', '    modifier expired() {\n', '        require(block.timestamp > expiration);\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement not expired, refunds remaining balance in escrow\n', '    modifier notExpired() {\n', '        require(block.timestamp < expiration);\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement not locked\n', '    modifier notLocked() {\n', '        require(!locked);\n', '        _;\n', '    }\n', '\n', '    /// @notice add content to the agreement\n', '    function addContent(string _name, \n', '        string _description, \n', '        uint _reward) notLocked onlyBrand validReward(_reward) \n', '        public returns(bool _success) {\n', '            return content.put(_name, _description, _reward);\n', '    }\n', '\n', '    function _fulfill(bytes32 _id) private returns (bool) {\n', '        bool _fulfilled = content.fulfill(_id, creator, brand);\n', '        if(_fulfilled) {\n', '            return completeDeliverable(_id, creator, brand);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function fulfillDeliverable(bytes32 _id) notExpired onlyCreator public returns (bool) {\n', '        return _fulfill(_id);\n', '    }\n', '\n', '    function approveDeliverable(bytes32 _id) onlyBrand public returns (bool) {\n', '        return _fulfill(_id);\n', '    }\n', '    \n', '    function claim(bytes32 _id) external onlyCreator {\n', '        claimableRewards[_id] = 0;\n', '    }\n', '\n', '\n', '    function lock() onlyBrand public {\n', '        content.locked == true;\n', '        locked = true;\n', '        startTime = block.timestamp;\n', '    }\n', '\n', '    function extendExpiration(uint _expiration) onlyBrand public returns (bool) {\n', '        require(_expiration > expiration && _expiration >= block.timestamp);\n', '        expiration = _expiration;\n', '        return true;\n', '    }\n', '\n', '    function destroy() onlyBrand expired public {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    function deposit() payable {}\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) constant returns (uint);\n', '\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '\n', '    function approve(address spender, uint value) returns (bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0))\n', '            owner = newOwner;\n', '    }\n', '\n', '    function kill() {\n', '        if (msg.sender == owner)\n', '            selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '}\n', '\n', '// Token Contract\n', 'contract CCOIN is ERC20, Ownable {\n', '\n', '    struct Escrow {\n', '        address creator;\n', '        address brand;\n', '        address agreementContract;\n', '        uint256 reward;\n', '    }\n', '\n', '    // Public variables of the token\n', '    string public constant name = "CCOIN";\n', '    string public constant symbol = "CCOIN";\n', '    uint public constant decimals = 18;\n', '    uint public totalSupply = 1000000000 * 10 ** 18;\n', '    bool public locked;\n', '\n', '    address public multisigETH; // SafeMath.multisig contract that will receive the ETH\n', '    address public crowdSaleaddress; // Crowdsale address\n', '    uint public ethReceived; // Number of ETH received\n', '    uint public totalTokensSent; // Number of tokens sent to ETH contributors\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of token to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minContributionETH; // Minimum amount to invest\n', '    uint public tokenPriceWei;\n', '\n', '    uint firstPeriod;\n', '    uint secondPeriod;\n', '    uint thirdPeriod;\n', '    uint fourthPeriod;\n', '    uint fifthPeriod;\n', '    uint firstBonus;\n', '    uint secondBonus;\n', '    uint thirdBonus;\n', '    uint fourthBonus;\n', '    uint fifthBonus;\n', '    uint public multiplier;\n', '\n', '    bool public stopInEmergency = false;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping(address => Escrow) escrowAgreements;\n', '    // Whitelist\n', '    mapping(address => bool) public whitelisted;\n', '\n', '    event Whitelist(address indexed participant);\n', '    event Locked();\n', '    event Unlocked();\n', '    event StoppedCrowdsale();\n', '    event RestartedCrowdsale();\n', '    event Burned(uint256 value);\n', '\n', '    // Lock transfer during the ICO\n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleaddress && locked && msg.sender != owner)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice to protect short address attack\n', '    modifier onlyPayloadSize(uint numWords){\n', '        assert(msg.data.length >= numWords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != crowdSaleaddress && msg.sender != owner)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // The Token constructor\n', '    constructor() public {\n', '        locked = true;\n', '        multiplier = 10 ** 18;\n', '\n', '        multisigETH = msg.sender;\n', '        minContributionETH = 1;\n', '        startBlock = 0;\n', '        endBlock = 0;\n', '        maxCap = 1000 * multiplier;\n', '        tokenPriceWei = SafeMath.div(1, 1400);\n', '        minCap = 100 * multiplier;\n', '        totalTokensSent = 0;\n', '        firstPeriod = 100;\n', '        secondPeriod = 200;\n', '        thirdPeriod = 300;\n', '        fourthPeriod = 400;\n', '        fifthPeriod = 500;\n', '\n', '        firstBonus = 120;\n', '        secondBonus = 115;\n', '        thirdBonus = 110;\n', '        fourthBonus = SafeMath.div(1075, 10);\n', '        fifthBonus = 105;\n', '        balances[multisigETH] = totalSupply;\n', '    }\n', '\n', '    function resetCrowdSaleaddress(address _newCrowdSaleaddress) public onlyAuthorized() {\n', '        crowdSaleaddress = _newCrowdSaleaddress;\n', '    }\n', '\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '        emit Unlocked();\n', '    }\n', '\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '        emit Locked();\n', '    }\n', '\n', '    function burn(address _member, uint256 _value) public onlyAuthorized returns (bool) {\n', '        balances[_member] = SafeMath.sub(balances[_member], _value);\n', '        totalSupply = SafeMath.sub(totalSupply, _value);\n', '        emit Transfer(_member, 0x0, _value);\n', '        emit Burned(_value);\n', '        return true;\n', '    }\n', '\n', '    function Airdrop(address _to, uint256 _tokens) external onlyAuthorized returns(bool) {\n', '        require(transfer(_to, _tokens));\n', '    } \n', '\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns (bool) {\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '        balances[_to] = SafeMath.add(balances[_to], _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool success) {\n', '        if (balances[_from] < _value)\n', '            revert();\n', '        // Check if the sender has enough\n', '        if (_value > allowed[_from][msg.sender])\n', '            revert();\n', '        // Check allowance\n', '        balances[_from] = SafeMath.sub(balances[_from], _value);\n', '        // SafeMath.subtract from the sender\n', '        balances[_to] = SafeMath.add(balances[_to], _value);\n', '        // SafeMath.add the same to the recipient\n', '        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function withdrawFromEscrow(address _agreementAddr, bytes32 _id) {\n', '        require(balances[_agreementAddr] > 0);\n', '        Agreement agreement = Agreement(_agreementAddr);\n', '        require(agreement.creator() == msg.sender);\n', '        uint256 reward = agreement.getClaimableRewards(_id);\n', '        require(reward > 0);\n', '        balances[_agreementAddr] = SafeMath.sub(balances[_agreementAddr], reward);\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], reward);\n', '    }\n', '\n', '    function WhitelistParticipant(address participant) external onlyAuthorized {\n', '        whitelisted[participant] = true;\n', '        emit Whitelist(participant);\n', '    }\n', '\n', '    function BlacklistParticipant(address participant) external onlyAuthorized {\n', '        whitelisted[participant] = false;\n', '        emit Whitelist(participant);\n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\n', '    function() public payable onlyPayloadSize(2) {\n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of beneficiary\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal returns (bool res) {\n', '        // stop when required minimum is not sent\n', '        if (msg.value < minContributionETH)\n', '            revert();\n', '\n', '        // calculate number of tokens\n', '        uint tokensToSend = calculateNoOfTokensToSend();\n', '\n', '        // Ensure that max cap hasn&#39;t been reached\n', '        if (SafeMath.add(totalTokensSent, tokensToSend) > maxCap)\n', '            revert();\n', '\n', '        // Transfer tokens to contributor\n', '        if (!transfer(_backer, tokensToSend))\n', '            revert();\n', '\n', '        ethReceived = SafeMath.add(ethReceived, msg.value);\n', '        totalTokensSent = SafeMath.add(totalTokensSent, tokensToSend);\n', '\n', '        return true;\n', '    }\n', '\n', '    // @notice This function will return number of tokens based on time intervals in the campaign\n', '    function calculateNoOfTokensToSend() constant internal returns (uint) {\n', '        uint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);\n', '        if (block.number <= startBlock + firstPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);\n', '        else if (block.number <= startBlock + secondPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);\n', '        else if (block.number <= startBlock + thirdPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);\n', '        else if (block.number <= startBlock + fourthPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);\n', '        else if (block.number <= startBlock + fifthPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);\n', '        else\n', '            return tokenAmount;\n', '    }\n', '\n', '    function stopCrowdsale() external onlyOwner{\n', '        stopInEmergency = true;\n', '        emit StoppedCrowdsale();\n', '    }\n', '\n', '    function restartCrowdsale() external onlyOwner{\n', '        stopInEmergency = false;\n', '        emit RestartedCrowdsale();\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '\n', '\n', 'contract Escrow {\n', '    using SafeMath for uint256;\n', '    using ContentUtils for ContentUtils.ContentMapping;\n', '\n', '    ContentUtils.ContentMapping public content;\n', '    address escrowAddr = address(this);\n', '\n', '    uint256 public claimable = 0; \n', '    uint256 public currentBalance = 0; \n', '    mapping(bytes32 => uint256) public claimableRewards;\n', '\n', '    /// @notice valid reward and user has enough funds\n', '    modifier validReward(uint256 _reward) {\n', '        require(_reward > 0 && _depositEscrow(_reward));\n', '        _;\n', '    }\n', '\n', '    /// @notice complete deliverable by making reward amount claimable\n', '    function completeDeliverable(bytes32 _id, address _creator, address _brand) internal returns(bool) {\n', '        require(content.isFulfilled(_id, _creator, _brand));\n', '        content.completeDeliverable(_id);\n', '        return _approveEscrow(_id, content.rewardOf(_id));       \n', '    }\n', '\n', '    /// @notice update current balance, if proper token amount approved\n', '    function _depositEscrow(uint256 _amount) internal returns(bool) {\n', '        currentBalance = currentBalance.add(_amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice approve reward amount for transfer from escrow contract to creator\n', '    function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) {\n', '        claimable = claimable.add(_amount);\n', '        claimableRewards[_id] = _amount;\n', '        return true;\n', '    }\n', '\n', '    function getClaimableRewards(bytes32 _id) public returns(uint256) {\n', '        return claimableRewards[_id];\n', '    }\n', '\n', '    function getContentByName(string _name) public view returns(\n', '        string name,\n', '        string description,\n', '        uint reward,\n', '        uint addedOn) \n', '    {\n', '        var (_content, exist) = content.getContentByName(_name);\n', '        if (exist) {\n', '            return (_content.name, _content.description, _content.deliverable.reward, _content.addedOn);\n', '        } else {\n', '            return ("", "", 0, 0);\n', '        }\n', '    }\n', '\n', '    function currentFulfillment(string _name) public view returns(bool fulfillment) {\n', '        var (_content, exist) = content.getContentByName(_name);\n', '        if (exist) {\n', '            return _content.deliverable.fulfillment[msg.sender];\n', '        } else {\n', '            false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'library DeliverableUtils {\n', '\n', '    struct Deliverable {\n', '        uint256 reward;\n', '        mapping(address=>bool) fulfillment;\n', '        bool fulfilled;\n', '    }\n', '\n', '    /// @notice msg.sender can be creator or brand and mark their delivery or approval, returns check if completely Fulfilled\n', '    function fulfill(Deliverable storage self, address _creator, address _brand) internal returns(bool) {\n', '        require(msg.sender == _creator || msg.sender == _brand);\n', '        self.fulfillment[msg.sender] = true;\n', '        return self.fulfillment[_creator] && self.fulfillment[_brand];\n', '    }\n', '\n', '    /// @notice check if deliverable fulfilled completely\n', '    function isFulfilled(Deliverable storage self, address _creator, address _brand) internal view returns(bool) {\n', '        return self.fulfillment[_creator] && self.fulfillment[_brand];\n', '    }\n', '\n', '    /// @notice return new deliverable struct if reward greater than 0\n', '    function newDeliverable(uint256 _reward) internal pure returns(Deliverable _deliverable) {\n', '        require(_reward > 0);\n', '        return Deliverable(_reward, false);\n', '    }\n', '}\n', '\n', 'library ContentUtils {\n', '    using SafeMath for uint256;\n', '    using DeliverableUtils for DeliverableUtils.Deliverable;\n', '\n', '    struct Content {\n', '        bytes32 id;\n', '        string name;\n', '        string description;\n', '        uint addedOn;\n', '        DeliverableUtils.Deliverable deliverable;\n', '    }\n', '\n', '    /// @notice utility for mapping bytes32=>Content. Keys must be unique. It can be updated until it is locked.\n', '    struct ContentMapping {\n', '        mapping(bytes32=>Content) data;\n', '        bytes32[] keys;\n', '        bool locked;\n', '    }\n', '\n', '    string constant UNIQUE_KEY_ERR = "Content with ID already exists ";\n', '    string constant KEY_NOT_FOUND_ERR = "Key not found";\n', '\n', '    /// @notice put item into mapping\n', '    function put(ContentMapping storage self, \n', '        string _name, \n', '        string _description, \n', '        uint _reward) public returns (bool) \n', '    {\n', '            require(!self.locked);\n', '\n', '            bytes32 _id = generateContentID(_name);\n', '            require(self.data[_id].id == bytes32(0));\n', '\n', '            self.data[_id] = Content(_id, _name, _description, block.timestamp, DeliverableUtils.newDeliverable(_reward));\n', '            self.keys.push(_id);\n', '            return true;\n', '    }\n', '    \n', '    /// @notice get amount of items in mapping\n', '    function size(ContentMapping storage self) public view returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '\n', '    /// @notice return reward of content delivarable\n', '    function rewardOf(ContentMapping storage self, bytes32 _id) public view returns (uint256) {\n', '        return self.data[_id].deliverable.reward;\n', '    }\n', '\n', '    function getKey(ContentMapping storage self, uint _index) public view returns (bytes32) {\n', '        isValidIndex(_index, self.keys.length);\n', '        return self.keys[_index];\n', '    }\n', '\n', '    /// @notice get content by plain string name\n', '    function getContentByName(ContentMapping storage self, string _name) public view returns (Content storage _content, bool exists) {\n', '        bytes32 _hash = generateContentID(_name);\n', '        return (self.data[_hash], self.data[_hash].addedOn != 0);\n', '    }\n', '\n', '    /// @notice get content by sha3 ID hash\n', '    function getContentByID(ContentMapping storage self, bytes32 _id) public view returns (Content storage _content, bool exists) {\n', '        return (self.data[_id], self.data[_id].id == bytes32(0));\n', '    }\n', '\n', '    /// @notice get content by _index into key array \n', '    function getContentByKeyIndex(ContentMapping storage self, uint _index) public view returns (Content storage _content) {\n', '        isValidIndex(_index, self.keys.length);\n', '        return (self.data[self.keys[_index]]);\n', '    }\n', '\n', '    /// @notice wrapper around internal deliverable method\n', '    function fulfill(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public returns(bool) {\n', '        return self.data[_id].deliverable.fulfill(_creator, _brand);\n', '    }\n', '\n', '    /// @notice wrapper around internal deliverable method\n', '    function isFulfilled(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public view returns(bool) {\n', '        return self.data[_id].deliverable.isFulfilled(_creator, _brand);\n', '    }\n', '\n', '    /// @notice marks deliverable as fulfilled\n', '    function completeDeliverable(ContentMapping storage self, bytes32 _id) internal returns(bool) {\n', '        self.data[_id].deliverable.fulfilled = true;\n', '        return true;\n', '    }\n', '\n', '    /// @notice get sha256 hash of name for content ID\n', '    function generateContentID(string _name) public pure returns (bytes32) {\n', '        return keccak256(_name);\n', '    }\n', '\n', '    /// @notice index not out of bounds\n', '    function isValidIndex(uint _index, uint _size) public pure {\n', '        require(_index < _size, KEY_NOT_FOUND_ERR);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Agreement is Escrow {\n', '    \n', '    bool public locked;\n', '    uint  public createdOn;\n', '    uint public expiration;\n', '    uint public startTime;\n', '    address public brand;\n', '    address public creator;\n', '    \n', '    constructor(address _creator, uint _expiration, address _token) public {\n', '        brand = msg.sender;\n', '        creator = _creator;\n', '        expiration = _expiration;\n', '    }\n', '\n', '    /// @notice only brand is authorized\n', '    modifier onlyBrand() {\n', '        require(msg.sender == brand);\n', '        _;\n', '    }\n', '\n', '    /// @notice only creator is authorized\n', '    modifier onlyCreator() {\n', '        require(msg.sender == creator);\n', '        _;\n', '    }\n', '\n', '    /// @notice deliverable fulfilled\n', '    modifier fulfilled(bytes32 _id) {\n', '        require(content.isFulfilled(_id, creator, brand));\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement expired, refunds remaining balance in escrow\n', '    modifier expired() {\n', '        require(block.timestamp > expiration);\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement not expired, refunds remaining balance in escrow\n', '    modifier notExpired() {\n', '        require(block.timestamp < expiration);\n', '        _;\n', '    }\n', '\n', '    /// @notice agreement not locked\n', '    modifier notLocked() {\n', '        require(!locked);\n', '        _;\n', '    }\n', '\n', '    /// @notice add content to the agreement\n', '    function addContent(string _name, \n', '        string _description, \n', '        uint _reward) notLocked onlyBrand validReward(_reward) \n', '        public returns(bool _success) {\n', '            return content.put(_name, _description, _reward);\n', '    }\n', '\n', '    function _fulfill(bytes32 _id) private returns (bool) {\n', '        bool _fulfilled = content.fulfill(_id, creator, brand);\n', '        if(_fulfilled) {\n', '            return completeDeliverable(_id, creator, brand);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function fulfillDeliverable(bytes32 _id) notExpired onlyCreator public returns (bool) {\n', '        return _fulfill(_id);\n', '    }\n', '\n', '    function approveDeliverable(bytes32 _id) onlyBrand public returns (bool) {\n', '        return _fulfill(_id);\n', '    }\n', '    \n', '    function claim(bytes32 _id) external onlyCreator {\n', '        claimableRewards[_id] = 0;\n', '    }\n', '\n', '\n', '    function lock() onlyBrand public {\n', '        content.locked == true;\n', '        locked = true;\n', '        startTime = block.timestamp;\n', '    }\n', '\n', '    function extendExpiration(uint _expiration) onlyBrand public returns (bool) {\n', '        require(_expiration > expiration && _expiration >= block.timestamp);\n', '        expiration = _expiration;\n', '        return true;\n', '    }\n', '\n', '    function destroy() onlyBrand expired public {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    function deposit() payable {}\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) constant returns (uint);\n', '\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '\n', '    function approve(address spender, uint value) returns (bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0))\n', '            owner = newOwner;\n', '    }\n', '\n', '    function kill() {\n', '        if (msg.sender == owner)\n', '            selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '}\n', '\n', '// Token Contract\n', 'contract CCOIN is ERC20, Ownable {\n', '\n', '    struct Escrow {\n', '        address creator;\n', '        address brand;\n', '        address agreementContract;\n', '        uint256 reward;\n', '    }\n', '\n', '    // Public variables of the token\n', '    string public constant name = "CCOIN";\n', '    string public constant symbol = "CCOIN";\n', '    uint public constant decimals = 18;\n', '    uint public totalSupply = 1000000000 * 10 ** 18;\n', '    bool public locked;\n', '\n', '    address public multisigETH; // SafeMath.multisig contract that will receive the ETH\n', '    address public crowdSaleaddress; // Crowdsale address\n', '    uint public ethReceived; // Number of ETH received\n', '    uint public totalTokensSent; // Number of tokens sent to ETH contributors\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of token to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minContributionETH; // Minimum amount to invest\n', '    uint public tokenPriceWei;\n', '\n', '    uint firstPeriod;\n', '    uint secondPeriod;\n', '    uint thirdPeriod;\n', '    uint fourthPeriod;\n', '    uint fifthPeriod;\n', '    uint firstBonus;\n', '    uint secondBonus;\n', '    uint thirdBonus;\n', '    uint fourthBonus;\n', '    uint fifthBonus;\n', '    uint public multiplier;\n', '\n', '    bool public stopInEmergency = false;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping(address => Escrow) escrowAgreements;\n', '    // Whitelist\n', '    mapping(address => bool) public whitelisted;\n', '\n', '    event Whitelist(address indexed participant);\n', '    event Locked();\n', '    event Unlocked();\n', '    event StoppedCrowdsale();\n', '    event RestartedCrowdsale();\n', '    event Burned(uint256 value);\n', '\n', '    // Lock transfer during the ICO\n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleaddress && locked && msg.sender != owner)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice to protect short address attack\n', '    modifier onlyPayloadSize(uint numWords){\n', '        assert(msg.data.length >= numWords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != crowdSaleaddress && msg.sender != owner)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // The Token constructor\n', '    constructor() public {\n', '        locked = true;\n', '        multiplier = 10 ** 18;\n', '\n', '        multisigETH = msg.sender;\n', '        minContributionETH = 1;\n', '        startBlock = 0;\n', '        endBlock = 0;\n', '        maxCap = 1000 * multiplier;\n', '        tokenPriceWei = SafeMath.div(1, 1400);\n', '        minCap = 100 * multiplier;\n', '        totalTokensSent = 0;\n', '        firstPeriod = 100;\n', '        secondPeriod = 200;\n', '        thirdPeriod = 300;\n', '        fourthPeriod = 400;\n', '        fifthPeriod = 500;\n', '\n', '        firstBonus = 120;\n', '        secondBonus = 115;\n', '        thirdBonus = 110;\n', '        fourthBonus = SafeMath.div(1075, 10);\n', '        fifthBonus = 105;\n', '        balances[multisigETH] = totalSupply;\n', '    }\n', '\n', '    function resetCrowdSaleaddress(address _newCrowdSaleaddress) public onlyAuthorized() {\n', '        crowdSaleaddress = _newCrowdSaleaddress;\n', '    }\n', '\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '        emit Unlocked();\n', '    }\n', '\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '        emit Locked();\n', '    }\n', '\n', '    function burn(address _member, uint256 _value) public onlyAuthorized returns (bool) {\n', '        balances[_member] = SafeMath.sub(balances[_member], _value);\n', '        totalSupply = SafeMath.sub(totalSupply, _value);\n', '        emit Transfer(_member, 0x0, _value);\n', '        emit Burned(_value);\n', '        return true;\n', '    }\n', '\n', '    function Airdrop(address _to, uint256 _tokens) external onlyAuthorized returns(bool) {\n', '        require(transfer(_to, _tokens));\n', '    } \n', '\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns (bool) {\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '        balances[_to] = SafeMath.add(balances[_to], _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool success) {\n', '        if (balances[_from] < _value)\n', '            revert();\n', '        // Check if the sender has enough\n', '        if (_value > allowed[_from][msg.sender])\n', '            revert();\n', '        // Check allowance\n', '        balances[_from] = SafeMath.sub(balances[_from], _value);\n', '        // SafeMath.subtract from the sender\n', '        balances[_to] = SafeMath.add(balances[_to], _value);\n', '        // SafeMath.add the same to the recipient\n', '        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function withdrawFromEscrow(address _agreementAddr, bytes32 _id) {\n', '        require(balances[_agreementAddr] > 0);\n', '        Agreement agreement = Agreement(_agreementAddr);\n', '        require(agreement.creator() == msg.sender);\n', '        uint256 reward = agreement.getClaimableRewards(_id);\n', '        require(reward > 0);\n', '        balances[_agreementAddr] = SafeMath.sub(balances[_agreementAddr], reward);\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], reward);\n', '    }\n', '\n', '    function WhitelistParticipant(address participant) external onlyAuthorized {\n', '        whitelisted[participant] = true;\n', '        emit Whitelist(participant);\n', '    }\n', '\n', '    function BlacklistParticipant(address participant) external onlyAuthorized {\n', '        whitelisted[participant] = false;\n', '        emit Whitelist(participant);\n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\n', '    function() public payable onlyPayloadSize(2) {\n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of beneficiary\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal returns (bool res) {\n', '        // stop when required minimum is not sent\n', '        if (msg.value < minContributionETH)\n', '            revert();\n', '\n', '        // calculate number of tokens\n', '        uint tokensToSend = calculateNoOfTokensToSend();\n', '\n', "        // Ensure that max cap hasn't been reached\n", '        if (SafeMath.add(totalTokensSent, tokensToSend) > maxCap)\n', '            revert();\n', '\n', '        // Transfer tokens to contributor\n', '        if (!transfer(_backer, tokensToSend))\n', '            revert();\n', '\n', '        ethReceived = SafeMath.add(ethReceived, msg.value);\n', '        totalTokensSent = SafeMath.add(totalTokensSent, tokensToSend);\n', '\n', '        return true;\n', '    }\n', '\n', '    // @notice This function will return number of tokens based on time intervals in the campaign\n', '    function calculateNoOfTokensToSend() constant internal returns (uint) {\n', '        uint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);\n', '        if (block.number <= startBlock + firstPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);\n', '        else if (block.number <= startBlock + secondPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);\n', '        else if (block.number <= startBlock + thirdPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);\n', '        else if (block.number <= startBlock + fourthPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);\n', '        else if (block.number <= startBlock + fifthPeriod)\n', '            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);\n', '        else\n', '            return tokenAmount;\n', '    }\n', '\n', '    function stopCrowdsale() external onlyOwner{\n', '        stopInEmergency = true;\n', '        emit StoppedCrowdsale();\n', '    }\n', '\n', '    function restartCrowdsale() external onlyOwner{\n', '        stopInEmergency = false;\n', '        emit RestartedCrowdsale();\n', '    }\n', '\n', '}']
