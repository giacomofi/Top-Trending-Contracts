['pragma solidity ^0.4.15;\n', '\n', '// File: contracts/libs/Ownable.sol\n', '\n', '/**\n', '* @title Ownable\n', '* @dev Manages ownership of the contracts\n', '*/\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isOwner(address _address) public constant returns (bool) {\n', '        return _address == owner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libs/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @dev modifier to allow actions only when the contract IS paused\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev modifier to allow actions only when the contract IS NOT paused\n', '    */\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function _unpause() internal whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/libs/BaseStorage.sol\n', '\n', 'contract BaseStorage is Pausable {\n', '\n', '    event AccessAllowed(address _address);\n', '    event AccessDenied(address _address);\n', '\n', '    mapping (address => bool) public allowed;\n', '    address public developer;\n', '\n', '\n', '    modifier canWrite() {\n', '        require(allowed[msg.sender] || isOwner(msg.sender)\n', '            || (msg.sender == developer));\n', '        _;\n', '    }\n', '\n', '    function setDeveloper(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        developer = _address;\n', '    }\n', '\n', '    function allow(address _address) external canWrite {\n', '        require(_address != address(0));\n', '        allowed[_address] = true;\n', '        AccessAllowed(_address);\n', '    }\n', '\n', '    function denied(address _address) external canWrite {\n', '        delete allowed[_address];\n', '        AccessDenied(_address);\n', '    }\n', '\n', '    function isAllowed(address _address) external constant returns (bool) {\n', '        return allowed[_address];\n', '    }\n', '}\n', '\n', '// File: contracts/libs/AccessControlStorage.sol\n', '\n', 'contract AccessControlStorage is BaseStorage {\n', '\n', '\n', '    mapping (address => bool) public admins;\n', '    mapping (uint => address) public contracts;\n', '\n', '    function addAdmin(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function isAdmin(address _address) public constant returns (bool) {\n', '        return admins[_address];\n', '    }\n', '\n', '    function removeAdmin(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        delete admins[_address];\n', '    }\n', '\n', '    function setContract(uint _signature, address _address) external canWrite {\n', '        contracts[_signature] = _address;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/AuctionStorage.sol\n', '\n', 'contract AuctionStorage is BaseStorage {\n', '\n', '    // Represents an auction on an NFT\n', '    struct Auction {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) at beginning of auction\n', '        uint128 startingPrice;\n', '        // Price (in wei) at end of auction\n', '        uint128 endingPrice;\n', '        // Duration (in seconds) of auction\n', '        uint64 duration;\n', '        // Time when auction started\n', '        // NOTE: 0 if this auction has been concluded\n', '        uint startedAt;\n', '        // true = started by team, false = started by ordinary user\n', '        bool byTeam;\n', '    }\n', '\n', '    // Map from token ID to their corresponding auction.\n', '    mapping (uint => Auction) public tokenIdToAuction;\n', '    uint auctionsCounter = 0;\n', '    uint8 public secondarySaleCut = 4;\n', '\n', '    function addAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _duration,\n', '        address _seller) public canWrite {\n', '        require(!_isOnAuction(_tokenId));\n', '        tokenIdToAuction[_tokenId] = Auction({\n', '            seller: _seller,\n', '            startingPrice: uint128(_startingPrice),\n', '            endingPrice: uint128(_endingPrice),\n', '            duration: uint64(_duration),\n', '            startedAt: now,\n', '            byTeam: false\n', '        });\n', '        auctionsCounter++;\n', '    }\n', '\n', '    function initAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _startedAt,\n', '        uint _duration,\n', '        address _seller,\n', '        bool _byTeam) public canWrite {\n', '        require(!_isOnAuction(_tokenId));\n', '        tokenIdToAuction[_tokenId] = Auction({\n', '            seller: _seller,\n', '            startingPrice: uint128(_startingPrice),\n', '            endingPrice: uint128(_endingPrice),\n', '            duration: uint64(_duration),\n', '            startedAt: _startedAt,\n', '            byTeam: _byTeam\n', '        });\n', '        auctionsCounter++;\n', '    }\n', '\n', '    function addReleaseAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _startedAt,\n', '        uint _duration) public canWrite {\n', '        bool _byTeam = true;\n', '        address _seller = owner;\n', '        initAuction(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _startedAt,\n', '            _duration,\n', '            _seller,\n', '            _byTeam\n', '        );\n', '    }\n', '\n', '    function _isOnAuction(uint _tokenId)\n', '        internal constant returns (bool) {\n', '        return (tokenIdToAuction[_tokenId].startedAt > 0);\n', '    }\n', '\n', '    function isOnAuction(uint _tokenId)\n', '        external constant returns (bool) {\n', '        return _isOnAuction(_tokenId);\n', '    }\n', '\n', '    function removeAuction(uint _tokenId) public canWrite {\n', '        require(_isOnAuction(_tokenId));\n', '        delete tokenIdToAuction[_tokenId];\n', '        auctionsCounter--;\n', '    }\n', '\n', '    /// @dev Returns auction info for an NFT on auction.\n', '    /// @param _tokenId - ID of NFT on auction.\n', '    function getAuction(uint256 _tokenId)\n', '        external\n', '        constant\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 startingPrice,\n', '        uint256 endingPrice,\n', '        uint256 duration,\n', '        uint256 startedAt\n', '    ) {\n', '        Auction memory auction = tokenIdToAuction[_tokenId];\n', '        require(_isOnAuction(_tokenId));\n', '        return (\n', '            auction.seller,\n', '            auction.startingPrice,\n', '            auction.endingPrice,\n', '            auction.duration,\n', '            auction.startedAt\n', '        );\n', '    }\n', '\n', '    function getAuctionSeller(uint256 _tokenId)\n', '        public constant returns (address) {\n', '        return tokenIdToAuction[_tokenId].seller;\n', '    }\n', '\n', '    function getAuctionStartedAt(uint256 _tokenId)\n', '        public constant returns (uint) {\n', '        return tokenIdToAuction[_tokenId].startedAt;\n', '    }\n', '\n', '    function getAuctionEnd(uint _tokenId)\n', '        public constant returns (uint) {\n', '        Auction memory auction = tokenIdToAuction[_tokenId];\n', '        return auction.startedAt + auction.duration;\n', '    }\n', '\n', '    function getAuctionsCount() public constant returns (uint) {\n', '        return auctionsCounter;\n', '    }\n', '\n', '    function canBeCanceled(uint _tokenId) external constant returns (bool) {\n', '        return getAuctionEnd(_tokenId) <= now;\n', '    }\n', '\n', '    function isSecondary(uint _tokenId) public constant returns (bool _is) {\n', '        return (tokenIdToAuction[_tokenId].byTeam == false);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libs/EditionStorage.sol\n', '\n', 'contract EditionStorage is BaseStorage {\n', '\n', '    uint public offset = 1000000;\n', '    uint public offsetIndex = 1;\n', '    uint8[3] public defaultEditionLimits = [10, 89, 200];\n', '    mapping (uint => mapping (uint8 => uint8)) public editionCounts;\n', '    mapping (uint => mapping (uint8 => uint8)) public editionLimits;\n', '    mapping (uint => uint) public lastEditionOf;\n', '\n', '    function setOffset(uint _offset) external onlyOwner {\n', '        offset = _offset;\n', '    }\n', '\n', '    function getOffsetIndex() public constant returns (uint) {\n', '        return offset + offsetIndex;\n', '    }\n', '\n', '    function nextOffsetIndex() public canWrite {\n', '        offsetIndex++;\n', '    }\n', '\n', '    function canCreateEdition(uint _tokenId, uint8 _generation)\n', '        public constant returns (bool) {\n', '        uint8 actual = editionCounts[_tokenId][_generation - 1];\n', '        uint limit = editionLimits[_tokenId][_generation - 1];\n', '        return (actual < limit);\n', '    }\n', '\n', '    function isValidGeneration(uint8 _generation)\n', '        public constant returns (bool) {\n', '        return (_generation >= 1 && _generation <= 3);\n', '    }\n', '\n', '    function increaseGenerationCount(uint _tokenId, uint8 _generation)\n', '        public canWrite {\n', '        require(canCreateEdition(_tokenId, _generation));\n', '        require(isValidGeneration(_generation));\n', '        uint8 _generationIndex = _generation - 1;\n', '        editionCounts[_tokenId][_generationIndex]++;\n', '    }\n', '\n', '    function getEditionsCount(uint _tokenId)\n', '        external constant returns (uint8[3])  {\n', '        return [\n', '            editionCounts[_tokenId][0],\n', '            editionCounts[_tokenId][1],\n', '            editionCounts[_tokenId][2]\n', '        ];\n', '    }\n', '\n', '    function setLastEditionOf(uint _tokenId, uint _editionId)\n', '        public canWrite {\n', '        lastEditionOf[_tokenId] = _editionId;\n', '    }\n', '\n', '    function getEditionLimits(uint _tokenId)\n', '        external constant returns (uint8[3])  {\n', '        return [\n', '            editionLimits[_tokenId][0],\n', '            editionLimits[_tokenId][1],\n', '            editionLimits[_tokenId][2]\n', '        ];\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/libs/PaintingInformationStorage.sol\n', '\n', 'contract PaintingInformationStorage {\n', '\n', '    struct PaintingInformation {\n', '        string name;\n', '        string artist;\n', '    }\n', '\n', '    mapping (uint => PaintingInformation) public information;\n', '}\n', '\n', '// File: contracts/libs/PaintingStorage.sol\n', '\n', 'contract PaintingStorage is BaseStorage {\n', '\n', '    struct Painting {\n', '        uint parentId;\n', '        uint originalId;\n', '        uint createdAt;\n', '        uint completedAt;\n', '        uint8 generation;\n', '        uint8 speedIndex;\n', '        uint artistId;\n', '        uint releasedAt;\n', '        bool isFinal;\n', '    }\n', '\n', '    uint32[10] public speeds = [\n', '        uint32(8760 hours), // 365 days\n', '        uint32(6480 hours), // 270 days\n', '        uint32(4320 hours), // 180 days\n', '        uint32(2880 hours), // 120 days\n', '        uint32(1920 hours), // 80 days\n', '        uint32(960 hours), // 40 days\n', '        uint32(480 hours), // 20 days\n', '        uint32(240 hours), // 10 days\n', '        uint32(120 hours), // 5 days\n', '        uint32(24 hours) // 1 day\n', '    ];\n', '\n', '    uint32[10] public speedsTest = [\n', '        uint32(8760 seconds),\n', '        uint32(6480 seconds),\n', '        uint32(4320 seconds),\n', '        uint32(2880 seconds),\n', '        uint32(1920 seconds),\n', '        uint32(960 seconds),\n', '        uint32(480 seconds),\n', '        uint32(240 seconds),\n', '        uint32(120 seconds),\n', '        uint32(24 seconds)\n', '    ];\n', '\n', '    uint32[10] public speedsDev = [\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds)\n', '    ];\n', '\n', '    mapping (uint => address) public paintingIndexToOwner;\n', '    mapping (uint => Painting) public paintings;\n', '    mapping (uint => address) public paintingIndexToApproved;\n', '    uint[] public paintingIds;\n', '    mapping (uint => uint) public paintingIdToIndex;\n', '    uint public paintingsCount;\n', '    uint public totalPaintingsCount;\n', '    mapping (uint => bool) public isCanceled;\n', '    mapping (uint => bool) public isReleased;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    // Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) public ownershipTokenCount;\n', '\n', '    modifier isNew(uint _tokenId) {\n', '        require(paintings[_tokenId].createdAt == 0);\n', '        _;\n', '    }\n', '\n', '    function exists(uint _tokenId) external constant returns (bool) {\n', '        return paintings[_tokenId].createdAt != 0;\n', '    }\n', '\n', '    function increaseOwnershipTokenCount(address _address) public canWrite {\n', '        ownershipTokenCount[_address]++;\n', '    }\n', '\n', '    function decreaseOwnershipTokenCount(address _address) public canWrite {\n', '        ownershipTokenCount[_address]--;\n', '    }\n', '\n', '    function setOwnership(uint _tokenId, address _address) public canWrite {\n', '        paintingIndexToOwner[_tokenId] = _address;\n', '    }\n', '\n', '    function getPainting(uint _tokenId) external constant returns (\n', '        address owner,\n', '        uint parent,\n', '        uint createdAt,\n', '        uint completedAt,\n', '        uint8 generation,\n', '        uint8 speed) {\n', '        return (\n', '            paintingIndexToOwner[_tokenId],\n', '            paintings[_tokenId].parentId,\n', '            paintings[_tokenId].createdAt,\n', '            paintings[_tokenId].completedAt,\n', '            paintings[_tokenId].generation,\n', '            paintings[_tokenId].speedIndex + 1\n', '        );\n', '    }\n', '\n', '    function approve(uint _tokenId, address _claimant) external canWrite {\n', '        paintingIndexToApproved[_tokenId] = _claimant;\n', '    }\n', '\n', '    function isApprovedFor(uint _tokenId, address _claimant) external constant returns (bool) {\n', '        return paintingIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function decreaseSpeed(uint _tokenId) public canWrite() {\n', '        uint8 _speed = paintings[_tokenId].speedIndex;\n', '\n', '        if (_speed > 0) {\n', '            paintings[_tokenId].speedIndex--;\n', '        }\n', '    }\n', '\n', '    function getPaintingOwner(uint _tokenId)\n', '        external constant returns (address) {\n', '        return paintingIndexToOwner[_tokenId];\n', '    }\n', '\n', '    function getPaintingGeneration(uint _tokenId)\n', '        public constant returns (uint8) {\n', '        return paintings[_tokenId].generation;\n', '    }\n', '\n', '    function getPaintingArtistId(uint _tokenId)\n', '        public constant returns (uint artistId) {\n', '        return paintings[_tokenId].artistId;\n', '    }\n', '\n', '    function getPaintingSpeed(uint _tokenId)\n', '        external constant returns (uint8) {\n', '        return paintings[_tokenId].speedIndex + 1;\n', '    }\n', '\n', '    function getPaintingOriginal(uint _tokenId)\n', '        external constant returns (uint) {\n', '        return paintings[_tokenId].originalId;\n', '    }\n', '\n', '    function getOwnershipTokenCount(address _address)\n', '        external constant returns (uint) {\n', '        return ownershipTokenCount[_address];\n', '    }\n', '\n', '    function isReady(uint _tokenId)\n', '        public constant returns (bool) {\n', '        return paintings[_tokenId].completedAt <= now;\n', '    }\n', '\n', '    function getPaintingIdAtIndex(uint _index)\n', '        public constant returns (uint) {\n', '        return paintingIds[_index];\n', '    }\n', '\n', '    function canBeChanged(uint _tokenId) public constant returns (bool _can) {\n', '        return paintings[_tokenId].isFinal == false;\n', '    }\n', '\n', '    function sealForChanges(uint _tokenId) public canWrite {\n', '        if (paintings[_tokenId].isFinal == false) {\n', '            paintings[_tokenId].isFinal = true;\n', '        }\n', '    }\n', '\n', '    function canBeBidden(uint _tokenId) public constant returns (bool _can) {\n', '        return (paintings[_tokenId].releasedAt <= now);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/BitpaintingStorage.sol\n', '\n', 'contract BitpaintingStorage is PaintingStorage, PaintingInformationStorage, AccessControlStorage, AuctionStorage, EditionStorage {\n', '\n', '    /// 0 = production mode\n', '    /// 1 = testing mode\n', '    /// 2 = development mode\n', '    uint8 mode;\n', '\n', '    function BitpaintingStorage(uint8 _mode) public {\n', '        require(_mode >= 0 && _mode <=2);\n', '        mode = _mode;\n', '    }\n', '\n', '    function hasEditionInProgress(uint _tokenId)\n', '        external constant returns (bool) {\n', '        uint edition = lastEditionOf[_tokenId];\n', '        if (edition == 0) {\n', '            return false;\n', '        }\n', '\n', '        return !isReady(edition);\n', '    }\n', '\n', '    function hasEmptyEditionSlots(uint _tokenId)\n', '        external constant returns (bool) {\n', '        uint originalId = paintings[_tokenId].originalId;\n', '        if (originalId == 0) {\n', '            originalId = _tokenId;\n', '        }\n', '        uint8 generation = paintings[_tokenId].generation;\n', '        uint8 limit = editionLimits[originalId][generation];\n', '        uint8 current = editionCounts[originalId][generation];\n', '        return (current < limit);\n', '    }\n', '\n', '    function resetPainting(uint _tokenId) public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        isCanceled[_tokenId] = true;\n', '        paintingsCount--;\n', '        delete paintings[_tokenId];\n', '    }\n', '\n', '    function createPainting(\n', '        address _owner,\n', '        uint _tokenId,\n', '        uint _parentId,\n', '        uint8 _generation,\n', '        uint8 _speed,\n', '        uint _artistId,\n', '        uint _releasedAt\n', '    ) public isNew(_tokenId) canWrite {\n', '        require(now <= _releasedAt);\n', '        require(_speed >= 1 && _speed <= 10);\n', '        _speed--;\n', '\n', '        uint _createdAt = now;\n', '        uint _completedAt;\n', '        if (_generation == 0) {\n', '            _completedAt = now;\n', '        } else {\n', '            uint _parentSpeed = paintings[_parentId].speedIndex;\n', '            if (mode == 2) {\n', '                _completedAt = now + speedsDev[_parentSpeed];\n', '            } else {\n', '                if (mode == 1) {\n', '                    _completedAt = now + speedsTest[_parentSpeed];\n', '                } else {\n', '                    _completedAt = now + speeds[_parentSpeed];\n', '                }\n', '            }\n', '        }\n', '\n', '        uint _originalId;\n', '        if (_generation == 0) {\n', '            _originalId = _tokenId;\n', '        } else {\n', '            if (_generation == 1) {\n', '                _originalId = _parentId;\n', '            } else {\n', '                _originalId = paintings[_parentId].originalId;\n', '            }\n', '        }\n', '\n', '        paintings[_tokenId] = Painting({\n', '            parentId: _parentId,\n', '            originalId: _originalId,\n', '            createdAt: _createdAt,\n', '            generation: _generation,\n', '            speedIndex: _speed,\n', '            completedAt: _completedAt,\n', '            artistId: _artistId,\n', '            releasedAt: _releasedAt,\n', '            isFinal: (_generation != 0) // if generation == 1 or 2 or 3, so it cannot be changed\n', '        });\n', '\n', '        if (!isReleased[_tokenId]) {\n', '            isReleased[_tokenId] = true;\n', '            paintingIds.push(_tokenId);\n', '            paintingIdToIndex[_tokenId] = totalPaintingsCount;\n', '            increaseOwnershipTokenCount(_owner);\n', '            totalPaintingsCount++;\n', '        }\n', '        isCanceled[_tokenId] = false;\n', '        setOwnership(_tokenId, _owner);\n', '        paintingsCount++;\n', '    }\n', '\n', '    function setEditionLimits(\n', '        uint _tokenId,\n', '        uint8 _gen1,\n', '        uint8 _gen2,\n', '        uint8 _gen3)\n', '        public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        editionLimits[_tokenId][0] = _gen1;\n', '        editionLimits[_tokenId][1] = _gen2;\n', '        editionLimits[_tokenId][2] = _gen3;\n', '    }\n', '\n', '    function resetEditionLimits(uint _tokenId) public canWrite {\n', '        setEditionLimits(_tokenId, 0, 0, 0);\n', '    }\n', '\n', '    function createEditionMeta(uint _tokenId) public canWrite {\n', '        uint _originalId = paintings[_tokenId].originalId;\n', '        nextOffsetIndex();\n', '        uint editionId = getOffsetIndex();\n', '        setLastEditionOf(_tokenId, editionId);\n', '\n', '        uint8 _generation = getPaintingGeneration(_tokenId) + 1;\n', '        increaseGenerationCount(_originalId, _generation);\n', '    }\n', '\n', '    function purgeInformation(uint _tokenId) public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        delete information[_tokenId];\n', '    }\n', '\n', '    function setPaintingName(uint _tokenId, string _name) public canWrite {\n', '        information[_tokenId].name = _name;\n', '    }\n', '\n', '    function setPaintingArtist(uint _tokenId, string _name) public canWrite {\n', '        information[_tokenId].artist = _name;\n', '    }\n', '\n', '    function getTokensOnAuction() public constant returns (uint[] tokens) {\n', '        tokens = new uint[](auctionsCounter);\n', '        uint pointer = 0;\n', '\n', '        for(uint index = 0; index < totalPaintingsCount; index++) {\n', '            uint tokenId = getPaintingIdAtIndex(index);\n', '\n', '            if (isCanceled[tokenId]) {\n', '                continue;\n', '            }\n', '\n', '            if (!_isOnAuction(tokenId)) {\n', '                continue;\n', '            }\n', '\n', '            tokens[pointer] = tokenId;\n', '            pointer++;\n', '        }\n', '    }\n', '\n', '    function getPaintingName(uint _tokenId) public constant returns (string) {\n', '        uint id = paintings[_tokenId].originalId;\n', '        return information[id].name;\n', '    }\n', '\n', '    function getPaintingArtist(uint _tokenId)\n', '        public constant returns (string) {\n', '        uint id = paintings[_tokenId].originalId;\n', '        return information[id].artist;\n', '    }\n', '\n', '    function signature() external constant returns (bytes4) {\n', '        return bytes4(keccak256("storage"));\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '// File: contracts/libs/Ownable.sol\n', '\n', '/**\n', '* @title Ownable\n', '* @dev Manages ownership of the contracts\n', '*/\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isOwner(address _address) public constant returns (bool) {\n', '        return _address == owner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libs/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @dev modifier to allow actions only when the contract IS paused\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev modifier to allow actions only when the contract IS NOT paused\n', '    */\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function _unpause() internal whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/libs/BaseStorage.sol\n', '\n', 'contract BaseStorage is Pausable {\n', '\n', '    event AccessAllowed(address _address);\n', '    event AccessDenied(address _address);\n', '\n', '    mapping (address => bool) public allowed;\n', '    address public developer;\n', '\n', '\n', '    modifier canWrite() {\n', '        require(allowed[msg.sender] || isOwner(msg.sender)\n', '            || (msg.sender == developer));\n', '        _;\n', '    }\n', '\n', '    function setDeveloper(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        developer = _address;\n', '    }\n', '\n', '    function allow(address _address) external canWrite {\n', '        require(_address != address(0));\n', '        allowed[_address] = true;\n', '        AccessAllowed(_address);\n', '    }\n', '\n', '    function denied(address _address) external canWrite {\n', '        delete allowed[_address];\n', '        AccessDenied(_address);\n', '    }\n', '\n', '    function isAllowed(address _address) external constant returns (bool) {\n', '        return allowed[_address];\n', '    }\n', '}\n', '\n', '// File: contracts/libs/AccessControlStorage.sol\n', '\n', 'contract AccessControlStorage is BaseStorage {\n', '\n', '\n', '    mapping (address => bool) public admins;\n', '    mapping (uint => address) public contracts;\n', '\n', '    function addAdmin(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function isAdmin(address _address) public constant returns (bool) {\n', '        return admins[_address];\n', '    }\n', '\n', '    function removeAdmin(address _address) public onlyOwner {\n', '        require(_address != address(0));\n', '        delete admins[_address];\n', '    }\n', '\n', '    function setContract(uint _signature, address _address) external canWrite {\n', '        contracts[_signature] = _address;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/AuctionStorage.sol\n', '\n', 'contract AuctionStorage is BaseStorage {\n', '\n', '    // Represents an auction on an NFT\n', '    struct Auction {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) at beginning of auction\n', '        uint128 startingPrice;\n', '        // Price (in wei) at end of auction\n', '        uint128 endingPrice;\n', '        // Duration (in seconds) of auction\n', '        uint64 duration;\n', '        // Time when auction started\n', '        // NOTE: 0 if this auction has been concluded\n', '        uint startedAt;\n', '        // true = started by team, false = started by ordinary user\n', '        bool byTeam;\n', '    }\n', '\n', '    // Map from token ID to their corresponding auction.\n', '    mapping (uint => Auction) public tokenIdToAuction;\n', '    uint auctionsCounter = 0;\n', '    uint8 public secondarySaleCut = 4;\n', '\n', '    function addAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _duration,\n', '        address _seller) public canWrite {\n', '        require(!_isOnAuction(_tokenId));\n', '        tokenIdToAuction[_tokenId] = Auction({\n', '            seller: _seller,\n', '            startingPrice: uint128(_startingPrice),\n', '            endingPrice: uint128(_endingPrice),\n', '            duration: uint64(_duration),\n', '            startedAt: now,\n', '            byTeam: false\n', '        });\n', '        auctionsCounter++;\n', '    }\n', '\n', '    function initAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _startedAt,\n', '        uint _duration,\n', '        address _seller,\n', '        bool _byTeam) public canWrite {\n', '        require(!_isOnAuction(_tokenId));\n', '        tokenIdToAuction[_tokenId] = Auction({\n', '            seller: _seller,\n', '            startingPrice: uint128(_startingPrice),\n', '            endingPrice: uint128(_endingPrice),\n', '            duration: uint64(_duration),\n', '            startedAt: _startedAt,\n', '            byTeam: _byTeam\n', '        });\n', '        auctionsCounter++;\n', '    }\n', '\n', '    function addReleaseAuction(\n', '        uint _tokenId,\n', '        uint _startingPrice,\n', '        uint _endingPrice,\n', '        uint _startedAt,\n', '        uint _duration) public canWrite {\n', '        bool _byTeam = true;\n', '        address _seller = owner;\n', '        initAuction(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _startedAt,\n', '            _duration,\n', '            _seller,\n', '            _byTeam\n', '        );\n', '    }\n', '\n', '    function _isOnAuction(uint _tokenId)\n', '        internal constant returns (bool) {\n', '        return (tokenIdToAuction[_tokenId].startedAt > 0);\n', '    }\n', '\n', '    function isOnAuction(uint _tokenId)\n', '        external constant returns (bool) {\n', '        return _isOnAuction(_tokenId);\n', '    }\n', '\n', '    function removeAuction(uint _tokenId) public canWrite {\n', '        require(_isOnAuction(_tokenId));\n', '        delete tokenIdToAuction[_tokenId];\n', '        auctionsCounter--;\n', '    }\n', '\n', '    /// @dev Returns auction info for an NFT on auction.\n', '    /// @param _tokenId - ID of NFT on auction.\n', '    function getAuction(uint256 _tokenId)\n', '        external\n', '        constant\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 startingPrice,\n', '        uint256 endingPrice,\n', '        uint256 duration,\n', '        uint256 startedAt\n', '    ) {\n', '        Auction memory auction = tokenIdToAuction[_tokenId];\n', '        require(_isOnAuction(_tokenId));\n', '        return (\n', '            auction.seller,\n', '            auction.startingPrice,\n', '            auction.endingPrice,\n', '            auction.duration,\n', '            auction.startedAt\n', '        );\n', '    }\n', '\n', '    function getAuctionSeller(uint256 _tokenId)\n', '        public constant returns (address) {\n', '        return tokenIdToAuction[_tokenId].seller;\n', '    }\n', '\n', '    function getAuctionStartedAt(uint256 _tokenId)\n', '        public constant returns (uint) {\n', '        return tokenIdToAuction[_tokenId].startedAt;\n', '    }\n', '\n', '    function getAuctionEnd(uint _tokenId)\n', '        public constant returns (uint) {\n', '        Auction memory auction = tokenIdToAuction[_tokenId];\n', '        return auction.startedAt + auction.duration;\n', '    }\n', '\n', '    function getAuctionsCount() public constant returns (uint) {\n', '        return auctionsCounter;\n', '    }\n', '\n', '    function canBeCanceled(uint _tokenId) external constant returns (bool) {\n', '        return getAuctionEnd(_tokenId) <= now;\n', '    }\n', '\n', '    function isSecondary(uint _tokenId) public constant returns (bool _is) {\n', '        return (tokenIdToAuction[_tokenId].byTeam == false);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libs/EditionStorage.sol\n', '\n', 'contract EditionStorage is BaseStorage {\n', '\n', '    uint public offset = 1000000;\n', '    uint public offsetIndex = 1;\n', '    uint8[3] public defaultEditionLimits = [10, 89, 200];\n', '    mapping (uint => mapping (uint8 => uint8)) public editionCounts;\n', '    mapping (uint => mapping (uint8 => uint8)) public editionLimits;\n', '    mapping (uint => uint) public lastEditionOf;\n', '\n', '    function setOffset(uint _offset) external onlyOwner {\n', '        offset = _offset;\n', '    }\n', '\n', '    function getOffsetIndex() public constant returns (uint) {\n', '        return offset + offsetIndex;\n', '    }\n', '\n', '    function nextOffsetIndex() public canWrite {\n', '        offsetIndex++;\n', '    }\n', '\n', '    function canCreateEdition(uint _tokenId, uint8 _generation)\n', '        public constant returns (bool) {\n', '        uint8 actual = editionCounts[_tokenId][_generation - 1];\n', '        uint limit = editionLimits[_tokenId][_generation - 1];\n', '        return (actual < limit);\n', '    }\n', '\n', '    function isValidGeneration(uint8 _generation)\n', '        public constant returns (bool) {\n', '        return (_generation >= 1 && _generation <= 3);\n', '    }\n', '\n', '    function increaseGenerationCount(uint _tokenId, uint8 _generation)\n', '        public canWrite {\n', '        require(canCreateEdition(_tokenId, _generation));\n', '        require(isValidGeneration(_generation));\n', '        uint8 _generationIndex = _generation - 1;\n', '        editionCounts[_tokenId][_generationIndex]++;\n', '    }\n', '\n', '    function getEditionsCount(uint _tokenId)\n', '        external constant returns (uint8[3])  {\n', '        return [\n', '            editionCounts[_tokenId][0],\n', '            editionCounts[_tokenId][1],\n', '            editionCounts[_tokenId][2]\n', '        ];\n', '    }\n', '\n', '    function setLastEditionOf(uint _tokenId, uint _editionId)\n', '        public canWrite {\n', '        lastEditionOf[_tokenId] = _editionId;\n', '    }\n', '\n', '    function getEditionLimits(uint _tokenId)\n', '        external constant returns (uint8[3])  {\n', '        return [\n', '            editionLimits[_tokenId][0],\n', '            editionLimits[_tokenId][1],\n', '            editionLimits[_tokenId][2]\n', '        ];\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/libs/PaintingInformationStorage.sol\n', '\n', 'contract PaintingInformationStorage {\n', '\n', '    struct PaintingInformation {\n', '        string name;\n', '        string artist;\n', '    }\n', '\n', '    mapping (uint => PaintingInformation) public information;\n', '}\n', '\n', '// File: contracts/libs/PaintingStorage.sol\n', '\n', 'contract PaintingStorage is BaseStorage {\n', '\n', '    struct Painting {\n', '        uint parentId;\n', '        uint originalId;\n', '        uint createdAt;\n', '        uint completedAt;\n', '        uint8 generation;\n', '        uint8 speedIndex;\n', '        uint artistId;\n', '        uint releasedAt;\n', '        bool isFinal;\n', '    }\n', '\n', '    uint32[10] public speeds = [\n', '        uint32(8760 hours), // 365 days\n', '        uint32(6480 hours), // 270 days\n', '        uint32(4320 hours), // 180 days\n', '        uint32(2880 hours), // 120 days\n', '        uint32(1920 hours), // 80 days\n', '        uint32(960 hours), // 40 days\n', '        uint32(480 hours), // 20 days\n', '        uint32(240 hours), // 10 days\n', '        uint32(120 hours), // 5 days\n', '        uint32(24 hours) // 1 day\n', '    ];\n', '\n', '    uint32[10] public speedsTest = [\n', '        uint32(8760 seconds),\n', '        uint32(6480 seconds),\n', '        uint32(4320 seconds),\n', '        uint32(2880 seconds),\n', '        uint32(1920 seconds),\n', '        uint32(960 seconds),\n', '        uint32(480 seconds),\n', '        uint32(240 seconds),\n', '        uint32(120 seconds),\n', '        uint32(24 seconds)\n', '    ];\n', '\n', '    uint32[10] public speedsDev = [\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds),\n', '        uint32(0 seconds)\n', '    ];\n', '\n', '    mapping (uint => address) public paintingIndexToOwner;\n', '    mapping (uint => Painting) public paintings;\n', '    mapping (uint => address) public paintingIndexToApproved;\n', '    uint[] public paintingIds;\n', '    mapping (uint => uint) public paintingIdToIndex;\n', '    uint public paintingsCount;\n', '    uint public totalPaintingsCount;\n', '    mapping (uint => bool) public isCanceled;\n', '    mapping (uint => bool) public isReleased;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    // Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) public ownershipTokenCount;\n', '\n', '    modifier isNew(uint _tokenId) {\n', '        require(paintings[_tokenId].createdAt == 0);\n', '        _;\n', '    }\n', '\n', '    function exists(uint _tokenId) external constant returns (bool) {\n', '        return paintings[_tokenId].createdAt != 0;\n', '    }\n', '\n', '    function increaseOwnershipTokenCount(address _address) public canWrite {\n', '        ownershipTokenCount[_address]++;\n', '    }\n', '\n', '    function decreaseOwnershipTokenCount(address _address) public canWrite {\n', '        ownershipTokenCount[_address]--;\n', '    }\n', '\n', '    function setOwnership(uint _tokenId, address _address) public canWrite {\n', '        paintingIndexToOwner[_tokenId] = _address;\n', '    }\n', '\n', '    function getPainting(uint _tokenId) external constant returns (\n', '        address owner,\n', '        uint parent,\n', '        uint createdAt,\n', '        uint completedAt,\n', '        uint8 generation,\n', '        uint8 speed) {\n', '        return (\n', '            paintingIndexToOwner[_tokenId],\n', '            paintings[_tokenId].parentId,\n', '            paintings[_tokenId].createdAt,\n', '            paintings[_tokenId].completedAt,\n', '            paintings[_tokenId].generation,\n', '            paintings[_tokenId].speedIndex + 1\n', '        );\n', '    }\n', '\n', '    function approve(uint _tokenId, address _claimant) external canWrite {\n', '        paintingIndexToApproved[_tokenId] = _claimant;\n', '    }\n', '\n', '    function isApprovedFor(uint _tokenId, address _claimant) external constant returns (bool) {\n', '        return paintingIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function decreaseSpeed(uint _tokenId) public canWrite() {\n', '        uint8 _speed = paintings[_tokenId].speedIndex;\n', '\n', '        if (_speed > 0) {\n', '            paintings[_tokenId].speedIndex--;\n', '        }\n', '    }\n', '\n', '    function getPaintingOwner(uint _tokenId)\n', '        external constant returns (address) {\n', '        return paintingIndexToOwner[_tokenId];\n', '    }\n', '\n', '    function getPaintingGeneration(uint _tokenId)\n', '        public constant returns (uint8) {\n', '        return paintings[_tokenId].generation;\n', '    }\n', '\n', '    function getPaintingArtistId(uint _tokenId)\n', '        public constant returns (uint artistId) {\n', '        return paintings[_tokenId].artistId;\n', '    }\n', '\n', '    function getPaintingSpeed(uint _tokenId)\n', '        external constant returns (uint8) {\n', '        return paintings[_tokenId].speedIndex + 1;\n', '    }\n', '\n', '    function getPaintingOriginal(uint _tokenId)\n', '        external constant returns (uint) {\n', '        return paintings[_tokenId].originalId;\n', '    }\n', '\n', '    function getOwnershipTokenCount(address _address)\n', '        external constant returns (uint) {\n', '        return ownershipTokenCount[_address];\n', '    }\n', '\n', '    function isReady(uint _tokenId)\n', '        public constant returns (bool) {\n', '        return paintings[_tokenId].completedAt <= now;\n', '    }\n', '\n', '    function getPaintingIdAtIndex(uint _index)\n', '        public constant returns (uint) {\n', '        return paintingIds[_index];\n', '    }\n', '\n', '    function canBeChanged(uint _tokenId) public constant returns (bool _can) {\n', '        return paintings[_tokenId].isFinal == false;\n', '    }\n', '\n', '    function sealForChanges(uint _tokenId) public canWrite {\n', '        if (paintings[_tokenId].isFinal == false) {\n', '            paintings[_tokenId].isFinal = true;\n', '        }\n', '    }\n', '\n', '    function canBeBidden(uint _tokenId) public constant returns (bool _can) {\n', '        return (paintings[_tokenId].releasedAt <= now);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/BitpaintingStorage.sol\n', '\n', 'contract BitpaintingStorage is PaintingStorage, PaintingInformationStorage, AccessControlStorage, AuctionStorage, EditionStorage {\n', '\n', '    /// 0 = production mode\n', '    /// 1 = testing mode\n', '    /// 2 = development mode\n', '    uint8 mode;\n', '\n', '    function BitpaintingStorage(uint8 _mode) public {\n', '        require(_mode >= 0 && _mode <=2);\n', '        mode = _mode;\n', '    }\n', '\n', '    function hasEditionInProgress(uint _tokenId)\n', '        external constant returns (bool) {\n', '        uint edition = lastEditionOf[_tokenId];\n', '        if (edition == 0) {\n', '            return false;\n', '        }\n', '\n', '        return !isReady(edition);\n', '    }\n', '\n', '    function hasEmptyEditionSlots(uint _tokenId)\n', '        external constant returns (bool) {\n', '        uint originalId = paintings[_tokenId].originalId;\n', '        if (originalId == 0) {\n', '            originalId = _tokenId;\n', '        }\n', '        uint8 generation = paintings[_tokenId].generation;\n', '        uint8 limit = editionLimits[originalId][generation];\n', '        uint8 current = editionCounts[originalId][generation];\n', '        return (current < limit);\n', '    }\n', '\n', '    function resetPainting(uint _tokenId) public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        isCanceled[_tokenId] = true;\n', '        paintingsCount--;\n', '        delete paintings[_tokenId];\n', '    }\n', '\n', '    function createPainting(\n', '        address _owner,\n', '        uint _tokenId,\n', '        uint _parentId,\n', '        uint8 _generation,\n', '        uint8 _speed,\n', '        uint _artistId,\n', '        uint _releasedAt\n', '    ) public isNew(_tokenId) canWrite {\n', '        require(now <= _releasedAt);\n', '        require(_speed >= 1 && _speed <= 10);\n', '        _speed--;\n', '\n', '        uint _createdAt = now;\n', '        uint _completedAt;\n', '        if (_generation == 0) {\n', '            _completedAt = now;\n', '        } else {\n', '            uint _parentSpeed = paintings[_parentId].speedIndex;\n', '            if (mode == 2) {\n', '                _completedAt = now + speedsDev[_parentSpeed];\n', '            } else {\n', '                if (mode == 1) {\n', '                    _completedAt = now + speedsTest[_parentSpeed];\n', '                } else {\n', '                    _completedAt = now + speeds[_parentSpeed];\n', '                }\n', '            }\n', '        }\n', '\n', '        uint _originalId;\n', '        if (_generation == 0) {\n', '            _originalId = _tokenId;\n', '        } else {\n', '            if (_generation == 1) {\n', '                _originalId = _parentId;\n', '            } else {\n', '                _originalId = paintings[_parentId].originalId;\n', '            }\n', '        }\n', '\n', '        paintings[_tokenId] = Painting({\n', '            parentId: _parentId,\n', '            originalId: _originalId,\n', '            createdAt: _createdAt,\n', '            generation: _generation,\n', '            speedIndex: _speed,\n', '            completedAt: _completedAt,\n', '            artistId: _artistId,\n', '            releasedAt: _releasedAt,\n', '            isFinal: (_generation != 0) // if generation == 1 or 2 or 3, so it cannot be changed\n', '        });\n', '\n', '        if (!isReleased[_tokenId]) {\n', '            isReleased[_tokenId] = true;\n', '            paintingIds.push(_tokenId);\n', '            paintingIdToIndex[_tokenId] = totalPaintingsCount;\n', '            increaseOwnershipTokenCount(_owner);\n', '            totalPaintingsCount++;\n', '        }\n', '        isCanceled[_tokenId] = false;\n', '        setOwnership(_tokenId, _owner);\n', '        paintingsCount++;\n', '    }\n', '\n', '    function setEditionLimits(\n', '        uint _tokenId,\n', '        uint8 _gen1,\n', '        uint8 _gen2,\n', '        uint8 _gen3)\n', '        public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        editionLimits[_tokenId][0] = _gen1;\n', '        editionLimits[_tokenId][1] = _gen2;\n', '        editionLimits[_tokenId][2] = _gen3;\n', '    }\n', '\n', '    function resetEditionLimits(uint _tokenId) public canWrite {\n', '        setEditionLimits(_tokenId, 0, 0, 0);\n', '    }\n', '\n', '    function createEditionMeta(uint _tokenId) public canWrite {\n', '        uint _originalId = paintings[_tokenId].originalId;\n', '        nextOffsetIndex();\n', '        uint editionId = getOffsetIndex();\n', '        setLastEditionOf(_tokenId, editionId);\n', '\n', '        uint8 _generation = getPaintingGeneration(_tokenId) + 1;\n', '        increaseGenerationCount(_originalId, _generation);\n', '    }\n', '\n', '    function purgeInformation(uint _tokenId) public canWrite {\n', '        require(canBeChanged(_tokenId));\n', '\n', '        delete information[_tokenId];\n', '    }\n', '\n', '    function setPaintingName(uint _tokenId, string _name) public canWrite {\n', '        information[_tokenId].name = _name;\n', '    }\n', '\n', '    function setPaintingArtist(uint _tokenId, string _name) public canWrite {\n', '        information[_tokenId].artist = _name;\n', '    }\n', '\n', '    function getTokensOnAuction() public constant returns (uint[] tokens) {\n', '        tokens = new uint[](auctionsCounter);\n', '        uint pointer = 0;\n', '\n', '        for(uint index = 0; index < totalPaintingsCount; index++) {\n', '            uint tokenId = getPaintingIdAtIndex(index);\n', '\n', '            if (isCanceled[tokenId]) {\n', '                continue;\n', '            }\n', '\n', '            if (!_isOnAuction(tokenId)) {\n', '                continue;\n', '            }\n', '\n', '            tokens[pointer] = tokenId;\n', '            pointer++;\n', '        }\n', '    }\n', '\n', '    function getPaintingName(uint _tokenId) public constant returns (string) {\n', '        uint id = paintings[_tokenId].originalId;\n', '        return information[id].name;\n', '    }\n', '\n', '    function getPaintingArtist(uint _tokenId)\n', '        public constant returns (string) {\n', '        uint id = paintings[_tokenId].originalId;\n', '        return information[id].artist;\n', '    }\n', '\n', '    function signature() external constant returns (bytes4) {\n', '        return bytes4(keccak256("storage"));\n', '    }\n', '\n', '\n', '}']
