['pragma solidity ^0.4.17;\n', '\n', '/// @title Manages special access privileges of BankCore.\n', '/*** LoveBankAccessControl Contract adapted from CryptoKitty ***/\n', 'contract LoveBankAccessControl {\n', '\n', '    // This facet controls access control for LoveBank. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the BankCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from BankCore contract.\n', '    //\n', '    //     - The COO: The COO can set Free-Fee-Time.\n', '    //\n', '    // It should be noted that these roles are distinct without overlap in their access abilities, the\n', '    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n', "    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n", "    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n", '    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n', '    // account.\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newVerseContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused=false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '    \n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO is the address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO is the address of the new CFO\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO is the address of the new COO\n', '    function setCOO(address _newCOO) external onlyCEO {\n', '        require(_newCOO != address(0));\n', '        cooAddress = _newCOO;\n', '    }\n', '    \n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '}\n', '\n', '/// @title Love Account Base Contract for LoveBank. Holds all common structs, events and base \n', '///  variables for love accounts.\n', '/// @author Diana Kudrow <https://github.com/lovebankcrypto>\n', "/// @dev Create new account by couple ,deposit or bless by all, withdraw with both sides' confirmation\n", '\n', 'contract LoveAccountBase{\n', '\n', '    // An individual new contrat is build whenever a new couple create a new love account through the \n', '    // BankCore Contract. The love account contract plays seceral roles:\n', '    //\n', '    //     - Information Storage: owners names, wallet addresses, love-ID, their milestones in \n', '    //        relationship, diary……\n', '    //\n', '    //     - Balance Storage: each account keep their deposit in seperate contrat for safety and \n', '    //        privilege concern\n', '    //\n', '    //     - Access Control: only receive message from one of owners, triggered by bank for safety \n', '    //        reason\n', '    //     \n', '    //     - Deposit/Bless(fallback), Withdraw, BreakUp, MileStone, Diary: 5 main function of our \n', '    //        love bank\n', '\n', '    /*** EVENTS ***/\n', '    \n', '    /// @dev The Deposit event is fired whenever a value>0 ether is transfered into loveaccount\n', '    event Deposit(address _from, uint _value);\n', '    \n', '    /*** DATA TYPES ***/\n', '    /// @dev choices of all account status and milestones\n', '    enum Status{BreakUp, Active, RequestPending, FirstMet,  //0-3\n', '        FirstKiss, FirstConfess, InRelationship,FirstDate, //4-7\n', '        Proposal, Engage, WeddingDay, Anniversary, Trip,  //8-12\n', '        NewFamilyMember, FirstSex, Birthday,             //13-15\n', '        special1, special2, special3                  // 16-18\n', '    }\n', '\n', '    struct StonePage {\n', '    \tuint64 logtime;\n', '    \tStatus contant;\n', '    }\n', '\n', '    struct DiaryPage {\n', '    \tuint64 logtime;\n', '    \tbytes contant;\n', '    }\n', '\n', '    /*** STORAGE ***/\n', '    \n', '    /// @dev Nicename of the FOUNDER of this love account\n', '    bytes32 public name1;\n', '\n', "    /// @dev Nicename of the FOUNDER's lover\n", '    bytes32 public name2;\n', '\n', '    /// @dev Address of the FOUNDER of this love account\n', '    address public owner1;\n', '\n', "    /// @dev Address of the FOUNDER's lover\n", '    address public owner2;\n', '\n', '    /// @dev contract address of Love Bank, for access control\n', '    address BANKACCOUNT;\n', '\n', '    /// @dev Keep track of who is withdrawing money during double-sig pending time\n', '    address withdrawer;\n', '\n', '    /// @dev Keep track of how much is withdrawing money during double-sig pending time\n', '    uint256 request_amount;\n', '\n', '    /// @dev Keep track of service charge during double-sig pending time\n', '    uint256 request_fee;\n', '\n', '    /// @dev One and unique LoveID of this account, smaller if sign up early\n', '    uint64 public loveID;\n', '\n', '    /// @dev Time stamp of found moment\n', '    uint64 public foundTime=uint64(now);\n', '\n', '    /// @dev diary index log, public\n', '    uint64 public next_diary_id=0;\n', '\n', '    /// @dev milestone index log, public\n', '    uint64 public next_stone_id=0;\n', '\n', '    /// @dev Status of the account: BreakUp, Active(defult), RequestPending\n', '    Status public status=Status.Active;\n', '    \n', '    /// @dev A mapping from timestamp to Status. Keep track of all Memory Moment for lovers\n', '    mapping (uint64=>StonePage) public milestone;\n', '\n', '    /// @dev A mapping from timestamp to bytes. Lovers can keep whatever words on ethereum eternally\n', '    mapping (uint64=>DiaryPage) public diary;\n', '\n', '    /// @dev Initiate love account when first found\n', '    function LoveAccountBase (\n', '        bytes32 _name1,\n', '        bytes32 _name2,\n', '        address _address1,\n', '        address _address2,\n', '        uint64 _loveID) public {\n', '            name1 = _name1;\n', '            name2 = _name2;\n', '            owner1 = _address1;\n', '            owner2 = _address2;\n', '            loveID = _loveID;\n', '            BANKACCOUNT = msg.sender;\n', '    }\n', '    /// @dev Modifier to allow actions only when the account is not Breakup\n', '    modifier notBreakup() {require(uint(status)!=0);_;}\n', '\n', '    /// @dev Modifier to allow actions only when the call was sent by one of owners\n', '    modifier oneOfOwners(address _address) {\n', '        require (_address==owner1 || _address==owner2);_;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when message sender is Bank\n', '    modifier callByBank() {require(msg.sender == BANKACCOUNT);_;}\n', '    \n', '    /// @dev Rarely used! Only happen when extreme circumstances\n', '    function changeBankAccount(address newBank) external callByBank{\n', '        require(newBank!=address(0));\n', '        BANKACCOUNT = newBank;\n', '    }\n', '\n', '    /// @dev THINK TWICE! If you breakup with your lover, all your balance will transfer to your\n', "    ///  lover's account, AND you cannot re-activate this very account! Think about your sweet\n", "    ///  moments before you hurt someone's heart!!\n", '    function breakup(\n', '        address _breaker, uint256 _fee) external payable \n', '        notBreakup oneOfOwners(_breaker) callByBank{\n', '        if(_fee!=0){BankCore(BANKACCOUNT).receiveFee.value(_fee)();}\n', '        if(_breaker==owner1) {owner2.transfer(this.balance);}\n', '        if(_breaker==owner2) {owner1.transfer(this.balance);}\n', '        status=Status.BreakUp;\n', '    }\n', '    \n', '    /// @dev Log withdraw info when first receice request \n', '    function withdraw(uint256 amount, \n', '        address _to, uint256 _fee) external notBreakup oneOfOwners(_to) callByBank{\n', '        require(this.balance>=amount);\n', '        // change status to pending\n', '        status =Status.RequestPending;\n', '        request_amount = amount;\n', '        withdrawer = _to;\n', '        request_fee = _fee;\n', '    }\n', '\n', '    /// @dev Confirm request and send money; erase info logs\n', '    function withdrawConfirm(\n', '        uint256 _amount, \n', '        address _confirmer) external payable notBreakup oneOfOwners(_confirmer) callByBank{\n', '        // check for matching withdraw request\n', '        require(uint(status)==2);\n', '        require(_amount==request_amount);\n', '        require(_confirmer!=withdrawer);\n', '        require(this.balance>=request_amount);\n', '        \n', '        // send service fee to bank\n', '        if(request_fee!=0){BankCore(BANKACCOUNT).receiveFee.value(request_fee)();}\n', '        withdrawer.transfer(request_amount-request_fee);\n', '\n', '        // clean pending log informations\n', '        status=Status.Active;\n', '        withdrawer=address(0);\n', '        request_amount=0;\n', '        request_fee=0;\n', '    }\n', '    \n', '    /// @dev Log big events(pre-set-choice) in relationship, time stamp is required\n', '    function mileStone(address _sender, uint64 _time, uint8 _choice) external notBreakup oneOfOwners(_sender) callByBank {\n', '        milestone[next_stone_id]=StonePage({\n', '        \tlogtime: _time,\n', '        \tcontant: Status(_choice)\n', '        });\n', '        next_stone_id++;\n', '    }\n', '\n', '    /// @dev Log diary, time stamp is now\n', '    function Diary(address _sender, bytes _diary) external notBreakup oneOfOwners(_sender) callByBank {\n', '        diary[next_diary_id]=DiaryPage({\n', '        \tlogtime: uint64(now),\n', '        \tcontant: _diary\n', '        });\n', '        next_diary_id++;  \n', '    }\n', '    \n', '    // @dev Fallback function for deposit and blessing income\n', '    function() external payable notBreakup {\n', '        require(msg.value>0);\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', '\n', '/// @title Basic contract of LoveBank that defines the Creating, Saving, and Using of love \n', '/// accounts under the protect of one Bank contract.\n', '/// @author Diana Kudrow <https://github.com/lovebankcrypto>\n', 'contract Bank is LoveBankAccessControl{\n', '\n', '    /*** EVENTS ***/\n', '\n', '    /// @dev Create event is fired whenever a new love account is created, and a new contract\n', '    ///  address is created \n', '    event Create(bytes32 _name1, bytes32 _name2, address _conadd, \n', '                address _address1, address _address2, uint64 _loveID);\n', '    /// @dev Breakup event is fired when someone breakup with another\n', '    event Breakup(uint _time);\n', '    /// @dev StoneLog event returns when love account log a milestone\n', '    event StoneLog(uint _time, uint _choice);\n', '    /// @dev DiaryLog event returns when love account log a diary\n', '    event DiaryLog(uint _time, bytes _contant);\n', '    /// @dev Withdraw event returns when a user trigger a withdrow demand\n', '    event Withdraw(uint _amount, uint _endTime);\n', '    /// @dev WithdrawConfirm event returns when a withdraw demand is confirmed and accomplished\n', '    event WithdrawConfirm(uint _amount, uint _confirmTime);\n', '\n', '    /*** DATA TYPES ***/\n', '    \n', '    struct pending {\n', '        bool pending;\n', '        address withdrawer;\n', '        uint256 amount;\n', '        uint256 fee;\n', '        uint64 endTime;\n', '    }\n', '\n', '    /*** CONSTANTS ***/\n', '\n', '    /// @dev constant variables\n', '    uint256 STONE_FEE=4000000000000000;\n', '    uint256 OPEN_FEE=20000000000000000;\n', '    uint64 FREE_START=0;\n', '    uint64 FREE_END=0;\n', '    uint64 WD_FEE_VERSE=100;  // 1% service fee\n', '    uint64 BU_FEE_VERSE=50;   // 2% service fee\n', '    uint32 public CONFIRM_LIMIT = 900; //15mins\n', '\n', '    /*** STORAGE ***/\n', '\n', '    /// @dev The ID of the next signing couple, also the number of current signed accounts\n', '    uint64 public next_id=0; \n', "    /// @dev A mapping from owers addresses' sha256 to love account address\n", '    mapping (bytes16 => address)  public sig_to_add;\n', '    /// @dev A mapping from love account address to withdraw demand detail\n', '    mapping (address => pending) public pendingList;\n', '    \n', '    /// @dev Create a new love account and log in Bank\n', '    /// @param name1 is nicename of the FOUNDER of this love account\n', "    /// @param name2 is nicename of the FOUNDER's lover\n", '    /// @param address1 is address of the FOUNDER of this love account, need to be msg.sender\n', "    /// @param address2 is address of the FOUNDER's lover\n", '    function createAccount(\n', '        bytes32 name1,\n', '        bytes32 name2,\n', '        address address1,\n', '        address address2) external payable whenNotPaused {\n', '        uint fee;\n', '        // calculate open account service fee\n', '        if (_ifFree()){fee=0;} else{fee=OPEN_FEE;}\n', '        require(msg.sender==address1   &&\n', '                address1!=address2     && \n', '                address1!=address(0)   &&\n', '                address2!=address(0)   &&\n', '                msg.value>=fee);\n', '        require(_ifFree() || msg.value >= OPEN_FEE);\n', "        // Same couple can only created love account once. Addresses' keccak256 is logged\n", '        bytes16 sig = bytes16(keccak256(address1))^bytes16(keccak256(address2));\n', '        require(sig_to_add[sig]==0);\n', '        // New contract created\n', '        address newContract = (new LoveAccountBase)(name1, name2, address1, address2, next_id);\n', '        sig_to_add[sig]=newContract;\n', '        Create(name1, name2, newContract, address1, address2, next_id);\n', '        // First deposit\n', '        if(msg.value>fee){\n', '            newContract.transfer(msg.value-fee);\n', '        }\n', '        next_id++;\n', '    }\n', '    \n', '    /// @dev Calculate service fee; to avoid ufixed data type, dev=(1/charge rate)\n', '    /// @param _dev is inverse of charging rate. If service fee is 1%, _dev=100\n', '    function _calculate(uint256 _amount, uint _dev) internal pure returns(uint256 _int){\n', '        _int = _amount/uint256(_dev);\n', '    }\n', '\n', '    /// @dev If now is during service-free promotion, return true; else return false\n', '    function _ifFree() view internal returns(bool) {\n', '        if(uint64(now)<FREE_START || uint64(now)>FREE_END\n', '            ) {return false;\n', '        } else {return true;}\n', '    }\n', '\n', '    /// @dev THINK TWICE! If you breakup with your lover, all your balance will transfer \n', "    ///  to your lover's account, AND you cannot re-activate this very account! Think about \n", "    ///  your sweet moments before you hurt someone's heart!!\n", '    /// @param _conadd is contract address of love account\n', '    function sendBreakup(address _conadd) external whenNotPaused {\n', '        if (_ifFree()){\n', '            // Call function in love account contract\n', '            LoveAccountBase(_conadd).breakup(msg.sender,0);}\n', '        else{\n', '            uint _balance = _conadd.balance;\n', '            uint _fee = _calculate(_balance, BU_FEE_VERSE);\n', '            // Call function in love account contract\n', '            LoveAccountBase(_conadd).breakup(msg.sender,_fee);}\n', '        Breakup(now);\n', '     }\n', '\n', '    /// @dev Log big events(pre-set-choice) in relationship, time stamp is required\n', '    /// @param _conadd is contract address of love account\n', '    /// @param _time is time stamp of the time of event\n', '    /// @param _choice is uint of enum. See Love Account Base to understand how milestone work\n', '    function sendMileStone(\n', '        address _conadd, uint _time, \n', '        uint _choice) external payable whenNotPaused {\n', '        require(msg.value >= STONE_FEE);\n', '        uint8 _choice8 = uint8(_choice);\n', '        require(_choice8>2 && _choice8<=18);\n', '        // Call function in love account contract\n', '        LoveAccountBase(_conadd).mileStone(msg.sender, uint64(_time), _choice8);\n', '        StoneLog(_time, _choice8);\n', '    }\n', '    \n', '    /// @dev Log diary, time stamp is now\n', '    /// @param _conadd is contract address of love account\n', '    function sendDiary(address _conadd, bytes _diary) external whenNotPaused{\n', '        LoveAccountBase(_conadd).Diary(msg.sender, _diary);\n', '        DiaryLog(now, _diary);\n', '    }\n', '    \n', '    /// @dev Log withdraw info when first receice request\n', '    /// @param _conadd is contract address of love account\n', '    /// @param _amount is the amount of money to withdraw in unit wei\n', '    function bankWithdraw(address _conadd, uint _amount) external whenNotPaused{\n', '        // Make sure no valid withdraw is pending\n', '        require(!pendingList[_conadd].pending || now>pendingList[_conadd].endTime);\n', '        uint256 _fee;\n', '        uint256 _amount256 = uint256(_amount); \n', '        require(_amount256==_amount);\n', '\n', '        // Fee calculation\n', '        if (_ifFree()){_fee=0;}else{_fee=_calculate(_amount, WD_FEE_VERSE);}\n', '\n', '        // Call function in love account contract\n', '        LoveAccountBase _conA = LoveAccountBase(_conadd);\n', '        _conA.withdraw(_amount, msg.sender, _fee);\n', '\n', '        // Log detail info for latter check\n', '        uint64 _end = uint64(now)+CONFIRM_LIMIT;\n', '        pendingList[_conadd] = pending({\n', '                    pending:true,\n', '                    withdrawer:msg.sender,\n', '                    amount: _amount256,\n', '                    fee:_fee,\n', '                    endTime: _end});\n', '        Withdraw(_amount256, _end);\n', '    }\n', '\n', '    /// @dev Confirm request and send money; erase info logs\n', '    /// @param _conadd is contract address of love account \n', '    /// @param _amount is the amount of money to withdraw in unit wei\n', '    function bankConfirm(address _conadd, uint _amount) external whenNotPaused{\n', '        // Confirm matching request\n', '        uint256 _amount256 = uint256(_amount); \n', '        require(_amount256==_amount);\n', '        require(pendingList[_conadd].pending && now<pendingList[_conadd].endTime);\n', '        require(pendingList[_conadd].withdrawer != msg.sender);\n', '        require(pendingList[_conadd].amount == _amount);\n', '\n', '        // Call function in love account contract\n', '        LoveAccountBase(_conadd).withdrawConfirm(_amount, msg.sender);\n', '\n', '        // Clean pending information\n', '        delete pendingList[_conadd];\n', '        WithdrawConfirm(_amount, now);\n', '    }\n', '}\n', '\n', '/// @title Promotion contract of LoveBank. \n', '/// @author Diana Kudrow <https://github.com/lovebankcrypto>\n', '/// @dev All CLevel OPs, for promotion. CFO can define free-of-charge time, and CEO can lower the \n', "///  service fee. (Yeah, we won't raise charge for sure, it's in the contrat!) \n", 'contract LovePromo is Bank{\n', '\n', '    /// @dev Withdraw your money for FREEEEEE! Or too if you wanna break up\n', '    /// @param _start is time stamp of free start time\n', '    /// @param _end is time stamp of free end time\n', '    function setFreeTime(uint _start, uint _end) external onlyCOO {\n', '        require(_end>=_start && _start>uint64(now));\n', '        FREE_START = uint64(_start);\n', '        FREE_END = uint64(_end);\n', '    }\n', '\n', '\n', '    /// @dev Set new charging rate\n', '    /// @param _withdrawFee is inverse of charging rate to avoid ufixed data type. \n', '    ///  _withdrawFee=(1/x). If withdraw fee is 1%, _withdrawFee=100\n', '    /// @param _breakupFee is inverse of charging rate to avoid ufixed data type. \n', '    ///  _breakupFee=(1/x). If breakup fee is 2%, _breakupFee=50\n', '    /// @param _stone is Milestone logging fee, wei (diary is free of charge, cost only gas)\n', '    /// @param _open is Open account fee, wei\n', '\n', '    function setFee(\n', '        uint _withdrawFee, \n', '        uint _breakupFee, \n', '        uint _stone, \n', '        uint _open) external onlyCEO {\n', '\n', '        /// Service fee of withdraw NO HIGHER THAN 1%\n', '        require(_withdrawFee>=100);\n', '        /// Service fee of breakup NO HIGHER THAN 2%\n', '        require(_breakupFee>=50);\n', '\n', '        WD_FEE_VERSE = uint64(_withdrawFee);\n', '        BU_FEE_VERSE = uint64(_breakupFee);\n', '        STONE_FEE = _stone;\n', '        OPEN_FEE = _open;\n', '    }\n', '\n', '    /// @dev CEO might extend the confirm time limit when Etherum Network is blocked\n', '    /// @param _newlimit uses second as a unit\n', '    function setConfirm(uint _newlimit) external onlyCEO {\n', '        CONFIRM_LIMIT = uint32(_newlimit);\n', '    }\n', '\n', '    /// @dev Just for checking\n', '    function getFreeTime() external view onlyCLevel returns(uint64 _start, uint64 _end){\n', '        _start = uint64(FREE_START);\n', '        _end = uint64(FREE_END);\n', '    }\n', '    \n', '    /// @dev Just for checking\n', '    function getFee() external view onlyCLevel returns(\n', '        uint64 _withdrawFee, \n', '        uint64 _breakupFee, \n', '        uint _stone, \n', '        uint _open){\n', '\n', '        _withdrawFee = WD_FEE_VERSE;\n', '        _breakupFee = BU_FEE_VERSE;\n', '        _stone = STONE_FEE;\n', '        _open = OPEN_FEE;\n', '    }\n', '}\n', '\n', '/// @title Love Bank, a safe place for lovers to save money money for future and get bless from\n', '///  strangers and keep eternally on Etherum blockchain\n', '/// @author Diana Kudrow <https://github.com/lovebankcrypto>\n', '/// @dev The main LoveBank contract, keep track of all love accounts and their contracts, double\n', '///  security check before any operations\n', 'contract BankCore is LovePromo {\n', '\n', '    // This is the main LoveBank contract. The function of our DApp is quite straight forward:\n', '    //  to create a account for couple, which is displayed on our website. Owers can put money in \n', '    //  as well as strangers. Withdraw request can only be done with both owners permission.\n', '    //  In honor of eternal love, the party who puts forward a breakup will transfer all the remain\n', '    //  balance to the other party by default.\n', '    // \n', '    //  To make the contract more logical, we simple seperate our contract in following parts:\n', '    //\n', '    //      - LoveBankAccessControl: This contract manages the various addresses and constraints for \n', '    //             operations that can be executed only by specific roles. Namely CEO, CFO and COO.\n', '    //\n', '    //      - Bank is LoveBankAccessControl: In this contract we define the main stucture of our \n', '    //              Love Bank and the methord to create accounts. Also, all the operations of users are\n', '    //              defined here, like money withdraw, breakup, diary, milestones. Lots of modifiers\n', "    //              are used to protect user's safety.\n", '    //\n', '    //      - LovePromo is Bank: Here are some simple operations for COO to set free-charge time and for CEO\n', '    //              to lower the charge rate.\n', '    //\n', '    //      - BankCore is LovePromo: inherit all previous contract. Contains all the big moves, like: \n', '    //              creating a bank, set defult C-Level users, unpause, update (only when hugh bug happens),\n', '    //              withdraw money, etc.\n', '    //\n', '    //      - LoveAccountBase: This contract is the contract of a love account. Holds all common structs,\n', '    //              events and base variables for love accounts.\n', '\n', '\n', '    // Set in case the core contract is broken and an upgrade is required\n', '    address public newContractAddress;\n', '\n', '    /// @dev DepositBank is fired when ether is received from CLevel to BankCore Contract\n', '    event DepositBank(address _sender, uint _value);\n', '\n', '    function BankCore() public {\n', '        // Starts paused.\n', '        paused = true;\n', '        // the creator of the contract is the initial CEO\n', '        ceoAddress = msg.sender;\n', '        // the creator of the contract is also the initial COO\n', '        cooAddress = msg.sender;\n', '        // the creator of the contract is also the initial COO\n', '        cfoAddress = msg.sender;\n', '    }\n', '\n', '    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n', '    ///  breaking bug. This method does nothing but keep track of the new contract and\n', "    ///  emit a message indicating that the new address is set. It's up to clients of this\n", '    ///  contract to update to the new contract address in that case. (This contract will\n', '    ///  be paused indefinitely if such an upgrade takes place.)\n', '    /// @param _v2Address new address\n', '    /*** setNewAddress adapted from CryptoKitty ***/\n', '    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n', '        newContractAddress = _v2Address;\n', '        ContractUpgrade(_v2Address);\n', '    }\n', '\n', '    /// @dev Override unpause so it requires all external contract addresses\n', "    ///  to be set before contract can be unpaused. Also, we can't have\n", '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    function unpause() public onlyCEO whenPaused {\n', '        require(newContractAddress == address(0));\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '    \n', '    /// @dev Rarely used! Only happen when extreme circumstances\n', '    /// @param _conadd is contract address of love account\n', '    /// @param newBank is newBank contract addess if updated\n', '    function changeBank(address _conadd, address newBank) external whenPaused onlyCEO{\n', '        require(newBank != address(0));\n', '        LoveAccountBase(_conadd).changeBankAccount(newBank);\n', '    }\n', '\n', '    /// @dev Allows the CFO to capture the balance of Bank contract\n', '    function withdrawBalance() external onlyCFO {\n', '        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n', '        if (this.balance > 0) {\n', '            cfoAddress.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    /// @dev Get Love account contrat address through Bank contract index\n', '    function getContract(address _add1, address _add2) external view returns(address){\n', '        bytes16 _sig = bytes16(keccak256(_add1))^bytes16(keccak256(_add2));\n', '        return sig_to_add[_sig];\n', '    }\n', '    \n', '    /// @dev Receive service fee from sub contracts\n', '    function receiveFee() external payable{}\n', '    \n', '    /// @dev Reject all deposit from outside CLevel accounts\n', '    function() external payable onlyCLevel {\n', '        require(msg.value>0);\n', '        DepositBank(msg.sender, msg.value);\n', '    }\n', '}']