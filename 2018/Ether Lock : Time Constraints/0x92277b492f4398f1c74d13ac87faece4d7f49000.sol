['pragma solidity ^0.4.15;\n', '\n', '    /****************************************************************\n', '     *\n', '     * Name of the project: Genevieve GXVC New ICO\n', '     * Contract name: NewIco\n', '     * Author: Juan Livingston @ Ethernity.live\n', '\t *\n', '     ****************************************************************/\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  function burn(address spender, uint256 value) returns (bool); // Optional \n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC223 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  \n', '  function name() constant returns (string _name);\n', '  function symbol() constant returns (string _symbol);\n', '  function decimals() constant returns (uint8 _decimals);\n', '  function totalSupply() constant returns (uint256 _supply);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transfer(address to, uint value, bytes data) returns (bool ok);\n', '  function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', 'contract Whitelist {\n', '  mapping (address => bool) public registered;\n', '}\n', '\n', 'contract IcoExt {\n', '\n', '    address public authorizedCaller;\n', '    address public collectorAddress;\n', '    address public owner;\n', '    address public whitelistAdd;\n', '\n', '    address public tokenAdd; \n', '    address public tokenSpender;\n', '\n', '    uint public initialPrice;\n', '    uint public initialTime;\n', '    uint tokenPrice;\n', '\n', '    uint increasePerBlock;\n', '    uint increasePerBlockDiv;\n', '\n', '    bool public autoPrice;\n', '    bool public isPaused;\n', '\n', '    uint public minAcceptedETH;\n', '\n', '    uint public tokenDecimals;\n', '    uint public tokenMult;\n', '\n', '    uint8 public stage;\n', '\n', '    // Main counters\n', '\n', '    uint public totalReceived;\n', '    uint public totalSent;\n', '\n', '    // Constructor function with main constants and variables \n', ' \n', ' \tfunction IcoExt() {\n', '\t    authorizedCaller = msg.sender;\n', '\t    owner = msg.sender;\n', '\n', '      collectorAddress = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f;\n', '\t    tokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a;\n', '      tokenSpender = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f;\n', '\n', '      whitelistAdd = 0xad56C554f32D51526475d541F5DeAabE1534854d;\n', '\n', '\t    autoPrice = true;\n', '\t    authorized[authorizedCaller] = true;\n', '\n', '      minAcceptedETH = 0.05 ether;\n', '\n', '\t    tokenDecimals = 10;\n', '\t    tokenMult = 10 ** tokenDecimals;\n', '\n', '\t   \tinitialPrice = 10000 * tokenMult; // 10,000 tokens per ether (0,0001 eth/token)\n', '      tokenPrice = initialPrice;\n', '      autoPrice = false;\n', '\n', '\t    initialTime = now; // 1521590400; // March 21st, 2018\n', '\t    increasePerBlock = 159; // Percentage to add per each block respect original price, in cents\n', '\t    increasePerBlockDiv = 1000000000; // According to specs: 1,59% x 10 ^ -5 (= 159 / 10 ^ 7)\n', '\n', '\t    stage = 0;\n', '\t}\n', '\n', '\n', '\t// Mapping to store swaps made and authorized callers\n', '\n', '    mapping(address => uint) public receivedFrom;\n', '    mapping(address => uint) public sentTo;\n', '    mapping(address => bool) public authorized;\n', '\n', '    // Event definitions\n', '\n', '    event TokensSent(address _address , uint _received , uint _sent);\n', '\n', '    // Modifier for authorized calls\n', '\n', '    modifier isAuthorized() {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier isNotPaused() {\n', '    \trequire(!isPaused);\n', '    \t_;\n', '    }\n', '\n', '    // Function borrowed from ds-math.\n', '\n', '    function mul(uint x, uint y) internal returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    // Falback function, invoked each time ethers are received\n', '\n', '    function () payable { \n', '        makeSwapInternal();\n', '    }\n', '\n', '\n', '    // Ether swap, activated by the fallback function after receiving ethers\n', '\n', '   function makeSwapInternal() private isNotPaused { // Main function, called internally when ethers are received\n', '\n', '   \trequire(stage>0 && stage<3 && msg.value >= minAcceptedETH);\n', '\n', '    Whitelist wl = Whitelist(whitelistAdd);\n', '\n', '   \tif (stage==1 || stage==2 ) require(wl.registered(msg.sender));\n', '\n', '    ERC223 GXVCtoken = ERC223(tokenAdd);\n', '\n', '    address _address = msg.sender;\n', '    uint _value = msg.value;\n', '    uint _price = getPrice();\n', '\n', '\t  uint tokensToSend = _price * _value / 10 ** 18;\n', '\n', '    receivedFrom[_address] += _value;\n', '    totalReceived += _value;\n', '    sentTo[_address] += tokensToSend;\n', '    totalSent = tokensToSend;\n', '\n', '    //Send tokens\n', '    require(GXVCtoken.transferFrom(tokenSpender,_address,tokensToSend));\n', '\t// Log tokens sent for ethers;\n', '    TokensSent(_address,_value,tokensToSend);\n', '    // Send ethers to collector\n', '    require(collectorAddress.send(_value));\n', '    }\n', '\n', '  \n', '\n', 'function getPrice() constant public returns(uint _price){\n', '    if (autoPrice) {\n', '        return calculatePrice(now);\n', '    \t} else {\n', '    \t\treturn tokenPrice;\n', '    \t\t}\n', '}\n', '\n', 'function getCurrentStage() public constant returns(uint8 _stage){\n', '\treturn stage;\n', '}\n', '\n', 'function calculatePrice(uint _when) constant public returns(uint _result){\n', '\tif (_when == 0) _when = now;\n', '\t// 25 are estimated of 25 seconds per block\n', '\tuint delay = (_when - initialTime) / 25;\n', '\tuint factor = delay * increasePerBlock;\n', '\tuint multip = initialPrice * factor;\n', '\tuint result = initialPrice - multip / increasePerBlockDiv / 100; // 100 = percent\n', '\trequire (result<=initialPrice);\n', '\treturn result;\n', '   \t//return initialPrice - initialPrice * (_when - initialTime) / 25 * increasePerBlock / increasePerBlockDiv;\n', '}\n', '\n', '\n', 'function changeToStage(uint8 _stage) isAuthorized returns(bool) {\n', '\trequire(stage<_stage && _stage < 4);\n', '\tstage = _stage;\n', '\treturn true;\n', '}\n', '\n', 'function pause() public isAuthorized {\n', '\tisPaused = true;\n', '}\n', '\n', 'function resume() public isAuthorized {\n', '\tisPaused = false;\n', '}\n', '\n', 'function setManualPrice(uint _price) public isAuthorized {\n', '    autoPrice = false;\n', '    tokenPrice = _price;\n', '}\n', '\n', 'function setAutoPrice() public isAuthorized {\n', '    autoPrice = true;\n', '}\n', '\n', 'function setInitialTime() public isAuthorized {\n', '    initialTime = now;\n', '}\n', '\n', 'function getNow() public constant returns(uint _now){\n', '\treturn now;\n', '}\n', '\n', 'function flushEthers() public isAuthorized { // Send ether to collector\n', '  require( collectorAddress.send( this.balance ) );\n', '}\n', '\n', 'function changeMinAccEthers(uint _newMin) public isAuthorized {\n', '  minAcceptedETH = _newMin;\n', '}\n', '\n', 'function addAuthorized(address _address) public isAuthorized {\n', '\tauthorized[_address] = true;\n', '\n', '}\n', '\n', 'function removeAuthorized(address _address) public isAuthorized {\n', '\trequire(_address != owner);\n', '\tauthorized[_address] = false;\n', '}\n', '\n', 'function changeOwner(address _address) public {\n', '\trequire(msg.sender == owner);\n', '\towner = _address;\n', '}\n', '\n', '// To manage ERC20 tokens in case of accidental sending to the contract\n', '\n', 'function sendTokens(address _address , uint256 _amount) isAuthorized returns (bool success) {\n', '    ERC20Basic token = ERC20Basic( tokenAdd );\n', '    require( token.transfer(_address , _amount ) );\n', '    return true;\n', '}\n', '\n', '\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '    /****************************************************************\n', '     *\n', '     * Name of the project: Genevieve GXVC New ICO\n', '     * Contract name: NewIco\n', '     * Author: Juan Livingston @ Ethernity.live\n', '\t *\n', '     ****************************************************************/\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  function burn(address spender, uint256 value) returns (bool); // Optional \n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC223 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  \n', '  function name() constant returns (string _name);\n', '  function symbol() constant returns (string _symbol);\n', '  function decimals() constant returns (uint8 _decimals);\n', '  function totalSupply() constant returns (uint256 _supply);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transfer(address to, uint value, bytes data) returns (bool ok);\n', '  function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', 'contract Whitelist {\n', '  mapping (address => bool) public registered;\n', '}\n', '\n', 'contract IcoExt {\n', '\n', '    address public authorizedCaller;\n', '    address public collectorAddress;\n', '    address public owner;\n', '    address public whitelistAdd;\n', '\n', '    address public tokenAdd; \n', '    address public tokenSpender;\n', '\n', '    uint public initialPrice;\n', '    uint public initialTime;\n', '    uint tokenPrice;\n', '\n', '    uint increasePerBlock;\n', '    uint increasePerBlockDiv;\n', '\n', '    bool public autoPrice;\n', '    bool public isPaused;\n', '\n', '    uint public minAcceptedETH;\n', '\n', '    uint public tokenDecimals;\n', '    uint public tokenMult;\n', '\n', '    uint8 public stage;\n', '\n', '    // Main counters\n', '\n', '    uint public totalReceived;\n', '    uint public totalSent;\n', '\n', '    // Constructor function with main constants and variables \n', ' \n', ' \tfunction IcoExt() {\n', '\t    authorizedCaller = msg.sender;\n', '\t    owner = msg.sender;\n', '\n', '      collectorAddress = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f;\n', '\t    tokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a;\n', '      tokenSpender = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f;\n', '\n', '      whitelistAdd = 0xad56C554f32D51526475d541F5DeAabE1534854d;\n', '\n', '\t    autoPrice = true;\n', '\t    authorized[authorizedCaller] = true;\n', '\n', '      minAcceptedETH = 0.05 ether;\n', '\n', '\t    tokenDecimals = 10;\n', '\t    tokenMult = 10 ** tokenDecimals;\n', '\n', '\t   \tinitialPrice = 10000 * tokenMult; // 10,000 tokens per ether (0,0001 eth/token)\n', '      tokenPrice = initialPrice;\n', '      autoPrice = false;\n', '\n', '\t    initialTime = now; // 1521590400; // March 21st, 2018\n', '\t    increasePerBlock = 159; // Percentage to add per each block respect original price, in cents\n', '\t    increasePerBlockDiv = 1000000000; // According to specs: 1,59% x 10 ^ -5 (= 159 / 10 ^ 7)\n', '\n', '\t    stage = 0;\n', '\t}\n', '\n', '\n', '\t// Mapping to store swaps made and authorized callers\n', '\n', '    mapping(address => uint) public receivedFrom;\n', '    mapping(address => uint) public sentTo;\n', '    mapping(address => bool) public authorized;\n', '\n', '    // Event definitions\n', '\n', '    event TokensSent(address _address , uint _received , uint _sent);\n', '\n', '    // Modifier for authorized calls\n', '\n', '    modifier isAuthorized() {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier isNotPaused() {\n', '    \trequire(!isPaused);\n', '    \t_;\n', '    }\n', '\n', '    // Function borrowed from ds-math.\n', '\n', '    function mul(uint x, uint y) internal returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    // Falback function, invoked each time ethers are received\n', '\n', '    function () payable { \n', '        makeSwapInternal();\n', '    }\n', '\n', '\n', '    // Ether swap, activated by the fallback function after receiving ethers\n', '\n', '   function makeSwapInternal() private isNotPaused { // Main function, called internally when ethers are received\n', '\n', '   \trequire(stage>0 && stage<3 && msg.value >= minAcceptedETH);\n', '\n', '    Whitelist wl = Whitelist(whitelistAdd);\n', '\n', '   \tif (stage==1 || stage==2 ) require(wl.registered(msg.sender));\n', '\n', '    ERC223 GXVCtoken = ERC223(tokenAdd);\n', '\n', '    address _address = msg.sender;\n', '    uint _value = msg.value;\n', '    uint _price = getPrice();\n', '\n', '\t  uint tokensToSend = _price * _value / 10 ** 18;\n', '\n', '    receivedFrom[_address] += _value;\n', '    totalReceived += _value;\n', '    sentTo[_address] += tokensToSend;\n', '    totalSent = tokensToSend;\n', '\n', '    //Send tokens\n', '    require(GXVCtoken.transferFrom(tokenSpender,_address,tokensToSend));\n', '\t// Log tokens sent for ethers;\n', '    TokensSent(_address,_value,tokensToSend);\n', '    // Send ethers to collector\n', '    require(collectorAddress.send(_value));\n', '    }\n', '\n', '  \n', '\n', 'function getPrice() constant public returns(uint _price){\n', '    if (autoPrice) {\n', '        return calculatePrice(now);\n', '    \t} else {\n', '    \t\treturn tokenPrice;\n', '    \t\t}\n', '}\n', '\n', 'function getCurrentStage() public constant returns(uint8 _stage){\n', '\treturn stage;\n', '}\n', '\n', 'function calculatePrice(uint _when) constant public returns(uint _result){\n', '\tif (_when == 0) _when = now;\n', '\t// 25 are estimated of 25 seconds per block\n', '\tuint delay = (_when - initialTime) / 25;\n', '\tuint factor = delay * increasePerBlock;\n', '\tuint multip = initialPrice * factor;\n', '\tuint result = initialPrice - multip / increasePerBlockDiv / 100; // 100 = percent\n', '\trequire (result<=initialPrice);\n', '\treturn result;\n', '   \t//return initialPrice - initialPrice * (_when - initialTime) / 25 * increasePerBlock / increasePerBlockDiv;\n', '}\n', '\n', '\n', 'function changeToStage(uint8 _stage) isAuthorized returns(bool) {\n', '\trequire(stage<_stage && _stage < 4);\n', '\tstage = _stage;\n', '\treturn true;\n', '}\n', '\n', 'function pause() public isAuthorized {\n', '\tisPaused = true;\n', '}\n', '\n', 'function resume() public isAuthorized {\n', '\tisPaused = false;\n', '}\n', '\n', 'function setManualPrice(uint _price) public isAuthorized {\n', '    autoPrice = false;\n', '    tokenPrice = _price;\n', '}\n', '\n', 'function setAutoPrice() public isAuthorized {\n', '    autoPrice = true;\n', '}\n', '\n', 'function setInitialTime() public isAuthorized {\n', '    initialTime = now;\n', '}\n', '\n', 'function getNow() public constant returns(uint _now){\n', '\treturn now;\n', '}\n', '\n', 'function flushEthers() public isAuthorized { // Send ether to collector\n', '  require( collectorAddress.send( this.balance ) );\n', '}\n', '\n', 'function changeMinAccEthers(uint _newMin) public isAuthorized {\n', '  minAcceptedETH = _newMin;\n', '}\n', '\n', 'function addAuthorized(address _address) public isAuthorized {\n', '\tauthorized[_address] = true;\n', '\n', '}\n', '\n', 'function removeAuthorized(address _address) public isAuthorized {\n', '\trequire(_address != owner);\n', '\tauthorized[_address] = false;\n', '}\n', '\n', 'function changeOwner(address _address) public {\n', '\trequire(msg.sender == owner);\n', '\towner = _address;\n', '}\n', '\n', '// To manage ERC20 tokens in case of accidental sending to the contract\n', '\n', 'function sendTokens(address _address , uint256 _amount) isAuthorized returns (bool success) {\n', '    ERC20Basic token = ERC20Basic( tokenAdd );\n', '    require( token.transfer(_address , _amount ) );\n', '    return true;\n', '}\n', '\n', '\n', '}']
