['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* ZETHR PRESENTS: SLOTS\n', '*\n', '* Written August 2018 by the Zethr team for zethr.io.\n', '*\n', '* Code framework written by Norsefire.\n', '* EV calculations written by TropicalRogue.\n', '* Audit and edits written by Klob.\n', '* Multiroll framework written by Etherguy.\n', '*\n', '* Rolling Odds:\n', '*   49.31%  Lose    \n', '*   35.64%  Two Matching Icons\n', '*       - 10.00% : 2x    Multiplier [Two Rockets]\n', '*       - 15.00% : 1.33x Multiplier [Two Gold  Pyramids]\n', '*       - 15.00% : 1x    Multiplier [Two &#39;Z&#39; Symbols]\n', '*       - 15.00% : 1x    Multiplier [Two &#39;T&#39; Symbols]\n', '*       - 15.00% : 1x    Multiplier [Two &#39;H&#39; Symbols]\n', '*       - 15.00% : 1.33x Multiplier [Two Purple Pyramids]\n', '*       - 15.00% : 2x    Multiplier [Two Ether Icons]\n', '*   6.79%   One Of Each Pyramid\n', '*       - 1.5x  Multiplier\n', '*   2.94%   One Moon Icon\n', '*       - 2.5x Multiplier\n', '*   5.00%   Three Matching Icons\n', '*       -  3.00% : 12x   Multiplier [Three Rockets]\n', '*       -  5.00% : 10x   Multiplier [Three Gold  Pyramids]\n', '*       - 27.67% : 7.5x  Multiplier [Three &#39;Z&#39; Symbols]\n', '*       - 27.67% : 7.5x  Multiplier [Three &#39;T&#39; Symbols]\n', '*       - 27.67% : 7.5x  Multiplier [Three &#39;H&#39; Symbols]\n', '*       -  5.00% : 10x   Multiplier [Three Purple Pyramids]\n', '*       -  4.00% : 15x   Multiplier [Three Ether Icons]\n', '*   0.28%   Z T H Prize\n', '*       - 20x Multiplier\n', '*   0.03%   Two Moon Icons\n', '*       - 50x  Multiplier\n', '*   0.0001% Three Moon Grand Jackpot\n', '*       - Jackpot Amount (variable)\n', '*\n', '*   From all of us at Zethr, thank you for playing!    \n', '*\n', '*/\n', '\n', '// Zethr Token Bankroll interface\n', 'contract ZethrTokenBankroll{\n', '    // Game request token transfer to player \n', '    function gameRequestTokens(address target, uint tokens) public;\n', '    function gameTokenAmount(address what) public returns (uint);\n', '}\n', '\n', '// Zether Main Bankroll interface\n', 'contract ZethrMainBankroll{\n', '    function gameGetTokenBankrollList() public view returns (address[7]);\n', '}\n', '\n', '// Zethr main contract interface\n', 'contract ZethrInterface{\n', '    function withdraw() public;\n', '}\n', '\n', '// Library for figuring out the "tier" (1-7) of a dividend rate\n', 'library ZethrTierLibrary{\n', '\n', '    function getTier(uint divRate) internal pure returns (uint){\n', '        // Tier logic \n', '        // Returns the index of the UsedBankrollAddresses which should be used to call into to withdraw tokens \n', '        \n', '        // We can divide by magnitude\n', '        // Remainder is removed so we only get the actual number we want\n', '        uint actualDiv = divRate; \n', '        if (actualDiv >= 30){\n', '            return 6;\n', '        } else if (actualDiv >= 25){\n', '            return 5;\n', '        } else if (actualDiv >= 20){\n', '            return 4;\n', '        } else if (actualDiv >= 15){\n', '            return 3;\n', '        } else if (actualDiv >= 10){\n', '            return 2; \n', '        } else if (actualDiv >= 5){\n', '            return 1;\n', '        } else if (actualDiv >= 2){\n', '            return 0;\n', '        } else{\n', '            // Impossible\n', '            revert(); \n', '        }\n', '    }\n', '}\n', '\n', '// Contract that contains the functions to interact with the ZlotsJackpotHoldingContract\n', 'contract ZlotsJackpotHoldingContract {\n', '  function payOutWinner(address winner) public; \n', '  function getJackpot() public view returns (uint);\n', '}\n', ' \n', '// Contract that contains the functions to interact with the bankroll system\n', 'contract ZethrBankrollBridge {\n', '    // Must have an interface with the main Zethr token contract \n', '    ZethrInterface Zethr;\n', '   \n', '    // Store the bankroll addresses \n', '    // address[0] is main bankroll \n', '    // address[1] is tier1: 2-5% \n', '    // address[2] is tier2: 5-10, etc\n', '    address[7] UsedBankrollAddresses; \n', '\n', '    // Mapping for easy checking\n', '    mapping(address => bool) ValidBankrollAddress;\n', '    \n', '    // Set up the tokenbankroll stuff \n', '    function setupBankrollInterface(address ZethrMainBankrollAddress) internal {\n', '\n', '        // Instantiate Zethr\n', '        Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D);\n', '\n', '        // Get the bankroll addresses from the main bankroll\n', '        UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\n', '        for(uint i=0; i<7; i++){\n', '            ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\n', '        }\n', '    }\n', '    \n', '    // Require a function to be called from a *token* bankroll \n', '    modifier fromBankroll(){\n', '        require(ValidBankrollAddress[msg.sender], "msg.sender should be a valid bankroll");\n', '        _;\n', '    }\n', '    \n', '    // Request a payment in tokens to a user FROM the appropriate tokenBankroll \n', '    // Figure out the right bankroll via divRate \n', '    function RequestBankrollPayment(address to, uint tokens, uint tier) internal {\n', '        address tokenBankrollAddress = UsedBankrollAddresses[tier];\n', '        ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\n', '    }\n', '    \n', '    function getZethrTokenBankroll(uint divRate) public constant returns (ZethrTokenBankroll){\n', '        return ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)]);\n', '    }\n', '}\n', '\n', '// Contract that contains functions to move divs to the main bankroll\n', 'contract ZethrShell is ZethrBankrollBridge {\n', '\n', '    // Dump ETH balance to main bankroll\n', '    function WithdrawToBankroll() public {\n', '        address(UsedBankrollAddresses[0]).transfer(address(this).balance);\n', '    }\n', '\n', '    // Dump divs and dump ETH into bankroll\n', '    function WithdrawAndTransferToBankroll() public {\n', '        Zethr.withdraw();\n', '        WithdrawToBankroll();\n', '    }\n', '}\n', '\n', '// Zethr game data setup\n', '// Includes all necessary to run with Zethr\n', 'contract ZlotsMulti is ZethrShell {\n', '    using SafeMath for uint;\n', '\n', '    // ---------------------- Events\n', '\n', '    // Might as well notify everyone when the house takes its cut out.\n', '    event HouseRetrievedTake(\n', '        uint timeTaken,\n', '        uint tokensWithdrawn\n', '    );\n', '\n', '    // Fire an event whenever someone places a bet.\n', '    event TokensWagered(\n', '        address _wagerer,\n', '        uint _wagered\n', '    );\n', '\n', '    event LogResult(\n', '        address _wagerer,\n', '        uint _result,\n', '        uint _profit,\n', '        uint _wagered,\n', '        uint _category,\n', '        bool _win\n', '    );\n', '\n', '    // Result announcement events (to dictate UI output!)\n', '    event Loss(address _wagerer, uint _block);                  // Category 0\n', '    event ThreeMoonJackpot(address _wagerer, uint _block);      // Category 1\n', '    event TwoMoonPrize(address _wagerer, uint _block);          // Category 2\n', '    event ZTHPrize(address _wagerer, uint _block);              // Category 3\n', '    event ThreeZSymbols(address _wagerer, uint _block);         // Category 4\n', '    event ThreeTSymbols(address _wagerer, uint _block);         // Category 5\n', '    event ThreeHSymbols(address _wagerer, uint _block);         // Category 6\n', '    event ThreeEtherIcons(address _wagerer, uint _block);       // Category 7\n', '    event ThreePurplePyramids(address _wagerer, uint _block);   // Category 8\n', '    event ThreeGoldPyramids(address _wagerer, uint _block);     // Category 9\n', '    event ThreeRockets(address _wagerer, uint _block);          // Category 10\n', '    event OneMoonPrize(address _wagerer, uint _block);          // Category 11\n', '    event OneOfEachPyramidPrize(address _wagerer, uint _block); // Category 12\n', '    event TwoZSymbols(address _wagerer, uint _block);           // Category 13\n', '    event TwoTSymbols(address _wagerer, uint _block);           // Category 14\n', '    event TwoHSymbols(address _wagerer, uint _block);           // Category 15\n', '    event TwoEtherIcons(address _wagerer, uint _block);         // Category 16\n', '    event TwoPurplePyramids(address _wagerer, uint _block);     // Category 17\n', '    event TwoGoldPyramids(address _wagerer, uint _block);       // Category 18\n', '    event TwoRockets(address _wagerer, uint _block);            // Category 19    \n', '    event SpinConcluded(address _wagerer, uint _block);         // Debug event\n', '\n', '    // ---------------------- Modifiers\n', '\n', '    // Makes sure that player porfit can&#39;t exceed a maximum amount\n', '    // We use the max win here - 50x\n', '    modifier betIsValid(uint _betSize, uint divRate, uint8 spins) {\n', '      require(_betSize.div(spins).mul(50) <= getMaxProfit(divRate));\n', '      require(_betSize.div(spins) >= minBet);\n', '      _;\n', '    }\n', '\n', '    // Requires the game to be currently active\n', '    modifier gameIsActive {\n', '      require(gamePaused == false);\n', '      _;\n', '    }\n', '\n', '    // Require msg.sender to be owner\n', '    modifier onlyOwner {\n', '      require(msg.sender == owner); \n', '      _;\n', '    }\n', '\n', '    // Requires msg.sender to be bankroll\n', '    modifier onlyBankroll {\n', '      require(msg.sender == bankroll);\n', '      _;\n', '    }\n', '\n', '    // Requires msg.sender to be owner or bankroll\n', '    modifier onlyOwnerOrBankroll {\n', '      require(msg.sender == owner || msg.sender == bankroll);\n', '      _;\n', '    }\n', '\n', '    // ---------------------- Variables\n', '\n', '    // Configurables\n', '    uint constant public maxProfitDivisor = 1000000;\n', '    uint constant public houseEdgeDivisor = 1000;\n', '    mapping (uint => uint) public maxProfit;\n', '    uint public maxProfitAsPercentOfHouse;\n', '    uint public minBet = 1e18;\n', '    address public zlotsJackpot;\n', '    address private owner;\n', '    address private bankroll;\n', '    bool gamePaused;\n', '\n', '    // Trackers\n', '    uint  public totalSpins;\n', '    uint  public totalZTHWagered;\n', '    mapping (uint => uint) public contractBalance;\n', '    \n', '    // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\n', '    bool public gameActive;\n', '\n', '    address private ZTHTKNADDR;\n', '    address private ZTHBANKROLL;\n', '\n', '    // ---------------------- Functions \n', '\n', '    // Constructor; must supply bankroll address\n', '    constructor(address BankrollAddress) public {\n', '        // Set up the bankroll interface\n', '        setupBankrollInterface(BankrollAddress); \n', '\n', '        // Owner is deployer\n', '        owner = msg.sender;\n', '\n', '        // Default max profit to 5% of contract balance\n', '        ownerSetMaxProfitAsPercentOfHouse(50000);\n', '\n', '        // Set starting variables\n', '        bankroll      = ZTHBANKROLL;\n', '        gameActive  = true;\n', '\n', '        // Init min bet (1 ZTH)\n', '        ownerSetMinBet(1e18);\n', '    }\n', '\n', '    // Zethr dividends gained are accumulated and sent to bankroll manually\n', '    function() public payable {  }\n', '\n', '    // If the contract receives tokens, bundle them up in a struct and fire them over to _spinTokens for validation.\n', '    struct TKN { address sender; uint value; }\n', '    function execute(address _from, uint _value, uint divRate, bytes  _data ) public fromBankroll returns (bool){\n', '            TKN memory          _tkn;\n', '            _tkn.sender       = _from;\n', '            _tkn.value        = _value;\n', '            _spinTokens(_tkn, divRate, uint8(_data[0]));\n', '            return true;\n', '    }\n', '\n', '    struct playerSpin {\n', '        uint192 tokenValue; // Token value in uint\n', '        uint48 blockn;      // Block number 48 bits\n', '        uint8 tier;\n', '        uint8 spins;\n', '        uint divRate;\n', '    }\n', '\n', '    // Mapping because a player can do one spin at a time\n', '    mapping(address => playerSpin) public playerSpins;\n', '\n', '    // Execute spin.\n', '    function _spinTokens(TKN _tkn, uint divRate, uint8 spins) \n', '      private \n', '      betIsValid(_tkn.value, divRate, spins)\n', '    {\n', '\n', '        require(gameActive);\n', '        require(block.number <= ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint56\n', '        require(_tkn.value <= ((2 ** 192) - 1));\n', '        address _customerAddress = _tkn.sender;\n', '        uint    _wagered         = _tkn.value;\n', '\n', '        playerSpin memory spin = playerSpins[_tkn.sender];\n', ' \n', '        // We update the contract balance *before* the spin is over, not after\n', '        // This means that we don&#39;t have to worry about unresolved rolls never resolving\n', '        // (we also update it when a player wins)\n', '        addContractBalance(divRate, _wagered);\n', '\n', '        // Cannot spin twice in one block\n', '        require(block.number != spin.blockn);\n', '\n', '        // If there exists a spin, finish it\n', '        if (spin.blockn != 0) {\n', '          _finishSpin(_tkn.sender);\n', '        }\n', '\n', '        // Set struct block number and token value\n', '        spin.blockn = uint48(block.number);\n', '        spin.tokenValue = uint192(_wagered.div(spins));\n', '        spin.tier = uint8(ZethrTierLibrary.getTier(divRate));\n', '        spin.divRate = divRate;\n', '        spin.spins = spins;\n', '\n', '        // Store the roll struct - 40k gas.\n', '        playerSpins[_tkn.sender] = spin;\n', '\n', '        // Increment total number of spins\n', '        totalSpins += spins;\n', '\n', '        // Total wagered\n', '        totalZTHWagered += _wagered;\n', '\n', '        emit TokensWagered(_customerAddress, _wagered);\n', '    }\n', '\n', '    // Finish the current spin of a player, if they have one\n', '    function finishSpin() public\n', '        gameIsActive\n', '        returns (uint[])\n', '    {\n', '        return _finishSpin(msg.sender);\n', '    }\n', '\n', '    struct rollData{\n', '        uint win;\n', '        uint loss; \n', '        uint jp;\n', '    }\n', '\n', '    // Pay winners, update contract balance, send rewards where applicable.\n', '    function _finishSpin(address target)\n', '        private returns (uint[])\n', '    {\n', '        playerSpin memory spin = playerSpins[target];\n', '\n', '        require(spin.tokenValue > 0); // No re-entrancy\n', '        require(spin.blockn != block.number);\n', '        \n', '        uint[] memory output = new uint[](spin.spins);\n', '        rollData memory outcomeTrack = rollData(0,0,0);\n', '        uint category = 0;\n', '        uint profit;\n', '        uint playerDivrate = spin.divRate;\n', '        \n', '        for(uint i=0; i<spin.spins; i++){\n', '        \n', '        // If the block is more than 255 blocks old, we can&#39;t get the result\n', '        // Also, if the result has already happened, fail as well\n', '        uint result;\n', '        if (block.number - spin.blockn > 255) {\n', '          result = 1000000; // Can&#39;t win: default to largest number\n', '          \n', '          output[i] = 1000000;\n', '        } else {\n', '\n', '          // Generate a result - random based ONLY on a past block (future when submitted).\n', '          // Case statement barrier numbers defined by the current payment schema at the top of the contract.\n', '          result = random(1000000, spin.blockn, target, i) + 1;\n', '          output[i] = result;\n', '        }\n', '\n', '        if (result > 506856) {\n', '            // Player has lost. Womp womp.\n', '\n', '            // Add one percent of player loss to the jackpot\n', '            // (do this by requesting a payout to the jackpot)\n', '            outcomeTrack.loss += spin.tokenValue/100;\n', '           // RequestBankrollPayment(zlotsJackpot, spin.tokenValue / 100, tier);\n', '\n', '            // Null out player spin\n', '            //playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0), uint(0));\n', '\n', '            emit Loss(target, spin.blockn);\n', '            emit LogResult(target, result, profit, spin.tokenValue, category, false);\n', '        } else if (result < 2) {\n', '            // Player has won the three-moon mega jackpot!\n', '      \n', '            // Get profit amount via jackpot\n', '            profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot();\n', '            category = 1;\n', '    \n', '            // Emit events\n', '            emit ThreeMoonJackpot(target, spin.blockn);\n', '            emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '\n', '\n', '            outcomeTrack.jp += 1;\n', '\n', '            // Null out spins\n', '            //playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0));\n', '\n', '            // Pay out the winner\n', '            //ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target);\n', '            \n', '\n', '        } else {\n', '            if (result < 299) {\n', '                // Player has won a two-moon prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 50);\n', '                category = 2;\n', '                emit TwoMoonPrize(target, spin.blockn);\n', '            } else if (result < 3128) {\n', '                // Player has won the Z T H prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 20);\n', '                category = 3;\n', '                emit ZTHPrize(target, spin.blockn);\n', '            } else if (result < 16961) {\n', '                // Player has won a three Z symbol prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '                category = 4;\n', '                emit ThreeZSymbols(target, spin.blockn);\n', '            } else if (result < 30794) {\n', '                // Player has won a three T symbol prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '                category = 5;\n', '                emit ThreeTSymbols(target, spin.blockn);\n', '            } else if (result < 44627) {\n', '                // Player has won a three H symbol prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '                category = 6;\n', '                emit ThreeHSymbols(target, spin.blockn);\n', '            } else if (result < 46627) {\n', '                // Player has won a three Ether icon prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 11);\n', '                category = 7;\n', '                emit ThreeEtherIcons(target, spin.blockn);\n', '            } else if (result < 49127) {\n', '                // Player has won a three purple pyramid prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 75), 10);\n', '                category = 8;\n', '                emit ThreePurplePyramids(target, spin.blockn);\n', '            } else if (result < 51627) {\n', '                // Player has won a three gold pyramid prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 9);\n', '                category = 9;\n', '                emit ThreeGoldPyramids(target, spin.blockn);\n', '            } else if (result < 53127) {\n', '                // Player has won a three rocket prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 13);\n', '                category = 10;\n', '                emit ThreeRockets(target, spin.blockn);\n', '            } else if (result < 82530) {\n', '                // Player has won a one moon prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25),10);\n', '                category = 11;\n', '                emit OneMoonPrize(target, spin.blockn);\n', '            } else if (result < 150423) {\n', '                // Player has won a each-coloured-pyramid prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n', '                category = 12;\n', '                emit OneOfEachPyramidPrize(target, spin.blockn);\n', '            } else if (result < 203888) {\n', '                // Player has won a two Z symbol prize!\n', '                profit = spin.tokenValue;\n', '                category = 13;\n', '                 emit TwoZSymbols(target, spin.blockn);\n', '            } else if (result < 257353) {\n', '                // Player has won a two T symbol prize!\n', '                profit = spin.tokenValue;\n', '                category = 14;\n', '                emit TwoTSymbols(target, spin.blockn);\n', '            } else if (result < 310818) {\n', '                // Player has won a two H symbol prize!\n', '                profit = spin.tokenValue;\n', '                category = 15;\n', '                emit TwoHSymbols(target, spin.blockn);\n', '            } else if (result < 364283) {\n', '                // Player has won a two Ether icon prize!\n', '                profit = SafeMath.mul(spin.tokenValue, 2);\n', '                category = 16;\n', '                emit TwoEtherIcons(target, spin.blockn);\n', '            } else if (result < 417748) {\n', '                // Player has won a two purple pyramid prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125), 100);\n', '                category = 17;\n', '                emit TwoPurplePyramids(target, spin.blockn);\n', '            } else if (result < 471213) {\n', '                // Player has won a two gold pyramid prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 133), 100);\n', '                category = 18;\n', '                emit TwoGoldPyramids(target, spin.blockn);\n', '            } else {\n', '                // Player has won a two rocket prize!\n', '                profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\n', '                category = 19;\n', '                emit TwoRockets(target, spin.blockn);\n', '            }\n', '            uint newMaxProfit = getNewMaxProfit(playerDivrate, outcomeTrack.win);\n', '            if (profit > newMaxProfit){\n', '                profit = newMaxProfit;\n', '            }\n', '\n', '            emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '            outcomeTrack.win += profit;\n', '            //tier = spin.tier;\n', '            //playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0)); // Prevent Re-entrancy\n', '            \n', '            //RequestBankrollPayment(target, profit, tier);\n', '          }\n', '        }\n', '\n', '        playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0));\n', '        if (outcomeTrack.jp > 0){\n', '            for (i = 0; i < outcomeTrack.jp; i++){\n', '                // in the weird case a player wins two jackpots, we of course pay them twice \n', '                ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target);\n', '            }\n', '        }\n', '        if (outcomeTrack.win > 0){\n', '                    // Subtact from contract balance their profit\n', '           // subContractBalance(playerDivrate, win); // happens in the callback from request payment \n', '            RequestBankrollPayment(target, outcomeTrack.win, spin.tier);\n', '        }\n', '        if (outcomeTrack.loss > 0){\n', '            // this loss is the loss to pay to the jackpot account \n', '            // the delta in contractBalance is already updated  in a pending bet.\n', '            RequestBankrollPayment(zlotsJackpot, outcomeTrack.loss, spin.tier);\n', '        }\n', '            \n', '        emit SpinConcluded(target, spin.blockn);\n', '        return output;\n', '    }   \n', '\n', '    // Returns a random number using a specified block number\n', '    // Always use a FUTURE block number.\n', '    function maxRandom(uint blockn, address entropy, uint index) private view returns (uint256 randomNumber) {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '       // address(this), // adds no entropy \n', '        blockhash(blockn),\n', '        entropy,\n', '        index)\n', '      ));\n', '    }\n', '\n', '    // Random helper\n', '    function random(uint256 upper, uint256 blockn, address entropy, uint index) internal view returns (uint256 randomNumber) {\n', '      return maxRandom(blockn, entropy, index) % upper;\n', '    }\n', '\n', '    // Sets max profit (internal)\n', '    function setMaxProfit(uint divRate) internal {\n', '      maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor; \n', '    } \n', '\n', '    // Gets max profit  \n', '    function getMaxProfit(uint divRate) public view returns (uint) {\n', '      return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '    }\n', '\n', '    function getNewMaxProfit(uint divRate, uint currentWin) public view returns (uint) {\n', '      return ( (contractBalance[divRate] - currentWin) * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '    }\n', '\n', '    // Subtracts from the contract balance tracking var\n', '    function subContractBalance(uint divRate, uint sub) internal {\n', '      contractBalance[divRate] = contractBalance[divRate].sub(sub);\n', '    }\n', '\n', '    // Adds to the contract balance tracking var\n', '    function addContractBalance(uint divRate, uint add) internal {\n', '      contractBalance[divRate] = contractBalance[divRate].add(add);\n', '    }\n', '\n', '    // An EXTERNAL update of tokens should be handled here\n', '    // This is due to token allocation\n', '    // The game should handle internal updates itself (e.g. tokens are betted)\n', '    function bankrollExternalUpdateTokens(uint divRate, uint newBalance) \n', '      public \n', '      fromBankroll \n', '    {\n', '      contractBalance[divRate] = newBalance;\n', '      setMaxProfit(divRate);\n', '    }\n', '\n', '    // Set the new max profit as percent of house - can be as high as 20%\n', '    // (1,000,000 = 100%)\n', '    function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n', '    onlyOwner\n', '    {\n', '      // Restricts each bet to a maximum profit of 50% contractBalance\n', '      require(newMaxProfitAsPercent <= 500000);\n', '      maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n', '      setMaxProfit(2);\n', '      setMaxProfit(5);\n', '      setMaxProfit(10);\n', '      setMaxProfit(15); \n', '      setMaxProfit(20);\n', '      setMaxProfit(25);\n', '      setMaxProfit(33);\n', '    }\n', '\n', '    // Only owner can set minBet   \n', '    function ownerSetMinBet(uint newMinimumBet) public\n', '    onlyOwner\n', '    {\n', '      minBet = newMinimumBet;\n', '    }\n', '\n', '    // Only owner can set zlotsJackpot address\n', '    function ownerSetZlotsAddress(address zlotsAddress) public\n', '    onlyOwner\n', '    {\n', '        zlotsJackpot = zlotsAddress;\n', '    }\n', '\n', '    // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\n', '    function pauseGame() public onlyOwnerOrBankroll {\n', '        gameActive = false;\n', '    }\n', '\n', '    // The converse of the above, resuming betting if a freeze had been put in place.\n', '    function resumeGame() public onlyOwnerOrBankroll {\n', '        gameActive = true;\n', '    }\n', '\n', '    // Administrative function to change the owner of the contract.\n', '    function changeOwner(address _newOwner) public onlyOwnerOrBankroll {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // Administrative function to change the Zethr bankroll contract, should the need arise.\n', '    function changeBankroll(address _newBankroll) public onlyOwnerOrBankroll {\n', '        bankroll = _newBankroll;\n', '    }\n', '\n', '    // Is the address that the token has come from actually ZTH?\n', '    function _zthToken(address _tokenContract) private view returns (bool) {\n', '       return _tokenContract == ZTHTKNADDR;\n', '    }\n', '}\n', '\n', '// And here&#39;s the boring bit.\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']