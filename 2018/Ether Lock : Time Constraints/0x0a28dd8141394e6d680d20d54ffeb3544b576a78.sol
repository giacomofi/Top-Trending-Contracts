['pragma solidity ^0.4.21;\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        \n', '        \n', '        \n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract BaseGame {\n', '    using SafeMath for uint256;\n', '    \n', '    string public officialGameUrl;  \n', '    string public gameName = "SelectOne";    \n', '    uint public gameType = 3002;               \n', '\n', '    mapping (address => uint256) public userEtherOf;\n', '    \n', '    function userRefund() public  returns(bool _result);\n', '}\n', '\n', 'contract Base is  BaseGame{\n', '    uint public createTime = now;\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {             \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }\n', '\n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;\n', '    }\n', '\n', '\n', '    uint public currentEventId = 1;\n', '\n', '    function getEventId() internal returns(uint _result) { \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '}\n', '\n', '\n', '\n', 'interface IDividendToken{                           \n', '    function profitOrgPay() payable external ;    \n', '}\n', '\n', 'interface IGameToken{                                             \n', '    function mineToken(address _player, uint256 _etherAmount) external returns (uint _toPlayerToken);\n', '    function balanceOf(address _owner) constant  external returns (uint256 _balance);\n', '}\n', '\n', 'contract Loan is Base{     \n', '\n', '    address public shareholder;               \n', '\n', '    bool public shareholderIsToken = false;\n', '    bool public isStopPlay = false;\n', '    uint public stopTime = 0;\n', '    \n', '    function setStopPlay(bool _isStopPlay) public onlyOwner\n', '    {\n', '        isStopPlay = _isStopPlay;\n', '        stopTime = now;\n', '    }\n', '\n', '    function userRefund() public  returns(bool _result) {\n', '        return _userRefund(msg.sender);\n', '    }\n', '\n', '    function _userRefund(address _to) internal  returns(bool _result){    \n', '        require (_to != 0x0);\n', '        _result = false;\n', '        lock();\n', '        uint256 amount = userEtherOf[msg.sender];\n', '        if(amount > 0){\n', '            if(msg.sender == shareholder){       \n', '\t\tcheckPayShareholder();\n', '            }\n', '            else{       \n', '                userEtherOf[msg.sender] = 0;\n', '                _to.transfer(amount);\n', '            }\n', '            _result = true;\n', '        }\n', '        else{   \n', '            _result = false;\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    uint256 maxShareholderEther = 20 ether;                                \n', '\n', '    function setMaxShareholderEther(uint256 _value) public onlyOwner {     \n', '        require(_value >= minBankerEther * 2);\n', '        require(_value <= minBankerEther * 20);\n', '        maxShareholderEther = _value;\n', '    }\n', '\n', '    function autoCheckPayShareholder() internal {                             \n', '        if (userEtherOf[shareholder] > maxShareholderEther){\n', '            checkPayShareholder();\n', '         }\n', '    }\n', '\n', '    function checkPayShareholder() internal {               \n', '        uint256 amount = userEtherOf[shareholder];\n', '        if(currentLoanPerson == 0x0 || checkPayLoan()){       \n', '            uint256 me = minBankerEther;                    \n', '            if(isStopPlay){\n', '                me = 0;\n', '            }\n', '            if(amount >= me){     \n', '                uint256 toShareHolder = amount - me;\n', '                if(shareholderIsToken){     \n', '                    IDividendToken token = IDividendToken(shareholder);\n', '                    token.profitOrgPay.value(toShareHolder)();  \n', '                }else{\n', '                    shareholder.transfer(toShareHolder);\n', '                }\n', '                userEtherOf[shareholder] = me;\n', '            }\n', '        }\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    uint256 public gameMaxBetAmount = 0.4 ether;        \n', '    uint256 public gameMinBetAmount = 0.04 ether;      \n', '    uint256 public minBankerEther = gameMaxBetAmount * 20;\n', '\n', '    function setMinBankerEther(uint256 _value) public onlyOwner {          \n', '        require(_value >= gameMinBetAmount *  18 * 1);\n', '        require(_value <= gameMaxBetAmount *  18 * 10);\n', '        minBankerEther = _value;\n', '    }\n', '\n', '    uint256 public currentDayRate10000 = 0;\n', '    address public currentLoanPerson;       \n', '    uint256 public currentLoanAmount;       \n', '    uint public currentLoanDayTime;      \n', '\n', '    function depositEther() public payable\n', '    {  \n', '        if (msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '        }\n', '    }\n', '\n', '    event OnBidLoan(bool indexed _success, address indexed _user, uint256 indexed _dayRate10000,  uint256 _etherAmount);\n', '    event OnPayLoan(address _sender,uint _eventTime,uint256 _toLoan);\n', '\n', '    function bidLoan(uint256 _dayRate10000) public payable returns(bool _result) {      \n', '        _result = false;\n', '        require(!isStopPlay);\n', '        require(msg.sender != shareholder);\n', '\n', '        require(_dayRate10000 < 1000);\n', '        depositEther();\n', '        \n', '        if(checkPayLoan()){\n', '            emit OnBidLoan(false, msg.sender, _dayRate10000,  0);\n', '            return;\n', '        }\n', '        \n', '        uint256 toLoan = calLoanAmount();\n', '        uint256 toGame = 0;\n', '        if (userEtherOf[shareholder] < minBankerEther){       \n', '            toGame = minBankerEther.sub(userEtherOf[shareholder]);\n', '        }\n', '\n', '        if(toLoan > 0 && toGame == 0 && currentLoanPerson != 0x0){                   \n', '            require(_dayRate10000 < currentDayRate10000);\n', '        }\n', '\n', '        require(toLoan + toGame > 0);\n', '        require(userEtherOf[msg.sender] >= toLoan + toGame);\n', '\n', '        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(toLoan + toGame);\n', '        userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '        userEtherOf[shareholder] = userEtherOf[shareholder].add(toGame);\n', '\n', '        currentLoanPerson = msg.sender;\n', '        currentDayRate10000 = _dayRate10000;\n', '        currentLoanAmount = toLoan + toGame;\n', '        currentLoanDayTime = now;\n', '\n', '        emit OnBidLoan(false, msg.sender, _dayRate10000,  currentLoanAmount);\n', '\n', '        _result = true;\n', '        return;\n', '    }\n', '\n', '    function getCanLoanAmount() public view returns(uint256  _result){                 \n', '        uint256 toLoan = calLoanAmount();\n', '\n', '        uint256 toGame = 0;\n', '        if (userEtherOf[shareholder] <= minBankerEther){\n', '            toGame = minBankerEther - userEtherOf[shareholder];\n', '            _result =  toLoan + toGame;\n', '            return;\n', '        }\n', '        else if (userEtherOf[shareholder] > minBankerEther){\n', '            uint256 c = userEtherOf[shareholder] - minBankerEther;\n', '            if(toLoan > c){\n', '                _result =  toLoan - c;\n', '                return;\n', '            }\n', '            else{\n', '                _result =  0;\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    function calLoanAmount() public view returns (uint256 _result){\n', '      _result = 0;\n', '      if(currentLoanPerson != 0x0 && currentLoanAmount > 0){\n', '          _result = currentLoanAmount;\n', '          uint d = now.sub(currentLoanDayTime).div(1 days);\n', '          for(uint i = 0; i < d; i++){\n', '              _result = _result.mul(currentDayRate10000.add(10000)).div(10000);\n', '          }\n', '        }\n', '    }\n', '\n', '\n', '    function checkPayLoan() public returns (bool _result) {                        \n', '        _result = false;\n', '        uint256 toLoan = calLoanAmount();\n', '        if(toLoan > 0){\n', '            if(isStopPlay && now  > stopTime.add(1 days)){         \n', '                if(toLoan > userEtherOf[shareholder]){\n', '                    toLoan = userEtherOf[shareholder];\n', '                    userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '                    userEtherOf[shareholder] = userEtherOf[shareholder].sub(toLoan);\n', '                }\n', '                else{\n', '                    userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '                    userEtherOf[shareholder] = userEtherOf[shareholder].sub(toLoan);\n', '                }\n', '\n', '                currentLoanPerson = 0x0;\n', '                currentDayRate10000 = 0;\n', '                currentLoanAmount = 0;\n', '                currentLoanDayTime = now;\n', '                _result = true;\n', '                emit OnPayLoan(msg.sender, now, toLoan);\n', '                return;\n', '            }                             \n', '            if (userEtherOf[shareholder] >= minBankerEther.add(toLoan)){            \n', '                userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '                userEtherOf[shareholder] = userEtherOf[shareholder].sub(toLoan);\n', '                currentLoanPerson = 0x0;\n', '                currentDayRate10000 = 0;\n', '                currentLoanAmount = 0;\n', '                currentLoanDayTime = now;\n', '                _result = true;\n', '                emit OnPayLoan(msg.sender,now,toLoan);\n', '                return;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract SelectOne is Loan\n', '{\n', '  uint public playNo = 1;      \n', '  uint public constant minNum = 1; \n', '  uint public constant maxNum = 22;         \n', '  uint public constant winMultiplePer = 1800;\n', '\n', '  struct betInfo              \n', '  {\n', '    address Player;         \n', '    uint[] BetNums;\n', '    uint AwardNum;\n', '    uint256[] BetAmounts;      \n', '    uint256 BlockNumber;    \n', '    uint EventId;           \n', '    bool IsReturnAward;     \n', '  }\n', '  mapping (uint => betInfo) public playerBetInfoOf;               \n', '  IGameToken public GameToken;\n', '\n', '\n', '  //function SelectOne(uint _maxNum, uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount,uint _winMultiplePer,string _gameName,address _gameToken,bool _isToken) public{\n', '  function SelectOne(uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount, string _gameName,address _gameToken) public{\n', '    //require(1 < _maxNum);\n', '    //require(_maxNum < 100);\n', '    require(_gameMinBetAmount > 0); \n', '    require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '    //require(_winMultiplePer < _maxNum.mul(100));\n', '    owner = msg.sender;             \n', '    //maxNum = _maxNum;\n', '    gameMinBetAmount = _gameMinBetAmount;\n', '    gameMaxBetAmount = _gameMaxBetAmount;\n', '    minBankerEther = gameMaxBetAmount * 20;\n', '    //winMultiplePer = _winMultiplePer;\n', '    gameName = _gameName;   \n', '    GameToken = IGameToken(_gameToken);\n', '    shareholder = _gameToken;\n', '    shareholderIsToken = true;\n', "    officialGameUrl='http://select.donquixote.games/';\n", '  }\n', '  \n', '\n', '  function tokenOf(address _user) view public returns(uint _result){\n', '    _result = GameToken.balanceOf(_user);\n', '  }\n', '\n', '  event OnPlay(address indexed _player, uint[] _betNums,uint256[] _betAmounts,uint256 _giftToken, uint _blockNumber,uint _playNo, uint _eventTime, uint eventId);\n', '  event OnGetAward(address indexed _player, uint256 _playNo, uint[] _betNums,uint _blockNumber,uint256[] _betAmounts ,uint _eventId,uint _awardNum,uint256 _awardAmount);\n', '\n', '\n', '  function play(uint[] _betNums,uint256[] _betAmounts) public  payable returns(bool _result){       \n', '    _result = false;\n', '    require(_betNums.length > 0);\n', '    require(_betNums.length == _betAmounts.length);\n', '    depositEther();\n', '    _result = _play(_betNums,_betAmounts);\n', '  }\n', '\n', '  function _play(uint[] _betNums, uint256[] _betAmounts) private  returns(bool _result){            \n', '    _result = false;\n', '    require (!isStopPlay);\n', '\n', '    uint maxBetAmount = 0;\n', '    uint totalBetAmount = 0;\n', '    uint8[22] memory betNumOf;                      \n', '\n', '    for(uint i=0;i < _betNums.length;i++){\n', '      require(_betNums[i] > 0 && _betNums[i] <= maxNum );\n', '      require(betNumOf[_betNums[i] - 1] == 0);       \n', '\t  betNumOf[_betNums[i] - 1] = 1;      \n', '      if(_betAmounts[i] > gameMaxBetAmount){\n', '        _betAmounts[i] = gameMaxBetAmount;\n', '      }\n', '      if(_betAmounts[i] > maxBetAmount){\n', '        maxBetAmount = _betAmounts[i];\n', '      }\n', '      totalBetAmount = totalBetAmount.add(_betAmounts[i]);\n', '    }\n', '\n', '    uint256 needAmount = maxBetAmount.mul(winMultiplePer).div(100);\n', '    if(totalBetAmount > needAmount){\n', '      needAmount = 0;\n', '    }else{\n', '      needAmount = needAmount.sub(totalBetAmount);\n', '    }\n', '    require(userEtherOf[shareholder] >= needAmount);\n', '    require(userEtherOf[msg.sender] >= totalBetAmount);\n', '    lock();\n', '    betInfo memory bi = betInfo({\n', '      Player :  msg.sender,              \n', '      BetNums : _betNums,                       \n', '      AwardNum : 0,\n', '      BetAmounts : _betAmounts,                     \n', '      BlockNumber : block.number,         \n', '      EventId : currentEventId,           \n', '      IsReturnAward: false               \n', '    });\n', '    playerBetInfoOf[playNo] = bi;\n', '    userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(totalBetAmount);                  \n', '    userEtherOf[shareholder] = userEtherOf[shareholder].sub(needAmount);             \n', '    userEtherOf[this] = userEtherOf[this].add(needAmount).add(totalBetAmount);\n', '    \n', '    uint256 _giftToken = GameToken.mineToken(msg.sender,totalBetAmount);\n', '    emit OnPlay(msg.sender,_betNums,_betAmounts,_giftToken,block.number,playNo,now, getEventId());      \n', '    playNo++;       \n', '    _result = true;\n', '    unLock();\n', '\t  autoCheckPayShareholder();             \n', '  }\n', '\n', '  function getAward(uint[] _playNos) public returns(bool _result){\n', '    require(_playNos.length > 0);\n', '    _result = false;\n', '    for(uint i = 0;i < _playNos.length;i++){\n', '      _result = _getAward(_playNos[i]);\n', '    }\n', '  }\n', '\n', '  function _getAward(uint _playNo) private  returns(bool _result){\n', '    require(_playNo < playNo);       \n', '    _result = false;        \n', '    betInfo storage bi = playerBetInfoOf[_playNo];        \n', '    require(block.number > bi.BlockNumber);\n', '    require(!bi.IsReturnAward);      \n', '\n', '    lock();\n', '    uint awardNum = 0;\n', '    uint256 awardAmount = 0;\n', '    uint256 totalBetAmount = 0;\n', '    uint256 maxBetAmount = 0;\n', '    uint256 totalAmount = 0;\n', '    for(uint i=0;i <bi.BetNums.length;i++){\n', '      if(bi.BetAmounts[i] > maxBetAmount){\n', '        maxBetAmount = bi.BetAmounts[i];\n', '      }\n', '      totalBetAmount = totalBetAmount.add(bi.BetAmounts[i]);\n', '    }\n', '    totalAmount = maxBetAmount.mul(winMultiplePer).div(100);\n', '    if(totalBetAmount >= totalAmount){\n', '      totalAmount = totalBetAmount;\n', '    }\n', '    if(bi.BlockNumber.add(256) >= block.number){\n', '      uint256 randomNum = bi.EventId%1000000;\n', '      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n', '      awardNum = uint(encrptyHash)%22;\n', '      awardNum = awardNum.add(1);\n', '      bi.AwardNum = awardNum;\n', '      for(uint n=0;n <bi.BetNums.length;n++){\n', '        if(bi.BetNums[n] == awardNum){\n', '          awardAmount = bi.BetAmounts[n].mul(winMultiplePer).div(100);\n', '          bi.IsReturnAward = true;  \n', '          userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n', '          userEtherOf[bi.Player] = userEtherOf[bi.Player].add(awardAmount);\n', '          userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount.sub(awardAmount));\n', '          break;\n', '        }\n', '      }\n', '    }\n', '    if(!bi.IsReturnAward){\n', '      bi.IsReturnAward = true;\n', '      userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n', '      userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount);\n', '    }\n', '    emit OnGetAward(bi.Player,_playNo,bi.BetNums,bi.BlockNumber,bi.BetAmounts,getEventId(),awardNum,awardAmount);  \n', '    _result = true; \n', '    unLock();\n', '  }\n', '  function getAwardNum(uint _playNo) view public returns(uint _awardNum){\n', '    betInfo memory bi = playerBetInfoOf[_playNo];\n', '    if(bi.BlockNumber.add(256) >= block.number){\n', '      uint256 randomNum = bi.EventId%1000000;\n', '      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n', '      _awardNum = uint(encrptyHash)%22;\n', '      _awardNum = _awardNum.add(1);\n', '    }\n', '  }\n', '\n', '  function uintToString(uint v) private pure returns (string)    \n', '  {\n', '    uint maxlength = 10;                     \n', '    bytes memory reversed = new bytes(maxlength);\n', '    uint i = 0;\n', '    while (v != 0) {\n', '      uint remainder = v % 10;\n', '      v = v / 10;\n', '      reversed[i++] = byte(48 + remainder);\n', '    }\n', '    bytes memory s = new bytes(i);          \n', '    for (uint j = 0; j < i; j++) {\n', '      s[j] = reversed[i - j - 1];         \n', '    }\n', '    string memory str = string(s);         \n', '    return str;                            \n', '  }\n', '\n', '  function () public payable {        \n', '    if(msg.value > 0){\n', '      userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '    }\n', '  }\n', '\n', '}']