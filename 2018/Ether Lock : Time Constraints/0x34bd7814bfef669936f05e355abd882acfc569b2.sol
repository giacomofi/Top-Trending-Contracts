['pragma solidity ^0.4.18;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Destructible.sol\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/payment/PullPayment.sol\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(this.balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    assert(payee.send(payment));\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', '// File: contracts/GoGlobals.sol\n', '\n', '/// @title The base contract for EthernalGo, contains the admin functions and the globals used throught the game\n', '/// @author https://www.EthernalGo.com\n', '/// @dev See the GoGameLogic and GoBoardMetaDetails contract documentation to understand the actual game mechanics.\n', 'contract GoGlobals is Ownable, PullPayment, Destructible, Pausable {\n', '\n', '    // Used for simplifying capture calculations\n', '    uint8 constant MAX_UINT8 = 255;\n', '\n', '    // Used to dermine player color and who is up next\n', '    enum PlayerColor {None, Black, White}\n', '\n', '    ///    @dev Board status is a critical concept that determines which actions can be taken within each phase\n', '    ///        WaitForOpponent - When the first player has registered and waiting for a second player\n', '    ///        InProgress - The match is on! The acting player can choose between placing a stone or passing (or resigning)\n', '    ///        WaitingToResolve - Both players chose to pass their turn and we are waiting for the winner to ask the contract for  score count\n', '    ///        BlackWin, WhiteWin, Draw - Pretty self explanatory\n', '    ///        Canceled - The first player who joined the board is allowed to cancel a match if no opponent has joined yet\n', '    enum BoardStatus {WaitForOpponent, InProgress, WaitingToResolve, BlackWin, WhiteWin, Draw, Canceled}\n', '\n', '    // We staretd with a 9x9 rows\n', '    uint8 constant BOARD_ROW_SIZE = 9;\n', '    uint8 constant BOARD_SIZE = BOARD_ROW_SIZE ** 2;\n', '\n', '    // We use a shrinked board size to optimize gas costs\n', '    uint8 constant SHRINKED_BOARD_SIZE = 21;\n', '\n', '    // These are the shares each player and EthernalGo are getting for each game\n', '    uint public WINNER_SHARE;\n', '    uint public HOST_SHARE;\n', '    uint public HONORABLE_LOSS_BONUS;\n', '\n', '    // Each player gets PLAYER_TURN_SINGLE_PERIOD x PLAYER_START_PERIODS to act. These may change according to player feedback and network conjunction to optimize the playing experience\n', '    uint  public PLAYER_TURN_SINGLE_PERIOD = 4 minutes;\n', '    uint8 public PLAYER_START_PERIODS = 5;\n', '    \n', '    // We decided to restrict the table stakes to several options to allow for easier match-making\n', '    uint[] public tableStakesOptions;\n', '\n', '    // This is the main data field that contains access to all of the GoBoards that were created\n', '    GoBoard[] internal allBoards;\n', '\n', '    // The CFO is the only account that is allowed to withdraw funds\n', '    address public CFO;\n', '\n', '    // This is the main board structure and is instantiated for every new game\n', '    struct GoBoard {        \n', '        // We use the last update to determine how long has it been since the player could act\n', '        uint lastUpdate;\n', '        \n', '        // The table stakes marks how much ETH each participant needs to pay to register for the board\n', '        uint tableStakes;\n', '        \n', '        // The board balance keeps track of how much ETH this board has in order to see if we already distributed the payments for this match\n', '        uint boardBalance;\n', '\n', '        // Black and white player addresses\n', '        address blackAddress;\n', '        address whiteAddress;\n', '\n', '        // Black and white time periods remaining (initially they will be PLAYER_START_PERIODS)\n', '        uint8 blackPeriodsRemaining;\n', '        uint8 whitePeriodsRemaining;\n', '\n', '        // Keep track of double pass to finish the game\n', '        bool didPassPrevTurn;\n', '        \n', '        // Keep track of double pass to finish the game\n', '        bool isHonorableLoss;\n', '\n', '        // Who&#39;s next\n', '        PlayerColor nextTurnColor;\n', '\n', '        // Use a mapping to figure out which stone is set in which position. (Positions can be 0-BOARD_SIZE)\n', '        // @dev We decided not use an array to minimize the storage cost\n', '        mapping(uint8=>uint8) positionToColor;\n', '\n', '        // The board&#39;s current status        \n', '        BoardStatus status;\n', '    }\n', '\n', '    /// @notice The constructor is called with our inital values, they will probably change but this is what had in mind when developing the game.\n', '    function GoGlobals() public Ownable() PullPayment() Destructible() {\n', '\n', '        // Add initial price tiers so from variouos ranges\n', '        addPriceTier(0.5 ether);\n', '        addPriceTier(1 ether);\n', '        addPriceTier(5 ether);\n', '\n', '        // These are the inital shares we&#39;ve had in mind when developing the game\n', '        updateShares(950, 50, 5);\n', '        \n', '        // The CFO will be the owner, but it will change soon after the contract is deployed\n', '        CFO = owner;\n', '    }\n', '\n', '    /// @notice In case we need extra price tiers (table stakes where people can play) we can add additional ones\n', '    /// @param price the price for the new price tier in WEI\n', '    function addPriceTier(uint price) public onlyOwner {\n', '        tableStakesOptions.push(price);\n', '    }\n', '\n', '    /// If we need to update price tiers\n', '    /// @param priceTier the tier index from the array\n', '    /// @param price the new price to set\n', '    function updatePriceTier(uint8 priceTier, uint price) public onlyOwner {\n', '        tableStakesOptions[priceTier] = price;\n', '    }\n', '\n', '    /// @notice If we need to adjust the amounts players or EthernalGo gets for each game\n', '    /// @param newWinnerShare the winner&#39;s share (out of 1000)\n', '    /// @param newHostShare EthernalGo&#39;s share (out of 1000)\n', '    /// @param newBonusShare Bonus that comes our of EthernalGo and goes to the loser in case of an honorable loss (out of 1000)\n', '    function updateShares(uint newWinnerShare, uint newHostShare, uint newBonusShare) public onlyOwner {\n', '        require(newWinnerShare + newHostShare == 1000);\n', '        WINNER_SHARE = newWinnerShare;\n', '        HOST_SHARE = newHostShare;\n', '        HONORABLE_LOSS_BONUS = newBonusShare;\n', '    }\n', '\n', '    /// @notice Separating the CFO and the CEO responsibilities requires the ability to set the CFO account\n', '    /// @param newCFO the new CFO\n', '    function setNewCFO(address newCFO) public onlyOwner {\n', '        require(newCFO != 0);\n', '        CFO = newCFO;\n', '    }\n', '\n', '    /// @notice Separating the CFO and the CEO responsibilities requires the ability to set the CFO account\n', '    /// @param secondsPerPeriod The number of seconds we would like each period to last\n', '    /// @param numberOfPeriods The number of of periods each player initially has\n', '    function updateGameTimes(uint secondsPerPeriod, uint8 numberOfPeriods) public onlyOwner {\n', '\n', '        PLAYER_TURN_SINGLE_PERIOD = secondsPerPeriod;\n', '        PLAYER_START_PERIODS = numberOfPeriods;\n', '    }\n', '\n', '    /// @dev Convinience function to access the shares\n', '    function getShares() public view returns(uint, uint, uint) {\n', '        return (WINNER_SHARE, HOST_SHARE, HONORABLE_LOSS_BONUS);\n', '    }\n', '}\n', '\n', '// File: contracts/GoBoardMetaDetails.sol\n', '\n', '/// @title This contract manages the meta details of EthernalGo. \n', '///     Registering to a board, splitting the revenues and other day-to-day actions that are unrelated to the actual game\n', '/// @author https://www.EthernalGo.com\n', '/// @dev See the GoGameLogic to understand the actual game mechanics and rules\n', 'contract GoBoardMetaDetails is GoGlobals {\n', '    \n', '    /// @dev The player added to board event can be used to check upon registration success\n', '    event PlayerAddedToBoard(uint boardId, address playerAddress);\n', '    \n', '    /// @dev The board updated status can be used to get the new board status\n', '    event BoardStatusUpdated(uint boardId, BoardStatus newStatus);\n', '    \n', '    /// @dev The player withdrawn his accumulated balance \n', '    event PlayerWithdrawnBalance(address playerAddress);\n', '    \n', '    /// @dev Simple wrapper to return the number of boards in total\n', '    function getTotalNumberOfBoards() public view returns(uint) {\n', '        return allBoards.length;\n', '    }\n', '\n', '    /// @notice We would like to easily and transparantly share the game&#39;s statistics with anyone and present on the web-app\n', '    function getCompletedGamesStatistics() public view returns(uint, uint) {\n', '        uint completed = 0;\n', '        uint ethPaid = 0;\n', '        \n', '        // @dev Go through all the boards, we start with 1 as it&#39;s an unsigned int\n', '        for (uint i = 1; i <= allBoards.length; i++) {\n', '\n', '            // Get the current board\n', '            GoBoard storage board = allBoards[i - 1];\n', '            \n', '            // Check if it was a victory, otherwise it&#39;s not interesting as the players just got their deposit back\n', '            if ((board.status == BoardStatus.BlackWin) || (board.status == BoardStatus.WhiteWin)) {\n', '                ++completed;\n', '\n', '                // We need to query the table stakes as the board&#39;s balance will be zero once a game is finished\n', '                ethPaid += board.tableStakes.mul(2);\n', '            }\n', '        }\n', '\n', '        return (completed, ethPaid);\n', '    }\n', '\n', '    /// @dev At this point there is no support for returning dynamic arrays (it&#39;s supported for web3 calls but not for internal testing) so we will "only" present the recent 50 games per player.\n', '    uint8 constant PAGE_SIZE = 50;\n', '\n', '    /// @dev Make sure this board is in waiting for result status\n', '    modifier boardWaitingToResolve(uint boardId){\n', '        require(allBoards[boardId].status == BoardStatus.WaitingToResolve);\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board is in one of the end of game states\n', '    modifier boardGameEnded(GoBoard storage board){\n', '        require(isEndGameStatus(board.status));\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board still has balance\n', '    modifier boardNotPaid(GoBoard storage board){\n', '        require(board.boardBalance > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board still has a spot for at least one player to join\n', '    modifier boardWaitingForPlayers(uint boardId){\n', '        require(allBoards[boardId].status == BoardStatus.WaitForOpponent &&\n', '                (allBoards[boardId].blackAddress == 0 || \n', '                 allBoards[boardId].whiteAddress == 0));\n', '        _;\n', '    }\n', '\n', '    /// @dev Restricts games for the allowed table stakes\n', '    /// @param value the value we are looking for to register\n', '    modifier allowedValuesOnly(uint value){\n', '        bool didFindValue = false;\n', '        \n', '        // The number of tableStakesOptions can change hence it has to be dynamic\n', '        for (uint8 i = 0; i < tableStakesOptions.length; ++ i) {\n', '           if (value == tableStakesOptions[i])\n', '            didFindValue = true;\n', '        }\n', '\n', '        require (didFindValue);\n', '        _;\n', '    }\n', '\n', '    /// @dev Checks a status if and returns if it&#39;s an end game\n', '    /// @param status the value we are checking\n', '    /// @return true if it&#39;s an end-game status\n', '    function isEndGameStatus(BoardStatus status) public pure returns(bool) {\n', '        return (status == BoardStatus.BlackWin) || (status == BoardStatus.WhiteWin) || (status == BoardStatus.Draw) || (status == BoardStatus.Canceled);\n', '    }\n', '\n', '    /// @dev Gets the update time for a board\n', '    /// @param boardId The id of the board to check\n', '    /// @return the update timestamp in seconds\n', '    function getBoardUpdateTime(uint boardId) public view returns(uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.lastUpdate);\n', '    }\n', '\n', '    /// @dev Gets the current board status\n', '    /// @param boardId The id of the board to check\n', '    /// @return the current board status\n', '    function getBoardStatus(uint boardId) public view returns(BoardStatus) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.status);\n', '    }\n', '\n', '    /// @dev Gets the current balance of the board\n', '    /// @param boardId The id of the board to check\n', '    /// @return the current board balance in WEI\n', '    function getBoardBalance(uint boardId) public view returns(uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.boardBalance);\n', '    }\n', '\n', '    /// @dev Sets the current balance of the board, this is internal and is triggerred by functions run by external player actions\n', '    /// @param board The board to update\n', '    /// @param boardId The board&#39;s Id\n', '    /// @param newStatus The new status to set\n', '    function updateBoardStatus(GoBoard storage board, uint boardId, BoardStatus newStatus) internal {    \n', '        \n', '        // Save gas if we accidentally are trying to update to an existing update\n', '        if (newStatus != board.status) {\n', '            \n', '            // Set the new board status\n', '            board.status = newStatus;\n', '            \n', '            // Update the time (important for start and finish states)\n', '            board.lastUpdate = now;\n', '\n', '            // If this is an end game status\n', '            if (isEndGameStatus(newStatus)) {\n', '\n', '                // Credit the players accoriding to the board score\n', '                creditBoardGameRevenues(board);\n', '            }\n', '\n', '            // Notify status update\n', '            BoardStatusUpdated(boardId, newStatus);\n', '        }\n', '    }\n', '\n', '    /// @dev Overload to set the board status when we only have a boardId\n', '    /// @param boardId The boardId to update\n', '    /// @param newStatus The new status to set\n', '    function updateBoardStatus(uint boardId, BoardStatus newStatus) internal {\n', '        updateBoardStatus(allBoards[boardId], boardId, newStatus);\n', '    }\n', '\n', '    /// @dev Gets the player color given an address and board (overload for when we only have boardId)\n', '    /// @param boardId The boardId to check\n', '    /// @param searchAddress The player&#39;s address we are searching for\n', '    /// @return the player&#39;s color\n', '    function getPlayerColor(uint boardId, address searchAddress) internal view returns (PlayerColor) {\n', '        return (getPlayerColor(allBoards[boardId], searchAddress));\n', '    }\n', '    \n', '    /// @dev Gets the player color given an address and board\n', '    /// @param board The board to check\n', '    /// @param searchAddress The player&#39;s address we are searching for\n', '    /// @return the player&#39;s color\n', '    function getPlayerColor(GoBoard storage board, address searchAddress) internal view returns (PlayerColor) {\n', '\n', '        // Check if this is the black player\n', '        if (board.blackAddress == searchAddress) {\n', '            return (PlayerColor.Black);\n', '        }\n', '\n', '        // Check if this is the white player\n', '        if (board.whiteAddress == searchAddress) {\n', '            return (PlayerColor.White);\n', '        }\n', '\n', '        // We aren&#39;t suppose to try and get the color of a player if they aren&#39;t on the board\n', '        revert();\n', '    }\n', '\n', '    /// @dev Gets the player address given a color on the board\n', '    /// @param boardId The board to check\n', '    /// @param color The color of the player we want\n', '    /// @return the player&#39;s address\n', '    function getPlayerAddress(uint boardId, PlayerColor color) public view returns(address) {\n', '\n', '        // If it&#39;s the black player\n', '        if (color == PlayerColor.Black) {\n', '            return allBoards[boardId].blackAddress;\n', '        }\n', '\n', '        // If it&#39;s the white player\n', '        if (color == PlayerColor.White) {\n', '            return allBoards[boardId].whiteAddress;\n', '        }\n', '\n', '        // We aren&#39;t suppose to try and get the color of a player if they aren&#39;t on the board\n', '        revert();\n', '    }\n', '\n', '    /// @dev Check if a player is on board (overload for boardId)\n', '    /// @param boardId The board to check\n', '    /// @param searchAddress the player&#39;s address we want to check\n', '    /// @return true if the player is playing in the board\n', '    function isPlayerOnBoard(uint boardId, address searchAddress) public view returns(bool) {\n', '        return (isPlayerOnBoard(allBoards[boardId], searchAddress));\n', '    }\n', '\n', '    /// @dev Check if a player is on board\n', '    /// @param board The board to check\n', '    /// @param searchAddress the player&#39;s address we want to check\n', '    /// @return true if the player is playing in the board\n', '    function isPlayerOnBoard(GoBoard storage board, address searchAddress) private view returns(bool) {\n', '        return (board.blackAddress == searchAddress || board.whiteAddress == searchAddress);\n', '    }\n', '\n', '    /// @dev Check which player acts next\n', '    /// @param boardId The board to check\n', '    /// @return The color of the current player to act\n', '    function getNextTurnColor(uint boardId) public view returns(PlayerColor) {\n', '        return allBoards[boardId].nextTurnColor;\n', '    }\n', '\n', '    /// @notice This is the first function a player will be using in order to start playing. This function allows \n', '    ///  to register to an existing or a new board, depending on the current available boards.\n', '    ///  Upon registeration the player will pay the board&#39;s stakes and will be the black or white player.\n', '    ///  The black player also creates the board, and is the first player which gives a small advantage in the\n', '    ///  game, therefore we decided that the black player will be the one paying for the additional gas\n', '    ///  that is required to create the board.\n', '    /// @param  tableStakes The tablestakes to use, although this appears in the "value" of the message, we preferred to\n', '    ///  add it as an additional parameter for client use for clients that allow to customize the value parameter.\n', '    /// @return The boardId the player registered to (either a new board or an existing board)\n', '    function registerPlayerToBoard(uint tableStakes) external payable allowedValuesOnly(msg.value) whenNotPaused returns(uint) {\n', '        // Make sure the value and tableStakes are the same\n', '        require (msg.value == tableStakes);\n', '        GoBoard storage boardToJoin;\n', '        uint boardIDToJoin;\n', '        \n', '        // Check which board to connect to\n', '        (boardIDToJoin, boardToJoin) = getOrCreateWaitingBoard(tableStakes);\n', '        \n', '        // Add the player to the board (they already paid)\n', '        bool shouldStartGame = addPlayerToBoard(boardToJoin, tableStakes);\n', '\n', '        // Fire the event for anyone listening\n', '        PlayerAddedToBoard(boardIDToJoin, msg.sender);\n', '\n', '        // If we have both players, start the game\n', '        if (shouldStartGame) {\n', '\n', '            // Start the game\n', '            startBoardGame(boardToJoin, boardIDToJoin);\n', '        }\n', '\n', '        return boardIDToJoin;\n', '    }\n', '\n', '    /// @notice This function allows a player to cancel a match in the case they were waiting for an opponent for\n', '    ///  a long time but didn&#39;t find anyone and would want to get their deposit of table stakes back.\n', '    ///  That player may cancel the game as long as no opponent was found and the deposit will be returned in full (though gas fees still apply). The player will also need to withdraw funds from the contract after this action.\n', '    /// @param boardId The board to cancel\n', '    function cancelMatch(uint boardId) external {\n', '        \n', '        // Get the player\n', '        GoBoard storage board = allBoards[boardId];\n', '\n', '        // Make sure this player is on board\n', '        require(isPlayerOnBoard(boardId, msg.sender));\n', '\n', '        // Make sure that the game hasn&#39;t started\n', '        require(board.status == BoardStatus.WaitForOpponent);\n', '\n', '        // Update the board status to cancel (which also triggers the revenue sharing function)\n', '        updateBoardStatus(board, boardId, BoardStatus.Canceled);\n', '    }\n', '\n', '    /// @dev Gets the current player boards to present to the player as needed\n', '    /// @param activeTurnsOnly We might want to highlight the boards where the player is expected to act\n', '    /// @return an array of PAGE_SIZE with the number of boards found and the actual IDs\n', '    function getPlayerBoardsIDs(bool activeTurnsOnly) public view returns (uint, uint[PAGE_SIZE]) {\n', '        uint[PAGE_SIZE] memory playerBoardIDsToReturn;\n', '        uint numberOfPlayerBoardsToReturn = 0;\n', '        \n', '        // Look at the recent boards until you find a player board\n', '        for (uint currBoard = allBoards.length; currBoard > 0 && numberOfPlayerBoardsToReturn < PAGE_SIZE; currBoard--) {\n', '            uint boardID = currBoard - 1;            \n', '\n', '            // We only care about boards the player is in\n', '            if (isPlayerOnBoard(boardID, msg.sender)) {\n', '\n', '                // Check if the player is the next to act, or just include it if it wasn&#39;t requested\n', '                if (!activeTurnsOnly || getNextTurnColor(boardID) == getPlayerColor(boardID, msg.sender)) {\n', '                    playerBoardIDsToReturn[numberOfPlayerBoardsToReturn] = boardID;\n', '                    ++numberOfPlayerBoardsToReturn;\n', '                }\n', '            }\n', '        }\n', '\n', '        return (numberOfPlayerBoardsToReturn, playerBoardIDsToReturn);\n', '    }\n', '\n', '    /// @dev Creates a new board in case no board was found for a player to register\n', '    /// @param tableStakesToUse The value used to set the board\n', '    /// @return the id of new board (which is it&#39;s position in the allBoards array)\n', '    function createNewGoBoard(uint tableStakesToUse) private returns(uint, GoBoard storage) {\n', '        GoBoard memory newBoard = GoBoard({lastUpdate: now,\n', '                                           isHonorableLoss: false,\n', '                                           tableStakes: tableStakesToUse,\n', '                                           boardBalance: 0,\n', '                                           blackAddress: 0,\n', '                                           whiteAddress: 0,\n', '                                           blackPeriodsRemaining: PLAYER_START_PERIODS,\n', '                                           whitePeriodsRemaining: PLAYER_START_PERIODS,\n', '                                           nextTurnColor: PlayerColor.None,\n', '                                           status:BoardStatus.WaitForOpponent,\n', '                                           didPassPrevTurn:false});\n', '\n', '        uint boardId = allBoards.push(newBoard) - 1;\n', '        return (boardId, allBoards[boardId]);\n', '    }\n', '\n', '    /// @dev Creates a new board in case no board was found for a player to register\n', '    /// @param tableStakes The value used to set the board\n', '    /// @return the id of new board (which is it&#39;s position in the allBoards array)\n', '    function getOrCreateWaitingBoard(uint tableStakes) private returns(uint, GoBoard storage) {\n', '        bool wasFound = false;\n', '        uint selectedBoardId = 0;\n', '        GoBoard storage board;\n', '\n', '        // First, try to find a board that has an empty spot and the right table stakes\n', '        for (uint i = allBoards.length; i > 0 && !wasFound; --i) {\n', '            board = allBoards[i - 1];\n', '\n', '            // Make sure this board is already waiting and it&#39;s stakes are the same\n', '            if (board.tableStakes == tableStakes) {\n', '                \n', '                // If this board is waiting for an opponent\n', '                if (board.status == BoardStatus.WaitForOpponent) {\n', '                    \n', '                    // Awesome, we have the board and we are done\n', '                    wasFound = true;\n', '                    selectedBoardId = i - 1;\n', '                }\n', '\n', '                // If we found the rights stakes board but it isn&#39;t waiting for player we won&#39;t have another empty board.\n', '                // We need to create a new one\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Create a new board if we couldn&#39;t find one\n', '        if (!wasFound) {\n', '            (selectedBoardId, board) = createNewGoBoard(tableStakes);\n', '        }\n', '\n', '        return (selectedBoardId, board);\n', '    }\n', '\n', '    /// @dev Starts the game and sets everything up for the match\n', '    /// @param board The board to update with the starting data\n', '    /// @param boardId The board&#39;s Id\n', '    function startBoardGame(GoBoard storage board, uint boardId) private {\n', '        \n', '        // Make sure both players are present\n', '        require(board.blackAddress != 0 && board.whiteAddress != 0);\n', '        \n', '        // The black is always the first player in GO\n', '        board.nextTurnColor = PlayerColor.Black;\n', '\n', '        // Save the game start time and set the game status to in progress\n', '        updateBoardStatus(board, boardId, BoardStatus.InProgress);\n', '    }\n', '\n', '    /// @dev Handles the registration of a player to a board\n', '    /// @param board The board to update with the starting data\n', '    /// @param paidAmount The amount the player paid to start playing (will be added to the board balance)\n', '    /// @return true if the game should be started\n', '    function addPlayerToBoard(GoBoard storage board, uint paidAmount) private returns(bool) {\n', '        \n', '        // Make suew we are still waitinf for opponent (otherwise we can&#39;t add players)\n', '        bool shouldStartTheGame = false;\n', '        require(board.status == BoardStatus.WaitForOpponent);\n', '\n', '        // Check that the player isn&#39;t already on the board, otherwise they would pay twice for a single board... :( \n', '        require(!isPlayerOnBoard(board, msg.sender));\n', '\n', '        // We always add the black player first as they created the board\n', '        if (board.blackAddress == 0) {\n', '            board.blackAddress = msg.sender;\n', '        \n', '        // If we have a black player, add the white player\n', '        } else if (board.whiteAddress == 0) {\n', '            board.whiteAddress = msg.sender;\n', '        \n', '            // Once the white player has been added, we can start the match\n', '            shouldStartTheGame = true;           \n', '\n', '        // If both addresses are occuipied and we got here, it&#39;s a problem\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        // Credit the board with what we know \n', '        board.boardBalance += paidAmount;\n', '\n', '        return shouldStartTheGame;\n', '    }\n', '\n', '    /// @dev Helper function to caclulate how much time a player used since now\n', '    /// @param lastUpdate the timestamp of last update of the board\n', '    /// @return the number of periods used for this time\n', '    function getTimePeriodsUsed(uint lastUpdate) private view returns(uint8) {\n', '        return uint8(now.sub(lastUpdate).div(PLAYER_TURN_SINGLE_PERIOD));\n', '    }\n', '\n', '    /// @notice Convinience function to help present how much time a player has.\n', '    /// @param boardId the board to check.\n', '    /// @param color the color of the player to check.\n', '    /// @return The number of time periods the player has, the number of seconds per each period and the total number of seconds for convinience.\n', '    function getPlayerRemainingTime(uint boardId, PlayerColor color) view external returns (uint, uint, uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '\n', '        // Always verify we can act\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', '        // Get the total remaining time:\n', '        uint timePeriods = getPlayerTimePeriods(board, color);\n', '        uint totalTimeRemaining = timePeriods * PLAYER_TURN_SINGLE_PERIOD;\n', '\n', '        // If this is the acting player\n', '        if (color == board.nextTurnColor) {\n', '\n', '            // Calc time periods for player\n', '            uint timePeriodsUsed = getTimePeriodsUsed(board.lastUpdate);\n', '            if (timePeriods > timePeriodsUsed) {\n', '                timePeriods -= timePeriodsUsed;\n', '            } else {\n', '                timePeriods = 0;\n', '            }\n', '\n', '            // Calc total time remaining  for player\n', '            uint timeUsed = (now - board.lastUpdate);\n', '            \n', '            // Safely reduce the time used\n', '            if (totalTimeRemaining > timeUsed) {\n', '                totalTimeRemaining -= timeUsed;\n', '            \n', '            // A player can&#39;t have less than zero time to act\n', '            } else {\n', '                totalTimeRemaining = 0;\n', '            }\n', '        }\n', '        \n', '        return (timePeriods, PLAYER_TURN_SINGLE_PERIOD, totalTimeRemaining);\n', '    }\n', '\n', '    /// @dev After a player acted we might need to reduce the number of remaining time periods.\n', '    /// @param board The board the player acted upon.\n', '    /// @param color the color of the player that acted.\n', '    /// @param timePeriodsUsed the number of periods the player used.\n', '    function updatePlayerTimePeriods(GoBoard storage board, PlayerColor color, uint8 timePeriodsUsed) internal {\n', '\n', '        // Reduce from the black player\n', '        if (color == PlayerColor.Black) {\n', '\n', '            // The player can&#39;t have less than 0 periods remaining\n', '            board.blackPeriodsRemaining = board.blackPeriodsRemaining > timePeriodsUsed ? board.blackPeriodsRemaining - timePeriodsUsed : 0;\n', '        // Reduce from the white player\n', '        } else if (color == PlayerColor.White) {\n', '            \n', '            // The player can&#39;t have less than 0 periods remaining\n', '            board.whitePeriodsRemaining = board.whitePeriodsRemaining > timePeriodsUsed ? board.whitePeriodsRemaining - timePeriodsUsed : 0;\n', '\n', '        // We are not supposed to get here\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Helper function to access the time periods of a player in a board.\n', '    /// @param board The board to check.\n', '    /// @param color the color of the player to check.\n', '    /// @return The number of time periods remaining for this player\n', '    function getPlayerTimePeriods(GoBoard storage board, PlayerColor color) internal view returns (uint8) {\n', '\n', '        // For the black player\n', '        if (color == PlayerColor.Black) {\n', '            return board.blackPeriodsRemaining;\n', '\n', '        // For the white player\n', '        } else if (color == PlayerColor.White) {\n', '            return board.whitePeriodsRemaining;\n', '\n', '        // We are not supposed to get here\n', '        } else {\n', '\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @notice The main function to split game revenues, this is triggered only by changing the game&#39;s state\n', '    ///  to one of the ending game states.\n', '    ///  We make sure this board has a balance and that it&#39;s only running once a board game has ended\n', '    ///  We used numbers for easier read through as this function is critical for the revenue sharing model\n', '    /// @param board The board the credit will come from.\n', '    function creditBoardGameRevenues(GoBoard storage board) private boardGameEnded(board) boardNotPaid(board) {\n', '                \n', '        // Get the shares from the globals\n', '        uint updatedHostShare = HOST_SHARE;\n', '        uint updatedLoserShare = 0;\n', '\n', '        // Start accumulating funds for each participant and EthernalGo&#39;s CFO\n', '        uint amountBlack = 0;\n', '        uint amountWhite = 0;\n', '        uint amountCFO = 0;\n', '        uint fullAmount = 1000;\n', '\n', '        // Incentivize resigns and quick end-games for the loser\n', '        if (board.status == BoardStatus.BlackWin || board.status == BoardStatus.WhiteWin) {\n', '            \n', '            // In case the game ended honorably (not by time out), the loser will get credit (from the CFO&#39;s share)\n', '            if (board.isHonorableLoss) {\n', '                \n', '                // Reduce the credit from the CFO\n', '                updatedHostShare = HOST_SHARE - HONORABLE_LOSS_BONUS;\n', '                \n', '                // Add to the loser share\n', '                updatedLoserShare = HONORABLE_LOSS_BONUS;\n', '            }\n', '\n', '            // If black won\n', '            if (board.status == BoardStatus.BlackWin) {\n', '                \n', '                // Black should get the winner share\n', '                amountBlack = board.boardBalance.mul(WINNER_SHARE).div(fullAmount);\n', '                \n', '                // White player should get the updated loser share (with or without the bonus)\n', '                amountWhite = board.boardBalance.mul(updatedLoserShare).div(fullAmount);\n', '            }\n', '\n', '            // If white won\n', '            if (board.status == BoardStatus.WhiteWin) {\n', '\n', '                // White should get the winner share\n', '                amountWhite = board.boardBalance.mul(WINNER_SHARE).div(fullAmount);\n', '                \n', '                // Black should get the updated loser share (with or without the bonus)\n', '                amountBlack = board.boardBalance.mul(updatedLoserShare).div(fullAmount);\n', '            }\n', '\n', '            // The CFO should get the updates share if the game ended as expected\n', '            amountCFO = board.boardBalance.mul(updatedHostShare).div(fullAmount);\n', '        }\n', '\n', '        // If the match ended in a draw or it was cancelled\n', '        if (board.status == BoardStatus.Draw || board.status == BoardStatus.Canceled) {\n', '            \n', '            // The CFO is not taking a share from draw or a cancelled match\n', '            amountCFO = 0;\n', '\n', '            // If the white player was on board, we should split the balance in half\n', '            if (board.whiteAddress != 0) {\n', '\n', '                // Each player gets half of the balance\n', '                amountBlack = board.boardBalance.div(2);\n', '                amountWhite = board.boardBalance.div(2);\n', '\n', '            // If there was only the black player, they should get the entire balance\n', '            } else {\n', '                amountBlack = board.boardBalance;\n', '            }\n', '        }\n', '\n', '        // Make sure we are going to split the entire amount and nothing gets left behind\n', '        assert(amountBlack + amountWhite + amountCFO == board.boardBalance);\n', '        \n', '        // Reset the balance\n', '        board.boardBalance = 0;\n', '\n', '        // Async sends to the participants (this means each participant will be required to withdraw funds)\n', '        asyncSend(board.blackAddress, amountBlack);\n', '        asyncSend(board.whiteAddress, amountWhite);\n', '        asyncSend(CFO, amountCFO);\n', '    }\n', '\n', '    /// @dev withdraw accumulated balance, called by payee.\n', '    function withdrawPayments() public {\n', '\n', '        // Call Zeppelin&#39;s withdrawPayments\n', '        super.withdrawPayments();\n', '\n', '        // Send an event\n', '        PlayerWithdrawnBalance(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/GoGameLogic.sol\n', '\n', '/// @title The actual game logic for EthernalGo - setting stones, capturing, etc.\n', '/// @author https://www.EthernalGo.com\n', 'contract GoGameLogic is GoBoardMetaDetails {\n', '\n', '    /// @dev The StoneAddedToBoard event is fired when a new stone is added to the board, \n', '    ///  and includes the board Id, stone color, row & column. This event will fire even if it was a suicide stone.\n', '    event StoneAddedToBoard(uint boardId, PlayerColor color, uint8 row, uint8 col);\n', '\n', '    /// @dev The PlayerPassedTurn event is fired when a player passes turn \n', '    ///  and includes the board Id, color.\n', '    event PlayerPassedTurn(uint boardId, PlayerColor color);\n', '    \n', '    /// @dev Updating the player&#39;s time periods left, according to the current time - board last update time.\n', '    ///  If the player does not have enough time and chose to act, the game will end and the player will lose.\n', '    /// @param board is the relevant board.\n', '    /// @param boardId is the board&#39;s Id.\n', '    /// @param color is the color of the player we want to update.\n', '    /// @return true if the player can continue playing, otherwise false.\n', '    function updatePlayerTime(GoBoard storage board, uint boardId, PlayerColor color) private returns(bool) {\n', '\n', '        // Verify that the board is in progress and that it&#39;s the current player\n', '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == color);\n', '\n', '        // Calculate time periods used by the player\n', '        uint timePeriodsUsed = uint(now.sub(board.lastUpdate).div(PLAYER_TURN_SINGLE_PERIOD));\n', '\n', '        // Subtract time periods if needed\n', '        if (timePeriodsUsed > 0) {\n', '\n', '            // Can&#39;t spend more than MAX_UINT8\n', '            updatePlayerTimePeriods(board, color, timePeriodsUsed > MAX_UINT8 ? MAX_UINT8 : uint8(timePeriodsUsed));\n', '\n', '            // The player losses when there aren&#39;t any time periods left\n', '            if (getPlayerTimePeriods(board, color) == 0) {\n', '                playerLost(board, boardId, color);\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Updates the board status according to the players score.\n', '    ///  Can only be called when the board is in a &#39;waitingToResolve&#39; status.\n', '    /// @param boardId is the board to check and update\n', '    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {\n', '        \n', '        uint8 blackScore;\n', '        uint8 whiteScore;\n', '\n', '        // Get the players&#39; score\n', '        (blackScore, whiteScore) = calculateBoardScore(boardId);\n', '\n', '        // Default to Draw\n', '        BoardStatus status = BoardStatus.Draw;\n', '\n', '        // If black&#39;s score is bigger than white&#39;s score, black is the winner\n', '        if (blackScore > whiteScore) {\n', '\n', '            status = BoardStatus.BlackWin;\n', '        // If white&#39;s score is bigger, white is the winner\n', '        } else if (whiteScore > blackScore) {\n', '\n', '            status = BoardStatus.WhiteWin;\n', '        }\n', '\n', '        // Update the board&#39;s status\n', '        updateBoardStatus(boardId, status);\n', '    }\n', '\n', '    /// @notice Performs a pass action on a psecific board, only by the current active color player.\n', '    /// @param boardId is the board to perform pass on.\n', '    function passTurn(uint boardId) external {\n', '\n', '        // Get the board & player\n', '        GoBoard storage board = allBoards[boardId];\n', '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '\n', '        // Verify the player can act\n', '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == activeColor);\n', '        \n', '        // Check if this player can act\n', '        if (updatePlayerTime(board, boardId, activeColor)) {\n', '\n', '            // If it&#39;s the second straight pass, the game is over\n', '            if (board.didPassPrevTurn) {\n', '\n', '                // Finishing the game like this is considered honorable\n', '                board.isHonorableLoss = true;\n', '\n', '                // On second pass, the board status changes to &#39;WaitingToResolve&#39;\n', '                updateBoardStatus(board, boardId, BoardStatus.WaitingToResolve);\n', '\n', '            // If it&#39;s the first pass, we can simply continue\n', '            } else {\n', '\n', '                // Move to the next player, flag that it was a pass action\n', '                nextTurn(board);\n', '                board.didPassPrevTurn = true;\n', '\n', '                // Notify the player passed turn\n', '                PlayerPassedTurn(boardId, activeColor);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Resigns a player from a specific board, can get called by either player on the board.\n', '    /// @param boardId is the board to resign from.\n', '    function resignFromMatch(uint boardId) external {\n', '\n', '        // Get the board, make sure it&#39;s in progress\n', '        GoBoard storage board = allBoards[boardId];\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', '        // Get the sender&#39;s color\n', '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '                \n', '        // Finishing the game like this is considered honorable\n', '        board.isHonorableLoss = true;\n', '\n', '        // Set that color as the losing player\n', '        playerLost(board, boardId, activeColor);\n', '    }\n', '\n', '    /// @notice Claiming the current acting player on the board is out of time, thus losses the game.\n', '    /// @param boardId is the board to claim it on.\n', '    function claimActingPlayerOutOfTime(uint boardId) external {\n', '\n', '        // Get the board, make sure it&#39;s in progress\n', '        GoBoard storage board = allBoards[boardId];\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', '        // Get the acting player color\n', '        PlayerColor actingPlayerColor = getNextTurnColor(boardId);\n', '\n', '        // Calculate remaining allowed time for the acting player\n', '        uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods(board, actingPlayerColor);\n', '\n', '        // If the player doesn&#39;t have enough time left, the player losses\n', '        if (playerTimeRemaining < now - board.lastUpdate) {\n', '            playerLost(board, boardId, actingPlayerColor);\n', '        }\n', '    }\n', '\n', '    /// @dev Update a board status with a losing color\n', '    /// @param board is the board to update.\n', '    /// @param boardId is the board&#39;s Id.\n', '    /// @param color is the losing player&#39;s color.\n', '    function playerLost(GoBoard storage board, uint boardId, PlayerColor color) private {\n', '\n', '        // If black is the losing color, white wins\n', '        if (color == PlayerColor.Black) {\n', '            updateBoardStatus(board, boardId, BoardStatus.WhiteWin);\n', '        \n', '        // If white is the losing color, black wins\n', '        } else if (color == PlayerColor.White) {\n', '            updateBoardStatus(board, boardId, BoardStatus.BlackWin);\n', '\n', '        // There&#39;s an error, revert\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Internally used to move to the next turn, by switching sides and updating the board last update time.\n', '    /// @param board is the board to update.\n', '    function nextTurn(GoBoard storage board) private {\n', '        \n', '        // Switch sides\n', '        board.nextTurnColor = board.nextTurnColor == PlayerColor.Black ? PlayerColor.White : PlayerColor.Black;\n', '\n', '        // Last update time\n', '        board.lastUpdate = now;\n', '    }\n', '    \n', '    /// @notice Adding a stone to a specific board and position (row & col).\n', '    ///  Requires the board to be in progress, that the caller is the acting player, \n', '    ///  and that the spot on the board is empty.\n', '    /// @param boardId is the board to add the stone to.\n', '    /// @param row is the row for the new stone.\n', '    /// @param col is the column for the new stone.\n', '    function addStoneToBoard(uint boardId, uint8 row, uint8 col) external {\n', '        \n', '        // Get the board & sender&#39;s color\n', '        GoBoard storage board = allBoards[boardId];\n', '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '\n', '        // Verify the player can act\n', '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == activeColor);\n', '\n', '        // Calculate the position\n', '        uint8 position = row * BOARD_ROW_SIZE + col;\n', '        \n', '        // Check that it&#39;s an empty spot\n', '        require(board.positionToColor[position] == 0);\n', '\n', '        // Update the player timeout (if the player doesn&#39;t have time left, discontinue)\n', '        if (updatePlayerTime(board, boardId, activeColor)) {\n', '\n', '            // Set the stone on the board\n', '            board.positionToColor[position] = uint8(activeColor);\n', '\n', '            // Run capture / suidice logic\n', '            updateCaptures(board, position, uint8(activeColor));\n', '            \n', '            // Next turn logic\n', '            nextTurn(board);\n', '\n', '            // Clear the pass flag\n', '            if (board.didPassPrevTurn) {\n', '                board.didPassPrevTurn = false;\n', '            }\n', '\n', '            // Fire the event\n', '            StoneAddedToBoard(boardId, activeColor, row, col);\n', '        }\n', '    }\n', '\n', '    /// @notice Returns a board&#39;s row details, specifies which color occupies which cell in that row.\n', '    /// @dev It returns a row and not the entire board because some nodes might fail to return arrays larger than ~50.\n', '    /// @param boardId is the board to inquire.\n', '    /// @param row is the row to get details on.\n', '    /// @return an array that contains the colors occupying each cell in that row.\n', '    function getBoardRowDetails(uint boardId, uint8 row) external view returns (uint8[BOARD_ROW_SIZE]) {\n', '        \n', '        // The array to return\n', '        uint8[BOARD_ROW_SIZE] memory rowToReturn;\n', '\n', '        // For all columns, calculate the position and get the current status\n', '        for (uint8 col = 0; col < BOARD_ROW_SIZE; col++) {\n', '            \n', '            uint8 position = row * BOARD_ROW_SIZE + col;\n', '            rowToReturn[col] = allBoards[boardId].positionToColor[position];\n', '        }\n', '\n', '        // Return the array\n', '        return (rowToReturn);\n', '    }\n', '\n', '    /// @notice Returns the current color of a specific position in a board.\n', '    /// @param boardId is the board to inquire.\n', '    /// @param row is part of the position to get details on.\n', '    /// @param col is part of the position to get details on.\n', '    /// @return the color occupying that position.\n', '    function getBoardSingleSpaceDetails(uint boardId, uint8 row, uint8 col) external view returns (uint8) {\n', '\n', '        uint8 position = row * BOARD_ROW_SIZE + col;\n', '        return allBoards[boardId].positionToColor[position];\n', '    }\n', '\n', '    /// @dev Calcultes whether a position captures an enemy group, or whether it&#39;s a suicide. \n', '    ///  Updates the board accoridngly (clears captured groups, or the suiciding stone).\n', '    /// @param board the board to check and update\n', '    /// @param position the position of the new stone\n', '    /// @param positionColor the color of the new stone (this param is sent to spare another reading op)\n', '    function updateCaptures(GoBoard storage board, uint8 position, uint8 positionColor) private {\n', '\n', '        // Group positions, used later\n', '        uint8[BOARD_SIZE] memory group;\n', '\n', '        // Is group captured, or free\n', '        bool isGroupCaptured;\n', '\n', '        // In order to save gas, we check suicide only if the position is fully surrounded and doesn&#39;t capture enemy groups \n', '        bool shouldCheckSuicide = true;\n', '\n', '        // Get the position&#39;s adjacent cells\n', '        uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', '        // Run as long as there an adjacent cell, or until we reach the end of the array\n', '        for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '\n', '            // Get the adjacent cell&#39;s color\n', '            uint8 currColor = board.positionToColor[adjacentArray[currAdjacentIndex]];\n', '\n', '            // If the enemy&#39;s color\n', '            if (currColor != 0 && currColor != positionColor) {\n', '\n', '                // Get the group&#39;s info\n', '                (group, isGroupCaptured) = getGroup(board, adjacentArray[currAdjacentIndex], currColor);\n', '\n', '                // Captured a group\n', '                if (isGroupCaptured) {\n', '                    \n', '                    // Clear the group from the board\n', '                    for (uint8 currGroupIndex = 0; currGroupIndex < BOARD_SIZE && group[currGroupIndex] < MAX_UINT8; currGroupIndex++) {\n', '\n', '                        board.positionToColor[group[currGroupIndex]] = 0;\n', '                    }\n', '\n', '                    // Shouldn&#39;t check suicide\n', '                    shouldCheckSuicide = false;\n', '                }\n', '            // There&#39;s an empty adjacent cell\n', '            } else if (currColor == 0) {\n', '\n', '                // Shouldn&#39;t check suicide\n', '                shouldCheckSuicide = false;\n', '            }\n', '        }\n', '\n', '        // Detect suicide if needed\n', '        if (shouldCheckSuicide) {\n', '\n', '            // Get the new stone&#39;s surrounding group\n', '            (group, isGroupCaptured) = getGroup(board, position, positionColor);\n', '\n', '            // If the group is captured, it&#39;s a suicide move, remove it\n', '            if (isGroupCaptured) {\n', '\n', '                // Clear added stone\n', '                board.positionToColor[position] = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Internally used to set a flag in a shrinked board array (used to save gas costs).\n', '    /// @param visited the array to update.\n', '    /// @param position the position on the board we want to flag.\n', '    /// @param flag the flag we want to set (either 1 or 2).\n', '    function setFlag(uint8[SHRINKED_BOARD_SIZE] visited, uint8 position, uint8 flag) private pure {\n', '        visited[position / 4] |= flag << ((position % 4) * 2);\n', '    }\n', '\n', '    /// @dev Internally used to check whether a flag in a shrinked board array is set.\n', '    /// @param visited the array to check.\n', '    /// @param position the position on the board we want to check.\n', '    /// @param flag the flag we want to check (either 1 or 2).\n', '    /// @return true if that flag is set, false otherwise.\n', '    function isFlagSet(uint8[SHRINKED_BOARD_SIZE] visited, uint8 position, uint8 flag) private pure returns (bool) {\n', '        return (visited[position / 4] & (flag << ((position % 4) * 2)) > 0);\n', '    }\n', '\n', '    // Get group visited flags\n', '    uint8 constant FLAG_POSITION_WAS_IN_STACK = 1;\n', '    uint8 constant FLAG_DID_VISIT_POSITION = 2;\n', '\n', '    /// @dev Gets a group starting from the position & color sent. In order for a stone to be part of the group,\n', '    ///  it must match the original stone&#39;s color, and be connected to it - either directly, or through adjacent cells.\n', '    ///  A group is captured if there aren&#39;t any empty cells around it.\n', '    ///  The function supports both returning colored groups - white/black, and empty groups (for that case, isGroupCaptured isn&#39;t relevant).\n', '    /// @param board the board to check and update\n', '    /// @param position the position of the starting stone\n', '    /// @param positionColor the color of the starting stone (this param is sent to spare another reading op)\n', '    /// @return an array that contains the positions of the group, \n', '    ///  a boolean that specifies whether the group is captured or not.\n', '    ///  In order to save gas, if a group isn&#39;t captured, the array might not contain the enitre group.\n', '    function getGroup(GoBoard storage board, uint8 position, uint8 positionColor) private view returns (uint8[BOARD_SIZE], bool isGroupCaptured) {\n', '\n', '        // The return array, and its size\n', '        uint8[BOARD_SIZE] memory groupPositions;\n', '        uint8 groupSize = 0;\n', '        \n', '        // Flagging visited locations\n', '        uint8[SHRINKED_BOARD_SIZE] memory visited;\n', '\n', '        // Stack of waiting positions, the first position to check is the sent position\n', '        uint8[BOARD_SIZE] memory stack;\n', '        stack[0] = position;\n', '        uint8 stackSize = 1;\n', '\n', '        // That position was added to the stack\n', '        setFlag(visited, position, FLAG_POSITION_WAS_IN_STACK);\n', '\n', '        // Run as long as there are positions in the stack\n', '        while (stackSize > 0) {\n', '\n', '            // Take the last position and clear it\n', '            position = stack[--stackSize];\n', '            stack[stackSize] = 0;\n', '\n', '            // Only if we didn&#39;t visit that stone before\n', '            if (!isFlagSet(visited, position, FLAG_DID_VISIT_POSITION)) {\n', '                \n', '                // Set the flag so we won&#39;t visit it again\n', '                setFlag(visited, position, FLAG_DID_VISIT_POSITION);\n', '\n', '                // Add that position to the return value\n', '                groupPositions[groupSize++] = position;\n', '\n', '                // Get that position adjacent cells\n', '                uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', '                // Run over the adjacent cells\n', '                for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '                    \n', '                    // Get the current adjacent cell color\n', '                    uint8 currColor = board.positionToColor[adjacentArray[currAdjacentIndex]];\n', '                    \n', '                    // If it&#39;s the same color as the original position color\n', '                    if (currColor == positionColor) {\n', '\n', '                        // Add that position to the stack\n', '                        if (!isFlagSet(visited, adjacentArray[currAdjacentIndex], FLAG_POSITION_WAS_IN_STACK)) {\n', '                            stack[stackSize++] = adjacentArray[currAdjacentIndex];\n', '                            setFlag(visited, adjacentArray[currAdjacentIndex], FLAG_POSITION_WAS_IN_STACK);\n', '                        }\n', '                    // If that position is empty, the group isn&#39;t captured, no need to continue running\n', '                    } else if (currColor == 0) {\n', '                        \n', '                        return (groupPositions, false);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Flag the end of the group array only if needed\n', '        if (groupSize < BOARD_SIZE) {\n', '            groupPositions[groupSize] = MAX_UINT8;\n', '        }\n', '        \n', '        // The group is captured, return it\n', '        return (groupPositions, true);\n', '    }\n', '    \n', '    /// The max number of adjacent cells is 4\n', '    uint8 constant MAX_ADJACENT_CELLS = 4;\n', '\n', '    /// @dev returns the adjacent positions for a given position.\n', '    /// @param position to get its adjacents.\n', '    /// @return the adjacent positions array, filled with MAX_INT8 in case there aren&#39;t 4 adjacent positions.\n', '    function getAdjacentCells(uint8 position) private pure returns (uint8[MAX_ADJACENT_CELLS]) {\n', '\n', '        // Init the return array and current index\n', '        uint8[MAX_ADJACENT_CELLS] memory returnCells = [MAX_UINT8, MAX_UINT8, MAX_UINT8, MAX_UINT8];\n', '        uint8 adjacentCellsIndex = 0;\n', '\n', '        // Set the up position, if relevant\n', '        if (position / BOARD_ROW_SIZE > 0) {\n', '            returnCells[adjacentCellsIndex++] = position - BOARD_ROW_SIZE;\n', '        }\n', '\n', '        // Set the down position, if relevant\n', '        if (position / BOARD_ROW_SIZE < BOARD_ROW_SIZE - 1) {\n', '            returnCells[adjacentCellsIndex++] = position + BOARD_ROW_SIZE;\n', '        }\n', '\n', '        // Set the left position, if relevant\n', '        if (position % BOARD_ROW_SIZE > 0) {\n', '            returnCells[adjacentCellsIndex++] = position - 1;\n', '        }\n', '\n', '        // Set the right position, if relevant\n', '        if (position % BOARD_ROW_SIZE < BOARD_ROW_SIZE - 1) {\n', '            returnCells[adjacentCellsIndex++] = position + 1;\n', '        }\n', '\n', '        return returnCells;\n', '    }\n', '\n', '    /// @notice Calculates the board&#39;s score, using area scoring.\n', '    /// @param boardId the board to calculate the score for.\n', '    /// @return blackScore & whiteScore, the players&#39; scores.\n', '    function calculateBoardScore(uint boardId) public view returns (uint8 blackScore, uint8 whiteScore) {\n', '\n', '        GoBoard storage board = allBoards[boardId];\n', '        uint8[BOARD_SIZE] memory boardEmptyGroups;\n', '        uint8 maxEmptyGroupId;\n', '        (boardEmptyGroups, maxEmptyGroupId) = getBoardEmptyGroups(board);\n', '        uint8[BOARD_SIZE] memory groupsSize;\n', '        uint8[BOARD_SIZE] memory groupsState;\n', '        \n', '        blackScore = 0;\n', '        whiteScore = 0;\n', '\n', '        // Count stones and find empty territories\n', '        for (uint8 position = 0; position < BOARD_SIZE; position++) {\n', '\n', '            if (PlayerColor(board.positionToColor[position]) == PlayerColor.Black) {\n', '\n', '                blackScore++;\n', '            } else if (PlayerColor(board.positionToColor[position]) == PlayerColor.White) {\n', '\n', '                whiteScore++;\n', '            } else {\n', '\n', '                uint8 groupId = boardEmptyGroups[position];\n', '                groupsSize[groupId]++;\n', '\n', '                // Checking is needed only if we didn&#39;t find the group is adjacent to the two colors already\n', '                if ((groupsState[groupId] & uint8(PlayerColor.Black) == 0) || (groupsState[groupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                    uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', '                    // Check adjacent cells to mark the group&#39;s bounderies\n', '                    for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '\n', '                        // Check if the group has a black boundry\n', '                        if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.Black) && \n', '                            (groupsState[groupId] & uint8(PlayerColor.Black) == 0)) {\n', '\n', '                            groupsState[groupId] |= uint8(PlayerColor.Black);\n', '\n', '                        // Check if the group has a white boundry\n', '                        } else if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.White) && \n', '                                   (groupsState[groupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                            groupsState[groupId] |= uint8(PlayerColor.White);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Add territories size to the relevant player\n', '        for (uint8 currGroupId = 1; currGroupId < maxEmptyGroupId; currGroupId++) {\n', '            \n', '            // Check if it&#39;s a black territory\n', '            if ((groupsState[currGroupId] & uint8(PlayerColor.Black) > 0) &&\n', '                (groupsState[currGroupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                blackScore += groupsSize[currGroupId];\n', '\n', '            // Check if it&#39;s a white territory\n', '            } else if ((groupsState[currGroupId] & uint8(PlayerColor.White) > 0) &&\n', '                       (groupsState[currGroupId] & uint8(PlayerColor.Black) == 0)) {\n', '\n', '                whiteScore += groupsSize[currGroupId];\n', '            }\n', '        }\n', '\n', '        return (blackScore, whiteScore);\n', '    }\n', '\n', '    /// @dev IDs empty groups on the board.\n', '    /// @param board the board to map.\n', '    /// @return an array that contains the mapped empty group ids, and the max empty group id\n', '    function getBoardEmptyGroups(GoBoard storage board) private view returns (uint8[BOARD_SIZE], uint8) {\n', '\n', '        uint8[BOARD_SIZE] memory boardEmptyGroups;\n', '        uint8 nextGroupId = 1;\n', '\n', '        for (uint8 position = 0; position < BOARD_SIZE; position++) {\n', '\n', '            PlayerColor currPositionColor = PlayerColor(board.positionToColor[position]);\n', '\n', '            if ((currPositionColor == PlayerColor.None) && (boardEmptyGroups[position] == 0)) {\n', '\n', '                uint8[BOARD_SIZE] memory emptyGroup;\n', '                bool isGroupCaptured;\n', '                (emptyGroup, isGroupCaptured) = getGroup(board, position, 0);\n', '\n', '                for (uint8 currGroupIndex = 0; currGroupIndex < BOARD_SIZE && emptyGroup[currGroupIndex] < MAX_UINT8; currGroupIndex++) {\n', '\n', '                    boardEmptyGroups[emptyGroup[currGroupIndex]] = nextGroupId;\n', '                }\n', '\n', '                nextGroupId++;\n', '            }\n', '        }\n', '\n', '        return (boardEmptyGroups, nextGroupId);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Destructible.sol\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/payment/PullPayment.sol\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(this.balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    assert(payee.send(payment));\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', '// File: contracts/GoGlobals.sol\n', '\n', '/// @title The base contract for EthernalGo, contains the admin functions and the globals used throught the game\n', '/// @author https://www.EthernalGo.com\n', '/// @dev See the GoGameLogic and GoBoardMetaDetails contract documentation to understand the actual game mechanics.\n', 'contract GoGlobals is Ownable, PullPayment, Destructible, Pausable {\n', '\n', '    // Used for simplifying capture calculations\n', '    uint8 constant MAX_UINT8 = 255;\n', '\n', '    // Used to dermine player color and who is up next\n', '    enum PlayerColor {None, Black, White}\n', '\n', '    ///    @dev Board status is a critical concept that determines which actions can be taken within each phase\n', '    ///        WaitForOpponent - When the first player has registered and waiting for a second player\n', '    ///        InProgress - The match is on! The acting player can choose between placing a stone or passing (or resigning)\n', '    ///        WaitingToResolve - Both players chose to pass their turn and we are waiting for the winner to ask the contract for  score count\n', '    ///        BlackWin, WhiteWin, Draw - Pretty self explanatory\n', '    ///        Canceled - The first player who joined the board is allowed to cancel a match if no opponent has joined yet\n', '    enum BoardStatus {WaitForOpponent, InProgress, WaitingToResolve, BlackWin, WhiteWin, Draw, Canceled}\n', '\n', '    // We staretd with a 9x9 rows\n', '    uint8 constant BOARD_ROW_SIZE = 9;\n', '    uint8 constant BOARD_SIZE = BOARD_ROW_SIZE ** 2;\n', '\n', '    // We use a shrinked board size to optimize gas costs\n', '    uint8 constant SHRINKED_BOARD_SIZE = 21;\n', '\n', '    // These are the shares each player and EthernalGo are getting for each game\n', '    uint public WINNER_SHARE;\n', '    uint public HOST_SHARE;\n', '    uint public HONORABLE_LOSS_BONUS;\n', '\n', '    // Each player gets PLAYER_TURN_SINGLE_PERIOD x PLAYER_START_PERIODS to act. These may change according to player feedback and network conjunction to optimize the playing experience\n', '    uint  public PLAYER_TURN_SINGLE_PERIOD = 4 minutes;\n', '    uint8 public PLAYER_START_PERIODS = 5;\n', '    \n', '    // We decided to restrict the table stakes to several options to allow for easier match-making\n', '    uint[] public tableStakesOptions;\n', '\n', '    // This is the main data field that contains access to all of the GoBoards that were created\n', '    GoBoard[] internal allBoards;\n', '\n', '    // The CFO is the only account that is allowed to withdraw funds\n', '    address public CFO;\n', '\n', '    // This is the main board structure and is instantiated for every new game\n', '    struct GoBoard {        \n', '        // We use the last update to determine how long has it been since the player could act\n', '        uint lastUpdate;\n', '        \n', '        // The table stakes marks how much ETH each participant needs to pay to register for the board\n', '        uint tableStakes;\n', '        \n', '        // The board balance keeps track of how much ETH this board has in order to see if we already distributed the payments for this match\n', '        uint boardBalance;\n', '\n', '        // Black and white player addresses\n', '        address blackAddress;\n', '        address whiteAddress;\n', '\n', '        // Black and white time periods remaining (initially they will be PLAYER_START_PERIODS)\n', '        uint8 blackPeriodsRemaining;\n', '        uint8 whitePeriodsRemaining;\n', '\n', '        // Keep track of double pass to finish the game\n', '        bool didPassPrevTurn;\n', '        \n', '        // Keep track of double pass to finish the game\n', '        bool isHonorableLoss;\n', '\n', "        // Who's next\n", '        PlayerColor nextTurnColor;\n', '\n', '        // Use a mapping to figure out which stone is set in which position. (Positions can be 0-BOARD_SIZE)\n', '        // @dev We decided not use an array to minimize the storage cost\n', '        mapping(uint8=>uint8) positionToColor;\n', '\n', "        // The board's current status        \n", '        BoardStatus status;\n', '    }\n', '\n', '    /// @notice The constructor is called with our inital values, they will probably change but this is what had in mind when developing the game.\n', '    function GoGlobals() public Ownable() PullPayment() Destructible() {\n', '\n', '        // Add initial price tiers so from variouos ranges\n', '        addPriceTier(0.5 ether);\n', '        addPriceTier(1 ether);\n', '        addPriceTier(5 ether);\n', '\n', "        // These are the inital shares we've had in mind when developing the game\n", '        updateShares(950, 50, 5);\n', '        \n', '        // The CFO will be the owner, but it will change soon after the contract is deployed\n', '        CFO = owner;\n', '    }\n', '\n', '    /// @notice In case we need extra price tiers (table stakes where people can play) we can add additional ones\n', '    /// @param price the price for the new price tier in WEI\n', '    function addPriceTier(uint price) public onlyOwner {\n', '        tableStakesOptions.push(price);\n', '    }\n', '\n', '    /// If we need to update price tiers\n', '    /// @param priceTier the tier index from the array\n', '    /// @param price the new price to set\n', '    function updatePriceTier(uint8 priceTier, uint price) public onlyOwner {\n', '        tableStakesOptions[priceTier] = price;\n', '    }\n', '\n', '    /// @notice If we need to adjust the amounts players or EthernalGo gets for each game\n', "    /// @param newWinnerShare the winner's share (out of 1000)\n", "    /// @param newHostShare EthernalGo's share (out of 1000)\n", '    /// @param newBonusShare Bonus that comes our of EthernalGo and goes to the loser in case of an honorable loss (out of 1000)\n', '    function updateShares(uint newWinnerShare, uint newHostShare, uint newBonusShare) public onlyOwner {\n', '        require(newWinnerShare + newHostShare == 1000);\n', '        WINNER_SHARE = newWinnerShare;\n', '        HOST_SHARE = newHostShare;\n', '        HONORABLE_LOSS_BONUS = newBonusShare;\n', '    }\n', '\n', '    /// @notice Separating the CFO and the CEO responsibilities requires the ability to set the CFO account\n', '    /// @param newCFO the new CFO\n', '    function setNewCFO(address newCFO) public onlyOwner {\n', '        require(newCFO != 0);\n', '        CFO = newCFO;\n', '    }\n', '\n', '    /// @notice Separating the CFO and the CEO responsibilities requires the ability to set the CFO account\n', '    /// @param secondsPerPeriod The number of seconds we would like each period to last\n', '    /// @param numberOfPeriods The number of of periods each player initially has\n', '    function updateGameTimes(uint secondsPerPeriod, uint8 numberOfPeriods) public onlyOwner {\n', '\n', '        PLAYER_TURN_SINGLE_PERIOD = secondsPerPeriod;\n', '        PLAYER_START_PERIODS = numberOfPeriods;\n', '    }\n', '\n', '    /// @dev Convinience function to access the shares\n', '    function getShares() public view returns(uint, uint, uint) {\n', '        return (WINNER_SHARE, HOST_SHARE, HONORABLE_LOSS_BONUS);\n', '    }\n', '}\n', '\n', '// File: contracts/GoBoardMetaDetails.sol\n', '\n', '/// @title This contract manages the meta details of EthernalGo. \n', '///     Registering to a board, splitting the revenues and other day-to-day actions that are unrelated to the actual game\n', '/// @author https://www.EthernalGo.com\n', '/// @dev See the GoGameLogic to understand the actual game mechanics and rules\n', 'contract GoBoardMetaDetails is GoGlobals {\n', '    \n', '    /// @dev The player added to board event can be used to check upon registration success\n', '    event PlayerAddedToBoard(uint boardId, address playerAddress);\n', '    \n', '    /// @dev The board updated status can be used to get the new board status\n', '    event BoardStatusUpdated(uint boardId, BoardStatus newStatus);\n', '    \n', '    /// @dev The player withdrawn his accumulated balance \n', '    event PlayerWithdrawnBalance(address playerAddress);\n', '    \n', '    /// @dev Simple wrapper to return the number of boards in total\n', '    function getTotalNumberOfBoards() public view returns(uint) {\n', '        return allBoards.length;\n', '    }\n', '\n', "    /// @notice We would like to easily and transparantly share the game's statistics with anyone and present on the web-app\n", '    function getCompletedGamesStatistics() public view returns(uint, uint) {\n', '        uint completed = 0;\n', '        uint ethPaid = 0;\n', '        \n', "        // @dev Go through all the boards, we start with 1 as it's an unsigned int\n", '        for (uint i = 1; i <= allBoards.length; i++) {\n', '\n', '            // Get the current board\n', '            GoBoard storage board = allBoards[i - 1];\n', '            \n', "            // Check if it was a victory, otherwise it's not interesting as the players just got their deposit back\n", '            if ((board.status == BoardStatus.BlackWin) || (board.status == BoardStatus.WhiteWin)) {\n', '                ++completed;\n', '\n', "                // We need to query the table stakes as the board's balance will be zero once a game is finished\n", '                ethPaid += board.tableStakes.mul(2);\n', '            }\n', '        }\n', '\n', '        return (completed, ethPaid);\n', '    }\n', '\n', '    /// @dev At this point there is no support for returning dynamic arrays (it\'s supported for web3 calls but not for internal testing) so we will "only" present the recent 50 games per player.\n', '    uint8 constant PAGE_SIZE = 50;\n', '\n', '    /// @dev Make sure this board is in waiting for result status\n', '    modifier boardWaitingToResolve(uint boardId){\n', '        require(allBoards[boardId].status == BoardStatus.WaitingToResolve);\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board is in one of the end of game states\n', '    modifier boardGameEnded(GoBoard storage board){\n', '        require(isEndGameStatus(board.status));\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board still has balance\n', '    modifier boardNotPaid(GoBoard storage board){\n', '        require(board.boardBalance > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Make sure this board still has a spot for at least one player to join\n', '    modifier boardWaitingForPlayers(uint boardId){\n', '        require(allBoards[boardId].status == BoardStatus.WaitForOpponent &&\n', '                (allBoards[boardId].blackAddress == 0 || \n', '                 allBoards[boardId].whiteAddress == 0));\n', '        _;\n', '    }\n', '\n', '    /// @dev Restricts games for the allowed table stakes\n', '    /// @param value the value we are looking for to register\n', '    modifier allowedValuesOnly(uint value){\n', '        bool didFindValue = false;\n', '        \n', '        // The number of tableStakesOptions can change hence it has to be dynamic\n', '        for (uint8 i = 0; i < tableStakesOptions.length; ++ i) {\n', '           if (value == tableStakesOptions[i])\n', '            didFindValue = true;\n', '        }\n', '\n', '        require (didFindValue);\n', '        _;\n', '    }\n', '\n', "    /// @dev Checks a status if and returns if it's an end game\n", '    /// @param status the value we are checking\n', "    /// @return true if it's an end-game status\n", '    function isEndGameStatus(BoardStatus status) public pure returns(bool) {\n', '        return (status == BoardStatus.BlackWin) || (status == BoardStatus.WhiteWin) || (status == BoardStatus.Draw) || (status == BoardStatus.Canceled);\n', '    }\n', '\n', '    /// @dev Gets the update time for a board\n', '    /// @param boardId The id of the board to check\n', '    /// @return the update timestamp in seconds\n', '    function getBoardUpdateTime(uint boardId) public view returns(uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.lastUpdate);\n', '    }\n', '\n', '    /// @dev Gets the current board status\n', '    /// @param boardId The id of the board to check\n', '    /// @return the current board status\n', '    function getBoardStatus(uint boardId) public view returns(BoardStatus) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.status);\n', '    }\n', '\n', '    /// @dev Gets the current balance of the board\n', '    /// @param boardId The id of the board to check\n', '    /// @return the current board balance in WEI\n', '    function getBoardBalance(uint boardId) public view returns(uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '        return (board.boardBalance);\n', '    }\n', '\n', '    /// @dev Sets the current balance of the board, this is internal and is triggerred by functions run by external player actions\n', '    /// @param board The board to update\n', "    /// @param boardId The board's Id\n", '    /// @param newStatus The new status to set\n', '    function updateBoardStatus(GoBoard storage board, uint boardId, BoardStatus newStatus) internal {    \n', '        \n', '        // Save gas if we accidentally are trying to update to an existing update\n', '        if (newStatus != board.status) {\n', '            \n', '            // Set the new board status\n', '            board.status = newStatus;\n', '            \n', '            // Update the time (important for start and finish states)\n', '            board.lastUpdate = now;\n', '\n', '            // If this is an end game status\n', '            if (isEndGameStatus(newStatus)) {\n', '\n', '                // Credit the players accoriding to the board score\n', '                creditBoardGameRevenues(board);\n', '            }\n', '\n', '            // Notify status update\n', '            BoardStatusUpdated(boardId, newStatus);\n', '        }\n', '    }\n', '\n', '    /// @dev Overload to set the board status when we only have a boardId\n', '    /// @param boardId The boardId to update\n', '    /// @param newStatus The new status to set\n', '    function updateBoardStatus(uint boardId, BoardStatus newStatus) internal {\n', '        updateBoardStatus(allBoards[boardId], boardId, newStatus);\n', '    }\n', '\n', '    /// @dev Gets the player color given an address and board (overload for when we only have boardId)\n', '    /// @param boardId The boardId to check\n', "    /// @param searchAddress The player's address we are searching for\n", "    /// @return the player's color\n", '    function getPlayerColor(uint boardId, address searchAddress) internal view returns (PlayerColor) {\n', '        return (getPlayerColor(allBoards[boardId], searchAddress));\n', '    }\n', '    \n', '    /// @dev Gets the player color given an address and board\n', '    /// @param board The board to check\n', "    /// @param searchAddress The player's address we are searching for\n", "    /// @return the player's color\n", '    function getPlayerColor(GoBoard storage board, address searchAddress) internal view returns (PlayerColor) {\n', '\n', '        // Check if this is the black player\n', '        if (board.blackAddress == searchAddress) {\n', '            return (PlayerColor.Black);\n', '        }\n', '\n', '        // Check if this is the white player\n', '        if (board.whiteAddress == searchAddress) {\n', '            return (PlayerColor.White);\n', '        }\n', '\n', "        // We aren't suppose to try and get the color of a player if they aren't on the board\n", '        revert();\n', '    }\n', '\n', '    /// @dev Gets the player address given a color on the board\n', '    /// @param boardId The board to check\n', '    /// @param color The color of the player we want\n', "    /// @return the player's address\n", '    function getPlayerAddress(uint boardId, PlayerColor color) public view returns(address) {\n', '\n', "        // If it's the black player\n", '        if (color == PlayerColor.Black) {\n', '            return allBoards[boardId].blackAddress;\n', '        }\n', '\n', "        // If it's the white player\n", '        if (color == PlayerColor.White) {\n', '            return allBoards[boardId].whiteAddress;\n', '        }\n', '\n', "        // We aren't suppose to try and get the color of a player if they aren't on the board\n", '        revert();\n', '    }\n', '\n', '    /// @dev Check if a player is on board (overload for boardId)\n', '    /// @param boardId The board to check\n', "    /// @param searchAddress the player's address we want to check\n", '    /// @return true if the player is playing in the board\n', '    function isPlayerOnBoard(uint boardId, address searchAddress) public view returns(bool) {\n', '        return (isPlayerOnBoard(allBoards[boardId], searchAddress));\n', '    }\n', '\n', '    /// @dev Check if a player is on board\n', '    /// @param board The board to check\n', "    /// @param searchAddress the player's address we want to check\n", '    /// @return true if the player is playing in the board\n', '    function isPlayerOnBoard(GoBoard storage board, address searchAddress) private view returns(bool) {\n', '        return (board.blackAddress == searchAddress || board.whiteAddress == searchAddress);\n', '    }\n', '\n', '    /// @dev Check which player acts next\n', '    /// @param boardId The board to check\n', '    /// @return The color of the current player to act\n', '    function getNextTurnColor(uint boardId) public view returns(PlayerColor) {\n', '        return allBoards[boardId].nextTurnColor;\n', '    }\n', '\n', '    /// @notice This is the first function a player will be using in order to start playing. This function allows \n', '    ///  to register to an existing or a new board, depending on the current available boards.\n', "    ///  Upon registeration the player will pay the board's stakes and will be the black or white player.\n", '    ///  The black player also creates the board, and is the first player which gives a small advantage in the\n', '    ///  game, therefore we decided that the black player will be the one paying for the additional gas\n', '    ///  that is required to create the board.\n', '    /// @param  tableStakes The tablestakes to use, although this appears in the "value" of the message, we preferred to\n', '    ///  add it as an additional parameter for client use for clients that allow to customize the value parameter.\n', '    /// @return The boardId the player registered to (either a new board or an existing board)\n', '    function registerPlayerToBoard(uint tableStakes) external payable allowedValuesOnly(msg.value) whenNotPaused returns(uint) {\n', '        // Make sure the value and tableStakes are the same\n', '        require (msg.value == tableStakes);\n', '        GoBoard storage boardToJoin;\n', '        uint boardIDToJoin;\n', '        \n', '        // Check which board to connect to\n', '        (boardIDToJoin, boardToJoin) = getOrCreateWaitingBoard(tableStakes);\n', '        \n', '        // Add the player to the board (they already paid)\n', '        bool shouldStartGame = addPlayerToBoard(boardToJoin, tableStakes);\n', '\n', '        // Fire the event for anyone listening\n', '        PlayerAddedToBoard(boardIDToJoin, msg.sender);\n', '\n', '        // If we have both players, start the game\n', '        if (shouldStartGame) {\n', '\n', '            // Start the game\n', '            startBoardGame(boardToJoin, boardIDToJoin);\n', '        }\n', '\n', '        return boardIDToJoin;\n', '    }\n', '\n', '    /// @notice This function allows a player to cancel a match in the case they were waiting for an opponent for\n', "    ///  a long time but didn't find anyone and would want to get their deposit of table stakes back.\n", '    ///  That player may cancel the game as long as no opponent was found and the deposit will be returned in full (though gas fees still apply). The player will also need to withdraw funds from the contract after this action.\n', '    /// @param boardId The board to cancel\n', '    function cancelMatch(uint boardId) external {\n', '        \n', '        // Get the player\n', '        GoBoard storage board = allBoards[boardId];\n', '\n', '        // Make sure this player is on board\n', '        require(isPlayerOnBoard(boardId, msg.sender));\n', '\n', "        // Make sure that the game hasn't started\n", '        require(board.status == BoardStatus.WaitForOpponent);\n', '\n', '        // Update the board status to cancel (which also triggers the revenue sharing function)\n', '        updateBoardStatus(board, boardId, BoardStatus.Canceled);\n', '    }\n', '\n', '    /// @dev Gets the current player boards to present to the player as needed\n', '    /// @param activeTurnsOnly We might want to highlight the boards where the player is expected to act\n', '    /// @return an array of PAGE_SIZE with the number of boards found and the actual IDs\n', '    function getPlayerBoardsIDs(bool activeTurnsOnly) public view returns (uint, uint[PAGE_SIZE]) {\n', '        uint[PAGE_SIZE] memory playerBoardIDsToReturn;\n', '        uint numberOfPlayerBoardsToReturn = 0;\n', '        \n', '        // Look at the recent boards until you find a player board\n', '        for (uint currBoard = allBoards.length; currBoard > 0 && numberOfPlayerBoardsToReturn < PAGE_SIZE; currBoard--) {\n', '            uint boardID = currBoard - 1;            \n', '\n', '            // We only care about boards the player is in\n', '            if (isPlayerOnBoard(boardID, msg.sender)) {\n', '\n', "                // Check if the player is the next to act, or just include it if it wasn't requested\n", '                if (!activeTurnsOnly || getNextTurnColor(boardID) == getPlayerColor(boardID, msg.sender)) {\n', '                    playerBoardIDsToReturn[numberOfPlayerBoardsToReturn] = boardID;\n', '                    ++numberOfPlayerBoardsToReturn;\n', '                }\n', '            }\n', '        }\n', '\n', '        return (numberOfPlayerBoardsToReturn, playerBoardIDsToReturn);\n', '    }\n', '\n', '    /// @dev Creates a new board in case no board was found for a player to register\n', '    /// @param tableStakesToUse The value used to set the board\n', "    /// @return the id of new board (which is it's position in the allBoards array)\n", '    function createNewGoBoard(uint tableStakesToUse) private returns(uint, GoBoard storage) {\n', '        GoBoard memory newBoard = GoBoard({lastUpdate: now,\n', '                                           isHonorableLoss: false,\n', '                                           tableStakes: tableStakesToUse,\n', '                                           boardBalance: 0,\n', '                                           blackAddress: 0,\n', '                                           whiteAddress: 0,\n', '                                           blackPeriodsRemaining: PLAYER_START_PERIODS,\n', '                                           whitePeriodsRemaining: PLAYER_START_PERIODS,\n', '                                           nextTurnColor: PlayerColor.None,\n', '                                           status:BoardStatus.WaitForOpponent,\n', '                                           didPassPrevTurn:false});\n', '\n', '        uint boardId = allBoards.push(newBoard) - 1;\n', '        return (boardId, allBoards[boardId]);\n', '    }\n', '\n', '    /// @dev Creates a new board in case no board was found for a player to register\n', '    /// @param tableStakes The value used to set the board\n', "    /// @return the id of new board (which is it's position in the allBoards array)\n", '    function getOrCreateWaitingBoard(uint tableStakes) private returns(uint, GoBoard storage) {\n', '        bool wasFound = false;\n', '        uint selectedBoardId = 0;\n', '        GoBoard storage board;\n', '\n', '        // First, try to find a board that has an empty spot and the right table stakes\n', '        for (uint i = allBoards.length; i > 0 && !wasFound; --i) {\n', '            board = allBoards[i - 1];\n', '\n', "            // Make sure this board is already waiting and it's stakes are the same\n", '            if (board.tableStakes == tableStakes) {\n', '                \n', '                // If this board is waiting for an opponent\n', '                if (board.status == BoardStatus.WaitForOpponent) {\n', '                    \n', '                    // Awesome, we have the board and we are done\n', '                    wasFound = true;\n', '                    selectedBoardId = i - 1;\n', '                }\n', '\n', "                // If we found the rights stakes board but it isn't waiting for player we won't have another empty board.\n", '                // We need to create a new one\n', '                break;\n', '            }\n', '        }\n', '\n', "        // Create a new board if we couldn't find one\n", '        if (!wasFound) {\n', '            (selectedBoardId, board) = createNewGoBoard(tableStakes);\n', '        }\n', '\n', '        return (selectedBoardId, board);\n', '    }\n', '\n', '    /// @dev Starts the game and sets everything up for the match\n', '    /// @param board The board to update with the starting data\n', "    /// @param boardId The board's Id\n", '    function startBoardGame(GoBoard storage board, uint boardId) private {\n', '        \n', '        // Make sure both players are present\n', '        require(board.blackAddress != 0 && board.whiteAddress != 0);\n', '        \n', '        // The black is always the first player in GO\n', '        board.nextTurnColor = PlayerColor.Black;\n', '\n', '        // Save the game start time and set the game status to in progress\n', '        updateBoardStatus(board, boardId, BoardStatus.InProgress);\n', '    }\n', '\n', '    /// @dev Handles the registration of a player to a board\n', '    /// @param board The board to update with the starting data\n', '    /// @param paidAmount The amount the player paid to start playing (will be added to the board balance)\n', '    /// @return true if the game should be started\n', '    function addPlayerToBoard(GoBoard storage board, uint paidAmount) private returns(bool) {\n', '        \n', "        // Make suew we are still waitinf for opponent (otherwise we can't add players)\n", '        bool shouldStartTheGame = false;\n', '        require(board.status == BoardStatus.WaitForOpponent);\n', '\n', "        // Check that the player isn't already on the board, otherwise they would pay twice for a single board... :( \n", '        require(!isPlayerOnBoard(board, msg.sender));\n', '\n', '        // We always add the black player first as they created the board\n', '        if (board.blackAddress == 0) {\n', '            board.blackAddress = msg.sender;\n', '        \n', '        // If we have a black player, add the white player\n', '        } else if (board.whiteAddress == 0) {\n', '            board.whiteAddress = msg.sender;\n', '        \n', '            // Once the white player has been added, we can start the match\n', '            shouldStartTheGame = true;           \n', '\n', "        // If both addresses are occuipied and we got here, it's a problem\n", '        } else {\n', '            revert();\n', '        }\n', '\n', '        // Credit the board with what we know \n', '        board.boardBalance += paidAmount;\n', '\n', '        return shouldStartTheGame;\n', '    }\n', '\n', '    /// @dev Helper function to caclulate how much time a player used since now\n', '    /// @param lastUpdate the timestamp of last update of the board\n', '    /// @return the number of periods used for this time\n', '    function getTimePeriodsUsed(uint lastUpdate) private view returns(uint8) {\n', '        return uint8(now.sub(lastUpdate).div(PLAYER_TURN_SINGLE_PERIOD));\n', '    }\n', '\n', '    /// @notice Convinience function to help present how much time a player has.\n', '    /// @param boardId the board to check.\n', '    /// @param color the color of the player to check.\n', '    /// @return The number of time periods the player has, the number of seconds per each period and the total number of seconds for convinience.\n', '    function getPlayerRemainingTime(uint boardId, PlayerColor color) view external returns (uint, uint, uint) {\n', '        GoBoard storage board = allBoards[boardId];\n', '\n', '        // Always verify we can act\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', '        // Get the total remaining time:\n', '        uint timePeriods = getPlayerTimePeriods(board, color);\n', '        uint totalTimeRemaining = timePeriods * PLAYER_TURN_SINGLE_PERIOD;\n', '\n', '        // If this is the acting player\n', '        if (color == board.nextTurnColor) {\n', '\n', '            // Calc time periods for player\n', '            uint timePeriodsUsed = getTimePeriodsUsed(board.lastUpdate);\n', '            if (timePeriods > timePeriodsUsed) {\n', '                timePeriods -= timePeriodsUsed;\n', '            } else {\n', '                timePeriods = 0;\n', '            }\n', '\n', '            // Calc total time remaining  for player\n', '            uint timeUsed = (now - board.lastUpdate);\n', '            \n', '            // Safely reduce the time used\n', '            if (totalTimeRemaining > timeUsed) {\n', '                totalTimeRemaining -= timeUsed;\n', '            \n', "            // A player can't have less than zero time to act\n", '            } else {\n', '                totalTimeRemaining = 0;\n', '            }\n', '        }\n', '        \n', '        return (timePeriods, PLAYER_TURN_SINGLE_PERIOD, totalTimeRemaining);\n', '    }\n', '\n', '    /// @dev After a player acted we might need to reduce the number of remaining time periods.\n', '    /// @param board The board the player acted upon.\n', '    /// @param color the color of the player that acted.\n', '    /// @param timePeriodsUsed the number of periods the player used.\n', '    function updatePlayerTimePeriods(GoBoard storage board, PlayerColor color, uint8 timePeriodsUsed) internal {\n', '\n', '        // Reduce from the black player\n', '        if (color == PlayerColor.Black) {\n', '\n', "            // The player can't have less than 0 periods remaining\n", '            board.blackPeriodsRemaining = board.blackPeriodsRemaining > timePeriodsUsed ? board.blackPeriodsRemaining - timePeriodsUsed : 0;\n', '        // Reduce from the white player\n', '        } else if (color == PlayerColor.White) {\n', '            \n', "            // The player can't have less than 0 periods remaining\n", '            board.whitePeriodsRemaining = board.whitePeriodsRemaining > timePeriodsUsed ? board.whitePeriodsRemaining - timePeriodsUsed : 0;\n', '\n', '        // We are not supposed to get here\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Helper function to access the time periods of a player in a board.\n', '    /// @param board The board to check.\n', '    /// @param color the color of the player to check.\n', '    /// @return The number of time periods remaining for this player\n', '    function getPlayerTimePeriods(GoBoard storage board, PlayerColor color) internal view returns (uint8) {\n', '\n', '        // For the black player\n', '        if (color == PlayerColor.Black) {\n', '            return board.blackPeriodsRemaining;\n', '\n', '        // For the white player\n', '        } else if (color == PlayerColor.White) {\n', '            return board.whitePeriodsRemaining;\n', '\n', '        // We are not supposed to get here\n', '        } else {\n', '\n', '            revert();\n', '        }\n', '    }\n', '\n', "    /// @notice The main function to split game revenues, this is triggered only by changing the game's state\n", '    ///  to one of the ending game states.\n', "    ///  We make sure this board has a balance and that it's only running once a board game has ended\n", '    ///  We used numbers for easier read through as this function is critical for the revenue sharing model\n', '    /// @param board The board the credit will come from.\n', '    function creditBoardGameRevenues(GoBoard storage board) private boardGameEnded(board) boardNotPaid(board) {\n', '                \n', '        // Get the shares from the globals\n', '        uint updatedHostShare = HOST_SHARE;\n', '        uint updatedLoserShare = 0;\n', '\n', "        // Start accumulating funds for each participant and EthernalGo's CFO\n", '        uint amountBlack = 0;\n', '        uint amountWhite = 0;\n', '        uint amountCFO = 0;\n', '        uint fullAmount = 1000;\n', '\n', '        // Incentivize resigns and quick end-games for the loser\n', '        if (board.status == BoardStatus.BlackWin || board.status == BoardStatus.WhiteWin) {\n', '            \n', "            // In case the game ended honorably (not by time out), the loser will get credit (from the CFO's share)\n", '            if (board.isHonorableLoss) {\n', '                \n', '                // Reduce the credit from the CFO\n', '                updatedHostShare = HOST_SHARE - HONORABLE_LOSS_BONUS;\n', '                \n', '                // Add to the loser share\n', '                updatedLoserShare = HONORABLE_LOSS_BONUS;\n', '            }\n', '\n', '            // If black won\n', '            if (board.status == BoardStatus.BlackWin) {\n', '                \n', '                // Black should get the winner share\n', '                amountBlack = board.boardBalance.mul(WINNER_SHARE).div(fullAmount);\n', '                \n', '                // White player should get the updated loser share (with or without the bonus)\n', '                amountWhite = board.boardBalance.mul(updatedLoserShare).div(fullAmount);\n', '            }\n', '\n', '            // If white won\n', '            if (board.status == BoardStatus.WhiteWin) {\n', '\n', '                // White should get the winner share\n', '                amountWhite = board.boardBalance.mul(WINNER_SHARE).div(fullAmount);\n', '                \n', '                // Black should get the updated loser share (with or without the bonus)\n', '                amountBlack = board.boardBalance.mul(updatedLoserShare).div(fullAmount);\n', '            }\n', '\n', '            // The CFO should get the updates share if the game ended as expected\n', '            amountCFO = board.boardBalance.mul(updatedHostShare).div(fullAmount);\n', '        }\n', '\n', '        // If the match ended in a draw or it was cancelled\n', '        if (board.status == BoardStatus.Draw || board.status == BoardStatus.Canceled) {\n', '            \n', '            // The CFO is not taking a share from draw or a cancelled match\n', '            amountCFO = 0;\n', '\n', '            // If the white player was on board, we should split the balance in half\n', '            if (board.whiteAddress != 0) {\n', '\n', '                // Each player gets half of the balance\n', '                amountBlack = board.boardBalance.div(2);\n', '                amountWhite = board.boardBalance.div(2);\n', '\n', '            // If there was only the black player, they should get the entire balance\n', '            } else {\n', '                amountBlack = board.boardBalance;\n', '            }\n', '        }\n', '\n', '        // Make sure we are going to split the entire amount and nothing gets left behind\n', '        assert(amountBlack + amountWhite + amountCFO == board.boardBalance);\n', '        \n', '        // Reset the balance\n', '        board.boardBalance = 0;\n', '\n', '        // Async sends to the participants (this means each participant will be required to withdraw funds)\n', '        asyncSend(board.blackAddress, amountBlack);\n', '        asyncSend(board.whiteAddress, amountWhite);\n', '        asyncSend(CFO, amountCFO);\n', '    }\n', '\n', '    /// @dev withdraw accumulated balance, called by payee.\n', '    function withdrawPayments() public {\n', '\n', "        // Call Zeppelin's withdrawPayments\n", '        super.withdrawPayments();\n', '\n', '        // Send an event\n', '        PlayerWithdrawnBalance(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/GoGameLogic.sol\n', '\n', '/// @title The actual game logic for EthernalGo - setting stones, capturing, etc.\n', '/// @author https://www.EthernalGo.com\n', 'contract GoGameLogic is GoBoardMetaDetails {\n', '\n', '    /// @dev The StoneAddedToBoard event is fired when a new stone is added to the board, \n', '    ///  and includes the board Id, stone color, row & column. This event will fire even if it was a suicide stone.\n', '    event StoneAddedToBoard(uint boardId, PlayerColor color, uint8 row, uint8 col);\n', '\n', '    /// @dev The PlayerPassedTurn event is fired when a player passes turn \n', '    ///  and includes the board Id, color.\n', '    event PlayerPassedTurn(uint boardId, PlayerColor color);\n', '    \n', "    /// @dev Updating the player's time periods left, according to the current time - board last update time.\n", '    ///  If the player does not have enough time and chose to act, the game will end and the player will lose.\n', '    /// @param board is the relevant board.\n', "    /// @param boardId is the board's Id.\n", '    /// @param color is the color of the player we want to update.\n', '    /// @return true if the player can continue playing, otherwise false.\n', '    function updatePlayerTime(GoBoard storage board, uint boardId, PlayerColor color) private returns(bool) {\n', '\n', "        // Verify that the board is in progress and that it's the current player\n", '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == color);\n', '\n', '        // Calculate time periods used by the player\n', '        uint timePeriodsUsed = uint(now.sub(board.lastUpdate).div(PLAYER_TURN_SINGLE_PERIOD));\n', '\n', '        // Subtract time periods if needed\n', '        if (timePeriodsUsed > 0) {\n', '\n', "            // Can't spend more than MAX_UINT8\n", '            updatePlayerTimePeriods(board, color, timePeriodsUsed > MAX_UINT8 ? MAX_UINT8 : uint8(timePeriodsUsed));\n', '\n', "            // The player losses when there aren't any time periods left\n", '            if (getPlayerTimePeriods(board, color) == 0) {\n', '                playerLost(board, boardId, color);\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Updates the board status according to the players score.\n', "    ///  Can only be called when the board is in a 'waitingToResolve' status.\n", '    /// @param boardId is the board to check and update\n', '    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {\n', '        \n', '        uint8 blackScore;\n', '        uint8 whiteScore;\n', '\n', "        // Get the players' score\n", '        (blackScore, whiteScore) = calculateBoardScore(boardId);\n', '\n', '        // Default to Draw\n', '        BoardStatus status = BoardStatus.Draw;\n', '\n', "        // If black's score is bigger than white's score, black is the winner\n", '        if (blackScore > whiteScore) {\n', '\n', '            status = BoardStatus.BlackWin;\n', "        // If white's score is bigger, white is the winner\n", '        } else if (whiteScore > blackScore) {\n', '\n', '            status = BoardStatus.WhiteWin;\n', '        }\n', '\n', "        // Update the board's status\n", '        updateBoardStatus(boardId, status);\n', '    }\n', '\n', '    /// @notice Performs a pass action on a psecific board, only by the current active color player.\n', '    /// @param boardId is the board to perform pass on.\n', '    function passTurn(uint boardId) external {\n', '\n', '        // Get the board & player\n', '        GoBoard storage board = allBoards[boardId];\n', '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '\n', '        // Verify the player can act\n', '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == activeColor);\n', '        \n', '        // Check if this player can act\n', '        if (updatePlayerTime(board, boardId, activeColor)) {\n', '\n', "            // If it's the second straight pass, the game is over\n", '            if (board.didPassPrevTurn) {\n', '\n', '                // Finishing the game like this is considered honorable\n', '                board.isHonorableLoss = true;\n', '\n', "                // On second pass, the board status changes to 'WaitingToResolve'\n", '                updateBoardStatus(board, boardId, BoardStatus.WaitingToResolve);\n', '\n', "            // If it's the first pass, we can simply continue\n", '            } else {\n', '\n', '                // Move to the next player, flag that it was a pass action\n', '                nextTurn(board);\n', '                board.didPassPrevTurn = true;\n', '\n', '                // Notify the player passed turn\n', '                PlayerPassedTurn(boardId, activeColor);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Resigns a player from a specific board, can get called by either player on the board.\n', '    /// @param boardId is the board to resign from.\n', '    function resignFromMatch(uint boardId) external {\n', '\n', "        // Get the board, make sure it's in progress\n", '        GoBoard storage board = allBoards[boardId];\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', "        // Get the sender's color\n", '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '                \n', '        // Finishing the game like this is considered honorable\n', '        board.isHonorableLoss = true;\n', '\n', '        // Set that color as the losing player\n', '        playerLost(board, boardId, activeColor);\n', '    }\n', '\n', '    /// @notice Claiming the current acting player on the board is out of time, thus losses the game.\n', '    /// @param boardId is the board to claim it on.\n', '    function claimActingPlayerOutOfTime(uint boardId) external {\n', '\n', "        // Get the board, make sure it's in progress\n", '        GoBoard storage board = allBoards[boardId];\n', '        require(board.status == BoardStatus.InProgress);\n', '\n', '        // Get the acting player color\n', '        PlayerColor actingPlayerColor = getNextTurnColor(boardId);\n', '\n', '        // Calculate remaining allowed time for the acting player\n', '        uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods(board, actingPlayerColor);\n', '\n', "        // If the player doesn't have enough time left, the player losses\n", '        if (playerTimeRemaining < now - board.lastUpdate) {\n', '            playerLost(board, boardId, actingPlayerColor);\n', '        }\n', '    }\n', '\n', '    /// @dev Update a board status with a losing color\n', '    /// @param board is the board to update.\n', "    /// @param boardId is the board's Id.\n", "    /// @param color is the losing player's color.\n", '    function playerLost(GoBoard storage board, uint boardId, PlayerColor color) private {\n', '\n', '        // If black is the losing color, white wins\n', '        if (color == PlayerColor.Black) {\n', '            updateBoardStatus(board, boardId, BoardStatus.WhiteWin);\n', '        \n', '        // If white is the losing color, black wins\n', '        } else if (color == PlayerColor.White) {\n', '            updateBoardStatus(board, boardId, BoardStatus.BlackWin);\n', '\n', "        // There's an error, revert\n", '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Internally used to move to the next turn, by switching sides and updating the board last update time.\n', '    /// @param board is the board to update.\n', '    function nextTurn(GoBoard storage board) private {\n', '        \n', '        // Switch sides\n', '        board.nextTurnColor = board.nextTurnColor == PlayerColor.Black ? PlayerColor.White : PlayerColor.Black;\n', '\n', '        // Last update time\n', '        board.lastUpdate = now;\n', '    }\n', '    \n', '    /// @notice Adding a stone to a specific board and position (row & col).\n', '    ///  Requires the board to be in progress, that the caller is the acting player, \n', '    ///  and that the spot on the board is empty.\n', '    /// @param boardId is the board to add the stone to.\n', '    /// @param row is the row for the new stone.\n', '    /// @param col is the column for the new stone.\n', '    function addStoneToBoard(uint boardId, uint8 row, uint8 col) external {\n', '        \n', "        // Get the board & sender's color\n", '        GoBoard storage board = allBoards[boardId];\n', '        PlayerColor activeColor = getPlayerColor(board, msg.sender);\n', '\n', '        // Verify the player can act\n', '        require(board.status == BoardStatus.InProgress && board.nextTurnColor == activeColor);\n', '\n', '        // Calculate the position\n', '        uint8 position = row * BOARD_ROW_SIZE + col;\n', '        \n', "        // Check that it's an empty spot\n", '        require(board.positionToColor[position] == 0);\n', '\n', "        // Update the player timeout (if the player doesn't have time left, discontinue)\n", '        if (updatePlayerTime(board, boardId, activeColor)) {\n', '\n', '            // Set the stone on the board\n', '            board.positionToColor[position] = uint8(activeColor);\n', '\n', '            // Run capture / suidice logic\n', '            updateCaptures(board, position, uint8(activeColor));\n', '            \n', '            // Next turn logic\n', '            nextTurn(board);\n', '\n', '            // Clear the pass flag\n', '            if (board.didPassPrevTurn) {\n', '                board.didPassPrevTurn = false;\n', '            }\n', '\n', '            // Fire the event\n', '            StoneAddedToBoard(boardId, activeColor, row, col);\n', '        }\n', '    }\n', '\n', "    /// @notice Returns a board's row details, specifies which color occupies which cell in that row.\n", '    /// @dev It returns a row and not the entire board because some nodes might fail to return arrays larger than ~50.\n', '    /// @param boardId is the board to inquire.\n', '    /// @param row is the row to get details on.\n', '    /// @return an array that contains the colors occupying each cell in that row.\n', '    function getBoardRowDetails(uint boardId, uint8 row) external view returns (uint8[BOARD_ROW_SIZE]) {\n', '        \n', '        // The array to return\n', '        uint8[BOARD_ROW_SIZE] memory rowToReturn;\n', '\n', '        // For all columns, calculate the position and get the current status\n', '        for (uint8 col = 0; col < BOARD_ROW_SIZE; col++) {\n', '            \n', '            uint8 position = row * BOARD_ROW_SIZE + col;\n', '            rowToReturn[col] = allBoards[boardId].positionToColor[position];\n', '        }\n', '\n', '        // Return the array\n', '        return (rowToReturn);\n', '    }\n', '\n', '    /// @notice Returns the current color of a specific position in a board.\n', '    /// @param boardId is the board to inquire.\n', '    /// @param row is part of the position to get details on.\n', '    /// @param col is part of the position to get details on.\n', '    /// @return the color occupying that position.\n', '    function getBoardSingleSpaceDetails(uint boardId, uint8 row, uint8 col) external view returns (uint8) {\n', '\n', '        uint8 position = row * BOARD_ROW_SIZE + col;\n', '        return allBoards[boardId].positionToColor[position];\n', '    }\n', '\n', "    /// @dev Calcultes whether a position captures an enemy group, or whether it's a suicide. \n", '    ///  Updates the board accoridngly (clears captured groups, or the suiciding stone).\n', '    /// @param board the board to check and update\n', '    /// @param position the position of the new stone\n', '    /// @param positionColor the color of the new stone (this param is sent to spare another reading op)\n', '    function updateCaptures(GoBoard storage board, uint8 position, uint8 positionColor) private {\n', '\n', '        // Group positions, used later\n', '        uint8[BOARD_SIZE] memory group;\n', '\n', '        // Is group captured, or free\n', '        bool isGroupCaptured;\n', '\n', "        // In order to save gas, we check suicide only if the position is fully surrounded and doesn't capture enemy groups \n", '        bool shouldCheckSuicide = true;\n', '\n', "        // Get the position's adjacent cells\n", '        uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', '        // Run as long as there an adjacent cell, or until we reach the end of the array\n', '        for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '\n', "            // Get the adjacent cell's color\n", '            uint8 currColor = board.positionToColor[adjacentArray[currAdjacentIndex]];\n', '\n', "            // If the enemy's color\n", '            if (currColor != 0 && currColor != positionColor) {\n', '\n', "                // Get the group's info\n", '                (group, isGroupCaptured) = getGroup(board, adjacentArray[currAdjacentIndex], currColor);\n', '\n', '                // Captured a group\n', '                if (isGroupCaptured) {\n', '                    \n', '                    // Clear the group from the board\n', '                    for (uint8 currGroupIndex = 0; currGroupIndex < BOARD_SIZE && group[currGroupIndex] < MAX_UINT8; currGroupIndex++) {\n', '\n', '                        board.positionToColor[group[currGroupIndex]] = 0;\n', '                    }\n', '\n', "                    // Shouldn't check suicide\n", '                    shouldCheckSuicide = false;\n', '                }\n', "            // There's an empty adjacent cell\n", '            } else if (currColor == 0) {\n', '\n', "                // Shouldn't check suicide\n", '                shouldCheckSuicide = false;\n', '            }\n', '        }\n', '\n', '        // Detect suicide if needed\n', '        if (shouldCheckSuicide) {\n', '\n', "            // Get the new stone's surrounding group\n", '            (group, isGroupCaptured) = getGroup(board, position, positionColor);\n', '\n', "            // If the group is captured, it's a suicide move, remove it\n", '            if (isGroupCaptured) {\n', '\n', '                // Clear added stone\n', '                board.positionToColor[position] = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Internally used to set a flag in a shrinked board array (used to save gas costs).\n', '    /// @param visited the array to update.\n', '    /// @param position the position on the board we want to flag.\n', '    /// @param flag the flag we want to set (either 1 or 2).\n', '    function setFlag(uint8[SHRINKED_BOARD_SIZE] visited, uint8 position, uint8 flag) private pure {\n', '        visited[position / 4] |= flag << ((position % 4) * 2);\n', '    }\n', '\n', '    /// @dev Internally used to check whether a flag in a shrinked board array is set.\n', '    /// @param visited the array to check.\n', '    /// @param position the position on the board we want to check.\n', '    /// @param flag the flag we want to check (either 1 or 2).\n', '    /// @return true if that flag is set, false otherwise.\n', '    function isFlagSet(uint8[SHRINKED_BOARD_SIZE] visited, uint8 position, uint8 flag) private pure returns (bool) {\n', '        return (visited[position / 4] & (flag << ((position % 4) * 2)) > 0);\n', '    }\n', '\n', '    // Get group visited flags\n', '    uint8 constant FLAG_POSITION_WAS_IN_STACK = 1;\n', '    uint8 constant FLAG_DID_VISIT_POSITION = 2;\n', '\n', '    /// @dev Gets a group starting from the position & color sent. In order for a stone to be part of the group,\n', "    ///  it must match the original stone's color, and be connected to it - either directly, or through adjacent cells.\n", "    ///  A group is captured if there aren't any empty cells around it.\n", "    ///  The function supports both returning colored groups - white/black, and empty groups (for that case, isGroupCaptured isn't relevant).\n", '    /// @param board the board to check and update\n', '    /// @param position the position of the starting stone\n', '    /// @param positionColor the color of the starting stone (this param is sent to spare another reading op)\n', '    /// @return an array that contains the positions of the group, \n', '    ///  a boolean that specifies whether the group is captured or not.\n', "    ///  In order to save gas, if a group isn't captured, the array might not contain the enitre group.\n", '    function getGroup(GoBoard storage board, uint8 position, uint8 positionColor) private view returns (uint8[BOARD_SIZE], bool isGroupCaptured) {\n', '\n', '        // The return array, and its size\n', '        uint8[BOARD_SIZE] memory groupPositions;\n', '        uint8 groupSize = 0;\n', '        \n', '        // Flagging visited locations\n', '        uint8[SHRINKED_BOARD_SIZE] memory visited;\n', '\n', '        // Stack of waiting positions, the first position to check is the sent position\n', '        uint8[BOARD_SIZE] memory stack;\n', '        stack[0] = position;\n', '        uint8 stackSize = 1;\n', '\n', '        // That position was added to the stack\n', '        setFlag(visited, position, FLAG_POSITION_WAS_IN_STACK);\n', '\n', '        // Run as long as there are positions in the stack\n', '        while (stackSize > 0) {\n', '\n', '            // Take the last position and clear it\n', '            position = stack[--stackSize];\n', '            stack[stackSize] = 0;\n', '\n', "            // Only if we didn't visit that stone before\n", '            if (!isFlagSet(visited, position, FLAG_DID_VISIT_POSITION)) {\n', '                \n', "                // Set the flag so we won't visit it again\n", '                setFlag(visited, position, FLAG_DID_VISIT_POSITION);\n', '\n', '                // Add that position to the return value\n', '                groupPositions[groupSize++] = position;\n', '\n', '                // Get that position adjacent cells\n', '                uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', '                // Run over the adjacent cells\n', '                for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '                    \n', '                    // Get the current adjacent cell color\n', '                    uint8 currColor = board.positionToColor[adjacentArray[currAdjacentIndex]];\n', '                    \n', "                    // If it's the same color as the original position color\n", '                    if (currColor == positionColor) {\n', '\n', '                        // Add that position to the stack\n', '                        if (!isFlagSet(visited, adjacentArray[currAdjacentIndex], FLAG_POSITION_WAS_IN_STACK)) {\n', '                            stack[stackSize++] = adjacentArray[currAdjacentIndex];\n', '                            setFlag(visited, adjacentArray[currAdjacentIndex], FLAG_POSITION_WAS_IN_STACK);\n', '                        }\n', "                    // If that position is empty, the group isn't captured, no need to continue running\n", '                    } else if (currColor == 0) {\n', '                        \n', '                        return (groupPositions, false);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Flag the end of the group array only if needed\n', '        if (groupSize < BOARD_SIZE) {\n', '            groupPositions[groupSize] = MAX_UINT8;\n', '        }\n', '        \n', '        // The group is captured, return it\n', '        return (groupPositions, true);\n', '    }\n', '    \n', '    /// The max number of adjacent cells is 4\n', '    uint8 constant MAX_ADJACENT_CELLS = 4;\n', '\n', '    /// @dev returns the adjacent positions for a given position.\n', '    /// @param position to get its adjacents.\n', "    /// @return the adjacent positions array, filled with MAX_INT8 in case there aren't 4 adjacent positions.\n", '    function getAdjacentCells(uint8 position) private pure returns (uint8[MAX_ADJACENT_CELLS]) {\n', '\n', '        // Init the return array and current index\n', '        uint8[MAX_ADJACENT_CELLS] memory returnCells = [MAX_UINT8, MAX_UINT8, MAX_UINT8, MAX_UINT8];\n', '        uint8 adjacentCellsIndex = 0;\n', '\n', '        // Set the up position, if relevant\n', '        if (position / BOARD_ROW_SIZE > 0) {\n', '            returnCells[adjacentCellsIndex++] = position - BOARD_ROW_SIZE;\n', '        }\n', '\n', '        // Set the down position, if relevant\n', '        if (position / BOARD_ROW_SIZE < BOARD_ROW_SIZE - 1) {\n', '            returnCells[adjacentCellsIndex++] = position + BOARD_ROW_SIZE;\n', '        }\n', '\n', '        // Set the left position, if relevant\n', '        if (position % BOARD_ROW_SIZE > 0) {\n', '            returnCells[adjacentCellsIndex++] = position - 1;\n', '        }\n', '\n', '        // Set the right position, if relevant\n', '        if (position % BOARD_ROW_SIZE < BOARD_ROW_SIZE - 1) {\n', '            returnCells[adjacentCellsIndex++] = position + 1;\n', '        }\n', '\n', '        return returnCells;\n', '    }\n', '\n', "    /// @notice Calculates the board's score, using area scoring.\n", '    /// @param boardId the board to calculate the score for.\n', "    /// @return blackScore & whiteScore, the players' scores.\n", '    function calculateBoardScore(uint boardId) public view returns (uint8 blackScore, uint8 whiteScore) {\n', '\n', '        GoBoard storage board = allBoards[boardId];\n', '        uint8[BOARD_SIZE] memory boardEmptyGroups;\n', '        uint8 maxEmptyGroupId;\n', '        (boardEmptyGroups, maxEmptyGroupId) = getBoardEmptyGroups(board);\n', '        uint8[BOARD_SIZE] memory groupsSize;\n', '        uint8[BOARD_SIZE] memory groupsState;\n', '        \n', '        blackScore = 0;\n', '        whiteScore = 0;\n', '\n', '        // Count stones and find empty territories\n', '        for (uint8 position = 0; position < BOARD_SIZE; position++) {\n', '\n', '            if (PlayerColor(board.positionToColor[position]) == PlayerColor.Black) {\n', '\n', '                blackScore++;\n', '            } else if (PlayerColor(board.positionToColor[position]) == PlayerColor.White) {\n', '\n', '                whiteScore++;\n', '            } else {\n', '\n', '                uint8 groupId = boardEmptyGroups[position];\n', '                groupsSize[groupId]++;\n', '\n', "                // Checking is needed only if we didn't find the group is adjacent to the two colors already\n", '                if ((groupsState[groupId] & uint8(PlayerColor.Black) == 0) || (groupsState[groupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                    uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);\n', '\n', "                    // Check adjacent cells to mark the group's bounderies\n", '                    for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {\n', '\n', '                        // Check if the group has a black boundry\n', '                        if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.Black) && \n', '                            (groupsState[groupId] & uint8(PlayerColor.Black) == 0)) {\n', '\n', '                            groupsState[groupId] |= uint8(PlayerColor.Black);\n', '\n', '                        // Check if the group has a white boundry\n', '                        } else if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.White) && \n', '                                   (groupsState[groupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                            groupsState[groupId] |= uint8(PlayerColor.White);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Add territories size to the relevant player\n', '        for (uint8 currGroupId = 1; currGroupId < maxEmptyGroupId; currGroupId++) {\n', '            \n', "            // Check if it's a black territory\n", '            if ((groupsState[currGroupId] & uint8(PlayerColor.Black) > 0) &&\n', '                (groupsState[currGroupId] & uint8(PlayerColor.White) == 0)) {\n', '\n', '                blackScore += groupsSize[currGroupId];\n', '\n', "            // Check if it's a white territory\n", '            } else if ((groupsState[currGroupId] & uint8(PlayerColor.White) > 0) &&\n', '                       (groupsState[currGroupId] & uint8(PlayerColor.Black) == 0)) {\n', '\n', '                whiteScore += groupsSize[currGroupId];\n', '            }\n', '        }\n', '\n', '        return (blackScore, whiteScore);\n', '    }\n', '\n', '    /// @dev IDs empty groups on the board.\n', '    /// @param board the board to map.\n', '    /// @return an array that contains the mapped empty group ids, and the max empty group id\n', '    function getBoardEmptyGroups(GoBoard storage board) private view returns (uint8[BOARD_SIZE], uint8) {\n', '\n', '        uint8[BOARD_SIZE] memory boardEmptyGroups;\n', '        uint8 nextGroupId = 1;\n', '\n', '        for (uint8 position = 0; position < BOARD_SIZE; position++) {\n', '\n', '            PlayerColor currPositionColor = PlayerColor(board.positionToColor[position]);\n', '\n', '            if ((currPositionColor == PlayerColor.None) && (boardEmptyGroups[position] == 0)) {\n', '\n', '                uint8[BOARD_SIZE] memory emptyGroup;\n', '                bool isGroupCaptured;\n', '                (emptyGroup, isGroupCaptured) = getGroup(board, position, 0);\n', '\n', '                for (uint8 currGroupIndex = 0; currGroupIndex < BOARD_SIZE && emptyGroup[currGroupIndex] < MAX_UINT8; currGroupIndex++) {\n', '\n', '                    boardEmptyGroups[emptyGroup[currGroupIndex]] = nextGroupId;\n', '                }\n', '\n', '                nextGroupId++;\n', '            }\n', '        }\n', '\n', '        return (boardEmptyGroups, nextGroupId);\n', '    }\n', '}']
