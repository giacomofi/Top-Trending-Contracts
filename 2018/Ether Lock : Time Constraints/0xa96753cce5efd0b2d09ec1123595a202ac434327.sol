['pragma solidity ^0.4.8;\n', '\n', '\n', 'library BobbySafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract BobbyERC20Base {\n', '\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    //是否暂停智能合约的运行\n', '    bool public paused = false;\n', '\n', '    constructor(address cfoAddr) public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = cfoAddr;\n', '    }\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier allButCFO() {\n', '        require(msg.sender != cfoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyCEO whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    //ERC20指定接口\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '    //extend event\n', '    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\n', '    event Unlock(address indexed user, uint wad);                       //解禁代币\n', '\n', '    function name() public view returns (string n);\n', '    function symbol() public view returns (string s);\n', '    function decimals() public view returns (uint8 d);\n', '    function totalSupply() public view returns (uint256 t);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '    using BobbySafeMath for uint256;\n', '\n', '    uint private _Thousand = 1000;\n', '    uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '    //代币基本信息\n', '    string private _name = "BOBBYTest";     //代币名称\n', '    string private _symbol = "BOBBYTest";   //代币标识\n', '    uint8 private _decimals = 9;        //小数点后位数\n', '    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '    //解封用户代币结构\n', '    struct UserToken {\n', '        uint index;              //放在数组中的下标\n', '        address addr;            //用户账号\n', '        uint256 tokens;          //通证数量\n', '\n', '        uint256 unlockUnit;     // 每次解锁数量\n', '        uint256 unlockPeriod;   // 解锁时间间隔\n', '        uint256 unlockLeft;     // 未解锁通证数量\n', '        uint256 unlockLastTime; // 上次解锁时间\n', '    }\n', '\n', '    mapping(address=>UserToken) private _balancesMap;           //用户可用代币映射\n', '    address[] private _balancesArray;                           //用户可用代币数组,from 1\n', '\n', '    uint32 private actionTransfer = 0;\n', '    uint32 private actionGrant = 1;\n', '    uint32 private actionUnlock = 2;\n', '\n', '    struct LogEntry {\n', '        uint256 time;\n', '        uint32  action;       // 0 转账 1 发放 2 解锁\n', '        address from;\n', '        address to;\n', '        uint256 v1;\n', '        uint256 v2;\n', '        uint256 v3;\n', '    }\n', '\n', '    LogEntry[] private _logs;\n', '\n', '    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\n', '\n', '        //placeholder\n', '        _balancesArray.push(address(0));\n', '\n', '        //此处需要注意，请使用CEO的地址,因为初始化后，将会使用这个地址作为CEO地址\n', '        //注意，一定要使用memory类型，否则，后面的赋值会影响其它成员变量\n', '        UserToken memory userCFO;\n', '        userCFO.index = _balancesArray.length;\n', '        userCFO.addr = cfoAddr;\n', '        userCFO.tokens = _totalSupply;\n', '        userCFO.unlockUnit = 0;\n', '        userCFO.unlockPeriod = 0;\n', '        userCFO.unlockLeft = 0;\n', '        userCFO.unlockLastTime = 0;\n', '        _balancesArray.push(cfoAddr);\n', '        _balancesMap[cfoAddr] = userCFO;\n', '    }\n', '\n', '    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '    function name() public view returns (string n){\n', '        n = _name;\n', '    }\n', '\n', '    //返回合约标识符\n', '    function symbol() public view returns (string s){\n', '        s = _symbol;\n', '    }\n', '\n', '    //返回合约小数位\n', '    function decimals() public view returns (uint8 d){\n', '        d = _decimals;\n', '    }\n', '\n', '    //返回合约总供给额\n', '    function totalSupply() public view returns (uint256 t){\n', '        t = _totalSupply;\n', '    }\n', '\n', '    //查询账户_owner的账户余额\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        UserToken storage user = _balancesMap[_owner];\n', '        balance = user.tokens.add(user.unlockLeft);\n', '    }\n', '\n', '    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        require(!paused);\n', '        require(msg.sender != cfoAddress);\n', '        require(msg.sender != _to);\n', '\n', '        //先判断是否有可以解禁\n', '        if(_balancesMap[msg.sender].unlockLeft > 0){\n', '            UserToken storage sender = _balancesMap[msg.sender];\n', '            uint256 diff = now.sub(sender.unlockLastTime);\n', '            uint256 round = diff.div(sender.unlockPeriod);\n', '            if(round > 0) {\n', '                uint256 unlocked = sender.unlockUnit.mul(round);\n', '                if (unlocked > sender.unlockLeft) {\n', '                    unlocked = sender.unlockLeft;\n', '                }\n', '\n', '                sender.unlockLeft = sender.unlockLeft.sub(unlocked);\n', '                sender.tokens = sender.tokens.add(unlocked);\n', '                sender.unlockLastTime = sender.unlockLastTime.add(sender.unlockPeriod.mul(round));\n', '\n', '                emit Unlock(msg.sender, unlocked);\n', '                log(actionUnlock, msg.sender, 0, unlocked, 0, 0);\n', '            }\n', '        }\n', '\n', '        require(_balancesMap[msg.sender].tokens >= _value);\n', '        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\n', '\n', '        uint index = _balancesMap[_to].index;\n', '        if(index == 0){\n', '            UserToken memory user;\n', '            user.index = _balancesArray.length;\n', '            user.addr = _to;\n', '            user.tokens = _value;\n', '            user.unlockUnit = 0;\n', '            user.unlockPeriod = 0;\n', '            user.unlockLeft = 0;\n', '            user.unlockLastTime = 0;\n', '            _balancesMap[_to] = user;\n', '            _balancesArray.push(_to);\n', '        }\n', '        else{\n', '            _balancesMap[_to].tokens = _balancesMap[_to].tokens.add(_value);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        log(actionTransfer, msg.sender, _to, _value, 0, 0);\n', '        success = true;\n', '    }\n', '\n', '    function transferFrom(address, address, uint256) public returns (bool success){\n', '        require(!paused);\n', '        success = true;\n', '    }\n', '\n', '    function approve(address, uint256) public returns (bool success){\n', '        require(!paused);\n', '        success = true;\n', '    }\n', '\n', '    function allowance(address, address) public view returns (uint256 remaining){\n', '        require(!paused);\n', '        remaining = 0;\n', '    }\n', '\n', '    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public returns (bool success){\n', '        require(msg.sender != _to);\n', '        require(_balancesMap[msg.sender].tokens >= _value);\n', '        require(_balancesMap[_to].unlockLastTime == 0);\n', '\n', '        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\n', '\n', '        if(_balancesMap[_to].index == 0){\n', '            UserToken memory user;\n', '            user.index = _balancesArray.length;\n', '            user.addr = _to;\n', '            user.tokens = 0;\n', '            user.unlockUnit = _value.div(_periods);\n', '            // user.unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\n', '            user.unlockPeriod = _duration.mul(1 days).div(_periods); //for test \n', '            user.unlockLeft = _value;\n', '            user.unlockLastTime = now;\n', '            _balancesMap[_to] = user;\n', '            _balancesArray.push(_to);\n', '        }\n', '        else{\n', '            _balancesMap[_to].unlockUnit = _value.div(_periods);\n', '            // _balancesMap[_to].unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\n', '            _balancesMap[_to].unlockPeriod = _duration.mul(1 days).div(_periods); //for test\n', '            _balancesMap[_to].unlockLeft = _value;\n', '            _balancesMap[_to].unlockLastTime = now;\n', '        }\n', '\n', '        emit Grant(msg.sender, _to, _value);\n', '        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\n', '        success = true;\n', '    }\n', '\n', '    function getBalanceAddr(uint256 _index) public view returns(address addr){\n', '        require(_index < _balancesArray.length);\n', '        require(_index >= 0);\n', '        addr = _balancesArray[_index];\n', '    }\n', '\n', '    function getBalanceSize() public view returns(uint256 size){\n', '        size = _balancesArray.length;\n', '    }\n', '\n', '    function getLockInfo(address addr) public view returns (uint256 unlocked, uint256 unit, uint256 period, uint256 last) {\n', '        UserToken storage user = _balancesMap[addr];\n', '        unlocked = user.unlockLeft;\n', '        unit = user.unlockUnit;\n', '        period = user.unlockPeriod;\n', '        last = user.unlockLastTime;\n', '    }\n', '\n', '    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\n', '        LogEntry memory entry;\n', '        entry.action = action;\n', '        entry.time = now;\n', '        entry.from = from;\n', '        entry.to = to;\n', '        entry.v1 = _v1;\n', '        entry.v2 = _v2;\n', '        entry.v3 = _v3;\n', '        _logs.push(entry);\n', '    }\n', '\n', '    function getLogSize() public view returns(uint256 size){\n', '        size = _logs.length;\n', '    }\n', '\n', '    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\n', '        require(_index < _logs.length);\n', '        require(_index >= 0);\n', '        LogEntry storage entry = _logs[_index];\n', '        action = entry.action;\n', '        time = entry.time;\n', '        from = entry.from;\n', '        to = entry.to;\n', '        _v1 = entry.v1;\n', '        _v2 = entry.v2;\n', '        _v3 = entry.v3;\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', 'library BobbySafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract BobbyERC20Base {\n', '\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    //是否暂停智能合约的运行\n', '    bool public paused = false;\n', '\n', '    constructor(address cfoAddr) public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = cfoAddr;\n', '    }\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier allButCFO() {\n', '        require(msg.sender != cfoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyCEO whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    //ERC20指定接口\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '    //extend event\n', '    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\n', '    event Unlock(address indexed user, uint wad);                       //解禁代币\n', '\n', '    function name() public view returns (string n);\n', '    function symbol() public view returns (string s);\n', '    function decimals() public view returns (uint8 d);\n', '    function totalSupply() public view returns (uint256 t);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '    using BobbySafeMath for uint256;\n', '\n', '    uint private _Thousand = 1000;\n', '    uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '    //代币基本信息\n', '    string private _name = "BOBBYTest";     //代币名称\n', '    string private _symbol = "BOBBYTest";   //代币标识\n', '    uint8 private _decimals = 9;        //小数点后位数\n', '    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '    //解封用户代币结构\n', '    struct UserToken {\n', '        uint index;              //放在数组中的下标\n', '        address addr;            //用户账号\n', '        uint256 tokens;          //通证数量\n', '\n', '        uint256 unlockUnit;     // 每次解锁数量\n', '        uint256 unlockPeriod;   // 解锁时间间隔\n', '        uint256 unlockLeft;     // 未解锁通证数量\n', '        uint256 unlockLastTime; // 上次解锁时间\n', '    }\n', '\n', '    mapping(address=>UserToken) private _balancesMap;           //用户可用代币映射\n', '    address[] private _balancesArray;                           //用户可用代币数组,from 1\n', '\n', '    uint32 private actionTransfer = 0;\n', '    uint32 private actionGrant = 1;\n', '    uint32 private actionUnlock = 2;\n', '\n', '    struct LogEntry {\n', '        uint256 time;\n', '        uint32  action;       // 0 转账 1 发放 2 解锁\n', '        address from;\n', '        address to;\n', '        uint256 v1;\n', '        uint256 v2;\n', '        uint256 v3;\n', '    }\n', '\n', '    LogEntry[] private _logs;\n', '\n', '    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\n', '\n', '        //placeholder\n', '        _balancesArray.push(address(0));\n', '\n', '        //此处需要注意，请使用CEO的地址,因为初始化后，将会使用这个地址作为CEO地址\n', '        //注意，一定要使用memory类型，否则，后面的赋值会影响其它成员变量\n', '        UserToken memory userCFO;\n', '        userCFO.index = _balancesArray.length;\n', '        userCFO.addr = cfoAddr;\n', '        userCFO.tokens = _totalSupply;\n', '        userCFO.unlockUnit = 0;\n', '        userCFO.unlockPeriod = 0;\n', '        userCFO.unlockLeft = 0;\n', '        userCFO.unlockLastTime = 0;\n', '        _balancesArray.push(cfoAddr);\n', '        _balancesMap[cfoAddr] = userCFO;\n', '    }\n', '\n', '    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '    function name() public view returns (string n){\n', '        n = _name;\n', '    }\n', '\n', '    //返回合约标识符\n', '    function symbol() public view returns (string s){\n', '        s = _symbol;\n', '    }\n', '\n', '    //返回合约小数位\n', '    function decimals() public view returns (uint8 d){\n', '        d = _decimals;\n', '    }\n', '\n', '    //返回合约总供给额\n', '    function totalSupply() public view returns (uint256 t){\n', '        t = _totalSupply;\n', '    }\n', '\n', '    //查询账户_owner的账户余额\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        UserToken storage user = _balancesMap[_owner];\n', '        balance = user.tokens.add(user.unlockLeft);\n', '    }\n', '\n', '    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        require(!paused);\n', '        require(msg.sender != cfoAddress);\n', '        require(msg.sender != _to);\n', '\n', '        //先判断是否有可以解禁\n', '        if(_balancesMap[msg.sender].unlockLeft > 0){\n', '            UserToken storage sender = _balancesMap[msg.sender];\n', '            uint256 diff = now.sub(sender.unlockLastTime);\n', '            uint256 round = diff.div(sender.unlockPeriod);\n', '            if(round > 0) {\n', '                uint256 unlocked = sender.unlockUnit.mul(round);\n', '                if (unlocked > sender.unlockLeft) {\n', '                    unlocked = sender.unlockLeft;\n', '                }\n', '\n', '                sender.unlockLeft = sender.unlockLeft.sub(unlocked);\n', '                sender.tokens = sender.tokens.add(unlocked);\n', '                sender.unlockLastTime = sender.unlockLastTime.add(sender.unlockPeriod.mul(round));\n', '\n', '                emit Unlock(msg.sender, unlocked);\n', '                log(actionUnlock, msg.sender, 0, unlocked, 0, 0);\n', '            }\n', '        }\n', '\n', '        require(_balancesMap[msg.sender].tokens >= _value);\n', '        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\n', '\n', '        uint index = _balancesMap[_to].index;\n', '        if(index == 0){\n', '            UserToken memory user;\n', '            user.index = _balancesArray.length;\n', '            user.addr = _to;\n', '            user.tokens = _value;\n', '            user.unlockUnit = 0;\n', '            user.unlockPeriod = 0;\n', '            user.unlockLeft = 0;\n', '            user.unlockLastTime = 0;\n', '            _balancesMap[_to] = user;\n', '            _balancesArray.push(_to);\n', '        }\n', '        else{\n', '            _balancesMap[_to].tokens = _balancesMap[_to].tokens.add(_value);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        log(actionTransfer, msg.sender, _to, _value, 0, 0);\n', '        success = true;\n', '    }\n', '\n', '    function transferFrom(address, address, uint256) public returns (bool success){\n', '        require(!paused);\n', '        success = true;\n', '    }\n', '\n', '    function approve(address, uint256) public returns (bool success){\n', '        require(!paused);\n', '        success = true;\n', '    }\n', '\n', '    function allowance(address, address) public view returns (uint256 remaining){\n', '        require(!paused);\n', '        remaining = 0;\n', '    }\n', '\n', '    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public returns (bool success){\n', '        require(msg.sender != _to);\n', '        require(_balancesMap[msg.sender].tokens >= _value);\n', '        require(_balancesMap[_to].unlockLastTime == 0);\n', '\n', '        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\n', '\n', '        if(_balancesMap[_to].index == 0){\n', '            UserToken memory user;\n', '            user.index = _balancesArray.length;\n', '            user.addr = _to;\n', '            user.tokens = 0;\n', '            user.unlockUnit = _value.div(_periods);\n', '            // user.unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\n', '            user.unlockPeriod = _duration.mul(1 days).div(_periods); //for test \n', '            user.unlockLeft = _value;\n', '            user.unlockLastTime = now;\n', '            _balancesMap[_to] = user;\n', '            _balancesArray.push(_to);\n', '        }\n', '        else{\n', '            _balancesMap[_to].unlockUnit = _value.div(_periods);\n', '            // _balancesMap[_to].unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\n', '            _balancesMap[_to].unlockPeriod = _duration.mul(1 days).div(_periods); //for test\n', '            _balancesMap[_to].unlockLeft = _value;\n', '            _balancesMap[_to].unlockLastTime = now;\n', '        }\n', '\n', '        emit Grant(msg.sender, _to, _value);\n', '        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\n', '        success = true;\n', '    }\n', '\n', '    function getBalanceAddr(uint256 _index) public view returns(address addr){\n', '        require(_index < _balancesArray.length);\n', '        require(_index >= 0);\n', '        addr = _balancesArray[_index];\n', '    }\n', '\n', '    function getBalanceSize() public view returns(uint256 size){\n', '        size = _balancesArray.length;\n', '    }\n', '\n', '    function getLockInfo(address addr) public view returns (uint256 unlocked, uint256 unit, uint256 period, uint256 last) {\n', '        UserToken storage user = _balancesMap[addr];\n', '        unlocked = user.unlockLeft;\n', '        unit = user.unlockUnit;\n', '        period = user.unlockPeriod;\n', '        last = user.unlockLastTime;\n', '    }\n', '\n', '    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\n', '        LogEntry memory entry;\n', '        entry.action = action;\n', '        entry.time = now;\n', '        entry.from = from;\n', '        entry.to = to;\n', '        entry.v1 = _v1;\n', '        entry.v2 = _v2;\n', '        entry.v3 = _v3;\n', '        _logs.push(entry);\n', '    }\n', '\n', '    function getLogSize() public view returns(uint256 size){\n', '        size = _logs.length;\n', '    }\n', '\n', '    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\n', '        require(_index < _logs.length);\n', '        require(_index >= 0);\n', '        LogEntry storage entry = _logs[_index];\n', '        action = entry.action;\n', '        time = entry.time;\n', '        from = entry.from;\n', '        to = entry.to;\n', '        _v1 = entry.v1;\n', '        _v2 = entry.v2;\n', '        _v3 = entry.v3;\n', '    }\n', '}']
