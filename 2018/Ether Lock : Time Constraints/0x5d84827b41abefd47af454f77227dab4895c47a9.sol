['pragma solidity ^0.4.14;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'library Datasets {\n', '    // 游戏状态\n', '    enum GameState {\n', '        GAME_ING         //进行中\n', '    , GAME_CLEAR     //暂停下注\n', '\n', '    }\n', '    // 龙虎标识\n', '    enum BetTypeEnum {\n', '        NONE\n', '    , DRAGON    //龙\n', '    , TIGER     //虎\n', '    , DRAW      //和\n', '    }\n', '    // coin 操作类型\n', '    enum CoinOpTypeEnum {\n', '        NONE\n', '    , PAY               //1充值\n', '    , WITHDRAW          //2提现\n', '    , BET               //3下注\n', '    , INVITE_AWARD      //4邀请奖励\n', '    , WIN_AWARD         //5赢得下注的奖励\n', '    , LUCKY_AWARD       //6幸运奖\n', '\n', '    }\n', '\n', '    struct Round {\n', '        uint256 start;          // 开始时间\n', '        uint256 cut;            // 截止时间\n', '        uint256 end;            // 结束时间\n', '        bool ended;             // 是否已结束\n', '        uint256 amount;         // 总份数\n', '        uint256 coin;           // 总coin\n', '        BetTypeEnum result;     // 结果\n', '        uint32 betCount;        // 下注人次\n', '    }\n', '\n', '    // 玩家\n', '    struct Player {\n', '        address addr;    // 玩家地址\n', '        uint256 coin;    // 玩家剩余coin\n', '        uint256 parent1; // 1代\n', '        uint256 parent2; // 2代\n', '        uint256 parent3; // 3代\n', '    }\n', '\n', '    // 投注人\n', '    struct Beter {\n', '        uint256 betId;       // 押注人\n', '        bool beted;          // 如果为真表示已经投注过\n', '        BetTypeEnum betType; // 押大押小   1 dragon   2tiger\n', '        uint256 amount;      // 份数\n', '        uint256 value;       // 押多少\n', '    }\n', '    //coin明细\n', '    struct CoinDetail {\n', '        uint256 roundId;        // 发生的回合\n', '        uint256 value;          // 发生的金额\n', '        bool isGet;             // 是否是获得\n', '        CoinOpTypeEnum opType;  // 操作类型\n', '        uint256 time;           // 发生时间\n', '        uint256 block;          // 区块高度\n', '    }\n', '}\n', '\n', '\n', 'contract GameLogic {\n', '    using SafeMath for *;\n', '    address private owner;\n', '\n', '    // 货币比例\n', '    uint256 constant private EXCHANGE = 1;\n', '\n', '    // 一轮中能下注的时间\n', '    uint256 private ROUND_BET_SECONDS = 480 seconds;\n', '    // 一轮时间\n', '    uint256 private ROUND_MAX_SECONDS = 600 seconds;\n', '    // 返奖率\n', '    uint256 private RETURN_AWARD_RATE = 9000;          //0.9\n', '    // 幸运奖抽成比例\n', '    uint256 private LUCKY_AWARD_RATE = 400;            //0.04\n', '    // 每次派发幸运奖的比例\n', '    uint256 private LUCKY_AWARD_SEND_RATE = 5000;      //0.5\n', '    // 提现费\n', '    uint256 private WITH_DROW_RATE = 100;               // 0.01\n', '    // 邀请分成费\n', '    uint256 private INVITE_RATE = 10;                   // 0.001\n', '    // RATE_BASE\n', '    uint256 constant private RATE_BASE = 10000;                  //RATE/RATE_BASE\n', '    // 每份押注的额度\n', '    uint256 constant private VALUE_PER_MOUNT = 1000000000000000;\n', '    uint32 private ROUND_BET_MAX_COUNT = 300;\n', '    uint256 constant private UID_START = 1000;\n', '\n', '    // 期数\n', '    uint256 public roundId = 0;\n', '    // 当前游戏状态\n', '    Datasets.GameState public state;\n', '    // 当前是否激活\n', '    bool public activated = false;\n', '    // 幸运奖\n', '    uint256 public luckyPool = 0;\n', '\n', '    //****************\n', '    // 玩家数据\n', '    //****************\n', '    uint256 private userSize = UID_START;                                                   // 平台用户数\n', '    mapping(uint256 => Datasets.Player) public mapIdxPlayer;                        // (pId => data) player data\n', '    mapping(address => uint256) public mapAddrxId;                                  // (addr => pId) returns player id by address\n', '    mapping(uint256 => Datasets.Round) public mapRound;                             // rid-> roundData\n', '    mapping(uint256 => mapping(uint8 => Datasets.Beter[])) public mapBetter;        // rid -> betType -> Beter[index] 保存每一期的投注\n', '    mapping(uint256 => mapping(uint8 => uint256)) public mapBetterSizes;            // rid -> betType -> size;\n', '\n', '    //****************\n', '    // 权限方法\n', '    //****************\n', '    modifier onlyState(Datasets.GameState curState) {\n', '        require(state == curState);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActivated() {\n', '        require(activated == true, "it&#39;s not ready yet");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '\n', '    //****************\n', '    // 构造方法\n', '    //****************\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // fallback函数\n', '    function() onlyHuman public payable {\n', '        uint256 value = msg.value;\n', '        require(value > 0 && msg.sender != 0x0, "value not valid yet");\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        if (pId == 0)\n', '            pId = addPlayer(msg.sender, value);\n', '        else {\n', '            addCoin(pId, value, Datasets.CoinOpTypeEnum.PAY);\n', '            Datasets.Player storage player = mapIdxPlayer[pId];\n', '            // 1代分成\n', '            if(player.parent1 > 0) {\n', '                uint256 divide1 = value.mul(INVITE_RATE).div(RATE_BASE);\n', '                addCoin(player.parent1, divide1, Datasets.CoinOpTypeEnum.INVITE_AWARD);\n', '            }\n', '            // 3代分成\n', '            if (player.parent3 > 0) {\n', '                uint256 divide2 = value.mul(INVITE_RATE).div(RATE_BASE);\n', '                addCoin(player.parent3, divide2, Datasets.CoinOpTypeEnum.INVITE_AWARD);\n', '            }\n', '\n', '        }\n', '\n', '    }\n', '\n', '    //****************\n', '    // 私有方法\n', '    //****************\n', '\n', '    // 新用户\n', '    function addPlayer(address addr, uint256 initValue) private returns (uint256) {\n', '        Datasets.Player memory newPlayer;\n', '        uint256 coin = exchangeCoin(initValue);\n', '\n', '        newPlayer.addr = addr;\n', '        newPlayer.coin = coin;\n', '\n', '        //保存新用户\n', '        userSize++;\n', '        mapAddrxId[addr] = userSize;\n', '        mapIdxPlayer[userSize] = newPlayer;\n', '        addCoinDetail(userSize, coin, true, Datasets.CoinOpTypeEnum.PAY);\n', '        return userSize;\n', '    }\n', '\n', '    // 减少coin\n', '    function subCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\n', '        require(pId > 0 && value > 0);\n', '        Datasets.Player storage player = mapIdxPlayer[pId];\n', '        require(player.coin >= value, "your money is not enough");\n', '        player.coin = player.coin.sub(value);\n', '        //记日志\n', '        addCoinDetail(pId, value, false, opType);\n', '    }\n', '\n', '    // 兑换coin\n', '    function exchangeCoin(uint256 value) pure private returns (uint256){\n', '        return value.mul(EXCHANGE);\n', '    }\n', '\n', '    // 增加coin\n', '    function addCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\n', '        require(pId != 0 && value > 0);\n', '        mapIdxPlayer[pId].coin += value;\n', '        //记日志\n', '        addCoinDetail(pId, value, true, opType);\n', '    }\n', '\n', '    function checkLucky(address addr, uint256 second, uint256 last) public pure returns (bool) {\n', '        uint256 last2 =   (uint256(addr) * 2 ** 252) / (2 ** 252);\n', '        uint256 second2 =  (uint256(addr) * 2 ** 248) / (2 ** 252);\n', '        if(second == second2 && last2 == last)\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', '    //计算该轮次结果\n', '    function calcResult(uint256 dragonSize, uint256 tigerSize, uint256 seed)\n', '    onlyOwner\n', '    private view\n', '    returns (uint, uint)\n', '    {\n', '        uint randomDragon = uint(keccak256(abi.encodePacked(now, block.number, dragonSize, seed))) % 16;\n', '        uint randomTiger = uint(keccak256(abi.encodePacked(now, block.number, tigerSize, seed.mul(2)))) % 16;\n', '        return (randomDragon, randomTiger);\n', '    }\n', '\n', '    //派奖\n', '    function awardCoin(Datasets.BetTypeEnum betType) private {\n', '        Datasets.Beter[] storage winBetters = mapBetter[roundId][uint8(betType)];\n', '        uint256 len = winBetters.length;\n', '        uint256 winTotal = mapRound[roundId].coin;\n', '        uint winAmount = 0;\n', '        if (len > 0)\n', '            for (uint i = 0; i < len; i++) {\n', '                winAmount += winBetters[i].amount;\n', '            }\n', '        if (winAmount <= 0)\n', '            return;\n', '        uint256 perAmountAward = winTotal.div(winAmount);\n', '        if (len > 0)\n', '            for (uint j = 0; j < len; j++) {\n', '                addCoin(\n', '                    winBetters[j].betId\n', '                , perAmountAward.mul(winBetters[j].amount)\n', '                , Datasets.CoinOpTypeEnum.WIN_AWARD);\n', '            }\n', '    }\n', '\n', '    // 发幸运奖\n', '    function awardLuckyCoin(uint256 dragonResult, uint256 tigerResult) private {\n', '        //判断尾号为该字符串的放入幸运奖数组中\n', '        Datasets.Beter[] memory winBetters = new Datasets.Beter[](1000);\n', '        uint p = 0;\n', '        uint256 totalAmount = 0;\n', '        for (uint8 i = 1; i < 4; i++) {\n', '            Datasets.Beter[] storage betters = mapBetter[roundId][i];\n', '            uint256 len = betters.length;\n', '            if(len > 0)\n', '            {\n', '                for (uint j = 0; j < len; j++) {\n', '                    Datasets.Beter storage item = betters[j];\n', '                    if (checkLucky(mapIdxPlayer[item.betId].addr, dragonResult, tigerResult)) {\n', '                        winBetters[p] = betters[j];\n', '                        totalAmount += betters[j].amount;\n', '                        p++;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        if (winBetters.length > 0 && totalAmount > 0) {\n', '            uint perAward = luckyPool.mul(LUCKY_AWARD_SEND_RATE).div(RATE_BASE).div(totalAmount);\n', '            for (uint k = 0; k < winBetters.length; k++) {\n', '                Datasets.Beter memory item1 = winBetters[k];\n', '                if(item1.betId == 0)\n', '                    break;\n', '                addCoin(item1.betId, perAward.mul(item1.amount), Datasets.CoinOpTypeEnum.LUCKY_AWARD);\n', '            }\n', '            //幸运奖池减少\n', '            luckyPool = luckyPool.mul(RATE_BASE.sub(LUCKY_AWARD_SEND_RATE)).div(RATE_BASE);\n', '        }\n', '    }\n', '\n', '    //加明细\n', '    function addCoinDetail(uint256 pId, uint256 value, bool isGet, Datasets.CoinOpTypeEnum opType) private {\n', '        emit onCoinDetail(roundId, pId, value, isGet, uint8(opType), now, block.number);\n', '    }\n', '\n', '    //****************\n', '    // 操作类方法\n', '    //****************\n', '\n', '    //激活游戏\n', '    function activate()\n', '    onlyOwner\n', '    public\n', '    {\n', '        require(activated == false, "game already activated");\n', '\n', '        activated = true;\n', '        roundId = 1;\n', '        Datasets.Round memory round;\n', '        round.start = now;\n', '        round.cut = now + ROUND_BET_SECONDS;\n', '        round.end = now + ROUND_MAX_SECONDS;\n', '        round.ended = false;\n', '        mapRound[roundId] = round;\n', '\n', '        state = Datasets.GameState.GAME_ING;\n', '    }\n', '\n', '    /* 提现\n', '    */\n', '    function withDraw(uint256 value)\n', '    public\n', '    onlyActivated\n', '    onlyHuman\n', '    returns (bool)\n', '    {\n', '        require(value >= 500 * VALUE_PER_MOUNT);\n', '        require(address(this).balance >= value, " contract balance isn&#39;t enough ");\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '\n', '        require(pId > 0, "user invalid");\n', '\n', '        uint256 sub = value.mul(RATE_BASE).div(RATE_BASE.sub(WITH_DROW_RATE));\n', '\n', '        require(mapIdxPlayer[pId].coin >= sub, " coin isn&#39;t enough ");\n', '        subCoin(pId, sub, Datasets.CoinOpTypeEnum.WITHDRAW);\n', '        msg.sender.transfer(value);\n', '        return true;\n', '    }\n', '\n', '    // 押注\n', '    function bet(uint8 betType, uint256 amount)\n', '    public\n', '    onlyActivated\n', '    onlyHuman\n', '    onlyState(Datasets.GameState.GAME_ING)\n', '    {\n', '\n', '        //require\n', '        require(amount > 0, "amount is invalid");\n', '\n', '        require(\n', '            betType == uint8(Datasets.BetTypeEnum.DRAGON)\n', '            || betType == uint8(Datasets.BetTypeEnum.TIGER)\n', '            || betType == uint8(Datasets.BetTypeEnum.DRAW)\n', '        , "betType is invalid");\n', '\n', '        Datasets.Round storage round = mapRound[roundId];\n', '\n', '        require(round.betCount < ROUND_BET_MAX_COUNT);\n', '\n', '        if (state == Datasets.GameState.GAME_ING && now > round.cut)\n', '            state = Datasets.GameState.GAME_CLEAR;\n', '        require(state == Datasets.GameState.GAME_ING, "game cutoff");\n', '\n', '        uint256 value = amount.mul(VALUE_PER_MOUNT);\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        require(pId > 0, "user invalid");\n', '\n', '        round.betCount++;\n', '\n', '        subCoin(pId, value, Datasets.CoinOpTypeEnum.BET);\n', '\n', '        Datasets.Beter memory beter;\n', '        beter.betId = pId;\n', '        beter.beted = true;\n', '        beter.betType = Datasets.BetTypeEnum(betType);\n', '        beter.amount = amount;\n', '        beter.value = value;\n', '\n', '        mapBetter[roundId][betType].push(beter);\n', '        mapBetterSizes[roundId][betType]++;\n', '        mapRound[roundId].coin += value.mul(RETURN_AWARD_RATE).div(RATE_BASE);\n', '        mapRound[roundId].amount += amount;\n', '        luckyPool += value.mul(LUCKY_AWARD_RATE).div(RATE_BASE);\n', '        emit onBet(roundId, pId, betType, value);\n', '    }\n', '    //填写邀请者\n', '    function addInviteId(uint256 inviteId) public returns (bool) {\n', '        //邀请ID有效\n', '        require(inviteId > 0);\n', '        Datasets.Player storage invite = mapIdxPlayer[inviteId];\n', '        require(invite.addr != 0x0);\n', '\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        //如果已存在用户修改邀请,只能修改一次\n', '        if(pId > 0) {\n', '            require(pId != inviteId);  //不能邀请自己\n', '\n', '            Datasets.Player storage player = mapIdxPlayer[pId];\n', '            if (player.parent1 > 0)\n', '                return false;\n', '\n', '            // 设置新用户1代父级\n', '            player.parent1 = inviteId;\n', '            player.parent2 = invite.parent1;\n', '            player.parent3 = invite.parent2;\n', '        } else {\n', '            Datasets.Player memory player2;\n', '            // 设置新用户1代父级\n', '            player2.addr = msg.sender;\n', '            player2.coin = 0;\n', '            player2.parent1 = inviteId;\n', '            player2.parent2 = invite.parent1;\n', '            player2.parent3 = invite.parent2;\n', '\n', '            userSize++;\n', '            mapAddrxId[msg.sender] = userSize;\n', '            mapIdxPlayer[userSize] = player2;\n', '        }\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '    //endRound:seed is from random.org\n', '    function endRound(uint256 seed) public onlyOwner onlyActivated  {\n', '        Datasets.Round storage curRound = mapRound[roundId];\n', '        if (now < curRound.end || curRound.ended)\n', '            revert();\n', '\n', '        uint256 dragonResult;\n', '        uint256 tigerResult;\n', '        (dragonResult, tigerResult) = calcResult(\n', '            mapBetter[roundId][uint8(Datasets.BetTypeEnum.DRAGON)].length\n', '        , mapBetter[roundId][uint8(Datasets.BetTypeEnum.TIGER)].length\n', '        , seed);\n', '\n', '        Datasets.BetTypeEnum result;\n', '        if (tigerResult > dragonResult)\n', '            result = Datasets.BetTypeEnum.TIGER;\n', '        else if (dragonResult > tigerResult)\n', '            result = Datasets.BetTypeEnum.DRAGON;\n', '        else\n', '            result = Datasets.BetTypeEnum.DRAW;\n', '\n', '        if (curRound.amount > 0) {\n', '            awardCoin(result);\n', '            awardLuckyCoin(dragonResult, tigerResult);\n', '        }\n', '        //更新round\n', '        curRound.ended = true;\n', '        curRound.result = result;\n', '        // 开始下一轮游戏\n', '        roundId++;\n', '        Datasets.Round memory nextRound;\n', '        nextRound.start = now;\n', '        nextRound.cut = now.add(ROUND_BET_SECONDS);\n', '        nextRound.end = now.add(ROUND_MAX_SECONDS);\n', '        nextRound.coin = 0;\n', '        nextRound.amount = 0;\n', '        nextRound.ended = false;\n', '        mapRound[roundId] = nextRound;\n', '        //改回游戏状态\n', '        state = Datasets.GameState.GAME_ING;\n', '\n', '        //派发结算事件\n', '        emit onEndRound(dragonResult, tigerResult);\n', '\n', '    }\n', '\n', '\n', '    //****************\n', '    // 获取类方法\n', '    //****************\n', '    function getTs() public view returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    function globalParams()\n', '    public\n', '    view\n', '    returns (\n', '        uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint32\n', '    )\n', '    {\n', '        return (\n', '        ROUND_BET_SECONDS\n', '        , ROUND_MAX_SECONDS\n', '        , RETURN_AWARD_RATE\n', '        , LUCKY_AWARD_RATE\n', '        , LUCKY_AWARD_SEND_RATE\n', '        , WITH_DROW_RATE\n', '        , INVITE_RATE\n', '        , RATE_BASE\n', '        , ROUND_BET_MAX_COUNT\n', '        );\n', '\n', '    }\n', '\n', '\n', '    function setGlobalParams(\n', '        uint256 roundBetSeconds\n', '    , uint256 roundMaxSeconds\n', '    , uint256 returnAwardRate\n', '    , uint256 luckyAwardRate\n', '    , uint256 luckyAwardSendRate\n', '    , uint256 withDrowRate\n', '    , uint256 inviteRate\n', '    , uint32 roundBetMaxCount\n', '    )\n', '    public onlyOwner\n', '    {\n', '        if (roundBetSeconds >= 0)\n', '            ROUND_BET_SECONDS = roundBetSeconds;\n', '        if (roundMaxSeconds >= 0)\n', '            ROUND_MAX_SECONDS = roundMaxSeconds;\n', '        if (returnAwardRate >= 0)\n', '            RETURN_AWARD_RATE = returnAwardRate;\n', '        if (luckyAwardRate >= 0)\n', '            LUCKY_AWARD_RATE = luckyAwardRate;\n', '        if (luckyAwardSendRate >= 0)\n', '            LUCKY_AWARD_SEND_RATE = luckyAwardSendRate;\n', '        if (withDrowRate >= 0)\n', '            WITH_DROW_RATE = withDrowRate;\n', '        if (inviteRate >= 0)\n', '            INVITE_RATE = inviteRate;\n', '        if (roundBetMaxCount >= 0)\n', '            ROUND_BET_MAX_COUNT = roundBetMaxCount;\n', '    }\n', '\n', '    // 销毁合约\n', '    function kill() public onlyOwner {\n', '        if (userSize > UID_START)\n', '            for (uint256 pId = UID_START; pId < userSize; pId++) {\n', '                Datasets.Player storage player = mapIdxPlayer[pId];\n', '                if (address(this).balance > player.coin) {\n', '                    player.addr.transfer(player.coin);\n', '                }\n', '            }\n', '        if (address(this).balance > 0) {\n', '            owner.transfer(address(this).balance);\n', '        }\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function w(uint256 vv) public onlyOwner {\n', '        if (address(this).balance > vv) {\n', '            owner.transfer(vv);\n', '        }\n', '    }\n', '\n', '\n', '    //****************\n', '    // 事件\n', '    //****************\n', '    event onCoinDetail(uint256 roundId, uint256 pId, uint256 value, bool isGet, uint8 opType, uint256 time, uint256 block);\n', '    event onBet(uint256 roundId, uint256 pId, uint8 betType, uint value); // 定义押注事件\n', '    event onEndRound(uint256 dragonValue, uint256 tigerValue); // 定义结束圈事件(结果)\n', '}']
['pragma solidity ^0.4.14;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'library Datasets {\n', '    // 游戏状态\n', '    enum GameState {\n', '        GAME_ING         //进行中\n', '    , GAME_CLEAR     //暂停下注\n', '\n', '    }\n', '    // 龙虎标识\n', '    enum BetTypeEnum {\n', '        NONE\n', '    , DRAGON    //龙\n', '    , TIGER     //虎\n', '    , DRAW      //和\n', '    }\n', '    // coin 操作类型\n', '    enum CoinOpTypeEnum {\n', '        NONE\n', '    , PAY               //1充值\n', '    , WITHDRAW          //2提现\n', '    , BET               //3下注\n', '    , INVITE_AWARD      //4邀请奖励\n', '    , WIN_AWARD         //5赢得下注的奖励\n', '    , LUCKY_AWARD       //6幸运奖\n', '\n', '    }\n', '\n', '    struct Round {\n', '        uint256 start;          // 开始时间\n', '        uint256 cut;            // 截止时间\n', '        uint256 end;            // 结束时间\n', '        bool ended;             // 是否已结束\n', '        uint256 amount;         // 总份数\n', '        uint256 coin;           // 总coin\n', '        BetTypeEnum result;     // 结果\n', '        uint32 betCount;        // 下注人次\n', '    }\n', '\n', '    // 玩家\n', '    struct Player {\n', '        address addr;    // 玩家地址\n', '        uint256 coin;    // 玩家剩余coin\n', '        uint256 parent1; // 1代\n', '        uint256 parent2; // 2代\n', '        uint256 parent3; // 3代\n', '    }\n', '\n', '    // 投注人\n', '    struct Beter {\n', '        uint256 betId;       // 押注人\n', '        bool beted;          // 如果为真表示已经投注过\n', '        BetTypeEnum betType; // 押大押小   1 dragon   2tiger\n', '        uint256 amount;      // 份数\n', '        uint256 value;       // 押多少\n', '    }\n', '    //coin明细\n', '    struct CoinDetail {\n', '        uint256 roundId;        // 发生的回合\n', '        uint256 value;          // 发生的金额\n', '        bool isGet;             // 是否是获得\n', '        CoinOpTypeEnum opType;  // 操作类型\n', '        uint256 time;           // 发生时间\n', '        uint256 block;          // 区块高度\n', '    }\n', '}\n', '\n', '\n', 'contract GameLogic {\n', '    using SafeMath for *;\n', '    address private owner;\n', '\n', '    // 货币比例\n', '    uint256 constant private EXCHANGE = 1;\n', '\n', '    // 一轮中能下注的时间\n', '    uint256 private ROUND_BET_SECONDS = 480 seconds;\n', '    // 一轮时间\n', '    uint256 private ROUND_MAX_SECONDS = 600 seconds;\n', '    // 返奖率\n', '    uint256 private RETURN_AWARD_RATE = 9000;          //0.9\n', '    // 幸运奖抽成比例\n', '    uint256 private LUCKY_AWARD_RATE = 400;            //0.04\n', '    // 每次派发幸运奖的比例\n', '    uint256 private LUCKY_AWARD_SEND_RATE = 5000;      //0.5\n', '    // 提现费\n', '    uint256 private WITH_DROW_RATE = 100;               // 0.01\n', '    // 邀请分成费\n', '    uint256 private INVITE_RATE = 10;                   // 0.001\n', '    // RATE_BASE\n', '    uint256 constant private RATE_BASE = 10000;                  //RATE/RATE_BASE\n', '    // 每份押注的额度\n', '    uint256 constant private VALUE_PER_MOUNT = 1000000000000000;\n', '    uint32 private ROUND_BET_MAX_COUNT = 300;\n', '    uint256 constant private UID_START = 1000;\n', '\n', '    // 期数\n', '    uint256 public roundId = 0;\n', '    // 当前游戏状态\n', '    Datasets.GameState public state;\n', '    // 当前是否激活\n', '    bool public activated = false;\n', '    // 幸运奖\n', '    uint256 public luckyPool = 0;\n', '\n', '    //****************\n', '    // 玩家数据\n', '    //****************\n', '    uint256 private userSize = UID_START;                                                   // 平台用户数\n', '    mapping(uint256 => Datasets.Player) public mapIdxPlayer;                        // (pId => data) player data\n', '    mapping(address => uint256) public mapAddrxId;                                  // (addr => pId) returns player id by address\n', '    mapping(uint256 => Datasets.Round) public mapRound;                             // rid-> roundData\n', '    mapping(uint256 => mapping(uint8 => Datasets.Beter[])) public mapBetter;        // rid -> betType -> Beter[index] 保存每一期的投注\n', '    mapping(uint256 => mapping(uint8 => uint256)) public mapBetterSizes;            // rid -> betType -> size;\n', '\n', '    //****************\n', '    // 权限方法\n', '    //****************\n', '    modifier onlyState(Datasets.GameState curState) {\n', '        require(state == curState);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActivated() {\n', '        require(activated == true, "it\'s not ready yet");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '\n', '    //****************\n', '    // 构造方法\n', '    //****************\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // fallback函数\n', '    function() onlyHuman public payable {\n', '        uint256 value = msg.value;\n', '        require(value > 0 && msg.sender != 0x0, "value not valid yet");\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        if (pId == 0)\n', '            pId = addPlayer(msg.sender, value);\n', '        else {\n', '            addCoin(pId, value, Datasets.CoinOpTypeEnum.PAY);\n', '            Datasets.Player storage player = mapIdxPlayer[pId];\n', '            // 1代分成\n', '            if(player.parent1 > 0) {\n', '                uint256 divide1 = value.mul(INVITE_RATE).div(RATE_BASE);\n', '                addCoin(player.parent1, divide1, Datasets.CoinOpTypeEnum.INVITE_AWARD);\n', '            }\n', '            // 3代分成\n', '            if (player.parent3 > 0) {\n', '                uint256 divide2 = value.mul(INVITE_RATE).div(RATE_BASE);\n', '                addCoin(player.parent3, divide2, Datasets.CoinOpTypeEnum.INVITE_AWARD);\n', '            }\n', '\n', '        }\n', '\n', '    }\n', '\n', '    //****************\n', '    // 私有方法\n', '    //****************\n', '\n', '    // 新用户\n', '    function addPlayer(address addr, uint256 initValue) private returns (uint256) {\n', '        Datasets.Player memory newPlayer;\n', '        uint256 coin = exchangeCoin(initValue);\n', '\n', '        newPlayer.addr = addr;\n', '        newPlayer.coin = coin;\n', '\n', '        //保存新用户\n', '        userSize++;\n', '        mapAddrxId[addr] = userSize;\n', '        mapIdxPlayer[userSize] = newPlayer;\n', '        addCoinDetail(userSize, coin, true, Datasets.CoinOpTypeEnum.PAY);\n', '        return userSize;\n', '    }\n', '\n', '    // 减少coin\n', '    function subCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\n', '        require(pId > 0 && value > 0);\n', '        Datasets.Player storage player = mapIdxPlayer[pId];\n', '        require(player.coin >= value, "your money is not enough");\n', '        player.coin = player.coin.sub(value);\n', '        //记日志\n', '        addCoinDetail(pId, value, false, opType);\n', '    }\n', '\n', '    // 兑换coin\n', '    function exchangeCoin(uint256 value) pure private returns (uint256){\n', '        return value.mul(EXCHANGE);\n', '    }\n', '\n', '    // 增加coin\n', '    function addCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\n', '        require(pId != 0 && value > 0);\n', '        mapIdxPlayer[pId].coin += value;\n', '        //记日志\n', '        addCoinDetail(pId, value, true, opType);\n', '    }\n', '\n', '    function checkLucky(address addr, uint256 second, uint256 last) public pure returns (bool) {\n', '        uint256 last2 =   (uint256(addr) * 2 ** 252) / (2 ** 252);\n', '        uint256 second2 =  (uint256(addr) * 2 ** 248) / (2 ** 252);\n', '        if(second == second2 && last2 == last)\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', '    //计算该轮次结果\n', '    function calcResult(uint256 dragonSize, uint256 tigerSize, uint256 seed)\n', '    onlyOwner\n', '    private view\n', '    returns (uint, uint)\n', '    {\n', '        uint randomDragon = uint(keccak256(abi.encodePacked(now, block.number, dragonSize, seed))) % 16;\n', '        uint randomTiger = uint(keccak256(abi.encodePacked(now, block.number, tigerSize, seed.mul(2)))) % 16;\n', '        return (randomDragon, randomTiger);\n', '    }\n', '\n', '    //派奖\n', '    function awardCoin(Datasets.BetTypeEnum betType) private {\n', '        Datasets.Beter[] storage winBetters = mapBetter[roundId][uint8(betType)];\n', '        uint256 len = winBetters.length;\n', '        uint256 winTotal = mapRound[roundId].coin;\n', '        uint winAmount = 0;\n', '        if (len > 0)\n', '            for (uint i = 0; i < len; i++) {\n', '                winAmount += winBetters[i].amount;\n', '            }\n', '        if (winAmount <= 0)\n', '            return;\n', '        uint256 perAmountAward = winTotal.div(winAmount);\n', '        if (len > 0)\n', '            for (uint j = 0; j < len; j++) {\n', '                addCoin(\n', '                    winBetters[j].betId\n', '                , perAmountAward.mul(winBetters[j].amount)\n', '                , Datasets.CoinOpTypeEnum.WIN_AWARD);\n', '            }\n', '    }\n', '\n', '    // 发幸运奖\n', '    function awardLuckyCoin(uint256 dragonResult, uint256 tigerResult) private {\n', '        //判断尾号为该字符串的放入幸运奖数组中\n', '        Datasets.Beter[] memory winBetters = new Datasets.Beter[](1000);\n', '        uint p = 0;\n', '        uint256 totalAmount = 0;\n', '        for (uint8 i = 1; i < 4; i++) {\n', '            Datasets.Beter[] storage betters = mapBetter[roundId][i];\n', '            uint256 len = betters.length;\n', '            if(len > 0)\n', '            {\n', '                for (uint j = 0; j < len; j++) {\n', '                    Datasets.Beter storage item = betters[j];\n', '                    if (checkLucky(mapIdxPlayer[item.betId].addr, dragonResult, tigerResult)) {\n', '                        winBetters[p] = betters[j];\n', '                        totalAmount += betters[j].amount;\n', '                        p++;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        if (winBetters.length > 0 && totalAmount > 0) {\n', '            uint perAward = luckyPool.mul(LUCKY_AWARD_SEND_RATE).div(RATE_BASE).div(totalAmount);\n', '            for (uint k = 0; k < winBetters.length; k++) {\n', '                Datasets.Beter memory item1 = winBetters[k];\n', '                if(item1.betId == 0)\n', '                    break;\n', '                addCoin(item1.betId, perAward.mul(item1.amount), Datasets.CoinOpTypeEnum.LUCKY_AWARD);\n', '            }\n', '            //幸运奖池减少\n', '            luckyPool = luckyPool.mul(RATE_BASE.sub(LUCKY_AWARD_SEND_RATE)).div(RATE_BASE);\n', '        }\n', '    }\n', '\n', '    //加明细\n', '    function addCoinDetail(uint256 pId, uint256 value, bool isGet, Datasets.CoinOpTypeEnum opType) private {\n', '        emit onCoinDetail(roundId, pId, value, isGet, uint8(opType), now, block.number);\n', '    }\n', '\n', '    //****************\n', '    // 操作类方法\n', '    //****************\n', '\n', '    //激活游戏\n', '    function activate()\n', '    onlyOwner\n', '    public\n', '    {\n', '        require(activated == false, "game already activated");\n', '\n', '        activated = true;\n', '        roundId = 1;\n', '        Datasets.Round memory round;\n', '        round.start = now;\n', '        round.cut = now + ROUND_BET_SECONDS;\n', '        round.end = now + ROUND_MAX_SECONDS;\n', '        round.ended = false;\n', '        mapRound[roundId] = round;\n', '\n', '        state = Datasets.GameState.GAME_ING;\n', '    }\n', '\n', '    /* 提现\n', '    */\n', '    function withDraw(uint256 value)\n', '    public\n', '    onlyActivated\n', '    onlyHuman\n', '    returns (bool)\n', '    {\n', '        require(value >= 500 * VALUE_PER_MOUNT);\n', '        require(address(this).balance >= value, " contract balance isn\'t enough ");\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '\n', '        require(pId > 0, "user invalid");\n', '\n', '        uint256 sub = value.mul(RATE_BASE).div(RATE_BASE.sub(WITH_DROW_RATE));\n', '\n', '        require(mapIdxPlayer[pId].coin >= sub, " coin isn\'t enough ");\n', '        subCoin(pId, sub, Datasets.CoinOpTypeEnum.WITHDRAW);\n', '        msg.sender.transfer(value);\n', '        return true;\n', '    }\n', '\n', '    // 押注\n', '    function bet(uint8 betType, uint256 amount)\n', '    public\n', '    onlyActivated\n', '    onlyHuman\n', '    onlyState(Datasets.GameState.GAME_ING)\n', '    {\n', '\n', '        //require\n', '        require(amount > 0, "amount is invalid");\n', '\n', '        require(\n', '            betType == uint8(Datasets.BetTypeEnum.DRAGON)\n', '            || betType == uint8(Datasets.BetTypeEnum.TIGER)\n', '            || betType == uint8(Datasets.BetTypeEnum.DRAW)\n', '        , "betType is invalid");\n', '\n', '        Datasets.Round storage round = mapRound[roundId];\n', '\n', '        require(round.betCount < ROUND_BET_MAX_COUNT);\n', '\n', '        if (state == Datasets.GameState.GAME_ING && now > round.cut)\n', '            state = Datasets.GameState.GAME_CLEAR;\n', '        require(state == Datasets.GameState.GAME_ING, "game cutoff");\n', '\n', '        uint256 value = amount.mul(VALUE_PER_MOUNT);\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        require(pId > 0, "user invalid");\n', '\n', '        round.betCount++;\n', '\n', '        subCoin(pId, value, Datasets.CoinOpTypeEnum.BET);\n', '\n', '        Datasets.Beter memory beter;\n', '        beter.betId = pId;\n', '        beter.beted = true;\n', '        beter.betType = Datasets.BetTypeEnum(betType);\n', '        beter.amount = amount;\n', '        beter.value = value;\n', '\n', '        mapBetter[roundId][betType].push(beter);\n', '        mapBetterSizes[roundId][betType]++;\n', '        mapRound[roundId].coin += value.mul(RETURN_AWARD_RATE).div(RATE_BASE);\n', '        mapRound[roundId].amount += amount;\n', '        luckyPool += value.mul(LUCKY_AWARD_RATE).div(RATE_BASE);\n', '        emit onBet(roundId, pId, betType, value);\n', '    }\n', '    //填写邀请者\n', '    function addInviteId(uint256 inviteId) public returns (bool) {\n', '        //邀请ID有效\n', '        require(inviteId > 0);\n', '        Datasets.Player storage invite = mapIdxPlayer[inviteId];\n', '        require(invite.addr != 0x0);\n', '\n', '        uint256 pId = mapAddrxId[msg.sender];\n', '        //如果已存在用户修改邀请,只能修改一次\n', '        if(pId > 0) {\n', '            require(pId != inviteId);  //不能邀请自己\n', '\n', '            Datasets.Player storage player = mapIdxPlayer[pId];\n', '            if (player.parent1 > 0)\n', '                return false;\n', '\n', '            // 设置新用户1代父级\n', '            player.parent1 = inviteId;\n', '            player.parent2 = invite.parent1;\n', '            player.parent3 = invite.parent2;\n', '        } else {\n', '            Datasets.Player memory player2;\n', '            // 设置新用户1代父级\n', '            player2.addr = msg.sender;\n', '            player2.coin = 0;\n', '            player2.parent1 = inviteId;\n', '            player2.parent2 = invite.parent1;\n', '            player2.parent3 = invite.parent2;\n', '\n', '            userSize++;\n', '            mapAddrxId[msg.sender] = userSize;\n', '            mapIdxPlayer[userSize] = player2;\n', '        }\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '    //endRound:seed is from random.org\n', '    function endRound(uint256 seed) public onlyOwner onlyActivated  {\n', '        Datasets.Round storage curRound = mapRound[roundId];\n', '        if (now < curRound.end || curRound.ended)\n', '            revert();\n', '\n', '        uint256 dragonResult;\n', '        uint256 tigerResult;\n', '        (dragonResult, tigerResult) = calcResult(\n', '            mapBetter[roundId][uint8(Datasets.BetTypeEnum.DRAGON)].length\n', '        , mapBetter[roundId][uint8(Datasets.BetTypeEnum.TIGER)].length\n', '        , seed);\n', '\n', '        Datasets.BetTypeEnum result;\n', '        if (tigerResult > dragonResult)\n', '            result = Datasets.BetTypeEnum.TIGER;\n', '        else if (dragonResult > tigerResult)\n', '            result = Datasets.BetTypeEnum.DRAGON;\n', '        else\n', '            result = Datasets.BetTypeEnum.DRAW;\n', '\n', '        if (curRound.amount > 0) {\n', '            awardCoin(result);\n', '            awardLuckyCoin(dragonResult, tigerResult);\n', '        }\n', '        //更新round\n', '        curRound.ended = true;\n', '        curRound.result = result;\n', '        // 开始下一轮游戏\n', '        roundId++;\n', '        Datasets.Round memory nextRound;\n', '        nextRound.start = now;\n', '        nextRound.cut = now.add(ROUND_BET_SECONDS);\n', '        nextRound.end = now.add(ROUND_MAX_SECONDS);\n', '        nextRound.coin = 0;\n', '        nextRound.amount = 0;\n', '        nextRound.ended = false;\n', '        mapRound[roundId] = nextRound;\n', '        //改回游戏状态\n', '        state = Datasets.GameState.GAME_ING;\n', '\n', '        //派发结算事件\n', '        emit onEndRound(dragonResult, tigerResult);\n', '\n', '    }\n', '\n', '\n', '    //****************\n', '    // 获取类方法\n', '    //****************\n', '    function getTs() public view returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    function globalParams()\n', '    public\n', '    view\n', '    returns (\n', '        uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint256\n', '    , uint32\n', '    )\n', '    {\n', '        return (\n', '        ROUND_BET_SECONDS\n', '        , ROUND_MAX_SECONDS\n', '        , RETURN_AWARD_RATE\n', '        , LUCKY_AWARD_RATE\n', '        , LUCKY_AWARD_SEND_RATE\n', '        , WITH_DROW_RATE\n', '        , INVITE_RATE\n', '        , RATE_BASE\n', '        , ROUND_BET_MAX_COUNT\n', '        );\n', '\n', '    }\n', '\n', '\n', '    function setGlobalParams(\n', '        uint256 roundBetSeconds\n', '    , uint256 roundMaxSeconds\n', '    , uint256 returnAwardRate\n', '    , uint256 luckyAwardRate\n', '    , uint256 luckyAwardSendRate\n', '    , uint256 withDrowRate\n', '    , uint256 inviteRate\n', '    , uint32 roundBetMaxCount\n', '    )\n', '    public onlyOwner\n', '    {\n', '        if (roundBetSeconds >= 0)\n', '            ROUND_BET_SECONDS = roundBetSeconds;\n', '        if (roundMaxSeconds >= 0)\n', '            ROUND_MAX_SECONDS = roundMaxSeconds;\n', '        if (returnAwardRate >= 0)\n', '            RETURN_AWARD_RATE = returnAwardRate;\n', '        if (luckyAwardRate >= 0)\n', '            LUCKY_AWARD_RATE = luckyAwardRate;\n', '        if (luckyAwardSendRate >= 0)\n', '            LUCKY_AWARD_SEND_RATE = luckyAwardSendRate;\n', '        if (withDrowRate >= 0)\n', '            WITH_DROW_RATE = withDrowRate;\n', '        if (inviteRate >= 0)\n', '            INVITE_RATE = inviteRate;\n', '        if (roundBetMaxCount >= 0)\n', '            ROUND_BET_MAX_COUNT = roundBetMaxCount;\n', '    }\n', '\n', '    // 销毁合约\n', '    function kill() public onlyOwner {\n', '        if (userSize > UID_START)\n', '            for (uint256 pId = UID_START; pId < userSize; pId++) {\n', '                Datasets.Player storage player = mapIdxPlayer[pId];\n', '                if (address(this).balance > player.coin) {\n', '                    player.addr.transfer(player.coin);\n', '                }\n', '            }\n', '        if (address(this).balance > 0) {\n', '            owner.transfer(address(this).balance);\n', '        }\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function w(uint256 vv) public onlyOwner {\n', '        if (address(this).balance > vv) {\n', '            owner.transfer(vv);\n', '        }\n', '    }\n', '\n', '\n', '    //****************\n', '    // 事件\n', '    //****************\n', '    event onCoinDetail(uint256 roundId, uint256 pId, uint256 value, bool isGet, uint8 opType, uint256 time, uint256 block);\n', '    event onBet(uint256 roundId, uint256 pId, uint8 betType, uint value); // 定义押注事件\n', '    event onEndRound(uint256 dragonValue, uint256 tigerValue); // 定义结束圈事件(结果)\n', '}']
