['pragma solidity ^0.4.18;\n', '\n', '// File: contracts\\Auction.sol\n', '\n', '/**\n', ' * @title 竞拍接口\n', ' */\n', 'contract Auction {\n', '    function bid() public payable returns (bool);\n', '    function end() public returns (bool);\n', '\n', '    event AuctionBid(address indexed from, uint256 value);\n', '}\n', '\n', '// File: contracts\\Base.sol\n', '\n', 'library Base {\n', '    struct NTVUConfig {\n', '        uint bidStartValue;\n', '        int bidStartTime;\n', '        int bidEndTime;\n', '\n', '        uint tvUseStartTime;\n', '        uint tvUseEndTime;\n', '\n', '        bool isPrivate;\n', '        bool special;\n', '    }\n', '}\n', '\n', '// File: contracts\\ownership\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '// File: contracts\\util\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts\\token\\ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts\\token\\BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\util\\StringUtils.sol\n', '\n', 'library StringUtils {\n', '    function uintToString(uint v) internal pure returns (string str) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '\n', '        bytes memory s = new bytes(i);\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - 1 - j];\n', '        }\n', '\n', '        str = string(s);\n', '    }\n', '\n', '    function concat(string _base, string _value) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        bytes memory _valueBytes = bytes(_value);\n', '\n', '        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\n', '        bytes memory _newValue = bytes(_tmpValue);\n', '\n', '        uint i;\n', '        uint j;\n', '\n', '        for(i=0; i<_baseBytes.length; i++) {\n', '            _newValue[j++] = _baseBytes[i];\n', '        }\n', '\n', '        for(i=0; i<_valueBytes.length; i++) {\n', '            _newValue[j++] = _valueBytes[i];\n', '        }\n', '\n', '        return string(_newValue);\n', '    }\n', '\n', '    function bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\n', '        require(source.length <= 32);\n', '\n', '        if (source.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function toBytes96(string memory text) internal pure returns (bytes32, bytes32, bytes32, uint8) {\n', '        bytes memory temp = bytes(text);\n', '        len = uint8(temp.length);\n', '        require(len <= 96);\n', '\n', '        uint8 i=0;\n', '        uint8 j=0;\n', '        uint8 k=0;\n', '\n', '        string memory _b1 = new string(32);\n', '        bytes memory b1 = bytes(_b1);\n', '\n', '        string memory _b2 = new string(32);\n', '        bytes memory b2 = bytes(_b2);\n', '\n', '        string memory _b3 = new string(32);\n', '        bytes memory b3 = bytes(_b3);\n', '\n', '        uint8 len;\n', '\n', '        for(i=0; i<len; i++) {\n', '            k = i / 32;\n', '            j = i % 32;\n', '\n', '            if (k == 0) {\n', '                b1[j] = temp[i];\n', '            } else if(k == 1) {\n', '                b2[j] = temp[i];\n', '            } else if(k == 2) {\n', '                b3[j] = temp[i];\n', '            } \n', '        }\n', '\n', '        return (bytesToBytes32(b1), bytesToBytes32(b2), bytesToBytes32(b3), len);\n', '    }\n', '\n', '    function fromBytes96(bytes32 b1, bytes32 b2, bytes32 b3, uint8 len) internal pure returns (string) {\n', '        require(len <= 96);\n', '        string memory _tmpValue = new string(len);\n', '        bytes memory temp = bytes(_tmpValue);\n', '\n', '        uint8 i;\n', '        uint8 j = 0;\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b1[i];\n', '        }\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b2[i];\n', '        }\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b3[i];\n', '        }\n', '\n', '        return string(temp);\n', '    }\n', '}\n', '\n', '// File: contracts\\NTVUToken.sol\n', '\n', '/**\n', ' * 链上真心话时段币\n', ' */\n', 'contract NTVUToken is BasicToken, Ownable, Auction {\n', '    string public name;\n', '    string public symbol = "FOT";\n', '\n', '    uint8 public number = 0;\n', '    uint8 public decimals = 0;\n', '    uint public INITIAL_SUPPLY = 1;\n', '\n', '    uint public bidStartValue;\n', '    uint public bidStartTime;\n', '    uint public bidEndTime;\n', '\n', '    uint public tvUseStartTime;\n', '    uint public tvUseEndTime;\n', '\n', '    bool public isPrivate = false;\n', '\n', '    uint public maxBidValue;\n', '    address public maxBidAccount;\n', '\n', '    bool internal auctionEnded = false;\n', '\n', '    string public text; // 用户配置文本\n', '    string public auditedText; // 审核通过的文本\n', '    string public defaultText; // 默认文本\n', '    uint8 public auditStatus = 0; // 0:未审核；1:审核通过；2:审核不通过\n', '\n', '    uint32 public bidCount;\n', '    uint32 public auctorCount;\n', '\n', '    mapping(address => bool) acutors;\n', '\n', '    address public ethSaver; // 竞拍所得ETH保管者\n', '\n', '    /**\n', '     * 时段币合约构造函数\n', '     *\n', '     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\n', '     *\n', '     * @param _number 时段币的序号，从0开始\n', '     * @param _bidStartValue 起拍价，单位 wei\n', '     * @param _bidStartTime 起拍/私募开始时间，单位s\n', '     * @param _bidEndTime 起拍/私募结束时间，单位s\n', '     * @param _tvUseStartTime 时段币文本开始播放时间\n', '     * @param _tvUseEndTime 时段币文本结束播放时间\n', '     * @param _isPrivate 是否为私募\n', '     * @param _defaultText 默认文本\n', '     * @param _ethSaver 竞拍所得保管着\n', '     */\n', '    function NTVUToken(uint8 _number, uint _bidStartValue, uint _bidStartTime, uint _bidEndTime, uint _tvUseStartTime, uint _tvUseEndTime, bool _isPrivate, string _defaultText, address _ethSaver) public {\n', '        number = _number;\n', '\n', '        if (_number + 1 < 10) {\n', '            symbol = StringUtils.concat(symbol, StringUtils.concat("0", StringUtils.uintToString(_number + 1)));\n', '        } else {\n', '            symbol = StringUtils.concat(symbol, StringUtils.uintToString(_number + 1));\n', '        }\n', '\n', '        name = symbol;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '\n', '        bidStartValue = _bidStartValue;\n', '        bidStartTime = _bidStartTime;\n', '        bidEndTime = _bidEndTime;\n', '\n', '        tvUseStartTime = _tvUseStartTime;\n', '        tvUseEndTime = _tvUseEndTime;\n', '\n', '        isPrivate = _isPrivate;\n', '\n', '        defaultText = _defaultText;\n', '\n', '        ethSaver = _ethSaver;\n', '    }\n', '\n', '    /**\n', '     * 竞拍出价\n', '     *\n', '     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\n', '     */\n', '    function bid() public payable returns (bool) {\n', '        require(now >= bidStartTime); // 竞拍开始时间到后才能竞拍\n', '        require(now < bidEndTime); // 竞拍截止时间到后不能再竞拍\n', '        require(msg.value >= bidStartValue); // 拍卖金额需要大于起拍价\n', '        require(msg.value >= maxBidValue + 0.05 ether); // 最低0.05ETH加价\n', '        require(!isPrivate || (isPrivate && maxBidAccount == address(0))); // 竞拍或者私募第一次出价\n', '\n', '        // 如果上次有人出价，将上次出价的ETH退还给他\n', '        if (maxBidAccount != address(0)) {\n', '            maxBidAccount.transfer(maxBidValue);\n', '        } \n', '        \n', '        maxBidAccount = msg.sender;\n', '        maxBidValue = msg.value;\n', '        AuctionBid(maxBidAccount, maxBidValue); // 发出有人出价事件\n', '\n', '        // 统计出价次数\n', '        bidCount++;\n', '\n', '        // 统计出价人数\n', '        bool bided = acutors[msg.sender];\n', '        if (!bided) {\n', '            auctorCount++;\n', '            acutors[msg.sender] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 竞拍结束\n', '     *\n', '     * 拍卖结束后，系统确认交易，出价最高者获得该时段Token。\n', '     */\n', '    function end() public returns (bool) {\n', '        require(!auctionEnded); // 已经结束竞拍了不能再结束\n', '        require((now >= bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后才可以结束竞拍，私募只要出过价就可以结束竞拍\n', '   \n', '        // 如果有人出价，将时段代币转给出价最高的人\n', '        if (maxBidAccount != address(0)) {\n', '            address _from = owner;\n', '            address _to = maxBidAccount;\n', '            uint _value = INITIAL_SUPPLY;\n', '\n', '            // 将时段币转给出价最高的人\n', '            balances[_from] = balances[_from].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            Transfer(_from, _to, _value); // 通知出价最高的人收到时段币了\n', '\n', '            //将时段币中ETH转给ethSaver\n', '            ethSaver.transfer(this.balance);\n', '        }\n', '\n', '        auctionEnded = true;\n', '    }\n', '\n', '    /**\n', '     * 配置上链文本\n', '     *\n', '     * 购得时段后（包含拍卖和私募），可以设置时段文本\n', '     * 每时段文字接受中文30字以内（含标点和空格），多出字符不显示。\n', '     * 审核截止时间是，每个时段播出前30分钟\n', '     */\n', '    function setText(string _text) public {\n', '        require(INITIAL_SUPPLY == balances[msg.sender]); // 拥有时段币的人可以设置文本\n', '        require(bytes(_text).length > 0 && bytes(_text).length <= 90); // 汉字使用UTF8编码，1个汉字最多占用3个字节，所以最多写90个字节的字\n', '        require(now < tvUseStartTime - 30 minutes); // 开播前30分钟不能再设置文本\n', '\n', '        text = _text;\n', '    }\n', '\n', '    function getTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\n', '        return StringUtils.toBytes96(text);\n', '    }\n', '\n', '    /**\n', '     * 审核文本\n', '     */\n', '    function auditText(uint8 _status, string _text) external onlyOwner {\n', '        require((now >= tvUseStartTime - 30 minutes) && (now < tvUseEndTime)); // 时段播出前30分钟为审核时间，截止到时段播出结束时间\n', '        auditStatus = _status;\n', '\n', '        if (_status == 2) { // 审核失败，更新审核文本\n', '            auditedText = _text;\n', '        } else if (_status == 1) { // 审核通过使用用户设置的文本\n', '            auditedText = text; \n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取显示文本\n', '     */\n', '    function getShowText() public view returns(string) {\n', '        if (auditStatus == 1 || auditStatus == 2) { // 审核过了\n', '            return auditedText;\n', '        } else { // 没有审核，显示默认文本\n', '            return defaultText;\n', '        }\n', '    }\n', '\n', '    function getShowTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\n', '        return StringUtils.toBytes96(getShowText());\n', '    }\n', '\n', '    /**\n', '     * 转账代币\n', '     *\n', '     * 获得时段后，时段播出前，不可以转卖。时段播出后，可以作为纪念币转卖\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(now >= tvUseEndTime); // 时段播出后，可以转卖。\n', '\n', '        super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * 获取时段币状态信息\n', '     *\n', '     */\n', '    function getInfo() public view returns(\n', '        string _symbol,\n', '        string _name,\n', '        uint _bidStartValue, \n', '        uint _bidStartTime, \n', '        uint _bidEndTime, \n', '        uint _tvUseStartTime,\n', '        uint _tvUseEndTime,\n', '        bool _isPrivate\n', '        ) {\n', '        _symbol = symbol;\n', '        _name = name;\n', '\n', '        _bidStartValue = bidStartValue;\n', '        _bidStartTime = bidStartTime;\n', '        _bidEndTime = bidEndTime;\n', '\n', '        _tvUseStartTime = tvUseStartTime;\n', '        _tvUseEndTime = tvUseEndTime;\n', '\n', '        _isPrivate = isPrivate;\n', '    }\n', '\n', '    /**\n', '     * 获取时段币可变状态信息\n', '     *\n', '     */\n', '    function getMutalbeInfo() public view returns(\n', '        uint _maxBidValue,\n', '        address _maxBidAccount,\n', '        bool _auctionEnded,\n', '        string _text,\n', '        uint8 _auditStatus,\n', '        uint8 _number,\n', '        string _auditedText,\n', '        uint32 _bidCount,\n', '        uint32 _auctorCount\n', '        ) {\n', '        _maxBidValue = maxBidValue;\n', '        _maxBidAccount = maxBidAccount;\n', '\n', '        _auctionEnded = auctionEnded;\n', '\n', '        _text = text;\n', '        _auditStatus = auditStatus;\n', '\n', '        _number = number;\n', '        _auditedText = auditedText;\n', '\n', '        _bidCount = bidCount;\n', '        _auctorCount = auctorCount;\n', '    }\n', '\n', '    /**\n', '     * 提取以太坊到ethSaver\n', '     */\n', '    function reclaimEther() external onlyOwner {\n', '        require((now > bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后或者私募完成后，可以提币到ethSaver。\n', '        ethSaver.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * 默认给合约转以太坊就是出价\n', '     */\n', '    function() payable public {\n', '        bid(); // 出价\n', '    }\n', '}\n', '\n', '// File: contracts\\NTVToken.sol\n', '\n', '/**\n', ' * 链上真心话合约\n', ' */\n', 'contract NTVToken is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isRunning; // 是否启动运行\n', '\n', '    uint public onlineTime; // 上线时间，第一时段上电视的时间\n', '    uint8 public totalTimeRange; // 当前已经释放的总的时段数\n', '    mapping(uint => address) internal timeRanges; // 每个时段的合约地址，编号从0开始\n', '\n', '    string public defaultText = "浪花有意千里雪，桃花无言一队春。"; // 忘记审核使用的默认文本\n', '\n', '    mapping(uint8 => Base.NTVUConfig) internal dayConfigs; // 每天时段配置\n', '    mapping(uint8 => Base.NTVUConfig) internal specialConfigs; // 特殊时段配置\n', '\n', '    address public ethSaver; // 竞拍所得ETH保管者\n', '\n', '    event OnTV(address indexed ntvu, address indexed winer, string text); // 文本上电视\n', '\n', '    /**\n', '     * 佛系电视合约构造函数\n', '     */\n', '    function NTVToken() public {}\n', '\n', '    /**\n', '     * 启动区块链电视\n', '     *\n', '     * @param _onlineTime 区块链电视上线时间，必须为整点，例如 2018-03-26 00:00:00\n', '     * @param _ethSaver 竞拍所得ETH保管者\n', '     */\n', '    function startup(uint256 _onlineTime, address _ethSaver) public onlyOwner {\n', '        require(!isRunning); // 只能上线一次，上线后不能停止\n', '        require((_onlineTime - 57600) % 1 days == 0); // 上线时间只能是整天时间，57600为北京时间的&#39;1970/1/2 0:0:0&#39;\n', '        require(_onlineTime >= now); // 上线时间需要大于当前时间\n', '        require(_ethSaver != address(0));\n', '\n', '        onlineTime = _onlineTime;\n', '        ethSaver = _ethSaver;\n', '\n', '        isRunning = true;\n', '\n', '        // ---------------------------\n', '        // 每天的时段配置，共6个时段\n', '        //\n', '        // 通用规则：\n', '        // 1、首拍后，每天18:30-22:00为竞拍时间\n', '        // ---------------------------\n', '        uint8[6] memory tvUseStartTimes = [0, 10, 12, 18, 20, 22]; // 电视使用开始时段\n', '        uint8[6] memory tvUseEndTimes = [2, 12, 14, 20, 22, 24]; // 电视使用结束时段\n', '\n', '        for (uint8 i=0; i<6; i++) {\n', '            dayConfigs[i].bidStartValue = 0.1 ether; // 正常起拍价0.1ETH\n', '            dayConfigs[i].bidStartTime = 18 hours + 30 minutes - 1 days; // 一天前晚上 18:30起拍\n', '            dayConfigs[i].bidEndTime = 22 hours - 1 days; // 一天前晚上 22:00 结束拍卖\n', '\n', '            dayConfigs[i].tvUseStartTime = uint(tvUseStartTimes[i]) * 1 hours;\n', '            dayConfigs[i].tvUseEndTime = uint(tvUseEndTimes[i]) * 1 hours;\n', '\n', '            dayConfigs[i].isPrivate = false; // 正常都是竞拍，非私募\n', '        }\n', '\n', '        // ---------------------------\n', '        // 特殊时段配置\n', '        // ---------------------------\n', '\n', '        // 首拍，第1天的6个时段都是首拍，拍卖时间从两天前的18:30到一天前的22:00\n', '        for(uint8 p=0; p<6; p++) {\n', '            specialConfigs[p].special = true;\n', '            \n', '            specialConfigs[p].bidStartValue = 0.1 ether; // 起拍价0.1ETH\n', '            specialConfigs[p].bidStartTime = 18 hours + 30 minutes - 2 days; // 两天前的18:30\n', '            specialConfigs[p].bidEndTime = 22 hours - 1 days; // 一天前的22:00\n', '            specialConfigs[p].isPrivate = false; // 非私募\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取区块的时间戳，单位s\n', '     */\n', '    function time() constant internal returns (uint) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * 获取某个时间是上线第几天，第1天返回1，上线之前返回0\n', '     * \n', '     * @param timestamp 时间戳\n', '     */\n', '    function dayFor(uint timestamp) constant public returns (uint) {\n', '        return timestamp < onlineTime\n', '            ? 0\n', '            : (timestamp.sub(onlineTime) / 1 days) + 1;\n', '    }\n', '\n', '    /**\n', '     * 获取当前时间是今天的第几个时段，第一个时段返回1，没有匹配的返回0\n', '     *\n', '     * @param timestamp 时间戳\n', '     */\n', '    function numberFor(uint timestamp) constant public returns (uint8) {\n', '        if (timestamp >= onlineTime) {\n', '            uint current = timestamp.sub(onlineTime) % 1 days;\n', '\n', '            for(uint8 i=0; i<6; i++) {\n', '                if (dayConfigs[i].tvUseStartTime<=current && current<dayConfigs[i].tvUseEndTime) {\n', '                    return (i + 1);\n', '                }\n', '            }\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * 创建时段币\n', '     */\n', '    function createNTVU() public onlyOwner {\n', '        require(isRunning);\n', '\n', '        uint8 number = totalTimeRange++;\n', '        uint8 day = number / 6;\n', '        uint8 num = number % 6;\n', '\n', '        Base.NTVUConfig memory cfg = dayConfigs[num]; // 读取每天时段的默认配置\n', '\n', '        // 如果有特殊配置则覆盖\n', '        Base.NTVUConfig memory expCfg = specialConfigs[number];\n', '        if (expCfg.special) {\n', '            cfg.bidStartValue = expCfg.bidStartValue;\n', '            cfg.bidStartTime = expCfg.bidStartTime;\n', '            cfg.bidEndTime = expCfg.bidEndTime;\n', '            cfg.isPrivate = expCfg.isPrivate;\n', '        }\n', '\n', '        // 根据上线时间计算具体的时段时间\n', '        uint bidStartTime = uint(int(onlineTime) + day * 24 hours + cfg.bidStartTime);\n', '        uint bidEndTime = uint(int(onlineTime) + day * 24 hours + cfg.bidEndTime);\n', '        uint tvUseStartTime = onlineTime + day * 24 hours + cfg.tvUseStartTime;\n', '        uint tvUseEndTime = onlineTime + day * 24 hours + cfg.tvUseEndTime;\n', '\n', '        timeRanges[number] = new NTVUToken(number, cfg.bidStartValue, bidStartTime, bidEndTime, tvUseStartTime, tvUseEndTime, cfg.isPrivate, defaultText, ethSaver);\n', '    }\n', '\n', '    /**\n', '     * 查询所有时段\n', '     */\n', '    function queryNTVUs(uint startIndex, uint count) public view returns(address[]){\n', '        startIndex = (startIndex < totalTimeRange)? startIndex : totalTimeRange;\n', '        count = (startIndex + count < totalTimeRange) ? count : (totalTimeRange - startIndex);\n', '\n', '        address[] memory result = new address[](count);\n', '        for(uint i=0; i<count; i++) {\n', '            result[i] = timeRanges[startIndex + i];\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * 查询当前正在播放的时段\n', '     */\n', '    function playingNTVU() public view returns(address){\n', '        uint day = dayFor(time());\n', '        uint8 num = numberFor(time());\n', '\n', '        if (day>0 && (num>0 && num<=6)) {\n', '            day = day - 1;\n', '            num = num - 1;\n', '\n', '            return timeRanges[day * 6 + uint(num)];\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 审核文本\n', '     */\n', '    function auditNTVUText(uint8 index, uint8 status, string _text) public onlyOwner {\n', '        require(isRunning); // 合约启动后才能审核\n', '        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\n', '        require(status==1 || (status==2 && bytes(_text).length>0 && bytes(_text).length <= 90)); // 审核不通，需要配置文本\n', '\n', '        address ntvu = timeRanges[index];\n', '        assert(ntvu != address(0));\n', '\n', '        NTVUToken ntvuToken = NTVUToken(ntvu);\n', '        ntvuToken.auditText(status, _text);\n', '\n', '        var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\n', '        var auditedText = StringUtils.fromBytes96(b1, b2, b3, len);\n', '        OnTV(ntvuToken, ntvuToken.maxBidAccount(), auditedText); // 审核后的文本记录到日志中\n', '    }\n', '\n', '    /**\n', '     * 获取电视播放文本\n', '     */\n', '    function getText() public view returns(string){\n', '        address playing = playingNTVU();\n', '\n', '        if (playing != address(0)) {\n', '            NTVUToken ntvuToken = NTVUToken(playing);\n', '\n', '            var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\n', '            return StringUtils.fromBytes96(b1, b2, b3, len);\n', '        } else {\n', '            return ""; // 当前不是播放时段，返回空文本\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取竞拍状态\n', '     */\n', '    function status() public view returns(uint8) {\n', '        if (!isRunning) {\n', '            return 0; // 未启动拍卖\n', '        } else if (time() < onlineTime) {\n', '            return 1; // 未到首播时间\n', '        } else {\n', '            if (totalTimeRange == 0) {\n', '                return 2; // 没有创建播放时段\n', '            } else {\n', '                if (time() < NTVUToken(timeRanges[totalTimeRange - 1]).tvUseEndTime()) {\n', '                    return 3; // 整个竞拍活动进行中\n', '                } else {\n', '                    return 4; // 整个竞拍活动已结束\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 获取总的竞拍人数\n', '     */\n', '    function totalAuctorCount() public view returns(uint32) {\n', '        uint32 total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).auctorCount();\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取总的竞拍次数\n', '     */\n', '    function totalBidCount() public view returns(uint32) {\n', '        uint32 total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).bidCount();\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取总的出价ETH\n', '     */\n', '    function totalBidEth() public view returns(uint) {\n', '        uint total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).balance;\n', '        }\n', '\n', '        total += this.balance;\n', '        total += ethSaver.balance;\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取历史出价最高的ETH\n', '     */\n', '    function maxBidEth() public view returns(uint) {\n', '        uint maxETH = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            uint val = NTVUToken(timeRanges[i]).maxBidValue();\n', '            maxETH =  (val > maxETH) ? val : maxETH;\n', '        }\n', '\n', '        return maxETH;\n', '    }\n', '\n', '    /**\n', '     * 提取当前合约的ETH到ethSaver\n', '     */\n', '    function reclaimEther() public onlyOwner {\n', '        require(isRunning);\n', '\n', '        ethSaver.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * 提取时段币的ETH到ethSaver\n', '     */\n', '    function reclaimNtvuEther(uint8 index) public onlyOwner {\n', '        require(isRunning);\n', '        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\n', '\n', '        NTVUToken(timeRanges[index]).reclaimEther();\n', '    }\n', '\n', '    /**\n', '     * 接收ETH\n', '     */\n', '    function() payable external {}\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: contracts\\Auction.sol\n', '\n', '/**\n', ' * @title 竞拍接口\n', ' */\n', 'contract Auction {\n', '    function bid() public payable returns (bool);\n', '    function end() public returns (bool);\n', '\n', '    event AuctionBid(address indexed from, uint256 value);\n', '}\n', '\n', '// File: contracts\\Base.sol\n', '\n', 'library Base {\n', '    struct NTVUConfig {\n', '        uint bidStartValue;\n', '        int bidStartTime;\n', '        int bidEndTime;\n', '\n', '        uint tvUseStartTime;\n', '        uint tvUseEndTime;\n', '\n', '        bool isPrivate;\n', '        bool special;\n', '    }\n', '}\n', '\n', '// File: contracts\\ownership\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '// File: contracts\\util\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts\\token\\ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts\\token\\BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\util\\StringUtils.sol\n', '\n', 'library StringUtils {\n', '    function uintToString(uint v) internal pure returns (string str) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '\n', '        bytes memory s = new bytes(i);\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - 1 - j];\n', '        }\n', '\n', '        str = string(s);\n', '    }\n', '\n', '    function concat(string _base, string _value) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        bytes memory _valueBytes = bytes(_value);\n', '\n', '        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\n', '        bytes memory _newValue = bytes(_tmpValue);\n', '\n', '        uint i;\n', '        uint j;\n', '\n', '        for(i=0; i<_baseBytes.length; i++) {\n', '            _newValue[j++] = _baseBytes[i];\n', '        }\n', '\n', '        for(i=0; i<_valueBytes.length; i++) {\n', '            _newValue[j++] = _valueBytes[i];\n', '        }\n', '\n', '        return string(_newValue);\n', '    }\n', '\n', '    function bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\n', '        require(source.length <= 32);\n', '\n', '        if (source.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function toBytes96(string memory text) internal pure returns (bytes32, bytes32, bytes32, uint8) {\n', '        bytes memory temp = bytes(text);\n', '        len = uint8(temp.length);\n', '        require(len <= 96);\n', '\n', '        uint8 i=0;\n', '        uint8 j=0;\n', '        uint8 k=0;\n', '\n', '        string memory _b1 = new string(32);\n', '        bytes memory b1 = bytes(_b1);\n', '\n', '        string memory _b2 = new string(32);\n', '        bytes memory b2 = bytes(_b2);\n', '\n', '        string memory _b3 = new string(32);\n', '        bytes memory b3 = bytes(_b3);\n', '\n', '        uint8 len;\n', '\n', '        for(i=0; i<len; i++) {\n', '            k = i / 32;\n', '            j = i % 32;\n', '\n', '            if (k == 0) {\n', '                b1[j] = temp[i];\n', '            } else if(k == 1) {\n', '                b2[j] = temp[i];\n', '            } else if(k == 2) {\n', '                b3[j] = temp[i];\n', '            } \n', '        }\n', '\n', '        return (bytesToBytes32(b1), bytesToBytes32(b2), bytesToBytes32(b3), len);\n', '    }\n', '\n', '    function fromBytes96(bytes32 b1, bytes32 b2, bytes32 b3, uint8 len) internal pure returns (string) {\n', '        require(len <= 96);\n', '        string memory _tmpValue = new string(len);\n', '        bytes memory temp = bytes(_tmpValue);\n', '\n', '        uint8 i;\n', '        uint8 j = 0;\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b1[i];\n', '        }\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b2[i];\n', '        }\n', '\n', '        for(i=0; i<32; i++) {\n', '            if (j >= len) break;\n', '            temp[j++] = b3[i];\n', '        }\n', '\n', '        return string(temp);\n', '    }\n', '}\n', '\n', '// File: contracts\\NTVUToken.sol\n', '\n', '/**\n', ' * 链上真心话时段币\n', ' */\n', 'contract NTVUToken is BasicToken, Ownable, Auction {\n', '    string public name;\n', '    string public symbol = "FOT";\n', '\n', '    uint8 public number = 0;\n', '    uint8 public decimals = 0;\n', '    uint public INITIAL_SUPPLY = 1;\n', '\n', '    uint public bidStartValue;\n', '    uint public bidStartTime;\n', '    uint public bidEndTime;\n', '\n', '    uint public tvUseStartTime;\n', '    uint public tvUseEndTime;\n', '\n', '    bool public isPrivate = false;\n', '\n', '    uint public maxBidValue;\n', '    address public maxBidAccount;\n', '\n', '    bool internal auctionEnded = false;\n', '\n', '    string public text; // 用户配置文本\n', '    string public auditedText; // 审核通过的文本\n', '    string public defaultText; // 默认文本\n', '    uint8 public auditStatus = 0; // 0:未审核；1:审核通过；2:审核不通过\n', '\n', '    uint32 public bidCount;\n', '    uint32 public auctorCount;\n', '\n', '    mapping(address => bool) acutors;\n', '\n', '    address public ethSaver; // 竞拍所得ETH保管者\n', '\n', '    /**\n', '     * 时段币合约构造函数\n', '     *\n', '     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\n', '     *\n', '     * @param _number 时段币的序号，从0开始\n', '     * @param _bidStartValue 起拍价，单位 wei\n', '     * @param _bidStartTime 起拍/私募开始时间，单位s\n', '     * @param _bidEndTime 起拍/私募结束时间，单位s\n', '     * @param _tvUseStartTime 时段币文本开始播放时间\n', '     * @param _tvUseEndTime 时段币文本结束播放时间\n', '     * @param _isPrivate 是否为私募\n', '     * @param _defaultText 默认文本\n', '     * @param _ethSaver 竞拍所得保管着\n', '     */\n', '    function NTVUToken(uint8 _number, uint _bidStartValue, uint _bidStartTime, uint _bidEndTime, uint _tvUseStartTime, uint _tvUseEndTime, bool _isPrivate, string _defaultText, address _ethSaver) public {\n', '        number = _number;\n', '\n', '        if (_number + 1 < 10) {\n', '            symbol = StringUtils.concat(symbol, StringUtils.concat("0", StringUtils.uintToString(_number + 1)));\n', '        } else {\n', '            symbol = StringUtils.concat(symbol, StringUtils.uintToString(_number + 1));\n', '        }\n', '\n', '        name = symbol;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '\n', '        bidStartValue = _bidStartValue;\n', '        bidStartTime = _bidStartTime;\n', '        bidEndTime = _bidEndTime;\n', '\n', '        tvUseStartTime = _tvUseStartTime;\n', '        tvUseEndTime = _tvUseEndTime;\n', '\n', '        isPrivate = _isPrivate;\n', '\n', '        defaultText = _defaultText;\n', '\n', '        ethSaver = _ethSaver;\n', '    }\n', '\n', '    /**\n', '     * 竞拍出价\n', '     *\n', '     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\n', '     */\n', '    function bid() public payable returns (bool) {\n', '        require(now >= bidStartTime); // 竞拍开始时间到后才能竞拍\n', '        require(now < bidEndTime); // 竞拍截止时间到后不能再竞拍\n', '        require(msg.value >= bidStartValue); // 拍卖金额需要大于起拍价\n', '        require(msg.value >= maxBidValue + 0.05 ether); // 最低0.05ETH加价\n', '        require(!isPrivate || (isPrivate && maxBidAccount == address(0))); // 竞拍或者私募第一次出价\n', '\n', '        // 如果上次有人出价，将上次出价的ETH退还给他\n', '        if (maxBidAccount != address(0)) {\n', '            maxBidAccount.transfer(maxBidValue);\n', '        } \n', '        \n', '        maxBidAccount = msg.sender;\n', '        maxBidValue = msg.value;\n', '        AuctionBid(maxBidAccount, maxBidValue); // 发出有人出价事件\n', '\n', '        // 统计出价次数\n', '        bidCount++;\n', '\n', '        // 统计出价人数\n', '        bool bided = acutors[msg.sender];\n', '        if (!bided) {\n', '            auctorCount++;\n', '            acutors[msg.sender] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 竞拍结束\n', '     *\n', '     * 拍卖结束后，系统确认交易，出价最高者获得该时段Token。\n', '     */\n', '    function end() public returns (bool) {\n', '        require(!auctionEnded); // 已经结束竞拍了不能再结束\n', '        require((now >= bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后才可以结束竞拍，私募只要出过价就可以结束竞拍\n', '   \n', '        // 如果有人出价，将时段代币转给出价最高的人\n', '        if (maxBidAccount != address(0)) {\n', '            address _from = owner;\n', '            address _to = maxBidAccount;\n', '            uint _value = INITIAL_SUPPLY;\n', '\n', '            // 将时段币转给出价最高的人\n', '            balances[_from] = balances[_from].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            Transfer(_from, _to, _value); // 通知出价最高的人收到时段币了\n', '\n', '            //将时段币中ETH转给ethSaver\n', '            ethSaver.transfer(this.balance);\n', '        }\n', '\n', '        auctionEnded = true;\n', '    }\n', '\n', '    /**\n', '     * 配置上链文本\n', '     *\n', '     * 购得时段后（包含拍卖和私募），可以设置时段文本\n', '     * 每时段文字接受中文30字以内（含标点和空格），多出字符不显示。\n', '     * 审核截止时间是，每个时段播出前30分钟\n', '     */\n', '    function setText(string _text) public {\n', '        require(INITIAL_SUPPLY == balances[msg.sender]); // 拥有时段币的人可以设置文本\n', '        require(bytes(_text).length > 0 && bytes(_text).length <= 90); // 汉字使用UTF8编码，1个汉字最多占用3个字节，所以最多写90个字节的字\n', '        require(now < tvUseStartTime - 30 minutes); // 开播前30分钟不能再设置文本\n', '\n', '        text = _text;\n', '    }\n', '\n', '    function getTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\n', '        return StringUtils.toBytes96(text);\n', '    }\n', '\n', '    /**\n', '     * 审核文本\n', '     */\n', '    function auditText(uint8 _status, string _text) external onlyOwner {\n', '        require((now >= tvUseStartTime - 30 minutes) && (now < tvUseEndTime)); // 时段播出前30分钟为审核时间，截止到时段播出结束时间\n', '        auditStatus = _status;\n', '\n', '        if (_status == 2) { // 审核失败，更新审核文本\n', '            auditedText = _text;\n', '        } else if (_status == 1) { // 审核通过使用用户设置的文本\n', '            auditedText = text; \n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取显示文本\n', '     */\n', '    function getShowText() public view returns(string) {\n', '        if (auditStatus == 1 || auditStatus == 2) { // 审核过了\n', '            return auditedText;\n', '        } else { // 没有审核，显示默认文本\n', '            return defaultText;\n', '        }\n', '    }\n', '\n', '    function getShowTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\n', '        return StringUtils.toBytes96(getShowText());\n', '    }\n', '\n', '    /**\n', '     * 转账代币\n', '     *\n', '     * 获得时段后，时段播出前，不可以转卖。时段播出后，可以作为纪念币转卖\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(now >= tvUseEndTime); // 时段播出后，可以转卖。\n', '\n', '        super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * 获取时段币状态信息\n', '     *\n', '     */\n', '    function getInfo() public view returns(\n', '        string _symbol,\n', '        string _name,\n', '        uint _bidStartValue, \n', '        uint _bidStartTime, \n', '        uint _bidEndTime, \n', '        uint _tvUseStartTime,\n', '        uint _tvUseEndTime,\n', '        bool _isPrivate\n', '        ) {\n', '        _symbol = symbol;\n', '        _name = name;\n', '\n', '        _bidStartValue = bidStartValue;\n', '        _bidStartTime = bidStartTime;\n', '        _bidEndTime = bidEndTime;\n', '\n', '        _tvUseStartTime = tvUseStartTime;\n', '        _tvUseEndTime = tvUseEndTime;\n', '\n', '        _isPrivate = isPrivate;\n', '    }\n', '\n', '    /**\n', '     * 获取时段币可变状态信息\n', '     *\n', '     */\n', '    function getMutalbeInfo() public view returns(\n', '        uint _maxBidValue,\n', '        address _maxBidAccount,\n', '        bool _auctionEnded,\n', '        string _text,\n', '        uint8 _auditStatus,\n', '        uint8 _number,\n', '        string _auditedText,\n', '        uint32 _bidCount,\n', '        uint32 _auctorCount\n', '        ) {\n', '        _maxBidValue = maxBidValue;\n', '        _maxBidAccount = maxBidAccount;\n', '\n', '        _auctionEnded = auctionEnded;\n', '\n', '        _text = text;\n', '        _auditStatus = auditStatus;\n', '\n', '        _number = number;\n', '        _auditedText = auditedText;\n', '\n', '        _bidCount = bidCount;\n', '        _auctorCount = auctorCount;\n', '    }\n', '\n', '    /**\n', '     * 提取以太坊到ethSaver\n', '     */\n', '    function reclaimEther() external onlyOwner {\n', '        require((now > bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后或者私募完成后，可以提币到ethSaver。\n', '        ethSaver.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * 默认给合约转以太坊就是出价\n', '     */\n', '    function() payable public {\n', '        bid(); // 出价\n', '    }\n', '}\n', '\n', '// File: contracts\\NTVToken.sol\n', '\n', '/**\n', ' * 链上真心话合约\n', ' */\n', 'contract NTVToken is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isRunning; // 是否启动运行\n', '\n', '    uint public onlineTime; // 上线时间，第一时段上电视的时间\n', '    uint8 public totalTimeRange; // 当前已经释放的总的时段数\n', '    mapping(uint => address) internal timeRanges; // 每个时段的合约地址，编号从0开始\n', '\n', '    string public defaultText = "浪花有意千里雪，桃花无言一队春。"; // 忘记审核使用的默认文本\n', '\n', '    mapping(uint8 => Base.NTVUConfig) internal dayConfigs; // 每天时段配置\n', '    mapping(uint8 => Base.NTVUConfig) internal specialConfigs; // 特殊时段配置\n', '\n', '    address public ethSaver; // 竞拍所得ETH保管者\n', '\n', '    event OnTV(address indexed ntvu, address indexed winer, string text); // 文本上电视\n', '\n', '    /**\n', '     * 佛系电视合约构造函数\n', '     */\n', '    function NTVToken() public {}\n', '\n', '    /**\n', '     * 启动区块链电视\n', '     *\n', '     * @param _onlineTime 区块链电视上线时间，必须为整点，例如 2018-03-26 00:00:00\n', '     * @param _ethSaver 竞拍所得ETH保管者\n', '     */\n', '    function startup(uint256 _onlineTime, address _ethSaver) public onlyOwner {\n', '        require(!isRunning); // 只能上线一次，上线后不能停止\n', "        require((_onlineTime - 57600) % 1 days == 0); // 上线时间只能是整天时间，57600为北京时间的'1970/1/2 0:0:0'\n", '        require(_onlineTime >= now); // 上线时间需要大于当前时间\n', '        require(_ethSaver != address(0));\n', '\n', '        onlineTime = _onlineTime;\n', '        ethSaver = _ethSaver;\n', '\n', '        isRunning = true;\n', '\n', '        // ---------------------------\n', '        // 每天的时段配置，共6个时段\n', '        //\n', '        // 通用规则：\n', '        // 1、首拍后，每天18:30-22:00为竞拍时间\n', '        // ---------------------------\n', '        uint8[6] memory tvUseStartTimes = [0, 10, 12, 18, 20, 22]; // 电视使用开始时段\n', '        uint8[6] memory tvUseEndTimes = [2, 12, 14, 20, 22, 24]; // 电视使用结束时段\n', '\n', '        for (uint8 i=0; i<6; i++) {\n', '            dayConfigs[i].bidStartValue = 0.1 ether; // 正常起拍价0.1ETH\n', '            dayConfigs[i].bidStartTime = 18 hours + 30 minutes - 1 days; // 一天前晚上 18:30起拍\n', '            dayConfigs[i].bidEndTime = 22 hours - 1 days; // 一天前晚上 22:00 结束拍卖\n', '\n', '            dayConfigs[i].tvUseStartTime = uint(tvUseStartTimes[i]) * 1 hours;\n', '            dayConfigs[i].tvUseEndTime = uint(tvUseEndTimes[i]) * 1 hours;\n', '\n', '            dayConfigs[i].isPrivate = false; // 正常都是竞拍，非私募\n', '        }\n', '\n', '        // ---------------------------\n', '        // 特殊时段配置\n', '        // ---------------------------\n', '\n', '        // 首拍，第1天的6个时段都是首拍，拍卖时间从两天前的18:30到一天前的22:00\n', '        for(uint8 p=0; p<6; p++) {\n', '            specialConfigs[p].special = true;\n', '            \n', '            specialConfigs[p].bidStartValue = 0.1 ether; // 起拍价0.1ETH\n', '            specialConfigs[p].bidStartTime = 18 hours + 30 minutes - 2 days; // 两天前的18:30\n', '            specialConfigs[p].bidEndTime = 22 hours - 1 days; // 一天前的22:00\n', '            specialConfigs[p].isPrivate = false; // 非私募\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取区块的时间戳，单位s\n', '     */\n', '    function time() constant internal returns (uint) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * 获取某个时间是上线第几天，第1天返回1，上线之前返回0\n', '     * \n', '     * @param timestamp 时间戳\n', '     */\n', '    function dayFor(uint timestamp) constant public returns (uint) {\n', '        return timestamp < onlineTime\n', '            ? 0\n', '            : (timestamp.sub(onlineTime) / 1 days) + 1;\n', '    }\n', '\n', '    /**\n', '     * 获取当前时间是今天的第几个时段，第一个时段返回1，没有匹配的返回0\n', '     *\n', '     * @param timestamp 时间戳\n', '     */\n', '    function numberFor(uint timestamp) constant public returns (uint8) {\n', '        if (timestamp >= onlineTime) {\n', '            uint current = timestamp.sub(onlineTime) % 1 days;\n', '\n', '            for(uint8 i=0; i<6; i++) {\n', '                if (dayConfigs[i].tvUseStartTime<=current && current<dayConfigs[i].tvUseEndTime) {\n', '                    return (i + 1);\n', '                }\n', '            }\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * 创建时段币\n', '     */\n', '    function createNTVU() public onlyOwner {\n', '        require(isRunning);\n', '\n', '        uint8 number = totalTimeRange++;\n', '        uint8 day = number / 6;\n', '        uint8 num = number % 6;\n', '\n', '        Base.NTVUConfig memory cfg = dayConfigs[num]; // 读取每天时段的默认配置\n', '\n', '        // 如果有特殊配置则覆盖\n', '        Base.NTVUConfig memory expCfg = specialConfigs[number];\n', '        if (expCfg.special) {\n', '            cfg.bidStartValue = expCfg.bidStartValue;\n', '            cfg.bidStartTime = expCfg.bidStartTime;\n', '            cfg.bidEndTime = expCfg.bidEndTime;\n', '            cfg.isPrivate = expCfg.isPrivate;\n', '        }\n', '\n', '        // 根据上线时间计算具体的时段时间\n', '        uint bidStartTime = uint(int(onlineTime) + day * 24 hours + cfg.bidStartTime);\n', '        uint bidEndTime = uint(int(onlineTime) + day * 24 hours + cfg.bidEndTime);\n', '        uint tvUseStartTime = onlineTime + day * 24 hours + cfg.tvUseStartTime;\n', '        uint tvUseEndTime = onlineTime + day * 24 hours + cfg.tvUseEndTime;\n', '\n', '        timeRanges[number] = new NTVUToken(number, cfg.bidStartValue, bidStartTime, bidEndTime, tvUseStartTime, tvUseEndTime, cfg.isPrivate, defaultText, ethSaver);\n', '    }\n', '\n', '    /**\n', '     * 查询所有时段\n', '     */\n', '    function queryNTVUs(uint startIndex, uint count) public view returns(address[]){\n', '        startIndex = (startIndex < totalTimeRange)? startIndex : totalTimeRange;\n', '        count = (startIndex + count < totalTimeRange) ? count : (totalTimeRange - startIndex);\n', '\n', '        address[] memory result = new address[](count);\n', '        for(uint i=0; i<count; i++) {\n', '            result[i] = timeRanges[startIndex + i];\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * 查询当前正在播放的时段\n', '     */\n', '    function playingNTVU() public view returns(address){\n', '        uint day = dayFor(time());\n', '        uint8 num = numberFor(time());\n', '\n', '        if (day>0 && (num>0 && num<=6)) {\n', '            day = day - 1;\n', '            num = num - 1;\n', '\n', '            return timeRanges[day * 6 + uint(num)];\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 审核文本\n', '     */\n', '    function auditNTVUText(uint8 index, uint8 status, string _text) public onlyOwner {\n', '        require(isRunning); // 合约启动后才能审核\n', '        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\n', '        require(status==1 || (status==2 && bytes(_text).length>0 && bytes(_text).length <= 90)); // 审核不通，需要配置文本\n', '\n', '        address ntvu = timeRanges[index];\n', '        assert(ntvu != address(0));\n', '\n', '        NTVUToken ntvuToken = NTVUToken(ntvu);\n', '        ntvuToken.auditText(status, _text);\n', '\n', '        var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\n', '        var auditedText = StringUtils.fromBytes96(b1, b2, b3, len);\n', '        OnTV(ntvuToken, ntvuToken.maxBidAccount(), auditedText); // 审核后的文本记录到日志中\n', '    }\n', '\n', '    /**\n', '     * 获取电视播放文本\n', '     */\n', '    function getText() public view returns(string){\n', '        address playing = playingNTVU();\n', '\n', '        if (playing != address(0)) {\n', '            NTVUToken ntvuToken = NTVUToken(playing);\n', '\n', '            var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\n', '            return StringUtils.fromBytes96(b1, b2, b3, len);\n', '        } else {\n', '            return ""; // 当前不是播放时段，返回空文本\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 获取竞拍状态\n', '     */\n', '    function status() public view returns(uint8) {\n', '        if (!isRunning) {\n', '            return 0; // 未启动拍卖\n', '        } else if (time() < onlineTime) {\n', '            return 1; // 未到首播时间\n', '        } else {\n', '            if (totalTimeRange == 0) {\n', '                return 2; // 没有创建播放时段\n', '            } else {\n', '                if (time() < NTVUToken(timeRanges[totalTimeRange - 1]).tvUseEndTime()) {\n', '                    return 3; // 整个竞拍活动进行中\n', '                } else {\n', '                    return 4; // 整个竞拍活动已结束\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 获取总的竞拍人数\n', '     */\n', '    function totalAuctorCount() public view returns(uint32) {\n', '        uint32 total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).auctorCount();\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取总的竞拍次数\n', '     */\n', '    function totalBidCount() public view returns(uint32) {\n', '        uint32 total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).bidCount();\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取总的出价ETH\n', '     */\n', '    function totalBidEth() public view returns(uint) {\n', '        uint total = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            total += NTVUToken(timeRanges[i]).balance;\n', '        }\n', '\n', '        total += this.balance;\n', '        total += ethSaver.balance;\n', '\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * 获取历史出价最高的ETH\n', '     */\n', '    function maxBidEth() public view returns(uint) {\n', '        uint maxETH = 0;\n', '\n', '        for(uint8 i=0; i<totalTimeRange; i++) {\n', '            uint val = NTVUToken(timeRanges[i]).maxBidValue();\n', '            maxETH =  (val > maxETH) ? val : maxETH;\n', '        }\n', '\n', '        return maxETH;\n', '    }\n', '\n', '    /**\n', '     * 提取当前合约的ETH到ethSaver\n', '     */\n', '    function reclaimEther() public onlyOwner {\n', '        require(isRunning);\n', '\n', '        ethSaver.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * 提取时段币的ETH到ethSaver\n', '     */\n', '    function reclaimNtvuEther(uint8 index) public onlyOwner {\n', '        require(isRunning);\n', '        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\n', '\n', '        NTVUToken(timeRanges[index]).reclaimEther();\n', '    }\n', '\n', '    /**\n', '     * 接收ETH\n', '     */\n', '    function() payable external {}\n', '}']
