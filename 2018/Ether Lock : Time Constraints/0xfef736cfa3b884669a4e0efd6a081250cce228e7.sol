['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Bob {\n', '  using SafeMath for uint;\n', '\n', '  enum DepositState {\n', '    Uninitialized,\n', '    BobMadeDeposit,\n', '    AliceClaimedDeposit,\n', '    BobClaimedDeposit\n', '  }\n', '\n', '  enum PaymentState {\n', '    Uninitialized,\n', '    BobMadePayment,\n', '    AliceClaimedPayment,\n', '    BobClaimedPayment\n', '  }\n', '\n', '  struct BobDeposit {\n', '    bytes20 depositHash;\n', '    uint64 lockTime;\n', '    DepositState state;\n', '  }\n', '\n', '  struct BobPayment {\n', '    bytes20 paymentHash;\n', '    uint64 lockTime;\n', '    PaymentState state;\n', '  }\n', '\n', '  mapping (bytes32 => BobDeposit) public deposits;\n', '\n', '  mapping (bytes32 => BobPayment) public payments;\n', '\n', '  function Bob() {\n', '  }\n', '\n', '  function bobMakesEthDeposit(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && deposits[_txId].state == DepositState.Uninitialized);\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      address(0),\n', '      msg.value\n', '    );\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Deposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _secret,\n', '    address _alice,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      ripemd160(sha256(_secret)),\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(depositHash == deposits[_txId].depositHash && now < deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.BobClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _bob,\n', '    address _tokenAddress,\n', '    bytes20 _secretHash\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(\n', '      msg.sender,\n', '      _bob,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(depositHash == deposits[_txId].depositHash && now >= deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.AliceClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function bobMakesEthPayment(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && payments[_txId].state == PaymentState.Uninitialized);\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      address(0),\n', '      msg.value\n', '    );\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Payment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    require(\n', '      _alice != 0x0 &&\n', '      _amount > 0 &&\n', '      payments[_txId].state == PaymentState.Uninitialized &&\n', '      _tokenAddress != 0x0\n', '    );\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    address _tokenAddress,\n', '    bytes20 _secretHash\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(now >= payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.BobClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _secret,\n', '    address _bob,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(\n', '      msg.sender,\n', '      _bob,\n', '      ripemd160(sha256(_secret)),\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(now < payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.AliceClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Bob {\n', '  using SafeMath for uint;\n', '\n', '  enum DepositState {\n', '    Uninitialized,\n', '    BobMadeDeposit,\n', '    AliceClaimedDeposit,\n', '    BobClaimedDeposit\n', '  }\n', '\n', '  enum PaymentState {\n', '    Uninitialized,\n', '    BobMadePayment,\n', '    AliceClaimedPayment,\n', '    BobClaimedPayment\n', '  }\n', '\n', '  struct BobDeposit {\n', '    bytes20 depositHash;\n', '    uint64 lockTime;\n', '    DepositState state;\n', '  }\n', '\n', '  struct BobPayment {\n', '    bytes20 paymentHash;\n', '    uint64 lockTime;\n', '    PaymentState state;\n', '  }\n', '\n', '  mapping (bytes32 => BobDeposit) public deposits;\n', '\n', '  mapping (bytes32 => BobPayment) public payments;\n', '\n', '  function Bob() {\n', '  }\n', '\n', '  function bobMakesEthDeposit(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && deposits[_txId].state == DepositState.Uninitialized);\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      address(0),\n', '      msg.value\n', '    );\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Deposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    deposits[_txId] = BobDeposit(\n', '      depositHash,\n', '      _lockTime,\n', '      DepositState.BobMadeDeposit\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _secret,\n', '    address _alice,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      ripemd160(sha256(_secret)),\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(depositHash == deposits[_txId].depositHash && now < deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.BobClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsDeposit(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _bob,\n', '    address _tokenAddress,\n', '    bytes20 _secretHash\n', '  ) external {\n', '    require(deposits[_txId].state == DepositState.BobMadeDeposit);\n', '    bytes20 depositHash = ripemd160(\n', '      msg.sender,\n', '      _bob,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(depositHash == deposits[_txId].depositHash && now >= deposits[_txId].lockTime);\n', '    deposits[_txId].state = DepositState.AliceClaimedDeposit;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function bobMakesEthPayment(\n', '    bytes32 _txId,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    uint64 _lockTime\n', '  ) external payable {\n', '    require(_alice != 0x0 && msg.value > 0 && payments[_txId].state == PaymentState.Uninitialized);\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      address(0),\n', '      msg.value\n', '    );\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '  }\n', '\n', '  function bobMakesErc20Payment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    bytes20 _secretHash,\n', '    address _tokenAddress,\n', '    uint64 _lockTime\n', '  ) external {\n', '    require(\n', '      _alice != 0x0 &&\n', '      _amount > 0 &&\n', '      payments[_txId].state == PaymentState.Uninitialized &&\n', '      _tokenAddress != 0x0\n', '    );\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    payments[_txId] = BobPayment(\n', '      paymentHash,\n', '      _lockTime,\n', '      PaymentState.BobMadePayment\n', '    );\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transferFrom(msg.sender, address(this), _amount));\n', '  }\n', '\n', '  function bobClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    address _alice,\n', '    address _tokenAddress,\n', '    bytes20 _secretHash\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(\n', '      _alice,\n', '      msg.sender,\n', '      _secretHash,\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(now >= payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.BobClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '\n', '  function aliceClaimsPayment(\n', '    bytes32 _txId,\n', '    uint256 _amount,\n', '    bytes32 _secret,\n', '    address _bob,\n', '    address _tokenAddress\n', '  ) external {\n', '    require(payments[_txId].state == PaymentState.BobMadePayment);\n', '    bytes20 paymentHash = ripemd160(\n', '      msg.sender,\n', '      _bob,\n', '      ripemd160(sha256(_secret)),\n', '      _tokenAddress,\n', '      _amount\n', '    );\n', '    require(now < payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);\n', '    payments[_txId].state = PaymentState.AliceClaimedPayment;\n', '    if (_tokenAddress == 0x0) {\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      ERC20 token = ERC20(_tokenAddress);\n', '      assert(token.transfer(msg.sender, _amount));\n', '    }\n', '  }\n', '}']
