['pragma solidity ^0.4.24;\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title PLAYToken contract\n', '/// @notice defines standard ERC-20 functionality.\n', '//-----------------------------------------------------------------------------\n', 'contract PLAYToken {\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when ownership of PLAY changes by any mechanism. Also emits\n', "    ///  when tokens are destroyed ('to' == 0).\n", '    //-------------------------------------------------------------------------\n', '    event Transfer (address indexed from, address indexed to, uint tokens);\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when an approved spender is changed or reaffirmed, or if\n', '    ///  the allowance amount changes. The zero address indicates there is no\n', '    ///  approved address.\n', '    //-------------------------------------------------------------------------\n', '    event Approval (\n', '        address indexed tokenOwner, \n', '        address indexed spender, \n', '        uint tokens\n', '    );\n', '    \n', '    // total number of tokens in circulation (in pWei).\n', '    //  Burning tokens reduces this amount\n', '    uint totalPLAY = 1000000000 * 10**18;    // one billion\n', '    // the token balances of all token holders\n', '    mapping (address => uint) playBalances;\n', '    // approved spenders and allowances of all token holders\n', '    mapping (address => mapping (address => uint)) allowances;\n', '\n', '    constructor() public {\n', '        playBalances[msg.sender] = totalPLAY;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Throws if parameter is zero\n', '    //-------------------------------------------------------------------------\n', '    modifier notZero(uint param) {\n', '        require (param != 0, "Parameter cannot be zero");\n', '        _;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------\n', '    /// @dev Throws if tokenOwner has insufficient PLAY balance\n', '    //-------------------------------------------------------------------------\n', '    modifier sufficientFunds(address tokenOwner, uint tokens) {\n', '        require (playBalances[tokenOwner] >= tokens, "Insufficient balance");\n', '        _;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------\n', '    /// @dev Throws if spender has insufficient allowance from owner\n', '    //-------------------------------------------------------------------------\n', '    modifier sufficientAllowance(address owner, address spender, uint tokens) {\n', '        require (\n', '            allowances[owner][spender] >= tokens, \n', '            "Insufficient allowance"\n', '        );\n', '        _;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY to `to`.\n', '    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\n', '    ///  insufficient balance for transfer. Throws if `to` is the zero address.\n', '    /// @param to The address to where PLAY is being sent.\n', '    /// @param tokens The number of tokens to send (in pWei).\n', '    /// @return True upon successful transfer. Will throw if unsuccessful.\n', '    //-------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) \n', '        public \n', '        notZero(uint(to)) \n', '        notZero(tokens)\n', '        sufficientFunds(msg.sender, tokens)\n', '        returns(bool) \n', '    {\n', '        // subtract amount from sender\n', '        playBalances[msg.sender] -= tokens;\n', '        // add amount to token receiver\n', '        playBalances[to] += tokens;\n', '        // emit transfer event\n', '        emit Transfer(msg.sender, to, tokens);\n', '        \n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY from\n', '    ///  `from` to `to`.\n', '    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\n', '    ///  insufficient allowance for transfer. Throws if `from` has\n', '    ///  insufficient balance for transfer. Throws if `to` is the zero address.\n', '    /// @param from The address from where PLAY is being sent. Sender must be\n', '    ///  an approved spender.\n', '    /// @param to The token owner whose PLAY is being sent.\n', '    /// @param tokens The number of tokens to send (in pWei).\n', '    /// @return True upon successful transfer. Will throw if unsuccessful.\n', '    //-------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) \n', '        public \n', '        notZero(uint(to)) \n', '        notZero(tokens) \n', '        sufficientFunds(from, tokens)\n', '        sufficientAllowance(from, msg.sender, tokens)\n', '        returns(bool) \n', '    {\n', "        // subtract amount from sender's allowance\n", '        allowances[from][msg.sender] -= tokens;\n', '        // subtract amount from token owner\n', '        playBalances[from] -= tokens;\n', '        // add amount to token receiver\n', '        playBalances[to] += tokens;\n', '        // emit transfer event\n', '        emit Transfer(from, to, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Allow `spender` to withdraw from your account, multiple times,\n', '    ///  up to `(tokens/1000000000000000000).fixed(0,18)` PLAY. Calling this\n', '    ///  function overwrites the previous allowance of spender.\n', '    /// @dev Emits approval event\n', '    /// @param spender The address to authorize as a spender\n', '    /// @param tokens The new token allowance of spender (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) external returns(bool) {\n', "        // set the spender's allowance to token amount\n", '        allowances[msg.sender][spender] = tokens;\n', '        // emit approval event\n', '        emit Approval(msg.sender, spender, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the total number of tokens in circulation.\n', '    /// @return Total tokens tracked by this contract.\n', '    //-------------------------------------------------------------------------\n', '    function totalSupply() external view returns (uint) { return totalPLAY; }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the number of PLAY tokens owned by `tokenOwner`.\n', '    /// @dev Throws if trying to query the zero address.\n', '    /// @param tokenOwner The PLAY token owner.\n', '    /// @return The number of PLAY tokens owned by `tokenOwner` (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) \n', '        public \n', '        view \n', '        notZero(uint(tokenOwner))\n', '        returns(uint)\n', '    {\n', '        return playBalances[tokenOwner];\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the remaining allowance of `spender` for `tokenOwner`.\n', '    /// @param tokenOwner The PLAY token owner.\n', '    /// @param spender The approved spender address.\n', '    /// @return The remaining allowance of `spender` for `tokenOwner`.\n', '    //-------------------------------------------------------------------------\n', '    function allowance(\n', '        address tokenOwner, \n', '        address spender\n', '    ) public view returns (uint) {\n', '        return allowances[tokenOwner][spender];\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', "    /// @notice Get the token's name.\n", "    /// @return The token's name as a string\n", '    //-------------------------------------------------------------------------\n', '    function name() external pure returns (string) { \n', '        return "PLAY Network Token"; \n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', "    /// @notice Get the token's ticker symbol.\n", "    /// @return The token's ticker symbol as a string\n", '    //-------------------------------------------------------------------------\n', '    function symbol() external pure returns (string) { return "PLAY"; }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the number of allowed decimal places for the token.\n', '    /// @return The number of allowed decimal places for the token.\n', '    //-------------------------------------------------------------------------\n', '    function decimals() external pure returns (uint8) { return 18; }\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title BurnToken contract\n', '/// @notice defines token burning functionality.\n', '//-----------------------------------------------------------------------------\n', 'contract BurnToken is PLAYToken {\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Destroy `(tokens/1000000000000000000).fixed(0,18)` PLAY. These\n', '    ///  tokens cannot be viewed or recovered.\n', '    /// @dev Throws if amount to burn is zero. Throws if sender has\n', '    ///  insufficient balance to burn. Emits transfer event.\n', '    /// @param tokens The number of tokens to burn (in pWei). \n', '    /// @return True upon successful burn. Will throw if unsuccessful.\n', '    //-------------------------------------------------------------------------\n', '    function burn(uint tokens)\n', '        external \n', '        notZero(tokens) \n', '        sufficientFunds(msg.sender, tokens)\n', '        returns(bool) \n', '    {\n', '        // subtract amount from token owner\n', '        playBalances[msg.sender] -= tokens;\n', '        // subtract amount from total supply\n', '        totalPLAY -= tokens;\n', '        // emit transfer event\n', '        emit Transfer(msg.sender, address(0), tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Destroy `(tokens/1000000000000000000).fixed(0,18)` PLAY from \n', '    /// `from`. These tokens cannot be viewed or recovered.\n', '    /// @dev Throws if amount to burn is zero. Throws if sender has\n', '    ///  insufficient allowance to burn. Throws if `from` has insufficient\n', '    ///  balance to burn. Emits transfer event.\n', '    /// @param from The token owner whose PLAY is being burned. Sender must be\n', '    ///  an approved spender.\n', '    /// @param tokens The number of tokens to burn (in pWei).\n', '    /// @return True upon successful burn. Will throw if unsuccessful.\n', '    //-------------------------------------------------------------------------\n', '    function burnFrom(address from, uint tokens) \n', '        external \n', '        notZero(tokens) \n', '        sufficientFunds(from, tokens)\n', '        sufficientAllowance(from, msg.sender, tokens)\n', '        returns(bool) \n', '    {\n', "        // subtract amount from sender's allowance\n", '        allowances[from][msg.sender] -= tokens;\n', '        // subtract amount from token owner\n', '        playBalances[from] -= tokens;\n', '        // subtract amount from total supply\n', '        totalPLAY -= tokens;\n', '        // emit transfer event\n', '        emit Transfer(from, address(0), tokens);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title LockToken contract\n', '/// @notice defines token locking and unlocking functionality.\n', '//-----------------------------------------------------------------------------\n', 'contract LockToken is BurnToken {\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when PLAY tokens become locked for any number of years by\n', '    ///  any mechanism.\n', '    //-------------------------------------------------------------------------\n', '    event Lock (address indexed tokenOwner, uint tokens);\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when PLAY tokens become unlocked by any mechanism.\n', '    //-------------------------------------------------------------------------\n', '    event Unlock (address indexed tokenOwner, uint tokens);\n', '\n', '    // Unix Timestamp for 1-1-2018 at 00:00:00.\n', '    //  Used to calculate years since release.\n', '    uint constant FIRST_YEAR_TIMESTAMP = 1514764800;\n', '    // Tracks years since release. Starts at 0 and increments every 365 days.\n', '    uint public currentYear;\n', '    // Maximum number of years into the future locked tokens can be recovered.\n', '    uint public maximumLockYears = 10;\n', '    // Locked token balances by unlock year  \n', '    mapping (address => mapping(uint => uint)) tokensLockedUntilYear;\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Lock `(tokens/1000000000000000000).fixed(0,18)` PLAY for\n', '    ///  `numberOfYears` years.\n', '    /// @dev Throws if amount to lock is zero. Throws if numberOfYears is zero\n', '    ///  or greater than maximumLockYears. Throws if `msg.sender` has \n', '    ///  insufficient balance to lock.\n', '    /// @param numberOfYears The number of years the tokens will be locked.\n', '    /// @param tokens The number of tokens to lock (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function lock(uint numberOfYears, uint tokens) \n', '        public \n', '        notZero(tokens)\n', '        sufficientFunds(msg.sender, tokens)\n', '        returns(bool)\n', '    {\n', '        // number of years must be a valid amount.\n', '        require (\n', '            numberOfYears > 0 && numberOfYears <= maximumLockYears,\n', '            "Invalid number of years"\n', '        );\n', '\n', '        // subtract amount from sender\n', '        playBalances[msg.sender] -= tokens;\n', "        // add amount to sender's locked token balance\n", '        tokensLockedUntilYear[msg.sender][currentYear+numberOfYears] += tokens;\n', '        // emit lock event\n', '        emit Lock(msg.sender, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Lock `(tokens/1000000000000000000).fixed(0,18)` PLAY from \n', '    ///  `from` for `numberOfYears` years.\n', '    /// @dev Throws if amount to lock is zero. Throws if numberOfYears is zero\n', '    ///  or greater than maximumLockYears. Throws if `msg.sender` has\n', '    ///  insufficient allowance to lock. Throws if `from` has insufficient\n', '    ///  balance to lock.\n', '    /// @param from The token owner whose PLAY is being locked. Sender must be\n', '    ///  an approved spender.\n', '    /// @param numberOfYears The number of years the tokens will be locked.\n', '    /// @param tokens The number of tokens to lock (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function lockFrom(address from, uint numberOfYears, uint tokens) \n', '        external\n', '        notZero(tokens)\n', '        sufficientFunds(from, tokens)\n', '        sufficientAllowance(from, msg.sender, tokens)\n', '        returns(bool) \n', '    {\n', '        // number of years must be a valid amount.\n', '        require (\n', '            numberOfYears > 0 && numberOfYears <= maximumLockYears,\n', '            "Invalid number of years"\n', '        );\n', '\n', "        // subtract amount from sender's allowance\n", '        allowances[from][msg.sender] -= tokens;\n', "        // subtract amount from token owner's balance\n", '        playBalances[from] -= tokens;\n', "        // add amount to token owner's locked token balance\n", '        tokensLockedUntilYear[from][currentYear + numberOfYears] += tokens;\n', '        // emit lock event\n', '        emit Lock(from, tokens);\n', '        \n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY to `to`,\n', '    ///  then lock for `numberOfYears` years.\n', '    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\n', '    ///  insufficient balance for transfer. Throws if `to` is the zero\n', '    ///  address. Emits transfer and lock events.\n', '    /// @param to The address to where PLAY is being sent and locked.\n', '    /// @param numberOfYears The number of years the tokens will be locked.\n', '    /// @param tokens The number of tokens to send (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function transferAndLock(\n', '        address to, \n', '        uint numberOfYears, \n', '        uint tokens\n', '    ) external {\n', '        // Transfer will fail if sender\'s balance is too low or "to" is zero\n', '        transfer(to, tokens);\n', '\n', "        // subtract amount from token receiver's balance\n", '        playBalances[to] -= tokens;\n', "        // add amount to token receiver's locked token balance\n", '        tokensLockedUntilYear[to][currentYear + numberOfYears] += tokens;\n', '        // emit lock event\n', '        emit Lock(msg.sender, tokens);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY from \n', '    ///  `from` to `to`, then lock for `numberOfYears` years.\n', '    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\n', '    ///  insufficient allowance for transfer. Throws if `from` has \n', '    ///  insufficient balance for transfer. Throws if `to` is the zero\n', '    ///  address. Emits transfer and lock events.\n', '    /// @param from The token owner whose PLAY is being sent. Sender must be\n', '    ///  an approved spender.\n', '    /// @param to The address to where PLAY is being sent and locked.\n', '    /// @param tokens The number of tokens to send (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function transferFromAndLock(\n', '        address from, \n', '        address to, \n', '        uint numberOfYears, \n', '        uint tokens\n', '    ) external {\n', "        // Initiate transfer. Transfer will fail if sender's allowance is too\n", '        //  low, token owner\'s balance is too low, or "to" is zero\n', '        transferFrom(from, to, tokens);\n', '\n', "        // subtract amount from token owner's balance\n", '        playBalances[to] -= tokens;\n', "        // add amount to token receiver's locked token balance\n", '        tokensLockedUntilYear[to][currentYear + numberOfYears] += tokens;\n', '        // emit lock event\n', '        emit Lock(msg.sender, tokens);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Unlock all qualifying tokens for `tokenOwner`. Sender must \n', '    ///  either be tokenOwner or an approved address.\n', '    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\n', '    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\n', '    /// @param tokenOwner The token owner whose tokens will unlock.\n', '    //-------------------------------------------------------------------------\n', '    function unlockAll(address tokenOwner) external {\n', '        // create local variable for token owner\n', '        address addressToUnlock = tokenOwner;\n', '        // if tokenOwner parameter is empty, set tokenOwner to sender\n', '        if (addressToUnlock == address(0)) {\n', '            addressToUnlock = msg.sender;\n', '        }\n', '        // sender must either be tokenOwner or an approved address\n', '        if (msg.sender != addressToUnlock) {\n', '            require (\n', '                allowances[addressToUnlock][msg.sender] > 0,\n', '                "Not authorized to unlock for this address"\n', '            );\n', '        }\n', '\n', '        // create local variable for unlock total\n', '        uint tokensToUnlock;\n', '        // check each year starting from 1 year after release\n', '        for (uint i = 1; i <= currentYear; ++i) {\n', '            // add qualifying tokens to tokens to unlock variable\n', '            tokensToUnlock += tokensLockedUntilYear[addressToUnlock][i];\n', '            // set locked token balance of year i to 0 \n', '            tokensLockedUntilYear[addressToUnlock][i] = 0;\n', '        }\n', "        // add qualifying tokens back to token owner's account balance\n", '        playBalances[addressToUnlock] += tokensToUnlock;\n', '        // emit unlock event\n', '        emit Unlock (addressToUnlock, tokensToUnlock);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Unlock all tokens locked until `year` years since 2018 for \n', '    ///  `tokenOwner`. Sender must be tokenOwner or an approved address.\n', '    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\n', '    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\n', '    /// @param tokenOwner The token owner whose tokens will unlock.\n', '    /// @param year Number of years since 2018 the tokens were locked until.\n', '    //-------------------------------------------------------------------------\n', '    function unlockByYear(address tokenOwner, uint year) external {\n', '        // create local variable for token owner\n', '        address addressToUnlock = tokenOwner;\n', '        // if tokenOwner parameter is empty, set tokenOwner to sender\n', '        if (addressToUnlock == address(0)) {\n', '            addressToUnlock = msg.sender;\n', '        }\n', '        // sender must either be tokenOwner or an approved address\n', '        if (msg.sender != addressToUnlock) {\n', '            require (\n', '                allowances[addressToUnlock][msg.sender] > 0,\n', '                "Not authorized to unlock for this address"\n', '            );\n', '        }\n', '        // year of locked tokens must be less than or equal to current year\n', '        require (\n', '            currentYear >= year,\n', '            "Tokens from this year cannot be unlocked yet"\n', '        );\n', '        // create local variable for unlock amount\n', '        uint tokensToUnlock = tokensLockedUntilYear[addressToUnlock][year];\n', '        // set locked token balance of year to 0\n', '        tokensLockedUntilYear[addressToUnlock][year] = 0;\n', "        // add qualifying tokens back to token owner's account balance\n", '        playBalances[addressToUnlock] += tokensToUnlock;\n', '        // emit unlock event\n', '        emit Unlock(addressToUnlock, tokensToUnlock);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Update the current year.\n', '    /// @dev Throws if less than 365 days has passed since currentYear.\n', '    //-------------------------------------------------------------------------\n', '    function updateYearsSinceRelease() external {\n', '        // check if years since first year is greater than the currentYear\n', '        uint secondsSinceRelease = block.timestamp - FIRST_YEAR_TIMESTAMP;\n', '        require (\n', '            currentYear < secondsSinceRelease / (365 * 1 days),\n', '            "Cannot update year yet"\n', '        );\n', '        // increment years since release\n', '        ++currentYear;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the total locked token holdings of `tokenOwner`.\n', '    /// @param tokenOwner The locked token owner.\n', '    /// @return Total locked token holdings of an address.\n', '    //-------------------------------------------------------------------------\n', '    function getTotalLockedTokens(\n', '        address tokenOwner\n', '    ) public view returns (uint lockedTokens) {\n', '        for (uint i = 1; i < currentYear + maximumLockYears; ++i) {\n', '            lockedTokens += tokensLockedUntilYear[tokenOwner][i];\n', '        }\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the locked token holdings of `tokenOwner` unlockable in\n', '    ///  `(year + 2018)`.\n', '    /// @param tokenOwner The locked token owner.\n', '    /// @param year Years since 2018 the tokens are locked until.\n', '    /// @return Locked token holdings of an address for `(year + 2018)`.\n', '    //-------------------------------------------------------------------------\n', '    function getLockedTokensByYear(\n', '        address tokenOwner, \n', '        uint year\n', '    ) external view returns (uint) {\n', '        return tokensLockedUntilYear[tokenOwner][year];\n', '    }\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic \n', '///  authorization control functions, this simplifies the implementation of\n', '///  "user permissions".\n', '//-----------------------------------------------------------------------------\n', 'contract Ownable {\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when owner address changes by any mechanism.\n', '    //-------------------------------------------------------------------------\n', '    event OwnershipTransfer (address previousOwner, address newOwner);\n', '    \n', '    // Wallet address that can sucessfully execute onlyOwner functions\n', '    address owner;\n', '    \n', '    //-------------------------------------------------------------------------\n', '    /// @dev Sets the owner of the contract to the sender account.\n', '    //-------------------------------------------------------------------------\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit OwnershipTransfer(address(0), owner);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Throws if called by any account other than `owner`.\n', '    //-------------------------------------------------------------------------\n', '    modifier onlyOwner() {\n', '        require(\n', '            msg.sender == owner,\n', '            "Function can only be called by contract owner"\n', '        );\n', '        _;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Transfer control of the contract to a newOwner.\n', '    /// @dev Throws if `_newOwner` is zero address.\n', '    /// @param _newOwner The address to transfer ownership to.\n', '    //-------------------------------------------------------------------------\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        // for safety, new owner parameter must not be 0\n', '        require (\n', '            _newOwner != address(0),\n', '            "New owner address cannot be zero"\n', '        );\n', '        // define local variable for old owner\n', '        address oldOwner = owner;\n', '        // set owner to new owner\n', '        owner = _newOwner;\n', '        // emit ownership transfer event\n', '        emit OwnershipTransfer(oldOwner, _newOwner);\n', '    }\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title TOY Token Interface - ERC721-compliant view functions \n', '//-----------------------------------------------------------------------------\n', 'interface ToyTokenOwnership {\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(\n', '        address _owner, \n', '        address _operator\n', '    ) external view returns (bool);\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title Color Token Contract\n', '/// @notice defines colored token registration, creation, and spending\n', '///  functionality.\n', '//-----------------------------------------------------------------------------\n', 'contract ColorToken is LockToken, Ownable {\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when a new colored token is created.\n', '    //-------------------------------------------------------------------------\n', '    event NewColor(address indexed creator, string name);\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when colored tokens are deposited into TOY Tokens. Color\n', '    ///  equivalent to PLAY.transfer().\n', '    //-------------------------------------------------------------------------\n', '    event DepositColor(\n', '        uint indexed to, \n', '        uint indexed colorIndex, \n', '        uint tokens\n', '    );\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @dev Emits when colored tokens are spent by any mechanism. Color\n', '    ///  equivalent to PLAY.burn().\n', '    //-------------------------------------------------------------------------\n', '    event SpendColor(\n', '        uint indexed from, \n', '        uint indexed color, \n', '        uint amount\n', '    );\n', '\n', '    // Colored token data\n', '    struct ColoredToken {\n', '        address creator;\n', '        string name;\n', '        mapping (uint => uint) balances;\n', '    }\n', '\n', '    // array containing all colored token data\n', '    ColoredToken[] coloredTokens;\n', '    // required locked tokens needed to register a color (in pWei)\n', '    uint public requiredLockedForColorRegistration = 10000 * 10**18;\n', '    // TOY Token contract to interface with\n', '    ToyTokenOwnership toy;\n', '    // UID value is 7 bytes. Max value is 2**56\n', '    uint constant UID_MAX = 0xFFFFFFFFFFFFFF;\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Set the address of the TOY Token interface to `toyAddress`.\n', '    /// @dev Throws if toyAddress is the zero address.\n', '    /// @param toyAddress The address of the TOY Token interface.\n', '    //-------------------------------------------------------------------------\n', '    function setToyTokenContractAddress (address toyAddress) \n', '        external \n', '        notZero(uint(toyAddress)) \n', '        onlyOwner\n', '    {\n', '        // initialize contract to toyAddress\n', '        toy = ToyTokenOwnership(toyAddress);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Set required total locked tokens to \n', '    ///  `(newAmount/1000000000000000000).fixed(0,18)`.\n', '    /// @dev Throws if the sender is not the contract owner. Throws if new\n', '    ///  amount is zero.\n', '    /// @param newAmount The new required locked token amount (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function setRequiredLockedForColorRegistration(uint newAmount) \n', '        external \n', '        onlyOwner\n', '        notZero(newAmount)\n', '    {\n', '        requiredLockedForColorRegistration = newAmount;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------\n', '    /// @notice Registers `colorName` as a new colored token. Must own\n', '    ///  `requiredLockedForColorReg` locked tokens as a requirement.\n', '    /// @dev Throws if `msg.sender` has insufficient locked tokens. Throws if\n', '    ///  colorName is empty or is longer than 32 characters.\n', '    /// @param colorName The name for the new colored token.\n', '    /// @return Index number for the new colored token.\n', '    //-------------------------------------------------------------------------\n', '    function registerNewColor(string colorName) external returns (uint) {\n', '        // sender must have enough locked tokens\n', '        require (\n', '            getTotalLockedTokens(msg.sender) >= requiredLockedForColorRegistration,\n', '            "Insufficient locked tokens"\n', '        );\n', '        // colorName must be a valid length\n', '        require (\n', '            bytes(colorName).length > 0 && bytes(colorName).length < 32,\n', '            "Invalid color name length"\n', '        );\n', '        // push new colored token to colored token array and store the index\n', '        uint index = coloredTokens.push(ColoredToken(msg.sender, colorName));\n', '        return index;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Locks `(tokens/1000000000000000000).fixed(0,18)` PLAY tokens\n', '    ///  for 2 years, then deposits the same number of colored tokens with \n', '    ///  index `colorIndex` into TOY Token #`uid`.\n', '    /// @dev Throws if tokens to deposit is zero. Throws if colorIndex is\n', '    ///  greater than number of colored tokens. Throws if `msg.sender` has\n', '    ///  insufficient balance to lock. Throws if `uid` is greater than\n', '    ///  maximum UID value. Throws if token does not have an owner. Throws if\n', '    ///  sender is not the creator of the colored token.\n', '    /// @param to The Unique Identifier of the TOY Token receiving tokens.\n', '    /// @param colorIndex The index of the color to spend.\n', '    /// @param tokens The number of colored tokens to spend (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function deposit (uint colorIndex, uint to, uint tokens)\n', '        external \n', '        notZero(tokens)\n', '    {\n', '        // colorIndex must be valid color\n', '        require (colorIndex < coloredTokens.length, "Invalid color index");\n', '        // sender must be colored token creator\n', '        require (\n', '            msg.sender == coloredTokens[colorIndex].creator,\n', '            "Not authorized to deposit this color"\n', '        );\n', '        // uid must be a valid UID\n', '        require (to < UID_MAX, "Invalid UID");\n', '        // If TOY Token #uid is not owned, it does not exist yet.\n', '        require(toy.ownerOf(to) != address(0), "TOY Token does not exist");\n', '        \n', "        // Initiate lock. Fails if sender's balance is too low.\n", '        lock(2, tokens);\n', '\n', '        // add tokens to TOY Token #UID\n', '        coloredTokens[colorIndex].balances[to] += tokens;\n', '        // emit color transfer event\n', '        emit DepositColor(to, colorIndex, tokens);\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Locks `(tokens/1000000000000000000).fixed(0,18)` PLAY tokens\n', '    ///  for 2 years, then deposits the same number of colored tokens with \n', '    ///  index `colorIndex` into multiple TOY Tokens.\n', '    /// @dev Throws if tokens to deposit is zero. Throws if colorIndex is\n', '    ///  greater than number of colored tokens. Throws if `msg.sender` has\n', '    ///  insufficient balance to lock. Throws if `uid` is greater than\n', '    ///  maximum UID value. Throws if any token does not have an owner. Throws\n', '    ///  if sender is not the creator of the colored token.\n', '    /// @param to The Unique Identifier of the TOY Token receiving tokens.\n', '    /// @param colorIndex The index of the color to spend.\n', '    /// @param tokens The number of colored tokens to spend (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function depositBulk (uint colorIndex, uint[] to, uint tokens)\n', '        external \n', '        notZero(tokens)\n', '    {\n', '        // colorIndex must be valid color\n', '        require (colorIndex < coloredTokens.length, "Invalid color index");\n', '        // sender must be colored token creator\n', '        require (\n', '            msg.sender == coloredTokens[colorIndex].creator,\n', '            "Not authorized to deposit this color"\n', '        );\n', '\n', "        // Initiate lock. Fails if sender's balance is too low.\n", '        lock(2, tokens * to.length);\n', '\n', '        for(uint i = 0; i < to.length; ++i){\n', '            // uid must be a valid UID\n', '            require (to[i] < UID_MAX, "Invalid UID");\n', '            // If TOY Token #uid is not owned, it does not exist yet.\n', '            require(toy.ownerOf(to[i]) != address(0), "TOY Token does not exist");\n', '\n', '            // add tokens to TOY Token #UID\n', '            coloredTokens[colorIndex].balances[to[i]] += tokens;\n', '            // emit color transfer event\n', '            emit DepositColor(to[i], colorIndex, tokens);\n', '        }\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Spend `(tokens/1000000000000000000).fixed(0,18)` colored \n', '    ///  tokens with index `colorIndex`.\n', '    /// @dev Throws if tokens to spend is zero. Throws if colorIndex is\n', '    ///  greater than number of colored tokens. Throws if `msg.sender` has\n', '    ///  insufficient balance to spend.\n', '    /// @param colorIndex The index of the color to spend.\n', '    /// @param from The UID of the TOY Token to spend from.\n', '    /// @param tokens The number of colored tokens to spend (in pWei).\n', '    /// @return True if spend successful. Throw if unsuccessful.\n', '    //-------------------------------------------------------------------------\n', '    function spend (uint colorIndex, uint from, uint tokens) \n', '        external \n', '        notZero(tokens)\n', '        returns(bool) \n', '    {\n', '        // colorIndex must be valid color\n', '        require (colorIndex < coloredTokens.length, "Invalid color index");\n', '        // sender must own TOY Token\n', '        require (\n', '            msg.sender == toy.ownerOf(from), \n', '            "Sender is not owner of TOY Token"\n', '        );\n', "        // token owner's balance must be enough to spend tokens\n", '        require (\n', '            coloredTokens[colorIndex].balances[from] >= tokens,\n', '            "Insufficient tokens to spend"\n', '        );\n', "        // deduct the tokens from the sender's balance\n", '        coloredTokens[colorIndex].balances[from] -= tokens;\n', '        // emit spend event\n', '        emit SpendColor(from, colorIndex, tokens);\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Spend `(tokens/1000000000000000000).fixed(0,18)` colored\n', '    ///  tokens with color index `index` from `from`.\n', '    /// @dev Throws if tokens to spend is zero. Throws if colorIndex is \n', '    ///  greater than number of colored tokens. Throws if `msg.sender` is not\n', "    ///  the colored token's creator. Throws if `from` has insufficient\n", '    ///  balance to spend.\n', '    /// @param colorIndex The index of the color to spend.\n', '    /// @param from The address whose colored tokens are being spent.\n', '    /// @param tokens The number of tokens to send (in pWei).\n', '    //-------------------------------------------------------------------------\n', '    function spendFrom(uint colorIndex, uint from, uint tokens)\n', '        external \n', '        notZero(tokens)\n', '        returns (bool) \n', '    {\n', '        // colorIndex must be valid color\n', '        require (colorIndex < coloredTokens.length, "Invalid color index");\n', '        // sender must be authorized address or operator for TOY Token\n', '        require (\n', '            msg.sender == toy.getApproved(from) ||\n', '            toy.isApprovedForAll(toy.ownerOf(from), msg.sender), \n', '            "Sender is not authorized operator for TOY Token"\n', '        );\n', "        // token owner's balance must be enough to spend tokens\n", '        require (\n', '            coloredTokens[colorIndex].balances[from] >= tokens,\n', '            "Insufficient balance to spend"\n', '        );\n', "        // deduct the tokens from token owner's balance\n", '        coloredTokens[colorIndex].balances[from] -= tokens;\n', '        // emit spend event\n', '        emit SpendColor(from, colorIndex, tokens);\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the number of colored tokens with color index `colorIndex`\n', '    ///  owned by TOY Token #`uid`.\n', '    /// @param uid The TOY Token with deposited color tokens.\n', '    /// @param colorIndex Index of the colored token to query.\n', '    /// @return The number of colored tokens with color index `colorIndex`\n', '    ///  owned by TOY Token #`uid`.\n', '    //-------------------------------------------------------------------------\n', '    function getColoredTokenBalance(uint uid, uint colorIndex) \n', '        external \n', '        view \n', '        returns(uint) \n', '    {\n', '        return coloredTokens[colorIndex].balances[uid];\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Count the number of colored token types\n', '    /// @return Number of colored token types\n', '    //-------------------------------------------------------------------------\n', '    function coloredTokenCount() external view returns (uint) {\n', '        return coloredTokens.length;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------\n', '    /// @notice Get the name and creator address of colored token with index\n', '    ///  `colorIndex`\n', '    /// @param colorIndex Index of the colored token to query.\n', '    /// @return The creator address and name of colored token.\n', '    //-------------------------------------------------------------------------\n', '    function getColoredToken(uint colorIndex) \n', '        external \n', '        view \n', '        returns(address, string)\n', '    {\n', '        return (\n', '            coloredTokens[colorIndex].creator, \n', '            coloredTokens[colorIndex].name\n', '        );\n', '    }\n', '}']