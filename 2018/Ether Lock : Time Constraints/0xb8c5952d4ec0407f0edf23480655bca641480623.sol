['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event LogNew(address indexed old, address indexed current);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        emit LogNew(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract IMoneyManager {\n', '    function payTo(address _participant, uint256 _revenue) payable public returns(bool);\n', '}\n', '\n', 'contract Game is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    // The address of the owner \n', '    address public ownerWallet;\n', '    // The address of the activator\n', '    mapping(address => bool) internal activator;\n', '    \n', '    // Constants\n', '    uint256 public constant BET = 10 finney; //0.01 ETH\n', '    uint8 public constant ODD = 1;\n', '    uint8 public constant EVEN = 2;\n', '    uint8 public constant noBets = 3;\n', '    uint256 public constant COMMISSION_PERCENTAGE = 10;\n', '    uint256 public constant END_DURATION_BETTING_BLOCK = 5520;\n', '    uint256 public constant TARGET_DURATION_BETTING_BLOCK = 5760;\n', '\t\n', '\tuint256 public constant CONTRACT_VERSION = 201805311200;\n', '    \n', '    // The address of the moneyManager\n', '    address public moneyManager;\n', '    \n', '    // Array which stores the target blocks\n', '    uint256[] targetBlocks;\n', '    \n', '    // Mappings\n', '    mapping(address => Participant) public participants;\n', '\n', '    mapping(uint256 => mapping(uint256 => uint256)) oddAndEvenBets; // Stores the msg.value for the block and the bet (odd or even)\n', '\n', '    mapping(uint256 => uint256) blockResult; // Stores if the blockhash&#39;s last char is odd or even\n', '    mapping(uint256 => bytes32) blockHash; // Stores the hash of block (block.number)\n', '\n', '    mapping(uint256 => uint256) blockRevenuePerTicket; // Stores the amount of the revenue per person for given block\n', '    mapping(uint256 => bool) isBlockRevenueCalculated; // Stores if the blocks revenue is calculated\n', '\n', '    mapping(uint256 => uint256) comissionsAtBlock; // Stores the commision amount for given block\n', '    \n', '    // Public variables\n', '    uint256 public _startBetBlock;\n', '    uint256 public _endBetBlock;\n', '\n', '    uint256 public _targetBlock;\n', '    \n', '    // Modifiers\n', '    modifier afterBlock(uint256 _blockNumber) {\n', '        require(block.number >= _blockNumber);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActivator(address _activator) {\n', '        require(activator[_activator] == true);\n', '        _;\n', '    }\n', '    \n', '    // Structures\n', '    struct Participant {\n', '        mapping(uint256 => Bet) bets;\n', '        bool isParticipated;\n', '    }\n', '\n', '    struct Bet {\n', '        uint256 ODDBets;\n', '\t\tuint256 EVENBets;\n', '        bool isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Constructor \n', '      * @param _moneyManager The address of the money manager.\n', '      * @param _ownerWallet The address of the owner.\n', '      * \n', '      */\n', '    constructor(address _moneyManager, address _ownerWallet) public {\n', '        setMoneyManager(_moneyManager);\n', '        setOwnerWallet(_ownerWallet);\n', '    }\n', '    \n', '    /** @dev Fallback function.\n', '      * Provides functionality for person to bet.\n', '      */\n', '    function() payable public {\n', '        bet(getBlockHashOddOrEven(block.number - 128), msg.value.div(BET));\n', '    }\n', '    \n', '    /** @dev Function which activates the cycle. \n', '      * Only the activator can call the function.\n', '      * @param _startBlock The starting block of the game.\n', '      * Set the starting block from which the participants can start to bet for target block.\n', '      * Set the end block to which the participants can bet fot target block. \n', '      * Set the target block for which the participants will bet.\n', '      * @return success Is the activation of the cycle successful.\n', '      */\n', '    function activateCycle(uint256 _startBlock) public onlyActivator(msg.sender) returns (bool _success) {\n', '        if (_startBlock == 0) {\n', '            _startBlock = block.number;\n', '        }\n', '        require(block.number >= _endBetBlock);\n', '\n', '        _startBetBlock = _startBlock;\n', '        _endBetBlock = _startBetBlock.add(END_DURATION_BETTING_BLOCK);\n', '\n', '        _targetBlock = _startBetBlock.add(TARGET_DURATION_BETTING_BLOCK);\n', '        targetBlocks.push(_targetBlock);\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Events\n', '    event LogBet(address indexed participant, uint256 blockNumber, uint8 oddOrEven, uint256 betAmount);\n', '    event LogNewParticipant(address indexed _newParticipant);\n', '    \n', '    /** @dev Function from which everyone can bet \n', '      * @param oddOrEven The number on which the participant want to bet (it is 1 - ODD or 2 - EVEN).\n', '      * @param betsAmount The amount of tickets the participant want to buy.\n', '      * @return success Is the bet successful.\n', '      */\n', '    function bet(uint8 oddOrEven, uint256 betsAmount) public payable returns (bool _success) {\n', '\t\trequire(betsAmount > 0);\n', '\t\tuint256 participantBet = betsAmount.mul(BET);\n', '\t\trequire(msg.value == participantBet);\n', '        require(oddOrEven == ODD || oddOrEven == EVEN);\n', '        require(block.number <= _endBetBlock && block.number >= _startBetBlock);\n', '\n', '\t\t// @dev - check if participant already betted\n', '\t\tif (participants[msg.sender].isParticipated == false) {\n', '\t\t\t// create new participant in memory\n', '\t\t\tParticipant memory newParticipant;\n', '\t\t\tnewParticipant.isParticipated = true;\n', '\t\t\t//save the participant to state\n', '\t\t\tparticipants[msg.sender] = newParticipant;\n', '\t\t\temit LogNewParticipant(msg.sender);\n', '\t\t}\n', '\t\t\n', '\t\tuint256 betTillNowODD = participants[msg.sender].bets[_targetBlock].ODDBets;\n', '\t\tuint256 betTillNowEVEN = participants[msg.sender].bets[_targetBlock].EVENBets;\n', '\t\tif(oddOrEven == ODD) {\n', '\t\t\tbetTillNowODD = betTillNowODD.add(participantBet);\n', '\t\t} else {\n', '\t\t\tbetTillNowEVEN = betTillNowEVEN.add(participantBet);\n', '\t\t}\n', '\t\tBet memory newBet = Bet({ODDBets : betTillNowODD, EVENBets: betTillNowEVEN, isRevenuePaid : false});\n', '\t\n', '        //save the bet\n', '        participants[msg.sender].bets[_targetBlock] = newBet;\n', '        // save the bet for the block\n', '        oddAndEvenBets[_targetBlock][oddOrEven] = oddAndEvenBets[_targetBlock][oddOrEven].add(msg.value);\n', '        address(moneyManager).transfer(msg.value);\n', '        emit LogBet(msg.sender, _targetBlock, oddOrEven, msg.value);\n', '\n', '        return true;\n', '    }\n', '    \n', '    /** @dev Function which calculates the revenue for block.\n', '      * @param _blockNumber The block for which the revenie will be calculated.\n', '      */\n', '    function calculateRevenueAtBlock(uint256 _blockNumber) public afterBlock(_blockNumber) {\n', '        require(isBlockRevenueCalculated[_blockNumber] == false);\n', '        if(oddAndEvenBets[_blockNumber][ODD] > 0 || oddAndEvenBets[_blockNumber][EVEN] > 0) {\n', '            blockResult[_blockNumber] = getBlockHashOddOrEven(_blockNumber);\n', '            require(blockResult[_blockNumber] == ODD || blockResult[_blockNumber] == EVEN);\n', '            if (blockResult[_blockNumber] == ODD) {\n', '                calculateRevenue(_blockNumber, ODD, EVEN);\n', '            } else if (blockResult[_blockNumber] == EVEN) {\n', '                calculateRevenue(_blockNumber, EVEN, ODD);\n', '            }\n', '        } else {\n', '            isBlockRevenueCalculated[_blockNumber] = true;\n', '            blockResult[_blockNumber] = noBets;\n', '        }\n', '    }\n', '\n', '    event LogOddOrEven(uint256 blockNumber, bytes32 blockHash, uint256 oddOrEven);\n', '    \n', '    /** @dev Function which calculates the hash of the given block.\n', '      * @param _blockNumber The block for which the hash will be calculated.\n', '      * The function is called by the calculateRevenueAtBlock()\n', '      * @return oddOrEven\n', '      */\n', '    function getBlockHashOddOrEven(uint256 _blockNumber) internal returns (uint8 oddOrEven) {\n', '        blockHash[_blockNumber] = blockhash(_blockNumber);\n', '        uint256 result = uint256(blockHash[_blockNumber]);\n', '        uint256 lastChar = (result * 2 ** 252) / (2 ** 252);\n', '        uint256 _oddOrEven = lastChar % 2;\n', '\n', '        emit LogOddOrEven(_blockNumber, blockHash[_blockNumber], _oddOrEven);\n', '\n', '        if (_oddOrEven == 1) {\n', '            return ODD;\n', '        } else if (_oddOrEven == 0) {\n', '            return EVEN;\n', '        }\n', '    }\n', '\n', '    event LogRevenue(uint256 blockNumber, uint256 winner, uint256 revenue);\n', '    \n', '    /** @dev Function which calculates the revenue of given block.\n', '      * @param _blockNumber The block for which the revenue will be calculated.\n', '      * @param winner The winner bet (1 - odd or 2 - even).\n', '      * @param loser The loser bet (2 even or 1 - odd).\n', '      * The function is called by the calculateRevenueAtBlock()\n', '      */\n', '    function calculateRevenue(uint256 _blockNumber, uint256 winner, uint256 loser) internal {\n', '        uint256 revenue = oddAndEvenBets[_blockNumber][loser];\n', '        if (oddAndEvenBets[_blockNumber][ODD] != 0 && oddAndEvenBets[_blockNumber][EVEN] != 0) {\n', '            uint256 comission = (revenue.div(100)).mul(COMMISSION_PERCENTAGE);\n', '            revenue = revenue.sub(comission);\n', '            comissionsAtBlock[_blockNumber] = comission;\n', '            IMoneyManager(moneyManager).payTo(ownerWallet, comission);\n', '            uint256 winners = oddAndEvenBets[_blockNumber][winner].div(BET);\n', '            blockRevenuePerTicket[_blockNumber] = revenue.div(winners);\n', '        }\n', '        isBlockRevenueCalculated[_blockNumber] = true;\n', '        emit LogRevenue(_blockNumber, winner, revenue);\n', '    }\n', '\n', '    event LogpayToRevenue(address indexed participant, uint256 blockNumber, bool revenuePaid);\n', '    \n', '    /** @dev Function which allows the participants to withdraw their revenue.\n', '      * @param _blockNumber The block for which the participants will withdraw their revenue.\n', '      * @return _success Is the revenue withdrawn successfully.\n', '      */\n', '    function withdrawRevenue(uint256 _blockNumber) public returns (bool _success) {\n', '        require(participants[msg.sender].bets[_blockNumber].ODDBets > 0 || participants[msg.sender].bets[_blockNumber].EVENBets > 0);\n', '        require(participants[msg.sender].bets[_blockNumber].isRevenuePaid == false);\n', '        require(isBlockRevenueCalculated[_blockNumber] == true);\n', '\n', '        if (oddAndEvenBets[_blockNumber][ODD] == 0 || oddAndEvenBets[_blockNumber][EVEN] == 0) {\n', '\t\t\tif(participants[msg.sender].bets[_blockNumber].ODDBets > 0) {\n', '\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].ODDBets);\n', '\t\t\t}else{\n', '\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].EVENBets);\n', '\t\t\t}\n', '            participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n', '            emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n', '\n', '            return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n', '        }\n', '        // @dev - initial revenue to be paid\n', '        uint256 _revenue = 0;\n', '        uint256 counter = 0;\n', '\t\tuint256 totalPayment = 0;\n', '        if (blockResult[_blockNumber] == ODD) {\n', '\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].ODDBets).div(BET);\n', '            _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n', '        } else if (blockResult[_blockNumber] == EVEN) {\n', '\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].EVENBets).div(BET);\n', '           _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n', '        }\n', '\t\ttotalPayment = _revenue.add(BET.mul(counter));\n', '        // pay the revenue\n', '        IMoneyManager(moneyManager).payTo(msg.sender, totalPayment);\n', '        participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n', '\n', '        emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n', '        return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Function which set the activator of the cycle.\n', '      * Only owner can call the function.\n', '      */\n', '    function setActivator(address _newActivator) onlyOwner public returns(bool) {\n', '        require(activator[_newActivator] == false);\n', '        activator[_newActivator] = true;\n', '        return activator[_newActivator];\n', '    }\n', '    \n', '    /** @dev Function which remove the activator.\n', '      * Only owner can call the function.\n', '      */\n', '    function removeActivator(address _Activator) onlyOwner public returns(bool) {\n', '        require(activator[_Activator] == true);\n', '        activator[_Activator] = false;\n', '        return true;\n', '    }\n', '    \n', '    /** @dev Function which set the owner of the wallet.\n', '      * Only owner can call the function.\n', '      * Called when the contract is deploying.\n', '      */\n', '    function setOwnerWallet(address _newOwnerWallet) public onlyOwner {\n', '        emit LogNew(ownerWallet, _newOwnerWallet);\n', '        ownerWallet = _newOwnerWallet;\n', '    }\n', '    \n', '    /** @dev Function which set the money manager.\n', '      * Only owner can call the function.\n', '      * Called when contract is deploying.\n', '      */\n', '    function setMoneyManager(address _moneyManager) public onlyOwner {\n', '        emit LogNew(moneyManager, _moneyManager);\n', '        moneyManager = _moneyManager;\n', '    }\n', '    \n', '    function getActivator(address _isActivator) public view returns(bool) {\n', '        return activator[_isActivator];\n', '    }\n', '    \n', '    /** @dev Function for getting the current block.\n', '      * @return _blockNumber\n', '      */\n', '    function getblock() public view returns (uint256 _blockNumber){\n', '        return block.number;\n', '    }\n', '\n', '    /** @dev Function for getting the current cycle info\n', '      * @return startBetBlock, endBetBlock, targetBlock\n', '      */\n', '    function getCycleInfo() public view returns (uint256 startBetBlock, uint256 endBetBlock, uint256 targetBlock){\n', '        return (\n', '        _startBetBlock,\n', '        _endBetBlock,\n', '        _targetBlock);\n', '    }\n', '    \n', '    /** @dev Function for getting the given block hash\n', '      * @param _blockNumber The block number of which you want to check hash.\n', '      * @return _blockHash\n', '      */\n', '    function getBlockHash(uint256 _blockNumber) public view returns (bytes32 _blockHash) {\n', '        return blockHash[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function for getting the bets for ODD and EVEN.\n', '      * @param _participant The address of the participant whose bets you want to check.\n', '      * @param _blockNumber The block for which you want to check.\n', '      * @return _oddBets, _evenBets\n', '      */\n', '    function getBetAt(address _participant, uint256 _blockNumber) public view returns (uint256 _oddBets, uint256 _evenBets){\n', '        return (participants[_participant].bets[_blockNumber].ODDBets, participants[_participant].bets[_blockNumber].EVENBets);\n', '    }\n', '    \n', '    /** @dev Function for getting the block result if it is ODD or EVEN.\n', '      * @param _blockNumber The block for which you want to get the result.\n', '      * @return _oddOrEven\n', '      */\n', '    function getBlockResult(uint256 _blockNumber) public view returns (uint256 _oddOrEven){\n', '        return blockResult[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function for getting the wei amount for given block.\n', '      * @param _blockNumber The block for which you want to get wei amount.\n', '      * @param _blockOddOrEven The block which is odd or even.\n', '      * @return _weiAmountAtStage\n', '      */\n', '    function getoddAndEvenBets(uint256 _blockNumber, uint256 _blockOddOrEven) public view returns (uint256 _weiAmountAtStage) {\n', '        return oddAndEvenBets[_blockNumber][_blockOddOrEven];\n', '    }\n', '    \n', '    /** @dev Function for checking if the given address participated in given block.\n', '      * @param _participant The participant whose participation we are going to check.\n', '      * @param _blockNumber The block for which we will check the participation.\n', '      * @return _isParticipate\n', '      */\n', '    function getIsParticipate(address _participant, uint256 _blockNumber) public view returns (bool _isParticipate) {\n', '        return (participants[_participant].bets[_blockNumber].ODDBets > 0 || participants[_participant].bets[_blockNumber].EVENBets > 0);\n', '    }\n', '    \n', '     /** @dev Function for getting the block revenue per ticket.\n', '      * @param _blockNumber The block for which we will calculate revenue per ticket.\n', '      * @return _revenue\n', '      */\n', '    function getblockRevenuePerTicket(uint256 _blockNumber) public view returns (uint256 _revenue) {\n', '        return blockRevenuePerTicket[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which tells us is the revenue for given block is calculated.\n', '      * @param _blockNumber The block for which we will check.\n', '      * @return _isCalculated\n', '      */\n', '    function getIsBlockRevenueCalculated(uint256 _blockNumber) public view returns (bool _isCalculated) {\n', '        return isBlockRevenueCalculated[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which tells us is the revenue for given block is paid.\n', '      * @param _blockNumber The block for which we will check.\n', '      * @return _isPaid\n', '      */\n', '    function getIsRevenuePaid(address _participant, uint256 _blockNumber) public view returns (bool _isPaid) {\n', '        return participants[_participant].bets[_blockNumber].isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Function which will return the block commission.\n', '      * @param _blockNumber The block for which we will get the commission.\n', '      * @return _comission\n', '      */\n', '    function getBlockComission(uint256 _blockNumber) public view returns (uint256 _comission) {\n', '        return comissionsAtBlock[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which will return the ODD and EVEN bets.\n', '      * @param _blockNumber The block for which we will get the commission.\n', '      * @return _ODDBets, _EVENBets\n', '      */\n', '    function getBetsEvenAndODD(uint256 _blockNumber) public view returns (uint256 _ODDBets, uint256 _EVENBets) {\n', '        return (oddAndEvenBets[_blockNumber][ODD], oddAndEvenBets[_blockNumber][EVEN]);\n', '    }\n', '\n', '    /** @dev Function which will return the count of target blocks.\n', '      * @return _targetBlockLenght\n', '      */\n', '    function getTargetBlockLength() public view returns (uint256 _targetBlockLenght) {\n', '        return targetBlocks.length;\n', '    }\n', '    \n', '    /** @dev Function which will return the whole target blocks.\n', '      * @return _targetBlocks Array of target blocks\n', '      */\n', '    function getTargetBlocks() public view returns (uint256[] _targetBlocks) {\n', '        return targetBlocks;\n', '    }\n', '    \n', '    /** @dev Function which will return a specific target block at index.\n', '      * @param _index The index of the target block which we want to get.\n', '      * @return _targetBlockNumber\n', '      */\n', '    function getTargetBlock(uint256 _index) public view returns (uint256 _targetBlockNumber) {\n', '        return targetBlocks[_index];\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event LogNew(address indexed old, address indexed current);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        emit LogNew(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract IMoneyManager {\n', '    function payTo(address _participant, uint256 _revenue) payable public returns(bool);\n', '}\n', '\n', 'contract Game is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    // The address of the owner \n', '    address public ownerWallet;\n', '    // The address of the activator\n', '    mapping(address => bool) internal activator;\n', '    \n', '    // Constants\n', '    uint256 public constant BET = 10 finney; //0.01 ETH\n', '    uint8 public constant ODD = 1;\n', '    uint8 public constant EVEN = 2;\n', '    uint8 public constant noBets = 3;\n', '    uint256 public constant COMMISSION_PERCENTAGE = 10;\n', '    uint256 public constant END_DURATION_BETTING_BLOCK = 5520;\n', '    uint256 public constant TARGET_DURATION_BETTING_BLOCK = 5760;\n', '\t\n', '\tuint256 public constant CONTRACT_VERSION = 201805311200;\n', '    \n', '    // The address of the moneyManager\n', '    address public moneyManager;\n', '    \n', '    // Array which stores the target blocks\n', '    uint256[] targetBlocks;\n', '    \n', '    // Mappings\n', '    mapping(address => Participant) public participants;\n', '\n', '    mapping(uint256 => mapping(uint256 => uint256)) oddAndEvenBets; // Stores the msg.value for the block and the bet (odd or even)\n', '\n', "    mapping(uint256 => uint256) blockResult; // Stores if the blockhash's last char is odd or even\n", '    mapping(uint256 => bytes32) blockHash; // Stores the hash of block (block.number)\n', '\n', '    mapping(uint256 => uint256) blockRevenuePerTicket; // Stores the amount of the revenue per person for given block\n', '    mapping(uint256 => bool) isBlockRevenueCalculated; // Stores if the blocks revenue is calculated\n', '\n', '    mapping(uint256 => uint256) comissionsAtBlock; // Stores the commision amount for given block\n', '    \n', '    // Public variables\n', '    uint256 public _startBetBlock;\n', '    uint256 public _endBetBlock;\n', '\n', '    uint256 public _targetBlock;\n', '    \n', '    // Modifiers\n', '    modifier afterBlock(uint256 _blockNumber) {\n', '        require(block.number >= _blockNumber);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActivator(address _activator) {\n', '        require(activator[_activator] == true);\n', '        _;\n', '    }\n', '    \n', '    // Structures\n', '    struct Participant {\n', '        mapping(uint256 => Bet) bets;\n', '        bool isParticipated;\n', '    }\n', '\n', '    struct Bet {\n', '        uint256 ODDBets;\n', '\t\tuint256 EVENBets;\n', '        bool isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Constructor \n', '      * @param _moneyManager The address of the money manager.\n', '      * @param _ownerWallet The address of the owner.\n', '      * \n', '      */\n', '    constructor(address _moneyManager, address _ownerWallet) public {\n', '        setMoneyManager(_moneyManager);\n', '        setOwnerWallet(_ownerWallet);\n', '    }\n', '    \n', '    /** @dev Fallback function.\n', '      * Provides functionality for person to bet.\n', '      */\n', '    function() payable public {\n', '        bet(getBlockHashOddOrEven(block.number - 128), msg.value.div(BET));\n', '    }\n', '    \n', '    /** @dev Function which activates the cycle. \n', '      * Only the activator can call the function.\n', '      * @param _startBlock The starting block of the game.\n', '      * Set the starting block from which the participants can start to bet for target block.\n', '      * Set the end block to which the participants can bet fot target block. \n', '      * Set the target block for which the participants will bet.\n', '      * @return success Is the activation of the cycle successful.\n', '      */\n', '    function activateCycle(uint256 _startBlock) public onlyActivator(msg.sender) returns (bool _success) {\n', '        if (_startBlock == 0) {\n', '            _startBlock = block.number;\n', '        }\n', '        require(block.number >= _endBetBlock);\n', '\n', '        _startBetBlock = _startBlock;\n', '        _endBetBlock = _startBetBlock.add(END_DURATION_BETTING_BLOCK);\n', '\n', '        _targetBlock = _startBetBlock.add(TARGET_DURATION_BETTING_BLOCK);\n', '        targetBlocks.push(_targetBlock);\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Events\n', '    event LogBet(address indexed participant, uint256 blockNumber, uint8 oddOrEven, uint256 betAmount);\n', '    event LogNewParticipant(address indexed _newParticipant);\n', '    \n', '    /** @dev Function from which everyone can bet \n', '      * @param oddOrEven The number on which the participant want to bet (it is 1 - ODD or 2 - EVEN).\n', '      * @param betsAmount The amount of tickets the participant want to buy.\n', '      * @return success Is the bet successful.\n', '      */\n', '    function bet(uint8 oddOrEven, uint256 betsAmount) public payable returns (bool _success) {\n', '\t\trequire(betsAmount > 0);\n', '\t\tuint256 participantBet = betsAmount.mul(BET);\n', '\t\trequire(msg.value == participantBet);\n', '        require(oddOrEven == ODD || oddOrEven == EVEN);\n', '        require(block.number <= _endBetBlock && block.number >= _startBetBlock);\n', '\n', '\t\t// @dev - check if participant already betted\n', '\t\tif (participants[msg.sender].isParticipated == false) {\n', '\t\t\t// create new participant in memory\n', '\t\t\tParticipant memory newParticipant;\n', '\t\t\tnewParticipant.isParticipated = true;\n', '\t\t\t//save the participant to state\n', '\t\t\tparticipants[msg.sender] = newParticipant;\n', '\t\t\temit LogNewParticipant(msg.sender);\n', '\t\t}\n', '\t\t\n', '\t\tuint256 betTillNowODD = participants[msg.sender].bets[_targetBlock].ODDBets;\n', '\t\tuint256 betTillNowEVEN = participants[msg.sender].bets[_targetBlock].EVENBets;\n', '\t\tif(oddOrEven == ODD) {\n', '\t\t\tbetTillNowODD = betTillNowODD.add(participantBet);\n', '\t\t} else {\n', '\t\t\tbetTillNowEVEN = betTillNowEVEN.add(participantBet);\n', '\t\t}\n', '\t\tBet memory newBet = Bet({ODDBets : betTillNowODD, EVENBets: betTillNowEVEN, isRevenuePaid : false});\n', '\t\n', '        //save the bet\n', '        participants[msg.sender].bets[_targetBlock] = newBet;\n', '        // save the bet for the block\n', '        oddAndEvenBets[_targetBlock][oddOrEven] = oddAndEvenBets[_targetBlock][oddOrEven].add(msg.value);\n', '        address(moneyManager).transfer(msg.value);\n', '        emit LogBet(msg.sender, _targetBlock, oddOrEven, msg.value);\n', '\n', '        return true;\n', '    }\n', '    \n', '    /** @dev Function which calculates the revenue for block.\n', '      * @param _blockNumber The block for which the revenie will be calculated.\n', '      */\n', '    function calculateRevenueAtBlock(uint256 _blockNumber) public afterBlock(_blockNumber) {\n', '        require(isBlockRevenueCalculated[_blockNumber] == false);\n', '        if(oddAndEvenBets[_blockNumber][ODD] > 0 || oddAndEvenBets[_blockNumber][EVEN] > 0) {\n', '            blockResult[_blockNumber] = getBlockHashOddOrEven(_blockNumber);\n', '            require(blockResult[_blockNumber] == ODD || blockResult[_blockNumber] == EVEN);\n', '            if (blockResult[_blockNumber] == ODD) {\n', '                calculateRevenue(_blockNumber, ODD, EVEN);\n', '            } else if (blockResult[_blockNumber] == EVEN) {\n', '                calculateRevenue(_blockNumber, EVEN, ODD);\n', '            }\n', '        } else {\n', '            isBlockRevenueCalculated[_blockNumber] = true;\n', '            blockResult[_blockNumber] = noBets;\n', '        }\n', '    }\n', '\n', '    event LogOddOrEven(uint256 blockNumber, bytes32 blockHash, uint256 oddOrEven);\n', '    \n', '    /** @dev Function which calculates the hash of the given block.\n', '      * @param _blockNumber The block for which the hash will be calculated.\n', '      * The function is called by the calculateRevenueAtBlock()\n', '      * @return oddOrEven\n', '      */\n', '    function getBlockHashOddOrEven(uint256 _blockNumber) internal returns (uint8 oddOrEven) {\n', '        blockHash[_blockNumber] = blockhash(_blockNumber);\n', '        uint256 result = uint256(blockHash[_blockNumber]);\n', '        uint256 lastChar = (result * 2 ** 252) / (2 ** 252);\n', '        uint256 _oddOrEven = lastChar % 2;\n', '\n', '        emit LogOddOrEven(_blockNumber, blockHash[_blockNumber], _oddOrEven);\n', '\n', '        if (_oddOrEven == 1) {\n', '            return ODD;\n', '        } else if (_oddOrEven == 0) {\n', '            return EVEN;\n', '        }\n', '    }\n', '\n', '    event LogRevenue(uint256 blockNumber, uint256 winner, uint256 revenue);\n', '    \n', '    /** @dev Function which calculates the revenue of given block.\n', '      * @param _blockNumber The block for which the revenue will be calculated.\n', '      * @param winner The winner bet (1 - odd or 2 - even).\n', '      * @param loser The loser bet (2 even or 1 - odd).\n', '      * The function is called by the calculateRevenueAtBlock()\n', '      */\n', '    function calculateRevenue(uint256 _blockNumber, uint256 winner, uint256 loser) internal {\n', '        uint256 revenue = oddAndEvenBets[_blockNumber][loser];\n', '        if (oddAndEvenBets[_blockNumber][ODD] != 0 && oddAndEvenBets[_blockNumber][EVEN] != 0) {\n', '            uint256 comission = (revenue.div(100)).mul(COMMISSION_PERCENTAGE);\n', '            revenue = revenue.sub(comission);\n', '            comissionsAtBlock[_blockNumber] = comission;\n', '            IMoneyManager(moneyManager).payTo(ownerWallet, comission);\n', '            uint256 winners = oddAndEvenBets[_blockNumber][winner].div(BET);\n', '            blockRevenuePerTicket[_blockNumber] = revenue.div(winners);\n', '        }\n', '        isBlockRevenueCalculated[_blockNumber] = true;\n', '        emit LogRevenue(_blockNumber, winner, revenue);\n', '    }\n', '\n', '    event LogpayToRevenue(address indexed participant, uint256 blockNumber, bool revenuePaid);\n', '    \n', '    /** @dev Function which allows the participants to withdraw their revenue.\n', '      * @param _blockNumber The block for which the participants will withdraw their revenue.\n', '      * @return _success Is the revenue withdrawn successfully.\n', '      */\n', '    function withdrawRevenue(uint256 _blockNumber) public returns (bool _success) {\n', '        require(participants[msg.sender].bets[_blockNumber].ODDBets > 0 || participants[msg.sender].bets[_blockNumber].EVENBets > 0);\n', '        require(participants[msg.sender].bets[_blockNumber].isRevenuePaid == false);\n', '        require(isBlockRevenueCalculated[_blockNumber] == true);\n', '\n', '        if (oddAndEvenBets[_blockNumber][ODD] == 0 || oddAndEvenBets[_blockNumber][EVEN] == 0) {\n', '\t\t\tif(participants[msg.sender].bets[_blockNumber].ODDBets > 0) {\n', '\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].ODDBets);\n', '\t\t\t}else{\n', '\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].EVENBets);\n', '\t\t\t}\n', '            participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n', '            emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n', '\n', '            return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n', '        }\n', '        // @dev - initial revenue to be paid\n', '        uint256 _revenue = 0;\n', '        uint256 counter = 0;\n', '\t\tuint256 totalPayment = 0;\n', '        if (blockResult[_blockNumber] == ODD) {\n', '\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].ODDBets).div(BET);\n', '            _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n', '        } else if (blockResult[_blockNumber] == EVEN) {\n', '\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].EVENBets).div(BET);\n', '           _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n', '        }\n', '\t\ttotalPayment = _revenue.add(BET.mul(counter));\n', '        // pay the revenue\n', '        IMoneyManager(moneyManager).payTo(msg.sender, totalPayment);\n', '        participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n', '\n', '        emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n', '        return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Function which set the activator of the cycle.\n', '      * Only owner can call the function.\n', '      */\n', '    function setActivator(address _newActivator) onlyOwner public returns(bool) {\n', '        require(activator[_newActivator] == false);\n', '        activator[_newActivator] = true;\n', '        return activator[_newActivator];\n', '    }\n', '    \n', '    /** @dev Function which remove the activator.\n', '      * Only owner can call the function.\n', '      */\n', '    function removeActivator(address _Activator) onlyOwner public returns(bool) {\n', '        require(activator[_Activator] == true);\n', '        activator[_Activator] = false;\n', '        return true;\n', '    }\n', '    \n', '    /** @dev Function which set the owner of the wallet.\n', '      * Only owner can call the function.\n', '      * Called when the contract is deploying.\n', '      */\n', '    function setOwnerWallet(address _newOwnerWallet) public onlyOwner {\n', '        emit LogNew(ownerWallet, _newOwnerWallet);\n', '        ownerWallet = _newOwnerWallet;\n', '    }\n', '    \n', '    /** @dev Function which set the money manager.\n', '      * Only owner can call the function.\n', '      * Called when contract is deploying.\n', '      */\n', '    function setMoneyManager(address _moneyManager) public onlyOwner {\n', '        emit LogNew(moneyManager, _moneyManager);\n', '        moneyManager = _moneyManager;\n', '    }\n', '    \n', '    function getActivator(address _isActivator) public view returns(bool) {\n', '        return activator[_isActivator];\n', '    }\n', '    \n', '    /** @dev Function for getting the current block.\n', '      * @return _blockNumber\n', '      */\n', '    function getblock() public view returns (uint256 _blockNumber){\n', '        return block.number;\n', '    }\n', '\n', '    /** @dev Function for getting the current cycle info\n', '      * @return startBetBlock, endBetBlock, targetBlock\n', '      */\n', '    function getCycleInfo() public view returns (uint256 startBetBlock, uint256 endBetBlock, uint256 targetBlock){\n', '        return (\n', '        _startBetBlock,\n', '        _endBetBlock,\n', '        _targetBlock);\n', '    }\n', '    \n', '    /** @dev Function for getting the given block hash\n', '      * @param _blockNumber The block number of which you want to check hash.\n', '      * @return _blockHash\n', '      */\n', '    function getBlockHash(uint256 _blockNumber) public view returns (bytes32 _blockHash) {\n', '        return blockHash[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function for getting the bets for ODD and EVEN.\n', '      * @param _participant The address of the participant whose bets you want to check.\n', '      * @param _blockNumber The block for which you want to check.\n', '      * @return _oddBets, _evenBets\n', '      */\n', '    function getBetAt(address _participant, uint256 _blockNumber) public view returns (uint256 _oddBets, uint256 _evenBets){\n', '        return (participants[_participant].bets[_blockNumber].ODDBets, participants[_participant].bets[_blockNumber].EVENBets);\n', '    }\n', '    \n', '    /** @dev Function for getting the block result if it is ODD or EVEN.\n', '      * @param _blockNumber The block for which you want to get the result.\n', '      * @return _oddOrEven\n', '      */\n', '    function getBlockResult(uint256 _blockNumber) public view returns (uint256 _oddOrEven){\n', '        return blockResult[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function for getting the wei amount for given block.\n', '      * @param _blockNumber The block for which you want to get wei amount.\n', '      * @param _blockOddOrEven The block which is odd or even.\n', '      * @return _weiAmountAtStage\n', '      */\n', '    function getoddAndEvenBets(uint256 _blockNumber, uint256 _blockOddOrEven) public view returns (uint256 _weiAmountAtStage) {\n', '        return oddAndEvenBets[_blockNumber][_blockOddOrEven];\n', '    }\n', '    \n', '    /** @dev Function for checking if the given address participated in given block.\n', '      * @param _participant The participant whose participation we are going to check.\n', '      * @param _blockNumber The block for which we will check the participation.\n', '      * @return _isParticipate\n', '      */\n', '    function getIsParticipate(address _participant, uint256 _blockNumber) public view returns (bool _isParticipate) {\n', '        return (participants[_participant].bets[_blockNumber].ODDBets > 0 || participants[_participant].bets[_blockNumber].EVENBets > 0);\n', '    }\n', '    \n', '     /** @dev Function for getting the block revenue per ticket.\n', '      * @param _blockNumber The block for which we will calculate revenue per ticket.\n', '      * @return _revenue\n', '      */\n', '    function getblockRevenuePerTicket(uint256 _blockNumber) public view returns (uint256 _revenue) {\n', '        return blockRevenuePerTicket[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which tells us is the revenue for given block is calculated.\n', '      * @param _blockNumber The block for which we will check.\n', '      * @return _isCalculated\n', '      */\n', '    function getIsBlockRevenueCalculated(uint256 _blockNumber) public view returns (bool _isCalculated) {\n', '        return isBlockRevenueCalculated[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which tells us is the revenue for given block is paid.\n', '      * @param _blockNumber The block for which we will check.\n', '      * @return _isPaid\n', '      */\n', '    function getIsRevenuePaid(address _participant, uint256 _blockNumber) public view returns (bool _isPaid) {\n', '        return participants[_participant].bets[_blockNumber].isRevenuePaid;\n', '    }\n', '    \n', '    /** @dev Function which will return the block commission.\n', '      * @param _blockNumber The block for which we will get the commission.\n', '      * @return _comission\n', '      */\n', '    function getBlockComission(uint256 _blockNumber) public view returns (uint256 _comission) {\n', '        return comissionsAtBlock[_blockNumber];\n', '    }\n', '    \n', '    /** @dev Function which will return the ODD and EVEN bets.\n', '      * @param _blockNumber The block for which we will get the commission.\n', '      * @return _ODDBets, _EVENBets\n', '      */\n', '    function getBetsEvenAndODD(uint256 _blockNumber) public view returns (uint256 _ODDBets, uint256 _EVENBets) {\n', '        return (oddAndEvenBets[_blockNumber][ODD], oddAndEvenBets[_blockNumber][EVEN]);\n', '    }\n', '\n', '    /** @dev Function which will return the count of target blocks.\n', '      * @return _targetBlockLenght\n', '      */\n', '    function getTargetBlockLength() public view returns (uint256 _targetBlockLenght) {\n', '        return targetBlocks.length;\n', '    }\n', '    \n', '    /** @dev Function which will return the whole target blocks.\n', '      * @return _targetBlocks Array of target blocks\n', '      */\n', '    function getTargetBlocks() public view returns (uint256[] _targetBlocks) {\n', '        return targetBlocks;\n', '    }\n', '    \n', '    /** @dev Function which will return a specific target block at index.\n', '      * @param _index The index of the target block which we want to get.\n', '      * @return _targetBlockNumber\n', '      */\n', '    function getTargetBlock(uint256 _index) public view returns (uint256 _targetBlockNumber) {\n', '        return targetBlocks[_index];\n', '    }\n', '}']
