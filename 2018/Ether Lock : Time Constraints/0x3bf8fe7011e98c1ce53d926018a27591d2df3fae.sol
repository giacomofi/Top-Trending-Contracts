['pragma solidity ^0.4.25;\n', '\n', '\n', 'contract Olympus {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    mapping (address=>uint) public invest;\n', '    mapping (address=>uint) public percentage;\n', '    mapping (address=>uint) public time_stamp;\n', '    \n', '    address techSupport = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0;\n', '    uint techSupportPercent = 2;\n', '    \n', '    uint refPercent = 3;\n', '    uint refBack = 3;\n', '    \n', '    uint public payment_delay = 1 hours;\n', '    uint public count_investors = 0;\n', '    \n', '    function bytesToAddress(bytes _data) internal pure returns(address referrer) {\n', '        assembly {\n', '            referrer := mload(add(_data, 20))\n', '        }\n', '        return referrer;\n', '    }\n', '    \n', '    function elapsedTime()public view returns(uint) {\n', '        return now.sub(time_stamp[msg.sender]).div(payment_delay);\n', '    }\n', '    \n', '    function calculateProfitPercent(uint bal) private pure returns (uint) {\n', '        if (bal >= 4e21) { // balance >= 4000 ETH\n', '            return 2500;   // 6% per day\n', '        }\n', '        if (bal >= 2e21) { // balance >= 2000 ETH\n', '            return 2083;   // 5% per day\n', '        }\n', '        if (bal >= 1e21) { // balance >= 1000 ETH\n', '            return 1875;   // 4.5% per day\n', '        }\n', '        if (bal >= 5e20) { // balance >= 500 ETH\n', '            return 1666;   // 4% per day\n', '        }\n', '        if (bal >= 4e20) { // balance >= 400 ETH\n', '            return 1583;   // 3.8% per day\n', '        }\n', '        if (bal >= 3e20) { // balance >= 300 ETH\n', '            return 1500;   // 3.6% per day\n', '        }\n', '        if (bal >= 2e20) { // balance >= 200 ETH\n', '            return 1416;   // 3.4% per day\n', '        }\n', '        if (bal >= 1e20) { // balance >= 100 ETH\n', '            return 1333;   // 3.2% per day\n', '        } else {\n', '            return 1250;   // 3% per day\n', '        }\n', '    }\n', '    \n', '    function deposit() internal {\n', '        if(invest[msg.sender] > 0 && elapsedTime() > 0) {\n', '            pickUpCharges();\n', '        }\n', '        if (msg.data.length > 0 ) {\n', '            address referrer = bytesToAddress(bytes(msg.data));\n', '            address sender = msg.sender;\n', '            if(referrer != sender) {\n', '                sender.transfer(msg.value * refBack / 100);\n', '                referrer.transfer(msg.value * refPercent / 100);\n', '            } else {\n', '                techSupport.transfer(msg.value * refPercent / 100);\n', '            }\n', '        } else {\n', '            techSupport.transfer(msg.value * refPercent / 100);\n', '        }\n', '        if(invest[msg.sender] == 0) {\n', '            count_investors+=1;\n', '        }\n', '        techSupport.transfer(msg.value.mul(techSupportPercent).div(100));\n', '        invest[msg.sender]+= msg.value;\n', '        time_stamp[msg.sender] = now;\n', '    }\n', '    \n', '    function pickUpCharges() internal {\n', '        uint hours_passed = elapsedTime();\n', "        require(hours_passed > 0, 'You can receive payment 1 time per hour');\n", '        uint thisBalance = address(this).balance;\n', '        uint value = (invest[msg.sender].mul(calculateProfitPercent(thisBalance)).div(1000000)).mul(hours_passed);\n', '        percentage[msg.sender] += value;\n', '        time_stamp[msg.sender] = now;\n', '        msg.sender.transfer(value);\n', '    }\n', '    \n', '    function() external payable {\n', '        if(msg.value > 0) {\n', '                deposit();\n', '        } else if(msg.value == 0) {\n', '            pickUpCharges();\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}']