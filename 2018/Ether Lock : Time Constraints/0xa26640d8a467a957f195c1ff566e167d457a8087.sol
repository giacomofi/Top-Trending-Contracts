['pragma solidity ^0.4.18;\n', '\n', 'contract ownerOnly {\n', '    \n', '    function ownerOnly() public { owner = msg.sender; }\n', '    address owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Game is ownerOnly {\n', '    \n', '    //Уникальный код коровы\n', '    uint cow_code;\n', '    \n', '    struct cows {\n', '        uint cow;\n', '        uint date_buy;\n', '        bool cow_live;\n', '        uint milk;\n', '        uint date_milk;\n', '    } \n', '    \n', '    //Маппинг количество коров у пользователя\n', '    mapping (address => uint) users_cows;\n', '    //Маппинг коровы у пользователя\n', '    mapping (bytes32 => cows) user;\n', '    //Маппинг телеги\n', '    mapping (address => bool) telega;\n', '    //Адрес кошелька rico\n', '    address rico;\n', '    \n', '    //сколько корова дает молока за одну дойку\n', '    uint volume_milk;\n', '    //сколько нужно времени между доениями\n', '    uint time_to_milk;\n', '    //времмя жизни коровы\n', '    uint time_to_live;   \n', '        \n', '    //сколько стоит молоко в веях в розницу\n', '    uint milkcost;\n', '    \n', '    //инициируем переменные движка\n', '    function Game() public {\n', '        \n', '        //устанавливаем кошелек движка для управления\n', '    \trico = 0xb5F60D78F15b73DC2D2083571d0EEa70d35b9D28;\n', '    \t\n', '    \t//Устанавливаем счетчик коров\n', '    \tcow_code = 0;\n', '    \t\n', '        //сколько литров дает корова на 5 минут\n', '        volume_milk = 1;\n', '        //через сколько секунд можно доить корову\n', '        time_to_milk = 60;\n', '        //сколько секунд живет корова - 30 мин\n', '        time_to_live = 600;  \n', '        \n', '        //Сколько стоит продать молоко в розницу\n', '        milkcost = 0.0013 ether;\n', '    }\n', '    \n', '    function pay() public payable {\n', '        payCow();\n', '    }        \n', '    \n', '    //покупаем коров только от движка\n', '    function payCow() private {\n', '       \n', '        uint time= now;\n', '        uint cows_count = users_cows[msg.sender];\n', '        \n', '        uint index = msg.value/0.01 ether;\n', '        \n', '        for (uint i = 1; i <= index; i++) {\n', '            \n', '            cow_code++;\n', '            cows_count++;\n', '            user[keccak256(msg.sender) & keccak256(i)]=cows(cow_code,time,true,0,time);\n', '        }\n', '        users_cows[msg.sender] = cows_count;\n', '        rico.transfer(0.001 ether);\n', '    }    \n', '    \n', '    //доим корову\n', '    function MilkCow(address gamer) private {\n', '       \n', '        uint time= now;\n', '        uint time_milk;\n', '        \n', '        for (uint i=1; i<=users_cows[gamer]; i++) {\n', '            \n', '            //если корова пока жива тогда доим\n', '            if (user[keccak256(gamer) & keccak256(i)].cow_live==true) {\n', '                \n', '                //получаем время смерти коровы\n', '                uint datedeadcow=user[keccak256(gamer) & keccak256(i)].date_buy+time_to_live;\n', '               \n', '                //если время смерти коровы уже наступило\n', '                if (time>=datedeadcow) {\n', '                    \n', '                    //получаем сколько доек мы пропустили\n', '                    time_milk=(time-user[keccak256(gamer) & keccak256(i)].date_milk)/time_to_milk;\n', '                    \n', '                    if (time_milk>=1) {\n', '                        //кидаем на склад молоко которое мы надоили за пропущенные дойки\n', '                        user[keccak256(gamer) & keccak256(i)].milk+=(volume_milk*time_milk);\n', '                        //убиваем корову\n', '                        user[keccak256(gamer) & keccak256(i)].cow_live=false;\n', '                        //устанавливаем последнее время доения\n', '                        user[keccak256(gamer) & keccak256(i)].date_milk+=(time_milk*time_to_milk);\n', '                    }\n', '                    \n', '                } else {\n', '                    \n', '                    time_milk=(time-user[keccak256(gamer) & keccak256(i)].date_milk)/time_to_milk;\n', '                    \n', '                    if (time_milk>=1) {\n', '                        user[keccak256(gamer) & keccak256(i)].milk+=(volume_milk*time_milk);\n', '                        user[keccak256(gamer) & keccak256(i)].date_milk+=(time_milk*time_to_milk);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }    \n', '  \n', '    //продаем молоко, если указано 0 тогда все молоко, иначе сколько сколько указано\n', '    function saleMilk() public {\n', '        \n', '        //сколько будем продовать молока\n', '        uint milk_to_sale;\n', '        \n', '        //отгрузка молока возможно только при наличии телеги у фермера\n', '        if (telega[msg.sender]==true) {\n', '            \n', '            MilkCow(msg.sender);\n', '            \n', '            //Получаем количество коров у пользователя\n', '            uint cows_count = users_cows[msg.sender];            \n', '        \n', '            //обнуляем все молоко на продажу\n', '            milk_to_sale=0;\n', '\n', '            for (uint i=1; i<=cows_count; i++) {\n', '\n', '                milk_to_sale += user[keccak256(msg.sender) & keccak256(i)].milk;\n', '                //удаляем из анкеты все молоко\n', '                user[keccak256(msg.sender) & keccak256(i)].milk = 0;\n', '            }\n', '            //отсылаем эфир за купленное молоко\n', '            uint a=milkcost*milk_to_sale;\n', '            msg.sender.transfer(milkcost*milk_to_sale);\n', '        }            \n', '    }\n', '            \n', '    //продаем корову от фермера фермеру, историю передачи всегда можно узнать из чтения бд\n', '    function TransferCow(address gamer, uint num_cow) public {\n', '        \n', '        //продавать разрешается только живую корову\n', '        if (user[keccak256(msg.sender) & keccak256(num_cow)].cow_live == true) {\n', '            \n', '            //получаем количество коров у покупателя\n', '            uint cows_count = users_cows[gamer];\n', '            \n', '            //создаем и заполняем анкету коровы для нового фермера, при этом молоко не передается\n', '            user[keccak256(gamer) & keccak256(cows_count)]=cows(user[keccak256(msg.sender) & keccak256(num_cow)].cow,\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].date_buy,\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].cow_live,0,now);\n', '            \n', '            //убиваем корову и прошлого фермера\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].cow_live= false;\n', '            \n', '            users_cows[gamer] ++;\n', '        }\n', '    }\n', '    \n', '    //убиваем корову принудительно из движка\n', '    function DeadCow(address gamer, uint num_cow) public onlyOwner {\n', '       \n', '        //обновляем анкету коровы\n', '        user[keccak256(gamer) & keccak256(num_cow)].cow_live = false;\n', '    }  \n', '    \n', '    //Послать телегу фермеру\n', '    function TelegaSend(address gamer) public onlyOwner {\n', '       \n', '        //Послать телегу\n', '        telega[gamer] = true;\n', '       \n', '    }  \n', '    \n', '    //Вернуть деньги\n', '    function SendOwner() public onlyOwner {\n', '        msg.sender.transfer(this.balance);\n', '    }      \n', '    \n', '    //Послать телегу фермеру\n', '    function TelegaOut(address gamer) public onlyOwner {\n', '       \n', '        //Послать телегу\n', '        telega[gamer] = false;\n', '       \n', '    }  \n', '    \n', '    //Вывести сколько коров у фермера\n', '    function CountCow(address gamer) public view returns (uint) {\n', '        return users_cows[gamer];   \n', '    }\n', '\n', '    //Вывести сколько коров у фермера\n', '    function StatusCow(address gamer, uint num_cow) public view returns (uint,uint,bool,uint,uint) {\n', '        return (user[keccak256(gamer) & keccak256(num_cow)].cow,\n', '        user[keccak256(gamer) & keccak256(num_cow)].date_buy,\n', '        user[keccak256(gamer) & keccak256(num_cow)].cow_live,\n', '        user[keccak256(gamer) & keccak256(num_cow)].milk,\n', '        user[keccak256(gamer) & keccak256(num_cow)].date_milk);   \n', '    }\n', '    \n', '    //Вывести наличие телеги у фермера\n', '    function Statustelega(address gamer) public view returns (bool) {\n', '        return telega[gamer];   \n', '    }    \n', '    \n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract ownerOnly {\n', '    \n', '    function ownerOnly() public { owner = msg.sender; }\n', '    address owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Game is ownerOnly {\n', '    \n', '    //Уникальный код коровы\n', '    uint cow_code;\n', '    \n', '    struct cows {\n', '        uint cow;\n', '        uint date_buy;\n', '        bool cow_live;\n', '        uint milk;\n', '        uint date_milk;\n', '    } \n', '    \n', '    //Маппинг количество коров у пользователя\n', '    mapping (address => uint) users_cows;\n', '    //Маппинг коровы у пользователя\n', '    mapping (bytes32 => cows) user;\n', '    //Маппинг телеги\n', '    mapping (address => bool) telega;\n', '    //Адрес кошелька rico\n', '    address rico;\n', '    \n', '    //сколько корова дает молока за одну дойку\n', '    uint volume_milk;\n', '    //сколько нужно времени между доениями\n', '    uint time_to_milk;\n', '    //времмя жизни коровы\n', '    uint time_to_live;   \n', '        \n', '    //сколько стоит молоко в веях в розницу\n', '    uint milkcost;\n', '    \n', '    //инициируем переменные движка\n', '    function Game() public {\n', '        \n', '        //устанавливаем кошелек движка для управления\n', '    \trico = 0xb5F60D78F15b73DC2D2083571d0EEa70d35b9D28;\n', '    \t\n', '    \t//Устанавливаем счетчик коров\n', '    \tcow_code = 0;\n', '    \t\n', '        //сколько литров дает корова на 5 минут\n', '        volume_milk = 1;\n', '        //через сколько секунд можно доить корову\n', '        time_to_milk = 60;\n', '        //сколько секунд живет корова - 30 мин\n', '        time_to_live = 600;  \n', '        \n', '        //Сколько стоит продать молоко в розницу\n', '        milkcost = 0.0013 ether;\n', '    }\n', '    \n', '    function pay() public payable {\n', '        payCow();\n', '    }        \n', '    \n', '    //покупаем коров только от движка\n', '    function payCow() private {\n', '       \n', '        uint time= now;\n', '        uint cows_count = users_cows[msg.sender];\n', '        \n', '        uint index = msg.value/0.01 ether;\n', '        \n', '        for (uint i = 1; i <= index; i++) {\n', '            \n', '            cow_code++;\n', '            cows_count++;\n', '            user[keccak256(msg.sender) & keccak256(i)]=cows(cow_code,time,true,0,time);\n', '        }\n', '        users_cows[msg.sender] = cows_count;\n', '        rico.transfer(0.001 ether);\n', '    }    \n', '    \n', '    //доим корову\n', '    function MilkCow(address gamer) private {\n', '       \n', '        uint time= now;\n', '        uint time_milk;\n', '        \n', '        for (uint i=1; i<=users_cows[gamer]; i++) {\n', '            \n', '            //если корова пока жива тогда доим\n', '            if (user[keccak256(gamer) & keccak256(i)].cow_live==true) {\n', '                \n', '                //получаем время смерти коровы\n', '                uint datedeadcow=user[keccak256(gamer) & keccak256(i)].date_buy+time_to_live;\n', '               \n', '                //если время смерти коровы уже наступило\n', '                if (time>=datedeadcow) {\n', '                    \n', '                    //получаем сколько доек мы пропустили\n', '                    time_milk=(time-user[keccak256(gamer) & keccak256(i)].date_milk)/time_to_milk;\n', '                    \n', '                    if (time_milk>=1) {\n', '                        //кидаем на склад молоко которое мы надоили за пропущенные дойки\n', '                        user[keccak256(gamer) & keccak256(i)].milk+=(volume_milk*time_milk);\n', '                        //убиваем корову\n', '                        user[keccak256(gamer) & keccak256(i)].cow_live=false;\n', '                        //устанавливаем последнее время доения\n', '                        user[keccak256(gamer) & keccak256(i)].date_milk+=(time_milk*time_to_milk);\n', '                    }\n', '                    \n', '                } else {\n', '                    \n', '                    time_milk=(time-user[keccak256(gamer) & keccak256(i)].date_milk)/time_to_milk;\n', '                    \n', '                    if (time_milk>=1) {\n', '                        user[keccak256(gamer) & keccak256(i)].milk+=(volume_milk*time_milk);\n', '                        user[keccak256(gamer) & keccak256(i)].date_milk+=(time_milk*time_to_milk);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }    \n', '  \n', '    //продаем молоко, если указано 0 тогда все молоко, иначе сколько сколько указано\n', '    function saleMilk() public {\n', '        \n', '        //сколько будем продовать молока\n', '        uint milk_to_sale;\n', '        \n', '        //отгрузка молока возможно только при наличии телеги у фермера\n', '        if (telega[msg.sender]==true) {\n', '            \n', '            MilkCow(msg.sender);\n', '            \n', '            //Получаем количество коров у пользователя\n', '            uint cows_count = users_cows[msg.sender];            \n', '        \n', '            //обнуляем все молоко на продажу\n', '            milk_to_sale=0;\n', '\n', '            for (uint i=1; i<=cows_count; i++) {\n', '\n', '                milk_to_sale += user[keccak256(msg.sender) & keccak256(i)].milk;\n', '                //удаляем из анкеты все молоко\n', '                user[keccak256(msg.sender) & keccak256(i)].milk = 0;\n', '            }\n', '            //отсылаем эфир за купленное молоко\n', '            uint a=milkcost*milk_to_sale;\n', '            msg.sender.transfer(milkcost*milk_to_sale);\n', '        }            \n', '    }\n', '            \n', '    //продаем корову от фермера фермеру, историю передачи всегда можно узнать из чтения бд\n', '    function TransferCow(address gamer, uint num_cow) public {\n', '        \n', '        //продавать разрешается только живую корову\n', '        if (user[keccak256(msg.sender) & keccak256(num_cow)].cow_live == true) {\n', '            \n', '            //получаем количество коров у покупателя\n', '            uint cows_count = users_cows[gamer];\n', '            \n', '            //создаем и заполняем анкету коровы для нового фермера, при этом молоко не передается\n', '            user[keccak256(gamer) & keccak256(cows_count)]=cows(user[keccak256(msg.sender) & keccak256(num_cow)].cow,\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].date_buy,\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].cow_live,0,now);\n', '            \n', '            //убиваем корову и прошлого фермера\n', '            user[keccak256(msg.sender) & keccak256(num_cow)].cow_live= false;\n', '            \n', '            users_cows[gamer] ++;\n', '        }\n', '    }\n', '    \n', '    //убиваем корову принудительно из движка\n', '    function DeadCow(address gamer, uint num_cow) public onlyOwner {\n', '       \n', '        //обновляем анкету коровы\n', '        user[keccak256(gamer) & keccak256(num_cow)].cow_live = false;\n', '    }  \n', '    \n', '    //Послать телегу фермеру\n', '    function TelegaSend(address gamer) public onlyOwner {\n', '       \n', '        //Послать телегу\n', '        telega[gamer] = true;\n', '       \n', '    }  \n', '    \n', '    //Вернуть деньги\n', '    function SendOwner() public onlyOwner {\n', '        msg.sender.transfer(this.balance);\n', '    }      \n', '    \n', '    //Послать телегу фермеру\n', '    function TelegaOut(address gamer) public onlyOwner {\n', '       \n', '        //Послать телегу\n', '        telega[gamer] = false;\n', '       \n', '    }  \n', '    \n', '    //Вывести сколько коров у фермера\n', '    function CountCow(address gamer) public view returns (uint) {\n', '        return users_cows[gamer];   \n', '    }\n', '\n', '    //Вывести сколько коров у фермера\n', '    function StatusCow(address gamer, uint num_cow) public view returns (uint,uint,bool,uint,uint) {\n', '        return (user[keccak256(gamer) & keccak256(num_cow)].cow,\n', '        user[keccak256(gamer) & keccak256(num_cow)].date_buy,\n', '        user[keccak256(gamer) & keccak256(num_cow)].cow_live,\n', '        user[keccak256(gamer) & keccak256(num_cow)].milk,\n', '        user[keccak256(gamer) & keccak256(num_cow)].date_milk);   \n', '    }\n', '    \n', '    //Вывести наличие телеги у фермера\n', '    function Statustelega(address gamer) public view returns (bool) {\n', '        return telega[gamer];   \n', '    }    \n', '    \n', '}']
