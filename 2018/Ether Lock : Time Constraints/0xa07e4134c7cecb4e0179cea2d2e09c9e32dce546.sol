['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract BGXTokenInterface{\n', '\n', '    function distribute( address _to, uint256 _amount ) public returns( bool );\n', '    function finally( address _teamAddress ) public returns( bool );\n', '\n', '}\n', '\n', 'contract BGXCrowdsale is Ownable{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    BGXTokenInterface bgxTokenInterface;\n', '\n', '    address   public bgxWallet;\n', '    address[] public adviser;\n', '    address[] public bounty;\n', '    address[] public team;\n', '\n', '    mapping( address => uint256 ) adviserAmount;\n', '    mapping( address => uint256 ) bountyAmount;\n', '    mapping( address => uint256 ) teamAmount;\n', '\n', '    uint256 public presaleDateStart      = 1524571200;\n', '    uint256 public presaleDateFinish     = 1526385600;\n', '    uint256 public saleDateStart         = 1526990400;\n', '    uint256 public saleDateFinish        = 1528200000;\n', '\n', '    uint256 constant public hardcap      = 500000000 ether;\n', '    uint256 public presaleHardcap        = 30000000  ether;\n', '    uint256 public softcap               = 40000000  ether;\n', '    uint256 public totalBGX              = 0;\n', '    uint256 constant public minimal      = 1000 ether;\n', '\n', '    uint256 reserved                     = 250000000 ether;\n', '    uint256 constant teamLimit           = 100000000 ether;\n', '    uint256 constant advisersLimit       = 100000000 ether;\n', '    uint256 constant bountyLimit         = 50000000 ether;\n', '    uint256 public distributionDate      = 0;\n', '\n', '    bool paused = false;\n', '\n', '    enum CrowdsaleStates { Pause, Presale, Sale, OverHardcap, Finish }\n', '\n', '    CrowdsaleStates public state = CrowdsaleStates.Pause;\n', '\n', '    uint256 public sendNowLastCount = 0;\n', '    uint256 public finishLastCount = 0;\n', '    uint256 public finishCurrentLimit = 0;\n', '\n', '    modifier activeState {\n', '        require(\n', '            getState() == CrowdsaleStates.Presale\n', '            || getState() == CrowdsaleStates.Sale\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onPause {\n', '        require(\n', '            getState() == CrowdsaleStates.Pause\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier overSoftcap {\n', '        require(\n', '            totalBGX >= softcap\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier finishOrHardcap {\n', '        require(\n', '            getState() == CrowdsaleStates.OverHardcap\n', '            || getState() == CrowdsaleStates.Finish\n', '        );\n', '        _;\n', '    }\n', '\n', '    // fix for short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    address[]                     public investors;\n', '    mapping( address => uint256 ) public investorBalance;\n', '    mapping( address => bool )    public inBlackList;\n', '\n', '\n', '\n', '    function setBgxWalletAddress( address _a ) public onlyOwner returns( bool )\n', '    {\n', '        require( address(0) != _a );\n', '        bgxWallet = _a;\n', '        return true;\n', '    }\n', '\n', '    function setCrowdsaleDate( uint256 _presaleStart, uint256 _presaleFinish, uint256 _saleStart, uint256 _saleFinish ) public onlyOwner onPause returns( bool )\n', '    {\n', '        presaleDateStart = _presaleStart;\n', '        presaleDateFinish = _presaleFinish;\n', '        saleDateStart = _saleStart;\n', '        saleDateFinish = _saleFinish;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setCaps( uint256 _presaleHardcap, uint256 _softcap ) public onlyOwner onPause returns( bool )\n', '    {\n', '        presaleHardcap = _presaleHardcap;\n', '        softcap = _softcap;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function getState() public returns( CrowdsaleStates )\n', '    {\n', '\n', '        if( state == CrowdsaleStates.Pause || paused ) return CrowdsaleStates.Pause;\n', '        if( state == CrowdsaleStates.Finish ) return CrowdsaleStates.Finish;\n', '\n', '        if( totalBGX >= hardcap ) return CrowdsaleStates.OverHardcap;\n', '\n', '\n', '        if( now >= presaleDateStart && now <= presaleDateFinish ){\n', '\n', '            if( totalBGX >= presaleHardcap ) return CrowdsaleStates.Pause;\n', '            return CrowdsaleStates.Presale;\n', '\n', '        }\n', '\n', '        if( now >= saleDateStart && now <= saleDateFinish ){\n', '\n', '            if( totalBGX >= hardcap ) {\n', '                _startCounter();\n', '                return CrowdsaleStates.OverHardcap;\n', '            }\n', '            return CrowdsaleStates.Sale;\n', '\n', '        }\n', '\n', '        if( now > saleDateFinish ) {\n', '            _startCounter();\n', '            return CrowdsaleStates.Finish;\n', '        }\n', '\n', '        return CrowdsaleStates.Pause;\n', '\n', '    }\n', '\n', '    function _startCounter() internal\n', '    {\n', '        if (distributionDate <= 0) {\n', '            distributionDate = now + 2 days;\n', '        }\n', '    }\n', '\n', '\n', '    function pauseStateSwithcer() public onlyOwner returns( bool )\n', '    {\n', '        paused = !paused;\n', '    }\n', '\n', '    function start() public onlyOwner returns( bool )\n', '    {\n', '        state = CrowdsaleStates.Presale;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function send(address _addr, uint _amount) public onlyOwner activeState onlyPayloadSize(2 * 32) returns( bool )\n', '    {\n', '        require( address(0) != _addr && _amount >= minimal && !inBlackList[_addr] );\n', '\n', '        if( getState() == CrowdsaleStates.Presale ) require( totalBGX.add( _amount ) <= presaleHardcap );\n', '        if( getState() == CrowdsaleStates.Sale )    require( totalBGX.add( _amount ) <= hardcap );\n', '\n', '\n', '        investors.push( _addr );\n', '\n', '\n', '        investorBalance[_addr] = investorBalance[_addr].add( _amount );\n', '        if ( !inBlackList[_addr]) {\n', '            totalBGX = totalBGX.add( _amount );\n', '        }\n', '        return true;\n', '\n', '    }\n', '\n', '    function investorsCount() public constant returns( uint256 )\n', '    {\n', '        return investors.length;\n', '    }\n', '\n', '    function sendNow( uint256 _count ) public onlyOwner overSoftcap  returns( bool )\n', '    {\n', '        require( sendNowLastCount.add( _count ) <= investors.length );\n', '\n', '        uint256 to = sendNowLastCount.add( _count );\n', '\n', '        for( uint256 i = sendNowLastCount; i <= to - 1; i++ )\n', '            if( !inBlackList[investors[i]] ){\n', '                investorBalance[investors[i]] = 0;\n', '                bgxTokenInterface.distribute( investors[i], investorBalance[investors[i]] );\n', '            }\n', '\n', '        sendNowLastCount = sendNowLastCount.add( _count );\n', '    }\n', '\n', '\n', '    function blackListSwithcer( address _addr ) public onlyOwner returns( bool )\n', '    {\n', '        require( address(0) != _addr );\n', '\n', '        if( !inBlackList[_addr] ){\n', '            totalBGX = totalBGX.sub( investorBalance[_addr] );\n', '        } else {\n', '            totalBGX = totalBGX.add( investorBalance[_addr] );\n', '        }\n', '\n', '        inBlackList[_addr] = !inBlackList[_addr];\n', '\n', '    }\n', '\n', '\n', '    function finish( uint256 _count) public onlyOwner finishOrHardcap overSoftcap returns( bool )\n', '    {\n', '        require(_count > 0);\n', '        require(distributionDate > 0 && distributionDate <= now);\n', '        if (finishCurrentLimit == 0) {\n', '            finishCurrentLimit = bountyLimit.add(teamLimit.add(advisersLimit));\n', '        }\n', '        // advisers + bounters total cnt\n', '        uint256 totalCnt = adviser.length.add(bounty.length);\n', '\n', '        if (finishLastCount < adviser.length) {\n', '            for( uint256 i = finishLastCount; i <= adviser.length - 1; i++  ){\n', '                finishCurrentLimit = finishCurrentLimit.sub( adviserAmount[adviser[i]] );\n', '                bgxTokenInterface.distribute( adviser[i],adviserAmount[adviser[i]] );\n', '                finishLastCount++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        if (finishLastCount < totalCnt) {\n', '            for( i = finishLastCount.sub(adviser.length); i <= bounty.length - 1; i++  ){\n', '                finishCurrentLimit = finishCurrentLimit.sub( bountyAmount[bounty[i]] );\n', '                bgxTokenInterface.distribute( bounty[i],bountyAmount[bounty[i]] );\n', '                finishLastCount ++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        if (finishLastCount >= totalCnt && finishLastCount < totalCnt.add(team.length)) {\n', '            for( i =  finishLastCount.sub(totalCnt); i <= team.length - 1; i++  ){\n', '\n', '                finishCurrentLimit = finishCurrentLimit.sub( teamAmount[team[i]] );\n', '                bgxTokenInterface.distribute( team[i],teamAmount[team[i]] );\n', '                finishLastCount ++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '\n', '        reserved = reserved.add( finishCurrentLimit );\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '    function sendToTeam() public onlyOwner finishOrHardcap overSoftcap returns( bool )\n', '    {\n', '        bgxTokenInterface.distribute( bgxWallet, reserved );\n', '        bgxTokenInterface.finally( bgxWallet );\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    function setAdvisers( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        adviser = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= adviser.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= advisersLimit );\n', '            adviserAmount[adviser[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '    function setBounty( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        bounty = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= bounty.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= bountyLimit );\n', '            bountyAmount[bounty[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '    function setTeams( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        team = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= team.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= teamLimit );\n', '            teamAmount[team[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '\n', '    function setBGXTokenInterface( address _BGXTokenAddress ) public onlyOwner returns( bool )\n', '    {\n', '        require( _BGXTokenAddress != address(0) );\n', '        bgxTokenInterface = BGXTokenInterface( _BGXTokenAddress );\n', '    }\n', '\n', '\n', '    function time() public constant returns(uint256 )\n', '    {\n', '        return now;\n', '    }\n', '\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract BGXTokenInterface{\n', '\n', '    function distribute( address _to, uint256 _amount ) public returns( bool );\n', '    function finally( address _teamAddress ) public returns( bool );\n', '\n', '}\n', '\n', 'contract BGXCrowdsale is Ownable{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    BGXTokenInterface bgxTokenInterface;\n', '\n', '    address   public bgxWallet;\n', '    address[] public adviser;\n', '    address[] public bounty;\n', '    address[] public team;\n', '\n', '    mapping( address => uint256 ) adviserAmount;\n', '    mapping( address => uint256 ) bountyAmount;\n', '    mapping( address => uint256 ) teamAmount;\n', '\n', '    uint256 public presaleDateStart      = 1524571200;\n', '    uint256 public presaleDateFinish     = 1526385600;\n', '    uint256 public saleDateStart         = 1526990400;\n', '    uint256 public saleDateFinish        = 1528200000;\n', '\n', '    uint256 constant public hardcap      = 500000000 ether;\n', '    uint256 public presaleHardcap        = 30000000  ether;\n', '    uint256 public softcap               = 40000000  ether;\n', '    uint256 public totalBGX              = 0;\n', '    uint256 constant public minimal      = 1000 ether;\n', '\n', '    uint256 reserved                     = 250000000 ether;\n', '    uint256 constant teamLimit           = 100000000 ether;\n', '    uint256 constant advisersLimit       = 100000000 ether;\n', '    uint256 constant bountyLimit         = 50000000 ether;\n', '    uint256 public distributionDate      = 0;\n', '\n', '    bool paused = false;\n', '\n', '    enum CrowdsaleStates { Pause, Presale, Sale, OverHardcap, Finish }\n', '\n', '    CrowdsaleStates public state = CrowdsaleStates.Pause;\n', '\n', '    uint256 public sendNowLastCount = 0;\n', '    uint256 public finishLastCount = 0;\n', '    uint256 public finishCurrentLimit = 0;\n', '\n', '    modifier activeState {\n', '        require(\n', '            getState() == CrowdsaleStates.Presale\n', '            || getState() == CrowdsaleStates.Sale\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onPause {\n', '        require(\n', '            getState() == CrowdsaleStates.Pause\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier overSoftcap {\n', '        require(\n', '            totalBGX >= softcap\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier finishOrHardcap {\n', '        require(\n', '            getState() == CrowdsaleStates.OverHardcap\n', '            || getState() == CrowdsaleStates.Finish\n', '        );\n', '        _;\n', '    }\n', '\n', '    // fix for short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    address[]                     public investors;\n', '    mapping( address => uint256 ) public investorBalance;\n', '    mapping( address => bool )    public inBlackList;\n', '\n', '\n', '\n', '    function setBgxWalletAddress( address _a ) public onlyOwner returns( bool )\n', '    {\n', '        require( address(0) != _a );\n', '        bgxWallet = _a;\n', '        return true;\n', '    }\n', '\n', '    function setCrowdsaleDate( uint256 _presaleStart, uint256 _presaleFinish, uint256 _saleStart, uint256 _saleFinish ) public onlyOwner onPause returns( bool )\n', '    {\n', '        presaleDateStart = _presaleStart;\n', '        presaleDateFinish = _presaleFinish;\n', '        saleDateStart = _saleStart;\n', '        saleDateFinish = _saleFinish;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setCaps( uint256 _presaleHardcap, uint256 _softcap ) public onlyOwner onPause returns( bool )\n', '    {\n', '        presaleHardcap = _presaleHardcap;\n', '        softcap = _softcap;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function getState() public returns( CrowdsaleStates )\n', '    {\n', '\n', '        if( state == CrowdsaleStates.Pause || paused ) return CrowdsaleStates.Pause;\n', '        if( state == CrowdsaleStates.Finish ) return CrowdsaleStates.Finish;\n', '\n', '        if( totalBGX >= hardcap ) return CrowdsaleStates.OverHardcap;\n', '\n', '\n', '        if( now >= presaleDateStart && now <= presaleDateFinish ){\n', '\n', '            if( totalBGX >= presaleHardcap ) return CrowdsaleStates.Pause;\n', '            return CrowdsaleStates.Presale;\n', '\n', '        }\n', '\n', '        if( now >= saleDateStart && now <= saleDateFinish ){\n', '\n', '            if( totalBGX >= hardcap ) {\n', '                _startCounter();\n', '                return CrowdsaleStates.OverHardcap;\n', '            }\n', '            return CrowdsaleStates.Sale;\n', '\n', '        }\n', '\n', '        if( now > saleDateFinish ) {\n', '            _startCounter();\n', '            return CrowdsaleStates.Finish;\n', '        }\n', '\n', '        return CrowdsaleStates.Pause;\n', '\n', '    }\n', '\n', '    function _startCounter() internal\n', '    {\n', '        if (distributionDate <= 0) {\n', '            distributionDate = now + 2 days;\n', '        }\n', '    }\n', '\n', '\n', '    function pauseStateSwithcer() public onlyOwner returns( bool )\n', '    {\n', '        paused = !paused;\n', '    }\n', '\n', '    function start() public onlyOwner returns( bool )\n', '    {\n', '        state = CrowdsaleStates.Presale;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function send(address _addr, uint _amount) public onlyOwner activeState onlyPayloadSize(2 * 32) returns( bool )\n', '    {\n', '        require( address(0) != _addr && _amount >= minimal && !inBlackList[_addr] );\n', '\n', '        if( getState() == CrowdsaleStates.Presale ) require( totalBGX.add( _amount ) <= presaleHardcap );\n', '        if( getState() == CrowdsaleStates.Sale )    require( totalBGX.add( _amount ) <= hardcap );\n', '\n', '\n', '        investors.push( _addr );\n', '\n', '\n', '        investorBalance[_addr] = investorBalance[_addr].add( _amount );\n', '        if ( !inBlackList[_addr]) {\n', '            totalBGX = totalBGX.add( _amount );\n', '        }\n', '        return true;\n', '\n', '    }\n', '\n', '    function investorsCount() public constant returns( uint256 )\n', '    {\n', '        return investors.length;\n', '    }\n', '\n', '    function sendNow( uint256 _count ) public onlyOwner overSoftcap  returns( bool )\n', '    {\n', '        require( sendNowLastCount.add( _count ) <= investors.length );\n', '\n', '        uint256 to = sendNowLastCount.add( _count );\n', '\n', '        for( uint256 i = sendNowLastCount; i <= to - 1; i++ )\n', '            if( !inBlackList[investors[i]] ){\n', '                investorBalance[investors[i]] = 0;\n', '                bgxTokenInterface.distribute( investors[i], investorBalance[investors[i]] );\n', '            }\n', '\n', '        sendNowLastCount = sendNowLastCount.add( _count );\n', '    }\n', '\n', '\n', '    function blackListSwithcer( address _addr ) public onlyOwner returns( bool )\n', '    {\n', '        require( address(0) != _addr );\n', '\n', '        if( !inBlackList[_addr] ){\n', '            totalBGX = totalBGX.sub( investorBalance[_addr] );\n', '        } else {\n', '            totalBGX = totalBGX.add( investorBalance[_addr] );\n', '        }\n', '\n', '        inBlackList[_addr] = !inBlackList[_addr];\n', '\n', '    }\n', '\n', '\n', '    function finish( uint256 _count) public onlyOwner finishOrHardcap overSoftcap returns( bool )\n', '    {\n', '        require(_count > 0);\n', '        require(distributionDate > 0 && distributionDate <= now);\n', '        if (finishCurrentLimit == 0) {\n', '            finishCurrentLimit = bountyLimit.add(teamLimit.add(advisersLimit));\n', '        }\n', '        // advisers + bounters total cnt\n', '        uint256 totalCnt = adviser.length.add(bounty.length);\n', '\n', '        if (finishLastCount < adviser.length) {\n', '            for( uint256 i = finishLastCount; i <= adviser.length - 1; i++  ){\n', '                finishCurrentLimit = finishCurrentLimit.sub( adviserAmount[adviser[i]] );\n', '                bgxTokenInterface.distribute( adviser[i],adviserAmount[adviser[i]] );\n', '                finishLastCount++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        if (finishLastCount < totalCnt) {\n', '            for( i = finishLastCount.sub(adviser.length); i <= bounty.length - 1; i++  ){\n', '                finishCurrentLimit = finishCurrentLimit.sub( bountyAmount[bounty[i]] );\n', '                bgxTokenInterface.distribute( bounty[i],bountyAmount[bounty[i]] );\n', '                finishLastCount ++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        if (finishLastCount >= totalCnt && finishLastCount < totalCnt.add(team.length)) {\n', '            for( i =  finishLastCount.sub(totalCnt); i <= team.length - 1; i++  ){\n', '\n', '                finishCurrentLimit = finishCurrentLimit.sub( teamAmount[team[i]] );\n', '                bgxTokenInterface.distribute( team[i],teamAmount[team[i]] );\n', '                finishLastCount ++;\n', '                _count--;\n', '                if (_count <= 0) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '\n', '        reserved = reserved.add( finishCurrentLimit );\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '    function sendToTeam() public onlyOwner finishOrHardcap overSoftcap returns( bool )\n', '    {\n', '        bgxTokenInterface.distribute( bgxWallet, reserved );\n', '        bgxTokenInterface.finally( bgxWallet );\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    function setAdvisers( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        adviser = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= adviser.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= advisersLimit );\n', '            adviserAmount[adviser[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '    function setBounty( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        bounty = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= bounty.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= bountyLimit );\n', '            bountyAmount[bounty[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '    function setTeams( address[] _addrs, uint256[] _amounts ) public onlyOwner finishOrHardcap returns( bool )\n', '    {\n', '        require( _addrs.length == _amounts.length );\n', '\n', '        team = _addrs;\n', '        uint256 limit = 0;\n', '\n', '        for( uint256 i = 0; i <= team.length - 1; i++  ){\n', '            require( limit.add( _amounts[i] ) <= teamLimit );\n', '            teamAmount[team[i]] = _amounts[i];\n', '            limit.add( _amounts[i] );\n', '        }\n', '    }\n', '\n', '\n', '    function setBGXTokenInterface( address _BGXTokenAddress ) public onlyOwner returns( bool )\n', '    {\n', '        require( _BGXTokenAddress != address(0) );\n', '        bgxTokenInterface = BGXTokenInterface( _BGXTokenAddress );\n', '    }\n', '\n', '\n', '    function time() public constant returns(uint256 )\n', '    {\n', '        return now;\n', '    }\n', '\n', '\n', '\n', '\n', '}']
