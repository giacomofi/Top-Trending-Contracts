['pragma solidity 0.4.24;\n', '\n', 'contract ERC20TokenInterface {\n', '\n', '    function totalSupply () external constant returns (uint);\n', '    function balanceOf (address tokenOwner) external constant returns (uint balance);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '    \n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam tokens vesting contract. \n', ' *\n', ' * According to the DreamTeam token distribution structure, there are two parties that should\n', ' * be provided with corresponding token amounts during the 2 years after TGE:\n', ' *      Teams and Tournament Organizers: 15%\n', ' *      Team and Early Investors: 10%\n', ' *\n', ' * The DreamTeam "Vesting" smart contract should be in place to ensure meeting the token sale commitments.\n', ' *\n', ' * Two instances of the contract will be deployed for holding tokens. \n', ' * First instance for "Teams and Tournament Organizers" tokens and second for "Team and Early Investors".\n', ' */\n', 'contract DreamTokensVesting {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Address of DreamToken.\n', '     */\n', '    ERC20TokenInterface public dreamToken;\n', '\n', '    /**\n', '     * Address for receiving tokens.\n', '     */\n', '    address public withdrawAddress;\n', '\n', '    /**\n', '     * Tokens vesting stage structure with vesting date and tokens allowed to unlock.\n', '     */\n', '    struct VestingStage {\n', '        uint256 date;\n', '        uint256 tokensUnlockedPercentage;\n', '    }\n', '\n', '    /**\n', '     * Array for storing all vesting stages with structure defined above.\n', '     */\n', '    VestingStage[5] public stages;\n', '\n', '    /**\n', '     * Starting timestamp of the first stage of vesting (Tuesday, 19 June 2018, 09:00:00 GMT).\n', '     * Will be used as a starting point for all dates calculations.\n', '     */\n', '    uint256 public vestingStartTimestamp = 1529398800;\n', '\n', '    /**\n', '     * Total amount of tokens sent.\n', '     */\n', '    uint256 public initialTokensBalance;\n', '\n', '    /**\n', '     * Amount of tokens already sent.\n', '     */\n', '    uint256 public tokensSent;\n', '\n', '    /**\n', '     * Event raised on each successful withdraw.\n', '     */\n', '    event Withdraw(uint256 amount, uint256 timestamp);\n', '\n', '    /**\n', '     * Could be called only from withdraw address.\n', '     */\n', '    modifier onlyWithdrawAddress () {\n', '        require(msg.sender == withdrawAddress);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * We are filling vesting stages array right when the contract is deployed.\n', '     *\n', '     * @param token Address of DreamToken that will be locked on contract.\n', '     * @param withdraw Address of tokens receiver when it is unlocked.\n', '     */\n', '    constructor (ERC20TokenInterface token, address withdraw) public {\n', '        dreamToken = token;\n', '        withdrawAddress = withdraw;\n', '        initVestingStages();\n', '    }\n', '    \n', '    /**\n', '     * Fallback \n', '     */\n', '    function () external {\n', '        withdrawTokens();\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens amount that is sent to withdrawAddress.\n', '     * \n', '     * @return Amount of tokens that can be sent.\n', '     */\n', '    function getAvailableTokensToWithdraw () public view returns (uint256 tokensToSend) {\n', '        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n', '        // In the case of stuck tokens we allow the withdrawal of them all after vesting period ends.\n', '        if (tokensUnlockedPercentage >= 100) {\n', '            tokensToSend = dreamToken.balanceOf(this);\n', '        } else {\n', '            tokensToSend = getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Get detailed info about stage. \n', '     * Provides ability to get attributes of every stage from external callers, ie Web3, truffle tests, etc.\n', '     *\n', '     * @param index Vesting stage number. Ordered by ascending date and starting from zero.\n', '     *\n', '     * @return {\n', '     *    "date": "Date of stage in unix timestamp format.",\n', '     *    "tokensUnlockedPercentage": "Percent of tokens allowed to be withdrawn."\n', '     * }\n', '     */\n', '    function getStageAttributes (uint8 index) public view returns (uint256 date, uint256 tokensUnlockedPercentage) {\n', '        return (stages[index].date, stages[index].tokensUnlockedPercentage);\n', '    }\n', '\n', '    /**\n', '     * Setup array with vesting stages dates and percents.\n', '     */\n', '    function initVestingStages () internal {\n', '        uint256 halfOfYear = 183 days;\n', '        uint256 year = halfOfYear * 2;\n', '        stages[0].date = vestingStartTimestamp;\n', '        stages[1].date = vestingStartTimestamp + halfOfYear;\n', '        stages[2].date = vestingStartTimestamp + year;\n', '        stages[3].date = vestingStartTimestamp + year + halfOfYear;\n', '        stages[4].date = vestingStartTimestamp + year * 2;\n', '\n', '        stages[0].tokensUnlockedPercentage = 25;\n', '        stages[1].tokensUnlockedPercentage = 50;\n', '        stages[2].tokensUnlockedPercentage = 75;\n', '        stages[3].tokensUnlockedPercentage = 88;\n', '        stages[4].tokensUnlockedPercentage = 100;\n', '    }\n', '\n', '    /**\n', '     * Main method for withdraw tokens from vesting.\n', '     */\n', '    function withdrawTokens () onlyWithdrawAddress private {\n', '        // Setting initial tokens balance on a first withdraw.\n', '        if (initialTokensBalance == 0) {\n', '            setInitialTokensBalance();\n', '        }\n', '        uint256 tokensToSend = getAvailableTokensToWithdraw();\n', '        sendTokens(tokensToSend);\n', '    }\n', '\n', '    /**\n', '     * Set initial tokens balance when making the first withdrawal.\n', '     */\n', '    function setInitialTokensBalance () private {\n', '        initialTokensBalance = dreamToken.balanceOf(this);\n', '    }\n', '\n', '    /**\n', '     * Send tokens to withdrawAddress.\n', '     * \n', '     * @param tokensToSend Amount of tokens will be sent.\n', '     */\n', '    function sendTokens (uint256 tokensToSend) private {\n', '        if (tokensToSend > 0) {\n', '            // Updating tokens sent counter\n', '            tokensSent = tokensSent.add(tokensToSend);\n', '            // Sending allowed tokens amount\n', '            dreamToken.transfer(withdrawAddress, tokensToSend);\n', '            // Raising event\n', '            emit Withdraw(tokensToSend, now);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens available for withdrawal.\n', '     *\n', '     * @param tokensUnlockedPercentage Percent of tokens that are allowed to be sent.\n', '     *\n', '     * @return Amount of tokens that can be sent according to provided percentage.\n', '     */\n', '    function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\n', '        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\n', '        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\n', '        return unsentTokensAmount;\n', '    }\n', '\n', '    /**\n', '     * Get tokens unlocked percentage on current stage.\n', '     * \n', '     * @return Percent of tokens allowed to be sent.\n', '     */\n', '    function getTokensUnlockedPercentage () private view returns (uint256) {\n', '        uint256 allowedPercent;\n', '        \n', '        for (uint8 i = 0; i < stages.length; i++) {\n', '            if (now >= stages[i].date) {\n', '                allowedPercent = stages[i].tokensUnlockedPercentage;\n', '            }\n', '        }\n', '        \n', '        return allowedPercent;\n', '    }\n', '}\n', '\n', 'contract ProTeamsAndTournamentOrganizersVesting is DreamTokensVesting {\n', '    constructor(ERC20TokenInterface token, address withdraw) DreamTokensVesting(token, withdraw) public {} \n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract ERC20TokenInterface {\n', '\n', '    function totalSupply () external constant returns (uint);\n', '    function balanceOf (address tokenOwner) external constant returns (uint balance);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '    \n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam tokens vesting contract. \n', ' *\n', ' * According to the DreamTeam token distribution structure, there are two parties that should\n', ' * be provided with corresponding token amounts during the 2 years after TGE:\n', ' *      Teams and Tournament Organizers: 15%\n', ' *      Team and Early Investors: 10%\n', ' *\n', ' * The DreamTeam "Vesting" smart contract should be in place to ensure meeting the token sale commitments.\n', ' *\n', ' * Two instances of the contract will be deployed for holding tokens. \n', ' * First instance for "Teams and Tournament Organizers" tokens and second for "Team and Early Investors".\n', ' */\n', 'contract DreamTokensVesting {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Address of DreamToken.\n', '     */\n', '    ERC20TokenInterface public dreamToken;\n', '\n', '    /**\n', '     * Address for receiving tokens.\n', '     */\n', '    address public withdrawAddress;\n', '\n', '    /**\n', '     * Tokens vesting stage structure with vesting date and tokens allowed to unlock.\n', '     */\n', '    struct VestingStage {\n', '        uint256 date;\n', '        uint256 tokensUnlockedPercentage;\n', '    }\n', '\n', '    /**\n', '     * Array for storing all vesting stages with structure defined above.\n', '     */\n', '    VestingStage[5] public stages;\n', '\n', '    /**\n', '     * Starting timestamp of the first stage of vesting (Tuesday, 19 June 2018, 09:00:00 GMT).\n', '     * Will be used as a starting point for all dates calculations.\n', '     */\n', '    uint256 public vestingStartTimestamp = 1529398800;\n', '\n', '    /**\n', '     * Total amount of tokens sent.\n', '     */\n', '    uint256 public initialTokensBalance;\n', '\n', '    /**\n', '     * Amount of tokens already sent.\n', '     */\n', '    uint256 public tokensSent;\n', '\n', '    /**\n', '     * Event raised on each successful withdraw.\n', '     */\n', '    event Withdraw(uint256 amount, uint256 timestamp);\n', '\n', '    /**\n', '     * Could be called only from withdraw address.\n', '     */\n', '    modifier onlyWithdrawAddress () {\n', '        require(msg.sender == withdrawAddress);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * We are filling vesting stages array right when the contract is deployed.\n', '     *\n', '     * @param token Address of DreamToken that will be locked on contract.\n', '     * @param withdraw Address of tokens receiver when it is unlocked.\n', '     */\n', '    constructor (ERC20TokenInterface token, address withdraw) public {\n', '        dreamToken = token;\n', '        withdrawAddress = withdraw;\n', '        initVestingStages();\n', '    }\n', '    \n', '    /**\n', '     * Fallback \n', '     */\n', '    function () external {\n', '        withdrawTokens();\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens amount that is sent to withdrawAddress.\n', '     * \n', '     * @return Amount of tokens that can be sent.\n', '     */\n', '    function getAvailableTokensToWithdraw () public view returns (uint256 tokensToSend) {\n', '        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n', '        // In the case of stuck tokens we allow the withdrawal of them all after vesting period ends.\n', '        if (tokensUnlockedPercentage >= 100) {\n', '            tokensToSend = dreamToken.balanceOf(this);\n', '        } else {\n', '            tokensToSend = getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Get detailed info about stage. \n', '     * Provides ability to get attributes of every stage from external callers, ie Web3, truffle tests, etc.\n', '     *\n', '     * @param index Vesting stage number. Ordered by ascending date and starting from zero.\n', '     *\n', '     * @return {\n', '     *    "date": "Date of stage in unix timestamp format.",\n', '     *    "tokensUnlockedPercentage": "Percent of tokens allowed to be withdrawn."\n', '     * }\n', '     */\n', '    function getStageAttributes (uint8 index) public view returns (uint256 date, uint256 tokensUnlockedPercentage) {\n', '        return (stages[index].date, stages[index].tokensUnlockedPercentage);\n', '    }\n', '\n', '    /**\n', '     * Setup array with vesting stages dates and percents.\n', '     */\n', '    function initVestingStages () internal {\n', '        uint256 halfOfYear = 183 days;\n', '        uint256 year = halfOfYear * 2;\n', '        stages[0].date = vestingStartTimestamp;\n', '        stages[1].date = vestingStartTimestamp + halfOfYear;\n', '        stages[2].date = vestingStartTimestamp + year;\n', '        stages[3].date = vestingStartTimestamp + year + halfOfYear;\n', '        stages[4].date = vestingStartTimestamp + year * 2;\n', '\n', '        stages[0].tokensUnlockedPercentage = 25;\n', '        stages[1].tokensUnlockedPercentage = 50;\n', '        stages[2].tokensUnlockedPercentage = 75;\n', '        stages[3].tokensUnlockedPercentage = 88;\n', '        stages[4].tokensUnlockedPercentage = 100;\n', '    }\n', '\n', '    /**\n', '     * Main method for withdraw tokens from vesting.\n', '     */\n', '    function withdrawTokens () onlyWithdrawAddress private {\n', '        // Setting initial tokens balance on a first withdraw.\n', '        if (initialTokensBalance == 0) {\n', '            setInitialTokensBalance();\n', '        }\n', '        uint256 tokensToSend = getAvailableTokensToWithdraw();\n', '        sendTokens(tokensToSend);\n', '    }\n', '\n', '    /**\n', '     * Set initial tokens balance when making the first withdrawal.\n', '     */\n', '    function setInitialTokensBalance () private {\n', '        initialTokensBalance = dreamToken.balanceOf(this);\n', '    }\n', '\n', '    /**\n', '     * Send tokens to withdrawAddress.\n', '     * \n', '     * @param tokensToSend Amount of tokens will be sent.\n', '     */\n', '    function sendTokens (uint256 tokensToSend) private {\n', '        if (tokensToSend > 0) {\n', '            // Updating tokens sent counter\n', '            tokensSent = tokensSent.add(tokensToSend);\n', '            // Sending allowed tokens amount\n', '            dreamToken.transfer(withdrawAddress, tokensToSend);\n', '            // Raising event\n', '            emit Withdraw(tokensToSend, now);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens available for withdrawal.\n', '     *\n', '     * @param tokensUnlockedPercentage Percent of tokens that are allowed to be sent.\n', '     *\n', '     * @return Amount of tokens that can be sent according to provided percentage.\n', '     */\n', '    function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\n', '        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\n', '        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\n', '        return unsentTokensAmount;\n', '    }\n', '\n', '    /**\n', '     * Get tokens unlocked percentage on current stage.\n', '     * \n', '     * @return Percent of tokens allowed to be sent.\n', '     */\n', '    function getTokensUnlockedPercentage () private view returns (uint256) {\n', '        uint256 allowedPercent;\n', '        \n', '        for (uint8 i = 0; i < stages.length; i++) {\n', '            if (now >= stages[i].date) {\n', '                allowedPercent = stages[i].tokensUnlockedPercentage;\n', '            }\n', '        }\n', '        \n', '        return allowedPercent;\n', '    }\n', '}\n', '\n', 'contract ProTeamsAndTournamentOrganizersVesting is DreamTokensVesting {\n', '    constructor(ERC20TokenInterface token, address withdraw) DreamTokensVesting(token, withdraw) public {} \n', '}']
