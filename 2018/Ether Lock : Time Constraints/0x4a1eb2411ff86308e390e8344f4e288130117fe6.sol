['pragma solidity >0.4.99 <0.6.0;\n', '\n', 'interface SlidebitsToken {\n', '    function frozenAccount(address tokenHolder) external returns (bool status);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '}\n', '\n', 'interface token {\n', '    function transfer(address _to, uint256 _value) external;\n', '}\n', '\n', 'contract UpgradeToken {\n', '   address public owner;\n', '\n', '   modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '  address oldTokenAddress = 0xb7FE7B2B723020Cf668Db4F78992d10F81990fc4;\n', '  address newTokenAddress = 0x46706C5e5B7dF0Afd54a7248F1E5788275B7FaC6;\n', '\n', '  SlidebitsToken public oldToken = SlidebitsToken(oldTokenAddress);\n', '  token public newToken = token(newTokenAddress);\n', '\n', '  mapping (address => bool) public upgradedAccount;\n', '  \n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function upgradeFrozenAccounts(address[] memory tokenHolders) public onlyOwner {\n', '    for(uint i = 0; i < tokenHolders.length; i++)\n', '    {\n', '      if (oldToken.frozenAccount(tokenHolders[i]) && !upgradedAccount[tokenHolders[i]]){\n', '          upgradedAccount[tokenHolders[i]] = true;\n', '          newToken.transfer(tokenHolders[i], oldToken.balanceOf(tokenHolders[i]));\n', '      }\n', '    }\n', '  }\n', '\n', '}']