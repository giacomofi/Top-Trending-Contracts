['pragma solidity ^0.4.24;\n', '\n', 'contract Owned {\n', '    address public aOwner;\n', '    address public coOwner1;\n', '    address public coOwner2;\n', '\n', '    constructor() public {\n', '        aOwner = msg.sender;\n', '        coOwner1 = msg.sender;\n', '        coOwner2 = msg.sender;\n', '    }\n', '\n', '    /* Modifiers */\n', '    modifier onlyOwner {\n', '        require(msg.sender == aOwner || msg.sender == coOwner1 || msg.sender == coOwner2);\n', '        _;\n', '    }\n', '\n', '    function setCoOwner1(address _coOwner) public onlyOwner {\n', '      coOwner1 = _coOwner;\n', '    }\n', '\n', '    function setCoOwner2(address _coOwner) public onlyOwner {\n', '      coOwner2 = _coOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract XEther is Owned {\n', '    /* Structurs and variables */\n', '    uint256 public totalInvestmentAmount = 0;\n', '    uint256 public ownerFeePercent = 50; // 5%\n', '    uint256 public investorsFeePercent = 130; // 13%\n', '\n', '    uint256 public curIteration = 1;\n', '\n', '    uint256 public depositsCount = 0;\n', '    uint256 public investorsCount = 1;\n', '\n', '    uint256 public bankAmount = 0;\n', '    uint256 public feeAmount = 0;\n', '\n', '    uint256 public toGwei = 1000000000; // or 1e9, helper vars\n', '    uint256 public minDepositAmount = 20000000; // minimum deposit\n', '    uint256 public minLotteryAmount = 100000000; // minimum to participate in lottery\n', '    uint256 public minInvestmentAmount = 5 ether; // min for investment\n', '\n', '    bool public isWipeAllowed = true; // wipe only if bank almost became empty\n', '    uint256 public investorsCountLimit = 7; // maximum investors\n', '    uint256 public lastTransaction = now;\n', '\n', '    // Stage variables\n', '    uint256 private stageStartTime = now;\n', '    uint private currentStage = 1;\n', '    uint private stageTime = 86400; // time of stage in minutes\n', '    uint private stageMin = 0;\n', '    uint private stageMax = 72;\n', '\n', '    // lottery\n', '    uint256 public jackpotBalance = 0;\n', '    uint256 public jackpotPercent = 20; // 2%\n', '\n', '    uint256 _seed;\n', '\n', '    // Deposits mapping\n', '    mapping(uint256 => address) public depContractidToAddress;\n', '    mapping(uint256 => uint256) public depContractidToAmount;\n', '    mapping(uint256 => bool) public depContractidToLottery;\n', '\n', '    // Investors mapping\n', '    mapping(uint256 => address) public investorsAddress;\n', '    mapping(uint256 => uint256) public investorsInvested;\n', '    mapping(uint256 => uint256) public investorsComissionPercent;\n', '    mapping(uint256 => uint256) public investorsEarned;\n', '\n', '    /* Events */\n', '    event EvDebug (\n', '        uint amount\n', '    );\n', '\n', '    /* New income transaction*/\n', '    event EvNewDeposit (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address sender,\n', '        uint256 amount,\n', '        uint256 multiplier,\n', '        uint256 time\n', '    );\n', '\n', '    /* New investment added */\n', '    event EvNewInvestment (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address sender,\n', '        uint256 amount,\n', '        uint256[] investorsFee\n', '    );\n', '\n', '    /* Collect investors earned, when some one get payment */\n', '    event EvInvestorsComission (\n', '        uint256 iteration,\n', '        uint256[] investorsComission\n', '    );\n', '\n', '    /* Bank amount increased */\n', '    event EvUpdateBankAmount (\n', '        uint256 iteration,\n', '        uint256 deposited,\n', '        uint256 balance\n', '    );\n', '\n', '    /* Payout for deposit */\n', '    event EvDepositPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address receiver,\n', '        uint256 amount,\n', '        uint256 fee,\n', '        uint256 jackpotBalance\n', '    );\n', '\n', '    /* newIteration */\n', '    event EvNewIteration (\n', '        uint256 iteration\n', '    );\n', '\n', '    /* No more funds in the bank, need actions (e.g. new iteration) */\n', '    event EvBankBecomeEmpty (\n', '        uint256 iteration,\n', '        uint256 index,\n', '        address receiver,\n', '        uint256 payoutAmount,\n', '        uint256 bankAmount\n', '    );\n', '\n', '    /* Investor get payment */\n', '    event EvInvestorPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        uint256 amount,\n', '        bool status\n', '    );\n', '\n', '    /* Investors get payment */\n', '    event EvInvestorsPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256[] payouts,\n', '        bool[] statuses\n', '    );\n', '\n', '    /* New stage - time of withdraw is tapered */\n', '    event EvStageChanged (\n', '        uint256 iteration,\n', '        uint timeDiff,\n', '        uint stage\n', '    );\n', '\n', '    /* Lottery numbers */\n', '    event EvLotteryWin (\n', '        uint256 iteration,\n', '        uint256 contractId,\n', '        address winer,\n', '        uint256 amount\n', '    );\n', '\n', '    /* Check address with code*/\n', '    event EvConfimAddress (\n', '        address sender,\n', '        bytes16 code\n', '    );\n', '\n', '    /* Lottery numbers */\n', '    event EvLotteryNumbers (\n', '        uint256 iteration,\n', '        uint256 index,\n', '        uint256[] lotteryNumbers\n', '    );\n', '\n', '    /* Manually update Jackpot amount */\n', '    event EvUpdateJackpot (\n', '        uint256 iteration,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /*---------- constructor ------------*/\n', '    constructor() public {\n', '        investorsAddress[0] = aOwner;\n', '        investorsInvested[0] = 0;\n', '        investorsComissionPercent[0] = 0;\n', '        investorsEarned[0] = 0;\n', '    }\n', '\n', '    /*--------------- public methods -----------------*/\n', '    function() public payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '\n', '        uint256 amount = msg.value / toGwei; // convert to gwei\n', '\n', '        if (amount >= minDepositAmount) {\n', '            lastTransaction = block.timestamp;\n', '            newDeposit(msg.sender, amount);\n', '        }\n', '        else {\n', '            bankAmount += amount;\n', '        }\n', '    }\n', '\n', '    function newIteration() public onlyOwner {\n', '        require(isWipeAllowed);\n', '\n', '        payoutInvestors();\n', '\n', '        investorsInvested[0] = 0;\n', '        investorsCount = 1;\n', '\n', '        totalInvestmentAmount = 0;\n', '        bankAmount = 0;\n', '        feeAmount = 0;\n', '        depositsCount = 0;\n', '\n', '        // Stage vars update\n', '        currentStage = 1;\n', '        stageStartTime = now;\n', '        stageMin = 0;\n', '        stageMax = 72;\n', '\n', '        curIteration += 1;\n', '\n', '        emit EvNewIteration(curIteration);\n', '\n', '        uint256 realBalance = address(this).balance - (jackpotBalance * toGwei);\n', '        if (realBalance > 0) {\n', '          aOwner.transfer(realBalance);\n', '        }\n', '    }\n', '\n', '    function updateBankAmount() public onlyOwner payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '\n', '        uint256 amount = msg.value / toGwei;\n', '\n', '        isWipeAllowed = false;\n', '\n', '        bankAmount += amount;\n', '        totalInvestmentAmount += amount;\n', '\n', '        emit EvUpdateBankAmount(curIteration, amount, bankAmount);\n', '\n', '        recalcInvestorsFee(msg.sender, amount);\n', '    }\n', '\n', '    function newInvestment() public payable {\n', '        require(msg.value >= minInvestmentAmount && msg.sender != address(0));\n', '\n', '        address sender = msg.sender;\n', '        uint256 investmentAmount = msg.value / toGwei; // convert to gwei\n', '\n', '        addInvestment(sender, investmentAmount);\n', '    }\n', '\n', '    /* Payout */\n', '    function depositPayout(uint depositIndex, uint pAmount) public onlyOwner returns(bool) {\n', '        require(depositIndex < depositsCount && depositIndex >= 0 && depContractidToAmount[depositIndex] > 0);\n', '        require(pAmount <= 5);\n', '\n', '        uint256 payoutAmount = depContractidToAmount[depositIndex];\n', '        payoutAmount += (payoutAmount * pAmount) / 100;\n', '\n', '        if (payoutAmount > bankAmount) {\n', '            isWipeAllowed = true;\n', '            // event payment not enaught bank amount\n', '            emit EvBankBecomeEmpty(curIteration, depositIndex, depContractidToAddress[depositIndex], payoutAmount, bankAmount);\n', '            return false;\n', '        }\n', '\n', '        uint256 ownerComission = (payoutAmount * ownerFeePercent) / 1000;\n', '        investorsEarned[0] += ownerComission;\n', '\n', '        uint256 addToJackpot = (payoutAmount * jackpotPercent) / 1000;\n', '        jackpotBalance += addToJackpot;\n', '\n', '        uint256 investorsComission = (payoutAmount * investorsFeePercent) / 1000;\n', '\n', '        uint256 payoutComission = ownerComission + addToJackpot + investorsComission;\n', '\n', '        uint256 paymentAmount = payoutAmount - payoutComission;\n', '\n', '        bankAmount -= payoutAmount;\n', '        feeAmount += ownerComission + investorsComission;\n', '\n', '        emit EvDepositPayout(curIteration, bankAmount, depositIndex, depContractidToAddress[depositIndex], paymentAmount, payoutComission, jackpotBalance);\n', '\n', '        updateInvestorsComission(investorsComission);\n', '\n', '        depContractidToAmount[depositIndex] = 0;\n', '\n', '        paymentAmount *= toGwei; // get back to wei\n', '        depContractidToAddress[depositIndex].transfer(paymentAmount);\n', '\n', '        if (depContractidToLottery[depositIndex]) {\n', '            lottery(depContractidToAddress[depositIndex], depositIndex);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Payout to investors */\n', '    function payoutInvestors() public {\n', '        uint256 paymentAmount = 0;\n', '        bool isSuccess = false;\n', '\n', '        uint256[] memory payouts = new uint256[](investorsCount);\n', '        bool[] memory statuses = new bool[](investorsCount);\n', '\n', '        uint256 mFeeAmount = feeAmount;\n', '        uint256 iteration = curIteration;\n', '\n', '        for (uint256 i = 0; i < investorsCount; i++) {\n', '            uint256 iEarned = investorsEarned[i];\n', '            if (iEarned == 0) {\n', '                continue;\n', '            }\n', '            paymentAmount = iEarned * toGwei; // get back to wei\n', '\n', '            mFeeAmount -= iEarned;\n', '            investorsEarned[i] = 0;\n', '\n', '            isSuccess = investorsAddress[i].send(paymentAmount);\n', '            payouts[i] = iEarned;\n', '            statuses[i] = isSuccess;\n', '\n', '\n', '        }\n', '        emit EvInvestorsPayout(iteration, bankAmount, payouts, statuses);\n', '\n', '        feeAmount = mFeeAmount;\n', '    }\n', '\n', '    /* Payout to investor */\n', '    function payoutInvestor(uint256 investorId) public {\n', '        require (investorId < investorsCount && investorsEarned[investorId] > 0);\n', '\n', '        uint256 paymentAmount = investorsEarned[investorId] * toGwei; // get back to wei\n', '        feeAmount -= investorsEarned[investorId];\n', '        investorsEarned[investorId] = 0;\n', '\n', '        bool isSuccess = investorsAddress[investorId].send(paymentAmount);\n', '\n', '        emit EvInvestorPayout(curIteration, bankAmount, investorId, paymentAmount, isSuccess);\n', '    }\n', '\n', '    /* Helper function to check sender */\n', '    function confirmAddress(bytes16 code) public {\n', '        emit EvConfimAddress(msg.sender, code);\n', '    }\n', '\n', '    /* Show depositers and investors info */\n', '    function depositInfo(uint256 contractId) view public returns(address _address, uint256 _amount, bool _participateInLottery) {\n', '      return (depContractidToAddress[contractId], depContractidToAmount[contractId] * toGwei, depContractidToLottery[contractId]);\n', '    }\n', '\n', '    /* Show investors info by id */\n', '    function investorInfo(uint256 contractId) view public returns(\n', '        address _address, uint256 _invested, uint256 _comissionPercent, uint256 earned\n', '    )\n', '    {\n', '      return (investorsAddress[contractId], investorsInvested[contractId] * toGwei,\n', '        investorsComissionPercent[contractId], investorsEarned[contractId] * toGwei);\n', '    }\n', '\n', '    function showBankAmount() view public returns(uint256 _bankAmount) {\n', '      return bankAmount * toGwei;\n', '    }\n', '\n', '    function showInvestorsComission() view public returns(uint256 _investorsComission) {\n', '      return feeAmount * toGwei;\n', '    }\n', '\n', '    function showJackpotBalance() view public returns(uint256 _jackpotBalance) {\n', '      return jackpotBalance * toGwei;\n', '    }\n', '\n', '    function showStats() view public returns(\n', '        uint256 _ownerFeePercent, uint256 _investorsFeePercent, uint256 _jackpotPercent,\n', '        uint256 _minDepositAmount, uint256 _minLotteryAmount,uint256 _minInvestmentAmount,\n', '        string info\n', '      )\n', '    {\n', '      return (ownerFeePercent, investorsFeePercent, jackpotPercent,\n', '        minDepositAmount * toGwei, minLotteryAmount * toGwei, minInvestmentAmount,\n', '        &#39;To get real percentages divide them to 10&#39;);\n', '    }\n', '\n', '    /* Function to change variables */\n', '    function updateJackpotBalance() public onlyOwner payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '        jackpotBalance += msg.value / toGwei;\n', '        emit EvUpdateJackpot(curIteration, msg.value, jackpotBalance);\n', '    }\n', '\n', '    /* Allow withdraw jackpot only if there are no transactions more then month*/\n', '    function withdrawJackpotBalance(uint amount) public onlyOwner {\n', '        require(jackpotBalance >= amount / toGwei && msg.sender != address(0));\n', '        // withdraw jacpot if no one dont play more then month\n', '        require(now - lastTransaction > 4 weeks);\n', '\n', '        uint256 tmpJP = amount / toGwei;\n', '        jackpotBalance -= tmpJP;\n', '\n', '        // Lottery payment\n', '        aOwner.transfer(amount);\n', '        emit EvUpdateJackpot(curIteration, amount, jackpotBalance);\n', '    }\n', '\n', '    /*--------------- private methods -----------------*/\n', '    function newDeposit(address _address, uint depositAmount) private {\n', '        uint256 randMulti = random(100) + 200;\n', '        uint256 rndX = random(1480);\n', '        uint256 _time = getRandomTime(rndX);\n', '\n', '        // Check is depositer hit the bonus number. Else return old multiplier.\n', '        randMulti = checkForBonuses(rndX, randMulti);\n', '\n', '        uint256 contractid = depositsCount;\n', '\n', '        depContractidToAddress[contractid] = _address;\n', '        depContractidToAmount[contractid] = (depositAmount * randMulti) / 100;\n', '        depContractidToLottery[contractid] = depositAmount >= minLotteryAmount;\n', '\n', '        depositsCount++;\n', '\n', '        bankAmount += depositAmount;\n', '\n', '        emit EvNewDeposit(curIteration, bankAmount, contractid, _address, depositAmount, randMulti, _time);\n', '    }\n', '\n', '    function addInvestment(address sender, uint256 investmentAmount) private {\n', '        require( (totalInvestmentAmount < totalInvestmentAmount + investmentAmount) && (bankAmount < bankAmount + investmentAmount) );\n', '        totalInvestmentAmount += investmentAmount;\n', '        bankAmount += investmentAmount;\n', '\n', '        recalcInvestorsFee(sender, investmentAmount);\n', '    }\n', '\n', '    function recalcInvestorsFee(address sender, uint256 investmentAmount) private {\n', '        uint256 investorIndex = 0;\n', '        bool isNewInvestor = true;\n', '        uint256 investorFeePercent = 0;\n', '        uint256[] memory investorsFee = new uint256[](investorsCount+1);\n', '\n', '        for (uint256 i = 0; i < investorsCount; i++) {\n', '            if (investorsAddress[i] == sender) {\n', '                investorIndex = i;\n', '                isNewInvestor = false;\n', '                investorsInvested[i] += investmentAmount;\n', '            }\n', '\n', '            investorFeePercent = percent(investorsInvested[i], totalInvestmentAmount, 3);\n', '            investorsComissionPercent[i] = investorFeePercent;\n', '            investorsFee[i] = investorFeePercent;\n', '        }\n', '\n', '        if (isNewInvestor) {\n', '            if (investorsCount > investorsCountLimit) revert(); // Limit investors count\n', '\n', '            investorFeePercent = percent(investmentAmount, totalInvestmentAmount, 3);\n', '            investorIndex = investorsCount;\n', '\n', '            investorsAddress[investorIndex] = sender;\n', '            investorsInvested[investorIndex] = investmentAmount;\n', '            investorsComissionPercent[investorIndex] = investorFeePercent;\n', '\n', '            investorsEarned[investorIndex] = 0;\n', '            investorsFee[investorIndex] = investorFeePercent;\n', '\n', '            investorsCount++;\n', '        }\n', '\n', '        emit EvNewInvestment(curIteration, bankAmount, investorIndex, sender, investmentAmount, investorsFee);\n', '    }\n', '\n', '    function updateInvestorsComission(uint256 amount) private {\n', '        uint256 investorsTotalIncome = 0;\n', '        uint256[] memory investorsComission = new uint256[](investorsCount);\n', '\n', '        for (uint256 i = 1; i < investorsCount; i++) {\n', '            uint256 investorIncome = (amount * investorsComissionPercent[i]) / 1000;\n', '\n', '            investorsEarned[i] += investorIncome;\n', '            investorsComission[i] = investorsEarned[i];\n', '\n', '            investorsTotalIncome += investorIncome;\n', '        }\n', '\n', '        investorsEarned[0] += amount - investorsTotalIncome;\n', '\n', '        emit EvInvestorsComission(curIteration, investorsComission);\n', '    }\n', '\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns(uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '\n', '        return (_quotient);\n', '    }\n', '\n', '    function random(uint numMax) private returns (uint256 result) {\n', '        _seed = uint256(keccak256(abi.encodePacked(\n', '            _seed,\n', '            blockhash(block.number - 1),\n', '            block.coinbase,\n', '            block.difficulty\n', '        )));\n', '\n', '        return _seed % numMax;\n', '    }\n', '\n', '    function getRandomTime(uint num) private returns (uint256 result) {\n', '        uint rndHours = random(68) + 4;\n', '        result = 72 - (2 ** ((num + 240) / 60) + 240) % rndHours;\n', '        checkStageCondition();\n', '        result = numStageRecalc(result);\n', '\n', '        return (result < 4) ? 4 : result;\n', '    }\n', '\n', '    function checkForBonuses(uint256 number, uint256 multiplier) private pure returns (uint256 newMultiplier) {\n', '        if (number == 8) return 1000;\n', '        if (number == 12) return 900;\n', '        if (number == 25) return 800;\n', '        if (number == 37) return 700;\n', '        if (number == 42) return 600;\n', '        if (number == 51) return 500;\n', '        if (number == 63 || number == 65 || number == 67) {\n', '            return 400;\n', '        }\n', '\n', '        return multiplier;\n', '    }\n', '\n', '    /*\n', '    * Check for time of current stage, in case of timeDiff bigger then stage time\n', '    * new stage states set.\n', '    */\n', '    function checkStageCondition() private {\n', '        uint timeDiff = now - stageStartTime;\n', '\n', '        if (timeDiff > stageTime && currentStage < 3) {\n', '            currentStage++;\n', '            stageMin += 10;\n', '            stageMax -= 10;\n', '            stageStartTime = now;\n', '            emit EvStageChanged(curIteration, timeDiff, currentStage);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Recalculate hours regarding current stage and counting chance of bonus.\n', '    */\n', '    function numStageRecalc(uint256 curHours) private returns (uint256 result) {\n', '        uint chance = random(110) + 1;\n', '        if (currentStage > 1 && chance % 9 != 0) {\n', '            if (curHours > stageMax) return stageMax;\n', '            if (curHours < stageMin) return stageMin;\n', '        }\n', '\n', '        return curHours;\n', '    }\n', '\n', '    /*\n', '    * Lottery main function\n', '    */\n', '    function lottery(address sender, uint256 index) private {\n', '        bool lotteryWin = false;\n', '        uint256[] memory lotteryNumbers = new uint256[](7);\n', '\n', '        (lotteryWin, lotteryNumbers) = randomizerLottery(blockhash(block.number - 1), sender);\n', '\n', '        emit EvLotteryNumbers(curIteration, index, lotteryNumbers);\n', '\n', '        if (lotteryWin) {\n', '          emit EvLotteryWin(curIteration, index, sender, jackpotBalance);\n', '          uint256 tmpJP = jackpotBalance * toGwei; // get back to wei\n', '          jackpotBalance = 0;\n', '\n', '          // Lottery payment\n', '          sender.transfer(tmpJP);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Lottery generator numbers by given hash.\n', '    */\n', '    function randomizerLottery(bytes32 hash, address sender) private returns(bool, uint256[] memory) {\n', '        uint256[] memory lotteryNumbers = new uint256[](7);\n', '        bytes32 userHash  = keccak256(abi.encodePacked(\n', '            hash,\n', '            sender,\n', '            random(999)\n', '        ));\n', '        bool win = true;\n', '\n', '        for (uint i = 0; i < 7; i++) {\n', '            uint position = i + random(1);\n', '            bytes1 charAtPos = charAt(userHash, position);\n', '            uint8 firstNums = getLastN(charAtPos, 4);\n', '            uint firstNumInt = uint(firstNums);\n', '\n', '            if (firstNumInt > 9) {\n', '                firstNumInt = 16 - firstNumInt;\n', '            }\n', '\n', '            lotteryNumbers[i] = firstNumInt;\n', '\n', '            if (firstNums != 7) {\n', '                win = false;\n', '            }\n', '        }\n', '\n', '        return (win, lotteryNumbers);\n', '    }\n', '\n', '    function charAt(bytes32 b, uint char) private pure returns (bytes1) {\n', '        return bytes1(uint8(uint(b) / (2**((31 - char) * 8))));\n', '    }\n', '\n', '    function getLastN(bytes1 a, uint8 n) private pure returns (uint8) {\n', '        uint8 lastN = uint8(a) % uint8(2) ** n;\n', '        return lastN;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Owned {\n', '    address public aOwner;\n', '    address public coOwner1;\n', '    address public coOwner2;\n', '\n', '    constructor() public {\n', '        aOwner = msg.sender;\n', '        coOwner1 = msg.sender;\n', '        coOwner2 = msg.sender;\n', '    }\n', '\n', '    /* Modifiers */\n', '    modifier onlyOwner {\n', '        require(msg.sender == aOwner || msg.sender == coOwner1 || msg.sender == coOwner2);\n', '        _;\n', '    }\n', '\n', '    function setCoOwner1(address _coOwner) public onlyOwner {\n', '      coOwner1 = _coOwner;\n', '    }\n', '\n', '    function setCoOwner2(address _coOwner) public onlyOwner {\n', '      coOwner2 = _coOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract XEther is Owned {\n', '    /* Structurs and variables */\n', '    uint256 public totalInvestmentAmount = 0;\n', '    uint256 public ownerFeePercent = 50; // 5%\n', '    uint256 public investorsFeePercent = 130; // 13%\n', '\n', '    uint256 public curIteration = 1;\n', '\n', '    uint256 public depositsCount = 0;\n', '    uint256 public investorsCount = 1;\n', '\n', '    uint256 public bankAmount = 0;\n', '    uint256 public feeAmount = 0;\n', '\n', '    uint256 public toGwei = 1000000000; // or 1e9, helper vars\n', '    uint256 public minDepositAmount = 20000000; // minimum deposit\n', '    uint256 public minLotteryAmount = 100000000; // minimum to participate in lottery\n', '    uint256 public minInvestmentAmount = 5 ether; // min for investment\n', '\n', '    bool public isWipeAllowed = true; // wipe only if bank almost became empty\n', '    uint256 public investorsCountLimit = 7; // maximum investors\n', '    uint256 public lastTransaction = now;\n', '\n', '    // Stage variables\n', '    uint256 private stageStartTime = now;\n', '    uint private currentStage = 1;\n', '    uint private stageTime = 86400; // time of stage in minutes\n', '    uint private stageMin = 0;\n', '    uint private stageMax = 72;\n', '\n', '    // lottery\n', '    uint256 public jackpotBalance = 0;\n', '    uint256 public jackpotPercent = 20; // 2%\n', '\n', '    uint256 _seed;\n', '\n', '    // Deposits mapping\n', '    mapping(uint256 => address) public depContractidToAddress;\n', '    mapping(uint256 => uint256) public depContractidToAmount;\n', '    mapping(uint256 => bool) public depContractidToLottery;\n', '\n', '    // Investors mapping\n', '    mapping(uint256 => address) public investorsAddress;\n', '    mapping(uint256 => uint256) public investorsInvested;\n', '    mapping(uint256 => uint256) public investorsComissionPercent;\n', '    mapping(uint256 => uint256) public investorsEarned;\n', '\n', '    /* Events */\n', '    event EvDebug (\n', '        uint amount\n', '    );\n', '\n', '    /* New income transaction*/\n', '    event EvNewDeposit (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address sender,\n', '        uint256 amount,\n', '        uint256 multiplier,\n', '        uint256 time\n', '    );\n', '\n', '    /* New investment added */\n', '    event EvNewInvestment (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address sender,\n', '        uint256 amount,\n', '        uint256[] investorsFee\n', '    );\n', '\n', '    /* Collect investors earned, when some one get payment */\n', '    event EvInvestorsComission (\n', '        uint256 iteration,\n', '        uint256[] investorsComission\n', '    );\n', '\n', '    /* Bank amount increased */\n', '    event EvUpdateBankAmount (\n', '        uint256 iteration,\n', '        uint256 deposited,\n', '        uint256 balance\n', '    );\n', '\n', '    /* Payout for deposit */\n', '    event EvDepositPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        address receiver,\n', '        uint256 amount,\n', '        uint256 fee,\n', '        uint256 jackpotBalance\n', '    );\n', '\n', '    /* newIteration */\n', '    event EvNewIteration (\n', '        uint256 iteration\n', '    );\n', '\n', '    /* No more funds in the bank, need actions (e.g. new iteration) */\n', '    event EvBankBecomeEmpty (\n', '        uint256 iteration,\n', '        uint256 index,\n', '        address receiver,\n', '        uint256 payoutAmount,\n', '        uint256 bankAmount\n', '    );\n', '\n', '    /* Investor get payment */\n', '    event EvInvestorPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256 index,\n', '        uint256 amount,\n', '        bool status\n', '    );\n', '\n', '    /* Investors get payment */\n', '    event EvInvestorsPayout (\n', '        uint256 iteration,\n', '        uint256 bankAmount,\n', '        uint256[] payouts,\n', '        bool[] statuses\n', '    );\n', '\n', '    /* New stage - time of withdraw is tapered */\n', '    event EvStageChanged (\n', '        uint256 iteration,\n', '        uint timeDiff,\n', '        uint stage\n', '    );\n', '\n', '    /* Lottery numbers */\n', '    event EvLotteryWin (\n', '        uint256 iteration,\n', '        uint256 contractId,\n', '        address winer,\n', '        uint256 amount\n', '    );\n', '\n', '    /* Check address with code*/\n', '    event EvConfimAddress (\n', '        address sender,\n', '        bytes16 code\n', '    );\n', '\n', '    /* Lottery numbers */\n', '    event EvLotteryNumbers (\n', '        uint256 iteration,\n', '        uint256 index,\n', '        uint256[] lotteryNumbers\n', '    );\n', '\n', '    /* Manually update Jackpot amount */\n', '    event EvUpdateJackpot (\n', '        uint256 iteration,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /*---------- constructor ------------*/\n', '    constructor() public {\n', '        investorsAddress[0] = aOwner;\n', '        investorsInvested[0] = 0;\n', '        investorsComissionPercent[0] = 0;\n', '        investorsEarned[0] = 0;\n', '    }\n', '\n', '    /*--------------- public methods -----------------*/\n', '    function() public payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '\n', '        uint256 amount = msg.value / toGwei; // convert to gwei\n', '\n', '        if (amount >= minDepositAmount) {\n', '            lastTransaction = block.timestamp;\n', '            newDeposit(msg.sender, amount);\n', '        }\n', '        else {\n', '            bankAmount += amount;\n', '        }\n', '    }\n', '\n', '    function newIteration() public onlyOwner {\n', '        require(isWipeAllowed);\n', '\n', '        payoutInvestors();\n', '\n', '        investorsInvested[0] = 0;\n', '        investorsCount = 1;\n', '\n', '        totalInvestmentAmount = 0;\n', '        bankAmount = 0;\n', '        feeAmount = 0;\n', '        depositsCount = 0;\n', '\n', '        // Stage vars update\n', '        currentStage = 1;\n', '        stageStartTime = now;\n', '        stageMin = 0;\n', '        stageMax = 72;\n', '\n', '        curIteration += 1;\n', '\n', '        emit EvNewIteration(curIteration);\n', '\n', '        uint256 realBalance = address(this).balance - (jackpotBalance * toGwei);\n', '        if (realBalance > 0) {\n', '          aOwner.transfer(realBalance);\n', '        }\n', '    }\n', '\n', '    function updateBankAmount() public onlyOwner payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '\n', '        uint256 amount = msg.value / toGwei;\n', '\n', '        isWipeAllowed = false;\n', '\n', '        bankAmount += amount;\n', '        totalInvestmentAmount += amount;\n', '\n', '        emit EvUpdateBankAmount(curIteration, amount, bankAmount);\n', '\n', '        recalcInvestorsFee(msg.sender, amount);\n', '    }\n', '\n', '    function newInvestment() public payable {\n', '        require(msg.value >= minInvestmentAmount && msg.sender != address(0));\n', '\n', '        address sender = msg.sender;\n', '        uint256 investmentAmount = msg.value / toGwei; // convert to gwei\n', '\n', '        addInvestment(sender, investmentAmount);\n', '    }\n', '\n', '    /* Payout */\n', '    function depositPayout(uint depositIndex, uint pAmount) public onlyOwner returns(bool) {\n', '        require(depositIndex < depositsCount && depositIndex >= 0 && depContractidToAmount[depositIndex] > 0);\n', '        require(pAmount <= 5);\n', '\n', '        uint256 payoutAmount = depContractidToAmount[depositIndex];\n', '        payoutAmount += (payoutAmount * pAmount) / 100;\n', '\n', '        if (payoutAmount > bankAmount) {\n', '            isWipeAllowed = true;\n', '            // event payment not enaught bank amount\n', '            emit EvBankBecomeEmpty(curIteration, depositIndex, depContractidToAddress[depositIndex], payoutAmount, bankAmount);\n', '            return false;\n', '        }\n', '\n', '        uint256 ownerComission = (payoutAmount * ownerFeePercent) / 1000;\n', '        investorsEarned[0] += ownerComission;\n', '\n', '        uint256 addToJackpot = (payoutAmount * jackpotPercent) / 1000;\n', '        jackpotBalance += addToJackpot;\n', '\n', '        uint256 investorsComission = (payoutAmount * investorsFeePercent) / 1000;\n', '\n', '        uint256 payoutComission = ownerComission + addToJackpot + investorsComission;\n', '\n', '        uint256 paymentAmount = payoutAmount - payoutComission;\n', '\n', '        bankAmount -= payoutAmount;\n', '        feeAmount += ownerComission + investorsComission;\n', '\n', '        emit EvDepositPayout(curIteration, bankAmount, depositIndex, depContractidToAddress[depositIndex], paymentAmount, payoutComission, jackpotBalance);\n', '\n', '        updateInvestorsComission(investorsComission);\n', '\n', '        depContractidToAmount[depositIndex] = 0;\n', '\n', '        paymentAmount *= toGwei; // get back to wei\n', '        depContractidToAddress[depositIndex].transfer(paymentAmount);\n', '\n', '        if (depContractidToLottery[depositIndex]) {\n', '            lottery(depContractidToAddress[depositIndex], depositIndex);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Payout to investors */\n', '    function payoutInvestors() public {\n', '        uint256 paymentAmount = 0;\n', '        bool isSuccess = false;\n', '\n', '        uint256[] memory payouts = new uint256[](investorsCount);\n', '        bool[] memory statuses = new bool[](investorsCount);\n', '\n', '        uint256 mFeeAmount = feeAmount;\n', '        uint256 iteration = curIteration;\n', '\n', '        for (uint256 i = 0; i < investorsCount; i++) {\n', '            uint256 iEarned = investorsEarned[i];\n', '            if (iEarned == 0) {\n', '                continue;\n', '            }\n', '            paymentAmount = iEarned * toGwei; // get back to wei\n', '\n', '            mFeeAmount -= iEarned;\n', '            investorsEarned[i] = 0;\n', '\n', '            isSuccess = investorsAddress[i].send(paymentAmount);\n', '            payouts[i] = iEarned;\n', '            statuses[i] = isSuccess;\n', '\n', '\n', '        }\n', '        emit EvInvestorsPayout(iteration, bankAmount, payouts, statuses);\n', '\n', '        feeAmount = mFeeAmount;\n', '    }\n', '\n', '    /* Payout to investor */\n', '    function payoutInvestor(uint256 investorId) public {\n', '        require (investorId < investorsCount && investorsEarned[investorId] > 0);\n', '\n', '        uint256 paymentAmount = investorsEarned[investorId] * toGwei; // get back to wei\n', '        feeAmount -= investorsEarned[investorId];\n', '        investorsEarned[investorId] = 0;\n', '\n', '        bool isSuccess = investorsAddress[investorId].send(paymentAmount);\n', '\n', '        emit EvInvestorPayout(curIteration, bankAmount, investorId, paymentAmount, isSuccess);\n', '    }\n', '\n', '    /* Helper function to check sender */\n', '    function confirmAddress(bytes16 code) public {\n', '        emit EvConfimAddress(msg.sender, code);\n', '    }\n', '\n', '    /* Show depositers and investors info */\n', '    function depositInfo(uint256 contractId) view public returns(address _address, uint256 _amount, bool _participateInLottery) {\n', '      return (depContractidToAddress[contractId], depContractidToAmount[contractId] * toGwei, depContractidToLottery[contractId]);\n', '    }\n', '\n', '    /* Show investors info by id */\n', '    function investorInfo(uint256 contractId) view public returns(\n', '        address _address, uint256 _invested, uint256 _comissionPercent, uint256 earned\n', '    )\n', '    {\n', '      return (investorsAddress[contractId], investorsInvested[contractId] * toGwei,\n', '        investorsComissionPercent[contractId], investorsEarned[contractId] * toGwei);\n', '    }\n', '\n', '    function showBankAmount() view public returns(uint256 _bankAmount) {\n', '      return bankAmount * toGwei;\n', '    }\n', '\n', '    function showInvestorsComission() view public returns(uint256 _investorsComission) {\n', '      return feeAmount * toGwei;\n', '    }\n', '\n', '    function showJackpotBalance() view public returns(uint256 _jackpotBalance) {\n', '      return jackpotBalance * toGwei;\n', '    }\n', '\n', '    function showStats() view public returns(\n', '        uint256 _ownerFeePercent, uint256 _investorsFeePercent, uint256 _jackpotPercent,\n', '        uint256 _minDepositAmount, uint256 _minLotteryAmount,uint256 _minInvestmentAmount,\n', '        string info\n', '      )\n', '    {\n', '      return (ownerFeePercent, investorsFeePercent, jackpotPercent,\n', '        minDepositAmount * toGwei, minLotteryAmount * toGwei, minInvestmentAmount,\n', "        'To get real percentages divide them to 10');\n", '    }\n', '\n', '    /* Function to change variables */\n', '    function updateJackpotBalance() public onlyOwner payable {\n', '        require(msg.value > 0 && msg.sender != address(0));\n', '        jackpotBalance += msg.value / toGwei;\n', '        emit EvUpdateJackpot(curIteration, msg.value, jackpotBalance);\n', '    }\n', '\n', '    /* Allow withdraw jackpot only if there are no transactions more then month*/\n', '    function withdrawJackpotBalance(uint amount) public onlyOwner {\n', '        require(jackpotBalance >= amount / toGwei && msg.sender != address(0));\n', '        // withdraw jacpot if no one dont play more then month\n', '        require(now - lastTransaction > 4 weeks);\n', '\n', '        uint256 tmpJP = amount / toGwei;\n', '        jackpotBalance -= tmpJP;\n', '\n', '        // Lottery payment\n', '        aOwner.transfer(amount);\n', '        emit EvUpdateJackpot(curIteration, amount, jackpotBalance);\n', '    }\n', '\n', '    /*--------------- private methods -----------------*/\n', '    function newDeposit(address _address, uint depositAmount) private {\n', '        uint256 randMulti = random(100) + 200;\n', '        uint256 rndX = random(1480);\n', '        uint256 _time = getRandomTime(rndX);\n', '\n', '        // Check is depositer hit the bonus number. Else return old multiplier.\n', '        randMulti = checkForBonuses(rndX, randMulti);\n', '\n', '        uint256 contractid = depositsCount;\n', '\n', '        depContractidToAddress[contractid] = _address;\n', '        depContractidToAmount[contractid] = (depositAmount * randMulti) / 100;\n', '        depContractidToLottery[contractid] = depositAmount >= minLotteryAmount;\n', '\n', '        depositsCount++;\n', '\n', '        bankAmount += depositAmount;\n', '\n', '        emit EvNewDeposit(curIteration, bankAmount, contractid, _address, depositAmount, randMulti, _time);\n', '    }\n', '\n', '    function addInvestment(address sender, uint256 investmentAmount) private {\n', '        require( (totalInvestmentAmount < totalInvestmentAmount + investmentAmount) && (bankAmount < bankAmount + investmentAmount) );\n', '        totalInvestmentAmount += investmentAmount;\n', '        bankAmount += investmentAmount;\n', '\n', '        recalcInvestorsFee(sender, investmentAmount);\n', '    }\n', '\n', '    function recalcInvestorsFee(address sender, uint256 investmentAmount) private {\n', '        uint256 investorIndex = 0;\n', '        bool isNewInvestor = true;\n', '        uint256 investorFeePercent = 0;\n', '        uint256[] memory investorsFee = new uint256[](investorsCount+1);\n', '\n', '        for (uint256 i = 0; i < investorsCount; i++) {\n', '            if (investorsAddress[i] == sender) {\n', '                investorIndex = i;\n', '                isNewInvestor = false;\n', '                investorsInvested[i] += investmentAmount;\n', '            }\n', '\n', '            investorFeePercent = percent(investorsInvested[i], totalInvestmentAmount, 3);\n', '            investorsComissionPercent[i] = investorFeePercent;\n', '            investorsFee[i] = investorFeePercent;\n', '        }\n', '\n', '        if (isNewInvestor) {\n', '            if (investorsCount > investorsCountLimit) revert(); // Limit investors count\n', '\n', '            investorFeePercent = percent(investmentAmount, totalInvestmentAmount, 3);\n', '            investorIndex = investorsCount;\n', '\n', '            investorsAddress[investorIndex] = sender;\n', '            investorsInvested[investorIndex] = investmentAmount;\n', '            investorsComissionPercent[investorIndex] = investorFeePercent;\n', '\n', '            investorsEarned[investorIndex] = 0;\n', '            investorsFee[investorIndex] = investorFeePercent;\n', '\n', '            investorsCount++;\n', '        }\n', '\n', '        emit EvNewInvestment(curIteration, bankAmount, investorIndex, sender, investmentAmount, investorsFee);\n', '    }\n', '\n', '    function updateInvestorsComission(uint256 amount) private {\n', '        uint256 investorsTotalIncome = 0;\n', '        uint256[] memory investorsComission = new uint256[](investorsCount);\n', '\n', '        for (uint256 i = 1; i < investorsCount; i++) {\n', '            uint256 investorIncome = (amount * investorsComissionPercent[i]) / 1000;\n', '\n', '            investorsEarned[i] += investorIncome;\n', '            investorsComission[i] = investorsEarned[i];\n', '\n', '            investorsTotalIncome += investorIncome;\n', '        }\n', '\n', '        investorsEarned[0] += amount - investorsTotalIncome;\n', '\n', '        emit EvInvestorsComission(curIteration, investorsComission);\n', '    }\n', '\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns(uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '\n', '        return (_quotient);\n', '    }\n', '\n', '    function random(uint numMax) private returns (uint256 result) {\n', '        _seed = uint256(keccak256(abi.encodePacked(\n', '            _seed,\n', '            blockhash(block.number - 1),\n', '            block.coinbase,\n', '            block.difficulty\n', '        )));\n', '\n', '        return _seed % numMax;\n', '    }\n', '\n', '    function getRandomTime(uint num) private returns (uint256 result) {\n', '        uint rndHours = random(68) + 4;\n', '        result = 72 - (2 ** ((num + 240) / 60) + 240) % rndHours;\n', '        checkStageCondition();\n', '        result = numStageRecalc(result);\n', '\n', '        return (result < 4) ? 4 : result;\n', '    }\n', '\n', '    function checkForBonuses(uint256 number, uint256 multiplier) private pure returns (uint256 newMultiplier) {\n', '        if (number == 8) return 1000;\n', '        if (number == 12) return 900;\n', '        if (number == 25) return 800;\n', '        if (number == 37) return 700;\n', '        if (number == 42) return 600;\n', '        if (number == 51) return 500;\n', '        if (number == 63 || number == 65 || number == 67) {\n', '            return 400;\n', '        }\n', '\n', '        return multiplier;\n', '    }\n', '\n', '    /*\n', '    * Check for time of current stage, in case of timeDiff bigger then stage time\n', '    * new stage states set.\n', '    */\n', '    function checkStageCondition() private {\n', '        uint timeDiff = now - stageStartTime;\n', '\n', '        if (timeDiff > stageTime && currentStage < 3) {\n', '            currentStage++;\n', '            stageMin += 10;\n', '            stageMax -= 10;\n', '            stageStartTime = now;\n', '            emit EvStageChanged(curIteration, timeDiff, currentStage);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Recalculate hours regarding current stage and counting chance of bonus.\n', '    */\n', '    function numStageRecalc(uint256 curHours) private returns (uint256 result) {\n', '        uint chance = random(110) + 1;\n', '        if (currentStage > 1 && chance % 9 != 0) {\n', '            if (curHours > stageMax) return stageMax;\n', '            if (curHours < stageMin) return stageMin;\n', '        }\n', '\n', '        return curHours;\n', '    }\n', '\n', '    /*\n', '    * Lottery main function\n', '    */\n', '    function lottery(address sender, uint256 index) private {\n', '        bool lotteryWin = false;\n', '        uint256[] memory lotteryNumbers = new uint256[](7);\n', '\n', '        (lotteryWin, lotteryNumbers) = randomizerLottery(blockhash(block.number - 1), sender);\n', '\n', '        emit EvLotteryNumbers(curIteration, index, lotteryNumbers);\n', '\n', '        if (lotteryWin) {\n', '          emit EvLotteryWin(curIteration, index, sender, jackpotBalance);\n', '          uint256 tmpJP = jackpotBalance * toGwei; // get back to wei\n', '          jackpotBalance = 0;\n', '\n', '          // Lottery payment\n', '          sender.transfer(tmpJP);\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Lottery generator numbers by given hash.\n', '    */\n', '    function randomizerLottery(bytes32 hash, address sender) private returns(bool, uint256[] memory) {\n', '        uint256[] memory lotteryNumbers = new uint256[](7);\n', '        bytes32 userHash  = keccak256(abi.encodePacked(\n', '            hash,\n', '            sender,\n', '            random(999)\n', '        ));\n', '        bool win = true;\n', '\n', '        for (uint i = 0; i < 7; i++) {\n', '            uint position = i + random(1);\n', '            bytes1 charAtPos = charAt(userHash, position);\n', '            uint8 firstNums = getLastN(charAtPos, 4);\n', '            uint firstNumInt = uint(firstNums);\n', '\n', '            if (firstNumInt > 9) {\n', '                firstNumInt = 16 - firstNumInt;\n', '            }\n', '\n', '            lotteryNumbers[i] = firstNumInt;\n', '\n', '            if (firstNums != 7) {\n', '                win = false;\n', '            }\n', '        }\n', '\n', '        return (win, lotteryNumbers);\n', '    }\n', '\n', '    function charAt(bytes32 b, uint char) private pure returns (bytes1) {\n', '        return bytes1(uint8(uint(b) / (2**((31 - char) * 8))));\n', '    }\n', '\n', '    function getLastN(bytes1 a, uint8 n) private pure returns (uint8) {\n', '        uint8 lastN = uint8(a) % uint8(2) ** n;\n', '        return lastN;\n', '    }\n', '}']
