['pragma solidity ^ 0.4.16;\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public constant returns(uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns(bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\n', '    function approve(address _spender, uint256 _value) public returns(bool success);\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract NBT is Token {\n', '\n', '    string public name;\n', '    uint256 public decimals;\n', '    string public symbol;\n', '    uint public startTime;\n', '    address public Short;\n', '    address public Long;\n', '    address public Team;\n', '    address public Reward;\n', '    address public Investment;\n', '    address public Foundation;\n', '    constructor(string _tokenName, string _tokenSymbol, address tempTeam, address tempReward, address tempInvestment, address tempFoundation) public {\n', '        name = _tokenName;\n', '        decimals = 18;\n', '        symbol = _tokenSymbol;\n', '        totalSupply = 1000000000 * 10 **uint256(decimals);\n', '        startTime = now;\n', '        Team = tempTeam;\n', '        Reward = tempReward;\n', '        Investment = tempInvestment;\n', '        Foundation = tempFoundation;\n', '\n', '        balances[Team] = totalSupply * 2 / 10;\n', '        balances[Reward] = totalSupply * 3 / 10;\n', '        balances[Investment] = totalSupply * 3 / 10;\n', '        balances[Foundation] = totalSupply * 2 / 10;\n', '        emit Transfer(0x0, Team, 200000000 * 10 **uint256(decimals));\n', '        emit Transfer(0x0, Reward, 300000000 * 10 **uint256(decimals));\n', '        emit Transfer(0x0, Investment, 300000000 * 10 **uint256(decimals));\n', '        emit Transfer(0x0, Foundation, 200000000 * 10 **uint256(decimals));\n', '    }\n', '\n', '\n', '    function setShort(address addr) public {\n', '        require(msg.sender == Investment);\n', '        Short = addr;\n', '    }\n', '\n', '\n', '    function setLong(address addr) public {\n', '        require(msg.sender == Investment);\n', '        Long = addr;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool success) {\n', '        if (msg.sender == Team) {\n', '            uint timeTemp = (now - startTime) / 60 / 60 / 24 / 100;\n', '            if (timeTemp > 10) {\n', '                timeTemp = 10;\n', '            }\n', '            require(balances[msg.sender] - _value >= (totalSupply / 5 - totalSupply * timeTemp / 50));\n', '            record(_to, _value);\n', '        }\n', '\n', '        if (msg.sender == Short) {\n', '            require(balances[msg.sender] >= _value);\n', '            record(_to, _value);\n', '        }\n', '\n', '        if (msg.sender == Long) {\n', '            require(balances[msg.sender] >= _value);\n', '            longRecord(_to, _value);\n', '        }\n', '\n', '        if (number[msg.sender] != 0) {\n', '            judge(_value, msg.sender);\n', '        }\n', '\n', '        if (longNumber[msg.sender] != 0) {\n', '            longJudge(_value, msg.sender);\n', '        }\n', '\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        require(_to != 0x0);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function record(address iniadr, uint256 account) private {\n', '        uint256[] storage T = time[iniadr];\n', '        T.push(now);\n', '        time[iniadr] = T;\n', '        uint256[] storage A = init[iniadr];\n', '        A.push(account);\n', '        init[iniadr] = A;\n', '        number[iniadr] = 1;\n', '    }\n', '\n', '    function longRecord(address iniadr, uint256 account) private {\n', '        uint256[] storage T = longTime[iniadr];\n', '        T.push(now);\n', '        longTime[iniadr] = T;\n', '        uint256[] storage A = longInit[iniadr];\n', '        A.push(account);\n', '        longInit[iniadr] = A;\n', '        longNumber[iniadr] = 1;\n', '    }\n', '\n', '    function judge(uint256 _value, address addr) private {\n', '        uint256[] storage T = time[addr];\n', '        uint256[] storage A = init[addr];\n', '        number[addr] = 0;\n', '        for (uint i = 0; i < T.length; i++) {\n', '            if (now < (T[i] + 100 days)) {\n', '                number[addr] += A[i];\n', '            }\n', '        }\n', '        require(balances[addr] - _value >= number[addr]);\n', '    }\n', '\n', '    function longJudge(uint256 _value, address addr) private {\n', '        uint256[] storage T = longTime[addr];\n', '        uint256[] storage A = longInit[addr];\n', '        longNumber[addr] = 0;\n', '        for (uint i = 0; i < T.length; i++) {\n', '            if (now < (T[i] + 1000 days)) {\n', '                longNumber[addr] += A[i];\n', '            }\n', '        }\n', '        require(balances[addr] - _value >= longNumber[addr]);\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function benchTransfer(address[] addr, uint256[] num) public {\n', '        require(addr.length == num.length);\n', '        for (uint i = 0; i < num.length; i++) {\n', '\n', '            transfer(addr[i], num[i] * 10 **uint256(decimals));\n', '        }\n', '    }\n', '\n', '    mapping(address =>uint256) balances;\n', '    mapping(address =>mapping(address =>uint256)) allowed;\n', '\n', '    mapping(address =>uint256[]) time;\n', '    mapping(address =>uint256[]) init;\n', '    mapping(address =>uint256) number;\n', '    mapping(address =>uint256[]) longTime;\n', '    mapping(address =>uint256[]) longInit;\n', '    mapping(address =>uint256) longNumber;\n', '}']