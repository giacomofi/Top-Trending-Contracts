['pragma solidity ^0.4.18;\n', '\n', 'contract DogCoreInterface {\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    function getDog(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        //冷却期索引号\n', '        uint256 cooldownIndex,\n', '        //本次冷却期结束所在区块\n', '        uint256 nextActionAt,\n', '        //配种的公狗ID\n', '        uint256 siringWithId,\n', '        //出生时间\n', '        uint256 birthTime,\n', '        //母亲ID\n', '        uint256 matronId,\n', '        //父亲ID\n', '        uint256 sireId,\n', '        //代数\n', '        uint256 generation,\n', '        //基因\n', '        uint256 genes,\n', '        //变异，0表示未变异，1-7表示变异\n', '        uint8  variation,\n', '        //0代祖先的ID\n', '        uint256 gen0\n', '    );\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function sendMoney(address _to, uint256 _money) external;\n', '    function totalSupply() external view returns (uint);\n', '}\n', '\n', '\n', '/*\n', '    LotteryBase 主要定义了开奖信息，奖金池转入函数以及判断是否开必中\n', '*/\n', 'contract LotteryBase {\n', '    \n', '    // 当前开奖基因位数\n', '    uint8 public currentGene;\n', '    // 当前开奖所在区块\n', '    uint256 public lastBlockNumber;\n', '    // 随机数种子\n', '    uint256 randomSeed = 1;\n', '    // 奖金池地址\n', '    address public bonusPool;\n', '    // 中奖信息\n', '    struct CLottery {\n', '        // 该期中奖基因\n', '        uint8[7]        luckyGenes;\n', '        // 该期奖金池总额\n', '        uint256         totalAmount;\n', '        // 该期第7个基因开奖所在区块\n', '        uint256         openBlock;\n', '        // 是否发奖完毕\n', '        bool            isReward;\n', '        // 未开一等奖标记\n', '        bool         noFirstReward;\n', '    }\n', '    // 历史开奖信息\n', '    CLottery[] public CLotteries;\n', '    // 发奖合约地址\n', '    address public finalLottery;\n', '    // 蓄奖池金额\n', '    uint256 public SpoolAmount = 0;\n', '    // 宠物信息接口\n', '    DogCoreInterface public dogCore;\n', '    // 随机开奖事件\n', '    event OpenLottery(uint8 currentGene, uint8 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);\n', '    //必中开奖事件\n', '    event OpenCarousel(uint256 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);\n', '    \n', '    \n', '    //\n', '    modifier onlyCEO() {\n', '        require(msg.sender == dogCore.ceoAddress());\n', '        _;  \n', '    }\n', '    //\n', '    modifier onlyCFO() {\n', '        require(msg.sender == dogCore.cfoAddress());\n', '        _;  \n', '    }\n', '    /*\n', '        蓄奖池转入奖金池函数\n', '    */\n', '    function toLotteryPool(uint amount) public onlyCFO {\n', '        require(SpoolAmount >= amount);\n', '        SpoolAmount -= amount;\n', '    }\n', '    /*\n', '    判断当期是否开必中\n', '    */\n', '    function _isCarousal(uint256 currentTerm) external view returns(bool) {\n', '       return (currentTerm > 1 && CLotteries[currentTerm - 2].noFirstReward && CLotteries[currentTerm - 1].noFirstReward); \n', '    }\n', '    \n', '    /*\n', '      返回当前期数\n', '    */ \n', '    function getCurrentTerm() external view returns (uint256) {\n', '\n', '        return (CLotteries.length - 1);\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    LotteryGenes主要实现奖宠物原始基因转化为兑奖数组\n', '*/\n', 'contract LotteryGenes is LotteryBase {\n', '    /*\n', '     将基因数字格式转换为抽奖数组格式\n', '    */\n', '    function convertGeneArray(uint256 gene) public pure returns(uint8[7]) {\n', '        uint8[28] memory geneArray; \n', '        uint8[7] memory lotteryArray;\n', '        uint index = 0;\n', '        for (index = 0; index < 28; index++) {\n', '            uint256 geneItem = gene % (2 ** (5 * (index + 1)));\n', '            geneItem /= (2 ** (5 * index));\n', '            geneArray[index] = uint8(geneItem);\n', '        }\n', '        for (index = 0; index < 7; index++) {\n', '            uint size = 4 * index;\n', '            lotteryArray[index] = geneArray[size];\n', '            \n', '        }\n', '        return lotteryArray;\n', '    }\n', '\n', '    /**\n', '       将显性基因串拼凑成原始基因数字\n', '    */ \n', '    function convertGene(uint8[7] luckyGenes) public pure returns(uint256) {\n', '        uint8[28] memory geneArray;\n', '        for (uint8 i = 0; i < 28; i++) {\n', '            if (i%4 == 0) {\n', '                geneArray[i] = luckyGenes[i/4];\n', '            } else {\n', '                geneArray[i] = 6;\n', '            }\n', '        }\n', '        uint256 gene = uint256(geneArray[0]);\n', '        \n', '        for (uint8 index = 1; index < 28; index++) {\n', '            uint256 geneItem = uint256(geneArray[index]);\n', '            gene += geneItem << (index * 5);\n', '        }\n', '        return gene;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    SetLottery主要实现了随机开奖和必中开奖\n', '*/\n', 'contract SetLottery is LotteryGenes {\n', '\n', '    function random(uint8 seed) internal returns(uint8) {\n', '        randomSeed = block.timestamp;\n', '        return uint8(uint256(keccak256(randomSeed, block.difficulty))%seed)+1;\n', '    }\n', '\n', '    /*\n', '     随机开奖函数，每一期开7次。\n', '     currentGene表示当期开奖的第N个基因\n', '     若当前currentGene指标为0，则表示在开奖期未开任何数字，或者开奖期已经开完了所有数字\n', '     当前开奖期最后一个基因开完后，记录当前所在区块号和当前奖金池金额\n', '     返回值分别为当前开奖基因(0代表不存在)、查询开奖基因(0代表不存在)、\n', '     开奖状态(0表示开奖成功，1表示当期开奖结束且在等待发奖，2表示当前基因开奖区块与上个基因开奖区块相同,3表示奖金池金额不足)\n', '     */\n', '    function openLottery(uint8 _viewId) public returns(uint8,uint8) {\n', '        uint8 viewId = _viewId;\n', '        require(viewId < 7);\n', '        // 获取当前中奖信息\n', '        uint256 currentTerm = CLotteries.length - 1;\n', '        CLottery storage clottery = CLotteries[currentTerm];\n', '\n', '        // 如果7个基因都完成开奖并且当期没有发奖，则说明当期所有基因已经开奖完毕在等待发奖，退出\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {\n', '            // 触发事件，返回查询的基因\n', '            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '            //分别返回查询基因，状态1 (表示当期所有基因开奖完毕在等待发奖)\n', '            return (clottery.luckyGenes[viewId],1);\n', '        }\n', '        // 如果上个基因开奖和本次开奖在同一个区块，退出\n', '        if (lastBlockNumber == block.number) {\n', '            // 触发事件，返回查询的基因\n', '            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '            //分别返回查询基因，状态2 (当前基因开奖区块与上个基因开奖区块相同)\n', '            return (clottery.luckyGenes[viewId],2);\n', '        }\n', '        // 如果当前开奖基因位为0且当期已经发奖，则进入下一期开奖\n', '        if (currentGene == 0 && clottery.isReward == true) {\n', '            // 初始化当前lottery信息\n', '            CLottery memory _clottery;\n', '            _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '            _clottery.totalAmount = uint256(0);\n', '            _clottery.isReward = false;\n', '            _clottery.openBlock = uint256(0);\n', '            currentTerm = CLotteries.push(_clottery) - 1;\n', '        }\n', '\n', '        // 如果前两期都没有一等奖产生，则该期产生必中奖，退出随机开奖函数\n', '        if (this._isCarousal(currentTerm)) {\n', '            revert();\n', '        }\n', '\n', '        //开奖结果\n', '        uint8 luckyNum = 0;\n', '        \n', '        if (currentGene == 6) {\n', '            // 如果奖金池金额为零，则退出\n', '            if (bonusPool.balance <= SpoolAmount) {\n', '                // 触发事件，返回查询的基因\n', '                OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '                //分别返回查询基因，状态3 (奖金池金额不足)\n', '                return (clottery.luckyGenes[viewId],3);\n', '            }\n', '            //将随机数赋值给当前基因\n', '            luckyNum = random(8);\n', '            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;\n', '            //触发开奖事件\n', '            OpenLottery(currentGene, luckyNum, currentTerm, block.number, bonusPool.balance);\n', '            //如果当前为最后一个开奖基因，则下一个开奖基因位为0，同时记录下当前区块号并写入开奖信息，同时将奖金池金额写入开奖信息, 同时启动主合约\n', '            currentGene = 0;\n', '            CLotteries[currentTerm].openBlock = block.number;\n', '            CLotteries[currentTerm].totalAmount = bonusPool.balance;\n', '            //记录当前开奖所在区块\n', '            lastBlockNumber = block.number;\n', '        } else { \n', '            //将随机数赋值给当前基因\n', '        \n', '            luckyNum = random(12);\n', '            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;\n', '\n', '            //触发开奖事件\n', '            OpenLottery(currentGene, luckyNum, currentTerm, 0, 0);\n', '            //其它情况下，下一个开奖基因位加1\n', '            currentGene ++;\n', '            //记录当前开奖所在区块\n', '            lastBlockNumber = block.number;\n', '        }\n', '        //分别返回开奖基因，查询基因和开奖成功状态\n', '        return (luckyNum,0);\n', '    } \n', '\n', '    function random2() internal view returns (uint256) {\n', '        return uint256(uint256(keccak256(block.timestamp, block.difficulty))%uint256(dogCore.totalSupply()) + 1);\n', '    }\n', '\n', '    /*\n', '     必中开奖函数,每期开一次\n', '    */\n', '    function openCarousel() public {\n', '        //获取当前开奖信息\n', '        uint256 currentTerm = CLotteries.length - 1;\n', '        CLottery storage clottery = CLotteries[currentTerm];\n', '\n', '        // 如果当前开奖基因指针为0且开奖基因存在，且未发奖，则说明当前基因开奖完毕，在等待发奖\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {\n', '\n', '            //触发开奖事件,返回当期现有开奖数据\n', '            OpenCarousel(convertGene(clottery.luckyGenes), currentTerm, clottery.openBlock, clottery.totalAmount);\n', '        }\n', '\n', '        // 如果开奖基因指针为0且开奖基因存在，并且发奖完毕，则进入下一开奖周期\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == true) {\n', '            CLottery memory _clottery;\n', '            _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '            _clottery.totalAmount = uint256(0);\n', '            _clottery.isReward = false;\n', '            _clottery.openBlock = uint256(0);\n', '            currentTerm = CLotteries.push(_clottery) - 1;\n', '        }\n', '\n', '        //期数大于3 且前三期未产生特等奖\n', '        require (this._isCarousal(currentTerm));\n', '        // 随机获取必中基因\n', '        uint256 genes = _getValidRandomGenes();\n', '        require (genes > 0);\n', '        uint8[7] memory luckyGenes = convertGeneArray(genes);\n', '        //触发开奖事件\n', '        OpenCarousel(genes, currentTerm, block.number, bonusPool.balance);\n', '\n', '        //写入记录\n', '        CLotteries[currentTerm].luckyGenes = luckyGenes;\n', '        CLotteries[currentTerm].openBlock = block.number;\n', '        CLotteries[currentTerm].totalAmount = bonusPool.balance;\n', '        \n', '    }\n', '    \n', '    /*\n', '      随机获取合法的必中基因\n', '    */\n', '    function _getValidRandomGenes() internal view returns (uint256) {\n', '        uint256 luckyDog = random2();\n', '        uint256 genes = _validGenes(luckyDog);\n', '        uint256 totalSupply = dogCore.totalSupply();\n', '        if (genes > 0) {\n', '            return genes;\n', '        }  \n', '        // 如果dog不能兑奖，则渐进振荡判断其它dog是否满足条件\n', '        uint256 min = (luckyDog < totalSupply-luckyDog) ? (luckyDog - 1) : totalSupply-luckyDog;\n', '        for (uint256 i = 1; i < min + 1; i++) {\n', '            genes = _validGenes(luckyDog - i);\n', '            if (genes > 0) {\n', '                break;\n', '            }\n', '            genes = _validGenes(luckyDog + i);\n', '            if (genes > 0) {\n', '                    break;\n', '                }\n', '            }\n', '            // min次震荡仍然未找到可兑奖基因\n', '        if (genes == 0) {\n', '            //luckyDog右侧更长\n', '            if (min == luckyDog - 1) {\n', '                for (i = min + luckyDog; i < totalSupply + 1; i++) {\n', '                        genes = _validGenes(i);\n', '                        if (genes > 0) {\n', '                            break;\n', '                        }\n', '                    }   \n', '                }\n', '            //luckyDog左侧更长\n', '            if (min == totalSupply - luckyDog) {\n', '                for (i = min; i < luckyDog; i++) {\n', '                        genes = _validGenes(luckyDog - i - 1);\n', '                        if (genes > 0) {\n', '                            break;\n', '                        }\n', '                    }   \n', '                }\n', '            }\n', '        return genes;\n', '    }\n', '\n', '\n', '    /*\n', '      判断狗是否能兑奖，能则直接返回狗的基因，不能则返回0\n', '    */\n', '    function _validGenes(uint256 dogId) internal view returns (uint256) {\n', '\n', '        var(, , , , , ,generation, genes, variation,) = dogCore.getDog(dogId);\n', '        if (generation == 0 || dogCore.ownerOf(dogId) == finalLottery || variation > 0) {\n', '            return 0;\n', '        } else {\n', '            return genes;\n', '        }\n', '    }\n', '\n', '    \n', '}\n', '\n', '/*\n', '  LotteryCore是开奖函数的入口合约\n', '  开奖包括必中开奖和随机开奖\n', '  同时LotteryCore提供对外查询接口\n', '*/\n', '\n', 'contract LotteryCore is SetLottery {\n', '    \n', '    // 构造函数，传入奖金池地址,初始化中奖信息\n', '    function LotteryCore(address _ktAddress) public {\n', '\n', '        bonusPool = _ktAddress;\n', '        dogCore = DogCoreInterface(_ktAddress);\n', '\n', '        //初始化中奖信息\n', '        CLottery memory _clottery;\n', '        _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '        _clottery.totalAmount = uint256(0);\n', '        _clottery.isReward = false;\n', '        _clottery.openBlock = uint256(0);\n', '        CLotteries.push(_clottery);\n', '    }\n', '    /*\n', '    设置FinalLottery地址\n', '    */\n', '    function setFinalLotteryAddress(address _flAddress) public onlyCEO {\n', '        finalLottery = _flAddress;\n', '    }\n', '    /*\n', '    获取当前中奖记录\n', '    */\n', '    function getCLottery() \n', '        public \n', '        view \n', '        returns (\n', '            uint8[7]        luckyGenes,\n', '            uint256         totalAmount,\n', '            uint256         openBlock,\n', '            bool            isReward,\n', '            uint256         term\n', '        ) {\n', '            term = CLotteries.length - uint256(1);\n', '            luckyGenes = CLotteries[term].luckyGenes;\n', '            totalAmount = CLotteries[term].totalAmount;\n', '            openBlock = CLotteries[term].openBlock;\n', '            isReward = CLotteries[term].isReward;\n', '    }\n', '\n', '    /*\n', '    更改发奖状态\n', '    */\n', '    function rewardLottery(bool isMore) external {\n', '        // require contract address is final lottery\n', '        require(msg.sender == finalLottery);\n', '\n', '        uint256 term = CLotteries.length - 1;\n', '        CLotteries[term].isReward = true;\n', '        CLotteries[term].noFirstReward = isMore;\n', '    }\n', '\n', '    /*\n', '    转入蓄奖池\n', '    */\n', '    function toSPool(uint amount) external {\n', '        // require contract address is final lottery\n', '        require(msg.sender == finalLottery);\n', '\n', '        SpoolAmount += amount;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    FinalLottery 包含兑奖函数和发奖函数\n', '    中奖信息flotteries存入开奖期数到[各等奖获奖者，各等奖中奖金额]的映射\n', '*/\n', 'contract FinalLottery {\n', '    bool public isLottery = true;\n', '    LotteryCore lotteryCore;\n', '    DogCoreInterface dogCore;\n', '    uint8[7] public luckyGenes;\n', '    uint256         totalAmount;\n', '    uint256         openBlock;\n', '    bool            isReward;\n', '    uint256         currentTerm;\n', '    uint256  public duration;\n', '    uint8   public  lotteryRatio;\n', '    uint8[7] public lotteryParam;\n', '    uint8   public  carousalRatio;\n', '    uint8[7] public carousalParam; \n', '    // 中奖信息\n', '    struct FLottery {\n', '        //  该期各等奖获奖者\n', '        //  一等奖\n', '        address[]        owners0;\n', '        uint256[]        dogs0;\n', '        //  二等奖\n', '        address[]        owners1;\n', '        uint256[]        dogs1;\n', '        //  三等奖\n', '        address[]        owners2;\n', '        uint256[]        dogs2;\n', '        //  四等奖\n', '        address[]        owners3;\n', '        uint256[]        dogs3;\n', '        //  五等奖\n', '        address[]        owners4;\n', '        uint256[]        dogs4;\n', '        //  六等奖\n', '        address[]        owners5;\n', '        uint256[]        dogs5;\n', '        //  七等奖\n', '        address[]        owners6;\n', '        uint256[]        dogs6;\n', '        // 中奖金额\n', '        uint256[]       reward;\n', '    }\n', '    // 兑奖发奖信息\n', '    mapping(uint256 => FLottery) flotteries;\n', '    // 构造函数\n', '    function FinalLottery(address _lcAddress) public {\n', '        lotteryCore = LotteryCore(_lcAddress);\n', '        dogCore = DogCoreInterface(lotteryCore.bonusPool());\n', '        duration = 11520;\n', '        lotteryRatio = 23;\n', '        lotteryParam = [46,16,10,9,8,6,5];\n', '        carousalRatio = 12;\n', '        carousalParam = [35,18,14,12,8,7,6];\n', '        \n', '    }\n', '    \n', '    // 发奖事件\n', '    event DistributeLottery(uint256[] rewardArray, uint256 currentTerm);\n', '    // 兑奖事件\n', '    event RegisterLottery(uint256 dogId, address owner, uint8 lotteryClass, string result);\n', '    // 设置兑奖周期\n', '    function setLotteryDuration(uint256 durationBlocks) public {\n', '        require(msg.sender == dogCore.ceoAddress());\n', '        require(durationBlocks > 140);\n', '        require(durationBlocks < block.number);\n', '        duration = durationBlocks;\n', '    }\n', '    /*\n', '     登记兑奖函数,发生在当期开奖结束之后7天内（即40，320个区块内）\n', '    */\n', '    function registerLottery(uint256 dogId) public returns (uint8) {\n', '        uint256 _dogId = dogId;\n', '        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();\n', '        // 获取当前开奖信息\n', '        address owner = dogCore.ownerOf(_dogId);\n', '        // 回收的不能兑奖\n', '        require (owner != address(this));\n', '        // 调用者必须是主合约\n', '        require(address(dogCore) == msg.sender);\n', '        // 所有基因位开奖完毕（指针为0同时奖金池大于0）且未发奖且未兑奖结束\n', '        require(totalAmount > 0 && isReward == false && openBlock > (block.number-duration));\n', '        // 获取该宠物的基因，代数，出生时间\n', '        var(, , , birthTime, , ,generation,genes, variation,) = dogCore.getDog(_dogId);\n', '        // 出生日期小于开奖时间\n', '        require(birthTime < openBlock);\n', '        // 0代狗不能兑奖\n', '        require(generation > 0);\n', '        // 变异的不能兑奖\n', '        require(variation == 0);\n', '        // 判断该用户获几等奖，100表示未中奖\n', '        uint8 _lotteryClass = getLotteryClass(luckyGenes, genes);\n', '        // 若未获奖则退出\n', '        require(_lotteryClass < 7);\n', '        // 避免重复兑奖\n', '        address[] memory owners;\n', '        uint256[] memory dogs;\n', '         (dogs, owners) = _getLuckyList(currentTerm, _lotteryClass);\n', '            \n', '        for (uint i = 0; i < dogs.length; i++) {\n', '            if (_dogId == dogs[i]) {\n', '            //    revert();\n', '                RegisterLottery(_dogId, owner, _lotteryClass,"dog already registered");\n', '                 return 5;\n', '            }\n', '        }\n', '        // 将登记中奖者的账户存入奖金信息表\n', '        _pushLuckyInfo(currentTerm, _lotteryClass, owner, _dogId);\n', '        // 触发兑奖成功事件\n', '        RegisterLottery(_dogId, owner, _lotteryClass,"successful");\n', '        return 0;\n', '    }\n', '    /*\n', '    发奖函数，发生在当期开奖结束之后\n', '    */\n', '    \n', '    function distributeLottery() public returns (uint8) {\n', '        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();\n', '        \n', '        // 必须在当期开奖结束一周之后发奖\n', '        require(openBlock > 0 && openBlock < (block.number-duration));\n', '\n', '        //奖金池可用金额必须大于或等于0\n', '        require(totalAmount >= lotteryCore.SpoolAmount());\n', '\n', '        // 如果已经发奖\n', '        if (isReward == true) {\n', '            DistributeLottery(flotteries[currentTerm].reward, currentTerm);\n', '            return 1;\n', '        }\n', '        uint256 legalAmount = totalAmount - lotteryCore.SpoolAmount();\n', '        uint256 totalDistribute = 0;\n', '        uint8[7] memory lR;\n', '        uint8 ratio;\n', '\n', '        // 必中和随机两种不同的奖金分配比率\n', '        if (lotteryCore._isCarousal(currentTerm) ) {\n', '            lR = carousalParam;\n', '            ratio = carousalRatio;\n', '        } else {\n', '            lR = lotteryParam;\n', '            ratio = lotteryRatio;\n', '        }\n', '        // 计算各奖项金额并分发给中奖者\n', '        for (uint8 i = 0; i < 7; i++) {\n', '            address[] memory owners;\n', '            uint256[] memory dogs;\n', '            (dogs, owners) = _getLuckyList(currentTerm, i);\n', '            if (owners.length > 0) {\n', '                    uint256 reward = (legalAmount * ratio * lR[i])/(10000 * owners.length);\n', '                    totalDistribute += reward * owners.length;\n', '                    // 转给CFO的手续费（10%）\n', '                    dogCore.sendMoney(dogCore.cfoAddress(),reward * owners.length/10);\n', '                    \n', '                    for (uint j = 0; j < owners.length; j++) {\n', '                        address gen0Add;\n', '                        if (i == 0) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*95*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*5/100);\n', '                        } else if (i == 1) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*97*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*3/100);\n', '                        } else if (i == 2) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*98*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*2/100);\n', '                        } else {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*9/10);\n', '                        }\n', '                    }\n', '                  // 记录各等奖发奖金额\n', '                    flotteries[currentTerm].reward.push(reward);  \n', '                } else {\n', '                    flotteries[currentTerm].reward.push(0); \n', '                } \n', '        }\n', '        //没有人登记一等奖中奖，将奖金池5%转入蓄奖池,并且更新无一等奖计数\n', '        if (flotteries[currentTerm].owners0.length == 0) {\n', '            lotteryCore.toSPool((lotteryCore.bonusPool().balance - lotteryCore.SpoolAmount())/20);\n', '            lotteryCore.rewardLottery(true);\n', '        } else {\n', '            //发奖完成之后，更新当前奖项状态、将当前奖项加入历史记录\n', '            lotteryCore.rewardLottery(false);\n', '        }\n', '        \n', '        DistributeLottery(flotteries[currentTerm].reward, currentTerm);\n', '        return 0;\n', '    }\n', '\n', '     /*\n', '    获取狗的gen0祖先的主人账户\n', '    */\n', '    function _getGen0Address(uint256 dogId) internal view returns(address) {\n', '        var(, , , , , , , , , gen0) = dogCore.getDog(dogId);\n', '        return dogCore.ownerOf(gen0);\n', '    }\n', '\n', '    /*\n', '      通过奖项等级获取中奖者列表和中奖狗列表\n', '    */\n', '    function _getLuckyList(uint256 currentTerm1, uint8 lotclass) public view returns (uint256[] kts, address[] ons) {\n', '        if (lotclass==0) {\n', '            ons = flotteries[currentTerm1].owners0;\n', '            kts = flotteries[currentTerm1].dogs0;\n', '        } else if (lotclass==1) {\n', '            ons = flotteries[currentTerm1].owners1;\n', '            kts = flotteries[currentTerm1].dogs1;\n', '        } else if (lotclass==2) {\n', '            ons = flotteries[currentTerm1].owners2;\n', '            kts = flotteries[currentTerm1].dogs2;\n', '        } else if (lotclass==3) {\n', '            ons = flotteries[currentTerm1].owners3;\n', '            kts = flotteries[currentTerm1].dogs3;\n', '        } else if (lotclass==4) {\n', '            ons = flotteries[currentTerm1].owners4;\n', '            kts = flotteries[currentTerm1].dogs4;\n', '        } else if (lotclass==5) {\n', '            ons = flotteries[currentTerm1].owners5;\n', '            kts = flotteries[currentTerm1].dogs5;\n', '        } else if (lotclass==6) {\n', '            ons = flotteries[currentTerm1].owners6;\n', '            kts = flotteries[currentTerm1].dogs6;\n', '        }\n', '    }\n', '\n', '    /*\n', '      将owner和dogId推入中奖信息存储\n', '    */\n', '    function _pushLuckyInfo(uint256 currentTerm1, uint8 _lotteryClass, address owner, uint256 _dogId) internal {\n', '        if (_lotteryClass == 0) {\n', '            flotteries[currentTerm1].owners0.push(owner);\n', '            flotteries[currentTerm1].dogs0.push(_dogId);\n', '        } else if (_lotteryClass == 1) {\n', '            flotteries[currentTerm1].owners1.push(owner);\n', '            flotteries[currentTerm1].dogs1.push(_dogId);\n', '        } else if (_lotteryClass == 2) {\n', '            flotteries[currentTerm1].owners2.push(owner);\n', '            flotteries[currentTerm1].dogs2.push(_dogId);\n', '        } else if (_lotteryClass == 3) {\n', '            flotteries[currentTerm1].owners3.push(owner);\n', '            flotteries[currentTerm1].dogs3.push(_dogId);\n', '        } else if (_lotteryClass == 4) {\n', '            flotteries[currentTerm1].owners4.push(owner);\n', '            flotteries[currentTerm1].dogs4.push(_dogId);\n', '        } else if (_lotteryClass == 5) {\n', '            flotteries[currentTerm1].owners5.push(owner);\n', '            flotteries[currentTerm1].dogs5.push(_dogId);\n', '        } else if (_lotteryClass == 6) {\n', '            flotteries[currentTerm1].owners6.push(owner);\n', '            flotteries[currentTerm1].dogs6.push(_dogId);\n', '        }\n', '    }\n', '\n', '    /*\n', '      检测该基因获奖等级\n', '    */\n', '    function getLotteryClass(uint8[7] luckyGenesArray, uint256 genes) internal view returns(uint8) {\n', '        // 不存在开奖信息,则直接返回未中奖\n', '        if (currentTerm < 0) {\n', '            return 100;\n', '        }\n', '        \n', '        uint8[7] memory dogArray = lotteryCore.convertGeneArray(genes);\n', '        uint8 cnt = 0;\n', '        uint8 lnt = 0;\n', '        for (uint i = 0; i < 6; i++) {\n', '\n', '            if (luckyGenesArray[i] > 0 && luckyGenesArray[i] == dogArray[i]) {\n', '                cnt++;\n', '            }\n', '        }\n', '        if (luckyGenesArray[6] > 0 && luckyGenesArray[6] == dogArray[6]) {\n', '            lnt = 1;\n', '        }\n', '        uint8 lotclass = 100;\n', '        if (cnt==6 && lnt==1) {\n', '            lotclass = 0;\n', '        } else if (cnt==6 && lnt==0) {\n', '            lotclass = 1;\n', '        } else if (cnt==5 && lnt==1) {\n', '            lotclass = 2;\n', '        } else if (cnt==5 && lnt==0) {\n', '            lotclass = 3;\n', '        } else if (cnt==4 && lnt==1) {\n', '            lotclass = 4;\n', '        } else if (cnt==3 && lnt==1) {\n', '            lotclass = 5;\n', '        } else if (cnt==3 && lnt==0) {\n', '            lotclass = 6;\n', '        } else {\n', '            lotclass = 100;\n', '        }\n', '        return lotclass;\n', '    }\n', '    /*\n', '       检测该基因获奖等级接口\n', '    */\n', '    function checkLottery(uint256 genes) public view returns(uint8) {\n', '        var(luckyGenesArray, , , isReward1, ) = lotteryCore.getCLottery();\n', '        if (isReward1) {\n', '            return 100;\n', '        }\n', '        return getLotteryClass(luckyGenesArray, genes);\n', '    }\n', '    /*\n', '       获取当前Lottery信息\n', '    */\n', '    function getCLottery() \n', '        public \n', '        view \n', '        returns (\n', '            uint8[7]        luckyGenes1,\n', '            uint256         totalAmount1,\n', '            uint256         openBlock1,\n', '            bool            isReward1,\n', '            uint256         term1,\n', '            uint8           currentGenes1,\n', '            uint256         tSupply,\n', '            uint256         sPoolAmount1,\n', '            uint256[]       reward1\n', '        ) {\n', '            (luckyGenes1, totalAmount1, openBlock1, isReward1, term1) = lotteryCore.getCLottery();\n', '            currentGenes1 = lotteryCore.currentGene();\n', '            tSupply = dogCore.totalSupply();\n', '            sPoolAmount1 = lotteryCore.SpoolAmount();\n', '            reward1 = flotteries[term1].reward;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract DogCoreInterface {\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    function getDog(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        //冷却期索引号\n', '        uint256 cooldownIndex,\n', '        //本次冷却期结束所在区块\n', '        uint256 nextActionAt,\n', '        //配种的公狗ID\n', '        uint256 siringWithId,\n', '        //出生时间\n', '        uint256 birthTime,\n', '        //母亲ID\n', '        uint256 matronId,\n', '        //父亲ID\n', '        uint256 sireId,\n', '        //代数\n', '        uint256 generation,\n', '        //基因\n', '        uint256 genes,\n', '        //变异，0表示未变异，1-7表示变异\n', '        uint8  variation,\n', '        //0代祖先的ID\n', '        uint256 gen0\n', '    );\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function sendMoney(address _to, uint256 _money) external;\n', '    function totalSupply() external view returns (uint);\n', '}\n', '\n', '\n', '/*\n', '    LotteryBase 主要定义了开奖信息，奖金池转入函数以及判断是否开必中\n', '*/\n', 'contract LotteryBase {\n', '    \n', '    // 当前开奖基因位数\n', '    uint8 public currentGene;\n', '    // 当前开奖所在区块\n', '    uint256 public lastBlockNumber;\n', '    // 随机数种子\n', '    uint256 randomSeed = 1;\n', '    // 奖金池地址\n', '    address public bonusPool;\n', '    // 中奖信息\n', '    struct CLottery {\n', '        // 该期中奖基因\n', '        uint8[7]        luckyGenes;\n', '        // 该期奖金池总额\n', '        uint256         totalAmount;\n', '        // 该期第7个基因开奖所在区块\n', '        uint256         openBlock;\n', '        // 是否发奖完毕\n', '        bool            isReward;\n', '        // 未开一等奖标记\n', '        bool         noFirstReward;\n', '    }\n', '    // 历史开奖信息\n', '    CLottery[] public CLotteries;\n', '    // 发奖合约地址\n', '    address public finalLottery;\n', '    // 蓄奖池金额\n', '    uint256 public SpoolAmount = 0;\n', '    // 宠物信息接口\n', '    DogCoreInterface public dogCore;\n', '    // 随机开奖事件\n', '    event OpenLottery(uint8 currentGene, uint8 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);\n', '    //必中开奖事件\n', '    event OpenCarousel(uint256 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);\n', '    \n', '    \n', '    //\n', '    modifier onlyCEO() {\n', '        require(msg.sender == dogCore.ceoAddress());\n', '        _;  \n', '    }\n', '    //\n', '    modifier onlyCFO() {\n', '        require(msg.sender == dogCore.cfoAddress());\n', '        _;  \n', '    }\n', '    /*\n', '        蓄奖池转入奖金池函数\n', '    */\n', '    function toLotteryPool(uint amount) public onlyCFO {\n', '        require(SpoolAmount >= amount);\n', '        SpoolAmount -= amount;\n', '    }\n', '    /*\n', '    判断当期是否开必中\n', '    */\n', '    function _isCarousal(uint256 currentTerm) external view returns(bool) {\n', '       return (currentTerm > 1 && CLotteries[currentTerm - 2].noFirstReward && CLotteries[currentTerm - 1].noFirstReward); \n', '    }\n', '    \n', '    /*\n', '      返回当前期数\n', '    */ \n', '    function getCurrentTerm() external view returns (uint256) {\n', '\n', '        return (CLotteries.length - 1);\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    LotteryGenes主要实现奖宠物原始基因转化为兑奖数组\n', '*/\n', 'contract LotteryGenes is LotteryBase {\n', '    /*\n', '     将基因数字格式转换为抽奖数组格式\n', '    */\n', '    function convertGeneArray(uint256 gene) public pure returns(uint8[7]) {\n', '        uint8[28] memory geneArray; \n', '        uint8[7] memory lotteryArray;\n', '        uint index = 0;\n', '        for (index = 0; index < 28; index++) {\n', '            uint256 geneItem = gene % (2 ** (5 * (index + 1)));\n', '            geneItem /= (2 ** (5 * index));\n', '            geneArray[index] = uint8(geneItem);\n', '        }\n', '        for (index = 0; index < 7; index++) {\n', '            uint size = 4 * index;\n', '            lotteryArray[index] = geneArray[size];\n', '            \n', '        }\n', '        return lotteryArray;\n', '    }\n', '\n', '    /**\n', '       将显性基因串拼凑成原始基因数字\n', '    */ \n', '    function convertGene(uint8[7] luckyGenes) public pure returns(uint256) {\n', '        uint8[28] memory geneArray;\n', '        for (uint8 i = 0; i < 28; i++) {\n', '            if (i%4 == 0) {\n', '                geneArray[i] = luckyGenes[i/4];\n', '            } else {\n', '                geneArray[i] = 6;\n', '            }\n', '        }\n', '        uint256 gene = uint256(geneArray[0]);\n', '        \n', '        for (uint8 index = 1; index < 28; index++) {\n', '            uint256 geneItem = uint256(geneArray[index]);\n', '            gene += geneItem << (index * 5);\n', '        }\n', '        return gene;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    SetLottery主要实现了随机开奖和必中开奖\n', '*/\n', 'contract SetLottery is LotteryGenes {\n', '\n', '    function random(uint8 seed) internal returns(uint8) {\n', '        randomSeed = block.timestamp;\n', '        return uint8(uint256(keccak256(randomSeed, block.difficulty))%seed)+1;\n', '    }\n', '\n', '    /*\n', '     随机开奖函数，每一期开7次。\n', '     currentGene表示当期开奖的第N个基因\n', '     若当前currentGene指标为0，则表示在开奖期未开任何数字，或者开奖期已经开完了所有数字\n', '     当前开奖期最后一个基因开完后，记录当前所在区块号和当前奖金池金额\n', '     返回值分别为当前开奖基因(0代表不存在)、查询开奖基因(0代表不存在)、\n', '     开奖状态(0表示开奖成功，1表示当期开奖结束且在等待发奖，2表示当前基因开奖区块与上个基因开奖区块相同,3表示奖金池金额不足)\n', '     */\n', '    function openLottery(uint8 _viewId) public returns(uint8,uint8) {\n', '        uint8 viewId = _viewId;\n', '        require(viewId < 7);\n', '        // 获取当前中奖信息\n', '        uint256 currentTerm = CLotteries.length - 1;\n', '        CLottery storage clottery = CLotteries[currentTerm];\n', '\n', '        // 如果7个基因都完成开奖并且当期没有发奖，则说明当期所有基因已经开奖完毕在等待发奖，退出\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {\n', '            // 触发事件，返回查询的基因\n', '            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '            //分别返回查询基因，状态1 (表示当期所有基因开奖完毕在等待发奖)\n', '            return (clottery.luckyGenes[viewId],1);\n', '        }\n', '        // 如果上个基因开奖和本次开奖在同一个区块，退出\n', '        if (lastBlockNumber == block.number) {\n', '            // 触发事件，返回查询的基因\n', '            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '            //分别返回查询基因，状态2 (当前基因开奖区块与上个基因开奖区块相同)\n', '            return (clottery.luckyGenes[viewId],2);\n', '        }\n', '        // 如果当前开奖基因位为0且当期已经发奖，则进入下一期开奖\n', '        if (currentGene == 0 && clottery.isReward == true) {\n', '            // 初始化当前lottery信息\n', '            CLottery memory _clottery;\n', '            _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '            _clottery.totalAmount = uint256(0);\n', '            _clottery.isReward = false;\n', '            _clottery.openBlock = uint256(0);\n', '            currentTerm = CLotteries.push(_clottery) - 1;\n', '        }\n', '\n', '        // 如果前两期都没有一等奖产生，则该期产生必中奖，退出随机开奖函数\n', '        if (this._isCarousal(currentTerm)) {\n', '            revert();\n', '        }\n', '\n', '        //开奖结果\n', '        uint8 luckyNum = 0;\n', '        \n', '        if (currentGene == 6) {\n', '            // 如果奖金池金额为零，则退出\n', '            if (bonusPool.balance <= SpoolAmount) {\n', '                // 触发事件，返回查询的基因\n', '                OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);\n', '                //分别返回查询基因，状态3 (奖金池金额不足)\n', '                return (clottery.luckyGenes[viewId],3);\n', '            }\n', '            //将随机数赋值给当前基因\n', '            luckyNum = random(8);\n', '            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;\n', '            //触发开奖事件\n', '            OpenLottery(currentGene, luckyNum, currentTerm, block.number, bonusPool.balance);\n', '            //如果当前为最后一个开奖基因，则下一个开奖基因位为0，同时记录下当前区块号并写入开奖信息，同时将奖金池金额写入开奖信息, 同时启动主合约\n', '            currentGene = 0;\n', '            CLotteries[currentTerm].openBlock = block.number;\n', '            CLotteries[currentTerm].totalAmount = bonusPool.balance;\n', '            //记录当前开奖所在区块\n', '            lastBlockNumber = block.number;\n', '        } else { \n', '            //将随机数赋值给当前基因\n', '        \n', '            luckyNum = random(12);\n', '            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;\n', '\n', '            //触发开奖事件\n', '            OpenLottery(currentGene, luckyNum, currentTerm, 0, 0);\n', '            //其它情况下，下一个开奖基因位加1\n', '            currentGene ++;\n', '            //记录当前开奖所在区块\n', '            lastBlockNumber = block.number;\n', '        }\n', '        //分别返回开奖基因，查询基因和开奖成功状态\n', '        return (luckyNum,0);\n', '    } \n', '\n', '    function random2() internal view returns (uint256) {\n', '        return uint256(uint256(keccak256(block.timestamp, block.difficulty))%uint256(dogCore.totalSupply()) + 1);\n', '    }\n', '\n', '    /*\n', '     必中开奖函数,每期开一次\n', '    */\n', '    function openCarousel() public {\n', '        //获取当前开奖信息\n', '        uint256 currentTerm = CLotteries.length - 1;\n', '        CLottery storage clottery = CLotteries[currentTerm];\n', '\n', '        // 如果当前开奖基因指针为0且开奖基因存在，且未发奖，则说明当前基因开奖完毕，在等待发奖\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {\n', '\n', '            //触发开奖事件,返回当期现有开奖数据\n', '            OpenCarousel(convertGene(clottery.luckyGenes), currentTerm, clottery.openBlock, clottery.totalAmount);\n', '        }\n', '\n', '        // 如果开奖基因指针为0且开奖基因存在，并且发奖完毕，则进入下一开奖周期\n', '        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == true) {\n', '            CLottery memory _clottery;\n', '            _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '            _clottery.totalAmount = uint256(0);\n', '            _clottery.isReward = false;\n', '            _clottery.openBlock = uint256(0);\n', '            currentTerm = CLotteries.push(_clottery) - 1;\n', '        }\n', '\n', '        //期数大于3 且前三期未产生特等奖\n', '        require (this._isCarousal(currentTerm));\n', '        // 随机获取必中基因\n', '        uint256 genes = _getValidRandomGenes();\n', '        require (genes > 0);\n', '        uint8[7] memory luckyGenes = convertGeneArray(genes);\n', '        //触发开奖事件\n', '        OpenCarousel(genes, currentTerm, block.number, bonusPool.balance);\n', '\n', '        //写入记录\n', '        CLotteries[currentTerm].luckyGenes = luckyGenes;\n', '        CLotteries[currentTerm].openBlock = block.number;\n', '        CLotteries[currentTerm].totalAmount = bonusPool.balance;\n', '        \n', '    }\n', '    \n', '    /*\n', '      随机获取合法的必中基因\n', '    */\n', '    function _getValidRandomGenes() internal view returns (uint256) {\n', '        uint256 luckyDog = random2();\n', '        uint256 genes = _validGenes(luckyDog);\n', '        uint256 totalSupply = dogCore.totalSupply();\n', '        if (genes > 0) {\n', '            return genes;\n', '        }  \n', '        // 如果dog不能兑奖，则渐进振荡判断其它dog是否满足条件\n', '        uint256 min = (luckyDog < totalSupply-luckyDog) ? (luckyDog - 1) : totalSupply-luckyDog;\n', '        for (uint256 i = 1; i < min + 1; i++) {\n', '            genes = _validGenes(luckyDog - i);\n', '            if (genes > 0) {\n', '                break;\n', '            }\n', '            genes = _validGenes(luckyDog + i);\n', '            if (genes > 0) {\n', '                    break;\n', '                }\n', '            }\n', '            // min次震荡仍然未找到可兑奖基因\n', '        if (genes == 0) {\n', '            //luckyDog右侧更长\n', '            if (min == luckyDog - 1) {\n', '                for (i = min + luckyDog; i < totalSupply + 1; i++) {\n', '                        genes = _validGenes(i);\n', '                        if (genes > 0) {\n', '                            break;\n', '                        }\n', '                    }   \n', '                }\n', '            //luckyDog左侧更长\n', '            if (min == totalSupply - luckyDog) {\n', '                for (i = min; i < luckyDog; i++) {\n', '                        genes = _validGenes(luckyDog - i - 1);\n', '                        if (genes > 0) {\n', '                            break;\n', '                        }\n', '                    }   \n', '                }\n', '            }\n', '        return genes;\n', '    }\n', '\n', '\n', '    /*\n', '      判断狗是否能兑奖，能则直接返回狗的基因，不能则返回0\n', '    */\n', '    function _validGenes(uint256 dogId) internal view returns (uint256) {\n', '\n', '        var(, , , , , ,generation, genes, variation,) = dogCore.getDog(dogId);\n', '        if (generation == 0 || dogCore.ownerOf(dogId) == finalLottery || variation > 0) {\n', '            return 0;\n', '        } else {\n', '            return genes;\n', '        }\n', '    }\n', '\n', '    \n', '}\n', '\n', '/*\n', '  LotteryCore是开奖函数的入口合约\n', '  开奖包括必中开奖和随机开奖\n', '  同时LotteryCore提供对外查询接口\n', '*/\n', '\n', 'contract LotteryCore is SetLottery {\n', '    \n', '    // 构造函数，传入奖金池地址,初始化中奖信息\n', '    function LotteryCore(address _ktAddress) public {\n', '\n', '        bonusPool = _ktAddress;\n', '        dogCore = DogCoreInterface(_ktAddress);\n', '\n', '        //初始化中奖信息\n', '        CLottery memory _clottery;\n', '        _clottery.luckyGenes = [0,0,0,0,0,0,0];\n', '        _clottery.totalAmount = uint256(0);\n', '        _clottery.isReward = false;\n', '        _clottery.openBlock = uint256(0);\n', '        CLotteries.push(_clottery);\n', '    }\n', '    /*\n', '    设置FinalLottery地址\n', '    */\n', '    function setFinalLotteryAddress(address _flAddress) public onlyCEO {\n', '        finalLottery = _flAddress;\n', '    }\n', '    /*\n', '    获取当前中奖记录\n', '    */\n', '    function getCLottery() \n', '        public \n', '        view \n', '        returns (\n', '            uint8[7]        luckyGenes,\n', '            uint256         totalAmount,\n', '            uint256         openBlock,\n', '            bool            isReward,\n', '            uint256         term\n', '        ) {\n', '            term = CLotteries.length - uint256(1);\n', '            luckyGenes = CLotteries[term].luckyGenes;\n', '            totalAmount = CLotteries[term].totalAmount;\n', '            openBlock = CLotteries[term].openBlock;\n', '            isReward = CLotteries[term].isReward;\n', '    }\n', '\n', '    /*\n', '    更改发奖状态\n', '    */\n', '    function rewardLottery(bool isMore) external {\n', '        // require contract address is final lottery\n', '        require(msg.sender == finalLottery);\n', '\n', '        uint256 term = CLotteries.length - 1;\n', '        CLotteries[term].isReward = true;\n', '        CLotteries[term].noFirstReward = isMore;\n', '    }\n', '\n', '    /*\n', '    转入蓄奖池\n', '    */\n', '    function toSPool(uint amount) external {\n', '        // require contract address is final lottery\n', '        require(msg.sender == finalLottery);\n', '\n', '        SpoolAmount += amount;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    FinalLottery 包含兑奖函数和发奖函数\n', '    中奖信息flotteries存入开奖期数到[各等奖获奖者，各等奖中奖金额]的映射\n', '*/\n', 'contract FinalLottery {\n', '    bool public isLottery = true;\n', '    LotteryCore lotteryCore;\n', '    DogCoreInterface dogCore;\n', '    uint8[7] public luckyGenes;\n', '    uint256         totalAmount;\n', '    uint256         openBlock;\n', '    bool            isReward;\n', '    uint256         currentTerm;\n', '    uint256  public duration;\n', '    uint8   public  lotteryRatio;\n', '    uint8[7] public lotteryParam;\n', '    uint8   public  carousalRatio;\n', '    uint8[7] public carousalParam; \n', '    // 中奖信息\n', '    struct FLottery {\n', '        //  该期各等奖获奖者\n', '        //  一等奖\n', '        address[]        owners0;\n', '        uint256[]        dogs0;\n', '        //  二等奖\n', '        address[]        owners1;\n', '        uint256[]        dogs1;\n', '        //  三等奖\n', '        address[]        owners2;\n', '        uint256[]        dogs2;\n', '        //  四等奖\n', '        address[]        owners3;\n', '        uint256[]        dogs3;\n', '        //  五等奖\n', '        address[]        owners4;\n', '        uint256[]        dogs4;\n', '        //  六等奖\n', '        address[]        owners5;\n', '        uint256[]        dogs5;\n', '        //  七等奖\n', '        address[]        owners6;\n', '        uint256[]        dogs6;\n', '        // 中奖金额\n', '        uint256[]       reward;\n', '    }\n', '    // 兑奖发奖信息\n', '    mapping(uint256 => FLottery) flotteries;\n', '    // 构造函数\n', '    function FinalLottery(address _lcAddress) public {\n', '        lotteryCore = LotteryCore(_lcAddress);\n', '        dogCore = DogCoreInterface(lotteryCore.bonusPool());\n', '        duration = 11520;\n', '        lotteryRatio = 23;\n', '        lotteryParam = [46,16,10,9,8,6,5];\n', '        carousalRatio = 12;\n', '        carousalParam = [35,18,14,12,8,7,6];\n', '        \n', '    }\n', '    \n', '    // 发奖事件\n', '    event DistributeLottery(uint256[] rewardArray, uint256 currentTerm);\n', '    // 兑奖事件\n', '    event RegisterLottery(uint256 dogId, address owner, uint8 lotteryClass, string result);\n', '    // 设置兑奖周期\n', '    function setLotteryDuration(uint256 durationBlocks) public {\n', '        require(msg.sender == dogCore.ceoAddress());\n', '        require(durationBlocks > 140);\n', '        require(durationBlocks < block.number);\n', '        duration = durationBlocks;\n', '    }\n', '    /*\n', '     登记兑奖函数,发生在当期开奖结束之后7天内（即40，320个区块内）\n', '    */\n', '    function registerLottery(uint256 dogId) public returns (uint8) {\n', '        uint256 _dogId = dogId;\n', '        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();\n', '        // 获取当前开奖信息\n', '        address owner = dogCore.ownerOf(_dogId);\n', '        // 回收的不能兑奖\n', '        require (owner != address(this));\n', '        // 调用者必须是主合约\n', '        require(address(dogCore) == msg.sender);\n', '        // 所有基因位开奖完毕（指针为0同时奖金池大于0）且未发奖且未兑奖结束\n', '        require(totalAmount > 0 && isReward == false && openBlock > (block.number-duration));\n', '        // 获取该宠物的基因，代数，出生时间\n', '        var(, , , birthTime, , ,generation,genes, variation,) = dogCore.getDog(_dogId);\n', '        // 出生日期小于开奖时间\n', '        require(birthTime < openBlock);\n', '        // 0代狗不能兑奖\n', '        require(generation > 0);\n', '        // 变异的不能兑奖\n', '        require(variation == 0);\n', '        // 判断该用户获几等奖，100表示未中奖\n', '        uint8 _lotteryClass = getLotteryClass(luckyGenes, genes);\n', '        // 若未获奖则退出\n', '        require(_lotteryClass < 7);\n', '        // 避免重复兑奖\n', '        address[] memory owners;\n', '        uint256[] memory dogs;\n', '         (dogs, owners) = _getLuckyList(currentTerm, _lotteryClass);\n', '            \n', '        for (uint i = 0; i < dogs.length; i++) {\n', '            if (_dogId == dogs[i]) {\n', '            //    revert();\n', '                RegisterLottery(_dogId, owner, _lotteryClass,"dog already registered");\n', '                 return 5;\n', '            }\n', '        }\n', '        // 将登记中奖者的账户存入奖金信息表\n', '        _pushLuckyInfo(currentTerm, _lotteryClass, owner, _dogId);\n', '        // 触发兑奖成功事件\n', '        RegisterLottery(_dogId, owner, _lotteryClass,"successful");\n', '        return 0;\n', '    }\n', '    /*\n', '    发奖函数，发生在当期开奖结束之后\n', '    */\n', '    \n', '    function distributeLottery() public returns (uint8) {\n', '        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();\n', '        \n', '        // 必须在当期开奖结束一周之后发奖\n', '        require(openBlock > 0 && openBlock < (block.number-duration));\n', '\n', '        //奖金池可用金额必须大于或等于0\n', '        require(totalAmount >= lotteryCore.SpoolAmount());\n', '\n', '        // 如果已经发奖\n', '        if (isReward == true) {\n', '            DistributeLottery(flotteries[currentTerm].reward, currentTerm);\n', '            return 1;\n', '        }\n', '        uint256 legalAmount = totalAmount - lotteryCore.SpoolAmount();\n', '        uint256 totalDistribute = 0;\n', '        uint8[7] memory lR;\n', '        uint8 ratio;\n', '\n', '        // 必中和随机两种不同的奖金分配比率\n', '        if (lotteryCore._isCarousal(currentTerm) ) {\n', '            lR = carousalParam;\n', '            ratio = carousalRatio;\n', '        } else {\n', '            lR = lotteryParam;\n', '            ratio = lotteryRatio;\n', '        }\n', '        // 计算各奖项金额并分发给中奖者\n', '        for (uint8 i = 0; i < 7; i++) {\n', '            address[] memory owners;\n', '            uint256[] memory dogs;\n', '            (dogs, owners) = _getLuckyList(currentTerm, i);\n', '            if (owners.length > 0) {\n', '                    uint256 reward = (legalAmount * ratio * lR[i])/(10000 * owners.length);\n', '                    totalDistribute += reward * owners.length;\n', '                    // 转给CFO的手续费（10%）\n', '                    dogCore.sendMoney(dogCore.cfoAddress(),reward * owners.length/10);\n', '                    \n', '                    for (uint j = 0; j < owners.length; j++) {\n', '                        address gen0Add;\n', '                        if (i == 0) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*95*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*5/100);\n', '                        } else if (i == 1) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*97*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*3/100);\n', '                        } else if (i == 2) {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*98*9/1000);\n', '                            // gen0 奖励\n', '                            gen0Add = _getGen0Address(dogs[j]);\n', '                            assert(gen0Add != address(0));\n', '                            dogCore.sendMoney(gen0Add,reward*2/100);\n', '                        } else {\n', '                            // 转账\n', '                            dogCore.sendMoney(owners[j],reward*9/10);\n', '                        }\n', '                    }\n', '                  // 记录各等奖发奖金额\n', '                    flotteries[currentTerm].reward.push(reward);  \n', '                } else {\n', '                    flotteries[currentTerm].reward.push(0); \n', '                } \n', '        }\n', '        //没有人登记一等奖中奖，将奖金池5%转入蓄奖池,并且更新无一等奖计数\n', '        if (flotteries[currentTerm].owners0.length == 0) {\n', '            lotteryCore.toSPool((lotteryCore.bonusPool().balance - lotteryCore.SpoolAmount())/20);\n', '            lotteryCore.rewardLottery(true);\n', '        } else {\n', '            //发奖完成之后，更新当前奖项状态、将当前奖项加入历史记录\n', '            lotteryCore.rewardLottery(false);\n', '        }\n', '        \n', '        DistributeLottery(flotteries[currentTerm].reward, currentTerm);\n', '        return 0;\n', '    }\n', '\n', '     /*\n', '    获取狗的gen0祖先的主人账户\n', '    */\n', '    function _getGen0Address(uint256 dogId) internal view returns(address) {\n', '        var(, , , , , , , , , gen0) = dogCore.getDog(dogId);\n', '        return dogCore.ownerOf(gen0);\n', '    }\n', '\n', '    /*\n', '      通过奖项等级获取中奖者列表和中奖狗列表\n', '    */\n', '    function _getLuckyList(uint256 currentTerm1, uint8 lotclass) public view returns (uint256[] kts, address[] ons) {\n', '        if (lotclass==0) {\n', '            ons = flotteries[currentTerm1].owners0;\n', '            kts = flotteries[currentTerm1].dogs0;\n', '        } else if (lotclass==1) {\n', '            ons = flotteries[currentTerm1].owners1;\n', '            kts = flotteries[currentTerm1].dogs1;\n', '        } else if (lotclass==2) {\n', '            ons = flotteries[currentTerm1].owners2;\n', '            kts = flotteries[currentTerm1].dogs2;\n', '        } else if (lotclass==3) {\n', '            ons = flotteries[currentTerm1].owners3;\n', '            kts = flotteries[currentTerm1].dogs3;\n', '        } else if (lotclass==4) {\n', '            ons = flotteries[currentTerm1].owners4;\n', '            kts = flotteries[currentTerm1].dogs4;\n', '        } else if (lotclass==5) {\n', '            ons = flotteries[currentTerm1].owners5;\n', '            kts = flotteries[currentTerm1].dogs5;\n', '        } else if (lotclass==6) {\n', '            ons = flotteries[currentTerm1].owners6;\n', '            kts = flotteries[currentTerm1].dogs6;\n', '        }\n', '    }\n', '\n', '    /*\n', '      将owner和dogId推入中奖信息存储\n', '    */\n', '    function _pushLuckyInfo(uint256 currentTerm1, uint8 _lotteryClass, address owner, uint256 _dogId) internal {\n', '        if (_lotteryClass == 0) {\n', '            flotteries[currentTerm1].owners0.push(owner);\n', '            flotteries[currentTerm1].dogs0.push(_dogId);\n', '        } else if (_lotteryClass == 1) {\n', '            flotteries[currentTerm1].owners1.push(owner);\n', '            flotteries[currentTerm1].dogs1.push(_dogId);\n', '        } else if (_lotteryClass == 2) {\n', '            flotteries[currentTerm1].owners2.push(owner);\n', '            flotteries[currentTerm1].dogs2.push(_dogId);\n', '        } else if (_lotteryClass == 3) {\n', '            flotteries[currentTerm1].owners3.push(owner);\n', '            flotteries[currentTerm1].dogs3.push(_dogId);\n', '        } else if (_lotteryClass == 4) {\n', '            flotteries[currentTerm1].owners4.push(owner);\n', '            flotteries[currentTerm1].dogs4.push(_dogId);\n', '        } else if (_lotteryClass == 5) {\n', '            flotteries[currentTerm1].owners5.push(owner);\n', '            flotteries[currentTerm1].dogs5.push(_dogId);\n', '        } else if (_lotteryClass == 6) {\n', '            flotteries[currentTerm1].owners6.push(owner);\n', '            flotteries[currentTerm1].dogs6.push(_dogId);\n', '        }\n', '    }\n', '\n', '    /*\n', '      检测该基因获奖等级\n', '    */\n', '    function getLotteryClass(uint8[7] luckyGenesArray, uint256 genes) internal view returns(uint8) {\n', '        // 不存在开奖信息,则直接返回未中奖\n', '        if (currentTerm < 0) {\n', '            return 100;\n', '        }\n', '        \n', '        uint8[7] memory dogArray = lotteryCore.convertGeneArray(genes);\n', '        uint8 cnt = 0;\n', '        uint8 lnt = 0;\n', '        for (uint i = 0; i < 6; i++) {\n', '\n', '            if (luckyGenesArray[i] > 0 && luckyGenesArray[i] == dogArray[i]) {\n', '                cnt++;\n', '            }\n', '        }\n', '        if (luckyGenesArray[6] > 0 && luckyGenesArray[6] == dogArray[6]) {\n', '            lnt = 1;\n', '        }\n', '        uint8 lotclass = 100;\n', '        if (cnt==6 && lnt==1) {\n', '            lotclass = 0;\n', '        } else if (cnt==6 && lnt==0) {\n', '            lotclass = 1;\n', '        } else if (cnt==5 && lnt==1) {\n', '            lotclass = 2;\n', '        } else if (cnt==5 && lnt==0) {\n', '            lotclass = 3;\n', '        } else if (cnt==4 && lnt==1) {\n', '            lotclass = 4;\n', '        } else if (cnt==3 && lnt==1) {\n', '            lotclass = 5;\n', '        } else if (cnt==3 && lnt==0) {\n', '            lotclass = 6;\n', '        } else {\n', '            lotclass = 100;\n', '        }\n', '        return lotclass;\n', '    }\n', '    /*\n', '       检测该基因获奖等级接口\n', '    */\n', '    function checkLottery(uint256 genes) public view returns(uint8) {\n', '        var(luckyGenesArray, , , isReward1, ) = lotteryCore.getCLottery();\n', '        if (isReward1) {\n', '            return 100;\n', '        }\n', '        return getLotteryClass(luckyGenesArray, genes);\n', '    }\n', '    /*\n', '       获取当前Lottery信息\n', '    */\n', '    function getCLottery() \n', '        public \n', '        view \n', '        returns (\n', '            uint8[7]        luckyGenes1,\n', '            uint256         totalAmount1,\n', '            uint256         openBlock1,\n', '            bool            isReward1,\n', '            uint256         term1,\n', '            uint8           currentGenes1,\n', '            uint256         tSupply,\n', '            uint256         sPoolAmount1,\n', '            uint256[]       reward1\n', '        ) {\n', '            (luckyGenes1, totalAmount1, openBlock1, isReward1, term1) = lotteryCore.getCLottery();\n', '            currentGenes1 = lotteryCore.currentGene();\n', '            tSupply = dogCore.totalSupply();\n', '            sPoolAmount1 = lotteryCore.SpoolAmount();\n', '            reward1 = flotteries[term1].reward;\n', '    }\n', '    \n', '}']
