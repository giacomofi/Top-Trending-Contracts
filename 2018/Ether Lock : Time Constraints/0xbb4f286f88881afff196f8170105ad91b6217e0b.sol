['pragma solidity ^0.4.25;\n', '\n', 'library Math {\n', '  function min(uint a, uint b) internal pure returns(uint) {\n', '    if (a > b) {\n', '      return b;\n', '    }\n', '    return a;\n', '  }\n', '  \n', '  function max(uint a, uint b) internal pure returns(uint) {\n', '    if (a > b) {\n', '      return a;\n', '    }\n', '    return b;\n', '  }\n', '}\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  \n', '  // storage\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '    return Percent.percent(p.num, p.den);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '  \n', '  /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(owner, address(0));\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '//шаблон контракта \n', 'contract distribution is Ownable {\n', '    using SafeMath for uint;\n', '    \n', '    uint public currentPaymentIndex = 0;\n', '    uint public depositorsCount;\n', '    uint public amountForDistribution = 0;\n', '    uint public amountRaised = 0;\n', '    \n', '    struct Deposite {\n', '        address depositor;\n', '        uint amount;\n', '        uint depositeTime;\n', '        uint paimentTime;\n', '    }\n', '    \n', '    Deposite[] public deposites;\n', '\n', '    mapping ( address => uint[]) public depositors;\n', '    \n', '    function getAllDepositesCount() public view returns (uint) ;\n', '    \n', '    function getLastDepositId() public view returns (uint) ;\n', '\n', '    function getDeposit(uint _id) public view returns (address, uint, uint, uint);\n', '}\n', '\n', 'contract FromResponsibleInvestors is Ownable {\n', '    using Percent for Percent.percent;\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '    \n', '    //Address for advertising and admins expences\n', '    address constant public advertisingAddress = address(0x43571AfEA3c3c6F02569bdC59325F4f95463014d); //test wallet\n', '    address constant public adminsAddress = address(0x8008BD6FdDF2C26382B4c19d714A1BfeA317ec57); //test wallet\n', '    \n', '    //Percent for promo expences\n', '    Percent.percent private m_adminsPercent = Percent.percent(3, 100);       //   3/100  *100% = 3%\n', '    Percent.percent private m_advertisingPercent = Percent.percent(5, 100);// 5/100  *100% = 5%\n', '    //How many percent for your deposit to be multiplied\n', '    Percent.percent public MULTIPLIER = Percent.percent(120, 100); // 120/100 * 100% = 120%\n', '    \n', '    //flag for end migration deposits from oldContract\n', '    bool public migrationFinished = false; \n', '    \n', '    uint public amountRaised = 0;\n', '    uint public advertAmountRaised = 0; //for advertising all\n', '    //The deposit structure holds all the info about the deposit made\n', '    struct Deposit {\n', '        address depositor; //The depositor address\n', '        uint deposit;   //The deposit amount\n', '        uint expects;    //How much we should pay out (initially it is 120% of deposit)\n', '        uint paymentTime; //when payment\n', '    }\n', '\n', '    Deposit[] private ImportedQueue;  //The queue for imported investments\n', '    Deposit[] private Queue;  //The queue for new investments\n', '    // list of deposites for 1 user\n', '    mapping(address => uint[]) public depositors;\n', '    \n', '    uint public depositorsCount = 0;\n', '    \n', '    uint public currentImportedReceiverIndex = 0; //The index of the first depositor in OldQueue. The receiver of investments!\n', '    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\n', '    \n', '    uint public minBalanceForDistribution = 24 ether; //первый минимально необходимый баланс должен быть достаточным для выплаты по 12 ETH из каждой очереди\n', '\n', '    // more events for easy read from blockchain\n', '    event LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\n', '    event LogImportInvestorsPartComplete(uint when, uint howmuch, uint lastIndex);\n', '    event LogNewInvestor(address indexed addr, uint when);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    //создаем депозит инвестора в основной очереди\n', '    function () public payable {\n', '        if(msg.value > 0){\n', '            require(msg.value >= 0.01 ether, "investment must be >= 0.01 ether"); //ограничение минимального депозита\n', '            require(msg.value <= 10 ether, "investment must be <= 10 ether"); //ограничение максимального депозита\n', '\n', '            //к выплате 120% от депозита\n', '            uint expect = MULTIPLIER.mul(msg.value);\n', '            Queue.push(Deposit({depositor:msg.sender, deposit:msg.value, expects:expect, paymentTime:0}));\n', '            amountRaised += msg.value;\n', '            if (depositors[msg.sender].length == 0) depositorsCount += 1;\n', '            depositors[msg.sender].push(Queue.length - 1);\n', '            \n', '            uint advertperc = m_advertisingPercent.mul(msg.value);\n', '            advertisingAddress.send(advertperc);\n', '            adminsAddress.send(m_adminsPercent.mul(msg.value));\n', '            advertAmountRaised += advertperc;\n', '        } \n', '    }\n', '\n', '    //выплаты инвесторам\n', '    //в каждой транзакции выплачивается не менее 1 депозита из каждой очереди, но не более 100 выплат из каждой очереди.\n', '    function distribute(uint maxIterations) public {\n', '        require(maxIterations <= 100, "no more than 100 iterations"); //ограничение в 100 итераций максимум\n', '        uint money = address(this).balance;\n', '        require(money >= minBalanceForDistribution, "Not enough funds to pay");//на балансе недостаточно денег для выплат\n', '        uint ImportedQueueLen = ImportedQueue.length;\n', '        uint QueueLen = Queue.length;\n', '        uint toSend = 0;\n', '        maxIterations = maxIterations.max(5);//минимум 5 итераций\n', '        \n', '        for (uint i = 0; i < maxIterations; i++) {\n', '            if (currentImportedReceiverIndex < ImportedQueueLen){\n', '                toSend = ImportedQueue[currentImportedReceiverIndex].expects;\n', '                if (money >= toSend){\n', '                    money = money.sub(toSend);\n', '                    ImportedQueue[currentImportedReceiverIndex].paymentTime = now;\n', '                    ImportedQueue[currentImportedReceiverIndex].depositor.send(toSend);\n', '                    currentImportedReceiverIndex += 1;\n', '                }\n', '            }\n', '            if (currentReceiverIndex < QueueLen){\n', '                toSend = Queue[currentReceiverIndex].expects;\n', '                if (money >= toSend){\n', '                    money = money.sub(toSend);\n', '                    Queue[currentReceiverIndex].paymentTime = now;\n', '                    Queue[currentReceiverIndex].depositor.send(toSend);\n', '                    currentReceiverIndex += 1;\n', '                }\n', '            }\n', '        }\n', '        setMinBalanceForDistribution();\n', '    }\n', '    //пересчитываем минимально необходимый баланс для выплат по одному депозиту из каждой очереди.\n', '    function setMinBalanceForDistribution() private {\n', '        uint importedExpects = 0;\n', '        \n', '        if (currentImportedReceiverIndex < ImportedQueue.length) {\n', '            importedExpects = ImportedQueue[currentImportedReceiverIndex].expects;\n', '        } \n', '        \n', '        if (currentReceiverIndex < Queue.length) {\n', '            minBalanceForDistribution = Queue[currentReceiverIndex].expects;\n', '        } else {\n', '            minBalanceForDistribution = 12 ether; //максимально возможная выплата основной очереди\n', '        }\n', '        \n', '        if (importedExpects > 0){\n', '            minBalanceForDistribution = minBalanceForDistribution.add(importedExpects);\n', '        }\n', '    }\n', '    \n', '    //перенос очереди из проекта MMM3.0Reload\n', '    function FromMMM30Reload(address _ImportContract, uint _from, uint _to) public onlyOwner {\n', '        require(!migrationFinished);\n', '        distribution ImportContract = distribution(_ImportContract);\n', '        \n', '        address depositor;\n', '        uint amount;\n', '        uint depositeTime;\n', '        uint paymentTime;\n', '        uint c = 0;\n', '        uint maxLen = ImportContract.getLastDepositId();\n', '        _to = _to.min(maxLen);\n', '        \n', '        for (uint i = _from; i <= _to; i++) {\n', '                (depositor, amount, depositeTime, paymentTime) = ImportContract.getDeposit(i);\n', '                //кошельки администрации проекта MMM3.0Reload исключаем из переноса\n', '                if ((depositor != address(0x494A7A2D0599f2447487D7fA10BaEAfCB301c41B)) && \n', '                    (depositor != address(0xFd3093a4A3bd68b46dB42B7E59e2d88c6D58A99E)) && \n', '                    (depositor != address(0xBaa2CB97B6e28ef5c0A7b957398edf7Ab5F01A1B)) && \n', '                    (depositor != address(0xFDd46866C279C90f463a08518e151bC78A1a5f38)) && \n', '                    (depositor != address(0xdFa5662B5495E34C2aA8f06Feb358A6D90A6d62e))) {\n', '                    ImportedQueue.push(Deposit({depositor:depositor, deposit:uint(amount), expects:uint(MULTIPLIER.mul(amount)), paymentTime:0}));\n', '                    depositors[depositor].push(ImportedQueue.length - 1);\n', '                    c++;\n', '                }\n', '        }\n', '        emit LogImportInvestorsPartComplete(now, c, _to);\n', '    }\n', '\n', '    //после окончания переноса очереди - отказ от владения контрактом\n', '    function finishMigration() public onlyOwner {\n', '        migrationFinished = true;\n', '        renounceOwnership();\n', '    }\n', '\n', '    //баланс контракта\n', '    function getBalance() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    //баланс кошелька рекламного бюджета\n', '    function getAdvertisingBalance() public view returns (uint) {\n', '        return advertisingAddress.balance;\n', '    }\n', '    \n', '    //Количество невыплаченных депозитов в основной очереди\n', '    function getDepositsCount() public view returns (uint) {\n', '        return Queue.length.sub(currentReceiverIndex);\n', '    }\n', '    \n', '    //Количество невыплаченных депозитов в перенесенной очереди\n', '    function getImportedDepositsCount() public view returns (uint) {\n', '        return ImportedQueue.length.sub(currentImportedReceiverIndex);\n', '    }\n', '    \n', '    //данные о депозите основной очереди по порядковому номеру \n', '    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect, uint paymentTime){\n', '        Deposit storage dep = Queue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expects, dep.paymentTime);\n', '    }\n', '    \n', '    //данные о депозите перенесенной очереди по порядковому номеру \n', '    function getImportedDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect, uint paymentTime){\n', '        Deposit storage dep = ImportedQueue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expects, dep.paymentTime);\n', '    }\n', '    \n', '    //Последний выплаченный депозит основной очереди, lastIndex - смещение номера в очереди (0 - последняя выплата, 1 - предпоследняя выплата)\n', '    function getLastPayments(uint lastIndex) public view returns (address, uint, uint) {\n', '        uint depositeIndex = currentReceiverIndex.sub(lastIndex).sub(1);\n', '        return (Queue[depositeIndex].depositor, Queue[depositeIndex].paymentTime, Queue[depositeIndex].expects);\n', '    }\n', '\n', '    //Последний выплаченный депозит перенесенной очереди, lastIndex - смещение номера в очереди (0 - последняя выплата, 1 - предпоследняя выплата)\n', '    function getLastImportedPayments(uint lastIndex) public view returns (address, uint, uint) {\n', '        uint depositeIndex = currentImportedReceiverIndex.sub(lastIndex).sub(1);\n', '        return (ImportedQueue[depositeIndex].depositor, ImportedQueue[depositeIndex].paymentTime, ImportedQueue[depositeIndex].expects);\n', '    }\n', '\n', '    //общее количество депозитов в основной очереди у кошелька depositor\n', '    function getUserDepositsCount(address depositor) public view returns (uint) {\n', '        uint c = 0;\n', '        for(uint i=0; i<Queue.length; ++i){\n', '            if(Queue[i].depositor == depositor)\n', '                c++;\n', '        }\n', '        return c;\n', '    }\n', '    \n', '    //общее количество депозитов в перенесенной очереди у кошелька depositor\n', '    function getImportedUserDepositsCount(address depositor) public view returns (uint) {\n', '        uint c = 0;\n', '        for(uint i=0; i<ImportedQueue.length; ++i){\n', '            if(ImportedQueue[i].depositor == depositor)\n', '                c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    //Все депозиты основной очереди кошелька depositor в виде массива\n', '    function getUserDeposits(address depositor) public view returns (uint[] idxs, uint[] paymentTime, uint[] amount, uint[] expects) {\n', '        uint c = getUserDepositsCount(depositor);\n', '\n', '        idxs = new uint[](c);\n', '        paymentTime = new uint[](c);\n', '        expects = new uint[](c);\n', '        amount = new uint[](c);\n', '        uint num = 0;\n', '\n', '        if(c > 0) {\n', '            uint j = 0;\n', '            for(uint i=0; i<c; ++i){\n', '                num = depositors[depositor][i];\n', '                Deposit storage dep = Queue[num];\n', '                idxs[j] = i;\n', '                paymentTime[j] = dep.paymentTime;\n', '                amount[j] = dep.deposit;\n', '                expects[j] = dep.expects;\n', '                j++;\n', '            }\n', '        }\n', '    }\n', '    \n', '    //Все депозиты перенесенной очереди кошелька depositor в виде массива\n', '    function getImportedUserDeposits(address depositor) public view returns (uint[] idxs, uint[] paymentTime, uint[] amount, uint[] expects) {\n', '        uint c = getImportedUserDepositsCount(depositor);\n', '\n', '        idxs = new uint[](c);\n', '        paymentTime = new uint[](c);\n', '        expects = new uint[](c);\n', '        amount = new uint[](c);\n', '\n', '        if(c > 0) {\n', '            uint j = 0;\n', '            for(uint i=0; i<ImportedQueue.length; ++i){\n', '                Deposit storage dep = ImportedQueue[i];\n', '                if(dep.depositor == depositor){\n', '                    idxs[j] = i;\n', '                    paymentTime[j] = dep.paymentTime;\n', '                    amount[j] = dep.deposit;\n', '                    expects[j] = dep.expects;\n', '                    j++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']