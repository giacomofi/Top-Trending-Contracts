['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'interface IGameToken{                                             \n', '    function mineToken(address _player, uint256 _etherAmount) external returns (uint _toPlayerToken);\n', '    function balanceOf(address _owner) constant  external returns (uint256 _balance);\n', '}\n', '\n', 'contract BaseGame {\n', '    using SafeMath for uint256;\n', '    \n', '    string public officialGameUrl;  \n', '    string public gameName = "GameSicBo";    \n', '    uint public gameType = 3003;               \n', '\n', '    mapping (address => uint256) public userEtherOf;\n', '    \n', '    function userRefund() public  returns(bool _result);\n', '   \n', '    address public currentBanker;    \n', '    uint public bankerBeginTime;     \n', '    uint public bankerEndTime;       \n', '    IGameToken public GameToken;  \n', '    \n', '    function canSetBanker() view public returns (bool _result);\n', '    function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);\n', '}\n', '\n', 'contract Base is  BaseGame{\n', '    uint public createTime = now;\n', '    address public owner;\n', '    bool public globalLocked = false;      \n', '    uint public currentEventId = 1;            \n', '\n', '    //function Base() public {\n', '    //}\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner)  public  onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function lock() internal {            \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }\n', '\n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;\n', '    }\n', '\n', '\n', '    function getEventId() internal returns(uint _result) {  \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '}\n', '\n', 'contract GameSicBo is Base\n', '{\n', '    uint public maxPlayableGameId = 0;      \n', '    uint public gameTime;              \n', '    uint256 public gameMaxBetAmount;    \n', '    uint256 public gameMinBetAmount;    \n', '    uint256 public minBankerEther = gameMaxBetAmount * 20;\n', '\n', '    function setMinBankerEther(uint256 _value) public onlyBanker {          \n', '        require(_value >= gameMinBetAmount *  150);\n', '        minBankerEther = _value;\n', '    }\n', '\n', '    uint public gameExpirationTime = 5 days;  \n', "    string public constant gameRandon2 = 'ChinasNewGovernmentBracesforTrump';    \n", '    bool public isStopPlay = false;\n', '    uint public playNo = 1;      \n', '    bool public isNeedLoan = true; \n', '    uint256 public currentDayRate10000 = 0;      \n', '    address public currentLoanPerson;       \n', '    uint256 public currentLoanAmount;       \n', '    uint public currentLoanDayTime;       \n', '\n', '    function GameSicBo(string _gameName,uint  _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,address _auction,address _gameToken)  public {\n', '        require(_gameTime > 0);\n', '        require(_gameMinBetAmount > 0);\n', '        require(_gameMaxBetAmount > 0);\n', '        require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '        require(_gameToken != 0x0);\n', '\n', '        gameMinBetAmount = _gameMinBetAmount;\n', '        gameMaxBetAmount = _gameMaxBetAmount;\n', '        \n', '        minBankerEther = gameMaxBetAmount * 20;\n', '        gameTime = _gameTime;\n', '        GameToken = IGameToken(_gameToken);\n', '\n', '        gameName = _gameName;\n', '        owner = msg.sender;\n', '        auction = _auction;\n', "        officialGameUrl='http://sicbo.donquixote.games/';\n", '    }\n', '\n', '    function tokenOf(address _user) view public returns(uint _result){\n', '       _result = GameToken.balanceOf(_user);\n', '    }\n', '\n', '    address public auction;     \n', '    function setAuction(address _newAuction) public onlyOwner{\n', '        auction = _newAuction;\n', '    }\n', '\n', '    modifier onlyAuction {              \n', '        require(msg.sender == auction);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBanker {              \n', '        require(msg.sender == currentBanker);\n', '        require(bankerBeginTime <= now);\n', '        require(now < bankerEndTime);\n', '        _;\n', '    }\n', '\n', '    modifier playable(uint betAmount) {\n', '        require (!isStopPlay); \n', '        require(msg.sender != currentBanker);               \n', '        require(betAmount >= gameMinBetAmount);        \n', '        _;\n', '    }\n', '\n', '   function canSetBanker() public view returns (bool _result){\n', '        _result =  bankerEndTime <= now;\n', '    }\n', '\n', '    event OnSetNewBanker(address _caller, address _banker, uint _beginTime, uint _endTime, uint _code,uint _eventId,uint _eventTime);\n', '    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)        \n', '    {\n', '        _result = false;\n', '        require(_banker != 0x0);\n', '             \n', '        if(now < bankerEndTime){\n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 1 ,getEventId(),now);\n', '            return;\n', '        }\n', '       \n', '        if(_beginTime > now){\n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 3 ,getEventId(),now);\n', '            return;\n', '        }\n', '     \n', '        if(_endTime <= now){\n', '            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 4 ,getEventId(),now);\n', '            return;\n', '        }\n', '       \n', '        uint256 toLoan = calLoanAmount();\n', '        uint256 _bankerAmount = userEtherOf[currentBanker];\n', '        if(_bankerAmount < toLoan){\n', '             toLoan = _bankerAmount;\n', '        }\n', '        userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '        userEtherOf[currentBanker] = userEtherOf[currentBanker].sub(toLoan);\n', '        currentLoanPerson = 0x0;\n', '        currentDayRate10000 = 0;\n', '        currentLoanAmount = 0;\n', '        currentLoanDayTime = now;\n', '        emit OnPayLoan(currentBanker,now,toLoan);\n', '\n', '        currentBanker = _banker;\n', '        bankerBeginTime = _beginTime;\n', '        bankerEndTime = _endTime;\n', '        isStopPlay = false;\n', '        \n', '        emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 0, getEventId(),now);\n', '        _result = true;\n', '    }\n', '   \n', '    struct gameInfo             \n', '    {\n', '        address Banker;\n', '        bytes32 EncryptedText;  \n', '        bytes32 GameRandon;        \n', '        uint GameResult ; \n', '        mapping(uint8 => uint) TotalBetInfoOf;\n', '    }\n', '\n', '    function hasBetting(uint _gameId) public view returns (bool _result){       \n', '        gameInfo storage gi = gameInfoOf[_gameId];\n', '        require(gi.Banker != 0x0);\n', '        _result = false;\n', '        for(uint8 i = 1; i <= 50; i++){\n', '            if (gi.TotalBetInfoOf[i] > 0){\n', '                _result = true;\n', '                return;\n', '            }\n', '        }\n', '    }\n', '    struct betInfo             \n', '    {\n', '        uint256 GameId;\n', '        address Player;\n', '        uint256 BetAmount;      \n', '        uint8 Odds;            \n', '        uint8 BetNum;           \n', '        bool IsReturnAward;     \n', '        bool IsWin ;         \n', '        uint BetTime;\n', '    }\n', '\n', '    mapping (uint => betInfo) public playerBetInfoOf;             \n', '    mapping (uint => gameInfo) public gameInfoOf;               \n', '\n', '    function getCurrentGameId()  public  view returns (uint _result){       \n', '        _result = now.sub(createTime).div(gameTime);\n', '        if(now.sub(createTime) % gameTime >0 ){\n', '           _result = _result.add(1);\n', '        }\n', '    }\n', '\n', '    function getCountCanAdd() view public returns (uint _result){         \n', '        _result = 0;\n', '        uint currentGameId = getCurrentGameId();\n', '        if(currentGameId < maxPlayableGameId){\n', '          _result = (bankerEndTime.sub(gameTime.mul(maxPlayableGameId).add(createTime))).div(gameTime);\n', '        }else{\n', '          _result = bankerEndTime.sub(now).div(gameTime);\n', '        }\n', '    }\n', '\n', '    function getGameBeginTime(uint _gameId) view public returns (uint _result){\n', '        _result = 0;\n', '        if(_gameId <= maxPlayableGameId && _gameId != 0){\n', '          _result = _gameId.mul(gameTime).add(createTime).sub(gameTime);\n', '        }\n', '    }\n', '\n', '    function getGameEndTime(uint _gameId) view public returns (uint _result){\n', '        _result = 0;\n', '        if(_gameId <= maxPlayableGameId  && _gameId != 0){\n', '          _result = _gameId.mul(gameTime).add(createTime);\n', '        }\n', '    }\n', '\n', '    function isGameExpiration(uint _gameId) view public returns(bool _result){        \n', '        _result = false;\n', '        if(_gameId.mul(gameTime).add(createTime).add(gameExpirationTime) < now && gameInfoOf[_gameId].GameResult ==0 ){\n', '          _result = true;\n', '        }\n', '    }\n', '\n', '    function userRefund() public  returns(bool _result) {\n', '        return _userRefund(msg.sender);\n', '    }\n', '    \n', '    function _userRefund(address _to) internal returns(bool _result) {\n', '        require (_to != 0x0);\n', '        lock();\n', '        uint256 amount = userEtherOf[msg.sender];\n', '        if(amount > 0){ \n', '            if(msg.sender == currentBanker){\n', '                if(currentLoanPerson == 0x0 || checkPayLoan() ){   \n', '                    if(amount >= minBankerEther){    \n', '                      uint256 toBanker = amount - minBankerEther;\n', '                      _to.transfer(toBanker);\n', '                      userEtherOf[msg.sender] = minBankerEther;\n', '                    }\n', '                }\n', '            }else{\n', '                _to.transfer(amount);\n', '                userEtherOf[msg.sender] = 0;    \n', '            }\n', '            _result = true;\n', '        }else{\n', '            _result = false;\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    function setIsNeedLoan(bool _isNeedLoan) public onlyBanker returns(bool _result) {  \n', '        _result = false;\n', '        if(!isNeedLoan){\n', '            \n', '            require(currentLoanAmount == 0);\n', '        }\n', '        isNeedLoan = _isNeedLoan;\n', '        _result = true;\n', '    }\n', '\n', '    event OnBidLoan(bool indexed _success, address indexed _user, uint256 indexed _dayRate10000,  uint256 _etherAmount);\n', '    event OnPayLoan(address _sender,uint _eventTime,uint256 _toLoan);\n', '\n', '    function bidLoan(uint256 _dayRate10000) public payable returns(bool _result) {      \n', '        _result = false;\n', '        require(isNeedLoan); \n', '        require(!isStopPlay);\n', '        require(msg.sender != currentBanker);\n', '        \n', '        require(_dayRate10000 < 1000);           \n', '        depositEther();\n', '        \n', '        if(checkPayLoan()){\n', '           \n', '            emit OnBidLoan(false, msg.sender, _dayRate10000,  0);\n', '            return;\n', '        }\n', '        \n', '        uint256 toLoan = calLoanAmount();\n', '        uint256 toGame = 0;\n', '        if (userEtherOf[currentBanker] < minBankerEther){      \n', '            toGame = minBankerEther.sub(userEtherOf[currentBanker]);\n', '        }\n', '\n', '        if(toLoan > 0 && toGame == 0 && currentLoanPerson != 0x0){                    \n', '            require(_dayRate10000 < currentDayRate10000);\n', '        }\n', '\n', '        require(toLoan + toGame > 0);                                                \n', '        require(userEtherOf[msg.sender] >= toLoan + toGame);\n', '\n', '        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(toLoan + toGame);\n', '        userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '        userEtherOf[currentBanker] = userEtherOf[currentBanker].add(toGame);\n', '\n', '        currentLoanPerson = msg.sender;\n', '        currentDayRate10000 = _dayRate10000;\n', '        currentLoanAmount = toLoan + toGame;\n', '        currentLoanDayTime = now;\n', '\n', '        emit OnBidLoan(false, msg.sender, _dayRate10000,  currentLoanAmount);\n', '\n', '        _result = true;\n', '        return;\n', '    }\n', '\n', '    function getCanLoanAmount() public view returns(uint256  _result){                 \n', '        uint256 toLoan = calLoanAmount();\n', '\n', '        uint256 toGame = 0;\n', '        if (userEtherOf[currentBanker] <= minBankerEther){\n', '            toGame = minBankerEther - userEtherOf[currentBanker];\n', '            _result =  toLoan + toGame;\n', '            return;\n', '        }\n', '        else if (userEtherOf[currentBanker] > minBankerEther){\n', '            uint256 c = userEtherOf[currentBanker] - minBankerEther;\n', '            if(toLoan > c){\n', '                _result =  toLoan - c;\n', '                return;\n', '            }\n', '            else{\n', '                _result =  0;\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    function calLoanAmount() public view returns (uint256 _result){\n', '      _result = 0;\n', '      if(currentLoanPerson != 0x0 && currentLoanAmount > 0){\n', '          _result = currentLoanAmount;\n', '          uint d = (now - currentLoanDayTime) / (1 days);\n', '          for(uint i = 0; i < d; i++){\n', '              _result = _result * (10000 + currentDayRate10000) / 10000;\n', '          }\n', '        }\n', '    }\n', '\n', '    function checkPayLoan() public returns (bool _result) {                        \n', '        _result = false;\n', '        uint256 toLoan = calLoanAmount();\n', '        if(toLoan > 0){      \n', '            bool isStop =  isStopPlay && now  > getGameEndTime(maxPlayableGameId).add(1 hours);                      \n', '            if (isStop || userEtherOf[currentBanker] >= minBankerEther.add(toLoan)){            \n', '                userEtherOf[currentLoanPerson] = userEtherOf[currentLoanPerson].add(toLoan);\n', '                userEtherOf[currentBanker] = userEtherOf[currentBanker].sub(toLoan);\n', '                currentLoanPerson = 0x0;\n', '                currentDayRate10000 = 0;\n', '                currentLoanAmount = 0;\n', '                currentLoanDayTime = now;\n', '                _result = true;\n', '                emit OnPayLoan(msg.sender,now,toLoan);\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    event OnNewGame(uint indexed _gameId, address indexed _bankerAddress, bytes32 indexed _gameEncryptedTexts, uint _gameBeginTime, uint _gameEndTime, uint _eventTime, uint _eventId);\n', '    function newGame(bytes32[] _gameEncryptedTexts) public onlyBanker payable returns(bool _result)       \n', '    {\n', '        if (msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);       \n', '        }\n', '\n', '        _result = _newGame( _gameEncryptedTexts);\n', '    }\n', '\n', '    function setStopPlay(bool _isStopPlay) public onlyBanker\n', '    {   \n', '        isStopPlay = _isStopPlay;\n', '    }\n', '\n', '    function _newGame(bytes32[] _gameEncryptedTexts)   private  returns(bool _result)       \n', '    {   \n', '        _result = false;\n', '\n', '        uint countCanAdd = getCountCanAdd();   \n', '        require(countCanAdd > 0); \n', '        if(countCanAdd > _gameEncryptedTexts.length){\n', '          countCanAdd = _gameEncryptedTexts.length;\n', '        }\n', '        uint currentGameId = getCurrentGameId();\n', '        if(maxPlayableGameId < currentGameId){\n', '          maxPlayableGameId = currentGameId.sub(1);\n', '        }\n', '\n', '        for(uint i=0;i<countCanAdd;i++){\n', '            if(_gameEncryptedTexts[i] == 0x0){\n', '                continue;\n', '            }\n', '            maxPlayableGameId++;\n', '            gameInfo memory info = gameInfo({\n', '                Banker :currentBanker,\n', '                EncryptedText:  _gameEncryptedTexts[i],\n', '                GameRandon:  0x0,       \n', '                GameResult:0  \n', '            });\n', '            gameInfoOf[maxPlayableGameId] = info;\n', '            emit OnNewGame(maxPlayableGameId, msg.sender, _gameEncryptedTexts[i], getGameBeginTime(maxPlayableGameId), getGameEndTime(maxPlayableGameId), now, getEventId());\n', '        }\n', '        _result = true;\n', '    }\n', '\n', '    event OnPlay(address indexed _player,uint indexed _gameId, uint indexed _playNo, uint8 _betNum, uint256 _betAmount,uint _giftToken, uint _eventId,uint _eventTime);\n', '\n', '    function depositEther() public payable\n', '    {  \n', '        if (msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '        }\n', '    }\n', '\n', '    function playBigOrSmall(uint8 _betNum, uint256 _betAmount) public payable playable(_betAmount) returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        require(_betNum ==1 || _betNum == 2); \n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(_betNum, _betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playAnyTriples(uint256 _betAmount) public payable  playable(_betAmount)  returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(3, _betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playSpecificTriples(uint8 _betNum, uint256 _betAmount) public payable playable(_betAmount)  returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        require(_betNum >= 1 && _betNum <=6); \n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(_betNum + 3, _betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playSpecificDoubles(uint8 _betNum, uint256 _betAmount) public payable playable(_betAmount)  returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        require(_betNum >= 1 && _betNum <=6);\n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(_betNum + 9 , _betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playThreeDiceTotal(uint8 _betNum,uint256 _betAmount) public payable  playable(_betAmount)  returns(bool _result){      \n', '        lock();\n', '        depositEther();\n', '        require(_betNum >= 4 && _betNum <=17); \n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(_betNum + 12, _betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playDiceCombinations(uint8 _smallNum,uint8 _bigNum,uint256 _betAmount) public payable playable(_betAmount)  returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        require(_smallNum < _bigNum);\n', '        require(_smallNum >= 1 && _smallNum <=5); \n', '        require(_bigNum >= 2 && _bigNum <=6);\n', '        if (_betAmount > gameMaxBetAmount){             \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        uint8 _betNum = 0 ;\n', '        if(_smallNum == 1){\n', '            _betNum = 28+_bigNum;\n', '        }else if(_smallNum ==2){\n', '             _betNum = 32+_bigNum;\n', '        }else if(_smallNum == 3){\n', '             _betNum = 35+_bigNum;\n', '        }else if(_smallNum == 4){\n', '             _betNum = 37+_bigNum;\n', '        }else if(_smallNum == 5){\n', '            _betNum = 44;\n', '        }\n', '        _result = _play(_betNum,_betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function playSingleDiceBet(uint8 _betNum,uint256 _betAmount) public payable playable(_betAmount)  returns(bool _result){       \n', '        lock();\n', '        depositEther();\n', '        require(_betNum >= 1 && _betNum <=6);\n', '        if (_betAmount > gameMaxBetAmount){            \n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '        _result = _play(_betNum + 44,_betAmount,false);\n', '        unLock();\n', '    }\n', '\n', '    function _calOdds(uint8 _betNum) internal pure returns(uint8 _odds){\n', '        if(_betNum > 0 && _betNum <= 2){\n', '            return 1;\n', '        }else if(_betNum == 3){\n', '            return 24;\n', '        }else if(_betNum <= 9){\n', '            return 150;\n', '        }else if(_betNum <= 15){\n', '            return 8;\n', '        }else if(_betNum <= 29){\n', '            if(_betNum == 16 || _betNum == 29){ \n', '                return 50;\n', '            }else if(_betNum == 17 || _betNum == 28){ \n', '                return 18;\n', '            }else if(_betNum == 18 || _betNum == 27){\n', '               return 14;\n', '            }else if(_betNum == 19 || _betNum == 26){  \n', '                return 12;\n', '            }else if(_betNum == 20 || _betNum == 25){ \n', '                return 8;\n', '            }else{\n', '                return 6;\n', '            }\n', '        }else if(_betNum <= 44){\n', '            return 5;\n', '        }else if(_betNum <= 50){\n', '            return 3;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function playBatch(uint8[] _betNums,uint256[] _betAmounts) public payable returns(bool _result)\n', '    {   \n', '        lock();\n', '        _result = false;\n', '      \n', '        require(msg.sender != currentBanker);               \n', '        \n', '        uint currentGameId = getCurrentGameId();\n', '        \n', '        gameInfo  storage gi = gameInfoOf[currentGameId];\n', '        require (gi.GameResult == 0 && gi.Banker == currentBanker);\n', '        depositEther();\n', '        require(_betNums.length == _betAmounts.length);\n', '        require (_betNums.length <= 10);\n', '        _result = true ;\n', '        for(uint i = 0; i < _betNums.length && _result ; i++ ){\n', '            uint8 _betNum = _betNums[i];\n', '            uint256 _betAmount = _betAmounts[i];\n', '            if(_betAmount < gameMinBetAmount || _betNum > 50){\n', '               \n', '                continue ;\n', '            }\n', '            if (_betAmount > gameMaxBetAmount){             \n', '                _betAmount = gameMaxBetAmount;\n', '            }\n', '            _result =_play(_betNum,_betAmount,true);\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    function _play(uint8 _betNum,  uint256 _betAmount,bool isBatch) private  returns(bool _result)\n', '    {            \n', '        _result = false;\n', '        uint8 _odds = _calOdds(_betNum);\n', '        uint bankerAmount = _betAmount.mul(_odds);   \n', '        if(!isBatch){\n', '            require(userEtherOf[msg.sender] >= _betAmount);\n', '            require(userEtherOf[currentBanker] >= bankerAmount); \n', '        }else{\n', '            if(userEtherOf[msg.sender] < _betAmount  || userEtherOf[currentBanker] < bankerAmount){\n', '                return false;\n', '            }\n', '        }\n', '        uint currentGameId = getCurrentGameId();\n', '        gameInfo  storage gi = gameInfoOf[currentGameId];\n', '        require (gi.GameResult == 0 && gi.Banker == currentBanker);\n', '\n', '        betInfo memory bi = betInfo({\n', '            GameId : currentGameId ,\n', '            Player :  msg.sender,\n', '            BetNum : _betNum,\n', '            BetAmount : _betAmount,\n', '            Odds : _odds,\n', '            IsReturnAward: false,\n', '            IsWin :  false,\n', '            BetTime : now\n', '        });\n', '        playerBetInfoOf[playNo] = bi;\n', '        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(_betAmount);                  \n', '        userEtherOf[currentBanker] = userEtherOf[currentBanker].sub(bankerAmount);     \n', '        userEtherOf[this] = userEtherOf[this].add(_betAmount.add(bankerAmount));\n', '\n', '        gi.TotalBetInfoOf[_betNum] = gi.TotalBetInfoOf[_betNum].add(_betAmount.add(bankerAmount));\n', '\n', '        uint _giftToken = GameToken.mineToken(msg.sender,_betAmount);\n', '\n', '        emit OnPlay(msg.sender, currentGameId, playNo , _betNum,  _betAmount,_giftToken,getEventId(), now);\n', '\n', '        playNo++;\n', '        _result = true;\n', '    }\n', '    \n', '    function _getPlayDiceCombinationsIndex(uint8 _smallNum,uint8 _bigNum) internal pure returns(uint8 index)\n', '    {\n', '        if(_smallNum == 1){\n', '            return 28+_bigNum;\n', '        }else if(_smallNum ==2){\n', '             return 32+_bigNum;\n', '        }else if(_smallNum == 3){\n', '             return 35+_bigNum;\n', '        }else if(_smallNum == 4){\n', '             return 37+_bigNum;\n', '        }else if(_smallNum == 5){\n', '            return 44;\n', '        }\n', '    }\n', '\n', '    function uintToString(uint v) private pure returns (string)\n', '    {\n', '        uint maxlength = 3;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i); \n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; \n', '        }\n', '        string memory str = string(s); \n', '        return str; \n', '    }\n', '\n', '    event OnOpenGameResult(uint indexed _gameId,  address indexed _banker,bytes32 indexed _randon1,uint _gameResult, uint _eventId,uint _eventTime);\n', '\n', '    function openGameResult(uint _gameId,uint8 _minGameResult,uint8 _midGameResult,uint8 _maxGameResult, bytes32 _randon1) public  returns(bool _result)\n', '    {\n', '        _result =  _openGameResult(_gameId, _minGameResult,_midGameResult,_maxGameResult,_randon1);\n', '    }\n', '\n', '    function _openGameResult(uint _gameId,uint8 _minGameResult,uint8 _midGameResult, uint8 _maxGameResult, bytes32 _randon1) private  returns(bool _result)\n', '    {            \n', '        _result = false;\n', '        require(_minGameResult <= _midGameResult);\n', '        require(_midGameResult <= _maxGameResult);\n', '        require (_minGameResult >= 1 && _maxGameResult <= 6);\n', '        uint _gameEndTime = getGameEndTime(_gameId);\n', '        require (_gameEndTime < now);  \n', '        require (_gameEndTime + gameExpirationTime > now);  \n', '\n', '        gameInfo  storage gi = gameInfoOf[_gameId];\n', '        require(gi.Banker == msg.sender);\n', '        require(gi.GameResult == 0);\n', '        uint _gameResult = uint(_minGameResult)*100 + _midGameResult*10 + _maxGameResult;\n', '\n', '      require (keccak256(uintToString(_gameResult) ,gameRandon2, _randon1) ==  gi.EncryptedText);\n', '\n', '        gi.GameResult = _gameResult;\n', '        gi.GameRandon = _randon1;\n', '\n', '        emit OnOpenGameResult(_gameId, msg.sender,_randon1,  _gameResult, getEventId(),now);\n', '        lock();\n', '        _bankerCal(gi,_minGameResult,_midGameResult,_maxGameResult);\n', '        unLock();\n', '        _result = true;\n', '    }\n', '\n', '    function _bankerCal(gameInfo storage _gi,uint8 _minGameResult,uint8 _midGameResult, uint8 _maxGameResult) internal\n', '    {\n', '        uint _bankerAmount = 0;\n', '\n', '        mapping(uint8 => uint) _totalBetInfoOf = _gi.TotalBetInfoOf;\n', '\n', '        uint8 _threeDiceTotal = _minGameResult + _midGameResult + _maxGameResult;  \n', '        bool _isAnyTriple = (_minGameResult == _maxGameResult);\n', '        uint8 _doubleTriple = (_minGameResult == _midGameResult) ? _minGameResult : ((_midGameResult == _maxGameResult)? _maxGameResult: 0);\n', '\n', '        _bankerAmount = _bankerAmount.add(_sumAmount(_gi,16,29,_threeDiceTotal + 12));\n', '        _bankerAmount = _bankerAmount.add(_sumAmount(_gi,10,15,_doubleTriple +9));\n', '\n', '        if(_isAnyTriple){ \n', '          \n', '            _bankerAmount = _bankerAmount.add(_totalBetInfoOf[1]);\n', '            _bankerAmount = _bankerAmount.add(_totalBetInfoOf[2]);\n', '            _bankerAmount = _bankerAmount.add(_sumAmount(_gi,4,9,3+_minGameResult));\n', '            _bankerAmount = _bankerAmount.add(_sumAmount(_gi,30,44,0));  \n', '            _bankerAmount = _bankerAmount.add(_sumAmount(_gi,45,50,_minGameResult + 44));  \n', '        }else{\n', '            \n', '            _bankerAmount = _bankerAmount.add(_sumAmount(_gi,3,9,0));\n', '            if(_threeDiceTotal >= 11){ \n', '                _bankerAmount = _bankerAmount.add(_totalBetInfoOf[1]);\n', '            }else{\n', '                _bankerAmount = _bankerAmount.add(_totalBetInfoOf[2]);\n', '            }\n', '            _bankerAmount = _bankerAmount.add(_bankerCalOther(_gi,_minGameResult,_midGameResult,_maxGameResult,_doubleTriple));\n', '        }\n', '         \n', '        userEtherOf[_gi.Banker] =userEtherOf[_gi.Banker].add(_bankerAmount);\n', '        userEtherOf[this] =userEtherOf[this].sub(_bankerAmount);\n', '    }\n', '\n', '    function _bankerCalOther(gameInfo storage _gi,uint8 _minGameResult,uint8 _midGameResult, uint8 _maxGameResult,uint8 _doubleTriple) private view returns(uint _bankerAmount) {\n', '        \n', '        mapping(uint8 => uint) _totalBetInfoOf = _gi.TotalBetInfoOf;\n', '        if(_doubleTriple != 0){\n', '            \n', '            if(_maxGameResult == _doubleTriple){\n', '               \n', '                uint8 _index1 = _getPlayDiceCombinationsIndex(_minGameResult,_midGameResult);\n', '                uint8 _index2 = _minGameResult + 44; \n', '            }else if(_minGameResult == _doubleTriple){\n', '                \n', '                _index1 =_getPlayDiceCombinationsIndex(_midGameResult,_maxGameResult);\n', '                _index2 = _maxGameResult + 44; \n', '            }\n', '            _bankerAmount = _bankerAmount.add(_sumAmount(_gi,30,44,_index1));  \n', '\n', '            uint8 _index3= _midGameResult + 44; \n', '            for(uint8 i=45;i<=50;i++){\n', '                if(i == _index3){\n', '                    \n', '                    _betAmount = _totalBetInfoOf[i];\n', '                    _bankerAmount = _bankerAmount.add(_betAmount.div(4));\n', '                }else if(i == _index2){\n', '                    \n', '                    _betAmount = _totalBetInfoOf[i];\n', '                    _bankerAmount = _bankerAmount.add(_betAmount.div(2));\n', '                }else{\n', '                    \n', '                    _bankerAmount = _bankerAmount.add(_totalBetInfoOf[i]);\n', '                }\n', '            }\n', '        }else{\n', '              \n', '            _index1 = _getPlayDiceCombinationsIndex(_minGameResult,_midGameResult);\n', '            _index2 = _getPlayDiceCombinationsIndex(_minGameResult,_maxGameResult);\n', '            _index3 = _getPlayDiceCombinationsIndex(_midGameResult,_maxGameResult);\n', '\n', '            for(i=30;i<=44;i++){\n', '                if(i != _index1 && i != _index2 && i != _index3){\n', '                    _bankerAmount = _bankerAmount.add(_totalBetInfoOf[i]);\n', '                }\n', '            }\n', '           \n', '            _index1 = _minGameResult+44;\n', '            _index2 = _midGameResult+44;\n', '            _index3 = _maxGameResult+44;\n', '            uint _betAmount = 0 ;\n', '            for(i=45;i<=50;i++){\n', '                if(i != _index1 && i != _index2 && i != _index3){\n', '                   \n', '                     _bankerAmount = _bankerAmount.add(_totalBetInfoOf[i]);\n', '                }else{\n', '                    \n', '                    _betAmount = _totalBetInfoOf[i];\n', '                    _bankerAmount = _bankerAmount.add(_betAmount.div(2)); \n', '                }\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '    function _sumAmount(gameInfo storage _gi,uint8 _startIndex,uint8 _endIndex,uint8 _excludeIndex) internal view returns(uint _totalAmount)\n', '    {   \n', '        _totalAmount = 0 ;\n', '        for(uint8 i=_startIndex;i<=_endIndex;i++){\n', '            if(i != _excludeIndex){\n', '                _totalAmount = _totalAmount.add(_gi.TotalBetInfoOf[i]);\n', '            }\n', '        }\n', '        return _totalAmount;\n', '    }\n', '\n', '    event OnGetAward(uint indexed _playNo,uint indexed _gameId, address indexed _player, uint _betNum, uint _betAmount,uint _awardAmount, uint _gameResult,uint _eventTime, uint _eventId);\n', '    \n', '    function getAwards(uint[] playNos) public\n', '    {   \n', '        lock();\n', '\n', '        for(uint i=0;i<playNos.length;i++){\n', '            if(playNos[i] > playNo){\n', '                continue; \n', '            }\n', '            betInfo storage p = playerBetInfoOf[playNos[i]];\n', '            if(p.IsReturnAward){\n', '                continue;\n', '            }\n', '\n', '            gameInfo storage _gi = gameInfoOf[p.GameId];\n', '            uint _gameEndTime = getGameEndTime(p.GameId);\n', '            uint _awardAmount = 0; \n', '            if(isGameExpiration(p.GameId)){\n', '                uint AllAmount = p.BetAmount.mul(1 + p.Odds); \n', '                userEtherOf[this] =userEtherOf[this].sub(AllAmount);\n', '                p.IsReturnAward = true;\n', '                if(now > _gameEndTime+ 30 days){\n', '                    userEtherOf[_gi.Banker] =userEtherOf[_gi.Banker].add(AllAmount);                   \n', '                }else{\n', '                    p.IsWin = true ; \n', '                    userEtherOf[p.Player] =userEtherOf[p.Player].add(AllAmount);\n', '                    _awardAmount = AllAmount;                \n', '                }                   \n', '            }else if(_gi.GameResult != 0){ \n', '                p.IsReturnAward = true;\n', '                uint8 _realOdd = _playRealOdds(p.BetNum,p.Odds,_gi.GameResult);\n', '                if(_realOdd > 0){ \n', '                    uint256 winAmount = p.BetAmount.mul(1 + _realOdd); \n', '                    p.Odds = _realOdd;\n', '                    userEtherOf[this] = userEtherOf[this].sub(winAmount);\n', '                    if(now > _gameEndTime + 30 days){\n', '                        \n', '                        userEtherOf[_gi.Banker] = userEtherOf[_gi.Banker].add(winAmount);\n', '                    }else{\n', '                        p.IsWin = true ;\n', '                        userEtherOf[p.Player] =  userEtherOf[p.Player].add(winAmount);\n', '                        _awardAmount = winAmount;\n', '                    }\n', '                }\n', '               \n', '            }\n', '            emit OnGetAward(playNos[i], p.GameId, p.Player,  p.BetNum, p.BetAmount, _awardAmount, _gi.GameResult, now, getEventId());\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    function _playRealOdds(uint8 _betNum,uint8 _odds,uint _gameResult) private  pure returns(uint8 _realOdds)\n', '    {\n', '        uint8 _minGameResult = uint8(_gameResult/100);\n', '        uint8 _midGameResult = uint8(_gameResult/10%10);\n', '        uint8 _maxGameResult = uint8(_gameResult%10);\n', '\n', '        _realOdds = 0;\n', '        uint8 _smallNum = 0;\n', '        uint8 _bigNum = 0;\n', '        if(_betNum <=2){\n', '            \n', '            if(_minGameResult == _maxGameResult){\n', '                return 0;\n', '            }\n', '            uint8 _threeDiceTotal = _minGameResult + _midGameResult +_maxGameResult ; \n', '            uint _bigOrSmall = _threeDiceTotal >= 11 ? 2 : 1 ; \n', '            _smallNum = _betNum;\n', '            if(_bigOrSmall == _smallNum){\n', '                _realOdds = _odds;\n', '            }\n', '        }else if(_betNum == 3){\n', '            if(_minGameResult == _maxGameResult){\n', '                _realOdds = _odds;\n', '            }\n', '        }else if(_betNum <= 9){\n', '            uint _specificTriple  = (_minGameResult == _maxGameResult) ? _minGameResult : 0 ; \n', '            _smallNum = _betNum - 3 ;\n', '            if( _specificTriple == _smallNum){\n', '                _realOdds = _odds;\n', '            }\n', '        }else if(_betNum <= 15){\n', '            uint _doubleTriple = (_minGameResult == _midGameResult) ? _minGameResult : ((_midGameResult == _maxGameResult)? _maxGameResult: 0);\n', '            _smallNum = _betNum - 9 ;\n', '            if(_doubleTriple == _smallNum){\n', '                _realOdds = _odds;\n', '            }\n', '        }else if(_betNum <= 29){\n', '            _threeDiceTotal = _minGameResult + _midGameResult + _maxGameResult ;  \n', '            _smallNum = _betNum - 12 ;\n', '            if(_threeDiceTotal == _smallNum){\n', '                _realOdds = _odds;\n', '            }\n', '        }else  if(_betNum <= 44){\n', '            \n', '            if(_betNum <= 34){\n', '                _smallNum = 1;\n', '                _bigNum = _betNum - 28;\n', '            }else if(_betNum <= 38){\n', '                _smallNum = 2;\n', '                _bigNum = _betNum - 32;\n', '            }else if(_betNum <=41){\n', '                 _smallNum = 3;\n', '                _bigNum = _betNum - 35;\n', '            }else if(_betNum <=43){\n', '                 _smallNum = 4;\n', '                _bigNum = _betNum - 37;\n', '            }else{\n', '                _smallNum = 5;\n', '                _bigNum = 6;\n', '            }\n', '            if(_smallNum == _minGameResult || _smallNum == _midGameResult){\n', '                if(_bigNum == _midGameResult || _bigNum == _maxGameResult){\n', '                    _realOdds = _odds;\n', '                }\n', '            }\n', '        }else if(_betNum <= 50){\n', '            \n', '            _smallNum = _betNum - 44;\n', '            if(_smallNum == _minGameResult){\n', '                _realOdds++;\n', '            }\n', '            if(_smallNum == _midGameResult){\n', '                _realOdds++;\n', '            }\n', '            if(_smallNum == _maxGameResult){\n', '                _realOdds++;\n', '            }\n', '        }\n', '        return _realOdds;\n', '    }\n', '\n', '    function () public payable {       \n', '        if(msg.value > 0){              \n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);   \n', '        }\n', '    }\n', '}']