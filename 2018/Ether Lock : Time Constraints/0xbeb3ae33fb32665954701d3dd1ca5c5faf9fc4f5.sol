['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', 'contract ARPHoldingWallet {\n', '    using SafeERC20 for ERC20;\n', '\n', '    // Middle term holding\n', '    uint256 constant MID_TERM   = 1 finney; // = 0.001 ether\n', '    // Long term holding\n', '    uint256 constant LONG_TERM  = 2 finney; // = 0.002 ether\n', '\n', '    uint256 constant GAS_LIMIT  = 200000;\n', '\n', '    address owner;\n', '\n', '    // ERC20 basic token contract being held\n', '    ERC20 arpToken;\n', '    address midTermHolding;\n', '    address longTermHolding;\n', '\n', '    /// Initialize the contract\n', '    constructor(address _owner, ERC20 _arpToken, address _midTermHolding, address _longTermHolding) public {\n', '        owner = _owner;\n', '        arpToken = _arpToken;\n', '        midTermHolding = _midTermHolding;\n', '        longTermHolding = _longTermHolding;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    function() payable public {\n', '        require(msg.sender == owner);\n', '\n', '        if (msg.value == MID_TERM) {\n', '            depositOrWithdraw(midTermHolding);\n', '        } else if (msg.value == LONG_TERM) {\n', '            depositOrWithdraw(longTermHolding);\n', '        } else if (msg.value == 0) {\n', '            drain();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function depositOrWithdraw(address _holding) private {\n', '        uint256 amount = arpToken.balanceOf(address(this));\n', '        if (amount > 0) {\n', '            arpToken.safeApprove(_holding, amount);\n', '        }\n', '        require(_holding.call.gas(GAS_LIMIT)());\n', '        amount = arpToken.balanceOf(address(this));\n', '        if (amount > 0) {\n', '            arpToken.safeTransfer(msg.sender, amount);\n', '        }\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '\n', '    /// Drains ARP.\n', '    function drain() private {\n', '        uint256 amount = arpToken.balanceOf(address(this));\n', '        require(amount > 0);\n', '\n', '        arpToken.safeTransfer(owner, amount);\n', '    }\n', '}\n', '\n', 'contract ARPHoldingWalletCreator {\n', '    /* \n', '     * EVENTS\n', '     */\n', '    event Created(address indexed _owner, address _wallet);\n', '\n', '    mapping (address => address) public wallets;\n', '    ERC20 public arpToken;\n', '    address public midTermHolding;\n', '    address public longTermHolding;\n', '\n', '    constructor(ERC20 _arpToken, address _midTermHolding, address _longTermHolding) public {\n', '        arpToken = _arpToken;\n', '        midTermHolding = _midTermHolding;\n', '        longTermHolding = _longTermHolding;\n', '    }\n', '\n', '    function() public {\n', '        require(wallets[msg.sender] == address(0x0));\n', '\n', '        address wallet = new ARPHoldingWallet(msg.sender, arpToken, midTermHolding, longTermHolding);\n', '        wallets[msg.sender] = wallet;\n', '\n', '        emit Created(msg.sender, wallet);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', 'contract ARPHoldingWallet {\n', '    using SafeERC20 for ERC20;\n', '\n', '    // Middle term holding\n', '    uint256 constant MID_TERM   = 1 finney; // = 0.001 ether\n', '    // Long term holding\n', '    uint256 constant LONG_TERM  = 2 finney; // = 0.002 ether\n', '\n', '    uint256 constant GAS_LIMIT  = 200000;\n', '\n', '    address owner;\n', '\n', '    // ERC20 basic token contract being held\n', '    ERC20 arpToken;\n', '    address midTermHolding;\n', '    address longTermHolding;\n', '\n', '    /// Initialize the contract\n', '    constructor(address _owner, ERC20 _arpToken, address _midTermHolding, address _longTermHolding) public {\n', '        owner = _owner;\n', '        arpToken = _arpToken;\n', '        midTermHolding = _midTermHolding;\n', '        longTermHolding = _longTermHolding;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    function() payable public {\n', '        require(msg.sender == owner);\n', '\n', '        if (msg.value == MID_TERM) {\n', '            depositOrWithdraw(midTermHolding);\n', '        } else if (msg.value == LONG_TERM) {\n', '            depositOrWithdraw(longTermHolding);\n', '        } else if (msg.value == 0) {\n', '            drain();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function depositOrWithdraw(address _holding) private {\n', '        uint256 amount = arpToken.balanceOf(address(this));\n', '        if (amount > 0) {\n', '            arpToken.safeApprove(_holding, amount);\n', '        }\n', '        require(_holding.call.gas(GAS_LIMIT)());\n', '        amount = arpToken.balanceOf(address(this));\n', '        if (amount > 0) {\n', '            arpToken.safeTransfer(msg.sender, amount);\n', '        }\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '\n', '    /// Drains ARP.\n', '    function drain() private {\n', '        uint256 amount = arpToken.balanceOf(address(this));\n', '        require(amount > 0);\n', '\n', '        arpToken.safeTransfer(owner, amount);\n', '    }\n', '}\n', '\n', 'contract ARPHoldingWalletCreator {\n', '    /* \n', '     * EVENTS\n', '     */\n', '    event Created(address indexed _owner, address _wallet);\n', '\n', '    mapping (address => address) public wallets;\n', '    ERC20 public arpToken;\n', '    address public midTermHolding;\n', '    address public longTermHolding;\n', '\n', '    constructor(ERC20 _arpToken, address _midTermHolding, address _longTermHolding) public {\n', '        arpToken = _arpToken;\n', '        midTermHolding = _midTermHolding;\n', '        longTermHolding = _longTermHolding;\n', '    }\n', '\n', '    function() public {\n', '        require(wallets[msg.sender] == address(0x0));\n', '\n', '        address wallet = new ARPHoldingWallet(msg.sender, arpToken, midTermHolding, longTermHolding);\n', '        wallets[msg.sender] = wallet;\n', '\n', '        emit Created(msg.sender, wallet);\n', '    }\n', '}']
