['pragma solidity ^0.4.25;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BasicAccountInfo {\n', '    using SafeMath for uint;\n', '\n', '    address constant public creatorAddress = 0xcDee178ed5B1968549810A237767ec388a3f83ba;\n', '    address constant public ecologyAddress = 0xe87C12E6971AAf04DB471e5f93629C8B6F31b8C2;\n', '    address constant public investorAddress = 0x660363e67485D2B51C071f42421b3DD134D3A835;\n', '    address constant public partnerAddress = 0xabcf257c90dfE5E3b5Fcd777797213F36F9aB25e;\n', '\n', '    struct BasicAccount {\n', '        uint256 initialBalance;\n', '        uint256 frozenBalance;\n', '        uint256 availableBalance;\n', '    }\n', '\n', '    mapping (address => BasicAccount) public accountInfoMap;\n', '\n', '    uint8 private frozenRatio = 60;\n', '    uint8 private frozenRatioUnit = 100;\n', '\n', '    address public owner;   //contract create by owner\n', '\n', '    function BasicAccountInfo(uint8 _decimal) public {\n', '        owner = msg.sender;\n', '\n', '        initialCreatorAccount(_decimal);\n', '        initialEcologyAccount(_decimal);\n', '        initialInvestorAccount(_decimal);\n', '        initialPartnerAccount(_decimal);\n', '    }\n', '\n', '    function initialCreatorAccount(uint8 _decimal) private {\n', '        uint256 creatorInitialBalance = 37500000 * (10**(uint256(_decimal)));\n', '        uint256 creatorFrozenBalance = creatorInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 creatorAvailableBalance = creatorInitialBalance - creatorFrozenBalance;\n', '\n', '        accountInfoMap[creatorAddress] = BasicAccount(creatorInitialBalance, creatorFrozenBalance, creatorAvailableBalance);\n', '    }\n', '\n', '    function initialEcologyAccount(uint8 _decimal) private {\n', '        uint256 ecologyInitialBalance = 25000000 * (10**(uint256(_decimal)));\n', '        uint256 ecologyFrozenBalance = ecologyInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 ecologyAvailableBalance = ecologyInitialBalance - ecologyFrozenBalance;\n', '\n', '        accountInfoMap[ecologyAddress] = BasicAccount(ecologyInitialBalance, ecologyFrozenBalance, ecologyAvailableBalance);\n', '    }\n', '\n', '    function initialInvestorAccount(uint8 _decimal) private {\n', '        uint256 investorInitialBalance = 37500000 * (10**(uint256(_decimal)));\n', '        uint256 investorFrozenBalance = investorInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 investorAvailableBalance = investorInitialBalance - investorFrozenBalance;\n', '\n', '        accountInfoMap[investorAddress] = BasicAccount(investorInitialBalance, investorFrozenBalance, investorAvailableBalance);\n', '    }\n', '\n', '    function initialPartnerAccount(uint8 _decimal) private {\n', '        uint256 partnerInitialBalance = 25000000 * (10**(uint256(_decimal)));\n', '        uint256 partnerFrozenBalance = partnerInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 partnerAvailableBalance = partnerInitialBalance - partnerFrozenBalance;\n', '\n', '        accountInfoMap[partnerAddress] = BasicAccount(partnerInitialBalance, partnerFrozenBalance, partnerAvailableBalance);\n', '    }\n', '\n', '    function getTotalFrozenBalance() public view returns (uint256 totalFrozenBalance) {\n', '        return accountInfoMap[creatorAddress].frozenBalance + accountInfoMap[ecologyAddress].frozenBalance +\n', '                        accountInfoMap[investorAddress].frozenBalance + accountInfoMap[partnerAddress].frozenBalance;\n', '    }\n', '\n', '    function getInitialBalanceByAddress(address _address) public view returns (uint256 initialBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.initialBalance;\n', '    }\n', '\n', '    function getAvailableBalanceByAddress(address _address) public view returns (uint256 availableBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.availableBalance;\n', '    }\n', '\n', '    function getFrozenBalanceByAddress(address _address) public view returns (uint256 frozenBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.frozenBalance;\n', '    }\n', '\n', '    function releaseFrozenBalance() public {\n', '        require(owner == msg.sender);\n', '\n', '        accountInfoMap[creatorAddress].availableBalance = accountInfoMap[creatorAddress].availableBalance.add(accountInfoMap[creatorAddress].frozenBalance);\n', '        accountInfoMap[ecologyAddress].availableBalance = accountInfoMap[ecologyAddress].availableBalance.add(accountInfoMap[ecologyAddress].frozenBalance);\n', '        accountInfoMap[investorAddress].availableBalance = accountInfoMap[investorAddress].availableBalance.add(accountInfoMap[investorAddress].frozenBalance);\n', '        accountInfoMap[partnerAddress].availableBalance = accountInfoMap[partnerAddress].availableBalance.add(accountInfoMap[partnerAddress].frozenBalance);\n', '\n', '        accountInfoMap[creatorAddress].frozenBalance = 0;\n', '        accountInfoMap[ecologyAddress].frozenBalance = 0;\n', '        accountInfoMap[investorAddress].frozenBalance = 0;\n', '        accountInfoMap[partnerAddress].frozenBalance = 0;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ERC20 is ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) private balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    uint256 public totalAvailable;\n', '\n', '    bool public transfersEnabled;\n', '    BasicAccountInfo private basicAccountInfo;\n', '    address public owner;   //contract create by owner\n', '\n', '    bool public released;\n', '    uint256 public frozenTime;  //second\n', '    uint256 public releaseTime;  //second\n', '    uint256 constant private frozenPeriod = 100;  //days\n', '    \n', '    event Release(address indexed _owner);\n', '\n', '    function ERC20(uint8 decimals) public {\n', '        totalSupply = 250000000 * (10**(uint256(decimals)));\n', '        transfersEnabled = true;\n', '        released = false;\n', '\n', '        owner = msg.sender;\n', '        basicAccountInfo = new BasicAccountInfo(decimals);\n', '\n', '        InitialBasicBalance();\n', '        initialFrozenTime();\n', '    }\n', '\n', '    function InitialBasicBalance() private {\n', '        totalAvailable = totalSupply - basicAccountInfo.getTotalFrozenBalance();\n', '        balances[owner] = totalSupply.div(2);\n', '        \n', '        balances[basicAccountInfo.creatorAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.creatorAddress());\n', '        balances[basicAccountInfo.ecologyAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.ecologyAddress());\n', '        balances[basicAccountInfo.investorAddress()] =basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.investorAddress());\n', '        balances[basicAccountInfo.partnerAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.partnerAddress());\n', '    }\n', '\n', '    function releaseBasicAccount() private {\n', '        balances[basicAccountInfo.creatorAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.creatorAddress());\n', '        balances[basicAccountInfo.ecologyAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.ecologyAddress());\n', '        balances[basicAccountInfo.investorAddress()] +=basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.investorAddress());\n', '        balances[basicAccountInfo.partnerAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.partnerAddress());\n', '\n', '        totalAvailable += basicAccountInfo.getTotalFrozenBalance();\n', '    }\n', '\n', '    function releaseToken() public returns (bool) {\n', '        require(owner == msg.sender);\n', '\n', '        if(released){\n', '            return false;\n', '        }\n', '\n', '        if(block.timestamp > releaseTime) {\n', '            releaseBasicAccount();\n', '            basicAccountInfo.releaseFrozenBalance();\n', '            released = true;\n', '            emit Release(owner);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function getFrozenBalanceByAddress(address _address) public view returns (uint256 frozenBalance) {\n', '        return basicAccountInfo.getFrozenBalanceByAddress(_address);\n', '    }\n', '\n', '    function getInitialBalanceByAddress(address _address) public view returns (uint256 initialBalance) {\n', '        return basicAccountInfo.getInitialBalanceByAddress(_address);\n', '    }\n', '\n', '    function getTotalFrozenBalance() public view returns (uint256 totalFrozenBalance) {\n', '        return basicAccountInfo.getTotalFrozenBalance();\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(transfersEnabled);\n', '\n', '        require(_to != 0x0);\n', '        require(balances[msg.sender] >= _value);\n', '        require((balances[_to] + _value )> balances[_to]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function enableTransfers(bool _transfersEnabled) {\n', '        require(owner == msg.sender);\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '    function initialFrozenTime() private {\n', '        frozenTime = block.timestamp;\n', '        uint256 secondsPerDay = 3600 * 24;\n', '        releaseTime = frozenPeriod * secondsPerDay  + frozenTime;\n', '    }\n', '}\n', '\n', 'contract BiTianToken is ERC20 {\n', '    string public name = "Bitian Token";\n', '    string public symbol = "BTT";\n', '    string public version = &#39;1.0.0&#39;;\n', '    uint8 public decimals = 18;\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     */\n', '    function BiTianToken() ERC20(decimals) {\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BasicAccountInfo {\n', '    using SafeMath for uint;\n', '\n', '    address constant public creatorAddress = 0xcDee178ed5B1968549810A237767ec388a3f83ba;\n', '    address constant public ecologyAddress = 0xe87C12E6971AAf04DB471e5f93629C8B6F31b8C2;\n', '    address constant public investorAddress = 0x660363e67485D2B51C071f42421b3DD134D3A835;\n', '    address constant public partnerAddress = 0xabcf257c90dfE5E3b5Fcd777797213F36F9aB25e;\n', '\n', '    struct BasicAccount {\n', '        uint256 initialBalance;\n', '        uint256 frozenBalance;\n', '        uint256 availableBalance;\n', '    }\n', '\n', '    mapping (address => BasicAccount) public accountInfoMap;\n', '\n', '    uint8 private frozenRatio = 60;\n', '    uint8 private frozenRatioUnit = 100;\n', '\n', '    address public owner;   //contract create by owner\n', '\n', '    function BasicAccountInfo(uint8 _decimal) public {\n', '        owner = msg.sender;\n', '\n', '        initialCreatorAccount(_decimal);\n', '        initialEcologyAccount(_decimal);\n', '        initialInvestorAccount(_decimal);\n', '        initialPartnerAccount(_decimal);\n', '    }\n', '\n', '    function initialCreatorAccount(uint8 _decimal) private {\n', '        uint256 creatorInitialBalance = 37500000 * (10**(uint256(_decimal)));\n', '        uint256 creatorFrozenBalance = creatorInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 creatorAvailableBalance = creatorInitialBalance - creatorFrozenBalance;\n', '\n', '        accountInfoMap[creatorAddress] = BasicAccount(creatorInitialBalance, creatorFrozenBalance, creatorAvailableBalance);\n', '    }\n', '\n', '    function initialEcologyAccount(uint8 _decimal) private {\n', '        uint256 ecologyInitialBalance = 25000000 * (10**(uint256(_decimal)));\n', '        uint256 ecologyFrozenBalance = ecologyInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 ecologyAvailableBalance = ecologyInitialBalance - ecologyFrozenBalance;\n', '\n', '        accountInfoMap[ecologyAddress] = BasicAccount(ecologyInitialBalance, ecologyFrozenBalance, ecologyAvailableBalance);\n', '    }\n', '\n', '    function initialInvestorAccount(uint8 _decimal) private {\n', '        uint256 investorInitialBalance = 37500000 * (10**(uint256(_decimal)));\n', '        uint256 investorFrozenBalance = investorInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 investorAvailableBalance = investorInitialBalance - investorFrozenBalance;\n', '\n', '        accountInfoMap[investorAddress] = BasicAccount(investorInitialBalance, investorFrozenBalance, investorAvailableBalance);\n', '    }\n', '\n', '    function initialPartnerAccount(uint8 _decimal) private {\n', '        uint256 partnerInitialBalance = 25000000 * (10**(uint256(_decimal)));\n', '        uint256 partnerFrozenBalance = partnerInitialBalance * uint256(frozenRatio) / uint256(frozenRatioUnit);\n', '        uint256 partnerAvailableBalance = partnerInitialBalance - partnerFrozenBalance;\n', '\n', '        accountInfoMap[partnerAddress] = BasicAccount(partnerInitialBalance, partnerFrozenBalance, partnerAvailableBalance);\n', '    }\n', '\n', '    function getTotalFrozenBalance() public view returns (uint256 totalFrozenBalance) {\n', '        return accountInfoMap[creatorAddress].frozenBalance + accountInfoMap[ecologyAddress].frozenBalance +\n', '                        accountInfoMap[investorAddress].frozenBalance + accountInfoMap[partnerAddress].frozenBalance;\n', '    }\n', '\n', '    function getInitialBalanceByAddress(address _address) public view returns (uint256 initialBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.initialBalance;\n', '    }\n', '\n', '    function getAvailableBalanceByAddress(address _address) public view returns (uint256 availableBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.availableBalance;\n', '    }\n', '\n', '    function getFrozenBalanceByAddress(address _address) public view returns (uint256 frozenBalance) {\n', '        BasicAccount basicAccount = accountInfoMap[_address];\n', '        return basicAccount.frozenBalance;\n', '    }\n', '\n', '    function releaseFrozenBalance() public {\n', '        require(owner == msg.sender);\n', '\n', '        accountInfoMap[creatorAddress].availableBalance = accountInfoMap[creatorAddress].availableBalance.add(accountInfoMap[creatorAddress].frozenBalance);\n', '        accountInfoMap[ecologyAddress].availableBalance = accountInfoMap[ecologyAddress].availableBalance.add(accountInfoMap[ecologyAddress].frozenBalance);\n', '        accountInfoMap[investorAddress].availableBalance = accountInfoMap[investorAddress].availableBalance.add(accountInfoMap[investorAddress].frozenBalance);\n', '        accountInfoMap[partnerAddress].availableBalance = accountInfoMap[partnerAddress].availableBalance.add(accountInfoMap[partnerAddress].frozenBalance);\n', '\n', '        accountInfoMap[creatorAddress].frozenBalance = 0;\n', '        accountInfoMap[ecologyAddress].frozenBalance = 0;\n', '        accountInfoMap[investorAddress].frozenBalance = 0;\n', '        accountInfoMap[partnerAddress].frozenBalance = 0;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ERC20 is ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) private balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    uint256 public totalAvailable;\n', '\n', '    bool public transfersEnabled;\n', '    BasicAccountInfo private basicAccountInfo;\n', '    address public owner;   //contract create by owner\n', '\n', '    bool public released;\n', '    uint256 public frozenTime;  //second\n', '    uint256 public releaseTime;  //second\n', '    uint256 constant private frozenPeriod = 100;  //days\n', '    \n', '    event Release(address indexed _owner);\n', '\n', '    function ERC20(uint8 decimals) public {\n', '        totalSupply = 250000000 * (10**(uint256(decimals)));\n', '        transfersEnabled = true;\n', '        released = false;\n', '\n', '        owner = msg.sender;\n', '        basicAccountInfo = new BasicAccountInfo(decimals);\n', '\n', '        InitialBasicBalance();\n', '        initialFrozenTime();\n', '    }\n', '\n', '    function InitialBasicBalance() private {\n', '        totalAvailable = totalSupply - basicAccountInfo.getTotalFrozenBalance();\n', '        balances[owner] = totalSupply.div(2);\n', '        \n', '        balances[basicAccountInfo.creatorAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.creatorAddress());\n', '        balances[basicAccountInfo.ecologyAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.ecologyAddress());\n', '        balances[basicAccountInfo.investorAddress()] =basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.investorAddress());\n', '        balances[basicAccountInfo.partnerAddress()] = basicAccountInfo.getAvailableBalanceByAddress(basicAccountInfo.partnerAddress());\n', '    }\n', '\n', '    function releaseBasicAccount() private {\n', '        balances[basicAccountInfo.creatorAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.creatorAddress());\n', '        balances[basicAccountInfo.ecologyAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.ecologyAddress());\n', '        balances[basicAccountInfo.investorAddress()] +=basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.investorAddress());\n', '        balances[basicAccountInfo.partnerAddress()] += basicAccountInfo.getFrozenBalanceByAddress(basicAccountInfo.partnerAddress());\n', '\n', '        totalAvailable += basicAccountInfo.getTotalFrozenBalance();\n', '    }\n', '\n', '    function releaseToken() public returns (bool) {\n', '        require(owner == msg.sender);\n', '\n', '        if(released){\n', '            return false;\n', '        }\n', '\n', '        if(block.timestamp > releaseTime) {\n', '            releaseBasicAccount();\n', '            basicAccountInfo.releaseFrozenBalance();\n', '            released = true;\n', '            emit Release(owner);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function getFrozenBalanceByAddress(address _address) public view returns (uint256 frozenBalance) {\n', '        return basicAccountInfo.getFrozenBalanceByAddress(_address);\n', '    }\n', '\n', '    function getInitialBalanceByAddress(address _address) public view returns (uint256 initialBalance) {\n', '        return basicAccountInfo.getInitialBalanceByAddress(_address);\n', '    }\n', '\n', '    function getTotalFrozenBalance() public view returns (uint256 totalFrozenBalance) {\n', '        return basicAccountInfo.getTotalFrozenBalance();\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(transfersEnabled);\n', '\n', '        require(_to != 0x0);\n', '        require(balances[msg.sender] >= _value);\n', '        require((balances[_to] + _value )> balances[_to]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function enableTransfers(bool _transfersEnabled) {\n', '        require(owner == msg.sender);\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '    function initialFrozenTime() private {\n', '        frozenTime = block.timestamp;\n', '        uint256 secondsPerDay = 3600 * 24;\n', '        releaseTime = frozenPeriod * secondsPerDay  + frozenTime;\n', '    }\n', '}\n', '\n', 'contract BiTianToken is ERC20 {\n', '    string public name = "Bitian Token";\n', '    string public symbol = "BTT";\n', "    string public version = '1.0.0';\n", '    uint8 public decimals = 18;\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     */\n', '    function BiTianToken() ERC20(decimals) {\n', '    }\n', '}']
