['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract BaseGame { \n', '\tfunction canSetBanker() view public returns (bool _result);\n', '    function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);\n', '    \n', '    string public gameName = "NO.1";\n', '    uint public gameType = 2004;\n', '    string public officialGameUrl;\n', '\n', '\tuint public bankerBeginTime;\n', '\tuint public bankerEndTime;\n', '\taddress public currentBanker;\n', '\t\n', '\tfunction depositToken(uint256 _amount) public;\n', '\tfunction withdrawAllToken() public;\n', '    function withdrawToken(uint256 _amount) public;\n', '    mapping (address => uint256) public userTokenOf;\n', '\n', '}\n', 'interface IDonQuixoteToken{\n', '    function withhold(address _user,  uint256 _amount) external returns (bool _result);\n', '    function transfer(address _to, uint256 _value) external;\n', '\t//function canSendGameGift() view external returns(bool _result);\n', '    function sendGameGift(address _player) external returns (bool _result);\n', '\tfunction logPlaying(address _player) external returns (bool _result);\n', '\tfunction balanceOf(address _user) constant external returns(uint256 balance);\n', '}  \n', '\n', '\n', 'contract Base is BaseGame{\n', '\tusing SafeMath for uint256; \n', '    uint public createTime = now;\n', '    address public owner;\n', '\tIDonQuixoteToken public DonQuixoteToken;\n', '\n', '    function Base() public {\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    bool public globalLocked = false;\n', '\n', '    function lock() internal {\n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }\n', '\n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;\n', '    }\n', '\t\n', '\tfunction tokenOf(address _user) view public returns(uint256 _result){\n', '\t\t_result = DonQuixoteToken.balanceOf(_user);\n', '\t}\n', '    \n', '    function depositToken(uint256 _amount) public {\n', '        lock();\n', '        _depositToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _depositToken(address _to, uint256 _amount) internal {\n', '        require(_to != 0x0);\n', '        DonQuixoteToken.withhold(_to, _amount);\n', '        userTokenOf[_to] = userTokenOf[_to].add(_amount);\n', '    }\n', '\n', '    function withdrawAllToken() public {    \n', '        lock();  \n', '\t\tuint256 _amount = userTokenOf[msg.sender];\n', '        _withdrawToken(msg.sender,_amount);\n', '        unLock();\n', '    }\n', '\t\n', '\tfunction withdrawToken(uint256 _amount) public {   \n', '        lock();  \n', '        _withdrawToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\t\n', '    function _withdrawToken(address _from, uint256 _amount) internal {\n', '        require(_from != 0x0);\n', '\t\trequire(_amount > 0 && _amount <= userTokenOf[_from]);\n', '\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n', '\t\tDonQuixoteToken.transfer(_from, _amount);\n', '    }\n', '\t\n', '\tuint public currentEventId = 1;\n', '\n', '    function getEventId() internal returns(uint _result) {\n', '        _result = currentEventId;\n', '        currentEventId = currentEventId.add(1); //currentEventId++\n', '    }\n', '\t\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '}\n', '\n', 'contract SoccerBet is Base\n', '{\n', '\tfunction SoccerBet(string _gameName,uint _bankerDepositPer, address _DonQuixoteToken) public {\n', '\t\trequire(_DonQuixoteToken != 0x0);\n', '\t\tgameName = _gameName;\n', '\t\tbankerDepositPer = _bankerDepositPer;\n', '        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n', '        owner = msg.sender;\n', '    }\n', '\n', '\tuint public unpayPooling = 0;\n', '\tuint public losePooling = 0;\n', '\tuint public winPooling = 0;\n', '\tuint public samePooling = 0;\n', '\t\n', '\tuint public bankerDepositPer = 20;\n', '\n', '    address public auction;\n', '\tfunction setAuction(address _newAuction) public onlyOwner{\n', '        auction = _newAuction;\n', '    }\n', '    modifier onlyAuction {\n', '\t    require(msg.sender == auction);\n', '        _;\n', '    }\n', '\t\n', '    modifier onlyBanker {\n', '        require(msg.sender == currentBanker);\n', '        require(bankerBeginTime <= now);\n', '        require(now < bankerEndTime);\n', '        _;\n', '    }    \n', '\t\n', '\tfunction canSetBanker() public view returns (bool _result){\n', '        _result =  false;\n', '\t\tif(now < bankerEndTime){\n', '\t\t\treturn;\n', '\t\t}\n', '\t\tif(userTokenOf[this] == 0){\n', '\t\t\t_result = true;\n', '\t\t}\n', '    }\n', '\t\n', '\tevent OnSetNewBanker(uint indexed _gameID , address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n', '    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n', '    {\n', '        _result = false;\n', '        require(_banker != 0x0);\n', '\n', '        if(now < bankerEndTime){\n', '            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());//"bankerEndTime > now"\n', '            return;\n', '        }\n', '\t\t\n', '\t\tif(userTokenOf[this] > 0){\n', '\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());//"userTokenOf[this] > 0"\n', '\t\t\treturn;\n', '\t\t}\n', '        \n', '        if(_beginTime > now){\n', '\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());//&#39;_beginTime > now&#39;\n', '            return;\n', '        }\n', '\n', '        if(_endTime <= now){\n', '\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());//&#39;_endTime <= now&#39;\n', '            return;\n', '        }\n', '\t\t\n', '\t\tif(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(_banker);\n', '        }\n', '        currentBanker = _banker;\n', '        bankerBeginTime = _beginTime;\n', '        bankerEndTime =  _endTime;\n', '\t\n', '\t\tunpayPooling = 0;\n', '\t\tlosePooling = 0;\n', '\t\twinPooling = 0;\n', '\t\tsamePooling = 0;\n', '\t\t\n', '\t\tgameResult = 9;\n', '\t\t\n', '\t\tgameOver = true;\n', '\n', '\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n', '        _result = true;\n', '    }\n', '\n', '\tstring public team1;\n', '    string public team2;\n', '\t\n', '    uint public constant loseNum = 1;\n', '    uint public constant winNum = 3;\n', '    uint public constant sameNum = 0;\n', '\n', '    uint public loseOdd;\n', '    uint public winOdd;\n', '    uint public sameOdd;\n', '\n', '    uint public betLastTime;\n', '\n', '    uint public playNo = 1;\n', '    uint public gameID = 0;\n', '\n', '    uint public gameBeginPlayNo;\n', '\n', '    uint public gameResult = 9;\n', '\n', '    uint  public gameBeginTime;\n', '\n', '    uint256 public gameMaxBetAmount;\n', '    uint256 public gameMinBetAmount;\n', '    bool public gameOver = true;\n', '\t\n', '\tuint public nextRewardPlayNo=1;\n', '    uint public currentRewardNum = 100;\n', '\t\n', '\tuint public donGameGiftLineTime =  now + 90 days;\n', '\t\n', '\taddress public decider;\n', '    function setDecider(address _decider) public onlyOwner{\t\n', '        decider = _decider;\n', '    }\n', '    modifier onlyDecider{\n', '        require(msg.sender == decider);\n', '        _;\n', '    }\n', '\tfunction setGameResult(uint _gameResult) public onlyDecider{\n', '\t\trequire(!gameOver);\n', '\t\trequire(betLastTime + 90 minutes < now);\n', '\t\trequire(gameResult == 9);\n', '\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n', '\t\tgameResult = _gameResult;\n', '\t\tif(gameResult == 3){\n', '\t\t\tunpayPooling = winPooling;\n', '\t\t}else if(gameResult == 1){\n', '\t\t\tunpayPooling = losePooling;\n', '\t\t}else if(gameResult == 0){\n', '\t\t\tunpayPooling = samePooling;\n', '\t\t}\n', '\t}\n', '\n', '    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n', '\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n', '    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker returns(bool _result){ //开局\n', '        require(bytes(_team1).length < 100);\n', '\t\trequire(bytes(_team2).length < 100);\n', '\t\t\n', '\t\trequire(gameOver);\n', '        require(now > bankerBeginTime);\n', '\t\trequire(_gameMinBetAmount >= 10000000);\n', '        require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '\t\trequire(now < _betLastTime);\n', '\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n', '\n', '        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n', '    }\n', '\n', '    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n', '        _result = false;\n', '\t\tgameID = gameID.add(1);\n', '\t\t\n', '\t\tteam1 = _team1;\n', '        team2 = _team2;\n', '\t\tloseOdd = _loseOdd;\n', '\t\twinOdd = _winOdd;\n', '\t\tsameOdd = _sameOdd;\n', '\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n', '\t\t\n', '\t\tbetLastTime = _betLastTime;\n', '        gameBeginTime = now;\n', '\t\tgameMinBetAmount = _gameMinBetAmount;\n', '        gameMaxBetAmount = _gameMaxBetAmount;\n', '\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n', '        \n', '        gameBeginPlayNo = playNo;\n', '        gameResult = 9;\n', '        gameOver = false;\n', '\t\tunpayPooling = 0;\n', '\t\tlosePooling = 0;\n', '\t\twinPooling = 0;\n', '\t\tsamePooling = 0;\n', '\n', '        _result = true;\n', '    }\n', '\t\n', '    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n', '\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n', '\t\twinOdd = _winOdd;\n', '\t\tloseOdd = _loseOdd;\n', '\t\tsameOdd = _sameOdd;\t\n', '\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n', '\t}\n', '\n', '    struct betInfo\n', '    {\n', '        uint Odd;\n', '        address Player;\n', '        uint BetNum;\n', '        uint256 BetAmount;\n', '\t\tuint loseToken;\n', '        bool IsReturnAward;\n', '    }\n', '\n', '    mapping (uint => betInfo) public playerBetInfoOf;\n', '\n', '    event OnPlay(uint indexed _gameID, string _gameName, address _player, uint odd, string _team1, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint eventId);\n', '    function play(uint _betNum, uint256 _betAmount) public returns(bool _result){ \n', '        _result = _play(_betNum, _betAmount);\n', '    }\n', '\n', '    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n', '        _result = false;\n', '        require(!gameOver);\n', '\n', '        require(_betNum == loseNum || _betNum == winNum || _betNum == sameNum);\n', '        require(msg.sender != currentBanker);\n', '\n', '        require(now < betLastTime);\n', '\t\t\n', '\t\trequire(_betAmount >= gameMinBetAmount);\n', '        if (_betAmount > gameMaxBetAmount){\n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '\n', '\t\t_betAmount = _betAmount / 100 * 100;\n', '\n', '        if(userTokenOf[msg.sender] < _betAmount){\n', '            depositToken(_betAmount.sub(userTokenOf[msg.sender]));\n', '        }\n', '        \n', '        uint BankerAmount = _betAmount.mul(bankerDepositPer).div(100);\n', '        require(userTokenOf[msg.sender] >= _betAmount);\n', '        require(userTokenOf[currentBanker] >= BankerAmount);\n', '\n', '\n', '        uint _odd = seekOdd(_betNum,_betAmount);\n', '\n', '        betInfo memory bi= betInfo({\n', '            Odd :_odd,\n', '            Player :  msg.sender,\n', '            BetNum : _betNum,\n', '            BetAmount : _betAmount,\n', '            loseToken : 0,\n', '            IsReturnAward: false\n', '        });\n', '\n', '        playerBetInfoOf[playNo] = bi;\n', '        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(_betAmount);\n', '\t\tuserTokenOf[this] = userTokenOf[this].add(_betAmount);\n', '        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);\n', '\t\tuserTokenOf[this] = userTokenOf[this].add(BankerAmount);\n', '        emit OnPlay(gameID, gameName, msg.sender, _odd, team1, _betNum, _betAmount, playNo, now, getEventId());\n', '\n', '        playNo = playNo.add(1); \n', '\t\tif(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(msg.sender);\n', '        }\n', '\t\t\n', '        _result = true;\n', '    }\n', '\t\n', '\tfunction seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n', '\t\tuint allAmount = 0;\n', '\t\tif(_betNum == 3){\n', '\t\t\tallAmount = _betAmount.mul(winOdd).div(100);//allAmount = _betAmount*winOdd/100\n', '\t\t\twinPooling = winPooling.add(allAmount);\n', '\t\t\t_odd  = winOdd;\n', '\t\t}else if(_betNum == 1){\n', '\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);//allAmount = _betAmount*loseOdd/100\n', '\t\t\tlosePooling = losePooling.add(allAmount);\n', '\t\t\t_odd = loseOdd;\n', '\t\t}else if(_betNum == 0){\n', '\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);//allAmount = _betAmount*sameOdd/100\n', '\t\t\tsamePooling = samePooling.add(allAmount);\n', '\t\t\t_odd = sameOdd;\n', '\t\t}\n', '    }\n', '\t\n', '    event OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n', '    function openGameLoop() public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGameLoop();\n', '        unLock();\n', '    }\n', '\n', '    function _openGameLoop() private returns(bool _result){\n', '        _result = false;\n', '        _checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n', '\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n', '\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n', '\t\t\t}\n', '\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n', '\t\t}\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGamePlayNo(_playNo);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n', '        _result = false;\n', '\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n', '\t\t_checkOpenGame();\n', '\t\t\n', '\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n', '\t\trequire(!p.IsReturnAward);\n', '\t\t\n', '\t\tuint256 allAmount = 0;\n', '\t\t_cashPrize(p, allAmount,_playNo);\n', '\t\t\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGamePlayNos(_playNos);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n', '        _result = false;\n', '        _checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n', '\t\t\tuint _playNo = _playNos[_index];\n', '\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n', '\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n', '\t\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n', '        _result = false;\n', '\t\trequire(_beginPlayNo < _endPlayNo);\n', '\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n', '\t\t\n', '\t\t_checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n', '\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n', '\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction _checkOpenGame() private{\n', '\t\trequire(!gameOver);\n', '\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n', '\t\trequire(betLastTime + 90 minutes < now);\n', '\t\t\n', '\t\tif(unpayPooling > userTokenOf[this]){\n', '\t\t\tuint shortOf = unpayPooling.sub(userTokenOf[this]);\n', '\t\t\tif(shortOf > userTokenOf[currentBanker]){\n', '\t\t\t\tshortOf = userTokenOf[currentBanker];\n', '\t\t\t}\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].sub(shortOf);\n', '\t\t\tuserTokenOf[this] = userTokenOf[this].add(shortOf);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n', '\t\tif(_p.BetNum == gameResult){\n', '\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n', '\t\t\t_allAmount = _allAmount.sub(_p.loseToken);\n', '\t\t\tif(userTokenOf[this] >= _allAmount){\n', '\t\t\t\t_p.IsReturnAward = true;\n', '\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(_allAmount);\n', '\t\t\t\tuserTokenOf[this] = userTokenOf[this].sub(_allAmount);\n', '\t\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n', '\t\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n', '\t\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\t\twinPooling = winPooling.sub(_allAmount);\n', '\t\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n', '\t\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n', '\t\t\t\t}\n', '\t\t\t}else{\n', '\t\t\t\t_p.loseToken = _p.loseToken.add(userTokenOf[this]);\n', '\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(userTokenOf[this]);\n', '\t\t\t\tunpayPooling = unpayPooling.sub(userTokenOf[this]);\n', '\t\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\t\twinPooling = winPooling.sub(userTokenOf[this]);\n', '\t\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\t\tlosePooling = losePooling.sub(userTokenOf[this]);\n', '\t\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\t\tsamePooling = samePooling.sub(userTokenOf[this]);\n', '\t\t\t\t}\n', '\t\t\t\t\n', '\t\t\t\tuserTokenOf[this] = 0;\n', '\t\t\t}\n', '\t\t}else{\n', '\t\t\t_p.IsReturnAward = true;\n', '\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n', '\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n', '\t\t\t//_allAmount = _allAmount.sub(_p.loseToken);\n', '\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\twinPooling = winPooling.sub(_allAmount);\n', '\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n', '\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif(now < donGameGiftLineTime){\n', '\t\t\t\tDonQuixoteToken.sendGameGift(_p.Player);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\n', '\tfunction _canSetGameOver() private view returns(bool){\n', '\t\treturn winPooling<100 && losePooling<100 && samePooling<100;//todo\n', '\t}\n', '\t\n', '    function _withdrawToken(address _from, uint256 _amount) internal {\n', '        require(_from != 0x0);\n', '\t\trequire(_from != currentBanker || gameOver);\n', '\t\tif(_amount > 0 && _amount <= userTokenOf[_from]){  \n', '\t\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n', '\t\t\tDonQuixoteToken.transfer(_from, _amount);\n', '\t\t}\n', '    }\n', '\t\n', '\t\n', '\tfunction transEther() public onlyOwner()\n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\t\n', '\tfunction () public payable {        //fall back function\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract BaseGame { \n', '\tfunction canSetBanker() view public returns (bool _result);\n', '    function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);\n', '    \n', '    string public gameName = "NO.1";\n', '    uint public gameType = 2004;\n', '    string public officialGameUrl;\n', '\n', '\tuint public bankerBeginTime;\n', '\tuint public bankerEndTime;\n', '\taddress public currentBanker;\n', '\t\n', '\tfunction depositToken(uint256 _amount) public;\n', '\tfunction withdrawAllToken() public;\n', '    function withdrawToken(uint256 _amount) public;\n', '    mapping (address => uint256) public userTokenOf;\n', '\n', '}\n', 'interface IDonQuixoteToken{\n', '    function withhold(address _user,  uint256 _amount) external returns (bool _result);\n', '    function transfer(address _to, uint256 _value) external;\n', '\t//function canSendGameGift() view external returns(bool _result);\n', '    function sendGameGift(address _player) external returns (bool _result);\n', '\tfunction logPlaying(address _player) external returns (bool _result);\n', '\tfunction balanceOf(address _user) constant external returns(uint256 balance);\n', '}  \n', '\n', '\n', 'contract Base is BaseGame{\n', '\tusing SafeMath for uint256; \n', '    uint public createTime = now;\n', '    address public owner;\n', '\tIDonQuixoteToken public DonQuixoteToken;\n', '\n', '    function Base() public {\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    bool public globalLocked = false;\n', '\n', '    function lock() internal {\n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }\n', '\n', '    function setLock()  public onlyOwner{\n', '        globalLocked = false;\n', '    }\n', '\t\n', '\tfunction tokenOf(address _user) view public returns(uint256 _result){\n', '\t\t_result = DonQuixoteToken.balanceOf(_user);\n', '\t}\n', '    \n', '    function depositToken(uint256 _amount) public {\n', '        lock();\n', '        _depositToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\n', '    function _depositToken(address _to, uint256 _amount) internal {\n', '        require(_to != 0x0);\n', '        DonQuixoteToken.withhold(_to, _amount);\n', '        userTokenOf[_to] = userTokenOf[_to].add(_amount);\n', '    }\n', '\n', '    function withdrawAllToken() public {    \n', '        lock();  \n', '\t\tuint256 _amount = userTokenOf[msg.sender];\n', '        _withdrawToken(msg.sender,_amount);\n', '        unLock();\n', '    }\n', '\t\n', '\tfunction withdrawToken(uint256 _amount) public {   \n', '        lock();  \n', '        _withdrawToken(msg.sender, _amount);\n', '        unLock();\n', '    }\n', '\t\n', '    function _withdrawToken(address _from, uint256 _amount) internal {\n', '        require(_from != 0x0);\n', '\t\trequire(_amount > 0 && _amount <= userTokenOf[_from]);\n', '\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n', '\t\tDonQuixoteToken.transfer(_from, _amount);\n', '    }\n', '\t\n', '\tuint public currentEventId = 1;\n', '\n', '    function getEventId() internal returns(uint _result) {\n', '        _result = currentEventId;\n', '        currentEventId = currentEventId.add(1); //currentEventId++\n', '    }\n', '\t\n', '    function setOfficialGameUrl(string _newOfficialGameUrl) public onlyOwner{\n', '        officialGameUrl = _newOfficialGameUrl;\n', '    }\n', '}\n', '\n', 'contract SoccerBet is Base\n', '{\n', '\tfunction SoccerBet(string _gameName,uint _bankerDepositPer, address _DonQuixoteToken) public {\n', '\t\trequire(_DonQuixoteToken != 0x0);\n', '\t\tgameName = _gameName;\n', '\t\tbankerDepositPer = _bankerDepositPer;\n', '        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n', '        owner = msg.sender;\n', '    }\n', '\n', '\tuint public unpayPooling = 0;\n', '\tuint public losePooling = 0;\n', '\tuint public winPooling = 0;\n', '\tuint public samePooling = 0;\n', '\t\n', '\tuint public bankerDepositPer = 20;\n', '\n', '    address public auction;\n', '\tfunction setAuction(address _newAuction) public onlyOwner{\n', '        auction = _newAuction;\n', '    }\n', '    modifier onlyAuction {\n', '\t    require(msg.sender == auction);\n', '        _;\n', '    }\n', '\t\n', '    modifier onlyBanker {\n', '        require(msg.sender == currentBanker);\n', '        require(bankerBeginTime <= now);\n', '        require(now < bankerEndTime);\n', '        _;\n', '    }    \n', '\t\n', '\tfunction canSetBanker() public view returns (bool _result){\n', '        _result =  false;\n', '\t\tif(now < bankerEndTime){\n', '\t\t\treturn;\n', '\t\t}\n', '\t\tif(userTokenOf[this] == 0){\n', '\t\t\t_result = true;\n', '\t\t}\n', '    }\n', '\t\n', '\tevent OnSetNewBanker(uint indexed _gameID , address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n', '    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n', '    {\n', '        _result = false;\n', '        require(_banker != 0x0);\n', '\n', '        if(now < bankerEndTime){\n', '            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());//"bankerEndTime > now"\n', '            return;\n', '        }\n', '\t\t\n', '\t\tif(userTokenOf[this] > 0){\n', '\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());//"userTokenOf[this] > 0"\n', '\t\t\treturn;\n', '\t\t}\n', '        \n', '        if(_beginTime > now){\n', "\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());//'_beginTime > now'\n", '            return;\n', '        }\n', '\n', '        if(_endTime <= now){\n', "\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());//'_endTime <= now'\n", '            return;\n', '        }\n', '\t\t\n', '\t\tif(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(_banker);\n', '        }\n', '        currentBanker = _banker;\n', '        bankerBeginTime = _beginTime;\n', '        bankerEndTime =  _endTime;\n', '\t\n', '\t\tunpayPooling = 0;\n', '\t\tlosePooling = 0;\n', '\t\twinPooling = 0;\n', '\t\tsamePooling = 0;\n', '\t\t\n', '\t\tgameResult = 9;\n', '\t\t\n', '\t\tgameOver = true;\n', '\n', '\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n', '        _result = true;\n', '    }\n', '\n', '\tstring public team1;\n', '    string public team2;\n', '\t\n', '    uint public constant loseNum = 1;\n', '    uint public constant winNum = 3;\n', '    uint public constant sameNum = 0;\n', '\n', '    uint public loseOdd;\n', '    uint public winOdd;\n', '    uint public sameOdd;\n', '\n', '    uint public betLastTime;\n', '\n', '    uint public playNo = 1;\n', '    uint public gameID = 0;\n', '\n', '    uint public gameBeginPlayNo;\n', '\n', '    uint public gameResult = 9;\n', '\n', '    uint  public gameBeginTime;\n', '\n', '    uint256 public gameMaxBetAmount;\n', '    uint256 public gameMinBetAmount;\n', '    bool public gameOver = true;\n', '\t\n', '\tuint public nextRewardPlayNo=1;\n', '    uint public currentRewardNum = 100;\n', '\t\n', '\tuint public donGameGiftLineTime =  now + 90 days;\n', '\t\n', '\taddress public decider;\n', '    function setDecider(address _decider) public onlyOwner{\t\n', '        decider = _decider;\n', '    }\n', '    modifier onlyDecider{\n', '        require(msg.sender == decider);\n', '        _;\n', '    }\n', '\tfunction setGameResult(uint _gameResult) public onlyDecider{\n', '\t\trequire(!gameOver);\n', '\t\trequire(betLastTime + 90 minutes < now);\n', '\t\trequire(gameResult == 9);\n', '\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n', '\t\tgameResult = _gameResult;\n', '\t\tif(gameResult == 3){\n', '\t\t\tunpayPooling = winPooling;\n', '\t\t}else if(gameResult == 1){\n', '\t\t\tunpayPooling = losePooling;\n', '\t\t}else if(gameResult == 0){\n', '\t\t\tunpayPooling = samePooling;\n', '\t\t}\n', '\t}\n', '\n', '    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n', '\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n', '    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker returns(bool _result){ //开局\n', '        require(bytes(_team1).length < 100);\n', '\t\trequire(bytes(_team2).length < 100);\n', '\t\t\n', '\t\trequire(gameOver);\n', '        require(now > bankerBeginTime);\n', '\t\trequire(_gameMinBetAmount >= 10000000);\n', '        require(_gameMaxBetAmount >= _gameMinBetAmount);\n', '\t\trequire(now < _betLastTime);\n', '\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n', '\n', '        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n', '    }\n', '\n', '    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n', '        _result = false;\n', '\t\tgameID = gameID.add(1);\n', '\t\t\n', '\t\tteam1 = _team1;\n', '        team2 = _team2;\n', '\t\tloseOdd = _loseOdd;\n', '\t\twinOdd = _winOdd;\n', '\t\tsameOdd = _sameOdd;\n', '\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n', '\t\t\n', '\t\tbetLastTime = _betLastTime;\n', '        gameBeginTime = now;\n', '\t\tgameMinBetAmount = _gameMinBetAmount;\n', '        gameMaxBetAmount = _gameMaxBetAmount;\n', '\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n', '        \n', '        gameBeginPlayNo = playNo;\n', '        gameResult = 9;\n', '        gameOver = false;\n', '\t\tunpayPooling = 0;\n', '\t\tlosePooling = 0;\n', '\t\twinPooling = 0;\n', '\t\tsamePooling = 0;\n', '\n', '        _result = true;\n', '    }\n', '\t\n', '    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n', '\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n', '\t\twinOdd = _winOdd;\n', '\t\tloseOdd = _loseOdd;\n', '\t\tsameOdd = _sameOdd;\t\n', '\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n', '\t}\n', '\n', '    struct betInfo\n', '    {\n', '        uint Odd;\n', '        address Player;\n', '        uint BetNum;\n', '        uint256 BetAmount;\n', '\t\tuint loseToken;\n', '        bool IsReturnAward;\n', '    }\n', '\n', '    mapping (uint => betInfo) public playerBetInfoOf;\n', '\n', '    event OnPlay(uint indexed _gameID, string _gameName, address _player, uint odd, string _team1, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint eventId);\n', '    function play(uint _betNum, uint256 _betAmount) public returns(bool _result){ \n', '        _result = _play(_betNum, _betAmount);\n', '    }\n', '\n', '    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n', '        _result = false;\n', '        require(!gameOver);\n', '\n', '        require(_betNum == loseNum || _betNum == winNum || _betNum == sameNum);\n', '        require(msg.sender != currentBanker);\n', '\n', '        require(now < betLastTime);\n', '\t\t\n', '\t\trequire(_betAmount >= gameMinBetAmount);\n', '        if (_betAmount > gameMaxBetAmount){\n', '            _betAmount = gameMaxBetAmount;\n', '        }\n', '\n', '\t\t_betAmount = _betAmount / 100 * 100;\n', '\n', '        if(userTokenOf[msg.sender] < _betAmount){\n', '            depositToken(_betAmount.sub(userTokenOf[msg.sender]));\n', '        }\n', '        \n', '        uint BankerAmount = _betAmount.mul(bankerDepositPer).div(100);\n', '        require(userTokenOf[msg.sender] >= _betAmount);\n', '        require(userTokenOf[currentBanker] >= BankerAmount);\n', '\n', '\n', '        uint _odd = seekOdd(_betNum,_betAmount);\n', '\n', '        betInfo memory bi= betInfo({\n', '            Odd :_odd,\n', '            Player :  msg.sender,\n', '            BetNum : _betNum,\n', '            BetAmount : _betAmount,\n', '            loseToken : 0,\n', '            IsReturnAward: false\n', '        });\n', '\n', '        playerBetInfoOf[playNo] = bi;\n', '        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(_betAmount);\n', '\t\tuserTokenOf[this] = userTokenOf[this].add(_betAmount);\n', '        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);\n', '\t\tuserTokenOf[this] = userTokenOf[this].add(BankerAmount);\n', '        emit OnPlay(gameID, gameName, msg.sender, _odd, team1, _betNum, _betAmount, playNo, now, getEventId());\n', '\n', '        playNo = playNo.add(1); \n', '\t\tif(now < donGameGiftLineTime){\n', '            DonQuixoteToken.logPlaying(msg.sender);\n', '        }\n', '\t\t\n', '        _result = true;\n', '    }\n', '\t\n', '\tfunction seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n', '\t\tuint allAmount = 0;\n', '\t\tif(_betNum == 3){\n', '\t\t\tallAmount = _betAmount.mul(winOdd).div(100);//allAmount = _betAmount*winOdd/100\n', '\t\t\twinPooling = winPooling.add(allAmount);\n', '\t\t\t_odd  = winOdd;\n', '\t\t}else if(_betNum == 1){\n', '\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);//allAmount = _betAmount*loseOdd/100\n', '\t\t\tlosePooling = losePooling.add(allAmount);\n', '\t\t\t_odd = loseOdd;\n', '\t\t}else if(_betNum == 0){\n', '\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);//allAmount = _betAmount*sameOdd/100\n', '\t\t\tsamePooling = samePooling.add(allAmount);\n', '\t\t\t_odd = sameOdd;\n', '\t\t}\n', '    }\n', '\t\n', '    event OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n', '    function openGameLoop() public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGameLoop();\n', '        unLock();\n', '    }\n', '\n', '    function _openGameLoop() private returns(bool _result){\n', '        _result = false;\n', '        _checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n', '\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n', '\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n', '\t\t\t}\n', '\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n', '\t\t}\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGamePlayNo(_playNo);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n', '        _result = false;\n', '\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n', '\t\t_checkOpenGame();\n', '\t\t\n', '\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n', '\t\trequire(!p.IsReturnAward);\n', '\t\t\n', '\t\tuint256 allAmount = 0;\n', '\t\t_cashPrize(p, allAmount,_playNo);\n', '\t\t\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGamePlayNos(_playNos);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n', '        _result = false;\n', '        _checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n', '\t\t\tuint _playNo = _playNos[_index];\n', '\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n', '\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n', '\t\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n', '\t\tlock();\n', '        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n', '        unLock();\n', '    }\n', '\t\n', '    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n', '        _result = false;\n', '\t\trequire(_beginPlayNo < _endPlayNo);\n', '\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n', '\t\t\n', '\t\t_checkOpenGame();\n', '\t\tuint256 allAmount = 0;\n', '\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n', '\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n', '\t\t\tif(!p.IsReturnAward){\n', '\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif(unpayPooling == 0 && _canSetGameOver()){\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n', '\t\t\tuserTokenOf[this] = 0;\n', '\t\t\tgameOver = true;\n', '\t\t}\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction _checkOpenGame() private{\n', '\t\trequire(!gameOver);\n', '\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n', '\t\trequire(betLastTime + 90 minutes < now);\n', '\t\t\n', '\t\tif(unpayPooling > userTokenOf[this]){\n', '\t\t\tuint shortOf = unpayPooling.sub(userTokenOf[this]);\n', '\t\t\tif(shortOf > userTokenOf[currentBanker]){\n', '\t\t\t\tshortOf = userTokenOf[currentBanker];\n', '\t\t\t}\n', '\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].sub(shortOf);\n', '\t\t\tuserTokenOf[this] = userTokenOf[this].add(shortOf);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n', '\t\tif(_p.BetNum == gameResult){\n', '\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n', '\t\t\t_allAmount = _allAmount.sub(_p.loseToken);\n', '\t\t\tif(userTokenOf[this] >= _allAmount){\n', '\t\t\t\t_p.IsReturnAward = true;\n', '\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(_allAmount);\n', '\t\t\t\tuserTokenOf[this] = userTokenOf[this].sub(_allAmount);\n', '\t\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n', '\t\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n', '\t\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\t\twinPooling = winPooling.sub(_allAmount);\n', '\t\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n', '\t\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n', '\t\t\t\t}\n', '\t\t\t}else{\n', '\t\t\t\t_p.loseToken = _p.loseToken.add(userTokenOf[this]);\n', '\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(userTokenOf[this]);\n', '\t\t\t\tunpayPooling = unpayPooling.sub(userTokenOf[this]);\n', '\t\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\t\twinPooling = winPooling.sub(userTokenOf[this]);\n', '\t\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\t\tlosePooling = losePooling.sub(userTokenOf[this]);\n', '\t\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\t\tsamePooling = samePooling.sub(userTokenOf[this]);\n', '\t\t\t\t}\n', '\t\t\t\t\n', '\t\t\t\tuserTokenOf[this] = 0;\n', '\t\t\t}\n', '\t\t}else{\n', '\t\t\t_p.IsReturnAward = true;\n', '\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n', '\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n', '\t\t\t//_allAmount = _allAmount.sub(_p.loseToken);\n', '\t\t\tif(_p.BetNum == 3){\n', '\t\t\t\twinPooling = winPooling.sub(_allAmount);\n', '\t\t\t}else if(_p.BetNum == 1){\n', '\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n', '\t\t\t}else if(_p.BetNum == 0){\n', '\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif(now < donGameGiftLineTime){\n', '\t\t\t\tDonQuixoteToken.sendGameGift(_p.Player);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\n', '\tfunction _canSetGameOver() private view returns(bool){\n', '\t\treturn winPooling<100 && losePooling<100 && samePooling<100;//todo\n', '\t}\n', '\t\n', '    function _withdrawToken(address _from, uint256 _amount) internal {\n', '        require(_from != 0x0);\n', '\t\trequire(_from != currentBanker || gameOver);\n', '\t\tif(_amount > 0 && _amount <= userTokenOf[_from]){  \n', '\t\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n', '\t\t\tDonQuixoteToken.transfer(_from, _amount);\n', '\t\t}\n', '    }\n', '\t\n', '\t\n', '\tfunction transEther() public onlyOwner()\n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\t\n', '\tfunction () public payable {        //fall back function\n', '    }\n', '\n', '}']
