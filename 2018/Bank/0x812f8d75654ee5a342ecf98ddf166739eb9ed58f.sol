['pragma solidity ^0.4.20;\n', '\n', '/*\n', '* LastHero团队.\n', '* -> 这是什么?\n', '* 改进的自主金字塔资金模型:\n', '* [x] 该合约是目前最稳定的智能合约，经受过所有的攻击测试!\n', '* [x] 由ARC等多名安全专家审核测试。\n', '* [X] 新功能：可部分卖出，而不必将你的所有资产全部卖出!\n', '* [x] 新功能：可以在钱包之间传输代币。可以在智能合约中进行交易!\n', '* [x] 新特性：世界首创POS节点以太坊职能合约，让V神疯狂的新功能。\n', '* [x] 主节点：持有100个代币即可拥有自己的主节点，主节点是唯一的智能合约入口!\n', '* [x] 主节点：所有通过你的主节点进入合约的玩家，你可以获得10%的分红!\n', '*\n', '* -> 关于项目?\n', '* 我们的团队成员拥有超强的创建安全智能合约的能力。\n', '* 新的开发团队由经验丰富的专业开发人员组成，并由资深合约安全专家审核。\n', '* 另外，我们公开进行过数百次的模拟攻击，该合约从来没有被攻破过。\n', '* \n', '* -> 这个项目的成员有哪些?\n', '* - PonziBot (math/memes/main site/master)数学\n', '* - Mantso (lead solidity dev/lead web3 dev)主程\n', '* - swagg (concept design/feedback/management)概念设计/反馈/管理\n', '* - Anonymous#1 (main site/web3/test cases)网站/web3/测试\n', '* - Anonymous#2 (math formulae/whitepaper)数学推导/白皮书\n', '*\n', '* -> 该项目的安全审核人员:\n', '* - Arc\n', '* - tocisck\n', '* - sumpunk\n', '*/\n', '\n', 'contract Hourglass {\n', '    /*=================================\n', '    =            MODIFIERS  全局       =\n', '    =================================*/\n', '    // 只限持币用户\n', '    modifier onlyBagholders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // 只限收益用户\n', '    modifier onlyStronghands() {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '    \n', '    // 管理员权限:\n', '    // -> 更改合约名称\n', '    // -> 更改代币名称\n', '    // -> 改变POS的难度（确保维持一个主节点需要多少代币，以避免滥发）\n', '    // 管理员没有权限做以下事宜:\n', '    // -> 动用资金\n', '    // -> 禁止用户取款\n', '    // -> 自毁合约\n', '    // -> 改变代币价格\n', '    modifier onlyAdministrator(){ // 用来确定是管理员\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[keccak256(_customerAddress)]); // 在管理员列表中存在\n', '        _; // 表示在modifier的函数执行完后，开始执行其它函数\n', '    }\n', '    \n', '    \n', '    // 确保合约中第一批代币均等的分配\n', '    // 这意味着，不公平的优势成本是不可能存在的\n', '    // 这将为基金的健康成长打下坚实的基础。\n', '    modifier antiEarlyWhale(uint256 _amountOfEthereum){ // 判断状态\n', '        address _customerAddress = msg.sender;\n', '        \n', '        // 我们还是处于不利的投资地位吗?\n', '        // 既然如此，我们将禁止早期的大额投资 \n', '        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\n', '            require(\n', '                // 这个用户在代表名单吗？\n', '                ambassadors_[_customerAddress] == true &&\n', '                \n', '                // 用户购买量是否超过代表的最大配额？\n', '                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\n', '                \n', '            );\n', '            \n', '            // 更新累计配额  \n', '            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\n', '        \n', '            // 执行\n', '            _;\n', '        } else {\n', '            // 如果基金中以太币数量下降到创世值，代表阶段也不会重新启动。\n', '            onlyAmbassadors = false;\n', '            _;    \n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    /*==============================\n', '    =            EVENTS  事件      =\n', '    ==============================*/\n', '    event onTokenPurchase( // 购买代币\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onTokenSell( // 出售代币\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '    \n', '    event onReinvestment( // 再投资\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw( // 提取资金\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    // ERC20标准\n', '    event Transfer( // 一次交易\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES  配置       =\n', '    =====================================*/\n', '    string public name = "LastHero3D"; // 名字\n', '    string public symbol = "Keys"; // 符号\n', '    uint8 constant public decimals = 18; // 小数位\n', '    uint8 constant internal dividendFee_ = 10; // 交易分红比例\n', '    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether; // 代币初始价格\n', '    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether; // 代币递增价格\n', '    uint256 constant internal magnitude = 2**64;\n', '    \n', '    // 股份证明（默认值为100代币）\n', '    uint256 public stakingRequirement = 100e18;\n', '    \n', '    // 代表计划\n', '    mapping(address => bool) internal ambassadors_; // 代表集合\n', '    uint256 constant internal ambassadorMaxPurchase_ = 1 ether; // 最大购买\n', '    uint256 constant internal ambassadorQuota_ = 20 ether; // 购买限额\n', '    \n', '    \n', '    \n', '   /*================================\n', '    =            DATASETS   数据     =\n', '    ================================*/\n', '    // 每个地址的股份数量（按比例编号）\n', '    mapping(address => uint256) internal tokenBalanceLedger_; // 保存地址的代币数量\n', '    mapping(address => uint256) internal referralBalance_; // 保存地址的推荐分红\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    // 管理员列表（管理员权限见上述）\n', '    mapping(bytes32 => bool) public administrators; // 管理者地址列表\n', '    \n', '    // 当代表制度成立，只有代表可以购买代币（这确保了完美的金字塔分布，以防持币比例不均）\n', '    bool public onlyAmbassadors = true; // 限制只有代表能够购买代币\n', '    \n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS 公开函数   =\n', '    =======================================*/\n', '    /*\n', '    * -- 应用入口 --  \n', '    */\n', '    function Hourglass()\n', '        public\n', '    {\n', '        // 在这里添加管理员\n', '        administrators[0xdacb12a29ec52e618a1dbe39a3317833066e94371856cc2013565dab2ae6fa62] = true;\n', '        \n', '        // 在这里添加代表。\n', '        // mantso - lead solidity dev & lead web dev. \n', '        ambassadors_[0x24257cF6fEBC8aAaE2dC20906d4Db1C619d40329] = true;\n', '        \n', '        // ponzibot - mathematics & website, and undisputed meme god.\n', '        ambassadors_[0xEa01f6203bD55BA694594FDb5575f2936dB7f698] = true;\n', '        \n', '        // swagg - concept design, feedback, management.\n', '        ambassadors_[0x22caa6670991D67bf0EA033156114F07de4aa20b] = true;\n', '        \n', '        // k-dawgz - shilling machine, meme maestro, bizman.\n', '        ambassadors_[0xf9d7f59E5d0711f5482968D69B5aEe251945D1c5] = true;\n', '        \n', '        // elmojo - all those pretty .GIFs & memes you see? you can thank this man for that.\n', '        ambassadors_[0x4d82B6839Fd64eF7D3Af64080167A42bF9B9E332] = true;\n', '        \n', '        // capex - community moderator.\n', '        ambassadors_[0x1f50451b941d163837623E25E22033C11626491C] = true;\n', '        \n', '        // j&#246;rmungandr - pentests & twitter trendsetter.\n', '        ambassadors_[0xC68538d6971D1B0AC8829f8B14e6a9B2AF614119] = true;\n', '        \n', '        // inventor - the source behind the non-intrusive referral model.\n', '        ambassadors_[0x23183DaFd738FB876c363dA7651A679fcb24b657] = true;\n', '        \n', '        // tocsick - pentesting, contract auditing.\n', '        ambassadors_[0x95E8713a5D2bf0DDAf8D0819e73907a8CEE3D111] = true;\n', '        \n', '        // arc - pentesting, contract auditing.\n', '        ambassadors_[0x976f6397ae155239289D6cb7904E6730BeBa7c79] = true;\n', '        \n', '        // sumpunk - contract auditing.\n', '        ambassadors_[0xC26BB52D97BA7e4c6DA8E7b07D1B8B78Be178FBd] = true;\n', '        \n', '        // randall - charts & sheets, data dissector, advisor.\n', '        ambassadors_[0x23C654314EaDAaE05857dE5a61c1228c33282807] = true;\n', '        \n', '        // ambius - 3d chart visualization.\n', '        ambassadors_[0xA732E7665fF54Ba63AE40E67Fac9f23EcD0b1223] = true;\n', '        \n', '        // contributors that need to remain private out of security concerns.\n', '        ambassadors_[0x445b660236c39F5bc98bc49ddDc7CF1F246a40aB] = true; //dp\n', '        ambassadors_[0x60e31B8b79bd92302FE452242Ea6F7672a77a80f] = true; //tc\n', '        ambassadors_[0xbbefE89eBb2a0e15921F07F041BE5691d834a287] = true; //ja\n', '        ambassadors_[0x5ad183E481cF0477C024A96c5d678a88249295b8] = true; //sf\n', '        ambassadors_[0x10C5423A46a09D6c5794Cdd507ee9DA7E406F095] = true; //tb\n', '        ambassadors_[0x9E191643D643AA5908C5B9d3b10c27Ad9fb4AcBE] = true; //sm\n', '        ambassadors_[0x2c389a382003E9467a84932E68a35cea27A34B8D] = true; //mc\n', '        ambassadors_[0x4af87534cb13B473D8c1199093a8052b5Ad6661B] = true; //et\n', '        \n', '\n', '    }\n', '    \n', '     \n', '    /**\n', '     * 将所有以太坊网络传入转换为代币调用，并向下传递（如果有下层拓扑）\n', '     */\n', '    function buy(address _referredBy)\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        purchaseTokens(msg.value, _referredBy);\n', '    }\n', '    \n', '    /**\n', '     * 回调函数来处理直接发送到合约的以太坊参数。\n', '     * 我们不能通过这种方式来指定一个地址。\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        purchaseTokens(msg.value, 0x0);\n', '    }\n', '    \n', '    /**\n', '     * 将所有的分红请求转换为代币。\n', '     */\n', '    function reinvest()\n', '        onlyStronghands()\n', '        public\n', '    {\n', '        // 提取股息\n', '        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '        \n', '        // 实际支付的股息\n', '        address _customerAddress = msg.sender;\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '        \n', '        // 检索参考奖金\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        \n', '        // 发送一个购买订单通过虚拟化的“撤回股息”\n', '        uint256 _tokens = purchaseTokens(_dividends, 0x0);\n', '        \n', '        // 重大事件\n', '        onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '    \n', '    /**\n', '     * 退出流程，卖掉并且提取资金\n', '     */\n', '    function exit()\n', '        public\n', '    {\n', '        // 通过调用获取代币数量并将其全部出售\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if(_tokens > 0) sell(_tokens);\n', '        \n', '        // 取款服务\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * 取走请求者的所有收益。\n', '     */\n', '    function withdraw()\n', '        onlyStronghands()\n', '        public\n', '    {\n', '        // 设置数据\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(false); // 从代码中获得参考奖金\n', '        \n', '        // 更新股息系统\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '        \n', '        // 添加参考奖金\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        \n', '        // 获取服务\n', '        _customerAddress.transfer(_dividends);\n', '        \n', '        // 重大事件\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    \n', '    /**\n', '     * 以太坊代币。\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '    {\n', '        // 设置数据\n', '        address _customerAddress = msg.sender;\n', '        // 来自俄罗斯的BTFO\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        \n', '        // 销毁已出售的代币\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '        \n', '        // 更新股息系统\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;       \n', '        \n', '        // 禁止除以0\n', '        if (tokenSupply_ > 0) {\n', '            // 更新代币的股息金额\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        }\n', '        \n', '        // 重大事件\n', '        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * 从请求者账户转移代币新持有者账户。\n', '     * 记住，这里还有10%的费用。\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '        returns(bool)\n', '    {\n', '        // 设置\n', '        address _customerAddress = msg.sender;\n', '        \n', '        // 取保拥有足够的代币\n', '        // 代币禁止转移，直到代表阶段结束。\n', '        // （我们不想捕鲸）\n', '        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        \n', '        // 取走所有未付的股息\n', '        if(myDividends(true) > 0) withdraw();\n', '        \n', '        // 被转移代币的十分之一\n', '        // 这些都将平分给个股东\n', '        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '  \n', '        // 销毁费用代币\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // 代币交换\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '        \n', '        // 更新股息系统\n', '        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n', '        \n', '        // 分发股息给持有者\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        \n', '        // 重大事件\n', '        Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '        \n', '        // ERC20标准\n', '        return true;\n', '       \n', '    }\n', '    \n', '    /*----------  管理员功能  ----------*/\n', '    /**\n', '     * 如果没有满足配额，管理员可以提前结束代表阶段。\n', '     */\n', '    function disableInitialStage()\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        onlyAmbassadors = false;\n', '    }\n', '    \n', '    /**\n', '     * 在特殊情况，可以更换管理员账户。\n', '     */\n', '    function setAdministrator(bytes32 _identifier, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '    \n', '    /**\n', '     * 作为预防措施，管理员可以调整主节点的费率。\n', '     */\n', '    function setStakingRequirement(uint256 _amountOfTokens)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        stakingRequirement = _amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * 管理员可以重新定义品牌（代币名称）。\n', '     */\n', '    function setName(string _name)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '    /**\n', '     * 管理员可以重新定义品牌（代币符号）。\n', '     */\n', '    function setSymbol(string _symbol)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        symbol = _symbol;\n', '    }\n', '\n', '    \n', '    /*----------  帮助者和计数器  ----------*/\n', '    /**\n', '     * 在合约中查看当前以太坊状态的方法\n', '     * 例如 totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() // 查看余额\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return this.balance;\n', '    }\n', '    \n', '    /**\n', '     * 检索代币供应总量。\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply_;\n', '    }\n', '    \n', '    /**\n', '     * 检索请求者的代币余额。\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender; // 获得发送者的地址\n', '        return balanceOf(_customerAddress);\n', '    }\n', '    \n', '    /**\n', '     * 取回请求者拥有的股息。\n', '     * 如果`_includeReferralBonus` 的值为1，那么推荐奖金将被计算在内。\n', '     * 其原因是，在网页的前端，我们希望得到全局汇总。\n', '     * 但在内部计算中，我们希望分开计算。\n', '     */ \n', '    function myDividends(bool _includeReferralBonus) // 返回分红数，传入的参数用来指示是否考虑推荐分红\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '    }\n', '    \n', '    /**\n', '     * 检索任意地址的代币余额。\n', '     */\n', '    function balanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '    \n', '    /**\n', '     * 检索任意地址的股息余额。\n', '     */\n', '    function dividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * 返回代币买入的价格。\n', '     */\n', '    function sellPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // 我们的计算依赖于代币供应，所以我们需要知道供应量。\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 返回代币卖出的价格。\n', '     */\n', '    function buyPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // 我们的计算依赖于代币供应，所以我们需要知道供应量。\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 前端功能，动态获取买入订单价格。\n', '     */\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * 前端功能，动态获取卖出订单价格。\n', '     */\n', '    function calculateEthereumReceived(uint256 _tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '    \n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS  内部函数   =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n', '        antiEarlyWhale(_incomingEthereum)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        // 数据设置\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\n', '        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        uint256 _fee = _dividends * magnitude;\n', ' \n', '        // 禁止恶意执行\n', '        // 防止溢出\n', '        // (防止黑客入侵)\n', '        // 定义SAFEMATH保证数据安全。\n', '        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n', '        \n', '        // 用户是否被主节点引用？\n', '        if(\n', '            // 是否有推荐者？\n', '            _referredBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // 禁止作弊!\n', '            _referredBy != _customerAddress && // 不能自己推荐自己\n', '            \n', '            // 推荐人是否有足够的代币？\n', '            // 确保推荐人是诚实的主节点\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ){\n', '            // 财富再分配\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '        } else {\n', '            // 无需购买\n', '            // 添加推荐奖励到全局分红\n', '            _dividends = SafeMath.add(_dividends, _referralBonus); // 把推荐奖励还给分红\n', '            _fee = _dividends * magnitude;\n', '        }\n', '        \n', '        // 我们不能给予无尽的以太坊\n', '        if(tokenSupply_ > 0){\n', '            \n', '            // 添加代币到代币池\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', ' \n', '            // 获取这笔交易所获得的股息，并将平均分配给所有股东\n', '            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n', '            \n', '            // 计算用户通过购买获得的代币数量。 \n', '            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n', '        \n', '        } else {\n', '            // 添加代币到代币池\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '        \n', '        // 更新代币供应总量及用户地址\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        \n', '        // 告诉买卖双方在拥有代币前不会获得分红；\n', '        // 我知道你认为你做了，但是你没有做。\n', '        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '        \n', '        // 重大事件\n', '        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * 通过以太坊传入数量计算代币价格；\n', '     * 这是一个算法，在白皮书中能找到它的科学算法；\n', '     * 做了一些修改，以防止十进制错误和代码的上下溢出。\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum) // 计算ETH兑换代币的汇率\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived = \n', '         (\n', '            (\n', '                // 向下溢出尝试\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial**2)\n', '                            +\n', '                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n', '                            +\n', '                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n', '                            +\n', '                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            )/(tokenPriceIncremental_)\n', '        )-(tokenSupply_)\n', '        ;\n', '  \n', '        return _tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * 计算代币出售的价格。\n', '     * 这是一个算法，在白皮书中能找到它的科学算法；\n', '     * 做了一些修改，以防止十进制错误和代码的上下溢出。\n', '     */\n', '     function tokensToEthereum_(uint256 _tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n', '                        )-tokenPriceIncremental_\n', '                    )*(tokens_ - 1e18)\n', '                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n', '            )\n', '        /1e18);\n', '        return _etherReceived;\n', '    }\n', '    \n', '    \n', '    //这里会消耗Gas\n', '    //你大概会多消耗1gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath函数\n', ' * @dev 安全的数学运算\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev 两个数字乘法，抛出溢出。\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的整数除法。\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // 值为0时自动抛出\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // 否则不成立\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的减法，如果减数大于被减数，则溢出抛出。\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的加法，向上溢出抛出\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/*\n', '* LastHero团队.\n', '* -> 这是什么?\n', '* 改进的自主金字塔资金模型:\n', '* [x] 该合约是目前最稳定的智能合约，经受过所有的攻击测试!\n', '* [x] 由ARC等多名安全专家审核测试。\n', '* [X] 新功能：可部分卖出，而不必将你的所有资产全部卖出!\n', '* [x] 新功能：可以在钱包之间传输代币。可以在智能合约中进行交易!\n', '* [x] 新特性：世界首创POS节点以太坊职能合约，让V神疯狂的新功能。\n', '* [x] 主节点：持有100个代币即可拥有自己的主节点，主节点是唯一的智能合约入口!\n', '* [x] 主节点：所有通过你的主节点进入合约的玩家，你可以获得10%的分红!\n', '*\n', '* -> 关于项目?\n', '* 我们的团队成员拥有超强的创建安全智能合约的能力。\n', '* 新的开发团队由经验丰富的专业开发人员组成，并由资深合约安全专家审核。\n', '* 另外，我们公开进行过数百次的模拟攻击，该合约从来没有被攻破过。\n', '* \n', '* -> 这个项目的成员有哪些?\n', '* - PonziBot (math/memes/main site/master)数学\n', '* - Mantso (lead solidity dev/lead web3 dev)主程\n', '* - swagg (concept design/feedback/management)概念设计/反馈/管理\n', '* - Anonymous#1 (main site/web3/test cases)网站/web3/测试\n', '* - Anonymous#2 (math formulae/whitepaper)数学推导/白皮书\n', '*\n', '* -> 该项目的安全审核人员:\n', '* - Arc\n', '* - tocisck\n', '* - sumpunk\n', '*/\n', '\n', 'contract Hourglass {\n', '    /*=================================\n', '    =            MODIFIERS  全局       =\n', '    =================================*/\n', '    // 只限持币用户\n', '    modifier onlyBagholders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // 只限收益用户\n', '    modifier onlyStronghands() {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '    \n', '    // 管理员权限:\n', '    // -> 更改合约名称\n', '    // -> 更改代币名称\n', '    // -> 改变POS的难度（确保维持一个主节点需要多少代币，以避免滥发）\n', '    // 管理员没有权限做以下事宜:\n', '    // -> 动用资金\n', '    // -> 禁止用户取款\n', '    // -> 自毁合约\n', '    // -> 改变代币价格\n', '    modifier onlyAdministrator(){ // 用来确定是管理员\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[keccak256(_customerAddress)]); // 在管理员列表中存在\n', '        _; // 表示在modifier的函数执行完后，开始执行其它函数\n', '    }\n', '    \n', '    \n', '    // 确保合约中第一批代币均等的分配\n', '    // 这意味着，不公平的优势成本是不可能存在的\n', '    // 这将为基金的健康成长打下坚实的基础。\n', '    modifier antiEarlyWhale(uint256 _amountOfEthereum){ // 判断状态\n', '        address _customerAddress = msg.sender;\n', '        \n', '        // 我们还是处于不利的投资地位吗?\n', '        // 既然如此，我们将禁止早期的大额投资 \n', '        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\n', '            require(\n', '                // 这个用户在代表名单吗？\n', '                ambassadors_[_customerAddress] == true &&\n', '                \n', '                // 用户购买量是否超过代表的最大配额？\n', '                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\n', '                \n', '            );\n', '            \n', '            // 更新累计配额  \n', '            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\n', '        \n', '            // 执行\n', '            _;\n', '        } else {\n', '            // 如果基金中以太币数量下降到创世值，代表阶段也不会重新启动。\n', '            onlyAmbassadors = false;\n', '            _;    \n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    /*==============================\n', '    =            EVENTS  事件      =\n', '    ==============================*/\n', '    event onTokenPurchase( // 购买代币\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onTokenSell( // 出售代币\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '    \n', '    event onReinvestment( // 再投资\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw( // 提取资金\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    // ERC20标准\n', '    event Transfer( // 一次交易\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES  配置       =\n', '    =====================================*/\n', '    string public name = "LastHero3D"; // 名字\n', '    string public symbol = "Keys"; // 符号\n', '    uint8 constant public decimals = 18; // 小数位\n', '    uint8 constant internal dividendFee_ = 10; // 交易分红比例\n', '    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether; // 代币初始价格\n', '    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether; // 代币递增价格\n', '    uint256 constant internal magnitude = 2**64;\n', '    \n', '    // 股份证明（默认值为100代币）\n', '    uint256 public stakingRequirement = 100e18;\n', '    \n', '    // 代表计划\n', '    mapping(address => bool) internal ambassadors_; // 代表集合\n', '    uint256 constant internal ambassadorMaxPurchase_ = 1 ether; // 最大购买\n', '    uint256 constant internal ambassadorQuota_ = 20 ether; // 购买限额\n', '    \n', '    \n', '    \n', '   /*================================\n', '    =            DATASETS   数据     =\n', '    ================================*/\n', '    // 每个地址的股份数量（按比例编号）\n', '    mapping(address => uint256) internal tokenBalanceLedger_; // 保存地址的代币数量\n', '    mapping(address => uint256) internal referralBalance_; // 保存地址的推荐分红\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    // 管理员列表（管理员权限见上述）\n', '    mapping(bytes32 => bool) public administrators; // 管理者地址列表\n', '    \n', '    // 当代表制度成立，只有代表可以购买代币（这确保了完美的金字塔分布，以防持币比例不均）\n', '    bool public onlyAmbassadors = true; // 限制只有代表能够购买代币\n', '    \n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS 公开函数   =\n', '    =======================================*/\n', '    /*\n', '    * -- 应用入口 --  \n', '    */\n', '    function Hourglass()\n', '        public\n', '    {\n', '        // 在这里添加管理员\n', '        administrators[0xdacb12a29ec52e618a1dbe39a3317833066e94371856cc2013565dab2ae6fa62] = true;\n', '        \n', '        // 在这里添加代表。\n', '        // mantso - lead solidity dev & lead web dev. \n', '        ambassadors_[0x24257cF6fEBC8aAaE2dC20906d4Db1C619d40329] = true;\n', '        \n', '        // ponzibot - mathematics & website, and undisputed meme god.\n', '        ambassadors_[0xEa01f6203bD55BA694594FDb5575f2936dB7f698] = true;\n', '        \n', '        // swagg - concept design, feedback, management.\n', '        ambassadors_[0x22caa6670991D67bf0EA033156114F07de4aa20b] = true;\n', '        \n', '        // k-dawgz - shilling machine, meme maestro, bizman.\n', '        ambassadors_[0xf9d7f59E5d0711f5482968D69B5aEe251945D1c5] = true;\n', '        \n', '        // elmojo - all those pretty .GIFs & memes you see? you can thank this man for that.\n', '        ambassadors_[0x4d82B6839Fd64eF7D3Af64080167A42bF9B9E332] = true;\n', '        \n', '        // capex - community moderator.\n', '        ambassadors_[0x1f50451b941d163837623E25E22033C11626491C] = true;\n', '        \n', '        // jörmungandr - pentests & twitter trendsetter.\n', '        ambassadors_[0xC68538d6971D1B0AC8829f8B14e6a9B2AF614119] = true;\n', '        \n', '        // inventor - the source behind the non-intrusive referral model.\n', '        ambassadors_[0x23183DaFd738FB876c363dA7651A679fcb24b657] = true;\n', '        \n', '        // tocsick - pentesting, contract auditing.\n', '        ambassadors_[0x95E8713a5D2bf0DDAf8D0819e73907a8CEE3D111] = true;\n', '        \n', '        // arc - pentesting, contract auditing.\n', '        ambassadors_[0x976f6397ae155239289D6cb7904E6730BeBa7c79] = true;\n', '        \n', '        // sumpunk - contract auditing.\n', '        ambassadors_[0xC26BB52D97BA7e4c6DA8E7b07D1B8B78Be178FBd] = true;\n', '        \n', '        // randall - charts & sheets, data dissector, advisor.\n', '        ambassadors_[0x23C654314EaDAaE05857dE5a61c1228c33282807] = true;\n', '        \n', '        // ambius - 3d chart visualization.\n', '        ambassadors_[0xA732E7665fF54Ba63AE40E67Fac9f23EcD0b1223] = true;\n', '        \n', '        // contributors that need to remain private out of security concerns.\n', '        ambassadors_[0x445b660236c39F5bc98bc49ddDc7CF1F246a40aB] = true; //dp\n', '        ambassadors_[0x60e31B8b79bd92302FE452242Ea6F7672a77a80f] = true; //tc\n', '        ambassadors_[0xbbefE89eBb2a0e15921F07F041BE5691d834a287] = true; //ja\n', '        ambassadors_[0x5ad183E481cF0477C024A96c5d678a88249295b8] = true; //sf\n', '        ambassadors_[0x10C5423A46a09D6c5794Cdd507ee9DA7E406F095] = true; //tb\n', '        ambassadors_[0x9E191643D643AA5908C5B9d3b10c27Ad9fb4AcBE] = true; //sm\n', '        ambassadors_[0x2c389a382003E9467a84932E68a35cea27A34B8D] = true; //mc\n', '        ambassadors_[0x4af87534cb13B473D8c1199093a8052b5Ad6661B] = true; //et\n', '        \n', '\n', '    }\n', '    \n', '     \n', '    /**\n', '     * 将所有以太坊网络传入转换为代币调用，并向下传递（如果有下层拓扑）\n', '     */\n', '    function buy(address _referredBy)\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        purchaseTokens(msg.value, _referredBy);\n', '    }\n', '    \n', '    /**\n', '     * 回调函数来处理直接发送到合约的以太坊参数。\n', '     * 我们不能通过这种方式来指定一个地址。\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        purchaseTokens(msg.value, 0x0);\n', '    }\n', '    \n', '    /**\n', '     * 将所有的分红请求转换为代币。\n', '     */\n', '    function reinvest()\n', '        onlyStronghands()\n', '        public\n', '    {\n', '        // 提取股息\n', '        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '        \n', '        // 实际支付的股息\n', '        address _customerAddress = msg.sender;\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '        \n', '        // 检索参考奖金\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        \n', '        // 发送一个购买订单通过虚拟化的“撤回股息”\n', '        uint256 _tokens = purchaseTokens(_dividends, 0x0);\n', '        \n', '        // 重大事件\n', '        onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '    \n', '    /**\n', '     * 退出流程，卖掉并且提取资金\n', '     */\n', '    function exit()\n', '        public\n', '    {\n', '        // 通过调用获取代币数量并将其全部出售\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if(_tokens > 0) sell(_tokens);\n', '        \n', '        // 取款服务\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * 取走请求者的所有收益。\n', '     */\n', '    function withdraw()\n', '        onlyStronghands()\n', '        public\n', '    {\n', '        // 设置数据\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(false); // 从代码中获得参考奖金\n', '        \n', '        // 更新股息系统\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '        \n', '        // 添加参考奖金\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        \n', '        // 获取服务\n', '        _customerAddress.transfer(_dividends);\n', '        \n', '        // 重大事件\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    \n', '    /**\n', '     * 以太坊代币。\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '    {\n', '        // 设置数据\n', '        address _customerAddress = msg.sender;\n', '        // 来自俄罗斯的BTFO\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        \n', '        // 销毁已出售的代币\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '        \n', '        // 更新股息系统\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;       \n', '        \n', '        // 禁止除以0\n', '        if (tokenSupply_ > 0) {\n', '            // 更新代币的股息金额\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        }\n', '        \n', '        // 重大事件\n', '        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * 从请求者账户转移代币新持有者账户。\n', '     * 记住，这里还有10%的费用。\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '        returns(bool)\n', '    {\n', '        // 设置\n', '        address _customerAddress = msg.sender;\n', '        \n', '        // 取保拥有足够的代币\n', '        // 代币禁止转移，直到代表阶段结束。\n', '        // （我们不想捕鲸）\n', '        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        \n', '        // 取走所有未付的股息\n', '        if(myDividends(true) > 0) withdraw();\n', '        \n', '        // 被转移代币的十分之一\n', '        // 这些都将平分给个股东\n', '        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '  \n', '        // 销毁费用代币\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // 代币交换\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '        \n', '        // 更新股息系统\n', '        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n', '        \n', '        // 分发股息给持有者\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        \n', '        // 重大事件\n', '        Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '        \n', '        // ERC20标准\n', '        return true;\n', '       \n', '    }\n', '    \n', '    /*----------  管理员功能  ----------*/\n', '    /**\n', '     * 如果没有满足配额，管理员可以提前结束代表阶段。\n', '     */\n', '    function disableInitialStage()\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        onlyAmbassadors = false;\n', '    }\n', '    \n', '    /**\n', '     * 在特殊情况，可以更换管理员账户。\n', '     */\n', '    function setAdministrator(bytes32 _identifier, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '    \n', '    /**\n', '     * 作为预防措施，管理员可以调整主节点的费率。\n', '     */\n', '    function setStakingRequirement(uint256 _amountOfTokens)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        stakingRequirement = _amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * 管理员可以重新定义品牌（代币名称）。\n', '     */\n', '    function setName(string _name)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '    /**\n', '     * 管理员可以重新定义品牌（代币符号）。\n', '     */\n', '    function setSymbol(string _symbol)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        symbol = _symbol;\n', '    }\n', '\n', '    \n', '    /*----------  帮助者和计数器  ----------*/\n', '    /**\n', '     * 在合约中查看当前以太坊状态的方法\n', '     * 例如 totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() // 查看余额\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return this.balance;\n', '    }\n', '    \n', '    /**\n', '     * 检索代币供应总量。\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply_;\n', '    }\n', '    \n', '    /**\n', '     * 检索请求者的代币余额。\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender; // 获得发送者的地址\n', '        return balanceOf(_customerAddress);\n', '    }\n', '    \n', '    /**\n', '     * 取回请求者拥有的股息。\n', '     * 如果`_includeReferralBonus` 的值为1，那么推荐奖金将被计算在内。\n', '     * 其原因是，在网页的前端，我们希望得到全局汇总。\n', '     * 但在内部计算中，我们希望分开计算。\n', '     */ \n', '    function myDividends(bool _includeReferralBonus) // 返回分红数，传入的参数用来指示是否考虑推荐分红\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '    }\n', '    \n', '    /**\n', '     * 检索任意地址的代币余额。\n', '     */\n', '    function balanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '    \n', '    /**\n', '     * 检索任意地址的股息余额。\n', '     */\n', '    function dividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * 返回代币买入的价格。\n', '     */\n', '    function sellPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // 我们的计算依赖于代币供应，所以我们需要知道供应量。\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 返回代币卖出的价格。\n', '     */\n', '    function buyPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // 我们的计算依赖于代币供应，所以我们需要知道供应量。\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * 前端功能，动态获取买入订单价格。\n', '     */\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * 前端功能，动态获取卖出订单价格。\n', '     */\n', '    function calculateEthereumReceived(uint256 _tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '    \n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS  内部函数   =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n', '        antiEarlyWhale(_incomingEthereum)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        // 数据设置\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\n', '        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        uint256 _fee = _dividends * magnitude;\n', ' \n', '        // 禁止恶意执行\n', '        // 防止溢出\n', '        // (防止黑客入侵)\n', '        // 定义SAFEMATH保证数据安全。\n', '        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n', '        \n', '        // 用户是否被主节点引用？\n', '        if(\n', '            // 是否有推荐者？\n', '            _referredBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // 禁止作弊!\n', '            _referredBy != _customerAddress && // 不能自己推荐自己\n', '            \n', '            // 推荐人是否有足够的代币？\n', '            // 确保推荐人是诚实的主节点\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ){\n', '            // 财富再分配\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '        } else {\n', '            // 无需购买\n', '            // 添加推荐奖励到全局分红\n', '            _dividends = SafeMath.add(_dividends, _referralBonus); // 把推荐奖励还给分红\n', '            _fee = _dividends * magnitude;\n', '        }\n', '        \n', '        // 我们不能给予无尽的以太坊\n', '        if(tokenSupply_ > 0){\n', '            \n', '            // 添加代币到代币池\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', ' \n', '            // 获取这笔交易所获得的股息，并将平均分配给所有股东\n', '            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n', '            \n', '            // 计算用户通过购买获得的代币数量。 \n', '            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n', '        \n', '        } else {\n', '            // 添加代币到代币池\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '        \n', '        // 更新代币供应总量及用户地址\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        \n', '        // 告诉买卖双方在拥有代币前不会获得分红；\n', '        // 我知道你认为你做了，但是你没有做。\n', '        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '        \n', '        // 重大事件\n', '        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * 通过以太坊传入数量计算代币价格；\n', '     * 这是一个算法，在白皮书中能找到它的科学算法；\n', '     * 做了一些修改，以防止十进制错误和代码的上下溢出。\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum) // 计算ETH兑换代币的汇率\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived = \n', '         (\n', '            (\n', '                // 向下溢出尝试\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial**2)\n', '                            +\n', '                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n', '                            +\n', '                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n', '                            +\n', '                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            )/(tokenPriceIncremental_)\n', '        )-(tokenSupply_)\n', '        ;\n', '  \n', '        return _tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * 计算代币出售的价格。\n', '     * 这是一个算法，在白皮书中能找到它的科学算法；\n', '     * 做了一些修改，以防止十进制错误和代码的上下溢出。\n', '     */\n', '     function tokensToEthereum_(uint256 _tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n', '                        )-tokenPriceIncremental_\n', '                    )*(tokens_ - 1e18)\n', '                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n', '            )\n', '        /1e18);\n', '        return _etherReceived;\n', '    }\n', '    \n', '    \n', '    //这里会消耗Gas\n', '    //你大概会多消耗1gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath函数\n', ' * @dev 安全的数学运算\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev 两个数字乘法，抛出溢出。\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的整数除法。\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // 值为0时自动抛出\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // 否则不成立\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的减法，如果减数大于被减数，则溢出抛出。\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev 两个数字的加法，向上溢出抛出\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
