['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', ' address public owner;\n', '\n', '\n', ' event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', ' /**\n', '  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '  * account.\n', '  */\n', ' function Ownable() public {\n', '   owner = msg.sender;\n', ' }\n', '\n', ' /**\n', '  * @dev Throws if called by any account other than the owner.\n', '  */\n', ' modifier onlyOwner() {\n', '   require(msg.sender == owner);\n', '   _;\n', ' }\n', '\n', ' /**\n', '  * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '  * @param newOwner The address to transfer ownership to.\n', '  */\n', ' function transferOwnership(address newOwner) public onlyOwner {\n', '   require(newOwner != address(0));\n', '   emit OwnershipTransferred(owner, newOwner);\n', '   owner = newOwner;\n', ' }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @title Token Loot Contract\n', '/// @author Julia Altenried, Yuriy Kashnikov\n', '\n', 'contract TokenLoot is Ownable {\n', '\n', '  // FIELDS\n', '  /* signer address, verified in &#39;receiveTokenLoot&#39; method, can be set by owner only */\n', '  address neverdieSigner;\n', '  /* SKL token */\n', '  ERC20 sklToken;\n', '  /* XP token */\n', '  ERC20 xpToken;\n', '  /* Gold token */\n', '  ERC20 goldToken;\n', '  /* Silver token */\n', '  ERC20 silverToken;\n', '  /* Scale token */\n', '  ERC20 scaleToken;\n', '  /* Nonces */\n', '  mapping (address => uint) public nonces;\n', '\n', '\n', '  // EVENTS\n', '  event ReceiveLoot(address indexed sender,\n', '                    uint _amountSKL,\n', '                    uint _amountXP,\n', '                    uint _amountGold,\n', '                    uint _amountSilver,\n', '                    uint _amountScale,\n', '                    uint _nonce);\n', ' \n', '\n', '  // SETTERS\n', '  function setSKLContractAddress(address _to) public onlyOwner {\n', '    sklToken = ERC20(_to);\n', '  }\n', '\n', '  function setXPContractAddress(address _to) public onlyOwner {\n', '    xpToken = ERC20(_to);\n', '  }\n', '\n', '  function setGoldContractAddress(address _to) public onlyOwner {\n', '    goldToken = ERC20(_to);\n', '  }\n', '\n', '  function setSilverContractAddress(address _to) public onlyOwner {\n', '    silverToken = ERC20(_to);\n', '  }\n', '\n', '  function setScaleContractAddress(address _to) public onlyOwner {\n', '    scaleToken = ERC20(_to);\n', '  }\n', '\n', '  function setNeverdieSignerAddress(address _to) public onlyOwner {\n', '    neverdieSigner = _to;\n', '  }\n', '\n', '  /// @dev handy constructor to initialize TokenLoot with a set of proper parameters\n', '  /// @param _xpContractAddress XP token address\n', '  /// @param _sklContractAddress SKL token address\n', '  /// @param _goldContractAddress Gold token address\n', '  /// @param _silverContractAddress Silver token address\n', '  /// @param _scaleContractAddress Scale token address\n', '  /// @param _signer signer address, verified further in swap functions\n', '  function TokenLoot(address _xpContractAddress,\n', '                     address _sklContractAddress,\n', '                     address _goldContractAddress,\n', '                     address _silverContractAddress,\n', '                     address _scaleContractAddress,\n', '                     address _signer) {\n', '    xpToken = ERC20(_xpContractAddress);\n', '    sklToken = ERC20(_sklContractAddress);\n', '    goldToken = ERC20(_goldContractAddress);\n', '    silverToken = ERC20(_silverContractAddress);\n', '    scaleToken = ERC20(_scaleContractAddress);\n', '    neverdieSigner = _signer;\n', '  }\n', '\n', '  /// @dev withdraw loot tokens\n', '  /// @param _amountSKL the amount of SKL tokens to withdraw\n', '  /// @param _amountXP them amount of XP tokens to withdraw\n', '  /// @param _amountGold them amount of Gold tokens to withdraw\n', '  /// @param _amountSilver them amount of Silver tokens to withdraw\n', '  /// @param _amountScale them amount of Scale tokens to withdraw\n', '  /// @param _nonce incremental index of withdrawal\n', '  /// @param _v ECDCA signature\n', '  /// @param _r ECDSA signature\n', '  /// @param _s ECDSA signature\n', '  function receiveTokenLoot(uint _amountSKL, \n', '                            uint _amountXP, \n', '                            uint _amountGold, \n', '                            uint _amountSilver,\n', '                            uint _amountScale,\n', '                            uint _nonce, \n', '                            uint8 _v, \n', '                            bytes32 _r, \n', '                            bytes32 _s) {\n', '\n', '    // reject if the new nonce is lower or equal to the current one\n', '    require(_nonce > nonces[msg.sender]);\n', '    nonces[msg.sender] = _nonce;\n', '\n', '    // verify signature\n', '    address signer = ecrecover(keccak256(msg.sender, \n', '                                         _amountSKL, \n', '                                         _amountXP, \n', '                                         _amountGold,\n', '                                         _amountSilver,\n', '                                         _amountScale,\n', '                                         _nonce), _v, _r, _s);\n', '    require(signer == neverdieSigner);\n', '\n', '    // transer tokens\n', '    if (_amountSKL > 0) assert(sklToken.transfer(msg.sender, _amountSKL));\n', '    if (_amountXP > 0) assert(xpToken.transfer(msg.sender, _amountXP));\n', '    if (_amountGold > 0) assert(goldToken.transfer(msg.sender, _amountGold));\n', '    if (_amountSilver > 0) assert(silverToken.transfer(msg.sender, _amountSilver));\n', '    if (_amountScale > 0) assert(scaleToken.transfer(msg.sender, _amountScale));\n', '\n', '    // emit event\n', '    ReceiveLoot(msg.sender, _amountSKL, _amountXP, _amountGold, _amountSilver, _amountScale, _nonce);\n', '  }\n', '\n', '  /// @dev fallback function to reject any ether coming directly to the contract\n', '  function () payable public { \n', '      revert(); \n', '  }\n', '\n', '  /// @dev withdraw all SKL and XP tokens\n', '  function withdraw() public onlyOwner {\n', '    uint256 allSKL = sklToken.balanceOf(this);\n', '    uint256 allXP = xpToken.balanceOf(this);\n', '    uint256 allGold = goldToken.balanceOf(this);\n', '    uint256 allSilver = silverToken.balanceOf(this);\n', '    uint256 allScale = scaleToken.balanceOf(this);\n', '    if (allSKL > 0) sklToken.transfer(msg.sender, allSKL);\n', '    if (allXP > 0) xpToken.transfer(msg.sender, allXP);\n', '    if (allGold > 0) goldToken.transfer(msg.sender, allGold);\n', '    if (allSilver > 0) silverToken.transfer(msg.sender, allSilver);\n', '    if (allScale > 0) scaleToken.transfer(msg.sender, allScale);\n', '  }\n', '\n', '  /// @dev kill contract, but before transfer all SKL and XP tokens \n', '  function kill() onlyOwner public {\n', '    withdraw();\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', ' address public owner;\n', '\n', '\n', ' event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', ' /**\n', '  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '  * account.\n', '  */\n', ' function Ownable() public {\n', '   owner = msg.sender;\n', ' }\n', '\n', ' /**\n', '  * @dev Throws if called by any account other than the owner.\n', '  */\n', ' modifier onlyOwner() {\n', '   require(msg.sender == owner);\n', '   _;\n', ' }\n', '\n', ' /**\n', '  * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '  * @param newOwner The address to transfer ownership to.\n', '  */\n', ' function transferOwnership(address newOwner) public onlyOwner {\n', '   require(newOwner != address(0));\n', '   emit OwnershipTransferred(owner, newOwner);\n', '   owner = newOwner;\n', ' }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @title Token Loot Contract\n', '/// @author Julia Altenried, Yuriy Kashnikov\n', '\n', 'contract TokenLoot is Ownable {\n', '\n', '  // FIELDS\n', "  /* signer address, verified in 'receiveTokenLoot' method, can be set by owner only */\n", '  address neverdieSigner;\n', '  /* SKL token */\n', '  ERC20 sklToken;\n', '  /* XP token */\n', '  ERC20 xpToken;\n', '  /* Gold token */\n', '  ERC20 goldToken;\n', '  /* Silver token */\n', '  ERC20 silverToken;\n', '  /* Scale token */\n', '  ERC20 scaleToken;\n', '  /* Nonces */\n', '  mapping (address => uint) public nonces;\n', '\n', '\n', '  // EVENTS\n', '  event ReceiveLoot(address indexed sender,\n', '                    uint _amountSKL,\n', '                    uint _amountXP,\n', '                    uint _amountGold,\n', '                    uint _amountSilver,\n', '                    uint _amountScale,\n', '                    uint _nonce);\n', ' \n', '\n', '  // SETTERS\n', '  function setSKLContractAddress(address _to) public onlyOwner {\n', '    sklToken = ERC20(_to);\n', '  }\n', '\n', '  function setXPContractAddress(address _to) public onlyOwner {\n', '    xpToken = ERC20(_to);\n', '  }\n', '\n', '  function setGoldContractAddress(address _to) public onlyOwner {\n', '    goldToken = ERC20(_to);\n', '  }\n', '\n', '  function setSilverContractAddress(address _to) public onlyOwner {\n', '    silverToken = ERC20(_to);\n', '  }\n', '\n', '  function setScaleContractAddress(address _to) public onlyOwner {\n', '    scaleToken = ERC20(_to);\n', '  }\n', '\n', '  function setNeverdieSignerAddress(address _to) public onlyOwner {\n', '    neverdieSigner = _to;\n', '  }\n', '\n', '  /// @dev handy constructor to initialize TokenLoot with a set of proper parameters\n', '  /// @param _xpContractAddress XP token address\n', '  /// @param _sklContractAddress SKL token address\n', '  /// @param _goldContractAddress Gold token address\n', '  /// @param _silverContractAddress Silver token address\n', '  /// @param _scaleContractAddress Scale token address\n', '  /// @param _signer signer address, verified further in swap functions\n', '  function TokenLoot(address _xpContractAddress,\n', '                     address _sklContractAddress,\n', '                     address _goldContractAddress,\n', '                     address _silverContractAddress,\n', '                     address _scaleContractAddress,\n', '                     address _signer) {\n', '    xpToken = ERC20(_xpContractAddress);\n', '    sklToken = ERC20(_sklContractAddress);\n', '    goldToken = ERC20(_goldContractAddress);\n', '    silverToken = ERC20(_silverContractAddress);\n', '    scaleToken = ERC20(_scaleContractAddress);\n', '    neverdieSigner = _signer;\n', '  }\n', '\n', '  /// @dev withdraw loot tokens\n', '  /// @param _amountSKL the amount of SKL tokens to withdraw\n', '  /// @param _amountXP them amount of XP tokens to withdraw\n', '  /// @param _amountGold them amount of Gold tokens to withdraw\n', '  /// @param _amountSilver them amount of Silver tokens to withdraw\n', '  /// @param _amountScale them amount of Scale tokens to withdraw\n', '  /// @param _nonce incremental index of withdrawal\n', '  /// @param _v ECDCA signature\n', '  /// @param _r ECDSA signature\n', '  /// @param _s ECDSA signature\n', '  function receiveTokenLoot(uint _amountSKL, \n', '                            uint _amountXP, \n', '                            uint _amountGold, \n', '                            uint _amountSilver,\n', '                            uint _amountScale,\n', '                            uint _nonce, \n', '                            uint8 _v, \n', '                            bytes32 _r, \n', '                            bytes32 _s) {\n', '\n', '    // reject if the new nonce is lower or equal to the current one\n', '    require(_nonce > nonces[msg.sender]);\n', '    nonces[msg.sender] = _nonce;\n', '\n', '    // verify signature\n', '    address signer = ecrecover(keccak256(msg.sender, \n', '                                         _amountSKL, \n', '                                         _amountXP, \n', '                                         _amountGold,\n', '                                         _amountSilver,\n', '                                         _amountScale,\n', '                                         _nonce), _v, _r, _s);\n', '    require(signer == neverdieSigner);\n', '\n', '    // transer tokens\n', '    if (_amountSKL > 0) assert(sklToken.transfer(msg.sender, _amountSKL));\n', '    if (_amountXP > 0) assert(xpToken.transfer(msg.sender, _amountXP));\n', '    if (_amountGold > 0) assert(goldToken.transfer(msg.sender, _amountGold));\n', '    if (_amountSilver > 0) assert(silverToken.transfer(msg.sender, _amountSilver));\n', '    if (_amountScale > 0) assert(scaleToken.transfer(msg.sender, _amountScale));\n', '\n', '    // emit event\n', '    ReceiveLoot(msg.sender, _amountSKL, _amountXP, _amountGold, _amountSilver, _amountScale, _nonce);\n', '  }\n', '\n', '  /// @dev fallback function to reject any ether coming directly to the contract\n', '  function () payable public { \n', '      revert(); \n', '  }\n', '\n', '  /// @dev withdraw all SKL and XP tokens\n', '  function withdraw() public onlyOwner {\n', '    uint256 allSKL = sklToken.balanceOf(this);\n', '    uint256 allXP = xpToken.balanceOf(this);\n', '    uint256 allGold = goldToken.balanceOf(this);\n', '    uint256 allSilver = silverToken.balanceOf(this);\n', '    uint256 allScale = scaleToken.balanceOf(this);\n', '    if (allSKL > 0) sklToken.transfer(msg.sender, allSKL);\n', '    if (allXP > 0) xpToken.transfer(msg.sender, allXP);\n', '    if (allGold > 0) goldToken.transfer(msg.sender, allGold);\n', '    if (allSilver > 0) silverToken.transfer(msg.sender, allSilver);\n', '    if (allScale > 0) scaleToken.transfer(msg.sender, allScale);\n', '  }\n', '\n', '  /// @dev kill contract, but before transfer all SKL and XP tokens \n', '  function kill() onlyOwner public {\n', '    withdraw();\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']
