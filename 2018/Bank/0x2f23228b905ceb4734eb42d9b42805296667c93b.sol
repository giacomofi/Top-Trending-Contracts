['pragma solidity ^0.4.23;\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title Token\n', ' * @dev Token interface necessary for working with tokens within the exchange contract.\n', ' */\n', 'contract IToken {\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    uint public decimals;\n', '    string public name;\n', '}\n', '\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library LSafeMath {\n', '\n', '    uint256 constant WAD = 1 ether;\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        if (c / a == b)\n', '            return c;\n', '        revert();\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b > 0) { \n', '            uint256 c = a / b;\n', '            return c;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b <= a)\n', '            return a - b;\n', '        revert();\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        if (c >= a) \n', '            return c;\n', '        revert();\n', '    }\n', '\n', '    function wmul(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, b), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, WAD), b / 2) / b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Coinchangex\n', ' * @dev This is the main contract for the Coinchangex exchange.\n', ' */\n', 'contract Coinchangex {\n', '  \n', '  using LSafeMath for uint;\n', '  \n', '  struct SpecialTokenBalanceFeeTake {\n', '      bool exist;\n', '      address token;\n', '      uint256 balance;\n', '      uint256 feeTake;\n', '  }\n', '  \n', '  uint constant private MAX_SPECIALS = 10;\n', '\n', '  /// Variables\n', '  address public admin; // the admin address\n', '  address public feeAccount; // the account that will receive fees\n', '  uint public feeTake; // percentage times (1 ether)\n', '  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\n', '  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '  SpecialTokenBalanceFeeTake[] public specialFees;\n', '  \n', '\n', '  /// Logging Events\n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\n', '  modifier isAdmin() {\n', '      require(msg.sender == admin);\n', '      _;\n', '  }\n', '\n', '  /// Constructor function. This is only called on contract creation.\n', '  function Coinchangex(address admin_, address feeAccount_, uint feeTake_) public {\n', '    admin = admin_;\n', '    feeAccount = feeAccount_;\n', '    feeTake = feeTake_;\n', '    depositingTokenFlag = false;\n', '  }\n', '\n', '  /// The fallback function. Ether transfered into the contract is not accepted.\n', '  function() public {\n', '    revert();\n', '  }\n', '\n', '  /// Changes the official admin user address. Accepts Ethereum address.\n', '  function changeAdmin(address admin_) public isAdmin {\n', '    require(admin_ != address(0));\n', '    admin = admin_;\n', '  }\n', '\n', '  /// Changes the account address that receives trading fees. Accepts Ethereum address.\n', '  function changeFeeAccount(address feeAccount_) public isAdmin {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\n', '  function changeFeeTake(uint feeTake_) public isAdmin {\n', '    // require(feeTake_ <= feeTake);\n', '    feeTake = feeTake_;\n', '  }\n', '  \n', '  // add special promotion fee\n', '  function addSpecialFeeTake(address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      uint id = specialFees.push(SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      ));\n', '  }\n', '  \n', '  // chnage special promotion fee\n', '  function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      require(id < specialFees.length);\n', '      specialFees[id] = SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      );\n', '  }\n', '  \n', '    // remove special promotion fee\n', '   function removeSpecialFeeTake(uint id) public isAdmin {\n', '       if (id >= specialFees.length) revert();\n', '\n', '        uint last = specialFees.length-1;\n', '        for (uint i = id; i<last; i++){\n', '            specialFees[i] = specialFees[i+1];\n', '        }\n', '        \n', '        delete specialFees[last];\n', '        specialFees.length--;\n', '  } \n', '  \n', '  //return total count promotion fees\n', '  function TotalSpecialFeeTakes() public constant returns(uint)  {\n', '      return specialFees.length;\n', '  }\n', '  \n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Deposits, Withdrawals, Balances\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * This function handles deposits of Ether into the contract.\n', '  * Emits a Deposit event.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function deposit() public payable {\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n', '    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles withdrawals of Ether from the contract.\n', '  * Verifies that the user has enough funds to cover the withdrawal.\n', '  * Emits a Withdraw event.\n', '  * @param amount uint of the amount of Ether the user wishes to withdraw\n', '  */\n', '  function withdraw(uint amount) public {\n', '    require(tokens[0][msg.sender] >= amount);\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n', '    msg.sender.transfer(amount);\n', '    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles deposits of Ethereum based tokens to the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Deposit event.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', ' }\n', '\n', '  /**\n', '  * This function provides a fallback solution as outlined in ERC223.\n', '  * If tokens are deposited through depositToken(), the transaction will continue.\n', '  * If tokens are sent directly to this contract, the transaction is reverted.\n', '  * @param sender Ethereum address of the sender of the token\n', '  * @param amount amount of the incoming tokens\n', '  * @param data attached data similar to msg.data of Ether transactions\n', '  */\n', '  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\n', '      if (depositingTokenFlag) {\n', '        // Transfer was initiated from depositToken(). User token balance will be updated there.\n', '        return true;\n', '      } else {\n', '        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\n', '        // with direct transfers of ECR20 and ETH.\n', '        revert();\n', '      }\n', '  }\n', '  \n', '  /**\n', '  * This function handles withdrawals of Ethereum based tokens from the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Withdraw event.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to withdraw\n', '  */\n', '  function withdrawToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    require(tokens[token][msg.sender] >= amount);\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '    require(IToken(token).transfer(msg.sender, amount));\n', '    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * Retrieves the balance of a token based on a user address and token address.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param user Ethereum address of the user\n', '  * @return the amount of tokens on the exchange for a given user address\n', '  */\n', '  function balanceOf(address token, address user) public constant returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Trading\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * Facilitates a trade from one user to another.\n', '  * Requires that the transaction is signed properly, the trade isn&#39;t past its expiration, and all funds are present to fill the trade.\n', '  * Calls tradeBalances().\n', '  * Updates orderFills with the amount traded.\n', '  * Emits a Trade event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require((\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires &&\n', '      orderFills[user][hash].add(amount) <= amountGet\n', '    ));\n', '    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '    orderFills[user][hash] = orderFills[user][hash].add(amount);\n', '    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\n', '  }\n', '\n', '  /**\n', '  * This is a private function and is only being called from trade().\n', '  * Handles the movement of funds when a trade occurs.\n', '  * Takes fees.\n', '  * Updates token balances for both buyer and seller.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '    \n', '    uint256 feeTakeXfer = calculateFee(amount);\n', '    \n', '    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\n', '    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\n', '    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\n', '    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\n', '    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\n', '  }\n', '  \n', '  //calculate fee including special promotions\n', '  function calculateFee(uint amount) private constant returns(uint256)  {\n', '    uint256 feeTakeXfer = 0;\n', '    \n', '    uint length = specialFees.length;\n', '    bool applied = false;\n', '    for(uint i = 0; length > 0 && i < length; i++) {\n', '        SpecialTokenBalanceFeeTake memory special = specialFees[i];\n', '        if(special.exist && special.balance <= tokens[special.token][msg.sender]) {\n', '            applied = true;\n', '            feeTakeXfer = amount.mul(special.feeTake).div(1 ether);\n', '            break;\n', '        }\n', '        if(i >= MAX_SPECIALS)\n', '            break;\n', '    }\n', '    \n', '    if(!applied)\n', '        feeTakeXfer = amount.mul(feeTake).div(1 ether);\n', '    \n', '    \n', '    return feeTakeXfer;\n', '  }\n', '\n', '  /**\n', '  * This function is to test if a trade would go through.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  * @param sender Ethereum address of the user taking the order\n', '  * @return bool: true if the trade would be successful, false otherwise\n', '  */\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n', '    if (!(\n', '      tokens[tokenGet][sender] >= amount &&\n', '      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '      )) { \n', '      return false;\n', '    } else {\n', '      return true;\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the available volume for a given order.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\n', '  */\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    if (!(\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires\n', '      )) {\n', '      return 0;\n', '    }\n', '    uint[2] memory available;\n', '    available[0] = amountGet.sub(orderFills[user][hash]);\n', '    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\n', '    if (available[0] < available[1]) {\n', '      return available[0];\n', '    } else {\n', '      return available[1];\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the amount of an order that has already been filled.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    return orderFills[user][hash];\n', '  }\n', '\n', '  /**\n', '  * This function cancels a given order by editing its fill data to the full amount.\n', '  * Requires that the transaction is signed properly.\n', '  * Updates orderFills to the full amountGet\n', '  * Emits a Cancel event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require ((ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == msg.sender));\n', '    orderFills[msg.sender][hash] = amountGet;\n', '    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '  }\n', '\n', '  \n', '  /**\n', '  * This function handles deposits of Ether into the contract, but allows specification of a user.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function depositForUser(address user) public payable {\n', '    require(user != address(0));\n', '    require(msg.value > 0);\n', '    tokens[0][user] = tokens[0][user].add(msg.value);\n', '  }\n', '  \n', '  /**\n', '  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositTokenForUser(address token, uint amount, address user) public {\n', '    require(token != address(0));\n', '    require(user != address(0));\n', '    require(amount > 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][user] = tokens[token][user].add(amount);\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.23;\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title Token\n', ' * @dev Token interface necessary for working with tokens within the exchange contract.\n', ' */\n', 'contract IToken {\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    uint public decimals;\n', '    string public name;\n', '}\n', '\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library LSafeMath {\n', '\n', '    uint256 constant WAD = 1 ether;\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        if (c / a == b)\n', '            return c;\n', '        revert();\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b > 0) { \n', '            uint256 c = a / b;\n', '            return c;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b <= a)\n', '            return a - b;\n', '        revert();\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        if (c >= a) \n', '            return c;\n', '        revert();\n', '    }\n', '\n', '    function wmul(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, b), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, WAD), b / 2) / b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Coinchangex\n', ' * @dev This is the main contract for the Coinchangex exchange.\n', ' */\n', 'contract Coinchangex {\n', '  \n', '  using LSafeMath for uint;\n', '  \n', '  struct SpecialTokenBalanceFeeTake {\n', '      bool exist;\n', '      address token;\n', '      uint256 balance;\n', '      uint256 feeTake;\n', '  }\n', '  \n', '  uint constant private MAX_SPECIALS = 10;\n', '\n', '  /// Variables\n', '  address public admin; // the admin address\n', '  address public feeAccount; // the account that will receive fees\n', '  uint public feeTake; // percentage times (1 ether)\n', '  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\n', '  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '  SpecialTokenBalanceFeeTake[] public specialFees;\n', '  \n', '\n', '  /// Logging Events\n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\n', '  modifier isAdmin() {\n', '      require(msg.sender == admin);\n', '      _;\n', '  }\n', '\n', '  /// Constructor function. This is only called on contract creation.\n', '  function Coinchangex(address admin_, address feeAccount_, uint feeTake_) public {\n', '    admin = admin_;\n', '    feeAccount = feeAccount_;\n', '    feeTake = feeTake_;\n', '    depositingTokenFlag = false;\n', '  }\n', '\n', '  /// The fallback function. Ether transfered into the contract is not accepted.\n', '  function() public {\n', '    revert();\n', '  }\n', '\n', '  /// Changes the official admin user address. Accepts Ethereum address.\n', '  function changeAdmin(address admin_) public isAdmin {\n', '    require(admin_ != address(0));\n', '    admin = admin_;\n', '  }\n', '\n', '  /// Changes the account address that receives trading fees. Accepts Ethereum address.\n', '  function changeFeeAccount(address feeAccount_) public isAdmin {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\n', '  function changeFeeTake(uint feeTake_) public isAdmin {\n', '    // require(feeTake_ <= feeTake);\n', '    feeTake = feeTake_;\n', '  }\n', '  \n', '  // add special promotion fee\n', '  function addSpecialFeeTake(address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      uint id = specialFees.push(SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      ));\n', '  }\n', '  \n', '  // chnage special promotion fee\n', '  function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      require(id < specialFees.length);\n', '      specialFees[id] = SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      );\n', '  }\n', '  \n', '    // remove special promotion fee\n', '   function removeSpecialFeeTake(uint id) public isAdmin {\n', '       if (id >= specialFees.length) revert();\n', '\n', '        uint last = specialFees.length-1;\n', '        for (uint i = id; i<last; i++){\n', '            specialFees[i] = specialFees[i+1];\n', '        }\n', '        \n', '        delete specialFees[last];\n', '        specialFees.length--;\n', '  } \n', '  \n', '  //return total count promotion fees\n', '  function TotalSpecialFeeTakes() public constant returns(uint)  {\n', '      return specialFees.length;\n', '  }\n', '  \n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Deposits, Withdrawals, Balances\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * This function handles deposits of Ether into the contract.\n', '  * Emits a Deposit event.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function deposit() public payable {\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n', '    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles withdrawals of Ether from the contract.\n', '  * Verifies that the user has enough funds to cover the withdrawal.\n', '  * Emits a Withdraw event.\n', '  * @param amount uint of the amount of Ether the user wishes to withdraw\n', '  */\n', '  function withdraw(uint amount) public {\n', '    require(tokens[0][msg.sender] >= amount);\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n', '    msg.sender.transfer(amount);\n', '    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles deposits of Ethereum based tokens to the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Deposit event.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', ' }\n', '\n', '  /**\n', '  * This function provides a fallback solution as outlined in ERC223.\n', '  * If tokens are deposited through depositToken(), the transaction will continue.\n', '  * If tokens are sent directly to this contract, the transaction is reverted.\n', '  * @param sender Ethereum address of the sender of the token\n', '  * @param amount amount of the incoming tokens\n', '  * @param data attached data similar to msg.data of Ether transactions\n', '  */\n', '  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\n', '      if (depositingTokenFlag) {\n', '        // Transfer was initiated from depositToken(). User token balance will be updated there.\n', '        return true;\n', '      } else {\n', '        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\n', '        // with direct transfers of ECR20 and ETH.\n', '        revert();\n', '      }\n', '  }\n', '  \n', '  /**\n', '  * This function handles withdrawals of Ethereum based tokens from the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Withdraw event.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to withdraw\n', '  */\n', '  function withdrawToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    require(tokens[token][msg.sender] >= amount);\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '    require(IToken(token).transfer(msg.sender, amount));\n', '    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * Retrieves the balance of a token based on a user address and token address.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param user Ethereum address of the user\n', '  * @return the amount of tokens on the exchange for a given user address\n', '  */\n', '  function balanceOf(address token, address user) public constant returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Trading\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * Facilitates a trade from one user to another.\n', "  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\n", '  * Calls tradeBalances().\n', '  * Updates orderFills with the amount traded.\n', '  * Emits a Trade event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require((\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires &&\n', '      orderFills[user][hash].add(amount) <= amountGet\n', '    ));\n', '    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '    orderFills[user][hash] = orderFills[user][hash].add(amount);\n', '    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\n', '  }\n', '\n', '  /**\n', '  * This is a private function and is only being called from trade().\n', '  * Handles the movement of funds when a trade occurs.\n', '  * Takes fees.\n', '  * Updates token balances for both buyer and seller.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '    \n', '    uint256 feeTakeXfer = calculateFee(amount);\n', '    \n', '    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\n', '    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\n', '    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\n', '    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\n', '    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\n', '  }\n', '  \n', '  //calculate fee including special promotions\n', '  function calculateFee(uint amount) private constant returns(uint256)  {\n', '    uint256 feeTakeXfer = 0;\n', '    \n', '    uint length = specialFees.length;\n', '    bool applied = false;\n', '    for(uint i = 0; length > 0 && i < length; i++) {\n', '        SpecialTokenBalanceFeeTake memory special = specialFees[i];\n', '        if(special.exist && special.balance <= tokens[special.token][msg.sender]) {\n', '            applied = true;\n', '            feeTakeXfer = amount.mul(special.feeTake).div(1 ether);\n', '            break;\n', '        }\n', '        if(i >= MAX_SPECIALS)\n', '            break;\n', '    }\n', '    \n', '    if(!applied)\n', '        feeTakeXfer = amount.mul(feeTake).div(1 ether);\n', '    \n', '    \n', '    return feeTakeXfer;\n', '  }\n', '\n', '  /**\n', '  * This function is to test if a trade would go through.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  * @param sender Ethereum address of the user taking the order\n', '  * @return bool: true if the trade would be successful, false otherwise\n', '  */\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n', '    if (!(\n', '      tokens[tokenGet][sender] >= amount &&\n', '      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '      )) { \n', '      return false;\n', '    } else {\n', '      return true;\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the available volume for a given order.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\n', '  */\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    if (!(\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires\n', '      )) {\n', '      return 0;\n', '    }\n', '    uint[2] memory available;\n', '    available[0] = amountGet.sub(orderFills[user][hash]);\n', '    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\n', '    if (available[0] < available[1]) {\n', '      return available[0];\n', '    } else {\n', '      return available[1];\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the amount of an order that has already been filled.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    return orderFills[user][hash];\n', '  }\n', '\n', '  /**\n', '  * This function cancels a given order by editing its fill data to the full amount.\n', '  * Requires that the transaction is signed properly.\n', '  * Updates orderFills to the full amountGet\n', '  * Emits a Cancel event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require ((ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == msg.sender));\n', '    orderFills[msg.sender][hash] = amountGet;\n', '    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '  }\n', '\n', '  \n', '  /**\n', '  * This function handles deposits of Ether into the contract, but allows specification of a user.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function depositForUser(address user) public payable {\n', '    require(user != address(0));\n', '    require(msg.value > 0);\n', '    tokens[0][user] = tokens[0][user].add(msg.value);\n', '  }\n', '  \n', '  /**\n', '  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositTokenForUser(address token, uint amount, address user) public {\n', '    require(token != address(0));\n', '    require(user != address(0));\n', '    require(amount > 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][user] = tokens[token][user].add(amount);\n', '  }\n', '  \n', '}']
