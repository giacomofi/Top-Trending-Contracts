['pragma solidity ^0.4.16;\n', '\n', 'contract Owned {\n', '    \n', '    address public owner;\n', '    mapping(address => bool) public owners;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '        owners[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyOwners{\n', '        address sen = msg.sender;\n', '        require(owners[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner{\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrigin{\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    function addOwner(address newOwner) public onlyOwners{\n', '        owners[newOwner] = true;\n', '    }\n', '\n', '    function removeOwner() public onlyOwners{\n', '        owners[msg.sender] = false;\n', '    }\n', '\n', '    function removeOwner(address newOwner) public onlyOwner{\n', '        owners[newOwner] = false;\n', '    }\n', '\n', '    function isOwner(address o) public view returns(bool){\n', '        return owners[o] == true;\n', '    }\n', '}\n', '\n', '//Can be used by other contracts to get approval to spend tokens\n', 'interface TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', '\n', 'contract TokenERC20 is Owned {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function TokenERC20(uint256 initialSupply,\n', '\t\tstring tokenName,\n', '\t\tstring tokenSymbol,\n', '\t\tuint8 dec) public {\n', '        // totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        totalSupply = initialSupply; // Update total supply with the decimal amount\n', '        balanceOf[this] = totalSupply; // Give the creator all initial tokens\n', '        name = tokenName; // Set the name for display purposes\n', '        symbol = tokenSymbol; // Set the symbol for display purposes\n', '        decimals = dec;\n', '    }\n', '\n', '\n', '    function transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){\n', '        require(_value <= allowance[_from][msg.sender]); // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool success){\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public\n', '\treturns(bool success){\n', '        TokenRecipient spender = TokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns(bool success){\n', '        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value; // Subtract from the sender\n', '        totalSupply -= _value; // Updates totalSupply\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns(bool success){\n', '        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]); // Check allowance\n', '        balanceOf[_from] -= _value; // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\n", '        totalSupply -= _value; // Update totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract MifflinToken is Owned, TokenERC20 {\n', '    \n', '    uint8 public tokenId;\n', '    uint256 ethDolRate = 1000;\n', '    uint256 weiRate = 1000000000000000000;\n', '    address exchange;\n', '    uint256 public buyPrice;\n', '    uint256 public totalContribution = 0;\n', '    uint256 public highestContribution = 0;\n', '    uint256 public lowestContribution = 2 ** 256 - 1;\n', '    uint256 public totalBought = 0;\n', '    mapping(address => bool) public frozenAccount;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    function MifflinToken(address exad,\n', '\t\tuint8 tid,\n', '\t\tuint256 issue,\n', '\t\tstring tokenName,\n', '\t\tstring tokenSymbol,\n', '\t\tuint8 dec)\n', '\t\tTokenERC20(issue * 10 ** uint256(dec), tokenName, tokenSymbol, dec) public {\n', '        tokenId = tid;\n', '        MifflinMarket e = MifflinMarket(exad);\n', '        e.setToken(tokenId,this);\n', '        exchange = exad;\n', '        addOwner(exchange);\n', '    }\n', '\n', '    function buy(uint _value) internal {\n', '        transfer(this, msg.sender, _value);\n', '        totalBought += _value;\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(balanceOf[_from] >= _value); // Check if the sender has enough\n', '        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]); // Check if sender is frozen\n', '        require(!frozenAccount[_to]); // Check if recipient is frozen\n', '        balanceOf[_from] -= _value; // Subtract from the sender\n', '        balanceOf[_to] += _value; // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // public methods to give and take that only owners can call\n', '    function give(address _to, uint256 _value) public onlyOwners returns(bool success){\n', '        transfer(this, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function take(address _from, uint256 _value) public onlyOwners returns(bool success){\n', '        transfer(_from, this, _value);\n', '        return true;\n', '    }\n', '\n', '    // / @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    // / @param target Address to be frozen\n', '    // / @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) public onlyOwners{\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    // / @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n', '    // / @param newBuyPrice Price users can buy from the contract\n', '    function setBuyPrice(uint256 newBuyPrice) public onlyOwners{\n', '        buyPrice = newBuyPrice;\n', '    }\n', '\n', '    // RULE we always lower the price any time there is a new high contribution!\n', '    function contribution(uint256 amount)internal returns(int highlow){\n', '        owner.transfer(msg.value);\n', '        totalContribution += msg.value;\n', '        if (amount > highestContribution) {\n', '            uint256 oneper = buyPrice * 99 / 100; // lower by 1%*\n', '            uint256 fullper = buyPrice *  highestContribution / amount; // lower by how much you beat the prior contribution\n', '            if(fullper > oneper) buyPrice = fullper;\n', '            else buyPrice = oneper;\n', '            highestContribution = amount;\n', '            // give reward\n', '            MifflinMarket(exchange).highContributionAward(msg.sender);\n', '            return 1;\n', '        } else if(amount < lowestContribution){\n', '            MifflinMarket(exchange).lowContributionAward(msg.sender);\n', '            lowestContribution = amount;\n', '            return -1;\n', '        } else return 0;\n', '    }\n', '\n', '    // sell tokens back to sender using owners ether\n', '    function sell(uint256 amount) public {\n', '        transfer(msg.sender, this, amount); // makes the transfers\n', '    }\n', '}\n', '\n', '\n', '/******************************************/\n', '/*       CUSTOM MIFFLIN TOKENS       */\n', '/******************************************/\n', '\n', 'contract BeetBuck is Owned, MifflinToken {\n', '    function BeetBuck(address exchange)MifflinToken(exchange, 2, 2000000, "Beet Buck", "BEET", 8) public {\n', '        buyPrice = weiRate / ethDolRate / uint(10) ** decimals; // 1d\n', '    }\n', '\n', '    function () payable public {\n', '        contribution(msg.value);\n', '        uint256 amountToGive = 0;\n', '        uint256 price = buyPrice;\n', '        if (totalBought < 10000) {\n', '            price -= price * 15 / 100;\n', '        } else if (totalBought < 50000) {\n', '            price -= price / 10;\n', '        } else if (totalBought < 100000) {\n', '            price -= price / 20;\n', '        } else if (totalBought < 200000) {\n', '            price -= price / 100;\n', '        }\n', '        amountToGive += msg.value / price;\n', '        buy(amountToGive);\n', '    }\n', '}\n', '\n', '\n', 'contract NapNickel is Owned, MifflinToken {\n', '\n', '    function NapNickel(address exchange)\n', '\tMifflinToken(exchange, 3, 1000000000, "Nap Nickel", "NAPP", 8) public {\n', '        buyPrice = weiRate / ethDolRate /  uint(10) ** decimals / 20; // 5c\n', '    }\n', '\n', '    function () payable public {\n', '        contribution(msg.value);\n', '        uint256 price = buyPrice;\n', '        uint256 estTime = block.timestamp - 5 * 60 * 60;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 weekday;\n', '        (, month,day,hour,,,weekday) = parseTimestampParts(estTime);\n', '        if (month == 4 && day == 26) {\n', '            // its pretzel day\n', '            price += buyPrice / 5;\n', '        } else if (weekday == 0 || weekday == 6) {\n', '            // buying during weekend, get off my property\n', '            price += buyPrice * 15 / 100;\n', '        } else if (hour < 9 || hour >= 17) {\n', '            // buying outside of work hours, im in my hot tub\n', '            price += buyPrice / 10;\n', '        } else if (hour > 12 && hour < 13) {\n', '            // buying during lunch, leave me alone dammit\n', '            price += buyPrice / 20;\n', '        }\n', '        uint256 amountToGive = 0;\n', '        amountToGive += msg.value / price;\n', '        buy(amountToGive);\n', '    }\n', '    \n', '    struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '        \n', '        function parseTimestampParts(uint timestamp) public pure returns (uint16 year,uint8 month,uint8 day, uint8 hour,uint8 minute,uint8 second,uint8 weekday) {\n', '            _DateTime memory dt = parseTimestamp(timestamp);\n', '            return (dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second,dt.weekday);\n', '        }\n', '\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '}\n', '\n', '\n', 'contract QuabityQuarter is Owned, MifflinToken {\n', '    uint lastContributionTime = 0;\n', '\n', '    function QuabityQuarter(address exchange)\n', '\tMifflinToken(exchange, 4, 420000000, "Quabity Quarter", "QUAB", 8) public {\n', '        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 4; // 25c\n', '    }\n', '\n', '    function () payable public {\n', '        contribution(msg.value);\n', '        uint256 amountToGive = 0;\n', '        amountToGive += msg.value / buyPrice;\n', '        uint256 time = block.timestamp;\n', '        uint256 diff = time - lastContributionTime / 60 / 60;\n', '        uint256 chance = 0;\n', '        if (diff > 96)\n', '\t\t\tchance = 50;\n', '        if (diff > 48)\n', '\t\t\tchance = 40;\n', '        else if (diff > 24)\n', '\t\t\tchance = 30;\n', '        else if (diff > 12)\n', '\t\t\tchance = 20;\n', '        else if (diff > 1)\n', '\t\t\tchance = 10;\n', '        else chance = 5;\n', '        if (chance > 0) {\n', '            uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0)));\n', '            if (lastBlockHash % 100 < chance) {\n', '                // stole 10% extra!\n', '                amountToGive += amountToGive / 10;\n', '            }}\n', '        buy(amountToGive);\n', '    }\n', '}\n', '\n', '\n', 'contract KelevinKoin is Owned, MifflinToken {\n', '    \n', '    function KelevinKoin(address exchange)\n', '\tMifflinToken(exchange, 5, 69000000, "Kelevin Koin", "KLEV", 8) public {\n', '        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 50; // 2c\n', '    }\n', '\n', '    function () payable public {\n', '        contribution(msg.value);\n', '        // have to balance the books!\n', '        uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0)));\n', '        uint256 newPrice = buyPrice + ((lastBlockHash % (buyPrice * 69 / 1000)) - (buyPrice * 69 * 2 / 1000));\n', '        buyPrice = newPrice;\n', '        uint256 amountToGive = msg.value / buyPrice;\n', '        if (buyPrice % msg.value == 0)\n', '\t\t\tamountToGive += amountToGive * 69 / 1000; // add 6.9%\n', '        buy(amountToGive);\n', '    }\n', '}\n', '\n', '\n', 'contract NnexNote is Owned, MifflinToken {\n', '    \n', '    function NnexNote(address exchange) \n', '\tMifflinToken(exchange, 6, 666000000, "Nnex Note", "NNEX", 8) public {\n', '        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 100; // 1c\n', '    }\n', '\n', '    // Do you really want a Nnex Note?\n', '    function () payable public {\n', '        // this is the only place I have human contact, so the more the better\n', '        contribution(msg.value);\n', '        // you can get up to a 50% discount\n', '        uint maxDiscountRange = buyPrice * 100;\n', '        uint discountPercent;\n', '        if(msg.value >= maxDiscountRange) discountPercent = 100;\n', '        else discountPercent = msg.value / maxDiscountRange * 100;\n', '        uint price = buyPrice - (buyPrice / 2) * (discountPercent / 100);\n', '        uint amountToGive = msg.value / price;\n', '        buy(amountToGive);\n', '    }\n', '}\n', '\n', '\n', 'contract DundieDollar is Owned, MifflinToken {\n', '    mapping(uint8 => string) public awards;\n', '    uint8 public awardsCount;\n', '    mapping(address => mapping(uint8 => uint256)) public awardsOf;\n', '\n', '    function DundieDollar(address exchange)\n', '\tMifflinToken(exchange, 1, 1725000000, "Dundie Dollar", "DUND", 0) public {\n', '        buyPrice = weiRate / ethDolRate * 10; // 10d\n', '        awards[0] = "Best Dad Award";\n', '        awards[1] = "Best Mom Award";\n', '        awards[2] = "Hottest in the Office Award";\n', '        awards[3] = "Diabetes Award";\n', '        awards[4] = "Promising Assistant Manager Award";\n', '        awards[5] = "Cutest Redhead in the Office Award";\n', '        awards[6] = "Best Host Award";\n', '        awards[7] = "Doobie Doobie Pothead Stoner of the Year Award";\n', '        awards[8] = "Extreme Repulsiveness Award";\n', '        awards[9] = "Redefining Beauty Award";\n', '        awards[10] = "Kind of A Bitch Award";\n', '        awards[11] = "Moving On Up Award";\n', '        awards[12] = "Worst Salesman of the Year";\n', '        awards[13] = "Busiest Beaver Award";\n', '        awards[14] = "Tight-Ass Award";\n', '        awards[15] = "Spicy Curry Award";\n', '        awards[16] = "Don\'t Go in There After Me";\n', '        awards[17] = "Fine Work Award";\n', '        awards[18] = "Whitest Sneakers Award";\n', '        awards[19] = "Great Work Award";\n', '        awards[20] = "Longest Engagement Award";\n', '        awards[21] = "Show Me the Money Award";\n', '        awards[22] = "Best Boss Award";\n', '        awards[23] = "Grace Under Fire Award";\n', '        awardsCount = 24;\n', '    }\n', '\n', '    function addAward(string name) public onlyOwners{\n', '        awards[awardsCount] = name;\n', '        awardsCount++;\n', '    }\n', '\n', '    function () payable public {\n', '        contribution(msg.value);\n', '        uint256 amountToGive = msg.value / buyPrice;\n', '        buy(amountToGive);\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value) internal {\n', '        super.transfer(_from,_to,_value);\n', '        transferAwards(_from,_to,_value);\n', '    }\n', '\n', '\t//This should only be called from the above function\n', '    function transferAwards(address _from, address _to, uint _value) internal {\n', '        uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0))) + _value;\n', '        uint8 award = uint8(lastBlockHash % awardsCount);\n', '        if(_from == address(this)) {\n', '            //dont need to loop through awards\n', '            transferAwards(_from,_to,award,_value);\n', '\n', '        } else { // only take awards that they have\n', '            uint left = _value;\n', '      \n', '      \t\tfor (uint8 i = 0; i < awardsCount; i++) {\n', '                uint256 bal = awardBalanceOf(_from,award);\n', '                if(bal > 0){\n', '                    if(bal < left) {\n', '                        transferAwards(_from,_to,award,bal);\n', '                        left -= bal;\n', '                    } else {\n', '                    \ttransferAwards(_from,_to,award,left);\n', '                        left = 0;\n', '                    }\n', '                }\n', '                if(left == 0) break;\n', '                award ++;\n', '                if(award == awardsCount - 1) award = 0; // reset\n', '            }\n', '        }\n', '    }\n', '    \n', '    function transferAwards(address from, address to, uint8 award , uint value) internal {\n', '        //dont try to take specific awards from the contract\n', '        if(from != address(this)) {\n', '            require(awardBalanceOf(from,award) >= value );\n', '            awardsOf[from][award] -= value;\n', '        }\n', '        //dont try to send specific awards to the contract\n', '        if(to != address(this)) awardsOf[to][award] += value;\n', '    }\n', '    \n', '\n', '    function awardBalanceOf(address addy,uint8 award) view public returns(uint){\n', '        return awardsOf[addy][award];\n', '    }\n', '    \n', '    function awardName(uint8 id) view public returns(string) {\n', '        return awards[id];\n', '    }\n', '}\n', '\n', '\n', 'contract MifflinMarket is Owned {\n', '    mapping(uint8 => address) public tokenIds;\n', '    //mapping(uint8 => mapping(uint8 => uint256)) exchangeRates;\n', '    mapping(uint8 => mapping(uint8 => int256)) public totalExchanged;\n', '    uint8 rewardTokenId = 1;\n', '    bool active;\n', '    \n', '     function MifflinMarket() public {\n', '         active = true;\n', '     }\n', '    \n', '     modifier onlyTokens {\n', '        MifflinToken mt = MifflinToken(msg.sender);\n', '        // make sure sender is a token contract\n', '        require(tokenIds[mt.tokenId()] == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function setToken(uint8 tid,address addy) public onlyOwnerOrigin { // Only add tokens that were created by exchange owner\n', '        tokenIds[tid] = addy;\n', '    }\n', '\n', '    function removeToken(uint8 id) public onlyOwner { // Only add tokens that were created by owner\n', '        tokenIds[id] = 0;\n', '    }\n', '    \n', '    function setActive(bool act) public onlyOwner {\n', '        active = act;\n', '    }\n', '\n', '    function getRewardToken() public view returns(MifflinToken){\n', '        return getTokenById(rewardTokenId);\n', '    }\n', '\n', '    function getTokenById(uint8 id) public view returns(MifflinToken){\n', '        require(tokenIds[id] > 0);\n', '        return MifflinToken(tokenIds[id]);\n', '    }\n', '    \n', '    function getTokenByAddress(address addy) public view returns(MifflinToken){\n', '        MifflinToken token = MifflinToken(addy);\n', '        uint8 tokenId = token.tokenId();\n', '        require(tokenIds[tokenId] == addy);\n', '        return token;\n', '    }\n', '\n', '    function exchangeTokensByAddress(uint256 fromAmount, address from, address to) public {\n', '        require(active);\n', '        uint256 takeAmount = fromAmount;\n', '        MifflinToken fromToken = getTokenByAddress(from);\n', '        MifflinToken toToken = getTokenByAddress(to);\n', '        uint8 fromId = fromToken.tokenId();\n', '        uint8 toId = toToken.tokenId();\n', '        uint256 fromPrice = fromToken.buyPrice();\n', '        uint256 toPrice = toToken.buyPrice();\n', '        uint256 toAmount = fromAmount * fromPrice / toPrice;\n', '        takeAmount = toAmount * toPrice / fromPrice;\n', '        // take fromTokens back to contract\n', '        fromToken.take(msg.sender, takeAmount);\n', '        // give toTokens out from contract\n', '        toToken.give(msg.sender, toAmount);\n', '        // update some stats\n', '        totalExchanged[fromId][toId] += int(toAmount);\n', '        totalExchanged[toId][fromId] -= int(takeAmount);\n', '    }\n', '\n', '    // most basic exchange - just calculates price ratio\n', '    function exchangeTokensById(uint256 fromAmount, uint8 from, uint8 to) public {\n', '        address fromAddress = tokenIds[from];\n', '        address toAddress = tokenIds[to];\n', '        exchangeTokensByAddress(fromAmount,fromAddress,toAddress);\n', '\t    //adjust price?\n', '    }\n', '\n', '    function highContributionAward(address to) public onlyTokens {\n', '        MifflinToken reward = getRewardToken();\n', '        //dont throw an error if there are no more tokens\n', '        if(reward.balanceOf(reward) > 0){\n', '            reward.give(to, 1);\n', '        }\n', '    }\n', '\n', '    function lowContributionAward(address to) public onlyTokens {\n', '        MifflinToken reward = getRewardToken();\n', '        //dont throw an error here since this is just sugar\n', '        if(reward.balanceOf(to) > 0){\n', '            reward.take(to, 1);\n', '        }\n', '    }\n', '}']