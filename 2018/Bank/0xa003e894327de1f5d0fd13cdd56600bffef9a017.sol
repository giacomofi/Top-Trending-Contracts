['pragma solidity 0.4.23;\n', '\n', 'contract ERC20Interface {\n', '\n', '    function totalSupply() public constant returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '}\n', '\n', 'contract AirSwapExchangeI {\n', '    function fill(address makerAddress, uint makerAmount, address makerToken,\n', '                  address takerAddress, uint takerAmount, address takerToken,\n', '                  uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) payable;\n', '}\n', '\n', 'contract KyberNetworkI {\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '}\n', '\n', 'contract EtherDelta {\n', '    function deposit() payable;\n', '    function withdraw(uint amount);\n', '    function depositToken(address token, uint amount);\n', '    function withdrawToken(address token, uint amount);\n', '    function balanceOf(address token, address user) constant returns (uint);\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '}\n', '\n', 'contract BancorConverterI {\n', '    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn)\n', '        public\n', '        payable\n', '        returns (uint256);\n', '}\n', '\n', '/*\n', ' * Dexter connects up EtherDelta, Kyber, Airswap, Bancor so trades can be proxied and a fee levied.\n', ' * The purpose of this is to backfill the sell side of order books so there is always some form of liqudity available.\n', ' *\n', ' * This contract was written by Arctek, for Bamboo Relay.\n', ' */\n', 'contract Dexter {\n', '    address public owner;\n', '    uint256 public takerFee;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function () public payable {\n', '        // need this for ED withdrawals\n', '    }\n', '\n', '    function kill() public {\n', '        require(msg.sender == owner);\n', '\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    function setFee(uint256 _takerFee) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(takerFee != _takerFee);\n', '\n', '        takerFee = _takerFee;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setOwner(address _owner) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(owner != _owner);\n', '\n', '        owner = _owner;\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw() public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(address(this).balance > 0);\n', '\n', '        msg.sender.transfer(address(this).balance);\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(ERC20Interface erc20) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        \n', '        uint256 balance = erc20.balanceOf(this);\n', '\n', '        // Sanity check in case the contract does not do this\n', '        require(balance > 0);\n', '\n', '        require(erc20.transfer(msg.sender, balance));\n', '\n', '        return true;\n', '    }\n', '\n', '    // In case it needs to proxy later in the future\n', '    function approve(ERC20Interface erc20, address spender, uint tokens) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '\n', '        require(erc20.approve(spender, tokens));\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeAirswap(\n', '        address makerAddress, \n', '        uint makerAmount, \n', '        address makerToken,\n', '        uint256 expirationFinalAmount, \n', '        uint256 nonceFee, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s\n', '    ) \n', '        payable\n', '        returns (bool success)\n', '    {\n', '        // Fill the order, always ETH, since we can&#39;t withdraw from the user unless authorized\n', '        AirSwapExchangeI(0x8fd3121013A07C57f0D69646E86E7a4880b467b7).fill.value(msg.value)(\n', '            makerAddress, \n', '            makerAmount, \n', '            makerToken, \n', '            0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, \n', '            msg.value, \n', '            address(0),\n', '            expirationFinalAmount, \n', '            nonceFee, \n', '            v, \n', '            r, \n', '            s\n', '        );\n', '\n', '        if (takerFee > 0) {\n', '            nonceFee = (makerAmount * takerFee) / (1 ether);\n', '\n', '            expirationFinalAmount = makerAmount - nonceFee;//;\n', '        }\n', '        else {\n', '            expirationFinalAmount = makerAmount;\n', '        }\n', '\n', '        require(ERC20Interface(makerToken).transferFrom(0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, msg.sender, expirationFinalAmount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeKyber(\n', '        address dest,\n', '        uint256 maxDestAmount,\n', '        uint256 minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        uint256 actualDestAmount = KyberNetworkI(0x964F35fAe36d75B1e72770e244F6595B68508CF5).trade.value(msg.value)(\n', '            0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, // eth token in kyber\n', '            msg.value,\n', '            dest, \n', '            this,\n', '            maxDestAmount,\n', '            minConversionRate,\n', '            walletId\n', '        );\n', '\n', '        uint256 transferAmount;\n', '\n', '        if (takerFee > 0) {\n', '            uint256 fee = (actualDestAmount * takerFee) / (1 ether);\n', '\n', '            transferAmount = actualDestAmount - fee;\n', '        }\n', '        else {\n', '            transferAmount = actualDestAmount;\n', '        }\n', '\n', '        require(ERC20Interface(dest).transfer(msg.sender, transferAmount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function widthdrawEtherDelta(uint256 amount) public returns (bool success) {\n', '        // withdraw dust\n', '        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\n', '\n', '        etherDelta.withdraw(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    //ed trade\n', '    function tradeEtherDelta(\n', '        address tokenGet, \n', '        uint256 amountGetFee,\n', '        address tokenGive,\n', '        uint256 amountGive, \n', '        uint256 expiresFinalAmount, \n', '        uint256 nonce, \n', '        address user, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s, \n', '        uint256 amount,\n', '        uint256 withdrawAmount\n', '    )\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\n', '\n', '        // deposit\n', '        etherDelta.deposit.value(msg.value)();\n', '\n', '        // trade throws if it can&#39;t match\n', '        etherDelta.trade(\n', '            tokenGet, \n', '            amountGetFee, \n', '            tokenGive, \n', '            amountGive,\n', '            expiresFinalAmount, \n', '            nonce, \n', '            user,\n', '            v, \n', '            r, \n', '            s, \n', '            amount\n', '        );\n', '\n', '        etherDelta.withdrawToken(tokenGive, withdrawAmount);\n', '\n', '        if (takerFee > 0) {\n', '            // amountGetFee\n', '            amountGetFee = (withdrawAmount * takerFee) / (1 ether);\n', '\n', '            expiresFinalAmount = withdrawAmount - amountGetFee;\n', '        }\n', '        else {\n', '            expiresFinalAmount = withdrawAmount;\n', '        }\n', '\n', '        require(ERC20Interface(tokenGive).transfer(msg.sender, expiresFinalAmount) != false);\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeBancor(address[] _path, uint256 _amount, uint256 _minReturn, address _token)\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        uint256 actualAmount = BancorConverterI(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29).quickConvert.value(msg.value)(\n', '            _path,\n', '            _amount,\n', '            _minReturn\n', '        );\n', '\n', '        uint256 transferAmount;\n', '\n', '        if (takerFee > 0) {\n', '            uint256 fee = (actualAmount * takerFee) / (1 ether);\n', '\n', '            transferAmount = actualAmount - fee;\n', '        }\n', '        else {\n', '            transferAmount = actualAmount;\n', '        }\n', '\n', '        require(ERC20Interface(_token).transfer(msg.sender, transferAmount));\n', '\n', '        return true;\n', '    }\n', '}']
['pragma solidity 0.4.23;\n', '\n', 'contract ERC20Interface {\n', '\n', '    function totalSupply() public constant returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '}\n', '\n', 'contract AirSwapExchangeI {\n', '    function fill(address makerAddress, uint makerAmount, address makerToken,\n', '                  address takerAddress, uint takerAmount, address takerToken,\n', '                  uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) payable;\n', '}\n', '\n', 'contract KyberNetworkI {\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '}\n', '\n', 'contract EtherDelta {\n', '    function deposit() payable;\n', '    function withdraw(uint amount);\n', '    function depositToken(address token, uint amount);\n', '    function withdrawToken(address token, uint amount);\n', '    function balanceOf(address token, address user) constant returns (uint);\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '}\n', '\n', 'contract BancorConverterI {\n', '    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn)\n', '        public\n', '        payable\n', '        returns (uint256);\n', '}\n', '\n', '/*\n', ' * Dexter connects up EtherDelta, Kyber, Airswap, Bancor so trades can be proxied and a fee levied.\n', ' * The purpose of this is to backfill the sell side of order books so there is always some form of liqudity available.\n', ' *\n', ' * This contract was written by Arctek, for Bamboo Relay.\n', ' */\n', 'contract Dexter {\n', '    address public owner;\n', '    uint256 public takerFee;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function () public payable {\n', '        // need this for ED withdrawals\n', '    }\n', '\n', '    function kill() public {\n', '        require(msg.sender == owner);\n', '\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    function setFee(uint256 _takerFee) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(takerFee != _takerFee);\n', '\n', '        takerFee = _takerFee;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setOwner(address _owner) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(owner != _owner);\n', '\n', '        owner = _owner;\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw() public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        require(address(this).balance > 0);\n', '\n', '        msg.sender.transfer(address(this).balance);\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(ERC20Interface erc20) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        \n', '        uint256 balance = erc20.balanceOf(this);\n', '\n', '        // Sanity check in case the contract does not do this\n', '        require(balance > 0);\n', '\n', '        require(erc20.transfer(msg.sender, balance));\n', '\n', '        return true;\n', '    }\n', '\n', '    // In case it needs to proxy later in the future\n', '    function approve(ERC20Interface erc20, address spender, uint tokens) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '\n', '        require(erc20.approve(spender, tokens));\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeAirswap(\n', '        address makerAddress, \n', '        uint makerAmount, \n', '        address makerToken,\n', '        uint256 expirationFinalAmount, \n', '        uint256 nonceFee, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s\n', '    ) \n', '        payable\n', '        returns (bool success)\n', '    {\n', "        // Fill the order, always ETH, since we can't withdraw from the user unless authorized\n", '        AirSwapExchangeI(0x8fd3121013A07C57f0D69646E86E7a4880b467b7).fill.value(msg.value)(\n', '            makerAddress, \n', '            makerAmount, \n', '            makerToken, \n', '            0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, \n', '            msg.value, \n', '            address(0),\n', '            expirationFinalAmount, \n', '            nonceFee, \n', '            v, \n', '            r, \n', '            s\n', '        );\n', '\n', '        if (takerFee > 0) {\n', '            nonceFee = (makerAmount * takerFee) / (1 ether);\n', '\n', '            expirationFinalAmount = makerAmount - nonceFee;//;\n', '        }\n', '        else {\n', '            expirationFinalAmount = makerAmount;\n', '        }\n', '\n', '        require(ERC20Interface(makerToken).transferFrom(0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, msg.sender, expirationFinalAmount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeKyber(\n', '        address dest,\n', '        uint256 maxDestAmount,\n', '        uint256 minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        uint256 actualDestAmount = KyberNetworkI(0x964F35fAe36d75B1e72770e244F6595B68508CF5).trade.value(msg.value)(\n', '            0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, // eth token in kyber\n', '            msg.value,\n', '            dest, \n', '            this,\n', '            maxDestAmount,\n', '            minConversionRate,\n', '            walletId\n', '        );\n', '\n', '        uint256 transferAmount;\n', '\n', '        if (takerFee > 0) {\n', '            uint256 fee = (actualDestAmount * takerFee) / (1 ether);\n', '\n', '            transferAmount = actualDestAmount - fee;\n', '        }\n', '        else {\n', '            transferAmount = actualDestAmount;\n', '        }\n', '\n', '        require(ERC20Interface(dest).transfer(msg.sender, transferAmount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function widthdrawEtherDelta(uint256 amount) public returns (bool success) {\n', '        // withdraw dust\n', '        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\n', '\n', '        etherDelta.withdraw(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    //ed trade\n', '    function tradeEtherDelta(\n', '        address tokenGet, \n', '        uint256 amountGetFee,\n', '        address tokenGive,\n', '        uint256 amountGive, \n', '        uint256 expiresFinalAmount, \n', '        uint256 nonce, \n', '        address user, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s, \n', '        uint256 amount,\n', '        uint256 withdrawAmount\n', '    )\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\n', '\n', '        // deposit\n', '        etherDelta.deposit.value(msg.value)();\n', '\n', "        // trade throws if it can't match\n", '        etherDelta.trade(\n', '            tokenGet, \n', '            amountGetFee, \n', '            tokenGive, \n', '            amountGive,\n', '            expiresFinalAmount, \n', '            nonce, \n', '            user,\n', '            v, \n', '            r, \n', '            s, \n', '            amount\n', '        );\n', '\n', '        etherDelta.withdrawToken(tokenGive, withdrawAmount);\n', '\n', '        if (takerFee > 0) {\n', '            // amountGetFee\n', '            amountGetFee = (withdrawAmount * takerFee) / (1 ether);\n', '\n', '            expiresFinalAmount = withdrawAmount - amountGetFee;\n', '        }\n', '        else {\n', '            expiresFinalAmount = withdrawAmount;\n', '        }\n', '\n', '        require(ERC20Interface(tokenGive).transfer(msg.sender, expiresFinalAmount) != false);\n', '\n', '        return true;\n', '    }\n', '\n', '    function tradeBancor(address[] _path, uint256 _amount, uint256 _minReturn, address _token)\n', '        public\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        uint256 actualAmount = BancorConverterI(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29).quickConvert.value(msg.value)(\n', '            _path,\n', '            _amount,\n', '            _minReturn\n', '        );\n', '\n', '        uint256 transferAmount;\n', '\n', '        if (takerFee > 0) {\n', '            uint256 fee = (actualAmount * takerFee) / (1 ether);\n', '\n', '            transferAmount = actualAmount - fee;\n', '        }\n', '        else {\n', '            transferAmount = actualAmount;\n', '        }\n', '\n', '        require(ERC20Interface(_token).transfer(msg.sender, transferAmount));\n', '\n', '        return true;\n', '    }\n', '}']
