['pragma solidity ^0.4.25;\n', '\n', 'contract etc4{\n', '    mapping (address => uint256) invested;\n', '    mapping (address => uint256) dateInvest;\n', '    uint constant public FEE = 4;\n', '    uint constant public ADMIN_FEE = 2;\n', '    uint constant public REFERRER_FEE = 2;\n', '    address private adminAddr;\n', '    \n', '    constructor() public{\n', '        adminAddr = msg.sender;\n', '    }\n', '\n', '    function () external payable {\n', '        address sender = msg.sender;\n', '        \n', '        if (invested[sender] != 0) {\n', '            uint256 amount = getInvestorDividend(sender);\n', '            if (amount >= address(this).balance){\n', '                amount = address(this).balance;\n', '            }\n', '            sender.send(amount);\n', '        }\n', '\n', '        dateInvest[sender] = now;\n', '        invested[sender] += msg.value;\n', '\n', '        if (msg.value > 0){\n', '            adminAddr.send(msg.value * ADMIN_FEE / 100);\n', '            address ref = bytesToAddress(msg.data);\n', '            if (ref != sender && invested[ref] != 0){\n', '                ref.send(msg.value * REFERRER_FEE / 100);\n', '                sender.send(msg.value * REFERRER_FEE / 100);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getInvestorDividend(address addr) public view returns(uint256) {\n', '        return invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 1 days;\n', '    }\n', '    \n', '    function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '\n', '}']