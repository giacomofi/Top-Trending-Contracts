['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) pure internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) pure internal returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) pure internal returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public; // Some ERC20 doesn&#39;t have return\n', '    function transferFrom(address _from, address _to, uint _value) public; // Some ERC20 doesn&#39;t have return\n', '    function approve(address _spender, uint _value) public; // Some ERC20 doesn&#39;t have return\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    function decimals() public view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract KyberNetworkContract {\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Src token\n', '    /// @param srcAmount amount of src tokens\n', '    /// @param dest   Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n', '    /// @param walletId is the wallet ID to send part of the fees\n', '    /// @return amount of actual dest tokens\n', '    function trade(\n', '        ERC20 src,\n', '        uint srcAmount,\n', '        ERC20 dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '    \n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param src Src token\n', '    /// @param dest Destination token\n', '    /* solhint-disable code-complexity */\n', '    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint);\n', '}\n', '\n', 'interface KULAPTradingProxy {\n', '    // Trade event\n', '    event Trade( ERC20 src, uint srcAmount, ERC20 dest, uint destAmount);\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Src token\n', '    /// @param srcAmount amount of src tokens\n', '    /// @param dest   Destination token\n', '    /// @return amount of actual dest tokens\n', '    function trade(\n', '        ERC20 src,\n', '        uint srcAmount,\n', '        ERC20 dest\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '    \n', '    function rate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint);\n', '}\n', '\n', 'contract Dex is Ownable {\n', '    event Trade( ERC20 src, uint srcAmount, ERC20 dest, uint destAmount);\n', '\n', '    using SafeMath for uint256;\n', '    ERC20 public etherERC20 = ERC20(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    address public dexWallet = 0x7ff0F1919424F0D2B6A109E3139ae0f1d836D468; // To receive fee of the DEX network\n', '\n', '    // list of trading proxies\n', '    KULAPTradingProxy[] public tradingProxies;\n', '\n', '    function _tradeEtherToToken(uint256 tradingProxyIndex, uint256 srcAmount, ERC20 dest) private returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Trade to proxy\n', '        uint256 destAmount = tradingProxy.trade.value(srcAmount)(\n', '            etherERC20,\n', '            srcAmount, \n', '            dest\n', '        );\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Receive ETH in case of trade Token -> ETH, will get ETH back from trading proxy\n', '    function () payable {\n', '\n', '    }\n', '\n', '    function _tradeTokenToEther(uint256 tradingProxyIndex, ERC20 src, uint256 amount) private returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, amount);\n', '\n', '        // Trande with kyber\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            amount, \n', '            etherERC20);\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function _trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) private returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        // Trade ETH -> Any\n', '        if (etherERC20 == src) {\n', '            destAmount = _tradeEtherToToken(tradingProxyIndex, srcAmount, dest);\n', '        \n', '        // Trade Any -> ETH\n', '        } else if (etherERC20 == dest) {\n', '            destAmount = _tradeTokenToEther(tradingProxyIndex, src, srcAmount);\n', '\n', '        // Trade Any -> Any\n', '        } else {\n', '\n', '        }\n', '\n', '        // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '        assert(destAmount >= minDestAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        // Trade ETH -> Any\n', '        if (etherERC20 == src) {\n', '            destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', '            // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '            assert(destAmount >= minDestAmount);\n', '\n', '            // Send back token to sender\n', '            // Some ERC20 Smart contract not return Bool, so we can&#39;t check here\n', '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        \n', '        // Trade Any -> ETH\n', '        } else if (etherERC20 == dest) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '\n', '            destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', '            // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '            assert(destAmount >= minDestAmount);\n', '\n', '            // Send back ether to sender\n', '            // TODO: Check if amount send correctly, because solidty will not raise error when not enough amount\n', '            msg.sender.send(destAmount);\n', '\n', '        // Trade Any -> Any\n', '        } else {\n', '\n', '        }\n', '\n', '        Trade( src, srcAmount, dest, destAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 50 OMG -> ETH -> EOS\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> EOS\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function tradeRoutes(ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount, address[] _tradingPaths) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        uint256 pathSrcAmount = srcAmount;\n', '        for (uint i=0; i < _tradingPaths.length; i+=3) {\n', '            uint256 tradingProxyIndex =         uint256(_tradingPaths[i]);\n', '            ERC20 pathSrc =                     ERC20(_tradingPaths[i+1]);\n', '            ERC20 pathDest =                    ERC20(_tradingPaths[i+2]);\n', '\n', '            destAmount = _trade(tradingProxyIndex, pathSrc, pathSrcAmount, pathDest, 1);\n', '            pathSrcAmount = destAmount;\n', '        }\n', '\n', '        // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '        assert(destAmount >= minDestAmount);\n', '\n', '        // Trade Any -> ETH\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // TODO: Check if amount send correctly, because solidty will not raise error when not enough amount\n', '            msg.sender.send(destAmount);\n', '        \n', '        // Trade Any -> Token\n', '        } else {\n', '            // Send back token to sender\n', '            // Some ERC20 Smart contract not return Bool, so we can&#39;t check here\n', '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        Trade( src, srcAmount, dest, destAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param tradingProxyIndex index of trading proxy\n', '    /// @param src Src token\n', '    /// @param dest Destination token\n', '    /// @param srcAmount Srouce amount\n', '    /* solhint-disable code-complexity */\n', '    function rate(uint256 tradingProxyIndex, ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint, uint) {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        return tradingProxy.rate(src, dest, srcAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Function for adding new trading proxy\n', '    * @param _proxyAddress The address of trading proxy.\n', '    * @return index of this proxy.\n', '    */\n', '    function addTradingProxy(\n', '        KULAPTradingProxy _proxyAddress\n', '    ) public onlyOwner returns (uint256) {\n', '\n', '        tradingProxies.push( _proxyAddress );\n', '\n', '        return tradingProxies.length;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) pure internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) pure internal returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) pure internal returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', "    function transfer(address _to, uint _value) public; // Some ERC20 doesn't have return\n", "    function transferFrom(address _from, address _to, uint _value) public; // Some ERC20 doesn't have return\n", "    function approve(address _spender, uint _value) public; // Some ERC20 doesn't have return\n", '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    function decimals() public view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract KyberNetworkContract {\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Src token\n', '    /// @param srcAmount amount of src tokens\n', '    /// @param dest   Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n', '    /// @param walletId is the wallet ID to send part of the fees\n', '    /// @return amount of actual dest tokens\n', '    function trade(\n', '        ERC20 src,\n', '        uint srcAmount,\n', '        ERC20 dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '    \n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param src Src token\n', '    /// @param dest Destination token\n', '    /* solhint-disable code-complexity */\n', '    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint);\n', '}\n', '\n', 'interface KULAPTradingProxy {\n', '    // Trade event\n', '    event Trade( ERC20 src, uint srcAmount, ERC20 dest, uint destAmount);\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Src token\n', '    /// @param srcAmount amount of src tokens\n', '    /// @param dest   Destination token\n', '    /// @return amount of actual dest tokens\n', '    function trade(\n', '        ERC20 src,\n', '        uint srcAmount,\n', '        ERC20 dest\n', '    )\n', '        public\n', '        payable\n', '        returns(uint);\n', '    \n', '    function rate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint);\n', '}\n', '\n', 'contract Dex is Ownable {\n', '    event Trade( ERC20 src, uint srcAmount, ERC20 dest, uint destAmount);\n', '\n', '    using SafeMath for uint256;\n', '    ERC20 public etherERC20 = ERC20(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    address public dexWallet = 0x7ff0F1919424F0D2B6A109E3139ae0f1d836D468; // To receive fee of the DEX network\n', '\n', '    // list of trading proxies\n', '    KULAPTradingProxy[] public tradingProxies;\n', '\n', '    function _tradeEtherToToken(uint256 tradingProxyIndex, uint256 srcAmount, ERC20 dest) private returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Trade to proxy\n', '        uint256 destAmount = tradingProxy.trade.value(srcAmount)(\n', '            etherERC20,\n', '            srcAmount, \n', '            dest\n', '        );\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Receive ETH in case of trade Token -> ETH, will get ETH back from trading proxy\n', '    function () payable {\n', '\n', '    }\n', '\n', '    function _tradeTokenToEther(uint256 tradingProxyIndex, ERC20 src, uint256 amount) private returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, amount);\n', '\n', '        // Trande with kyber\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            amount, \n', '            etherERC20);\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function _trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) private returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        // Trade ETH -> Any\n', '        if (etherERC20 == src) {\n', '            destAmount = _tradeEtherToToken(tradingProxyIndex, srcAmount, dest);\n', '        \n', '        // Trade Any -> ETH\n', '        } else if (etherERC20 == dest) {\n', '            destAmount = _tradeTokenToEther(tradingProxyIndex, src, srcAmount);\n', '\n', '        // Trade Any -> Any\n', '        } else {\n', '\n', '        }\n', '\n', "        // Throw exception if destination amount doesn't meet user requirement.\n", '        assert(destAmount >= minDestAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        // Trade ETH -> Any\n', '        if (etherERC20 == src) {\n', '            destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', "            // Throw exception if destination amount doesn't meet user requirement.\n", '            assert(destAmount >= minDestAmount);\n', '\n', '            // Send back token to sender\n', "            // Some ERC20 Smart contract not return Bool, so we can't check here\n", '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        \n', '        // Trade Any -> ETH\n', '        } else if (etherERC20 == dest) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '\n', '            destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', "            // Throw exception if destination amount doesn't meet user requirement.\n", '            assert(destAmount >= minDestAmount);\n', '\n', '            // Send back ether to sender\n', '            // TODO: Check if amount send correctly, because solidty will not raise error when not enough amount\n', '            msg.sender.send(destAmount);\n', '\n', '        // Trade Any -> Any\n', '        } else {\n', '\n', '        }\n', '\n', '        Trade( src, srcAmount, dest, destAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 50 OMG -> ETH -> EOS\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> EOS\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function tradeRoutes(ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount, address[] _tradingPaths) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        uint256 pathSrcAmount = srcAmount;\n', '        for (uint i=0; i < _tradingPaths.length; i+=3) {\n', '            uint256 tradingProxyIndex =         uint256(_tradingPaths[i]);\n', '            ERC20 pathSrc =                     ERC20(_tradingPaths[i+1]);\n', '            ERC20 pathDest =                    ERC20(_tradingPaths[i+2]);\n', '\n', '            destAmount = _trade(tradingProxyIndex, pathSrc, pathSrcAmount, pathDest, 1);\n', '            pathSrcAmount = destAmount;\n', '        }\n', '\n', "        // Throw exception if destination amount doesn't meet user requirement.\n", '        assert(destAmount >= minDestAmount);\n', '\n', '        // Trade Any -> ETH\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // TODO: Check if amount send correctly, because solidty will not raise error when not enough amount\n', '            msg.sender.send(destAmount);\n', '        \n', '        // Trade Any -> Token\n', '        } else {\n', '            // Send back token to sender\n', "            // Some ERC20 Smart contract not return Bool, so we can't check here\n", '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        Trade( src, srcAmount, dest, destAmount);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param tradingProxyIndex index of trading proxy\n', '    /// @param src Src token\n', '    /// @param dest Destination token\n', '    /// @param srcAmount Srouce amount\n', '    /* solhint-disable code-complexity */\n', '    function rate(uint256 tradingProxyIndex, ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint, uint) {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        return tradingProxy.rate(src, dest, srcAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Function for adding new trading proxy\n', '    * @param _proxyAddress The address of trading proxy.\n', '    * @return index of this proxy.\n', '    */\n', '    function addTradingProxy(\n', '        KULAPTradingProxy _proxyAddress\n', '    ) public onlyOwner returns (uint256) {\n', '\n', '        tradingProxies.push( _proxyAddress );\n', '\n', '        return tradingProxies.length;\n', '    }\n', '}']
