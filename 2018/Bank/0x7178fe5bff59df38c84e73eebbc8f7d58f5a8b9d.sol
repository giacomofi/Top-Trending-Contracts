['pragma solidity ^0.4.25;\n', '\n', '// donate: 0x95CC9E2FE2E2de48A02CF6C09439889d72D5ea78\n', '\n', 'contract GorgonaKiller {\n', '    // адрес горгоны\n', '    address public GorgonaAddr; \n', '    \n', '    // минимальный депозит\n', '    uint constant public MIN_DEP = 0.01 ether; \n', '    \n', '    // максимальное число транзакций при выплате дивидендов\n', '    uint constant public TRANSACTION_LIMIT = 100;\n', '    \n', '    // баланс дивидендов\n', '    uint public dividends;\n', '    \n', '    // id последнего инвестора, которому прошла оплата\n', '    uint public last_payed_id;\n', '    \n', '    // общая сумма депозитов от инвесторов\n', '    uint public deposits; \n', '    \n', '    // адреса инвесторов\n', '    address[] addresses;\n', '\n', '    // мапинг адрес инвестора - структура инвестора\n', '    mapping(address => Investor) public members;\n', '    \n', '    // id адреса в investors, deposit - сумма депозитов\n', '    struct Investor {\n', '        uint id;\n', '        uint deposit;\n', '    }\n', '    \n', '    constructor() public {\n', '        GorgonaAddr = 0x020e13faF0955eFeF0aC9cD4d2C64C513ffCBdec; \n', '    }\n', '\n', '    // обработка поступлений\n', '    function () external payable {\n', '\n', '        // если пришло с горгоны выходим\n', '        if (msg.sender == GorgonaAddr) {\n', '            return;\n', '        }\n', '        \n', '        // если баланс без текущего поступления > 0 пишем в дивиденды\n', '        if ( address(this).balance - msg.value > 0 ) {\n', '            dividends = address(this).balance - msg.value;\n', '        }\n', '        \n', '        // выплачиваем дивиденды\n', '        if ( dividends > 0 ) {\n', '            payDividends();\n', '        }\n', '        \n', '        // инвестируем текущее поступление\n', '        if (msg.value >= MIN_DEP) {\n', '            Investor storage investor = members[msg.sender];\n', '\n', '            // добавляем инвестора, если еще нет\n', '            if (investor.id == 0) {\n', '                investor.id = addresses.push(msg.sender);\n', '            }\n', '\n', '            // пополняем депозит инвестора и общий депозит\n', '            investor.deposit += msg.value;\n', '            deposits += msg.value;\n', '    \n', '            // отправляем в горгону\n', '            payToGorgona();\n', '\n', '        }\n', '        \n', '    }\n', '\n', '    // отправляем текущее поступление в горгону\n', '    function payToGorgona() private {\n', '        if ( GorgonaAddr.call.value( msg.value )() ) return; \n', '    }\n', '\n', '    // выплата дивидендов\n', '    function payDividends() private {\n', '        address[] memory _addresses = addresses;\n', '        \n', '        uint _dividends = dividends;\n', '\n', '        if ( _dividends > 0) {\n', '            uint num_payed = 0;\n', '            \n', '            for (uint i = last_payed_id; i < _addresses.length; i++) {\n', '                \n', '                // считаем для каждого инвестора долю дивидендов\n', '                uint amount = _dividends * members[ _addresses[i] ].deposit / deposits;\n', '                \n', '                // отправляем дивиденды\n', '                if ( _addresses[i].send( amount ) ) {\n', '                    last_payed_id = i+1;\n', '                    num_payed += 1;\n', '                }\n', '                \n', '                // если достигли лимита выплат выходим из цикла\n', '                if ( num_payed == TRANSACTION_LIMIT ) break;\n', '                \n', '            }\n', '            \n', '            // обнуляем id последней выплаты, если выплатили всем\n', '            if ( last_payed_id >= _addresses.length) {\n', '                last_payed_id = 0;\n', '            }\n', '            \n', '            dividends = 0;\n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    // смотрим баланс на контракте\n', '    function getBalance() public view returns(uint) {\n', '        return address(this).balance / 10 ** 18;\n', '    }\n', '\n', '    // смотрим число инвесторов\n', '    function getInvestorsCount() public view returns(uint) {\n', '        return addresses.length;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '// donate: 0x95CC9E2FE2E2de48A02CF6C09439889d72D5ea78\n', '\n', 'contract GorgonaKiller {\n', '    // адрес горгоны\n', '    address public GorgonaAddr; \n', '    \n', '    // минимальный депозит\n', '    uint constant public MIN_DEP = 0.01 ether; \n', '    \n', '    // максимальное число транзакций при выплате дивидендов\n', '    uint constant public TRANSACTION_LIMIT = 100;\n', '    \n', '    // баланс дивидендов\n', '    uint public dividends;\n', '    \n', '    // id последнего инвестора, которому прошла оплата\n', '    uint public last_payed_id;\n', '    \n', '    // общая сумма депозитов от инвесторов\n', '    uint public deposits; \n', '    \n', '    // адреса инвесторов\n', '    address[] addresses;\n', '\n', '    // мапинг адрес инвестора - структура инвестора\n', '    mapping(address => Investor) public members;\n', '    \n', '    // id адреса в investors, deposit - сумма депозитов\n', '    struct Investor {\n', '        uint id;\n', '        uint deposit;\n', '    }\n', '    \n', '    constructor() public {\n', '        GorgonaAddr = 0x020e13faF0955eFeF0aC9cD4d2C64C513ffCBdec; \n', '    }\n', '\n', '    // обработка поступлений\n', '    function () external payable {\n', '\n', '        // если пришло с горгоны выходим\n', '        if (msg.sender == GorgonaAddr) {\n', '            return;\n', '        }\n', '        \n', '        // если баланс без текущего поступления > 0 пишем в дивиденды\n', '        if ( address(this).balance - msg.value > 0 ) {\n', '            dividends = address(this).balance - msg.value;\n', '        }\n', '        \n', '        // выплачиваем дивиденды\n', '        if ( dividends > 0 ) {\n', '            payDividends();\n', '        }\n', '        \n', '        // инвестируем текущее поступление\n', '        if (msg.value >= MIN_DEP) {\n', '            Investor storage investor = members[msg.sender];\n', '\n', '            // добавляем инвестора, если еще нет\n', '            if (investor.id == 0) {\n', '                investor.id = addresses.push(msg.sender);\n', '            }\n', '\n', '            // пополняем депозит инвестора и общий депозит\n', '            investor.deposit += msg.value;\n', '            deposits += msg.value;\n', '    \n', '            // отправляем в горгону\n', '            payToGorgona();\n', '\n', '        }\n', '        \n', '    }\n', '\n', '    // отправляем текущее поступление в горгону\n', '    function payToGorgona() private {\n', '        if ( GorgonaAddr.call.value( msg.value )() ) return; \n', '    }\n', '\n', '    // выплата дивидендов\n', '    function payDividends() private {\n', '        address[] memory _addresses = addresses;\n', '        \n', '        uint _dividends = dividends;\n', '\n', '        if ( _dividends > 0) {\n', '            uint num_payed = 0;\n', '            \n', '            for (uint i = last_payed_id; i < _addresses.length; i++) {\n', '                \n', '                // считаем для каждого инвестора долю дивидендов\n', '                uint amount = _dividends * members[ _addresses[i] ].deposit / deposits;\n', '                \n', '                // отправляем дивиденды\n', '                if ( _addresses[i].send( amount ) ) {\n', '                    last_payed_id = i+1;\n', '                    num_payed += 1;\n', '                }\n', '                \n', '                // если достигли лимита выплат выходим из цикла\n', '                if ( num_payed == TRANSACTION_LIMIT ) break;\n', '                \n', '            }\n', '            \n', '            // обнуляем id последней выплаты, если выплатили всем\n', '            if ( last_payed_id >= _addresses.length) {\n', '                last_payed_id = 0;\n', '            }\n', '            \n', '            dividends = 0;\n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    // смотрим баланс на контракте\n', '    function getBalance() public view returns(uint) {\n', '        return address(this).balance / 10 ** 18;\n', '    }\n', '\n', '    // смотрим число инвесторов\n', '    function getInvestorsCount() public view returns(uint) {\n', '        return addresses.length;\n', '    }\n', '\n', '}']
