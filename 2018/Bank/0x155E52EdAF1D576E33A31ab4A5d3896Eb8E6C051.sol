['pragma solidity ^0.4.18;\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function decimals() public view returns(uint digits);\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Burn(address indexed _from, uint256 _value);\n', '\n', '}\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '    /// `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address newOwner=0x0;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    ///change the owner\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// accept the ownership\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract Controlled is Ownable{\n', '\n', '    function Controlled() public {\n', '        exclude[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        if(msg.sender != owner){\n', '            require(admins[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '\n', '    mapping(address => bool) admins;\n', '\n', '    // Flag that determines if the token is transferable or not.\n', '    bool public transferEnabled = false;\n', '\n', '    // frozen account\n', '    mapping(address => bool) exclude;\n', '    mapping(address => bool) locked;\n', '    mapping(address => bool) public frozenAccount;\n', '\n', '    // The nonce for avoid transfer replay attacks\n', '    mapping(address => uint256) nonces;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '\n', '    function setAdmin(address _addr, bool isAdmin) public onlyOwner returns (bool success){\n', '        admins[_addr]=isAdmin;\n', '        return true;\n', '    }\n', '\n', '\n', '    function enableTransfer(bool _enable) public onlyOwner{\n', '        transferEnabled=_enable;\n', '    }\n', '\n', '\n', '    function setExclude(address _addr, bool isExclude) public onlyOwner returns (bool success){\n', '        exclude[_addr]=isExclude;\n', '        return true;\n', '    }\n', '\n', '    function setLock(address _addr, bool isLock) public onlyAdmin returns (bool success){\n', '        locked[_addr]=isLock;\n', '        return true;\n', '    }\n', '\n', '\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /*\n', '     * Get the nonce\n', '     * @param _addr\n', '     */\n', '    function getNonce(address _addr) public constant returns (uint256){\n', '        return nonces[_addr];\n', '    }\n', '\n', '    modifier transferAllowed(address _addr) {\n', '        if (!exclude[_addr]) {\n', '            assert(transferEnabled);\n', '            assert(!locked[_addr]);\n', '            assert(!frozenAccount[_addr]);\n', '        }\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract FeeControlled is Controlled{\n', '\n', '    // receive transfer fee account\n', '    address feeReceAccount = 0x0;\n', '\n', '    // transfer rate  default value,  rate/10000\n', '    uint16 defaultTransferRate = 0;\n', '     // transfer fee min & max\n', '    uint256 transferFeeMin = 0;\n', '    uint256 transferFeeMax = 10 ** 10;\n', '\n', '    // transfer rate, rate/10000\n', '    mapping(address => int16) transferRates;\n', '    // reverse transfer rate when receive from user\n', '    mapping(address => int16) transferReverseRates;\n', '\n', '\n', '    function setFeeReceAccount(address _addr) public onlyAdmin\n', '    returns (bool success){\n', '        require(_addr != address(0) && feeReceAccount != _addr);\n', '        feeReceAccount = _addr;\n', '        return true;\n', '    }\n', '\n', '    function setFeeParams(uint16 _transferRate, uint256 _transferFeeMin, uint256 _transferFeeMax) public onlyAdmin\n', '    returns (bool success){\n', '        require(_transferRate>=0  && _transferRate<10000);\n', '        require(_transferFeeMin>=0 && _transferFeeMin<transferFeeMax);\n', '        transferFeeMin = _transferFeeMin;\n', '        transferFeeMax = _transferFeeMax;\n', '        defaultTransferRate = _transferRate;\n', '        if(feeReceAccount==0x0){\n', '            feeReceAccount = owner;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function setTransferRate(address[] _addrs, int16 _transferRate) public onlyAdmin\n', '    returns (bool success){\n', '        require((_transferRate>=0  || _transferRate==-1)&& _transferRate<10000);\n', '        for(uint256 i = 0; i < _addrs.length ; i++){\n', '            address _addr = _addrs[i];\n', '            transferRates[_addr] = _transferRate;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function removeTransferRate(address[] _addrs) public onlyAdmin\n', '    returns (bool success){\n', '        for(uint256 i = 0; i < _addrs.length ; i++){\n', '            address _addr = _addrs[i];\n', '            delete transferRates[_addr];\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function setReverseRate(address[] _addrs, int16 _reverseRate) public onlyAdmin\n', '    returns (bool success){\n', '        require(_reverseRate>0 && _reverseRate<10000);\n', '        for(uint256 i = 0; i < _addrs.length ; i++){\n', '            address _addr = _addrs[i];\n', '            transferReverseRates[_addr] = _reverseRate;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function removeReverseRate(address[] _addrs) public onlyAdmin returns (bool success){\n', '        for(uint256 i = 0; i < _addrs.length ; i++){\n', '            address _addr = _addrs[i];\n', '            delete transferReverseRates[_addr];\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getTransferRate(address _addr) public constant returns(uint16 transferRate){\n', '        if(_addr==owner || exclude[_addr] || transferRates[_addr]==-1){\n', '            return 0;\n', '        }else if(transferRates[_addr]==0){\n', '            return defaultTransferRate;\n', '        }else{\n', '            return uint16(transferRates[_addr]);\n', '        }\n', '    }\n', '\n', '    function getTransferFee(address _addr, uint256 _value) public constant returns(uint256 transferFee){\n', '        uint16 transferRate = getTransferRate(_addr);\n', '        transferFee = 0x0;\n', '        if(transferRate>0){\n', '           transferFee =  _value * transferRate / 10000;\n', '        }\n', '        if(transferFee<transferFeeMin){\n', '            transferFee = transferFeeMin;\n', '        }\n', '        if(transferFee>transferFeeMax){\n', '            transferFee = transferFeeMax;\n', '        }\n', '        return transferFee;\n', '    }\n', '\n', '    function getReverseRate(address _addr) public constant returns(uint16 reverseRate){\n', '        return uint16(transferReverseRates[_addr]);\n', '    }\n', '\n', '    function getReverseFee(address _addr, uint256 _value) public constant returns(uint256 reverseFee){\n', '        uint16 reverseRate = uint16(transferReverseRates[_addr]);\n', '        reverseFee = 0x0;\n', '        if(reverseRate>0){\n', '            reverseFee = _value * reverseRate / 10000;\n', '        }\n', '        if(reverseFee<transferFeeMin){\n', '            reverseFee = transferFeeMin;\n', '        }\n', '        if(reverseFee>transferFeeMax){\n', '            reverseFee = transferFeeMax;\n', '        }\n', '        return reverseFee;\n', '    }\n', '\n', '}\n', '\n', 'contract TokenERC20 is ERC20, Controlled {\n', '\n', '   // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    string public version = &#39;v1.0&#39;;\n', '\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint256 public totalSupply;\n', '\n', '    uint256 public allocateEndTime;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    \n', '\n', '    function totalSupply() public view returns(uint){\n', '        return totalSupply;\n', '    }\n', '\n', '    function decimals() public view returns(uint){\n', '        return decimals;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns(uint){\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) \n', '    public view returns (uint remaining){\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    \n', '\n', '    // Allocate tokens to the users\n', '    // @param _owners The owners list of the token\n', '    // @param _values The value list of the token\n', '    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\n', '        require(allocateEndTime > now);\n', '        require(_owners.length == _values.length);\n', '        for(uint256 i = 0; i < _owners.length ; i++){\n', '            address to = _owners[i];\n', '            uint256 value = _values[i];\n', '            require(totalSupply + value > totalSupply && balances[to] + value > balances[to]) ;\n', '            totalSupply += value;\n', '            balances[to] += value;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) transferAllowed(_from) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[_from] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        // Subtract from the sender\n', '        balances[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '    returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '    public\n', '    returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '        balances[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowed[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /*\n', '    * Proxy transfer  token. When some users of the ethereum account has no ether,\n', '    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\n', '    * @param _from\n', '    * @param _to\n', '    * @param _value\n', '    * @param feeProxy\n', '    * @param _v\n', '    * @param _r\n', '    * @param _s\n', '    */\n', '    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n', '        require(_value + _feeProxy >= _value);\n', '        require(balances[_from] >=_value  + _feeProxy);\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\n', '        require(_from == ecrecover(h,_v,_r,_s));\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(balances[msg.sender] + _feeProxy > balances[msg.sender]);\n', '        balances[_from] -= (_value  + _feeProxy);\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        if(_feeProxy>0){\n', '            balances[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract StableToken is TokenERC20, FeeControlled {\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return _transferWithRate(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        return _transferWithRate(_from, _to, _value);\n', '    }\n', '\n', '     function _transferWithRate(address _from, address _to, uint256 _value)  transferAllowed(_from) internal returns (bool success) {\n', '        // check transfer rate and transfer fee to owner\n', '        require(balances[_from] >= _value);\n', '        uint256 transferFee = getTransferFee(_from, _value);\n', '        require(balances[_from] >= _value + transferFee);\n', '        if(msg.sender!=_from){\n', '            require(allowed[_from][msg.sender] >= _value + transferFee);\n', '        }\n', '        require(balances[_to] + _value > balances[_to]);\n', '        if(transferFee>0){\n', '            require(balances[feeReceAccount] + transferFee > balances[feeReceAccount]);\n', '        }\n', '\n', '        balances[_from] -= (_value + transferFee);\n', '        if(msg.sender!=_from){\n', '            allowed[_from][msg.sender] -= (_value + transferFee);\n', '        }\n', '\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\n', '        if(transferFee>0){\n', '            balances[feeReceAccount] += transferFee;\n', '            Transfer(_from, feeReceAccount, transferFee);\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '     /*\n', '     * Proxy transfer token with reverse transfer fee. When some users of the ethereum account has no ether,\n', '     * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\n', '     * @param _from\n', '     * @param _to, must be reverse address\n', '     * @param _value\n', '     * @param fee\n', '     * @param _v\n', '     * @param _r\n', '     * @param _s\n', '     */\n', '    function transferReverseProxy(address _from, address _to, uint256 _value,uint256 _feeProxy,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n', '        require(_feeProxy>=0);\n', '        require(balances[_from] >= _value + _feeProxy);\n', '        require(getReverseRate(_to)>0);\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from,_to,_value, _feeProxy, nonce);\n', '        require(_from == ecrecover(h,_v,_r,_s));\n', '\n', '        uint256 transferReverseFee = getReverseFee(_to, _value);\n', '        require(transferReverseFee>0);\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(balances[feeReceAccount] + transferReverseFee > balances[feeReceAccount]);\n', '        require(balances[msg.sender] + _feeProxy >= balances[msg.sender]);\n', '\n', '        balances[_from] -= (_value + _feeProxy);\n', '        balances[_to] += (_value - transferReverseFee);\n', '        balances[feeReceAccount] += transferReverseFee;\n', '        Transfer(_from, _to, _value);\n', '        Transfer(_to, feeReceAccount, transferReverseFee);\n', '        if(_feeProxy>0){\n', '            balances[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * Proxy transfer  token. When some users of the ethereum account has no ether,\n', '    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\n', '    * @param _from\n', '    * @param _to\n', '    * @param _value\n', '    * @param feeProxy\n', '    * @param _v\n', '    * @param _r\n', '    * @param _s\n', '    */\n', '    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n', '        uint256 transferFee = getTransferFee(_from, _value);\n', '        require(_value + transferFee + _feeProxy >= _value);\n', '        require(balances[_from] >=_value + transferFee + _feeProxy);\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\n', '        require(_from == ecrecover(h,_v,_r,_s));\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(balances[msg.sender] + _feeProxy > balances[msg.sender]);\n', '        balances[_from] -= (_value + transferFee + _feeProxy);\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        if(_feeProxy>0){\n', '            balances[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '        if(transferFee>0){\n', '            balances[feeReceAccount] += transferFee;\n', '            Transfer(_from, feeReceAccount, transferFee);\n', '        }\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '\n', '   /*\n', '    * Wrapper function:  transferProxy + transferReverseProxy\n', '    * address[] _addrs => [_from, _origin, _to]\n', '    * uint256[] _values => [_value, _feeProxy]\n', '    * token flows\n', '    * _from->_origin: _value\n', '    * _from->sender: _feeProxy\n', '    * _origin->_to: _value\n', '    * _to->feeAccount: transferFee\n', '    * _from sign:\n', '    * (_v[0],_r[0],_s[0]) = sign(_from, _origin, _value, _feeProxy, nonces[_from])\n', '    * _origin sign:\n', '    * (_v[1],_r[1],_s[1]) = sign(_origin, _to, _value)\n', '    */\n', '    function transferReverseProxyThirdParty(address[] _addrs, uint256[] _values,\n', '        uint8[] _v, bytes32[] _r, bytes32[] _s)\n', '        public transferAllowed(_addrs[0]) returns (bool){\n', '        address _from = _addrs[0];\n', '        address _origin = _addrs[1];\n', '        address _to = _addrs[2];\n', '        uint256 _value = _values[0];\n', '        uint256 _feeProxy = _values[1];\n', '\n', '        require(_feeProxy>=0);\n', '        require(balances[_from] >= (_value + _feeProxy));\n', '        require(getReverseRate(_to)>0);\n', '        uint256 transferReverseFee = getReverseFee(_to, _value);\n', '        require(transferReverseFee>0);\n', '\n', '        // check sign _from => _origin\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from, _origin, _value, _feeProxy, nonce);\n', '        require(_from == ecrecover(h,_v[0],_r[0],_s[0]));\n', '         // check sign _origin => _to\n', '        bytes32 h1 = keccak256(_origin, _to, _value);\n', '        require(_origin == ecrecover(h1,_v[1],_r[1],_s[1]));\n', '\n', '\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(balances[feeReceAccount] + transferReverseFee > balances[feeReceAccount]);\n', '        require(balances[msg.sender] + _feeProxy >= balances[msg.sender]);\n', '\n', '        balances[_from] -= _value + _feeProxy;\n', '        balances[_to] += (_value - transferReverseFee);\n', '        balances[feeReceAccount] += transferReverseFee;\n', '       \n', '        Transfer(_from, _origin, _value);\n', '        Transfer(_origin, _to, _value);\n', '        Transfer(_to, feeReceAccount, transferReverseFee);\n', '        \n', '        if(_feeProxy>0){\n', '            balances[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '       \n', '\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Proxy approve that some one can authorize the agent for broadcast transaction\n', '     * which call approve method, and agents may charge agency fees\n', '     * @param _from The address which should tranfer TOKEN to others\n', '     * @param _spender The spender who allowed by _from\n', '     * @param _value The value that should be tranfered.\n', '     * @param _v\n', '     * @param _r\n', '     * @param _s\n', '     */\n', '    function approveProxy(address _from, address _spender, uint256 _value,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 hash = keccak256(_from,_spender,_value,nonce);\n', '        require(_from == ecrecover(hash,_v,_r,_s));\n', '        allowed[_from][_spender] = _value;\n', '        Approval(_from, _spender, _value);\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract HanYinToken is StableToken{\n', '    \n', '    function HanYinToken() public {\n', '        name = "HanYin stable Token";\n', '        decimals = 6;\n', '        symbol = "HYT";\n', '        version = &#39;v1.0&#39;;\n', '        \n', '        allocateEndTime = now + 1 days;\n', '\n', '        setFeeParams(100, 0, 1000000000000);\n', '    }\n', '}']