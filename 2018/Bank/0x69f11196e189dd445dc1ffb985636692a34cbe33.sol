['pragma solidity ^0.4.21;\n', '\n', 'interface BancorConverter {\n', '    // _path is actually IERC20Token[] type\n', '    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\n', '}\n', '\n', 'contract BancorHandler {\n', '    // State variables\n', '    uint256 public MAX_UINT = 2**256 -1;\n', '    BancorConverter public exchange;\n', '    // address public bancorQuickConvertAddress = address(0xcf1cc6ed5b653def7417e3fa93992c3ffe49139b);\n', '\n', '    // Constructor\n', '    function BancorHandler(address _exchange) public {\n', '        exchange = BancorConverter(_exchange);\n', '    }\n', '\n', '    // Public functions\n', '    function getAvailableAmount(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external returns (uint256) {\n', '        // Just return a massive number, as there&#39;s nothing else we can do here\n', '        return MAX_UINT;\n', '    }\n', '\n', '    function performBuy(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint256 amountToFill, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external payable returns (uint256) {\n', '        return trade(orderAddresses, orderValues);\n', '    }\n', '\n', '    function performSell(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint256 amountToFill, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external returns (uint256) {\n', '        return trade(orderAddresses, orderValues);\n', '    }\n', '\n', '    function trade(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '    ) internal returns (uint256) {\n', '        // Find the length of the conversion path\n', '        uint256 len = 0;\n', '        for(; len < orderAddresses.length; len++) {\n', '            if(orderAddresses[len] == 0) {\n', '                break;\n', '            }\n', '        }\n', '        // Create an array of that length\n', '        address[] memory conversionPath = new address[](len);\n', '\n', '        // Move the contents from orderAddresses to conversionPath\n', '        for(uint256 i = 0; i < len; i++) {\n', '            conversionPath[i] = orderAddresses[i];\n', '        }\n', '\n', '        return exchange.quickConvert.value(msg.value)(conversionPath, orderValues[0], orderValues[1]);\n', '    }\n', '\n', '    function() public payable {\n', '        // require(msg.sender == bancorQuickConvertAddress);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface BancorConverter {\n', '    // _path is actually IERC20Token[] type\n', '    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\n', '}\n', '\n', 'contract BancorHandler {\n', '    // State variables\n', '    uint256 public MAX_UINT = 2**256 -1;\n', '    BancorConverter public exchange;\n', '    // address public bancorQuickConvertAddress = address(0xcf1cc6ed5b653def7417e3fa93992c3ffe49139b);\n', '\n', '    // Constructor\n', '    function BancorHandler(address _exchange) public {\n', '        exchange = BancorConverter(_exchange);\n', '    }\n', '\n', '    // Public functions\n', '    function getAvailableAmount(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external returns (uint256) {\n', "        // Just return a massive number, as there's nothing else we can do here\n", '        return MAX_UINT;\n', '    }\n', '\n', '    function performBuy(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint256 amountToFill, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external payable returns (uint256) {\n', '        return trade(orderAddresses, orderValues);\n', '    }\n', '\n', '    function performSell(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues, // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '        uint256 exchangeFee, // ignore\n', '        uint256 amountToFill, // ignore\n', '        uint8 v, // ignore\n', '        bytes32 r, // ignore\n', '        bytes32 s // ignore\n', '    ) external returns (uint256) {\n', '        return trade(orderAddresses, orderValues);\n', '    }\n', '\n', '    function trade(\n', '        address[21] orderAddresses, // conversion path (max length 21)\n', '        uint256[6] orderValues // [amountToGive, minReturn, EMPTY, EMPTY, EMPTY, EMPTY]\n', '    ) internal returns (uint256) {\n', '        // Find the length of the conversion path\n', '        uint256 len = 0;\n', '        for(; len < orderAddresses.length; len++) {\n', '            if(orderAddresses[len] == 0) {\n', '                break;\n', '            }\n', '        }\n', '        // Create an array of that length\n', '        address[] memory conversionPath = new address[](len);\n', '\n', '        // Move the contents from orderAddresses to conversionPath\n', '        for(uint256 i = 0; i < len; i++) {\n', '            conversionPath[i] = orderAddresses[i];\n', '        }\n', '\n', '        return exchange.quickConvert.value(msg.value)(conversionPath, orderValues[0], orderValues[1]);\n', '    }\n', '\n', '    function() public payable {\n', '        // require(msg.sender == bancorQuickConvertAddress);\n', '    }\n', '}']
