['pragma solidity ^0.4.24;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '}\n', '\n', '/// @title localethereum.com\n', '/// @author localethereum.com\n', 'contract LocalEthereumEscrows {\n', '    /***********************\n', '    +   Global settings   +\n', '    ***********************/\n', '\n', '    // Address of the arbitrator (currently always localethereum staff)\n', '    address public arbitrator;\n', '    // Address of the owner (who can withdraw collected fees)\n', '    address public owner;\n', '    // Address of the relayer (who is allowed to forward signed instructions from parties)\n', '    address public relayer;\n', '    uint32 public requestCancellationMinimumTime;\n', '    // Cumulative balance of collected fees\n', '    uint256 public feesAvailableForWithdraw;\n', '\n', '    /***********************\n', '    +  Instruction types  +\n', '    ***********************/\n', '\n', '    // Called when the buyer marks payment as sent. Locks funds in escrow\n', '    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;\n', '    // Buyer cancelling\n', '    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;\n', '    // Seller cancelling\n', '    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;\n', '    // Seller requesting to cancel. Begins a window for buyer to object\n', '    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;\n', '    // Seller releasing funds to the buyer\n', '    uint8 constant INSTRUCTION_RELEASE = 0x05;\n', '    // Either party permitting the arbitrator to resolve a dispute\n', '    uint8 constant INSTRUCTION_RESOLVE = 0x06;\n', '\n', '    /***********************\n', '    +       Events        +\n', '    ***********************/\n', '\n', '    event Created(bytes32 indexed _tradeHash);\n', '    event SellerCancelDisabled(bytes32 indexed _tradeHash);\n', '    event SellerRequestedCancel(bytes32 indexed _tradeHash);\n', '    event CancelledBySeller(bytes32 indexed _tradeHash);\n', '    event CancelledByBuyer(bytes32 indexed _tradeHash);\n', '    event Released(bytes32 indexed _tradeHash);\n', '    event DisputeResolved(bytes32 indexed _tradeHash);\n', '\n', '    struct Escrow {\n', '        // So we know the escrow exists\n', '        bool exists;\n', '        // This is the timestamp in whic hthe seller can cancel the escrow after.\n', '        // It has two special values:\n', '        // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)\n', '        // 1 : The seller can only request to cancel, which will change this value to a timestamp.\n', '        //     This option is avaialble for complex trade terms such as cash-in-person where a\n', '        //     payment window is inappropriate\n', '        uint32 sellerCanCancelAfter;\n', '        // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner\n', '        // in the way of fees once the escrow has completed\n', '        uint128 totalGasFeesSpentByRelayer;\n', '    }\n', '\n', '    // Mapping of active trades. The key here is a hash of the trade proprties\n', '    mapping (bytes32 => Escrow) public escrows;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Must be owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyArbitrator() {\n', '        require(msg.sender == arbitrator, "Must be arbitrator");\n', '        _;\n', '    }\n', '\n', '    /// @notice Initialize the contract.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        arbitrator = msg.sender;\n', '        relayer = msg.sender;\n', '        requestCancellationMinimumTime = 2 hours;\n', '    }\n', '\n', '    /// @notice Create and fund a new escrow.\n', '    /// @param _tradeID The unique ID of the trade, generated by localethereum.com\n', '    /// @param _seller The selling party\n', '    /// @param _buyer The buying party\n', '    /// @param _value The amount of the escrow, exclusive of the fee\n', '    /// @param _fee Localethereum&#39;s commission in 1/10000ths\n', '    /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after\n', '    /// @param _expiry This transaction must be created before this time\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    function createEscrow(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint32 _paymentWindowInSeconds,\n', '        uint32 _expiry,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) payable external {\n', '        // The trade hash is created by tightly-concatenating and hashing properties of the trade.\n', '        // This hash becomes the identifier of the escrow, and hence all these variables must be\n', '        // supplied on future contract calls\n', '        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\n', '        // Require that trade does not already exist\n', '        require(!escrows[_tradeHash].exists, "Trade already exists");\n', '        // A signature (v, r and s) must come from localethereum to open an escrow\n', '        bytes32 _invitationHash = keccak256(abi.encodePacked(\n', '            _tradeHash,\n', '            _paymentWindowInSeconds,\n', '            _expiry\n', '        ));\n', '        require(recoverAddress(_invitationHash, _v, _r, _s) == relayer, "Must be relayer");\n', '        // These signatures come with an expiry stamp\n', '        require(block.timestamp < _expiry, "Signature has expired");\n', '        // Check transaction value against signed _value and make sure is not 0\n', '        require(msg.value == _value && msg.value > 0, "Incorrect ether sent");\n', '        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0\n', '            ? 1\n', '            : uint32(block.timestamp) + _paymentWindowInSeconds;\n', '        // Add the escrow to the public mapping\n', '        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\n', '        emit Created(_tradeHash);\n', '    }\n', '\n', '    uint16 constant GAS_doResolveDispute = 36100;\n', '    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)\n', '    function resolveDispute(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _buyerPercent\n', '    ) external onlyArbitrator {\n', '        address _signature = recoverAddress(keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            INSTRUCTION_RESOLVE\n', '        )), _v, _r, _s);\n', '        require(_signature == _buyer || _signature == _seller, "Must be buyer or seller");\n', '\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        require(_escrow.exists, "Escrow does not exist");\n', '        require(_buyerPercent <= 100, "_buyerPercent must be 100 or lower");\n', '\n', '        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));\n', '        require(_value - _totalFees <= _value, "Overflow error"); // Prevent underflow\n', '        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\n', '\n', '        delete escrows[_tradeHash];\n', '        emit DisputeResolved(_tradeHash);\n', '        if (_buyerPercent > 0)\n', '          _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\n', '        if (_buyerPercent < 100)\n', '          _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\n', '    }\n', '\n', '    /// @notice Release ether in escrow to the buyer. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function release(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool){\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Disable the seller from cancelling (i.e. "mark as paid"). Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function disableSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _buyer, "Must be buyer");\n', '        return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Cancel the escrow as a buyer. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function buyerCancel(\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _buyer, "Must be buyer");\n', '        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Cancel the escrow as a seller. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function sellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Request to cancel as a seller. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function sellerRequestCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Relay multiple signed instructions from parties of escrows.\n', '    /// @param _tradeID List of _tradeID values\n', '    /// @param _seller List of _seller values\n', '    /// @param _buyer List of _buyer values\n', '    /// @param _value List of _value values\n', '    /// @param _fee List of _fee values\n', '    /// @param _maximumGasPrice List of _maximumGasPrice values\n', '    /// @param _v List of signature "v" components\n', '    /// @param _r List of signature "r" components\n', '    /// @param _s List of signature "s" components\n', '    /// @param _instructionByte List of _instructionByte values\n', '    /// @return bool List of results\n', '    uint16 constant GAS_batchRelayBaseCost = 28500;\n', '    function batchRelay(\n', '        bytes16[] _tradeID,\n', '        address[] _seller,\n', '        address[] _buyer,\n', '        uint256[] _value,\n', '        uint16[] _fee,\n', '        uint128[] _maximumGasPrice,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        uint8[] _instructionByte\n', '    ) public returns (bool[]) {\n', '        bool[] memory _results = new bool[](_tradeID.length);\n', '        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\n', '        for (uint8 i=0; i<_tradeID.length; i++) {\n', '            _results[i] = relay(\n', '                _tradeID[i],\n', '                _seller[i],\n', '                _buyer[i],\n', '                _value[i],\n', '                _fee[i],\n', '                _maximumGasPrice[i],\n', '                _v[i],\n', '                _r[i],\n', '                _s[i],\n', '                _instructionByte[i],\n', '                _additionalGas\n', '            );\n', '        }\n', '        return _results;\n', '    }\n', '\n', '    /// @notice Withdraw fees collected by the contract. Only the owner can call this.\n', '    /// @param _to Address to withdraw fees in to\n', '    /// @param _amount Amount to withdraw\n', '    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\n', '        // This check also prevents underflow\n', '        require(_amount <= feesAvailableForWithdraw, "Amount is higher than amount available");\n', '        feesAvailableForWithdraw -= _amount;\n', '        _to.transfer(_amount);\n', '    }\n', '\n', '    /// @notice Set the arbitrator to a new address. Only the owner can call this.\n', '    /// @param _newArbitrator Address of the replacement arbitrator\n', '    function setArbitrator(address _newArbitrator) onlyOwner external {\n', '        arbitrator = _newArbitrator;\n', '    }\n', '\n', '    /// @notice Change the owner to a new address. Only the owner can call this.\n', '    /// @param _newOwner Address of the replacement owner\n', '    function setOwner(address _newOwner) onlyOwner external {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    /// @notice Change the relayer to a new address. Only the owner can call this.\n', '    /// @param _newRelayer Address of the replacement relayer\n', '    function setRelayer(address _newRelayer) onlyOwner external {\n', '        relayer = _newRelayer;\n', '    }\n', '\n', '    /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.\n', '    /// @param _newRequestCancellationMinimumTime Replacement\n', '    function setRequestCancellationMinimumTime(\n', '        uint32 _newRequestCancellationMinimumTime\n', '    ) onlyOwner external {\n', '        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _transferTo Recipient\n', '    /// @param _value Value\n', '    function transferToken(\n', '        Token _tokenContract,\n', '        address _transferTo,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.transfer(_transferTo, _value);\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _transferTo Recipient\n', '    /// @param _transferFrom Sender\n', '    /// @param _value Value\n', '    function transferTokenFrom(\n', '        Token _tokenContract,\n', '        address _transferTo,\n', '        address _transferFrom,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _spender Spender address\n', '    /// @param _value Value\n', '    function approveToken(\n', '        Token _tokenContract,\n', '        address _spender,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.approve(_spender, _value);\n', '    }\n', '\n', '    /// @notice Relay a signed instruction from a party of an escrow.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function relay(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _maximumGasPrice,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _instructionByte,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        address _relayedSender = getRelayedSender(\n', '            _tradeID,\n', '            _instructionByte,\n', '            _maximumGasPrice,\n', '            _v,\n', '            _r,\n', '            _s\n', '        );\n', '        if (_relayedSender == _buyer) {\n', '            // Buyer&#39;s instructions:\n', '            if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {\n', '                // Disable seller from cancelling\n', '                return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {\n', '                // Cancel\n', '                return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            }\n', '        } else if (_relayedSender == _seller) {\n', '            // Seller&#39;s instructions:\n', '            if (_instructionByte == INSTRUCTION_RELEASE) {\n', '                // Release\n', '                return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {\n', '                // Cancel\n', '                return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL){\n', '                // Request to cancel\n', '                return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            }\n', '        } else {\n', '            require(msg.sender == _seller, "Unrecognised party");\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @notice Increase the amount of gas to be charged later on completion of an escrow\n', '    /// @param _tradeHash Trade hash\n', '    /// @param _gas Gas cost\n', '    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\n', '        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\n', '    }\n', '\n', '    /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay\n', '    /// @param _to Recipient address\n', '    /// @param _value Value of the transfer\n', '    /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer\n', '    /// @param _fee Commission in 1/10000ths\n', '    function transferMinusFees(\n', '        address _to,\n', '        uint256 _value,\n', '        uint128 _totalGasFeesSpentByRelayer,\n', '        uint16 _fee\n', '    ) private {\n', '        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\n', '        // Prevent underflow\n', '        if(_value - _totalFees > _value) {\n', '            return;\n', '        }\n', '        // Add fees to the pot for localethereum to withdraw\n', '        feesAvailableForWithdraw += _totalFees;\n', '        _to.transfer(_value - _totalFees);\n', '    }\n', '\n', '    uint16 constant GAS_doRelease = 46588;\n', '    /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doRelease(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit Released(_tradeHash);\n', '        transferMinusFees(_buyer, _value, _gasFees, _fee);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doDisableSellerCancel = 28944;\n', '    /// @notice Prevents the seller from cancelling an escrow. Used to "mark as paid" by the buyer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doDisableSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        if(_escrow.sellerCanCancelAfter == 0) return false;\n', '        escrows[_tradeHash].sellerCanCancelAfter = 0;\n', '        emit SellerCancelDisabled(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doBuyerCancel = 46255;\n', '    /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doBuyerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit CancelledByBuyer(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerCancel = 46815;\n', '    /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {\n', '            return false;\n', '        }\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit CancelledBySeller(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerRequestCancel = 29507;\n', '    /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doSellerRequestCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        // Called on unlimited payment window trades where the buyer is not responding\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        if(_escrow.sellerCanCancelAfter != 1) {\n', '            return false;\n', '        }\n', '        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp)\n', '            + requestCancellationMinimumTime;\n', '        emit SellerRequestedCancel(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /// @notice Get the sender of the signed instruction.\n', '    /// @param _tradeID Identifier of the trade\n', '    /// @param _instructionByte Identifier of the instruction\n', '    /// @param _maximumGasPrice Maximum gas price permitted by the sender\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @return address\n', '    function getRelayedSender(\n', '      bytes16 _tradeID,\n', '      uint8 _instructionByte,\n', '      uint128 _maximumGasPrice,\n', '      uint8 _v,\n', '      bytes32 _r,\n', '      bytes32 _s\n', '    ) view private returns (address) {\n', '        bytes32 _hash = keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            _instructionByte,\n', '            _maximumGasPrice\n', '        ));\n', '        if(tx.gasprice > _maximumGasPrice) {\n', '            return;\n', '        }\n', '        return recoverAddress(_hash, _v, _r, _s);\n', '    }\n', '\n', '    /// @notice Hashes the values and returns the matching escrow object and trade hash.\n', '    /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return Escrow\n', '    function getEscrowAndHash(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) view private returns (Escrow, bytes32) {\n', '        bytes32 _tradeHash = keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            _seller,\n', '            _buyer,\n', '            _value,\n', '            _fee\n', '        ));\n', '        return (escrows[_tradeHash], _tradeHash);\n', '    }\n', '\n', '    /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.\n', '    /// @param _h Data to be hashed\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @return address\n', '    function recoverAddress(\n', '        bytes32 _h,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) private pure returns (address) {\n', '        bytes memory _prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\n', '        return ecrecover(_prefixedHash, _v, _r, _s);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '}\n', '\n', '/// @title localethereum.com\n', '/// @author localethereum.com\n', 'contract LocalEthereumEscrows {\n', '    /***********************\n', '    +   Global settings   +\n', '    ***********************/\n', '\n', '    // Address of the arbitrator (currently always localethereum staff)\n', '    address public arbitrator;\n', '    // Address of the owner (who can withdraw collected fees)\n', '    address public owner;\n', '    // Address of the relayer (who is allowed to forward signed instructions from parties)\n', '    address public relayer;\n', '    uint32 public requestCancellationMinimumTime;\n', '    // Cumulative balance of collected fees\n', '    uint256 public feesAvailableForWithdraw;\n', '\n', '    /***********************\n', '    +  Instruction types  +\n', '    ***********************/\n', '\n', '    // Called when the buyer marks payment as sent. Locks funds in escrow\n', '    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;\n', '    // Buyer cancelling\n', '    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;\n', '    // Seller cancelling\n', '    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;\n', '    // Seller requesting to cancel. Begins a window for buyer to object\n', '    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;\n', '    // Seller releasing funds to the buyer\n', '    uint8 constant INSTRUCTION_RELEASE = 0x05;\n', '    // Either party permitting the arbitrator to resolve a dispute\n', '    uint8 constant INSTRUCTION_RESOLVE = 0x06;\n', '\n', '    /***********************\n', '    +       Events        +\n', '    ***********************/\n', '\n', '    event Created(bytes32 indexed _tradeHash);\n', '    event SellerCancelDisabled(bytes32 indexed _tradeHash);\n', '    event SellerRequestedCancel(bytes32 indexed _tradeHash);\n', '    event CancelledBySeller(bytes32 indexed _tradeHash);\n', '    event CancelledByBuyer(bytes32 indexed _tradeHash);\n', '    event Released(bytes32 indexed _tradeHash);\n', '    event DisputeResolved(bytes32 indexed _tradeHash);\n', '\n', '    struct Escrow {\n', '        // So we know the escrow exists\n', '        bool exists;\n', '        // This is the timestamp in whic hthe seller can cancel the escrow after.\n', '        // It has two special values:\n', '        // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)\n', '        // 1 : The seller can only request to cancel, which will change this value to a timestamp.\n', '        //     This option is avaialble for complex trade terms such as cash-in-person where a\n', '        //     payment window is inappropriate\n', '        uint32 sellerCanCancelAfter;\n', '        // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner\n', '        // in the way of fees once the escrow has completed\n', '        uint128 totalGasFeesSpentByRelayer;\n', '    }\n', '\n', '    // Mapping of active trades. The key here is a hash of the trade proprties\n', '    mapping (bytes32 => Escrow) public escrows;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Must be owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyArbitrator() {\n', '        require(msg.sender == arbitrator, "Must be arbitrator");\n', '        _;\n', '    }\n', '\n', '    /// @notice Initialize the contract.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        arbitrator = msg.sender;\n', '        relayer = msg.sender;\n', '        requestCancellationMinimumTime = 2 hours;\n', '    }\n', '\n', '    /// @notice Create and fund a new escrow.\n', '    /// @param _tradeID The unique ID of the trade, generated by localethereum.com\n', '    /// @param _seller The selling party\n', '    /// @param _buyer The buying party\n', '    /// @param _value The amount of the escrow, exclusive of the fee\n', "    /// @param _fee Localethereum's commission in 1/10000ths\n", '    /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after\n', '    /// @param _expiry This transaction must be created before this time\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    function createEscrow(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint32 _paymentWindowInSeconds,\n', '        uint32 _expiry,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) payable external {\n', '        // The trade hash is created by tightly-concatenating and hashing properties of the trade.\n', '        // This hash becomes the identifier of the escrow, and hence all these variables must be\n', '        // supplied on future contract calls\n', '        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\n', '        // Require that trade does not already exist\n', '        require(!escrows[_tradeHash].exists, "Trade already exists");\n', '        // A signature (v, r and s) must come from localethereum to open an escrow\n', '        bytes32 _invitationHash = keccak256(abi.encodePacked(\n', '            _tradeHash,\n', '            _paymentWindowInSeconds,\n', '            _expiry\n', '        ));\n', '        require(recoverAddress(_invitationHash, _v, _r, _s) == relayer, "Must be relayer");\n', '        // These signatures come with an expiry stamp\n', '        require(block.timestamp < _expiry, "Signature has expired");\n', '        // Check transaction value against signed _value and make sure is not 0\n', '        require(msg.value == _value && msg.value > 0, "Incorrect ether sent");\n', '        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0\n', '            ? 1\n', '            : uint32(block.timestamp) + _paymentWindowInSeconds;\n', '        // Add the escrow to the public mapping\n', '        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\n', '        emit Created(_tradeHash);\n', '    }\n', '\n', '    uint16 constant GAS_doResolveDispute = 36100;\n', '    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)\n', '    function resolveDispute(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _buyerPercent\n', '    ) external onlyArbitrator {\n', '        address _signature = recoverAddress(keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            INSTRUCTION_RESOLVE\n', '        )), _v, _r, _s);\n', '        require(_signature == _buyer || _signature == _seller, "Must be buyer or seller");\n', '\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        require(_escrow.exists, "Escrow does not exist");\n', '        require(_buyerPercent <= 100, "_buyerPercent must be 100 or lower");\n', '\n', '        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));\n', '        require(_value - _totalFees <= _value, "Overflow error"); // Prevent underflow\n', '        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\n', '\n', '        delete escrows[_tradeHash];\n', '        emit DisputeResolved(_tradeHash);\n', '        if (_buyerPercent > 0)\n', '          _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\n', '        if (_buyerPercent < 100)\n', '          _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\n', '    }\n', '\n', '    /// @notice Release ether in escrow to the buyer. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function release(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool){\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Disable the seller from cancelling (i.e. "mark as paid"). Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function disableSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _buyer, "Must be buyer");\n', '        return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Cancel the escrow as a buyer. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function buyerCancel(\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _buyer, "Must be buyer");\n', '        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Cancel the escrow as a seller. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function sellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Request to cancel as a seller. Direct call option.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return bool\n', '    function sellerRequestCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) external returns (bool) {\n', '        require(msg.sender == _seller, "Must be seller");\n', '        return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    /// @notice Relay multiple signed instructions from parties of escrows.\n', '    /// @param _tradeID List of _tradeID values\n', '    /// @param _seller List of _seller values\n', '    /// @param _buyer List of _buyer values\n', '    /// @param _value List of _value values\n', '    /// @param _fee List of _fee values\n', '    /// @param _maximumGasPrice List of _maximumGasPrice values\n', '    /// @param _v List of signature "v" components\n', '    /// @param _r List of signature "r" components\n', '    /// @param _s List of signature "s" components\n', '    /// @param _instructionByte List of _instructionByte values\n', '    /// @return bool List of results\n', '    uint16 constant GAS_batchRelayBaseCost = 28500;\n', '    function batchRelay(\n', '        bytes16[] _tradeID,\n', '        address[] _seller,\n', '        address[] _buyer,\n', '        uint256[] _value,\n', '        uint16[] _fee,\n', '        uint128[] _maximumGasPrice,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        uint8[] _instructionByte\n', '    ) public returns (bool[]) {\n', '        bool[] memory _results = new bool[](_tradeID.length);\n', '        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\n', '        for (uint8 i=0; i<_tradeID.length; i++) {\n', '            _results[i] = relay(\n', '                _tradeID[i],\n', '                _seller[i],\n', '                _buyer[i],\n', '                _value[i],\n', '                _fee[i],\n', '                _maximumGasPrice[i],\n', '                _v[i],\n', '                _r[i],\n', '                _s[i],\n', '                _instructionByte[i],\n', '                _additionalGas\n', '            );\n', '        }\n', '        return _results;\n', '    }\n', '\n', '    /// @notice Withdraw fees collected by the contract. Only the owner can call this.\n', '    /// @param _to Address to withdraw fees in to\n', '    /// @param _amount Amount to withdraw\n', '    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\n', '        // This check also prevents underflow\n', '        require(_amount <= feesAvailableForWithdraw, "Amount is higher than amount available");\n', '        feesAvailableForWithdraw -= _amount;\n', '        _to.transfer(_amount);\n', '    }\n', '\n', '    /// @notice Set the arbitrator to a new address. Only the owner can call this.\n', '    /// @param _newArbitrator Address of the replacement arbitrator\n', '    function setArbitrator(address _newArbitrator) onlyOwner external {\n', '        arbitrator = _newArbitrator;\n', '    }\n', '\n', '    /// @notice Change the owner to a new address. Only the owner can call this.\n', '    /// @param _newOwner Address of the replacement owner\n', '    function setOwner(address _newOwner) onlyOwner external {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    /// @notice Change the relayer to a new address. Only the owner can call this.\n', '    /// @param _newRelayer Address of the replacement relayer\n', '    function setRelayer(address _newRelayer) onlyOwner external {\n', '        relayer = _newRelayer;\n', '    }\n', '\n', '    /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.\n', '    /// @param _newRequestCancellationMinimumTime Replacement\n', '    function setRequestCancellationMinimumTime(\n', '        uint32 _newRequestCancellationMinimumTime\n', '    ) onlyOwner external {\n', '        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _transferTo Recipient\n', '    /// @param _value Value\n', '    function transferToken(\n', '        Token _tokenContract,\n', '        address _transferTo,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.transfer(_transferTo, _value);\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _transferTo Recipient\n', '    /// @param _transferFrom Sender\n', '    /// @param _value Value\n', '    function transferTokenFrom(\n', '        Token _tokenContract,\n', '        address _transferTo,\n', '        address _transferFrom,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\n', '    }\n', '\n', '    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\n', '    /// @param _tokenContract Token contract\n', '    /// @param _spender Spender address\n', '    /// @param _value Value\n', '    function approveToken(\n', '        Token _tokenContract,\n', '        address _spender,\n', '        uint256 _value\n', '    ) onlyOwner external {\n', '        _tokenContract.approve(_spender, _value);\n', '    }\n', '\n', '    /// @notice Relay a signed instruction from a party of an escrow.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function relay(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _maximumGasPrice,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        uint8 _instructionByte,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        address _relayedSender = getRelayedSender(\n', '            _tradeID,\n', '            _instructionByte,\n', '            _maximumGasPrice,\n', '            _v,\n', '            _r,\n', '            _s\n', '        );\n', '        if (_relayedSender == _buyer) {\n', "            // Buyer's instructions:\n", '            if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {\n', '                // Disable seller from cancelling\n', '                return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {\n', '                // Cancel\n', '                return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            }\n', '        } else if (_relayedSender == _seller) {\n', "            // Seller's instructions:\n", '            if (_instructionByte == INSTRUCTION_RELEASE) {\n', '                // Release\n', '                return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {\n', '                // Cancel\n', '                return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL){\n', '                // Request to cancel\n', '                return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '            }\n', '        } else {\n', '            require(msg.sender == _seller, "Unrecognised party");\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @notice Increase the amount of gas to be charged later on completion of an escrow\n', '    /// @param _tradeHash Trade hash\n', '    /// @param _gas Gas cost\n', '    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\n', '        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\n', '    }\n', '\n', '    /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay\n', '    /// @param _to Recipient address\n', '    /// @param _value Value of the transfer\n', '    /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer\n', '    /// @param _fee Commission in 1/10000ths\n', '    function transferMinusFees(\n', '        address _to,\n', '        uint256 _value,\n', '        uint128 _totalGasFeesSpentByRelayer,\n', '        uint16 _fee\n', '    ) private {\n', '        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\n', '        // Prevent underflow\n', '        if(_value - _totalFees > _value) {\n', '            return;\n', '        }\n', '        // Add fees to the pot for localethereum to withdraw\n', '        feesAvailableForWithdraw += _totalFees;\n', '        _to.transfer(_value - _totalFees);\n', '    }\n', '\n', '    uint16 constant GAS_doRelease = 46588;\n', '    /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doRelease(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit Released(_tradeHash);\n', '        transferMinusFees(_buyer, _value, _gasFees, _fee);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doDisableSellerCancel = 28944;\n', '    /// @notice Prevents the seller from cancelling an escrow. Used to "mark as paid" by the buyer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doDisableSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        if(_escrow.sellerCanCancelAfter == 0) return false;\n', '        escrows[_tradeHash].sellerCanCancelAfter = 0;\n', '        emit SellerCancelDisabled(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doBuyerCancel = 46255;\n', '    /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doBuyerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit CancelledByBuyer(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerCancel = 46815;\n', '    /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doSellerCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {\n', '            return false;\n', '        }\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\n', '            + (msg.sender == relayer\n', '                ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)\n', '                : 0\n', '            );\n', '        delete escrows[_tradeHash];\n', '        emit CancelledBySeller(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerRequestCancel = 29507;\n', '    /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @param _additionalGas Additional gas to be deducted after this operation\n', '    /// @return bool\n', '    function doSellerRequestCancel(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee,\n', '        uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        // Called on unlimited payment window trades where the buyer is not responding\n', '        Escrow memory _escrow;\n', '        bytes32 _tradeHash;\n', '        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) {\n', '            return false;\n', '        }\n', '        if(_escrow.sellerCanCancelAfter != 1) {\n', '            return false;\n', '        }\n', '        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp)\n', '            + requestCancellationMinimumTime;\n', '        emit SellerRequestedCancel(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /// @notice Get the sender of the signed instruction.\n', '    /// @param _tradeID Identifier of the trade\n', '    /// @param _instructionByte Identifier of the instruction\n', '    /// @param _maximumGasPrice Maximum gas price permitted by the sender\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @return address\n', '    function getRelayedSender(\n', '      bytes16 _tradeID,\n', '      uint8 _instructionByte,\n', '      uint128 _maximumGasPrice,\n', '      uint8 _v,\n', '      bytes32 _r,\n', '      bytes32 _s\n', '    ) view private returns (address) {\n', '        bytes32 _hash = keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            _instructionByte,\n', '            _maximumGasPrice\n', '        ));\n', '        if(tx.gasprice > _maximumGasPrice) {\n', '            return;\n', '        }\n', '        return recoverAddress(_hash, _v, _r, _s);\n', '    }\n', '\n', '    /// @notice Hashes the values and returns the matching escrow object and trade hash.\n', '    /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.\n', '    /// @param _tradeID Escrow "tradeID" parameter\n', '    /// @param _seller Escrow "seller" parameter\n', '    /// @param _buyer Escrow "buyer" parameter\n', '    /// @param _value Escrow "value" parameter\n', '    /// @param _fee Escrow "fee parameter\n', '    /// @return Escrow\n', '    function getEscrowAndHash(\n', '        bytes16 _tradeID,\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _value,\n', '        uint16 _fee\n', '    ) view private returns (Escrow, bytes32) {\n', '        bytes32 _tradeHash = keccak256(abi.encodePacked(\n', '            _tradeID,\n', '            _seller,\n', '            _buyer,\n', '            _value,\n', '            _fee\n', '        ));\n', '        return (escrows[_tradeHash], _tradeHash);\n', '    }\n', '\n', '    /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.\n', '    /// @param _h Data to be hashed\n', '    /// @param _v Signature "v" component\n', '    /// @param _r Signature "r" component\n', '    /// @param _s Signature "s" component\n', '    /// @return address\n', '    function recoverAddress(\n', '        bytes32 _h,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) private pure returns (address) {\n', '        bytes memory _prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\n', '        return ecrecover(_prefixedHash, _v, _r, _s);\n', '    }\n', '}']
