['contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract ERC20dex {\n', '    int constant SELL = 0;\n', '    int constant BUY  = 1;\n', '    \n', '    byte constant COIN_DEAD         = 0;\n', '    byte constant COIN_NON_APPROVED = 1;\n', '    byte constant COIN_APPROVED     = 2;\n', '    \n', '    address owner = 0;\n', '    address trader = 0;\n', '    uint256 maker_fee = 0;\n', '    uint256 taker_fee = 0;\n', '    uint256 deploy_fee = 0;\n', '    int stopped = 0;\n', '    uint256 main_fee = 0;\n', '    \n', '    struct order_t {\n', '        int buy_sell;\n', '        address owner;\n', '        uint256 amount;\n', '        uint256 price;\n', '        uint256 block;\n', '    }\n', '    \n', '    struct coin_t {\n', '        string ticker;\n', '        string name;\n', '        address base;\n', '        uint8 digits;\n', '        address requestor;\n', '        uint256 minimum_trade;\n', '        byte state;\n', '        uint256 fee;\n', '        uint256 price;\n', '    }\n', '    \n', '    // List of registered coins\n', '    coin_t[] shitcoins;\n', '    \n', '    // Minimum value of a trade\n', '    uint256 minimum_trade;\n', '    \n', '    // Indexing for shitcoins array\n', '    mapping(string => uint16) shitcoin_index;\n', '\n', '    // Order book\n', '    mapping(string => order_t[]) order_book;\n', '    \n', '    // Balances\n', '    mapping(address => uint256) etx_balances;\n', '\n', '    function ERC20dex() {\n', '        owner = msg.sender;\n', '        trader = msg.sender;\n', '    }\n', '    \n', '    function set_owner(address new_owner) {\n', '        require(msg.sender == owner);\n', '        owner = new_owner;\n', '    }\n', '    function set_trader(address new_trader) {\n', '        require(msg.sender == owner);\n', '        trader = new_trader;\n', '    }\n', '    \n', '    function require(bool condition) constant private {\n', '        if (condition == false) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function assert(bool condition) constant private {\n', '        if (condition == false) {\n', '            throw;\n', '        }\n', '    }\n', '    \n', '    function safe_mul(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        \n', '        return c;\n', '    }\n', '    \n', '    function safe_add(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        require(a + b >= a);\n', '        return a + b;\n', '    }\n', '    \n', '    function safe_sub(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        require(a >= b);\n', '        return a - b;\n', '    }\n', '    \n', '    function stop() public {\n', '        require(msg.sender == owner);\n', '        stopped = 1;\n', '    }\n', '\n', '    function add_coin(string coin, string name, address base, uint8 digits) public {\n', '        require(msg.sender == owner);\n', '        require(shitcoin_index[coin] == 0);\n', '        \n', '        // Register a new coin\n', '        shitcoins.push(coin_t(coin, name, base, digits, msg.sender, 0, COIN_APPROVED, 0, 0));\n', '        shitcoin_index[coin] = uint16(shitcoins.length);\n', '    }\n', '    \n', '    function createToken(string symbol, string name, address coin_address, uint8 decimals) public {\n', '        // Check if sender included enough ETC for creation\n', '        require(msg.value == deploy_fee);\n', '        require(shitcoin_index[symbol] == 0);\n', '\n', '        // Pass fee to the owner\n', '        require(owner.send(msg.value));\n', '\n', '        // Register a new coin, but do not approve it\n', '        shitcoins.push(coin_t(symbol, name, coin_address, decimals, msg.sender, 0, COIN_NON_APPROVED, 0, 0));\n', '        shitcoin_index[symbol] = uint16(shitcoins.length);\n', '    }\n', '    \n', '    function approve_coin(string coin, bool approved) public {\n', '        require(msg.sender == owner);\n', '        if (approved) {\n', '            shitcoins[shitcoin_index[coin] - 1].state = COIN_APPROVED;\n', '        } else {\n', '            shitcoins[shitcoin_index[coin] - 1].state = COIN_NON_APPROVED;\n', '        }\n', '    }\n', '    \n', '    function remove_coin(uint index) public {\n', '        require(msg.sender == owner);\n', '        require(index < shitcoins.length);\n', '        \n', '        shitcoin_index[shitcoins[index].ticker] = 0;\n', '        shitcoins[index].state = COIN_DEAD;\n', '    }\n', '    \n', '    function set_fee(uint256 the_maker_fee, uint256 the_taker_fee, uint256 the_deploy_fee) public {\n', '        require(msg.sender == owner);\n', '        \n', '        maker_fee = the_maker_fee;\n', '        taker_fee = the_taker_fee;\n', '        deploy_fee = the_deploy_fee;\n', '    }\n', '    \n', '    function set_minimum_trade(uint256 the_minimum_trade) public {\n', '        require(msg.sender == owner);\n', '        minimum_trade = the_minimum_trade;\n', '    }\n', '    \n', '    function get_minimum_trade() constant returns (uint256) {\n', '        return minimum_trade;\n', '    }\n', '    \n', '    function set_coin_minimum_trade(string token, uint256 the_minimum_trade) public {\n', '        require(msg.sender == owner);\n', '        shitcoins[shitcoin_index[token] - 1].minimum_trade = the_minimum_trade;\n', '    }\n', '\n', '    function get_maker_fee() constant returns (uint256) {\n', '        return maker_fee;\n', '    }\n', '    \n', '    function get_taker_fee() constant returns (uint256) {\n', '        return taker_fee;\n', '    }\n', '    \n', '    function get_deploy_fee() constant returns (uint256) {\n', '        return deploy_fee;\n', '    }\n', '    \n', '    function get_coins_count() constant returns (uint256 length) {\n', '        length = shitcoins.length;\n', '    }\n', '    \n', '    function get_coin(uint index) constant returns (string, string, address, byte, uint8, address, uint256) {\n', '        coin_t coin = shitcoins[index];\n', '        return (coin.ticker, coin.name, coin.base, coin.state, coin.digits, coin.requestor, coin.minimum_trade);\n', '    }\n', '    \n', '    function get_balance(address a, string token) constant returns (uint256 balance) {\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        if (coin.state != COIN_DEAD) {\n', '            // Get ERC20 contract and check how many coins we can use for selling\n', '            ERC20 shitcoin = ERC20(shitcoins[shitcoin_index[token] - 1].base);\n', '            balance = shitcoin.allowance(a, this);\n', '        }\n', '    }\n', '    \n', '    function get_etc_balance(address a) constant returns (uint256 balance) {\n', '        return etx_balances[a];\n', '    }\n', '    \n', '    function get_order_book_length(string token) constant returns (uint256 length) {\n', '        return order_book[token].length;\n', '    }\n', '    \n', '    function get_order(string token, uint256 index) constant returns (int, address, uint256, uint256, uint256) {\n', '        order_t order = order_book[token][index];\n', '        return (order.buy_sell, order.owner, order.amount, order.price, order.block);\n', '    }\n', '    \n', '    function get_price(string token) constant returns (uint256) {\n', '        return shitcoins[shitcoin_index[token] - 1].price;\n', '    }\n', '    \n', '    function total_amount(string token, uint256 amount, uint256 price) constant returns (uint256) {\n', '        return safe_mul(amount, price) / 10**uint256(shitcoins[shitcoin_index[token] - 1].digits);\n', '    }\n', '    \n', '    function sell(string token, uint256 amount, uint256 price) public {\n', '        // Basic checks\n', '        require(stopped == 0);\n', '        require(total_amount(token, amount, price) >= minimum_trade);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '        require(amount >= coin.minimum_trade);\n', '        \n', '        // Check if we are allowed to secure coins for a deal\n', '        ERC20 shitcoin = ERC20(coin.base);\n', '        require(shitcoin.allowance(msg.sender, this) >= amount);\n', '        \n', '        // Secure tokens for a deal\n', '        require(shitcoin.transferFrom(msg.sender, this, amount));\n', '\n', '        // Register an order for further processing by matcher\n', '        order_book[token].push(order_t(SELL, msg.sender, amount, price, block.number));\n', '    }\n', '    \n', '    function buy(string token, uint256 amount, uint256 price) public {\n', '        // Basic checks\n', '        require(stopped == 0);\n', '        require(total_amount(token, amount, price) == msg.value);\n', '        require(msg.value >= minimum_trade);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '        require(amount >= coin.minimum_trade);\n', '\n', '        // Credit ETX to the holder account\n', '        etx_balances[msg.sender] += msg.value;\n', '\n', '        // Register an order for further processing by matcher\n', '        order_book[token].push(order_t(BUY, msg.sender, amount, price, block.number));\n', '    }\n', '    \n', '    function trade(string token, uint maker, uint taker) public {\n', '        // Basic checks\n', '        require(msg.sender == trader);\n', '        require(maker < order_book[token].length);\n', '        require(taker < order_book[token].length);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '\n', '        order_t make = order_book[token][maker];\n', '        order_t take = order_book[token][taker];\n', '        uint256 makerFee = 0;\n', '        uint256 takerFee = 0;\n', '        uint256 send_to_maker = 0;\n', '        uint256 send_to_taker = 0;\n', '        ERC20 shitcoin = ERC20(coin.base);\n', '        \n', '        // Check how many coins go into the deal\n', '        uint256 deal_amount = 0;\n', '        if (take.amount < make.amount) {\n', '            deal_amount = take.amount;\n', '        } else {\n', '            deal_amount = make.amount;\n', '        }\n', '        uint256 total_deal = total_amount(token, deal_amount, make.price);\n', '        \n', '        // If maker buys something\n', '        if (make.buy_sell == BUY) {\n', '            // Sanity check\n', '            require(take.price <= make.price);\n', '            \n', '            // Calculate fees\n', '            makerFee = safe_mul(deal_amount, maker_fee) / 10000;\n', '            takerFee = safe_mul(total_deal, taker_fee) / 10000;\n', '            \n', '            // Update accessible fees\n', '            coin.fee = coin.fee + makerFee;\n', '            main_fee = main_fee + takerFee;\n', '            \n', '            send_to_maker = safe_sub(deal_amount, makerFee);\n', '            send_to_taker = safe_sub(total_deal, takerFee);\n', '                \n', '            // Move shitcoin to maker\n', '            require(shitcoin.transfer(make.owner, send_to_maker));\n', '                \n', '            // Deduct from avaialble ETC balance\n', '            etx_balances[make.owner] = safe_sub(etx_balances[make.owner], total_deal);\n', '                \n', '            // Move funds to taker\n', '            require(take.owner.send(send_to_taker));\n', '                \n', '        } else {\n', '            // Sanity check\n', '            require(take.price >= make.price);\n', '            \n', '            // Calculate fees\n', '            makerFee = safe_mul(total_deal, maker_fee) / 10000;\n', '            takerFee = safe_mul(deal_amount, taker_fee) / 10000;\n', '            \n', '            // Update accessible fees\n', '            main_fee = main_fee + makerFee;\n', '            coin.fee = coin.fee + takerFee;\n', '            \n', '            send_to_maker = safe_sub(total_deal, makerFee);\n', '            send_to_taker = safe_sub(deal_amount, takerFee);\n', '                \n', '            // Move shitcoin to taker\n', '            require(shitcoin.transfer(take.owner, send_to_taker));\n', '                \n', '            // Deduct from avaialble ETC balance\n', '            etx_balances[take.owner] = safe_sub(etx_balances[take.owner], total_deal);\n', '                \n', '            // Move funds to maker\n', '            require(make.owner.send(send_to_maker));\n', '        }\n', '        \n', '        // Reduce order size\n', '        make.amount = safe_sub(make.amount, deal_amount);\n', '        take.amount = safe_sub(take.amount, deal_amount);\n', '        \n', '        // Update price\n', '        coin.price = make.price;\n', '    }\n', '    \n', '    function cancel(string token, uint256 index) public {\n', '        // Coin checks\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        order_t order = order_book[token][index];\n', '\n', '        require(coin.state == COIN_APPROVED);\n', '        require((msg.sender == order.owner) || (msg.sender == owner));\n', '        require(order.amount > 0);\n', '        \n', '        // Null the order\n', '        uint256 old_amount = order.amount;\n', '        order.amount = 0;\n', '\n', '        // Return coins\n', '        if (order.buy_sell == BUY) {\n', '            // Return back ETC\n', '            uint256 total_deal = total_amount(token, old_amount, order.price);\n', '            etx_balances[msg.sender] = safe_sub(etx_balances[msg.sender], total_deal);\n', '            require(order.owner.send(total_deal));\n', '        } else {\n', '            // Return shitcoins back \n', '            ERC20 shitcoin = ERC20(coin.base);\n', '            shitcoin.transfer(order.owner, old_amount);\n', '        }\n', '    }\n', '    \n', '    function collect_fee(string token) public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send shitcoins\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        if (coin.fee > 0) {\n', '            ERC20 shitcoin = ERC20(coin.base);\n', '            shitcoin.transfer(owner, coin.fee);\n', '            coin.fee = 0;\n', '        }\n', '    }\n', '    \n', '    function collect_main_fee() public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send main currency\n', '        require(owner.send(main_fee));\n', '        main_fee = 0;\n', '    }\n', '\n', '}']
['contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract ERC20dex {\n', '    int constant SELL = 0;\n', '    int constant BUY  = 1;\n', '    \n', '    byte constant COIN_DEAD         = 0;\n', '    byte constant COIN_NON_APPROVED = 1;\n', '    byte constant COIN_APPROVED     = 2;\n', '    \n', '    address owner = 0;\n', '    address trader = 0;\n', '    uint256 maker_fee = 0;\n', '    uint256 taker_fee = 0;\n', '    uint256 deploy_fee = 0;\n', '    int stopped = 0;\n', '    uint256 main_fee = 0;\n', '    \n', '    struct order_t {\n', '        int buy_sell;\n', '        address owner;\n', '        uint256 amount;\n', '        uint256 price;\n', '        uint256 block;\n', '    }\n', '    \n', '    struct coin_t {\n', '        string ticker;\n', '        string name;\n', '        address base;\n', '        uint8 digits;\n', '        address requestor;\n', '        uint256 minimum_trade;\n', '        byte state;\n', '        uint256 fee;\n', '        uint256 price;\n', '    }\n', '    \n', '    // List of registered coins\n', '    coin_t[] shitcoins;\n', '    \n', '    // Minimum value of a trade\n', '    uint256 minimum_trade;\n', '    \n', '    // Indexing for shitcoins array\n', '    mapping(string => uint16) shitcoin_index;\n', '\n', '    // Order book\n', '    mapping(string => order_t[]) order_book;\n', '    \n', '    // Balances\n', '    mapping(address => uint256) etx_balances;\n', '\n', '    function ERC20dex() {\n', '        owner = msg.sender;\n', '        trader = msg.sender;\n', '    }\n', '    \n', '    function set_owner(address new_owner) {\n', '        require(msg.sender == owner);\n', '        owner = new_owner;\n', '    }\n', '    function set_trader(address new_trader) {\n', '        require(msg.sender == owner);\n', '        trader = new_trader;\n', '    }\n', '    \n', '    function require(bool condition) constant private {\n', '        if (condition == false) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function assert(bool condition) constant private {\n', '        if (condition == false) {\n', '            throw;\n', '        }\n', '    }\n', '    \n', '    function safe_mul(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        \n', '        return c;\n', '    }\n', '    \n', '    function safe_add(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        require(a + b >= a);\n', '        return a + b;\n', '    }\n', '    \n', '    function safe_sub(uint256 a, uint256 b) constant returns (uint256 c) {\n', '        require(a >= b);\n', '        return a - b;\n', '    }\n', '    \n', '    function stop() public {\n', '        require(msg.sender == owner);\n', '        stopped = 1;\n', '    }\n', '\n', '    function add_coin(string coin, string name, address base, uint8 digits) public {\n', '        require(msg.sender == owner);\n', '        require(shitcoin_index[coin] == 0);\n', '        \n', '        // Register a new coin\n', '        shitcoins.push(coin_t(coin, name, base, digits, msg.sender, 0, COIN_APPROVED, 0, 0));\n', '        shitcoin_index[coin] = uint16(shitcoins.length);\n', '    }\n', '    \n', '    function createToken(string symbol, string name, address coin_address, uint8 decimals) public {\n', '        // Check if sender included enough ETC for creation\n', '        require(msg.value == deploy_fee);\n', '        require(shitcoin_index[symbol] == 0);\n', '\n', '        // Pass fee to the owner\n', '        require(owner.send(msg.value));\n', '\n', '        // Register a new coin, but do not approve it\n', '        shitcoins.push(coin_t(symbol, name, coin_address, decimals, msg.sender, 0, COIN_NON_APPROVED, 0, 0));\n', '        shitcoin_index[symbol] = uint16(shitcoins.length);\n', '    }\n', '    \n', '    function approve_coin(string coin, bool approved) public {\n', '        require(msg.sender == owner);\n', '        if (approved) {\n', '            shitcoins[shitcoin_index[coin] - 1].state = COIN_APPROVED;\n', '        } else {\n', '            shitcoins[shitcoin_index[coin] - 1].state = COIN_NON_APPROVED;\n', '        }\n', '    }\n', '    \n', '    function remove_coin(uint index) public {\n', '        require(msg.sender == owner);\n', '        require(index < shitcoins.length);\n', '        \n', '        shitcoin_index[shitcoins[index].ticker] = 0;\n', '        shitcoins[index].state = COIN_DEAD;\n', '    }\n', '    \n', '    function set_fee(uint256 the_maker_fee, uint256 the_taker_fee, uint256 the_deploy_fee) public {\n', '        require(msg.sender == owner);\n', '        \n', '        maker_fee = the_maker_fee;\n', '        taker_fee = the_taker_fee;\n', '        deploy_fee = the_deploy_fee;\n', '    }\n', '    \n', '    function set_minimum_trade(uint256 the_minimum_trade) public {\n', '        require(msg.sender == owner);\n', '        minimum_trade = the_minimum_trade;\n', '    }\n', '    \n', '    function get_minimum_trade() constant returns (uint256) {\n', '        return minimum_trade;\n', '    }\n', '    \n', '    function set_coin_minimum_trade(string token, uint256 the_minimum_trade) public {\n', '        require(msg.sender == owner);\n', '        shitcoins[shitcoin_index[token] - 1].minimum_trade = the_minimum_trade;\n', '    }\n', '\n', '    function get_maker_fee() constant returns (uint256) {\n', '        return maker_fee;\n', '    }\n', '    \n', '    function get_taker_fee() constant returns (uint256) {\n', '        return taker_fee;\n', '    }\n', '    \n', '    function get_deploy_fee() constant returns (uint256) {\n', '        return deploy_fee;\n', '    }\n', '    \n', '    function get_coins_count() constant returns (uint256 length) {\n', '        length = shitcoins.length;\n', '    }\n', '    \n', '    function get_coin(uint index) constant returns (string, string, address, byte, uint8, address, uint256) {\n', '        coin_t coin = shitcoins[index];\n', '        return (coin.ticker, coin.name, coin.base, coin.state, coin.digits, coin.requestor, coin.minimum_trade);\n', '    }\n', '    \n', '    function get_balance(address a, string token) constant returns (uint256 balance) {\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        if (coin.state != COIN_DEAD) {\n', '            // Get ERC20 contract and check how many coins we can use for selling\n', '            ERC20 shitcoin = ERC20(shitcoins[shitcoin_index[token] - 1].base);\n', '            balance = shitcoin.allowance(a, this);\n', '        }\n', '    }\n', '    \n', '    function get_etc_balance(address a) constant returns (uint256 balance) {\n', '        return etx_balances[a];\n', '    }\n', '    \n', '    function get_order_book_length(string token) constant returns (uint256 length) {\n', '        return order_book[token].length;\n', '    }\n', '    \n', '    function get_order(string token, uint256 index) constant returns (int, address, uint256, uint256, uint256) {\n', '        order_t order = order_book[token][index];\n', '        return (order.buy_sell, order.owner, order.amount, order.price, order.block);\n', '    }\n', '    \n', '    function get_price(string token) constant returns (uint256) {\n', '        return shitcoins[shitcoin_index[token] - 1].price;\n', '    }\n', '    \n', '    function total_amount(string token, uint256 amount, uint256 price) constant returns (uint256) {\n', '        return safe_mul(amount, price) / 10**uint256(shitcoins[shitcoin_index[token] - 1].digits);\n', '    }\n', '    \n', '    function sell(string token, uint256 amount, uint256 price) public {\n', '        // Basic checks\n', '        require(stopped == 0);\n', '        require(total_amount(token, amount, price) >= minimum_trade);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '        require(amount >= coin.minimum_trade);\n', '        \n', '        // Check if we are allowed to secure coins for a deal\n', '        ERC20 shitcoin = ERC20(coin.base);\n', '        require(shitcoin.allowance(msg.sender, this) >= amount);\n', '        \n', '        // Secure tokens for a deal\n', '        require(shitcoin.transferFrom(msg.sender, this, amount));\n', '\n', '        // Register an order for further processing by matcher\n', '        order_book[token].push(order_t(SELL, msg.sender, amount, price, block.number));\n', '    }\n', '    \n', '    function buy(string token, uint256 amount, uint256 price) public {\n', '        // Basic checks\n', '        require(stopped == 0);\n', '        require(total_amount(token, amount, price) == msg.value);\n', '        require(msg.value >= minimum_trade);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '        require(amount >= coin.minimum_trade);\n', '\n', '        // Credit ETX to the holder account\n', '        etx_balances[msg.sender] += msg.value;\n', '\n', '        // Register an order for further processing by matcher\n', '        order_book[token].push(order_t(BUY, msg.sender, amount, price, block.number));\n', '    }\n', '    \n', '    function trade(string token, uint maker, uint taker) public {\n', '        // Basic checks\n', '        require(msg.sender == trader);\n', '        require(maker < order_book[token].length);\n', '        require(taker < order_book[token].length);\n', '        \n', '        // Get coin\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        \n', '        // Validate coin\n', '        require(coin.state == COIN_APPROVED);\n', '\n', '        order_t make = order_book[token][maker];\n', '        order_t take = order_book[token][taker];\n', '        uint256 makerFee = 0;\n', '        uint256 takerFee = 0;\n', '        uint256 send_to_maker = 0;\n', '        uint256 send_to_taker = 0;\n', '        ERC20 shitcoin = ERC20(coin.base);\n', '        \n', '        // Check how many coins go into the deal\n', '        uint256 deal_amount = 0;\n', '        if (take.amount < make.amount) {\n', '            deal_amount = take.amount;\n', '        } else {\n', '            deal_amount = make.amount;\n', '        }\n', '        uint256 total_deal = total_amount(token, deal_amount, make.price);\n', '        \n', '        // If maker buys something\n', '        if (make.buy_sell == BUY) {\n', '            // Sanity check\n', '            require(take.price <= make.price);\n', '            \n', '            // Calculate fees\n', '            makerFee = safe_mul(deal_amount, maker_fee) / 10000;\n', '            takerFee = safe_mul(total_deal, taker_fee) / 10000;\n', '            \n', '            // Update accessible fees\n', '            coin.fee = coin.fee + makerFee;\n', '            main_fee = main_fee + takerFee;\n', '            \n', '            send_to_maker = safe_sub(deal_amount, makerFee);\n', '            send_to_taker = safe_sub(total_deal, takerFee);\n', '                \n', '            // Move shitcoin to maker\n', '            require(shitcoin.transfer(make.owner, send_to_maker));\n', '                \n', '            // Deduct from avaialble ETC balance\n', '            etx_balances[make.owner] = safe_sub(etx_balances[make.owner], total_deal);\n', '                \n', '            // Move funds to taker\n', '            require(take.owner.send(send_to_taker));\n', '                \n', '        } else {\n', '            // Sanity check\n', '            require(take.price >= make.price);\n', '            \n', '            // Calculate fees\n', '            makerFee = safe_mul(total_deal, maker_fee) / 10000;\n', '            takerFee = safe_mul(deal_amount, taker_fee) / 10000;\n', '            \n', '            // Update accessible fees\n', '            main_fee = main_fee + makerFee;\n', '            coin.fee = coin.fee + takerFee;\n', '            \n', '            send_to_maker = safe_sub(total_deal, makerFee);\n', '            send_to_taker = safe_sub(deal_amount, takerFee);\n', '                \n', '            // Move shitcoin to taker\n', '            require(shitcoin.transfer(take.owner, send_to_taker));\n', '                \n', '            // Deduct from avaialble ETC balance\n', '            etx_balances[take.owner] = safe_sub(etx_balances[take.owner], total_deal);\n', '                \n', '            // Move funds to maker\n', '            require(make.owner.send(send_to_maker));\n', '        }\n', '        \n', '        // Reduce order size\n', '        make.amount = safe_sub(make.amount, deal_amount);\n', '        take.amount = safe_sub(take.amount, deal_amount);\n', '        \n', '        // Update price\n', '        coin.price = make.price;\n', '    }\n', '    \n', '    function cancel(string token, uint256 index) public {\n', '        // Coin checks\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        order_t order = order_book[token][index];\n', '\n', '        require(coin.state == COIN_APPROVED);\n', '        require((msg.sender == order.owner) || (msg.sender == owner));\n', '        require(order.amount > 0);\n', '        \n', '        // Null the order\n', '        uint256 old_amount = order.amount;\n', '        order.amount = 0;\n', '\n', '        // Return coins\n', '        if (order.buy_sell == BUY) {\n', '            // Return back ETC\n', '            uint256 total_deal = total_amount(token, old_amount, order.price);\n', '            etx_balances[msg.sender] = safe_sub(etx_balances[msg.sender], total_deal);\n', '            require(order.owner.send(total_deal));\n', '        } else {\n', '            // Return shitcoins back \n', '            ERC20 shitcoin = ERC20(coin.base);\n', '            shitcoin.transfer(order.owner, old_amount);\n', '        }\n', '    }\n', '    \n', '    function collect_fee(string token) public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send shitcoins\n', '        coin_t coin = shitcoins[shitcoin_index[token] - 1];\n', '        if (coin.fee > 0) {\n', '            ERC20 shitcoin = ERC20(coin.base);\n', '            shitcoin.transfer(owner, coin.fee);\n', '            coin.fee = 0;\n', '        }\n', '    }\n', '    \n', '    function collect_main_fee() public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send main currency\n', '        require(owner.send(main_fee));\n', '        main_fee = 0;\n', '    }\n', '\n', '}']
