['pragma solidity ^0.4.24;\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '    \n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '}\n', '\n', 'contract Plumix is StandardToken { \n', '\n', '    /* Public variables of the token */\n', '\n', '   \n', '    string public name;                   \n', '    uint8 public decimals;                \n', '    string public symbol;                 \n', '    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', '    uint256 public minSales;                 // Minimum amount to be bought (0.01ETH)\n', '    uint256 public totalEthInWei;         \n', '    address internal fundsWallet;           \n', '    uint256 public airDropBal;\n', '    uint256 public icoSales;\n', '    uint256 public icoSalesBal;\n', '    uint256 public icoSalesCount;\n', '    bool public distributionClosed;\n', '\n', '    \n', '    modifier canDistr() {\n', '        require(!distributionClosed);\n', '        _;\n', '    }\n', '    \n', '    address owner = msg.sender;\n', '    \n', '     modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    \n', '    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n', '    event DistrClosed();\n', '    event DistrStarted();\n', '    event Burn(address indexed burner, uint256 value);\n', '    \n', '    \n', '    function endDistribution() onlyOwner canDistr public returns (bool) {\n', '        distributionClosed = true;\n', '        emit DistrClosed();\n', '        return true;\n', '    }\n', '    \n', '    function startDistribution() onlyOwner public returns (bool) {\n', '        distributionClosed = false;\n', '        emit DistrStarted();\n', '        return true;\n', '    }\n', '    \n', '\n', '    function Plumix() {\n', '        balances[msg.sender] = 10000000000e18;               \n', '        totalSupply = 10000000000e18;                        \n', '        airDropBal = 1500000000e18;\n', '        icoSales = 5000000000e18;\n', '        icoSalesBal = 5000000000e18;\n', '        name = "Plumix";                                   \n', '        decimals = 18;                                               \n', '        symbol = "PLXT";                                             \n', '        unitsOneEthCanBuy = 10000000;\n', '        minSales = 1 ether / 100; // 0.01ETH\n', '        icoSalesCount = 0;\n', '        fundsWallet = msg.sender;                                   \n', '        distributionClosed = true;\n', '        \n', '    }\n', '\n', '    function() public canDistr payable{\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        require(msg.value >= minSales);\n', '        require(amount <= icoSalesBal);\n', '        \n', '\n', '        balances[fundsWallet] = balances[fundsWallet] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        \n', '        fundsWallet.transfer(msg.value);\n', '        \n', '        icoSalesCount = icoSalesCount + amount;\n', '        icoSalesBal = icoSalesBal - amount;\n', '        if (icoSalesCount >= icoSales) {\n', '            distributionClosed = true;\n', '        }\n', '    }\n', '    \n', '    \n', ' function doAirdrop(address _participant, uint _amount) internal {\n', '\n', '        require( _amount > 0 );      \n', '\n', '        require( _amount <= airDropBal );\n', '        \n', '        balances[_participant] = balances[_participant] + _amount;\n', '        airDropBal = airDropBal - _amount ;\n', '     \n', '     // Airdrop log\n', '    emit Airdrop(_participant, _amount, balances[_participant]);  \n', '     }\n', '     \n', '     \n', '         function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        \n', '        doAirdrop(_participant, _amount);\n', '    }\n', '\n', '    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        \n', '        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);\n', '    }\n', '     \n', '    \n', '    function burn(uint256 _value) onlyOwner public {\n', '        require(_value <= balances[msg.sender]);\n', '\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner] - _value;\n', '        totalSupply = totalSupply - _value;\n', '        emit Burn(burner, _value);\n', '    }\n', '\n', '}']