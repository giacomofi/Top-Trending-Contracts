['pragma solidity ^0.4.17;\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'KWHToken' contract\n", '//\n', '// Symbol      : KWHT\n', '// Name        : KWHToken\n', '// Total supply: 900,000.000000000000000000\n', '// Decimals    : 18\n', '//\n', '// The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// Overflow math functions.\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        require(assertion);\n', '    }\n', '\n', '}\n', '\n', '\n', '// Contract Owned\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    function Owned() {\n', '\n', '        owner = msg.sender;\n', '\n', '    }\n', '\n', '    modifier onlyOwner {\n', '\n', '        require(msg.sender == owner);\n', '        _;\n', '\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '\n', '        require(newOwner != 0x0);\n', '        \n', '        owner = newOwner;\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '// Contract Token\n', '\n', 'contract Token {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', '// StandardToken\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '\n', '            balances[msg.sender] -= _value;\n', '            \n', '            balances[_to] += _value;\n', '            \n', '            Transfer(msg.sender, _to, _value);\n', '            \n', '            return true;\n', '\n', '        } else {\n', '            \n', '            return false;\n', '            \n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '\n', '            balances[_from] -= _value;\n', '            \n', '            balances[_to] += _value;\n', '            \n', '            allowed[_from][msg.sender] -= _value;\n', '            \n', '            Transfer(_from, _to, _value);\n', '            \n', '            return true;\n', '\n', '        } else {\n', '            \n', '            return false;\n', '            \n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '\n', '        return balances[_owner];\n', '\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        \n', '        return true;\n', '\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '\n', '      return allowed[_owner][_spender];\n', '\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '}\n', '\n', '\n', '\n', "// 'KWHToken' contract\n", '\n', 'contract KWHToken is SafeMath, Owned, StandardToken {\n', '\n', '    string public symbol = "KWHT";\n', '    \n', '    string public name = "KWHToken";\n', '\n', '    address public KWHTokenAddress = this;\n', '    \n', '    uint8 public decimals = 18;\n', '    \n', '    uint256 public totalSupply;\n', '    \n', '    uint256 public buyPriceEth = 5 finney;\n', '    \n', '    uint256 public sellPriceEth = 5 finney;\n', '    \n', '    uint256 public gasForKWH = 3 finney;\n', '    \n', '    uint256 public KWHForGas = 10;\n', '    \n', '    uint256 public gasReserve = 1 ether;\n', '    \n', '    uint256 public minBalanceForAccounts = 20 finney;\n', '    \n', '    bool public directTradeAllowed = false;\n', '\n', '\n', '    function KWHToken() {\n', '        \n', '        totalSupply = 900000 * 10**uint(decimals);\n', '        \n', '        balances[msg.sender] = totalSupply;\n', '        \n', '    }\n', '\n', '    function setEtherPrices(uint256 newBuyPriceEth, uint256 newSellPriceEth) onlyOwner {\n', '        \n', '        buyPriceEth = newBuyPriceEth;\n', '        \n', '        sellPriceEth = newSellPriceEth;\n', '        \n', '    }\n', '    \n', '    function setGasForKWH(uint newGasAmountInWei) onlyOwner {\n', '        \n', '        gasForKWH = newGasAmountInWei;\n', '        \n', '    }\n', '    \n', '    function setKWHForGas(uint newDCNAmount) onlyOwner {\n', '        \n', '        KWHForGas = newDCNAmount;\n', '        \n', '    }\n', '    \n', '    function setGasReserve(uint newGasReserveInWei) onlyOwner {\n', '        \n', '        gasReserve = newGasReserveInWei;\n', '    \n', '    }\n', '    \n', '    function setMinBalance(uint minimumBalanceInWei) onlyOwner {\n', '        \n', '        minBalanceForAccounts = minimumBalanceInWei;\n', '        \n', '    }\n', '\n', '\n', '// Halts or unhalts direct trades without the sell and buy functions below\n', '    function haltDirectTrade() onlyOwner {\n', '        \n', '        directTradeAllowed = false;\n', '        \n', '    }\n', '    \n', '    function unhaltDirectTrade() onlyOwner {\n', '        \n', '        directTradeAllowed = true;\n', '        \n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        \n', '        require(_value > KWHForGas);\n', '        \n', '        if (msg.sender != owner && _to == KWHTokenAddress && directTradeAllowed) {\n', '            \n', '            sellKWHAgainstEther(_value);\n', '            \n', '            return true;\n', '            \n', '        }\n', '\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            \n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\n', '            if (msg.sender.balance >= minBalanceForAccounts && _to.balance >= minBalanceForAccounts) {\n', '                \n', '                balances[_to] = safeAdd(balances[_to], _value);\n', '                \n', '                Transfer(msg.sender, _to, _value);\n', '                \n', '                return true;\n', '                \n', '            } else {\n', '                \n', '                balances[this] = safeAdd(balances[this], KWHForGas);\n', '                \n', '                balances[_to] = safeAdd(balances[_to], safeSub(_value, KWHForGas));\n', '                \n', '                Transfer(msg.sender, _to, safeSub(_value, KWHForGas));\n', '\n', '                if(msg.sender.balance < minBalanceForAccounts) {\n', '                    \n', '                    require(msg.sender.send(gasForKWH));\n', '                    \n', '                }\n', '                \n', '                if(_to.balance < minBalanceForAccounts) {\n', '                    \n', '                    require(_to.send(gasForKWH));\n', '                \n', '                }\n', '            }\n', '        } else { \n', '            throw; \n', '        }\n', '    }\n', '\n', '// User buys KWHs and pays in Ether\n', '    function buyKWHAgainstEther() payable returns (uint amount) {\n', '        \n', '        require(!(buyPriceEth == 0 || msg.value < buyPriceEth));\n', '        \n', '        amount = msg.value / buyPriceEth;\n', '        \n', '        require(!(balances[this] < amount));\n', '        \n', '        balances[msg.sender] = safeAdd(balances[msg.sender], amount);\n', '        \n', '        balances[this] = safeSub(balances[this], amount);\n', '        \n', '        Transfer(this, msg.sender, amount);\n', '        \n', '        return amount;\n', '    }\n', '\n', '\n', '// User sells KWHs and gets Ether\n', '    function sellKWHAgainstEther(uint256 amount) returns (uint revenue) {\n', '        \n', '        require(!(sellPriceEth == 0 || amount < KWHForGas));\n', '        \n', '        require(!(balances[msg.sender] < amount));\n', '        \n', '        revenue = safeMul(amount, sellPriceEth);\n', '        \n', '        require(!(safeSub(this.balance, revenue) < gasReserve));\n', '        \n', '        if (!msg.sender.send(revenue)) {\n', '            \n', '            throw;\n', '            \n', '        } else {\n', '            \n', '            balances[this] = safeAdd(balances[this], amount);\n', '            \n', '            balances[msg.sender] = safeSub(balances[msg.sender], amount);\n', '            \n', '            Transfer(this, msg.sender, revenue);\n', '            \n', '            return revenue;\n', '        }\n', '    }\n', '\n', '\n', '// Refunding owner\n', '    function refundToOwner (uint256 amountOfEth, uint256 kwh) onlyOwner {\n', '        \n', '        uint256 eth = safeMul(amountOfEth, 1 ether);\n', '        \n', '        if (!msg.sender.send(eth)) {\n', '            \n', '            throw;\n', '            \n', '        } else {\n', '            \n', '            Transfer(this, msg.sender, kwh);\n', '            \n', '        }\n', '        \n', '        require(!(balances[this] < kwh));\n', '        \n', '        balances[msg.sender] = safeAdd(balances[msg.sender], kwh);\n', '        \n', '        balances[this] = safeSub(balances[this], kwh);\n', '        \n', '        Transfer(this, msg.sender, kwh);\n', '    }\n', '\n', '\n', '    function() payable {\n', '        \n', '        if (msg.sender != owner) {\n', '            \n', '            require(directTradeAllowed);\n', '            \n', '            buyKWHAgainstEther();\n', '            \n', '        }\n', '    }\n', '}']