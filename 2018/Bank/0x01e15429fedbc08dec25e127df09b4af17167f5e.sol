['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', '* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\n', '*\n', '* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\n', '*\n', '* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\n', '* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\n', '* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\n', '*\n', '* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\n', '*\n', '* -- DEX Platform Notes --\n', '* 1. By default, only KYC&#39;ed hodlers of tokens may participate on this DEX.\n', '*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\n', '* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \n', '* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \n', '*    - Issuer is free to amend the trade execution fee percentage from time to time.\n', '*\n', '*/\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\n', '// \n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function allowance(address approver, address spender) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed approver, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '//\n', '// base contract for all our horizon contracts and tokens\n', '//\n', 'contract HorizonContractBase {\n', '    // The owner of the contract, set at contract creation to the creator.\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Contract authorization - only allow the owner to perform certain actions.\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Only the owner can call this function.");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', ' \n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' *\n', ' * Source: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// Taken from: https://dapp.tools/dappsys/ds-math.html\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', 'library DSMath {\n', '    \n', '    function dsAdd(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function dsMul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = dsAdd(dsMul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = dsAdd(dsMul(x, WAD), y / 2) / y;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\n', '*\n', '* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\n', '*\n', '* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\n', '* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\n', '* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\n', '*\n', '* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\n', '*\n', '* -- DEX Platform Notes --\n', '* 1. By default, only KYC&#39;ed hodlers of tokens may participate on this DEX.\n', '*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\n', '* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \n', '* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \n', '*    - Issuer is free to amend the trade execution fee percentage from time to time.\n', '*\n', '*/\n', 'contract VOXTrader is HorizonContractBase {\n', '    using SafeMath for uint256;\n', '    using DSMath for uint256;\n', '\n', '    struct TradeOrder {\n', '        uint256 quantity;\n', '        uint256 price;\n', '        uint256 expiry;\n', '    }\n', '\n', '    // The owner of this contract.\n', '    address public owner;\n', '\n', '    // The balances of all accounts.\n', '    mapping (address => TradeOrder) public orderBook;\n', '\n', '    // The contract containing the tokens that we trade.\n', '    address public tokenContract;\n', '\n', '    // The price paid for the last sale of tokens on this contract.\n', '    uint256 public lastSellPrice;\n', '\n', '    // The highest price an asks can be placed.\n', '    uint256 public sellCeiling;\n', '\n', '    // The lowest price an ask can be placed.\n', '    uint256 public sellFloor;\n', '\n', '    // The percentage taken off the cost of buying tokens in Ether.\n', '    uint256 public etherFeePercent;\n', '    \n', '    // The minimum Ether fee when buying tokens (if the calculated percent is less than this value);\n', '    uint256 public etherFeeMin;\n', '\n', '    // Both buying and selling tokens is restricted to only those who have successfully passed KYC.\n', '    bool public enforceKyc;\n', '\n', '    // The addresses of those allowed to trade using this contract.\n', '    mapping (address => bool) public tradingWhitelist;\n', '\n', '    // A sell order was put into the order book.\n', '    event TokensOffered(address indexed who, uint256 quantity, uint256 price, uint256 expiry);\n', '\n', '    // A user bought tokens from another user.\n', '    event TokensPurchased(address indexed purchaser, address indexed seller, uint256 quantity, uint256 price);\n', '\n', '    // A user updated their ask.\n', '    event TokenOfferChanged(address who, uint256 quantity, uint256 price, uint256 expiry);\n', '\n', '    // A user bought phone credit using a top-up voucher, buy VOX Tokens on thier behalf to convert to phone credit.\n', '    event VoucherRedeemed(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity);\n', '\n', '    // The contract has been shut down.\n', '    event ContractRetired(address newAddcontract);\n', '\n', '\n', '    /**\n', '     * @notice Set owner and the target ERC20 contract containing the tokens it trades.\n', '     *\n', '     * @param tokenContract_    The ERC20 contract whose tokens this contract trades.\n', '     */\n', '    constructor(address tokenContract_) public {\n', '        owner = msg.sender;\n', '        tokenContract = tokenContract_;\n', '\n', '        // On publication the only person allowed trade is the issuer/owner.\n', '        enforceKyc = true;\n', '        setTradingAllowed(msg.sender, true);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the trade order for the specified address.\n', '     *\n', '     * @param who    The address to get the trade order of.\n', '     */\n', '    function getOrder(address who) public view returns (uint256 quantity, uint256 price, uint256 expiry) {\n', '        TradeOrder memory order = orderBook[who];\n', '        return (order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Offer tokens for sale, you must call approve on the ERC20 contract first, giving approval to\n', '     * the address of this contract.\n', '     *\n', '     * @param quantity  The number of tokens to offer for sale.\n', '     * @param price     The unit price of the tokens.\n', '     * @param expiry    The date and time this order ends.\n', '     */\n', '    function offer(uint256 quantity, uint256 price, uint256 expiry) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(quantity > 0, "You must supply a quantity.");\n', '        require(price > 0, "The sale price cannot be zero.");\n', '        require(expiry > block.timestamp, "Cannot have an expiry date in the past.");\n', '        require(price >= sellFloor, "The ask is below the minimum allowed.");\n', '        require(sellCeiling == 0 || price <= sellCeiling, "The ask is above the maximum allowed.");\n', '\n', '        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\n', '        require(allowed >= quantity, "You must approve the transfer of tokens before offering them for sale.");\n', '\n', '        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\n', '        require(balance >= quantity, "Not enough tokens owned to complete the order.");\n', '\n', '        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);\n', '        emit TokensOffered(msg.sender, quantity, price, expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Buy tokens from an existing sell order.\n', '     *\n', '     * @param seller    The current owner of the tokens for sale.\n', '     * @param quantity  The number of tokens to buy.\n', '     * @param price     The ask price of the tokens.\n', '    */\n', '    function execute(address seller, uint256 quantity, uint256 price) public payable {\n', '        require(enforceKyc == false || (isAllowedTrade(msg.sender) && isAllowedTrade(seller)), "Buyer and Seller must be approved to trade on this exchange.");\n', '        TradeOrder memory order = orderBook[seller];\n', '        require(order.price == price, "Buy price does not match the listed sell price.");\n', '        require(block.timestamp < order.expiry, "Sell order has expired.");\n', '        require(price >= sellFloor, "The bid is below the minimum allowed.");\n', '        require(sellCeiling == 0 || price <= sellCeiling, "The bid is above the maximum allowed.");\n', '\n', '        // Deduct the sold tokens from the sell order immediateley to prevent re-entrancy.\n', '        uint256 tradeQuantity = order.quantity > quantity ? quantity : order.quantity;\n', '        order.quantity = order.quantity.sub(tradeQuantity);\n', '        if (order.quantity == 0) {\n', '            order.price = 0;\n', '            order.expiry = 0;\n', '        }\n', '        orderBook[seller] = order;\n', '\n', '        uint256 cost = tradeQuantity.wmul(order.price);\n', '        require(msg.value >= cost, "You did not send enough Ether to purchase the tokens.");\n', '\n', '        uint256 etherFee = calculateFee(cost);\n', '\n', '        if(!ERC20Interface(tokenContract).transferFrom(seller, msg.sender, tradeQuantity)) {\n', '            revert("Unable to transfer tokens from seller to buyer.");\n', '        }\n', '\n', '        // Pay the seller and if applicable the fee to the issuer.\n', '        seller.transfer(cost.sub(etherFee));\n', '        if(etherFee > 0)\n', '            owner.transfer(etherFee);\n', '\n', '        lastSellPrice = price;\n', '\n', '        emit TokensPurchased(msg.sender, seller, tradeQuantity, price);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel an outstanding order.\n', '     */\n', '    function cancel() public {\n', '        orderBook[msg.sender] = TradeOrder(0, 0, 0);\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /** @notice Allow/disallow users from participating in trading.\n', '     *\n', '     * @param who       The user \n', '     * @param canTrade  True to allow trading, false to disallow.\n', '    */\n', '    function setTradingAllowed(address who, bool canTrade) public onlyOwner {\n', '        tradingWhitelist[who] = canTrade;\n', '    }\n', '\n', '    /**\n', '     * @notice Check if a user is allowed to trade.\n', '     *\n', '     * @param who   The user to check.\n', '     */\n', '    function isAllowedTrade(address who) public view returns (bool) {\n', '        return tradingWhitelist[who];\n', '    }\n', '\n', '    /**\n', '     * @notice Restrict trading to only those who are whitelisted.  This is true during the ICO.\n', '     *\n', '     * @param enforce   True to restrict trading, false to open it up.\n', '    */\n', '    function setEnforceKyc(bool enforce) public onlyOwner {\n', '        enforceKyc = enforce;\n', '    }\n', '\n', '    /**\n', '     * @notice Modify the price of an existing ask.\n', '     *\n', '     * @param price     The new price.\n', '     */\n', '    function setOfferPrice(uint256 price) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(price >= sellFloor && (sellCeiling == 0 || price <= sellCeiling), "Updated price is out of range.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        require(order.price != 0 || order.expiry != 0, "There is no existing order to modify.");\n', '        \n', '        order.price = price;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the number of VOX Tokens offered by this user.  NOTE: to set the quantity to zero use cancel().\n', '     *\n', '     * @param quantity  The new quantity of the ask.\n', '     */\n', '    function setOfferSize(uint256 quantity) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(quantity > 0, "Size must be greater than zero, change rejected.");\n', '        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\n', '        require(balance >= quantity, "Not enough tokens owned to complete the order change.");\n', '        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\n', '        require(allowed >= quantity, "You must approve the transfer of tokens before offering them for sale.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        order.quantity = quantity;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Modify the expiry date of an existing ask.\n', '     *\n', '     * @param expiry    The new expiry date.\n', '     */\n', '    function setOfferExpiry(uint256 expiry) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(expiry > block.timestamp, "Cannot have an expiry date in the past.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        order.expiry = expiry;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);        \n', '    }\n', '\n', '    /**\n', '     * @notice Set the percent fee applied to the Ether used to pay for tokens.\n', '     *\n', '     * @param percent   The new percentage value at 18 decimal places.\n', '     */\n', '    function setEtherFeePercent(uint256 percent) public onlyOwner {\n', '        require(percent <= 100000000000000000000, "Percent must be between 0 and 100.");\n', '        etherFeePercent = percent;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the minimum amount of Ether to be deducted during a buy.\n', '     *\n', '     * @param min   The new minimum value.\n', '     */\n', '    function setEtherFeeMin(uint256 min) public onlyOwner {\n', '        etherFeeMin = min;\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the company&#39;s fee for facilitating the transfer of tokens.  The fee is in Ether so\n', '     * is deducted from the seller of the tokens.\n', '     *\n', '     * @param ethers    The amount of Ether to pay for the tokens.\n', '     * @return fee      The amount of Ether taken as a fee during a transfer.\n', '     */\n', '    function calculateFee(uint256 ethers) public view returns (uint256 fee) {\n', '\n', '        fee = ethers.wmul(etherFeePercent / 100);\n', '        if(fee < etherFeeMin)\n', '            fee = etherFeeMin;            \n', '\n', '        return fee;\n', '    }\n', '\n', '    /**\n', '     * @notice Buy from multiple sellers at once to fill a single large order.\n', '     *\n', '     * @dev This function is to reduce the transaction costs and to make the purchase a single transaction.\n', '     *\n', '     * @param sellers       The list of sellers whose tokens make up this buy.\n', '     * @param lastQuantity  The quantity of tokens to buy from the last seller on the list (the other asks\n', '     *                      are bought in full).\n', '     */\n', '    function multiExecute(address[] sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '\n', '        totalVouchers = 0;\n', '\n', '        for (uint i = 0; i < sellers.length; i++) {\n', '            TradeOrder memory to = orderBook[sellers[i]];\n', '            if(i == sellers.length-1) {\n', '                execute(sellers[i], lastQuantity, to.price);\n', '                totalVouchers += lastQuantity;\n', '            }\n', '            else {\n', '                execute(sellers[i], to.quantity, to.price);\n', '                totalVouchers += to.quantity;\n', '            }\n', '        }\n', '\n', '        return totalVouchers;\n', '    }\n', '\n', '    /**\n', '     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\n', '     * to convert a voucher to phone credit via VOX Tokens.\n', '     *\n', '     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\n', '     * @param voucherOwner  The wallet id of the user redeeming the voucher.\n', '     * @param seller        The wallet id selling the VOX Tokens needed to fill the voucher.\n', '     * @param quantity      The quantity of VOX tokens needed to fill the voucher.\n', '     */\n', '    function redeemVoucherSingle(uint256 voucherCode, address voucherOwner, address seller, uint256 quantity) public onlyOwner payable {\n', '\n', '        // Send ether to the token owner and as we buy them as the owner they get burned.\n', '        TradeOrder memory order = orderBook[seller];\n', '        execute(seller, quantity, order.price);\n', '\n', '        // Log the event so the system can detect the successful top-up and transfer credit to the voucher owner.\n', '        emit VoucherRedeemed(voucherCode, voucherOwner, seller, quantity);\n', '    }\n', '\n', '    /**\n', '     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\n', '     * to convert a voucher to phone credit via VOX Tokens.\n', '     *\n', '     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\n', '     * @param voucherOwner  The wallet id of the user redeeming the voucher.\n', '     * @param sellers       The wallet id(s) selling the VOX Tokens needed to fill the voucher.\n', '     * @param lastQuantity  The quantity of the last seller&#39;s ask to use, the other orders are used in full.\n', '     */\n', '    function redeemVoucher(uint256 voucherCode, address voucherOwner, address[] sellers, uint256 lastQuantity) public onlyOwner payable {\n', '\n', '        // Send ether to the token owner and as we buy them as the owner they get burned.\n', '        uint256 totalVouchers = multiExecute(sellers, lastQuantity);\n', '\n', '        // If we fill the voucher from multiple sellers we set the seller address to zero, the associated\n', '        // TokensPurchased events will contain the details of the orders filled.\n', '        address seller = sellers.length == 1 ? sellers[0] : 0;\n', '        emit VoucherRedeemed(voucherCode, voucherOwner, seller, totalVouchers);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the highest price an ask can be listed.\n', '     *\n', '     * @param ceiling   The new maximum price allowed for a sale.\n', '     */\n', '    function setSellCeiling(uint256 ceiling) public onlyOwner {\n', '        sellCeiling = ceiling;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the lowest price an ask can be listed.\n', '     *\n', '     * @param floor   The new minimum price allowed for a sale.\n', '     */\n', '    function setSellFloor(uint256 floor) public onlyOwner {\n', '        sellFloor = floor;\n', '    }\n', '\n', '    /**\n', '    * @dev A newer version of this contract is available and this contract is now discontinued.\n', '    *\n', '    * @param recipient      Which account would get any ether from this contract (it shouldn&#39;t have any).\n', '    * @param newContract    The address of the newer version of this contract.\n', '    */\n', '    function retire(address recipient, address newContract) public onlyOwner {\n', '        emit ContractRetired(newContract);\n', '\n', '        selfdestruct(recipient);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', '* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\n', '*\n', '* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\n', '*\n', '* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\n', '* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\n', '* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\n', '*\n', '* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\n', '*\n', '* -- DEX Platform Notes --\n', "* 1. By default, only KYC'ed hodlers of tokens may participate on this DEX.\n", '*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\n', '* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \n', '* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \n', '*    - Issuer is free to amend the trade execution fee percentage from time to time.\n', '*\n', '*/\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\n', '// \n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function allowance(address approver, address spender) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed approver, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '//\n', '// base contract for all our horizon contracts and tokens\n', '//\n', 'contract HorizonContractBase {\n', '    // The owner of the contract, set at contract creation to the creator.\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Contract authorization - only allow the owner to perform certain actions.\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Only the owner can call this function.");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', ' \n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' *\n', ' * Source: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// Taken from: https://dapp.tools/dappsys/ds-math.html\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', 'library DSMath {\n', '    \n', '    function dsAdd(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function dsMul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = dsAdd(dsMul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = dsAdd(dsMul(x, WAD), y / 2) / y;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\n', '*\n', '* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\n', '*\n', '* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\n', '* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\n', '* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\n', '*\n', '* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\n', '*\n', '* -- DEX Platform Notes --\n', "* 1. By default, only KYC'ed hodlers of tokens may participate on this DEX.\n", '*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\n', '* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \n', '* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \n', '*    - Issuer is free to amend the trade execution fee percentage from time to time.\n', '*\n', '*/\n', 'contract VOXTrader is HorizonContractBase {\n', '    using SafeMath for uint256;\n', '    using DSMath for uint256;\n', '\n', '    struct TradeOrder {\n', '        uint256 quantity;\n', '        uint256 price;\n', '        uint256 expiry;\n', '    }\n', '\n', '    // The owner of this contract.\n', '    address public owner;\n', '\n', '    // The balances of all accounts.\n', '    mapping (address => TradeOrder) public orderBook;\n', '\n', '    // The contract containing the tokens that we trade.\n', '    address public tokenContract;\n', '\n', '    // The price paid for the last sale of tokens on this contract.\n', '    uint256 public lastSellPrice;\n', '\n', '    // The highest price an asks can be placed.\n', '    uint256 public sellCeiling;\n', '\n', '    // The lowest price an ask can be placed.\n', '    uint256 public sellFloor;\n', '\n', '    // The percentage taken off the cost of buying tokens in Ether.\n', '    uint256 public etherFeePercent;\n', '    \n', '    // The minimum Ether fee when buying tokens (if the calculated percent is less than this value);\n', '    uint256 public etherFeeMin;\n', '\n', '    // Both buying and selling tokens is restricted to only those who have successfully passed KYC.\n', '    bool public enforceKyc;\n', '\n', '    // The addresses of those allowed to trade using this contract.\n', '    mapping (address => bool) public tradingWhitelist;\n', '\n', '    // A sell order was put into the order book.\n', '    event TokensOffered(address indexed who, uint256 quantity, uint256 price, uint256 expiry);\n', '\n', '    // A user bought tokens from another user.\n', '    event TokensPurchased(address indexed purchaser, address indexed seller, uint256 quantity, uint256 price);\n', '\n', '    // A user updated their ask.\n', '    event TokenOfferChanged(address who, uint256 quantity, uint256 price, uint256 expiry);\n', '\n', '    // A user bought phone credit using a top-up voucher, buy VOX Tokens on thier behalf to convert to phone credit.\n', '    event VoucherRedeemed(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity);\n', '\n', '    // The contract has been shut down.\n', '    event ContractRetired(address newAddcontract);\n', '\n', '\n', '    /**\n', '     * @notice Set owner and the target ERC20 contract containing the tokens it trades.\n', '     *\n', '     * @param tokenContract_    The ERC20 contract whose tokens this contract trades.\n', '     */\n', '    constructor(address tokenContract_) public {\n', '        owner = msg.sender;\n', '        tokenContract = tokenContract_;\n', '\n', '        // On publication the only person allowed trade is the issuer/owner.\n', '        enforceKyc = true;\n', '        setTradingAllowed(msg.sender, true);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the trade order for the specified address.\n', '     *\n', '     * @param who    The address to get the trade order of.\n', '     */\n', '    function getOrder(address who) public view returns (uint256 quantity, uint256 price, uint256 expiry) {\n', '        TradeOrder memory order = orderBook[who];\n', '        return (order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Offer tokens for sale, you must call approve on the ERC20 contract first, giving approval to\n', '     * the address of this contract.\n', '     *\n', '     * @param quantity  The number of tokens to offer for sale.\n', '     * @param price     The unit price of the tokens.\n', '     * @param expiry    The date and time this order ends.\n', '     */\n', '    function offer(uint256 quantity, uint256 price, uint256 expiry) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(quantity > 0, "You must supply a quantity.");\n', '        require(price > 0, "The sale price cannot be zero.");\n', '        require(expiry > block.timestamp, "Cannot have an expiry date in the past.");\n', '        require(price >= sellFloor, "The ask is below the minimum allowed.");\n', '        require(sellCeiling == 0 || price <= sellCeiling, "The ask is above the maximum allowed.");\n', '\n', '        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\n', '        require(allowed >= quantity, "You must approve the transfer of tokens before offering them for sale.");\n', '\n', '        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\n', '        require(balance >= quantity, "Not enough tokens owned to complete the order.");\n', '\n', '        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);\n', '        emit TokensOffered(msg.sender, quantity, price, expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Buy tokens from an existing sell order.\n', '     *\n', '     * @param seller    The current owner of the tokens for sale.\n', '     * @param quantity  The number of tokens to buy.\n', '     * @param price     The ask price of the tokens.\n', '    */\n', '    function execute(address seller, uint256 quantity, uint256 price) public payable {\n', '        require(enforceKyc == false || (isAllowedTrade(msg.sender) && isAllowedTrade(seller)), "Buyer and Seller must be approved to trade on this exchange.");\n', '        TradeOrder memory order = orderBook[seller];\n', '        require(order.price == price, "Buy price does not match the listed sell price.");\n', '        require(block.timestamp < order.expiry, "Sell order has expired.");\n', '        require(price >= sellFloor, "The bid is below the minimum allowed.");\n', '        require(sellCeiling == 0 || price <= sellCeiling, "The bid is above the maximum allowed.");\n', '\n', '        // Deduct the sold tokens from the sell order immediateley to prevent re-entrancy.\n', '        uint256 tradeQuantity = order.quantity > quantity ? quantity : order.quantity;\n', '        order.quantity = order.quantity.sub(tradeQuantity);\n', '        if (order.quantity == 0) {\n', '            order.price = 0;\n', '            order.expiry = 0;\n', '        }\n', '        orderBook[seller] = order;\n', '\n', '        uint256 cost = tradeQuantity.wmul(order.price);\n', '        require(msg.value >= cost, "You did not send enough Ether to purchase the tokens.");\n', '\n', '        uint256 etherFee = calculateFee(cost);\n', '\n', '        if(!ERC20Interface(tokenContract).transferFrom(seller, msg.sender, tradeQuantity)) {\n', '            revert("Unable to transfer tokens from seller to buyer.");\n', '        }\n', '\n', '        // Pay the seller and if applicable the fee to the issuer.\n', '        seller.transfer(cost.sub(etherFee));\n', '        if(etherFee > 0)\n', '            owner.transfer(etherFee);\n', '\n', '        lastSellPrice = price;\n', '\n', '        emit TokensPurchased(msg.sender, seller, tradeQuantity, price);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel an outstanding order.\n', '     */\n', '    function cancel() public {\n', '        orderBook[msg.sender] = TradeOrder(0, 0, 0);\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /** @notice Allow/disallow users from participating in trading.\n', '     *\n', '     * @param who       The user \n', '     * @param canTrade  True to allow trading, false to disallow.\n', '    */\n', '    function setTradingAllowed(address who, bool canTrade) public onlyOwner {\n', '        tradingWhitelist[who] = canTrade;\n', '    }\n', '\n', '    /**\n', '     * @notice Check if a user is allowed to trade.\n', '     *\n', '     * @param who   The user to check.\n', '     */\n', '    function isAllowedTrade(address who) public view returns (bool) {\n', '        return tradingWhitelist[who];\n', '    }\n', '\n', '    /**\n', '     * @notice Restrict trading to only those who are whitelisted.  This is true during the ICO.\n', '     *\n', '     * @param enforce   True to restrict trading, false to open it up.\n', '    */\n', '    function setEnforceKyc(bool enforce) public onlyOwner {\n', '        enforceKyc = enforce;\n', '    }\n', '\n', '    /**\n', '     * @notice Modify the price of an existing ask.\n', '     *\n', '     * @param price     The new price.\n', '     */\n', '    function setOfferPrice(uint256 price) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(price >= sellFloor && (sellCeiling == 0 || price <= sellCeiling), "Updated price is out of range.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        require(order.price != 0 || order.expiry != 0, "There is no existing order to modify.");\n', '        \n', '        order.price = price;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the number of VOX Tokens offered by this user.  NOTE: to set the quantity to zero use cancel().\n', '     *\n', '     * @param quantity  The new quantity of the ask.\n', '     */\n', '    function setOfferSize(uint256 quantity) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(quantity > 0, "Size must be greater than zero, change rejected.");\n', '        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\n', '        require(balance >= quantity, "Not enough tokens owned to complete the order change.");\n', '        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\n', '        require(allowed >= quantity, "You must approve the transfer of tokens before offering them for sale.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        order.quantity = quantity;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, quantity, order.price, order.expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Modify the expiry date of an existing ask.\n', '     *\n', '     * @param expiry    The new expiry date.\n', '     */\n', '    function setOfferExpiry(uint256 expiry) public {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '        require(expiry > block.timestamp, "Cannot have an expiry date in the past.");\n', '\n', '        TradeOrder memory order = orderBook[msg.sender];\n', '        order.expiry = expiry;\n', '        orderBook[msg.sender] = order;\n', '\n', '        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);        \n', '    }\n', '\n', '    /**\n', '     * @notice Set the percent fee applied to the Ether used to pay for tokens.\n', '     *\n', '     * @param percent   The new percentage value at 18 decimal places.\n', '     */\n', '    function setEtherFeePercent(uint256 percent) public onlyOwner {\n', '        require(percent <= 100000000000000000000, "Percent must be between 0 and 100.");\n', '        etherFeePercent = percent;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the minimum amount of Ether to be deducted during a buy.\n', '     *\n', '     * @param min   The new minimum value.\n', '     */\n', '    function setEtherFeeMin(uint256 min) public onlyOwner {\n', '        etherFeeMin = min;\n', '    }\n', '\n', '    /**\n', "     * @notice Calculate the company's fee for facilitating the transfer of tokens.  The fee is in Ether so\n", '     * is deducted from the seller of the tokens.\n', '     *\n', '     * @param ethers    The amount of Ether to pay for the tokens.\n', '     * @return fee      The amount of Ether taken as a fee during a transfer.\n', '     */\n', '    function calculateFee(uint256 ethers) public view returns (uint256 fee) {\n', '\n', '        fee = ethers.wmul(etherFeePercent / 100);\n', '        if(fee < etherFeeMin)\n', '            fee = etherFeeMin;            \n', '\n', '        return fee;\n', '    }\n', '\n', '    /**\n', '     * @notice Buy from multiple sellers at once to fill a single large order.\n', '     *\n', '     * @dev This function is to reduce the transaction costs and to make the purchase a single transaction.\n', '     *\n', '     * @param sellers       The list of sellers whose tokens make up this buy.\n', '     * @param lastQuantity  The quantity of tokens to buy from the last seller on the list (the other asks\n', '     *                      are bought in full).\n', '     */\n', '    function multiExecute(address[] sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {\n', '        require(enforceKyc == false || isAllowedTrade(msg.sender), "You are unknown and not allowed to trade.");\n', '\n', '        totalVouchers = 0;\n', '\n', '        for (uint i = 0; i < sellers.length; i++) {\n', '            TradeOrder memory to = orderBook[sellers[i]];\n', '            if(i == sellers.length-1) {\n', '                execute(sellers[i], lastQuantity, to.price);\n', '                totalVouchers += lastQuantity;\n', '            }\n', '            else {\n', '                execute(sellers[i], to.quantity, to.price);\n', '                totalVouchers += to.quantity;\n', '            }\n', '        }\n', '\n', '        return totalVouchers;\n', '    }\n', '\n', '    /**\n', '     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\n', '     * to convert a voucher to phone credit via VOX Tokens.\n', '     *\n', '     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\n', '     * @param voucherOwner  The wallet id of the user redeeming the voucher.\n', '     * @param seller        The wallet id selling the VOX Tokens needed to fill the voucher.\n', '     * @param quantity      The quantity of VOX tokens needed to fill the voucher.\n', '     */\n', '    function redeemVoucherSingle(uint256 voucherCode, address voucherOwner, address seller, uint256 quantity) public onlyOwner payable {\n', '\n', '        // Send ether to the token owner and as we buy them as the owner they get burned.\n', '        TradeOrder memory order = orderBook[seller];\n', '        execute(seller, quantity, order.price);\n', '\n', '        // Log the event so the system can detect the successful top-up and transfer credit to the voucher owner.\n', '        emit VoucherRedeemed(voucherCode, voucherOwner, seller, quantity);\n', '    }\n', '\n', '    /**\n', '     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\n', '     * to convert a voucher to phone credit via VOX Tokens.\n', '     *\n', '     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\n', '     * @param voucherOwner  The wallet id of the user redeeming the voucher.\n', '     * @param sellers       The wallet id(s) selling the VOX Tokens needed to fill the voucher.\n', "     * @param lastQuantity  The quantity of the last seller's ask to use, the other orders are used in full.\n", '     */\n', '    function redeemVoucher(uint256 voucherCode, address voucherOwner, address[] sellers, uint256 lastQuantity) public onlyOwner payable {\n', '\n', '        // Send ether to the token owner and as we buy them as the owner they get burned.\n', '        uint256 totalVouchers = multiExecute(sellers, lastQuantity);\n', '\n', '        // If we fill the voucher from multiple sellers we set the seller address to zero, the associated\n', '        // TokensPurchased events will contain the details of the orders filled.\n', '        address seller = sellers.length == 1 ? sellers[0] : 0;\n', '        emit VoucherRedeemed(voucherCode, voucherOwner, seller, totalVouchers);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the highest price an ask can be listed.\n', '     *\n', '     * @param ceiling   The new maximum price allowed for a sale.\n', '     */\n', '    function setSellCeiling(uint256 ceiling) public onlyOwner {\n', '        sellCeiling = ceiling;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the lowest price an ask can be listed.\n', '     *\n', '     * @param floor   The new minimum price allowed for a sale.\n', '     */\n', '    function setSellFloor(uint256 floor) public onlyOwner {\n', '        sellFloor = floor;\n', '    }\n', '\n', '    /**\n', '    * @dev A newer version of this contract is available and this contract is now discontinued.\n', '    *\n', "    * @param recipient      Which account would get any ether from this contract (it shouldn't have any).\n", '    * @param newContract    The address of the newer version of this contract.\n', '    */\n', '    function retire(address recipient, address newContract) public onlyOwner {\n', '        emit ContractRetired(newContract);\n', '\n', '        selfdestruct(recipient);\n', '    }\n', '}']
