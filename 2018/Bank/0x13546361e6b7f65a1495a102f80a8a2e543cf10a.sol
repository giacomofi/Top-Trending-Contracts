['pragma solidity 0.4.16;\n', '\n', '\n', 'library CommonLibrary {\n', '\tstruct Data {\n', '\t\tmapping (uint => Node) nodes; \n', '\t\tmapping (string => uint) nodesID;\n', '\t\tmapping (string => uint16) nodeGroups;\n', '\t\tuint16 nodeGroupID;\n', '\t\tuint nodeID;\n', '\t\tuint ownerNotationId;\n', '\t\tuint addNodeAddressId;\n', '\t}\n', '\t\n', '\tstruct Node {\n', '\t\tstring nodeName;\n', '\t\taddress producer;\n', '\t\taddress node;\n', '\t\tuint256 date;\n', '\t\tbool starmidConfirmed;\n', '\t\taddress[] outsourceConfirmed;\n', '\t\tuint16[] nodeGroup;\n', '\t\tuint8 producersPercent;\n', '\t\tuint16 nodeSocialMedia;\n', '\t}\n', '\t\n', '\tfunction addNodeGroup(Data storage self, string _newNodeGroup) returns(bool _result, uint16 _id) {\n', '\t\tif (self.nodeGroups[_newNodeGroup] == 0) {\n', '\t\t\t_id = self.nodeGroupID += 1;\n', '\t\t\tself.nodeGroups[_newNodeGroup] = self.nodeGroupID;\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction addNode(\n', '\t\tData storage self, \n', '\t\tstring _newNode, \n', '\t\tuint8 _producersPercent\n', '\t\t) returns (bool _result, uint _id) {\n', '\t\tif (self.nodesID[_newNode] < 1 && _producersPercent < 100) {\n', '\t\t\t_id = self.nodeID += 1;\n', '\t\t\trequire(self.nodeID < 1000000000000);\n', '\t\t\tself.nodes[self.nodeID].nodeName = _newNode;\n', '\t\t\tself.nodes[self.nodeID].producer = msg.sender;\n', '\t\t\tself.nodes[self.nodeID].date = block.timestamp;\n', '\t\t\tself.nodes[self.nodeID].starmidConfirmed = false;\n', '\t\t\tself.nodes[self.nodeID].producersPercent = _producersPercent;\n', '\t\t\tself.nodesID[_newNode] = self.nodeID;\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\tfunction editNode(\n', '\t    Data storage self, \n', '\t\tuint _nodeID, \n', '\t\taddress _nodeAddress, \n', '\t\tbool _isNewProducer, \n', '\t\taddress _newProducer, \n', '\t\tuint8 _newProducersPercent,\n', '\t\tbool _starmidConfirmed\n', '\t\t) returns (bool) {\n', '\t\tif (_isNewProducer == true) {\n', '\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\tself.nodes[_nodeID].producer = _newProducer;\n', '\t\t\tself.nodes[_nodeID].producersPercent = _newProducersPercent;\n', '\t\t\tself.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse {\n', '\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\tself.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction addNodeAddress(Data storage self, uint _nodeID, address _nodeAddress) returns(bool _result, uint _id) {\n', '\t\tif (msg.sender == self.nodes[_nodeID].producer) {\n', '\t\t\tif (self.nodes[_nodeID].node == 0) {\n', '\t\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\t\t_id = self.addNodeAddressId += 1;//for event count\n', '\t\t\t\t_result = true;\n', '\t\t\t}\n', '\t\t\telse _result = false;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\t//-----------------------------------------Starmid Exchange functions\n', '\tfunction stockMinSellPrice(StarCoinLibrary.Data storage self, uint _buyPrice, uint _node) constant returns (uint _minSellPrice) {\n', '\t\t_minSellPrice = _buyPrice + 1;\n', '\t\tfor (uint i = 0; i < self.stockSellOrderPrices[_node].length; i++) {\n', '\t\t\tif(self.stockSellOrderPrices[_node][i] < _minSellPrice) _minSellPrice = self.stockSellOrderPrices[_node][i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockMaxBuyPrice (StarCoinLibrary.Data storage self, uint _sellPrice, uint _node) constant returns (uint _maxBuyPrice) {\n', '\t\t_maxBuyPrice = _sellPrice - 1;\n', '\t\tfor (uint i = 0; i < self.stockBuyOrderPrices[_node].length; i++) {\n', '\t\t\tif(self.stockBuyOrderPrices[_node][i] > _maxBuyPrice) _maxBuyPrice = self.stockBuyOrderPrices[_node][i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {\n', '\t\tif (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;\n', '\t\telse _length = self.stockBuyOrders[_node][_price].length;\n', '\t\tfor (uint ii = 0; ii < _length - 1; ii++) {\n', '\t\t\tif (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t\telse self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tif (_isStockSellOrders == true) {\n', '\t\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\t\tself.stockSellOrders[_node][_price].length--;\n', '\t\t\t//Delete _price from stockSellOrderPrices[_node][] if it&#39;s the last order\n', '\t\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\t\tuint fromArg = 99999;\n', '\t\t\t\tfor (uint8 iii = 0; iii < self.stockSellOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\t\tif (self.stockSellOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t\tfromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (fromArg != 99999 && iii >= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t\t}\n', '\t\t}\n', '\t\telse {\n', '\t\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\t\tself.stockBuyOrders[_node][_price].length--;\n', '\t\t\t//Delete _price from stockBuyOrderPrices[_node][] if it&#39;s the last order\n', '\t\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\t\tfromArg = 99999;\n', '\t\t\t\tfor (iii = 0; iii < self.stockBuyOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\t\tif (self.stockBuyOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t\tfromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (fromArg != 99999 && iii >= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSaveOwnerInfo(StarCoinLibrary.Data storage self, uint _node, uint _amount, address _buyer, address _seller, uint _price) {\n', '\t\t//--------------------------------------_buyer\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumPriceAmount += _amount*_price;\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumDateAmount += _amount*block.timestamp;\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumAmount += _amount;\n', '\t\tuint16 _thisNode = 0;\n', '\t\t\tfor (uint16 i6 = 0; i6 < self.stockOwnerInfo[_buyer].nodes.length; i6++) {\n', '\t\t\t\tif (self.stockOwnerInfo[_buyer].nodes[i6] == _node) _thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (_thisNode == 0) self.stockOwnerInfo[_buyer].nodes.push(_node);\n', '\t\t//--------------------------------------_seller\n', '\t\tif(self.StockOwnersBuyPrice[_seller][_node].sumPriceAmount > 0) {\n', '\t\t\tself.StockOwnersBuyPrice[_seller][_node].sumPriceAmount -= _amount*_price;\n', '\t\t\tself.StockOwnersBuyPrice[_buyer][_node].sumDateAmount -= _amount*block.timestamp;\n', '\t\t\tself.StockOwnersBuyPrice[_buyer][_node].sumAmount -= _amount;\n', '\t\t}\n', '\t\t_thisNode = 0;\n', '\t\tfor (i6 = 0; i6 < self.stockOwnerInfo[_seller].nodes.length; i6++) {\n', '\t\t\tif (self.stockOwnerInfo[_seller].nodes[i6] == _node) _thisNode = i6;\n', '\t\t}\n', '\t\tif (_thisNode > 0) {\n', '\t\t\tfor (uint ii = _thisNode; ii < self.stockOwnerInfo[msg.sender].nodes.length - 1; ii++) {\n', '\t\t\t\tself.stockOwnerInfo[msg.sender].nodes[ii] = self.stockOwnerInfo[msg.sender].nodes[ii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockOwnerInfo[msg.sender].nodes[self.stockOwnerInfo[msg.sender].nodes.length - 1];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteStockBuyOrder(StarCoinLibrary.Data storage self, uint _iii, uint _node, uint _price) {\n', '\t\tfor (uint ii = _iii; ii < self.stockBuyOrders[_node][_price].length - 1; ii++) {\n', '\t\t\tself.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\tself.stockBuyOrders[_node][_price].length--;\n', '\t\t//Delete _price from stockBuyOrderPrices[_node][] if it&#39;s the last order\n', '\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (_iii = 0; _iii < self.stockBuyOrderPrices[_node].length - 1; _iii++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][_iii] == _price) {\n', '\t\t\t\t\t_fromArg = _iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && _iii >= _fromArg) self.stockBuyOrderPrices[_node][_iii] = self.stockBuyOrderPrices[_node][_iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteStockSellOrder(StarCoinLibrary.Data storage self, uint _iii, uint _node, uint _price) {\n', '\t\tfor (uint ii = _iii; ii < self.stockSellOrders[_node][_price].length - 1; ii++) {\n', '\t\t\tself.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\tself.stockSellOrders[_node][_price].length--;\n', '\t\t//Delete _price from stockSellOrderPrices[_node][] if it&#39;s the last order\n', '\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (_iii = 0; _iii < self.stockSellOrderPrices[_node].length - 1; _iii++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][_iii] == _price) {\n', '\t\t\t\t\t_fromArg = _iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && _iii >= _fromArg) self.stockSellOrderPrices[_node][_iii] = self.stockSellOrderPrices[_node][_iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', 'library StarCoinLibrary {\n', '\tstruct Data {\n', '\t\tuint256 lastMint;\n', '\t\tmapping (address => uint256) balanceOf;\n', '\t\tmapping (address => uint256) frozen;\n', '\t\tuint32 ordersId;\n', '\t\tmapping (uint256 => orderInfo[]) buyOrders;\n', '\t\tmapping (uint256 => orderInfo[]) sellOrders;\n', '\t\tmapping (address => mapping (uint => uint)) stockBalanceOf;\n', '\t\tmapping (address => mapping (uint => uint)) stockFrozen;\n', '\t\tmapping (uint => uint)  emissionLimits;\n', '\t\tuint32 stockOrdersId;\n', '\t\tmapping (uint => emissionNodeInfo) emissions;\n', '\t\tmapping (uint => mapping (uint256 => stockOrderInfo[])) stockBuyOrders;\n', '\t\tmapping (uint => mapping (uint256 => stockOrderInfo[])) stockSellOrders;\n', '\t\tmapping (address => mapping (uint => uint)) lastDividends;\n', '\t\tmapping (address => mapping (uint => averageBuyPrice)) StockOwnersBuyPrice;\n', '\t\tmapping (address => ownerInfo) stockOwnerInfo;\n', '\t\tuint[] buyOrderPrices;\n', '\t\tuint[] sellOrderPrices;\n', '\t\tmapping (uint => uint[]) stockBuyOrderPrices;\n', '\t\tmapping (uint => uint[]) stockSellOrderPrices;\n', '\t\tmapping (address => uint) pendingWithdrawals;\n', '\t}\n', '\tstruct orderInfo {\n', '\t\tuint date;\n', '\t\taddress client;\n', '\t\tuint256 amount;\n', '\t\tuint256 price;\n', '\t\tbool isBuyer;\n', '\t\tuint orderId;\n', '    }\n', '\tstruct emissionNodeInfo {\n', '\t\tuint emissionNumber;\n', '\t\tuint date;\n', '\t}\n', '\tstruct stockOrderInfo {\n', '\t\tuint date;\n', '\t\taddress client;\n', '\t\tuint256 amount;\n', '\t\tuint256 price;\n', '\t\tbool isBuyer;\n', '\t\tuint orderId;\n', '\t\tuint node;\n', '    }\n', '\tstruct averageBuyPrice {\n', '        uint sumPriceAmount;\n', '\t\tuint sumDateAmount;\n', '\t\tuint sumAmount;\n', '    }\n', '\tstruct ownerInfo {\n', '\t\tuint index;\n', '\t\tuint[] nodes;\n', '    }\n', '\t\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    \n', '    function buyOrder(Data storage self, uint256 _buyPrice) returns (uint[4] _results) {\n', '\t\tuint _remainingValue = msg.value;\n', '\t\tuint256[4] memory it;\n', '\t\tif (minSellPrice(self, _buyPrice) != _buyPrice + 1) {\n', '\t\t\tit[3] = self.sellOrderPrices.length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _minPrice = minSellPrice(self, _buyPrice);\n', '\t\t\t\tit[2] = self.sellOrders[_minPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tuint _amount = _remainingValue/_minPrice;\n', '\t\t\t\t\tif (_amount >= self.sellOrders[_minPrice][0].amount) {\n', '\t\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_minPrice][0].amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\t\tself.frozen[self.sellOrders[_minPrice][0].client] -= self.sellOrders[_minPrice][0].amount;// subtracts the amount from seller&#39;s frozen balance\n', '\t\t\t\t\t\tTransfer(self.sellOrders[_minPrice][0].client, msg.sender, self.sellOrders[_minPrice][0].amount);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer = _minPrice*self.sellOrders[_minPrice][0].amount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_minPrice][0].client] += amountTransfer;\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_minPrice][0].client, _minPrice, self.sellOrders[_minPrice][0].amount, \n', '\t\t\t\t\t\tself.sellOrders[_minPrice][0].orderId);\n', '\t\t\t\t\t\t_remainingValue -= amountTransfer;\n', '\t\t\t\t\t\t_results[0] += self.sellOrders[_minPrice][0].amount;\n', '\t\t\t\t\t\t//delete sellOrders[_minPrice][0] and move each element\n', '\t\t\t\t\t\tdeleteFirstOrder(self, _minPrice, true);\n', '\t\t\t\t\t\tif (_remainingValue/_minPrice < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit sellOrders[_minPrice][0]\n', '\t\t\t\t\t\tself.sellOrders[_minPrice][0].amount = self.sellOrders[_minPrice][0].amount - _amount;\n', '\t\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] += _amount;// adds the _amount to buyer&#39;s balance\n', '\t\t\t\t\t\tself.frozen[self.sellOrders[_minPrice][0].client] -= _amount;// subtracts the _amount from seller&#39;s frozen balance\n', '\t\t\t\t\t\tTransfer(self.sellOrders[_minPrice][0].client, msg.sender, _amount);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_minPrice][0].client, _minPrice, _amount, self.sellOrders[_minPrice][0].orderId);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer1 = _amount*_minPrice;\n', '\t\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_minPrice][0].client] += amountTransfer1;\n', '\t\t\t\t\t\t_remainingValue -= amountTransfer1;\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\tif(_remainingValue/_minPrice < 1) {\n', '\t\t\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_remainingValue/_minPrice < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif(_remainingValue/_buyPrice < 1) \n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns change to buyer\n', '\t\t}\n', '\t\tif (minSellPrice(self, _buyPrice) == _buyPrice + 1 && _remainingValue/_buyPrice >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _remainingValue/_buyPrice;\n', '\t\t\tif (_remainingValue - _results[1]*_buyPrice > 0) \n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue - _results[1]*_buyPrice;//returns change to buyer\n', '\t\t\tself.ordersId += 1;\n', '\t\t\t_results[2] = self.ordersId;\n', '\t\t\tself.buyOrders[_buyPrice].push(orderInfo( block.timestamp, msg.sender, _results[1], _buyPrice, true, self.ordersId));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//Add _buyPrice to buyOrderPrices[]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.buyOrderPrices.length; it[1]++) {\n', '\t\t\t\tif (self.buyOrderPrices[it[1]] == _buyPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.buyOrderPrices.push(_buyPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction minSellPrice(Data storage self, uint _buyPrice) constant returns (uint _minSellPrice) {\n', '\t\t_minSellPrice = _buyPrice + 1;\n', '\t\tfor (uint i = 0; i < self.sellOrderPrices.length; i++) {\n', '\t\t\tif(self.sellOrderPrices[i] < _minSellPrice) _minSellPrice = self.sellOrderPrices[i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction sellOrder(Data storage self, uint256 _sellPrice, uint _amount) returns (uint[4] _results) {\n', '\t\tuint _remainingAmount = _amount;\n', '\t\trequire(self.balanceOf[msg.sender] >= _amount);\n', '\t\tuint256[4] memory it;\n', '\t\tif (maxBuyPrice(self, _sellPrice) != _sellPrice - 1) {\n', '\t\t\tit[3] = self.buyOrderPrices.length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _maxPrice = maxBuyPrice(self, _sellPrice);\n', '\t\t\t\tit[2] = self.buyOrders[_maxPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_remainingAmount >= self.buyOrders[_maxPrice][0].amount) {\n', '\t\t\t\t\t\t//sell starcoins for ether\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] -= self.buyOrders[_maxPrice][0].amount;// subtracts amount from seller&#39;s balance\n', '\t\t\t\t\t\tself.balanceOf[self.buyOrders[_maxPrice][0].client] += self.buyOrders[_maxPrice][0].amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_maxPrice][0].client, self.buyOrders[_maxPrice][0].amount);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint _amountTransfer = _maxPrice*self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _amountTransfer;\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_maxPrice][0].client, msg.sender, _maxPrice, self.buyOrders[_maxPrice][0].amount, \n', '\t\t\t\t\t\tself.buyOrders[_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_remainingAmount -= self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\t//delete buyOrders[_maxPrice][0] and move each element\n', '\t\t\t\t\t\tdeleteFirstOrder(self, _maxPrice, false);\n', '\t\t\t\t\t\tif(_remainingAmount < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit buyOrders[_maxPrice][0]\n', '\t\t\t\t\t\tself.buyOrders[_maxPrice][0].amount = self.buyOrders[_maxPrice][0].amount-_remainingAmount;\n', '\t\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] -= _remainingAmount;// subtracts amount from seller&#39;s balance\n', '\t\t\t\t\t\tself.balanceOf[self.buyOrders[_maxPrice][0].client] += _remainingAmount;// adds the amount to buyer&#39;s balance \n', '\t\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_maxPrice][0].client, _remainingAmount);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_maxPrice][0].client, msg.sender, _maxPrice, _remainingAmount, self.buyOrders[_maxPrice][0].orderId);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer1 = _maxPrice*_remainingAmount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[msg.sender] += amountTransfer1;\n', '\t\t\t\t\t\t_results[0] += _remainingAmount;\n', '\t\t\t\t\t\t_remainingAmount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_remainingAmount<1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (maxBuyPrice(self, _sellPrice) == _sellPrice - 1 && _remainingAmount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _remainingAmount;\n', '\t\t\tself.ordersId += 1;\n', '\t\t\t_results[2] = self.ordersId;\n', '\t\t\tself.sellOrders[_sellPrice].push(orderInfo( block.timestamp, msg.sender, _results[1], _sellPrice, false, _results[2]));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer starcoins to the frozen balance\n', '\t\t\tself.frozen[msg.sender] += _remainingAmount;\n', '\t\t\tself.balanceOf[msg.sender] -= _remainingAmount;\n', '\t\t\t//Add _sellPrice to sellOrderPrices[]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.sellOrderPrices.length; it[1]++) {\n', '\t\t\t\tif (self.sellOrderPrices[it[1]] == _sellPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.sellOrderPrices.push(_sellPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction maxBuyPrice (Data storage self, uint _sellPrice) constant returns (uint _maxBuyPrice) {\n', '\t\t_maxBuyPrice = _sellPrice - 1;\n', '\t\tfor (uint i = 0; i < self.buyOrderPrices.length; i++) {\n', '\t\t\tif(self.buyOrderPrices[i] > _maxBuyPrice) _maxBuyPrice = self.buyOrderPrices[i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {\n', '\t\tif (_isSellOrders == true) uint _length = self.sellOrders[_price].length;\n', '\t\telse _length = self.buyOrders[_price].length;\n', '\t\tfor (uint ii = 0; ii < _length - 1; ii++) {\n', '\t\t\tif (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\telse self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];\n', '\t\t}\n', '\t\tif (_isSellOrders == true) {\n', '\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\tself.sellOrders[_price].length--;\n', '\t\t\t//Delete _price from sellOrderPrices[] if it&#39;s the last order\n', '\t\t\tif (_length == 1) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iii = 0; iii < self.sellOrderPrices.length - 1; iii++) {\n', '\t\t\t\t\tif (self.sellOrderPrices[iii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t\t}\n', '\t\t}\n', '\t\telse {\n', '\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\tself.buyOrders[_price].length--;\n', '\t\t\t//Delete _price from buyOrderPrices[] if it&#39;s the last order\n', '\t\t\tif (_length == 1) {\n', '\t\t\t\t_fromArg = 99999;\n', '\t\t\t\tfor (iii = 0; iii < self.buyOrderPrices.length - 1; iii++) {\n', '\t\t\t\t\tif (self.buyOrderPrices[iii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction cancelBuyOrder(Data storage self, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.buyOrders[_price].length; iii++) {\n', '\t\t\tif (self.buyOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\t//delete buyOrders[_price][iii] and move each element\n', '\t\t\t\trequire(msg.sender == self.buyOrders[_price][iii].client);\n', '\t\t\t\tuint _remainingValue = self.buyOrders[_price][iii].price*self.buyOrders[_price][iii].amount;\n', '\t\t\t\tfor (uint ii = iii; ii < self.buyOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\tself.buyOrders[_price][ii] = self.buyOrders[_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\t\tself.buyOrders[_price].length--;\n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns ether to buyer\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t//Delete _price from buyOrderPrices[] if it&#39;s the last order\n', '\t\tif (self.buyOrders[_price].length == 0) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iiii = 0; iiii < self.buyOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\tif (self.buyOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) self.buyOrderPrices[iiii] = self.buyOrderPrices[iiii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction cancelSellOrder(Data storage self, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.sellOrders[_price].length; iii++) {\n', '\t\t\tif (self.sellOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.sellOrders[_price][iii].client);\n', '\t\t\t\t//return starcoins from the frozen balance to seller\n', '\t\t\t\tself.frozen[msg.sender] -= self.sellOrders[_price][iii].amount;\n', '\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_price][iii].amount;\n', '\t\t\t\t//delete sellOrders[_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.sellOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\tself.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\t\tself.sellOrders[_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t//Delete _price from sellOrderPrices[] if it&#39;s the last order\n', '\t\tif (self.sellOrders[_price].length == 0) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iiii = 0; iiii < self.sellOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\tif (self.sellOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) \n', '\t\t\t\t\t\tself.sellOrderPrices[iiii] = self.sellOrderPrices[iiii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'library StarmidLibrary {\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    \n', '\tfunction stockBuyOrder(StarCoinLibrary.Data storage self, uint _node, uint256 _buyPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(self.balanceOf[msg.sender] >= _buyPrice*_amount);\n', '\t\tuint256[4] memory it;\n', '\t\tif (CommonLibrary.stockMinSellPrice(self, _buyPrice, _node) != _buyPrice + 1) {\n', '\t\t\tit[3] = self.stockSellOrderPrices[_node].length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint minPrice = CommonLibrary.stockMinSellPrice(self, _buyPrice, _node);\n', '\t\t\t\tit[2] = self.stockSellOrders[_node][minPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_amount >= self.stockSellOrders[_node][minPrice][0].amount) {\n', '\t\t\t\t\t\t//buy stocks for starcoins\n', '\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][minPrice][0].amount;// add the amount to buyer&#39;s balance\n', '\t\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][minPrice][0].client][_node] -= self.stockSellOrders[_node][minPrice][0].amount;// subtracts amount from seller&#39;s frozen stock balance\n', '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockSellOrders[_node][minPrice][0].amount, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] -= self.stockSellOrders[_node][minPrice][0].amount*minPrice;// subtracts amount from buyer&#39;s balance\n', '\t\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][minPrice][0].client] += self.stockSellOrders[_node][minPrice][0].amount*minPrice;// adds the amount to seller&#39;s balance\n', '\t\t\t\t\t\tTransfer(self.stockSellOrders[_node][minPrice][0].client, msg.sender, self.stockSellOrders[_node][minPrice][0].amount*minPrice);\n', '\t\t\t\t\t\t//save the transaction into event StocksTradeHistory;\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice, \n', '\t\t\t\t\t\tself.stockSellOrders[_node][minPrice][0].amount, self.stockSellOrders[_node][minPrice][0].orderId);\n', '\t\t\t\t\t\t_amount -= self.stockSellOrders[_node][minPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.stockSellOrders[_node][minPrice][0].amount;\n', '\t\t\t\t\t\t//delete stockSellOrders[_node][minPrice][0] and move each element\n', '\t\t\t\t\t\tCommonLibrary.stockDeleteFirstOrder(self, _node, minPrice, true);\n', '\t\t\t\t\t\tif (_amount<1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit stockSellOrders[_node][minPrice][0]\n', '\t\t\t\t\t\tself.stockSellOrders[_node][minPrice][0].amount -= _amount;\n', '\t\t\t\t\t\t//buy stocks for starcoins\n', '\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += _amount;// adds the _amount to buyer&#39;s balance\n', '\t\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][minPrice][0].client][_node] -= _amount;// subtracts _amount from seller&#39;s frozen stock balance\n', '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t    CommonLibrary.stockSaveOwnerInfo(self, _node, _amount, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] -= _amount*minPrice;// subtracts _amount from buyer&#39;s balance\n', '\t\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][minPrice][0].client] += _amount*minPrice;// adds the amount to seller&#39;s balance\n', '\t\t\t\t\t\tTransfer(self.stockSellOrders[_node][minPrice][0].client, msg.sender, _amount*minPrice);\n', '\t\t\t\t\t\t//save the transaction  into event StocksTradeHistory;\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice, \n', '\t\t\t\t\t\t_amount, self.stockSellOrders[_node][minPrice][0].orderId);\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif(_amount < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t   \t}\n', '\t\t}\n', '\t\tif (CommonLibrary.stockMinSellPrice(self, _buyPrice, _node) == _buyPrice + 1 && _amount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _amount;\n', '\t\t\tself.stockOrdersId += 1;\n', '\t\t\t_results[2] = self.stockOrdersId;\n', '\t\t\tself.stockBuyOrders[_node][_buyPrice].push(StarCoinLibrary.stockOrderInfo(block.timestamp, msg.sender, _results[1], _buyPrice, true, self.stockOrdersId, _node));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer starcoins to the frozen balance\n', '\t\t\tself.frozen[msg.sender] += _amount*_buyPrice;\n', '\t\t\tself.balanceOf[msg.sender] -= _amount*_buyPrice;\n', '\t\t\t//Add _buyPrice to stockBuyOrderPrices[_node][]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.stockBuyOrderPrices[_node].length; it[1]++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][it[1]] == _buyPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) self.stockBuyOrderPrices[_node].push(_buyPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSellOrder(StarCoinLibrary.Data storage self, uint _node, uint _sellPrice, uint _amount) returns (uint[4] _results) {\n', '\t\trequire(self.stockBalanceOf[msg.sender][_node] >= _amount);\n', '\t\tuint[4] memory it;\n', '\t\tif (CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node) != _sellPrice - 1) {\n', '\t\t\tit[3] = self.stockBuyOrderPrices[_node].length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _maxPrice = CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node);\n', '\t\t\t\tit[2] = self.stockBuyOrders[_node][_maxPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_amount >= self.stockBuyOrders[_node][_maxPrice][0].amount) {\n', '\t\t\t\t\t\t//sell stocks for starcoins\n', '\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= self.stockBuyOrders[_node][_maxPrice][0].amount;// subtracts the _amount from seller&#39;s balance \n', '\t\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_maxPrice][0].client][_node] += self.stockBuyOrders[_node][_maxPrice][0].amount;// adds the _amount to buyer&#39;s balance\n', '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockBuyOrders[_node][_maxPrice][0].amount, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _maxPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice;// adds the amount to buyer&#39;s balance \n', '\t\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_maxPrice][0].client] -= self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice;// subtracts amount from seller&#39;s frozen balance\n', '\t\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, \n', '\t\t\t\t\t\t_maxPrice, self.stockBuyOrders[_node][_maxPrice][0].amount, self.stockBuyOrders[_node][_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_amount -= self.stockBuyOrders[_node][_maxPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.stockBuyOrders[_node][_maxPrice][0].amount;\n', '\t\t\t\t\t\t//delete stockBuyOrders[_node][_maxPrice][0] and move each element\n', '\t\t\t\t\t\tCommonLibrary.stockDeleteFirstOrder(self, _node, _maxPrice, false);\n', '\t\t\t\t\t\tif(_amount < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit stockBuyOrders[_node][_maxPrice][0]\n', '\t\t\t\t\t\tself.stockBuyOrders[_node][_maxPrice][0].amount -= _amount;\n', '\t\t\t\t\t\t//sell stocks for starcoins\n', '\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;// subtracts _amount from seller&#39;s balance \n', '\t\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_maxPrice][0].client][_node] += _amount;// adds the _amount to buyer&#39;s balance\n', '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _maxPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\t\tself.balanceOf[msg.sender] += _amount*_maxPrice;// adds the _amount to buyer&#39;s balance \n', '\t\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_maxPrice][0].client] -= _amount*_maxPrice;// subtracts _amount from seller&#39;s frozen balance\n', '\t\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _amount*_maxPrice);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, \n', '\t\t\t\t\t\t_maxPrice, _amount, self.stockBuyOrders[_node][_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_amount < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node) == _sellPrice - 1 && _amount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _amount;\n', '\t\t\tself.stockOrdersId += 1;\n', '\t\t\t_results[2] = self.stockOrdersId;\n', '\t\t\tself.stockSellOrders[_node][_sellPrice].push(StarCoinLibrary.stockOrderInfo(block.timestamp, msg.sender, _results[1], _sellPrice, false, self.stockOrdersId, _node));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer stocks to the frozen stock balance\n', '\t\t\tself.stockFrozen[msg.sender][_node] += _amount;\n', '\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;\n', '\t\t\t//Add _sellPrice to stockSellOrderPrices[_node][]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.stockSellOrderPrices[_node].length; it[1]++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][it[1]] == _sellPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.stockSellOrderPrices[_node].push(_sellPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockCancelBuyOrder(StarCoinLibrary.Data storage self, uint _node, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint iii = 0; iii < self.stockBuyOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockBuyOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.stockBuyOrders[_node][_price][iii].client);\n', '\t\t\t\t//return starcoins from the buyer`s frozen balance\n', '\t\t\t\tself.frozen[msg.sender] -= self.stockBuyOrders[_node][_price][iii].amount*_price;\n', '\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_price][iii].amount*_price;\n', '\t\t\t\t//delete stockBuyOrders[_node][_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.stockBuyOrders[_node][_price].length - 1; ii++) {\n', '\t\t\t\t\tself.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\t\t\tself.stockBuyOrders[_node][_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t//Delete _price from stockBuyOrderPrices[_node][] if it&#39;s the last order\n', '\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (iii = 0; iii < self.stockBuyOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction stockCancelSellOrder(StarCoinLibrary.Data storage self, uint _node, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint iii = 0; iii < self.stockSellOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockSellOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.stockSellOrders[_node][_price][iii].client);\n', '\t\t\t\t//return stocks from the seller`s frozen stock balance\n', '\t\t\t\tself.stockFrozen[msg.sender][_node] -= self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\t//delete stockSellOrders[_node][_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.stockSellOrders[_node][_price].length - 1; ii++) {\n', '\t\t\t\t\tself.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\t\t\tself.stockSellOrders[_node][_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t//Delete _price from stockSellOrderPrices[_node][] if it&#39;s the last order\n', '\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (iii = 0; iii < self.stockSellOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'library StarmidLibraryExtra {\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\t\n', '\tfunction buyCertainOrder(StarCoinLibrary.Data storage self, uint _price, uint _thisOrderID) returns (bool) {\n', '\t\tuint _remainingValue = msg.value;\n', '\t\tfor (uint8 iii = 0; iii < self.sellOrders[_price].length; iii++) {\n', '\t\t\tif (self.sellOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\tuint _amount = _remainingValue/_price;\n', '\t\t\t\trequire(_amount <= self.sellOrders[_price][iii].amount);\n', '\t\t\t\tif (_amount == self.sellOrders[_price][iii].amount) {\n', '\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_price][iii].amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\tself.frozen[self.sellOrders[_price][iii].client] -= self.sellOrders[_price][iii].amount;// subtracts the amount from seller&#39;s frozen balance\n', '\t\t\t\t\tTransfer(self.sellOrders[_price][iii].client, msg.sender, self.sellOrders[_price][iii].amount);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_price][iii].client] += _price*self.sellOrders[_price][iii].amount;\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_price][iii].client, _price, self.sellOrders[_price][iii].amount, \n', '\t\t\t\t\tself.sellOrders[_price][iii].orderId);\n', '\t\t\t\t\t_remainingValue -= _price*self.sellOrders[_price][iii].amount;\n', '\t\t\t\t\t//delete sellOrders[_price][iii] and move each element\n', '\t\t\t\t\tfor (uint ii = iii; ii < self.sellOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\t\tself.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\t\t\t}\n', '\t\t\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\t\t\tself.sellOrders[_price].length--;\n', '\t\t\t\t\t//Delete _price from sellOrderPrices[] if it&#39;s the last order\n', '\t\t\t\t\tif (self.sellOrders[_price].length == 0) {\n', '\t\t\t\t\t\tuint fromArg = 99999;\n', '\t\t\t\t\t\tfor (ii = 0; ii < self.sellOrderPrices.length - 1; ii++) {\n', '\t\t\t\t\t\t\tif (self.sellOrderPrices[ii] == _price) {\n', '\t\t\t\t\t\t\t\tfromArg = ii;\n', '\t\t\t\t\t\t\t}\n', '\t\t\t\t\t\t\tif (fromArg != 99999 && ii >= fromArg) \n', '\t\t\t\t\t\t\t\tself.sellOrderPrices[ii] = self.sellOrderPrices[ii + 1];\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t\t\t\t}\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit sellOrders[_price][iii]\n', '\t\t\t\t\tself.sellOrders[_price][iii].amount = self.sellOrders[_price][iii].amount - _amount;\n', '\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\tself.balanceOf[msg.sender] += _amount;// adds the _amount to buyer&#39;s balance\n', '\t\t\t\t\tself.frozen[self.sellOrders[_price][iii].client] -= _amount;// subtracts the _amount from seller&#39;s frozen balance\n', '\t\t\t\t\tTransfer(self.sellOrders[_price][iii].client, msg.sender, _amount);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_price][iii].client, _price, _amount, self.sellOrders[_price][iii].orderId);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_price][iii].client] += _amount*_price;\n', '\t\t\t\t\t_remainingValue -= _amount*_price;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns change to buyer\t\t\t\t\n', '\t}\n', '\t\n', '\tfunction sellCertainOrder(StarCoinLibrary.Data storage self, uint _amount, uint _price, uint _thisOrderID) returns (bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.buyOrders[_price].length; iii++) {\n', '\t\t\tif (self.buyOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.buyOrders[_price][iii].amount && self.balanceOf[msg.sender] >= _amount);\n', '\t\t\t\tif (_amount == self.buyOrders[_price][iii].amount) {\n', '\t\t\t\t\t//sell starcoins for ether\n', '\t\t\t\t\tself.balanceOf[msg.sender] -= self.buyOrders[_price][iii].amount;// subtracts amount from seller&#39;s balance\n', '\t\t\t\t\tself.balanceOf[self.buyOrders[_price][iii].client] += self.buyOrders[_price][iii].amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_price][iii].client, self.buyOrders[_price][iii].amount);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tuint _amountTransfer = _price*self.buyOrders[_price][iii].amount;\n', '\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _amountTransfer;\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_price][iii].client, msg.sender, _price, self.buyOrders[_price][iii].amount, \n', '\t\t\t\t\tself.buyOrders[_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.buyOrders[_price][iii].amount;\n', '\t\t\t\t\t//delete buyOrders[_price][iii] and move each element\n', '\t\t\t\t\tfor (uint ii = iii; ii < self.buyOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\t\tself.buyOrders[_price][ii] = self.buyOrders[_price][ii + 1];\n', '\t\t\t\t\t}\n', '\t\t\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\t\t\tself.buyOrders[_price].length--;\n', '\t\t\t\t\t//Delete _price from buyOrderPrices[] if it&#39;s the last order\n', '\t\t\t\t\tif (self.buyOrders[_price].length == 0) {\n', '\t\t\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\t\t\tfor (uint8 iiii = 0; iiii < self.buyOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\t\t\tif (self.buyOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t\t\t}\n', '\t\t\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) self.buyOrderPrices[iiii] = self.buyOrderPrices[iiii + 1];\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t\t\t\t}\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit buyOrders[_price][iii]\n', '\t\t\t\t\tself.buyOrders[_price][iii].amount = self.buyOrders[_price][iii].amount - _amount;\n', '\t\t\t\t\t//buy starcoins for ether\n', '\t\t\t\t\tself.balanceOf[msg.sender] -= _amount;// subtracts amount from seller&#39;s balance\n', '\t\t\t\t\tself.balanceOf[self.buyOrders[_price][iii].client] += _amount;// adds the amount to buyer&#39;s balance \n', '\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_price][iii].client, _amount);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_price][iii].client, msg.sender, _price, _amount, self.buyOrders[_price][iii].orderId);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _price*_amount;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\t\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockBuyCertainOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, uint _amount, uint _thisOrderID) returns (bool) {\n', '\t\trequire(self.balanceOf[msg.sender] >= _price*_amount);\n', '\t\tfor (uint8 iii = 0; iii < self.stockSellOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockSellOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.stockSellOrders[_node][_price][iii].amount);\n', '\t\t\t\tif (_amount == self.stockSellOrders[_node][_price][iii].amount) {\n', '\t\t\t\t\t//buy stocks for starcoins\n', '\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][_price][iii].amount;// add the amount to buyer&#39;s balance\n', '\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][_price][iii].client][_node] -= self.stockSellOrders[_node][_price][iii].amount;// subtracts amount from seller&#39;s frozen stock balance\n', '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockSellOrders[_node][_price][iii].amount, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\tself.balanceOf[msg.sender] -= self.stockSellOrders[_node][_price][iii].amount*_price;// subtracts amount from buyer&#39;s balance\n', '\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][_price][iii].client] += self.stockSellOrders[_node][_price][iii].amount*_price;// adds the amount to seller&#39;s balance\n', '\t\t\t\t\tTransfer(self.stockSellOrders[_node][_price][iii].client, msg.sender, self.stockSellOrders[_node][_price][iii].amount*_price);\n', '\t\t\t\t\t//save the transaction into event StocksTradeHistory;\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price, \n', '\t\t\t\t\tself.stockSellOrders[_node][_price][iii].amount, self.stockSellOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\t\t//delete stockSellOrders[_node][_price][iii] and move each element\n', '\t\t\t\t\tCommonLibrary.deleteStockSellOrder(self, iii, _node, _price);\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit stockSellOrders[_node][_price][iii]\n', '\t\t\t\t\tself.stockSellOrders[_node][_price][iii].amount -= _amount;\n', '\t\t\t\t\t//buy stocks for starcoins\n', '\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += _amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][_price][iii].client][_node] -= _amount;// subtracts amount from seller&#39;s frozen stock balance\n', '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\tself.balanceOf[msg.sender] -= _amount*_price;// subtracts amount from buyer&#39;s balance\n', '\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][_price][iii].client] += _amount*_price;// adds the amount to seller&#39;s balance\n', '\t\t\t\t\tTransfer(self.stockSellOrders[_node][_price][iii].client, msg.sender, _amount*_price);\n', '\t\t\t\t\t//save the transaction  into event StocksTradeHistory;\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price, \n', '\t\t\t\t\t_amount, self.stockSellOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSellCertainOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, uint _amount, uint _thisOrderID) returns (bool results) {\n', '\t\tuint _remainingAmount = _amount;\n', '\t\tfor (uint8 iii = 0; iii < self.stockBuyOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockBuyOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.stockBuyOrders[_node][_price][iii].amount && self.stockBalanceOf[msg.sender][_node] >= _amount);\n', '\t\t\t\tif (_remainingAmount == self.stockBuyOrders[_node][_price][iii].amount) {\n', '\t\t\t\t\t//sell stocks for starcoins\n', '\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= self.stockBuyOrders[_node][_price][iii].amount;// subtracts amount from seller&#39;s balance \n', '\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_price][iii].client][_node] += self.stockBuyOrders[_node][_price][iii].amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockBuyOrders[_node][_price][iii].amount, self.stockBuyOrders[_node][_price][iii].client, msg.sender, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_price][iii].amount*_price;// adds the amount to buyer&#39;s balance \n', '\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_price][iii].client] -= self.stockBuyOrders[_node][_price][iii].amount*_price;// subtracts amount from seller&#39;s frozen balance\n', '\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_price][iii].client, msg.sender, self.stockBuyOrders[_node][_price][iii].amount*_price);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_price][iii].client, msg.sender, \n', '\t\t\t\t\t_price, self.stockBuyOrders[_node][_price][iii].amount, self.stockBuyOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.stockBuyOrders[_node][_price][iii].amount;\n', '\t\t\t\t\t//delete stockBuyOrders[_node][_price][iii] and move each element\n', '\t\t\t\t\tCommonLibrary.deleteStockBuyOrder(self, iii, _node, _price);\n', '\t\t\t\t\tresults = true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit stockBuyOrders[_node][_price][0]\n', '\t\t\t\t\tself.stockBuyOrders[_node][_price][iii].amount -= _amount;\n', '\t\t\t\t\t//sell stocks for starcoins\n', '\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;// subtracts amount from seller&#39;s balance \n', '\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_price][iii].client][_node] += _amount;// adds the amount to buyer&#39;s balance\n', '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, self.stockBuyOrders[_node][_price][iii].client, msg.sender, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', '\t\t\t\t\tself.balanceOf[msg.sender] += _amount*_price;// adds the amount to buyer&#39;s balance \n', '\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_price][iii].client] -= _amount*_price;// subtracts amount from seller&#39;s frozen balance\n', '\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_price][iii].client, msg.sender, _amount*_price);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_price][iii].client, msg.sender, \n', '\t\t\t\t\t_price, _amount, self.stockBuyOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\tresults = true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\t\n', '\t\t}\n', '\t}\t\n', '}\n', '\n', '\n', 'contract Nodes {\n', '\taddress public owner;\n', '\tCommonLibrary.Data public vars;\n', '\tmapping (address => string) public confirmationNodes;\n', '\tuint confirmNodeId;\n', '\tuint40 changePercentId;\n', '\tuint40 pushNodeGroupId;\n', '\tuint40 deleteNodeGroupId;\n', '\tevent NewNode(\n', '\t\tuint256 id, \n', '\t\tstring nodeName, \n', '\t\tuint8 producersPercent, \n', '\t\taddress producer, \n', '\t\tuint date\n', '\t\t);\n', '\tevent OwnerNotation(uint256 id, uint date, string newNotation);\n', '\tevent NewNodeGroup(uint16 id, string newNodeGroup);\n', '\tevent AddNodeAddress(uint id, uint nodeID, address nodeAdress);\n', '\tevent EditNode(\n', '\t\tuint nodeID,\n', '\t\taddress nodeAdress, \n', '\t\taddress newProducer, \n', '\t\tuint8 newProducersPercent,\n', '\t\tbool starmidConfirmed\n', '\t\t);\n', '\tevent ConfirmNode(uint id, uint nodeID);\n', '\tevent OutsourceConfirmNode(uint nodeID, address confirmationNode);\n', '\tevent ChangePercent(uint id, uint nodeId, uint producersPercent);\n', '\tevent PushNodeGroup(uint id, uint nodeId, uint newNodeGroup);\n', '\tevent DeleteNodeGroup(uint id, uint nodeId, uint deleteNodeGroup);\n', '\t\n', '\tfunction Nodes() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t//-----------------------------------------------------Nodes---------------------------------------------------------------\n', '\tfunction changeOwner(string _changeOwnerPassword, address _newOwnerAddress) onlyOwner returns(bool) {\n', '\t\t//One-time tool for emergency owner change\n', '\t\tif (keccak256(_changeOwnerPassword) == 0xe17a112b6fc12fc80c9b241de72da0d27ce7e244100f3c4e9358162a11bed629) {\n', '\t\t\towner = _newOwnerAddress;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse \n', '\t\t\treturn false;\n', '\t}\n', '\t\n', '\tfunction addOwnerNotations(string _newNotation) onlyOwner {\n', '\t\tuint date = block.timestamp;\n', '\t\tvars.ownerNotationId += 1;\n', '\t\tOwnerNotation(vars.ownerNotationId, date, _newNotation);\n', '\t}\n', '\t\n', '\tfunction addConfirmationNode(string _newConfirmationNode) public returns(bool) {\n', '\t\tconfirmationNodes[msg.sender] = _newConfirmationNode;\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction addNodeGroup(string _newNodeGroup) onlyOwner returns(uint16 _id) {\n', '\t\tbool result;\n', '\t\t(result, _id) = CommonLibrary.addNodeGroup(vars, _newNodeGroup);\n', '\t\trequire(result);\n', '\t\tNewNodeGroup(_id, _newNodeGroup);\n', '\t}\n', '\t\n', '\tfunction addNode(string _newNode, uint8 _producersPercent) returns(bool) {\n', '\t\tbool result;\n', '\t\tuint _id;\n', '\t\t(result, _id) = CommonLibrary.addNode(vars, _newNode, _producersPercent);\n', '\t\trequire(result);\n', '\t\tNewNode(_id, _newNode, _producersPercent, msg.sender, block.timestamp);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction editNode(\n', '\t\tuint _nodeID, \n', '\t\taddress _nodeAddress, \n', '\t\tbool _isNewProducer, \n', '\t\taddress _newProducer, \n', '\t\tuint8 _newProducersPercent,\n', '\t\tbool _starmidConfirmed\n', '\t\t) onlyOwner returns(bool) {\n', '\t\tbool x = CommonLibrary.editNode(vars, _nodeID, _nodeAddress,_isNewProducer, _newProducer, _newProducersPercent, _starmidConfirmed);\n', '\t\trequire(x);\n', '\t\tEditNode(_nodeID, _nodeAddress, _newProducer, _newProducersPercent, _starmidConfirmed);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t\n', '\tfunction addNodeAddress(uint _nodeID, address _nodeAddress) public returns(bool) {\n', '\t\tbool _result;\n', '\t\tuint _id;\n', '\t\t(_result, _id) = CommonLibrary.addNodeAddress(vars, _nodeID, _nodeAddress);\n', '\t\trequire(_result);\n', '\t\tAddNodeAddress(_id, _nodeID, _nodeAddress);\n', '\t\treturn true; \n', '\t}\n', '\t\n', '\tfunction pushNodeGroup(uint _nodeID, uint16 _newNodeGroup) public returns(bool) {\n', '\t\trequire(msg.sender == vars.nodes[_nodeID].node);\n', '\t\tvars.nodes[_nodeID].nodeGroup.push(_newNodeGroup);\n', '\t\tpushNodeGroupId += 1;\n', '\t\tPushNodeGroup(pushNodeGroupId, _nodeID, _newNodeGroup);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction deleteNodeGroup(uint _nodeID, uint16 _deleteNodeGroup) public returns(bool) {\n', '\t\trequire(msg.sender == vars.nodes[_nodeID].node);\n', '\t\tfor(uint16 i = 0; i < vars.nodes[_nodeID].nodeGroup.length; i++) {\n', '\t\t\tif(_deleteNodeGroup == vars.nodes[_nodeID].nodeGroup[i]) {\n', '\t\t\t\tfor(uint16 ii = i; ii < vars.nodes[_nodeID].nodeGroup.length - 1; ii++) \n', '\t\t\t\t\tvars.nodes[_nodeID].nodeGroup[ii] = vars.nodes[_nodeID].nodeGroup[ii + 1];\n', '\t\t    \tdelete vars.nodes[_nodeID].nodeGroup[vars.nodes[_nodeID].nodeGroup.length - 1];\n', '\t\t\t\tvars.nodes[_nodeID].nodeGroup.length--;\n', '\t\t\t\tbreak;\n', '\t\t    }\n', '\t    }\n', '\t\tdeleteNodeGroupId += 1;\n', '\t\tDeleteNodeGroup(deleteNodeGroupId, _nodeID, _deleteNodeGroup);\n', '\t\treturn true;\n', '    }\n', '\t\n', '\tfunction confirmNode(uint _nodeID) onlyOwner returns(bool) {\n', '\t\tvars.nodes[_nodeID].starmidConfirmed = true;\n', '\t\tconfirmNodeId += 1;\n', '\t\tConfirmNode(confirmNodeId, _nodeID);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction outsourceConfirmNode(uint _nodeID) public returns(bool) {\n', '\t\tvars.nodes[_nodeID].outsourceConfirmed.push(msg.sender);\n', '\t\tOutsourceConfirmNode(_nodeID, msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction changePercent(uint _nodeId, uint8 _producersPercent) public returns(bool){\n', '\t\tif(msg.sender == vars.nodes[_nodeId].producer && vars.nodes[_nodeId].node == 0x0000000000000000000000000000000000000000) {\n', '\t\t\tvars.nodes[_nodeId].producersPercent = _producersPercent;\n', '\t\t\tchangePercentId += 1;\n', '\t\t\tChangePercent(changePercentId, _nodeId, _producersPercent);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction getNodeInfo(uint _nodeID) constant public returns(\n', '\t\taddress _producer, \n', '\t\taddress _node, \n', '\t\tuint _date, \n', '\t\tbool _starmidConfirmed, \n', '\t\tstring _nodeName, \n', '\t\taddress[] _outsourceConfirmed, \n', '\t\tuint16[] _nodeGroup, \n', '\t\tuint _producersPercent\n', '\t\t) {\n', '\t\t_producer = vars.nodes[_nodeID].producer;\n', '\t\t_node = vars.nodes[_nodeID].node;\n', '\t\t_date = vars.nodes[_nodeID].date;\n', '\t\t_starmidConfirmed = vars.nodes[_nodeID].starmidConfirmed;\n', '\t\t_nodeName = vars.nodes[_nodeID].nodeName;\n', '\t\t_outsourceConfirmed = vars.nodes[_nodeID].outsourceConfirmed;\n', '\t\t_nodeGroup = vars.nodes[_nodeID].nodeGroup;\n', '\t\t_producersPercent = vars.nodes[_nodeID].producersPercent;\n', '\t}\n', '}\t\n', '\n', '\n', 'contract Starmid {\n', '\taddress public owner;\n', '\tNodes public nodesVars;\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\tStarCoinLibrary.Data public sCVars;\n', '\t\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent BuyOrder(address indexed from, uint orderId, uint buyPrice);\n', '\tevent SellOrder(address indexed from, uint orderId, uint sellPrice);\n', '\tevent CancelBuyOrder(address indexed from, uint indexed orderId, uint price);\n', '\tevent CancelSellOrder(address indexed from, uint indexed orderId, uint price);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    //----------------------------------------------------Starmid exchange\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockBuyOrder(uint node, uint buyPrice);\n', '\tevent StockSellOrder(uint node, uint sellPrice);\n', '\tevent StockCancelBuyOrder(uint node, uint price);\n', '\tevent StockCancelSellOrder(uint node, uint price);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\t\n', '\tfunction Starmid(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {\n', '\t\towner = 0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8;\n', '\t\ttotalSupply = initialSupply;  \n', '\t\tsCVars.balanceOf[msg.sender] = 5000000000;\n', '\t\tsCVars.balanceOf[0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8] = initialSupply - 5000000000;                \n', '\t\tname = tokenName;                                   \n', '\t\tsymbol = tokenSymbol;                               \n', '\t\tdecimals = decimalUnits; \n', '\t\tsCVars.lastMint = block.timestamp;\n', '\t\tsCVars.emissionLimits[1] = 500000; sCVars.emissionLimits[2] = 500000; sCVars.emissionLimits[3] = 500000;\n', '\t\tsCVars.emissionLimits[4] = 500000; sCVars.emissionLimits[5] = 500000; sCVars.emissionLimits[6] = 500000;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t//-----------------------------------------------------StarCoin Exchange------------------------------------------------------\n', '\tfunction getWithdrawal() constant public returns(uint _amount) {\n', '        _amount = sCVars.pendingWithdrawals[msg.sender];\n', '    }\n', '\t\n', '\tfunction withdraw() public returns(bool _result, uint _amount) {\n', '        _amount = sCVars.pendingWithdrawals[msg.sender];\n', '        sCVars.pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(_amount);\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction changeOwner(string _changeOwnerPassword, address _newOwnerAddress) onlyOwner returns(bool) {\n', '\t\t//One-time tool for emergency owner change\n', '\t\tif (keccak256(_changeOwnerPassword) == 0xe17a112b6fc12fc80c9b241de72da0d27ce7e244100f3c4e9358162a11bed629) {\n', '\t\t\towner = _newOwnerAddress;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse \n', '\t\t\treturn false;\n', '\t}\n', '\t\n', '\tfunction setNodesVars(address _addr) public {\n', '\t    require(msg.sender == 0xfCbA69eF1D63b0A4CcD9ceCeA429157bA48d6a9c);\n', '\t\tnodesVars = Nodes(_addr);\n', '\t}\n', '\t\n', '\tfunction getBalance(address _address) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.balanceOf[_address];\n', '\t}\n', '\t\n', '\tfunction getBuyOrderPrices() constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.buyOrderPrices;\n', '\t}\n', '\t\n', '\tfunction getSellOrderPrices() constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.sellOrderPrices;\n', '\t}\n', '\t\n', '\tfunction getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {\n', '\t\tif(_isBuyOrder == true) {\n', '\t\t\t_address = sCVars.buyOrders[_price][_number].client;\n', '\t\t\t_amount = sCVars.buyOrders[_price][_number].amount;\n', '\t\t\t_orderId = sCVars.buyOrders[_price][_number].orderId;\n', '\t\t}\n', '\t\telse {\n', '\t\t\t_address = sCVars.sellOrders[_price][_number].client;\n', '\t\t\t_amount = sCVars.sellOrders[_price][_number].amount;\n', '\t\t\t_orderId = sCVars.sellOrders[_price][_number].orderId;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction transfer(address _to, uint256 _value) public {\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '\tfunction mint() public onlyOwner returns(uint _mintedAmount) {\n', '\t\t//Minted amount does not exceed 8,5% per annum. Thus, minting does not greatly increase the total supply \n', '\t\t//and does not cause significant inflation and depreciation of the starcoin.\n', '\t\t_mintedAmount = (block.timestamp - sCVars.lastMint)*totalSupply/(12*31536000);//31536000 seconds in year\n', '\t\tsCVars.balanceOf[msg.sender] += _mintedAmount;\n', '\t\ttotalSupply += _mintedAmount;\n', '\t\tsCVars.lastMint = block.timestamp;\n', '\t\tTransfer(0, this, _mintedAmount);\n', '\t\tTransfer(this, msg.sender, _mintedAmount);\n', '\t}\n', '\t\n', '\tfunction buyOrder(uint256 _buyPrice) payable public returns (uint[4] _results) {\n', '\t\trequire(_buyPrice > 0 && msg.value > 0);\n', '\t\t_results = StarCoinLibrary.buyOrder(sCVars, _buyPrice);\n', '\t\trequire(_results[3] == 1);\n', '\t\tBuyOrder(msg.sender, _results[2], _buyPrice);\n', '\t}\n', '\t\n', '\tfunction sellOrder(uint256 _sellPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_sellPrice > 0 && _amount > 0);\n', '\t\t_results = StarCoinLibrary.sellOrder(sCVars, _sellPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tSellOrder(msg.sender, _results[2], _sellPrice);\n', '\t}\n', '\t\n', '\tfunction cancelBuyOrder(uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarCoinLibrary.cancelBuyOrder(sCVars, _thisOrderID, _price));\n', '\t\tCancelBuyOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction cancelSellOrder(uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarCoinLibrary.cancelSellOrder(sCVars, _thisOrderID, _price));\n', '\t\tCancelSellOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction _transfer(address _from, address _to, uint _value) internal {\n', '\t\trequire(_to != 0x0);\n', '        require(sCVars.balanceOf[_from] >= _value && sCVars.balanceOf[_to] + _value > sCVars.balanceOf[_to]);\n', '        sCVars.balanceOf[_from] -= _value;\n', '        sCVars.balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\t}\n', '\t\n', '\tfunction buyCertainOrder(uint _price, uint _thisOrderID) payable public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.buyCertainOrder(sCVars, _price, _thisOrderID);\n', '\t\trequire(_results && msg.value > 0);\n', '\t\tBuyOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction sellCertainOrder(uint _amount, uint _price, uint _thisOrderID) public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.sellCertainOrder(sCVars, _amount, _price, _thisOrderID);\n', '\t\trequire(_results && _amount > 0);\n', '\t\tSellOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t//------------------------------------------------------Starmid exchange----------------------------------------------------------\n', '\tfunction stockTransfer(address _to, uint _node, uint _value) public {\n', '\t\trequire(_to != 0x0);\n', '        require(sCVars.stockBalanceOf[msg.sender][_node] >= _value && sCVars.stockBalanceOf[_to][_node] + _value > sCVars.stockBalanceOf[_to][_node]);\n', '\t\tvar (x,y,) = nodesVars.getNodeInfo(_node);\n', '\t\trequire(msg.sender != y);//nodeOwner cannot transfer his stocks, only sell\n', '\t\tsCVars.stockBalanceOf[msg.sender][_node] -= _value;\n', '        sCVars.stockBalanceOf[_to][_node] += _value;\n', '        StockTransfer(msg.sender, _to, _node, _value);\n', '\t}\n', '\t\n', '\tfunction getEmission(uint _node) constant public returns(uint _emissionNumber, uint _emissionDate, uint _emissionAmount) {\n', '\t\t_emissionNumber = sCVars.emissions[_node].emissionNumber;\n', '\t\t_emissionDate = sCVars.emissions[_node].date;\n', '\t\t_emissionAmount = sCVars.emissionLimits[_emissionNumber];\n', '\t}\n', '\t\n', '\tfunction emission(uint _node) public returns(bool _result, uint _emissionNumber, uint _emissionAmount, uint _producersPercent) {\n', '\t\tvar (x,y,,,,,,z,) = nodesVars.getNodeInfo(_node);\n', '\t\taddress _nodeOwner = y;\n', '\t\taddress _nodeProducer = x;\n', '\t\t_producersPercent = z;\n', '\t\trequire(msg.sender == _nodeOwner || msg.sender == _nodeProducer);\n', '\t\tuint allStocks;\n', '\t\tfor (uint i = 1; i <= sCVars.emissions[_node].emissionNumber; i++) {\n', '\t\t\tallStocks += sCVars.emissionLimits[i];\n', '\t\t}\n', '\t\tif (_nodeOwner !=0x0000000000000000000000000000000000000000 && block.timestamp > sCVars.emissions[_node].date + 5184000 && \n', '\t\tsCVars.stockBalanceOf[_nodeOwner][_node] <= allStocks/2 ) {\n', '\t\t\t_emissionNumber = sCVars.emissions[_node].emissionNumber + 1;\n', '\t\t\tsCVars.stockBalanceOf[_nodeOwner][_node] += sCVars.emissionLimits[_emissionNumber]*(100 - _producersPercent)/100;\n', '\t\t\t//save stockOwnerInfo for _nodeOwner\n', '\t\t\tuint thisNode = 0;\n', '\t\t\tfor (i = 0; i < sCVars.stockOwnerInfo[_nodeOwner].nodes.length; i++) {\n', '\t\t\t\tif (sCVars.stockOwnerInfo[_nodeOwner].nodes[i] == _node) thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (thisNode == 0) sCVars.stockOwnerInfo[_nodeOwner].nodes.push(_node);\n', '\t\t\tsCVars.stockBalanceOf[_nodeProducer][_node] += sCVars.emissionLimits[_emissionNumber]*_producersPercent/100;\n', '\t\t\t//save stockOwnerInfo for _nodeProducer\n', '\t\t\tthisNode = 0;\n', '\t\t\tfor (i = 0; i < sCVars.stockOwnerInfo[_nodeProducer].nodes.length; i++) {\n', '\t\t\t\tif (sCVars.stockOwnerInfo[_nodeProducer].nodes[i] == _node) thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (thisNode == 0) sCVars.stockOwnerInfo[_nodeProducer].nodes.push(_node);\n', '\t\t\tsCVars.emissions[_node].date = block.timestamp;\n', '\t\t\tsCVars.emissions[_node].emissionNumber = _emissionNumber;\n', '\t\t\t_emissionAmount = sCVars.emissionLimits[_emissionNumber];\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\tfunction getStockOwnerInfo(address _address) constant public returns(uint[] _nodes) {\n', '\t\t_nodes = sCVars.stockOwnerInfo[_address].nodes;\n', '\t}\n', '\t\n', '\tfunction getStockBalance(address _address, uint _node) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.stockBalanceOf[_address][_node];\n', '\t}\n', '\t\n', '\tfunction getWithFrozenStockBalance(address _address, uint _node) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.stockBalanceOf[_address][_node] + sCVars.stockFrozen[_address][_node];\n', '\t}\n', '\t\n', '\tfunction getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {\n', '\t\tif(_isBuyOrder == true) {\n', '\t\t\t_address = sCVars.stockBuyOrders[_node][_price][_number].client;\n', '\t\t\t_amount = sCVars.stockBuyOrders[_node][_price][_number].amount;\n', '\t\t\t_orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;\n', '\t\t}\n', '\t\telse {\n', '\t\t\t_address = sCVars.stockSellOrders[_node][_price][_number].client;\n', '\t\t\t_amount = sCVars.stockSellOrders[_node][_price][_number].amount;\n', '\t\t\t_orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction getStockBuyOrderPrices(uint _node) constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.stockBuyOrderPrices[_node];\n', '\t}\n', '\t\n', '\tfunction getStockSellOrderPrices(uint _node) constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.stockSellOrderPrices[_node];\n', '\t}\n', '\t\n', '\tfunction stockBuyOrder(uint _node, uint256 _buyPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_node > 0 && _buyPrice > 0 && _amount > 0);\n', '\t\t_results = StarmidLibrary.stockBuyOrder(sCVars, _node, _buyPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tStockBuyOrder(_node, _buyPrice);\n', '\t}\n', '\t\n', '\tfunction stockSellOrder(uint _node, uint256 _sellPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_node > 0 && _sellPrice > 0 && _amount > 0);\n', '\t\t_results = StarmidLibrary.stockSellOrder(sCVars, _node, _sellPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tStockSellOrder(_node, _sellPrice);\n', '\t}\n', '\t\n', '\tfunction stockCancelBuyOrder(uint _node, uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarmidLibrary.stockCancelBuyOrder(sCVars, _node, _thisOrderID, _price));\n', '\t\tStockCancelBuyOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction stockCancelSellOrder(uint _node, uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarmidLibrary.stockCancelSellOrder(sCVars, _node, _thisOrderID, _price));\n', '\t\tStockCancelSellOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction getLastDividends(uint _node) public constant returns (uint _lastDividents, uint _dividends) {\n', '\t\tuint stockAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tuint sumAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tif(sumAmount > 0) {\n', '\t\t\tuint stockAverageBuyPrice = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumPriceAmount/sumAmount;\n', '\t\t\tuint dividendsBase = stockAmount*stockAverageBuyPrice;\n', '\t\t\t_lastDividents = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount/sumAmount;\n', '\t\t\tif(_lastDividents > 0)_dividends = (block.timestamp - _lastDividents)*dividendsBase/(10*31536000);\n', '\t\t\telse _dividends = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t//--------------------------------Dividends (10% to stock owner, 2,5% to node owner per annum)------------------------------------\n', '\tfunction dividends(uint _node) public returns (bool _result, uint _dividends) {\n', '\t\tvar (x,y,) = nodesVars.getNodeInfo(_node);\n', '\t\tuint _stockAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tuint _sumAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tif(_sumAmount > 0) {\n', '\t\t\tuint _stockAverageBuyPrice = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumPriceAmount/_sumAmount;\n', '\t\t\tuint _dividendsBase = _stockAmount*_stockAverageBuyPrice;\n', '\t\t\tuint _averageDate = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount/_sumAmount;\n', '\t\t\t//Stock owner`s dividends\n', '\t\t\tuint _div = (block.timestamp - _averageDate)*_dividendsBase/(10*31536000);//31536000 seconds in year\n', '\t\t\tsCVars.balanceOf[msg.sender] += _div;\n', '\t\t\t//Node owner`s dividends\n', '\t\t\tuint _nodeDividends = (block.timestamp - _averageDate)*_dividendsBase/(40*31536000);//31536000 seconds in year\n', '\t\t\tsCVars.balanceOf[y] += _nodeDividends;\n', '\t\t\tsCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount = block.timestamp*_stockAmount;//set new average dividends date\n', '\t\t\ttotalSupply += _div + _div/4;\n', '\t\t\t_dividends =  _div + _div/4;\n', '\t\t\tTransfer(this, msg.sender, _div);\t\n', '\t\t\tTransfer(this, y, _div/4);\t\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockBuyCertainOrder(uint _node, uint _price, uint _amount, uint _thisOrderID) payable public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.stockBuyCertainOrder(sCVars, _node, _price, _amount, _thisOrderID);\n', '\t\trequire(_results && _node > 0 && _amount > 0);\n', '\t\tStockBuyOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction stockSellCertainOrder(uint _node, uint _price, uint _amount, uint _thisOrderID) public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.stockSellCertainOrder(sCVars, _node, _price, _amount, _thisOrderID);\n', '\t\trequire(_results && _node > 0 && _amount > 0);\n', '\t\tStockSellOrder(_node, _price);\n', '\t}\n', '}']
['pragma solidity 0.4.16;\n', '\n', '\n', 'library CommonLibrary {\n', '\tstruct Data {\n', '\t\tmapping (uint => Node) nodes; \n', '\t\tmapping (string => uint) nodesID;\n', '\t\tmapping (string => uint16) nodeGroups;\n', '\t\tuint16 nodeGroupID;\n', '\t\tuint nodeID;\n', '\t\tuint ownerNotationId;\n', '\t\tuint addNodeAddressId;\n', '\t}\n', '\t\n', '\tstruct Node {\n', '\t\tstring nodeName;\n', '\t\taddress producer;\n', '\t\taddress node;\n', '\t\tuint256 date;\n', '\t\tbool starmidConfirmed;\n', '\t\taddress[] outsourceConfirmed;\n', '\t\tuint16[] nodeGroup;\n', '\t\tuint8 producersPercent;\n', '\t\tuint16 nodeSocialMedia;\n', '\t}\n', '\t\n', '\tfunction addNodeGroup(Data storage self, string _newNodeGroup) returns(bool _result, uint16 _id) {\n', '\t\tif (self.nodeGroups[_newNodeGroup] == 0) {\n', '\t\t\t_id = self.nodeGroupID += 1;\n', '\t\t\tself.nodeGroups[_newNodeGroup] = self.nodeGroupID;\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction addNode(\n', '\t\tData storage self, \n', '\t\tstring _newNode, \n', '\t\tuint8 _producersPercent\n', '\t\t) returns (bool _result, uint _id) {\n', '\t\tif (self.nodesID[_newNode] < 1 && _producersPercent < 100) {\n', '\t\t\t_id = self.nodeID += 1;\n', '\t\t\trequire(self.nodeID < 1000000000000);\n', '\t\t\tself.nodes[self.nodeID].nodeName = _newNode;\n', '\t\t\tself.nodes[self.nodeID].producer = msg.sender;\n', '\t\t\tself.nodes[self.nodeID].date = block.timestamp;\n', '\t\t\tself.nodes[self.nodeID].starmidConfirmed = false;\n', '\t\t\tself.nodes[self.nodeID].producersPercent = _producersPercent;\n', '\t\t\tself.nodesID[_newNode] = self.nodeID;\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\tfunction editNode(\n', '\t    Data storage self, \n', '\t\tuint _nodeID, \n', '\t\taddress _nodeAddress, \n', '\t\tbool _isNewProducer, \n', '\t\taddress _newProducer, \n', '\t\tuint8 _newProducersPercent,\n', '\t\tbool _starmidConfirmed\n', '\t\t) returns (bool) {\n', '\t\tif (_isNewProducer == true) {\n', '\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\tself.nodes[_nodeID].producer = _newProducer;\n', '\t\t\tself.nodes[_nodeID].producersPercent = _newProducersPercent;\n', '\t\t\tself.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse {\n', '\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\tself.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction addNodeAddress(Data storage self, uint _nodeID, address _nodeAddress) returns(bool _result, uint _id) {\n', '\t\tif (msg.sender == self.nodes[_nodeID].producer) {\n', '\t\t\tif (self.nodes[_nodeID].node == 0) {\n', '\t\t\t\tself.nodes[_nodeID].node = _nodeAddress;\n', '\t\t\t\t_id = self.addNodeAddressId += 1;//for event count\n', '\t\t\t\t_result = true;\n', '\t\t\t}\n', '\t\t\telse _result = false;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\t//-----------------------------------------Starmid Exchange functions\n', '\tfunction stockMinSellPrice(StarCoinLibrary.Data storage self, uint _buyPrice, uint _node) constant returns (uint _minSellPrice) {\n', '\t\t_minSellPrice = _buyPrice + 1;\n', '\t\tfor (uint i = 0; i < self.stockSellOrderPrices[_node].length; i++) {\n', '\t\t\tif(self.stockSellOrderPrices[_node][i] < _minSellPrice) _minSellPrice = self.stockSellOrderPrices[_node][i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockMaxBuyPrice (StarCoinLibrary.Data storage self, uint _sellPrice, uint _node) constant returns (uint _maxBuyPrice) {\n', '\t\t_maxBuyPrice = _sellPrice - 1;\n', '\t\tfor (uint i = 0; i < self.stockBuyOrderPrices[_node].length; i++) {\n', '\t\t\tif(self.stockBuyOrderPrices[_node][i] > _maxBuyPrice) _maxBuyPrice = self.stockBuyOrderPrices[_node][i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {\n', '\t\tif (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;\n', '\t\telse _length = self.stockBuyOrders[_node][_price].length;\n', '\t\tfor (uint ii = 0; ii < _length - 1; ii++) {\n', '\t\t\tif (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t\telse self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tif (_isStockSellOrders == true) {\n', '\t\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\t\tself.stockSellOrders[_node][_price].length--;\n', "\t\t\t//Delete _price from stockSellOrderPrices[_node][] if it's the last order\n", '\t\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\t\tuint fromArg = 99999;\n', '\t\t\t\tfor (uint8 iii = 0; iii < self.stockSellOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\t\tif (self.stockSellOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t\tfromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (fromArg != 99999 && iii >= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t\t}\n', '\t\t}\n', '\t\telse {\n', '\t\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\t\tself.stockBuyOrders[_node][_price].length--;\n', "\t\t\t//Delete _price from stockBuyOrderPrices[_node][] if it's the last order\n", '\t\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\t\tfromArg = 99999;\n', '\t\t\t\tfor (iii = 0; iii < self.stockBuyOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\t\tif (self.stockBuyOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t\tfromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (fromArg != 99999 && iii >= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSaveOwnerInfo(StarCoinLibrary.Data storage self, uint _node, uint _amount, address _buyer, address _seller, uint _price) {\n', '\t\t//--------------------------------------_buyer\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumPriceAmount += _amount*_price;\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumDateAmount += _amount*block.timestamp;\n', '\t\tself.StockOwnersBuyPrice[_buyer][_node].sumAmount += _amount;\n', '\t\tuint16 _thisNode = 0;\n', '\t\t\tfor (uint16 i6 = 0; i6 < self.stockOwnerInfo[_buyer].nodes.length; i6++) {\n', '\t\t\t\tif (self.stockOwnerInfo[_buyer].nodes[i6] == _node) _thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (_thisNode == 0) self.stockOwnerInfo[_buyer].nodes.push(_node);\n', '\t\t//--------------------------------------_seller\n', '\t\tif(self.StockOwnersBuyPrice[_seller][_node].sumPriceAmount > 0) {\n', '\t\t\tself.StockOwnersBuyPrice[_seller][_node].sumPriceAmount -= _amount*_price;\n', '\t\t\tself.StockOwnersBuyPrice[_buyer][_node].sumDateAmount -= _amount*block.timestamp;\n', '\t\t\tself.StockOwnersBuyPrice[_buyer][_node].sumAmount -= _amount;\n', '\t\t}\n', '\t\t_thisNode = 0;\n', '\t\tfor (i6 = 0; i6 < self.stockOwnerInfo[_seller].nodes.length; i6++) {\n', '\t\t\tif (self.stockOwnerInfo[_seller].nodes[i6] == _node) _thisNode = i6;\n', '\t\t}\n', '\t\tif (_thisNode > 0) {\n', '\t\t\tfor (uint ii = _thisNode; ii < self.stockOwnerInfo[msg.sender].nodes.length - 1; ii++) {\n', '\t\t\t\tself.stockOwnerInfo[msg.sender].nodes[ii] = self.stockOwnerInfo[msg.sender].nodes[ii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockOwnerInfo[msg.sender].nodes[self.stockOwnerInfo[msg.sender].nodes.length - 1];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteStockBuyOrder(StarCoinLibrary.Data storage self, uint _iii, uint _node, uint _price) {\n', '\t\tfor (uint ii = _iii; ii < self.stockBuyOrders[_node][_price].length - 1; ii++) {\n', '\t\t\tself.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\tself.stockBuyOrders[_node][_price].length--;\n', "\t\t//Delete _price from stockBuyOrderPrices[_node][] if it's the last order\n", '\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (_iii = 0; _iii < self.stockBuyOrderPrices[_node].length - 1; _iii++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][_iii] == _price) {\n', '\t\t\t\t\t_fromArg = _iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && _iii >= _fromArg) self.stockBuyOrderPrices[_node][_iii] = self.stockBuyOrderPrices[_node][_iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteStockSellOrder(StarCoinLibrary.Data storage self, uint _iii, uint _node, uint _price) {\n', '\t\tfor (uint ii = _iii; ii < self.stockSellOrders[_node][_price].length - 1; ii++) {\n', '\t\t\tself.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t}\n', '\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\tself.stockSellOrders[_node][_price].length--;\n', "\t\t//Delete _price from stockSellOrderPrices[_node][] if it's the last order\n", '\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (_iii = 0; _iii < self.stockSellOrderPrices[_node].length - 1; _iii++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][_iii] == _price) {\n', '\t\t\t\t\t_fromArg = _iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && _iii >= _fromArg) self.stockSellOrderPrices[_node][_iii] = self.stockSellOrderPrices[_node][_iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', 'library StarCoinLibrary {\n', '\tstruct Data {\n', '\t\tuint256 lastMint;\n', '\t\tmapping (address => uint256) balanceOf;\n', '\t\tmapping (address => uint256) frozen;\n', '\t\tuint32 ordersId;\n', '\t\tmapping (uint256 => orderInfo[]) buyOrders;\n', '\t\tmapping (uint256 => orderInfo[]) sellOrders;\n', '\t\tmapping (address => mapping (uint => uint)) stockBalanceOf;\n', '\t\tmapping (address => mapping (uint => uint)) stockFrozen;\n', '\t\tmapping (uint => uint)  emissionLimits;\n', '\t\tuint32 stockOrdersId;\n', '\t\tmapping (uint => emissionNodeInfo) emissions;\n', '\t\tmapping (uint => mapping (uint256 => stockOrderInfo[])) stockBuyOrders;\n', '\t\tmapping (uint => mapping (uint256 => stockOrderInfo[])) stockSellOrders;\n', '\t\tmapping (address => mapping (uint => uint)) lastDividends;\n', '\t\tmapping (address => mapping (uint => averageBuyPrice)) StockOwnersBuyPrice;\n', '\t\tmapping (address => ownerInfo) stockOwnerInfo;\n', '\t\tuint[] buyOrderPrices;\n', '\t\tuint[] sellOrderPrices;\n', '\t\tmapping (uint => uint[]) stockBuyOrderPrices;\n', '\t\tmapping (uint => uint[]) stockSellOrderPrices;\n', '\t\tmapping (address => uint) pendingWithdrawals;\n', '\t}\n', '\tstruct orderInfo {\n', '\t\tuint date;\n', '\t\taddress client;\n', '\t\tuint256 amount;\n', '\t\tuint256 price;\n', '\t\tbool isBuyer;\n', '\t\tuint orderId;\n', '    }\n', '\tstruct emissionNodeInfo {\n', '\t\tuint emissionNumber;\n', '\t\tuint date;\n', '\t}\n', '\tstruct stockOrderInfo {\n', '\t\tuint date;\n', '\t\taddress client;\n', '\t\tuint256 amount;\n', '\t\tuint256 price;\n', '\t\tbool isBuyer;\n', '\t\tuint orderId;\n', '\t\tuint node;\n', '    }\n', '\tstruct averageBuyPrice {\n', '        uint sumPriceAmount;\n', '\t\tuint sumDateAmount;\n', '\t\tuint sumAmount;\n', '    }\n', '\tstruct ownerInfo {\n', '\t\tuint index;\n', '\t\tuint[] nodes;\n', '    }\n', '\t\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    \n', '    function buyOrder(Data storage self, uint256 _buyPrice) returns (uint[4] _results) {\n', '\t\tuint _remainingValue = msg.value;\n', '\t\tuint256[4] memory it;\n', '\t\tif (minSellPrice(self, _buyPrice) != _buyPrice + 1) {\n', '\t\t\tit[3] = self.sellOrderPrices.length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _minPrice = minSellPrice(self, _buyPrice);\n', '\t\t\t\tit[2] = self.sellOrders[_minPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tuint _amount = _remainingValue/_minPrice;\n', '\t\t\t\t\tif (_amount >= self.sellOrders[_minPrice][0].amount) {\n', '\t\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_minPrice][0].amount;// adds the amount to buyer's balance\n", "\t\t\t\t\t\tself.frozen[self.sellOrders[_minPrice][0].client] -= self.sellOrders[_minPrice][0].amount;// subtracts the amount from seller's frozen balance\n", '\t\t\t\t\t\tTransfer(self.sellOrders[_minPrice][0].client, msg.sender, self.sellOrders[_minPrice][0].amount);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer = _minPrice*self.sellOrders[_minPrice][0].amount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_minPrice][0].client] += amountTransfer;\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_minPrice][0].client, _minPrice, self.sellOrders[_minPrice][0].amount, \n', '\t\t\t\t\t\tself.sellOrders[_minPrice][0].orderId);\n', '\t\t\t\t\t\t_remainingValue -= amountTransfer;\n', '\t\t\t\t\t\t_results[0] += self.sellOrders[_minPrice][0].amount;\n', '\t\t\t\t\t\t//delete sellOrders[_minPrice][0] and move each element\n', '\t\t\t\t\t\tdeleteFirstOrder(self, _minPrice, true);\n', '\t\t\t\t\t\tif (_remainingValue/_minPrice < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit sellOrders[_minPrice][0]\n', '\t\t\t\t\t\tself.sellOrders[_minPrice][0].amount = self.sellOrders[_minPrice][0].amount - _amount;\n', '\t\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] += _amount;// adds the _amount to buyer's balance\n", "\t\t\t\t\t\tself.frozen[self.sellOrders[_minPrice][0].client] -= _amount;// subtracts the _amount from seller's frozen balance\n", '\t\t\t\t\t\tTransfer(self.sellOrders[_minPrice][0].client, msg.sender, _amount);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_minPrice][0].client, _minPrice, _amount, self.sellOrders[_minPrice][0].orderId);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer1 = _amount*_minPrice;\n', '\t\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_minPrice][0].client] += amountTransfer1;\n', '\t\t\t\t\t\t_remainingValue -= amountTransfer1;\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\tif(_remainingValue/_minPrice < 1) {\n', '\t\t\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_remainingValue/_minPrice < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif(_remainingValue/_buyPrice < 1) \n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns change to buyer\n', '\t\t}\n', '\t\tif (minSellPrice(self, _buyPrice) == _buyPrice + 1 && _remainingValue/_buyPrice >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _remainingValue/_buyPrice;\n', '\t\t\tif (_remainingValue - _results[1]*_buyPrice > 0) \n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue - _results[1]*_buyPrice;//returns change to buyer\n', '\t\t\tself.ordersId += 1;\n', '\t\t\t_results[2] = self.ordersId;\n', '\t\t\tself.buyOrders[_buyPrice].push(orderInfo( block.timestamp, msg.sender, _results[1], _buyPrice, true, self.ordersId));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//Add _buyPrice to buyOrderPrices[]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.buyOrderPrices.length; it[1]++) {\n', '\t\t\t\tif (self.buyOrderPrices[it[1]] == _buyPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.buyOrderPrices.push(_buyPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction minSellPrice(Data storage self, uint _buyPrice) constant returns (uint _minSellPrice) {\n', '\t\t_minSellPrice = _buyPrice + 1;\n', '\t\tfor (uint i = 0; i < self.sellOrderPrices.length; i++) {\n', '\t\t\tif(self.sellOrderPrices[i] < _minSellPrice) _minSellPrice = self.sellOrderPrices[i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction sellOrder(Data storage self, uint256 _sellPrice, uint _amount) returns (uint[4] _results) {\n', '\t\tuint _remainingAmount = _amount;\n', '\t\trequire(self.balanceOf[msg.sender] >= _amount);\n', '\t\tuint256[4] memory it;\n', '\t\tif (maxBuyPrice(self, _sellPrice) != _sellPrice - 1) {\n', '\t\t\tit[3] = self.buyOrderPrices.length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _maxPrice = maxBuyPrice(self, _sellPrice);\n', '\t\t\t\tit[2] = self.buyOrders[_maxPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_remainingAmount >= self.buyOrders[_maxPrice][0].amount) {\n', '\t\t\t\t\t\t//sell starcoins for ether\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] -= self.buyOrders[_maxPrice][0].amount;// subtracts amount from seller's balance\n", "\t\t\t\t\t\tself.balanceOf[self.buyOrders[_maxPrice][0].client] += self.buyOrders[_maxPrice][0].amount;// adds the amount to buyer's balance\n", '\t\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_maxPrice][0].client, self.buyOrders[_maxPrice][0].amount);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint _amountTransfer = _maxPrice*self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _amountTransfer;\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_maxPrice][0].client, msg.sender, _maxPrice, self.buyOrders[_maxPrice][0].amount, \n', '\t\t\t\t\t\tself.buyOrders[_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_remainingAmount -= self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.buyOrders[_maxPrice][0].amount;\n', '\t\t\t\t\t\t//delete buyOrders[_maxPrice][0] and move each element\n', '\t\t\t\t\t\tdeleteFirstOrder(self, _maxPrice, false);\n', '\t\t\t\t\t\tif(_remainingAmount < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit buyOrders[_maxPrice][0]\n', '\t\t\t\t\t\tself.buyOrders[_maxPrice][0].amount = self.buyOrders[_maxPrice][0].amount-_remainingAmount;\n', '\t\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] -= _remainingAmount;// subtracts amount from seller's balance\n", "\t\t\t\t\t\tself.balanceOf[self.buyOrders[_maxPrice][0].client] += _remainingAmount;// adds the amount to buyer's balance \n", '\t\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_maxPrice][0].client, _remainingAmount);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_maxPrice][0].client, msg.sender, _maxPrice, _remainingAmount, self.buyOrders[_maxPrice][0].orderId);\n', '\t\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\t\tuint256 amountTransfer1 = _maxPrice*_remainingAmount;\n', '\t\t\t\t\t\tself.pendingWithdrawals[msg.sender] += amountTransfer1;\n', '\t\t\t\t\t\t_results[0] += _remainingAmount;\n', '\t\t\t\t\t\t_remainingAmount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_remainingAmount<1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (maxBuyPrice(self, _sellPrice) == _sellPrice - 1 && _remainingAmount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _remainingAmount;\n', '\t\t\tself.ordersId += 1;\n', '\t\t\t_results[2] = self.ordersId;\n', '\t\t\tself.sellOrders[_sellPrice].push(orderInfo( block.timestamp, msg.sender, _results[1], _sellPrice, false, _results[2]));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer starcoins to the frozen balance\n', '\t\t\tself.frozen[msg.sender] += _remainingAmount;\n', '\t\t\tself.balanceOf[msg.sender] -= _remainingAmount;\n', '\t\t\t//Add _sellPrice to sellOrderPrices[]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.sellOrderPrices.length; it[1]++) {\n', '\t\t\t\tif (self.sellOrderPrices[it[1]] == _sellPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.sellOrderPrices.push(_sellPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction maxBuyPrice (Data storage self, uint _sellPrice) constant returns (uint _maxBuyPrice) {\n', '\t\t_maxBuyPrice = _sellPrice - 1;\n', '\t\tfor (uint i = 0; i < self.buyOrderPrices.length; i++) {\n', '\t\t\tif(self.buyOrderPrices[i] > _maxBuyPrice) _maxBuyPrice = self.buyOrderPrices[i];\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {\n', '\t\tif (_isSellOrders == true) uint _length = self.sellOrders[_price].length;\n', '\t\telse _length = self.buyOrders[_price].length;\n', '\t\tfor (uint ii = 0; ii < _length - 1; ii++) {\n', '\t\t\tif (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\telse self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];\n', '\t\t}\n', '\t\tif (_isSellOrders == true) {\n', '\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\tself.sellOrders[_price].length--;\n', "\t\t\t//Delete _price from sellOrderPrices[] if it's the last order\n", '\t\t\tif (_length == 1) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iii = 0; iii < self.sellOrderPrices.length - 1; iii++) {\n', '\t\t\t\t\tif (self.sellOrderPrices[iii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t\t}\n', '\t\t}\n', '\t\telse {\n', '\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\tself.buyOrders[_price].length--;\n', "\t\t\t//Delete _price from buyOrderPrices[] if it's the last order\n", '\t\t\tif (_length == 1) {\n', '\t\t\t\t_fromArg = 99999;\n', '\t\t\t\tfor (iii = 0; iii < self.buyOrderPrices.length - 1; iii++) {\n', '\t\t\t\t\tif (self.buyOrderPrices[iii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction cancelBuyOrder(Data storage self, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.buyOrders[_price].length; iii++) {\n', '\t\t\tif (self.buyOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\t//delete buyOrders[_price][iii] and move each element\n', '\t\t\t\trequire(msg.sender == self.buyOrders[_price][iii].client);\n', '\t\t\t\tuint _remainingValue = self.buyOrders[_price][iii].price*self.buyOrders[_price][iii].amount;\n', '\t\t\t\tfor (uint ii = iii; ii < self.buyOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\tself.buyOrders[_price][ii] = self.buyOrders[_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\t\tself.buyOrders[_price].length--;\n', '\t\t\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns ether to buyer\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', "\t\t//Delete _price from buyOrderPrices[] if it's the last order\n", '\t\tif (self.buyOrders[_price].length == 0) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iiii = 0; iiii < self.buyOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\tif (self.buyOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) self.buyOrderPrices[iiii] = self.buyOrderPrices[iiii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction cancelSellOrder(Data storage self, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.sellOrders[_price].length; iii++) {\n', '\t\t\tif (self.sellOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.sellOrders[_price][iii].client);\n', '\t\t\t\t//return starcoins from the frozen balance to seller\n', '\t\t\t\tself.frozen[msg.sender] -= self.sellOrders[_price][iii].amount;\n', '\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_price][iii].amount;\n', '\t\t\t\t//delete sellOrders[_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.sellOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\tself.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\t\tself.sellOrders[_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', "\t\t//Delete _price from sellOrderPrices[] if it's the last order\n", '\t\tif (self.sellOrders[_price].length == 0) {\n', '\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\tfor (uint8 iiii = 0; iiii < self.sellOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\tif (self.sellOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t}\n', '\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) \n', '\t\t\t\t\t\tself.sellOrderPrices[iiii] = self.sellOrderPrices[iiii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'library StarmidLibrary {\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    \n', '\tfunction stockBuyOrder(StarCoinLibrary.Data storage self, uint _node, uint256 _buyPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(self.balanceOf[msg.sender] >= _buyPrice*_amount);\n', '\t\tuint256[4] memory it;\n', '\t\tif (CommonLibrary.stockMinSellPrice(self, _buyPrice, _node) != _buyPrice + 1) {\n', '\t\t\tit[3] = self.stockSellOrderPrices[_node].length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint minPrice = CommonLibrary.stockMinSellPrice(self, _buyPrice, _node);\n', '\t\t\t\tit[2] = self.stockSellOrders[_node][minPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_amount >= self.stockSellOrders[_node][minPrice][0].amount) {\n', '\t\t\t\t\t\t//buy stocks for starcoins\n', "\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][minPrice][0].amount;// add the amount to buyer's balance\n", "\t\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][minPrice][0].client][_node] -= self.stockSellOrders[_node][minPrice][0].amount;// subtracts amount from seller's frozen stock balance\n", '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockSellOrders[_node][minPrice][0].amount, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] -= self.stockSellOrders[_node][minPrice][0].amount*minPrice;// subtracts amount from buyer's balance\n", "\t\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][minPrice][0].client] += self.stockSellOrders[_node][minPrice][0].amount*minPrice;// adds the amount to seller's balance\n", '\t\t\t\t\t\tTransfer(self.stockSellOrders[_node][minPrice][0].client, msg.sender, self.stockSellOrders[_node][minPrice][0].amount*minPrice);\n', '\t\t\t\t\t\t//save the transaction into event StocksTradeHistory;\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice, \n', '\t\t\t\t\t\tself.stockSellOrders[_node][minPrice][0].amount, self.stockSellOrders[_node][minPrice][0].orderId);\n', '\t\t\t\t\t\t_amount -= self.stockSellOrders[_node][minPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.stockSellOrders[_node][minPrice][0].amount;\n', '\t\t\t\t\t\t//delete stockSellOrders[_node][minPrice][0] and move each element\n', '\t\t\t\t\t\tCommonLibrary.stockDeleteFirstOrder(self, _node, minPrice, true);\n', '\t\t\t\t\t\tif (_amount<1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit stockSellOrders[_node][minPrice][0]\n', '\t\t\t\t\t\tself.stockSellOrders[_node][minPrice][0].amount -= _amount;\n', '\t\t\t\t\t\t//buy stocks for starcoins\n', "\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += _amount;// adds the _amount to buyer's balance\n", "\t\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][minPrice][0].client][_node] -= _amount;// subtracts _amount from seller's frozen stock balance\n", '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t    CommonLibrary.stockSaveOwnerInfo(self, _node, _amount, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] -= _amount*minPrice;// subtracts _amount from buyer's balance\n", "\t\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][minPrice][0].client] += _amount*minPrice;// adds the amount to seller's balance\n", '\t\t\t\t\t\tTransfer(self.stockSellOrders[_node][minPrice][0].client, msg.sender, _amount*minPrice);\n', '\t\t\t\t\t\t//save the transaction  into event StocksTradeHistory;\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][minPrice][0].client, minPrice, \n', '\t\t\t\t\t\t_amount, self.stockSellOrders[_node][minPrice][0].orderId);\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif(_amount < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t   \t}\n', '\t\t}\n', '\t\tif (CommonLibrary.stockMinSellPrice(self, _buyPrice, _node) == _buyPrice + 1 && _amount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _amount;\n', '\t\t\tself.stockOrdersId += 1;\n', '\t\t\t_results[2] = self.stockOrdersId;\n', '\t\t\tself.stockBuyOrders[_node][_buyPrice].push(StarCoinLibrary.stockOrderInfo(block.timestamp, msg.sender, _results[1], _buyPrice, true, self.stockOrdersId, _node));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer starcoins to the frozen balance\n', '\t\t\tself.frozen[msg.sender] += _amount*_buyPrice;\n', '\t\t\tself.balanceOf[msg.sender] -= _amount*_buyPrice;\n', '\t\t\t//Add _buyPrice to stockBuyOrderPrices[_node][]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.stockBuyOrderPrices[_node].length; it[1]++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][it[1]] == _buyPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) self.stockBuyOrderPrices[_node].push(_buyPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSellOrder(StarCoinLibrary.Data storage self, uint _node, uint _sellPrice, uint _amount) returns (uint[4] _results) {\n', '\t\trequire(self.stockBalanceOf[msg.sender][_node] >= _amount);\n', '\t\tuint[4] memory it;\n', '\t\tif (CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node) != _sellPrice - 1) {\n', '\t\t\tit[3] = self.stockBuyOrderPrices[_node].length;\n', '\t\t\tfor (it[1] = 0; it[1] < it[3]; it[1]++) {\n', '\t\t\t\tuint _maxPrice = CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node);\n', '\t\t\t\tit[2] = self.stockBuyOrders[_node][_maxPrice].length;\n', '\t\t\t\tfor (it[0] = 0; it[0] < it[2]; it[0]++) {\n', '\t\t\t\t\tif (_amount >= self.stockBuyOrders[_node][_maxPrice][0].amount) {\n', '\t\t\t\t\t\t//sell stocks for starcoins\n', "\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= self.stockBuyOrders[_node][_maxPrice][0].amount;// subtracts the _amount from seller's balance \n", "\t\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_maxPrice][0].client][_node] += self.stockBuyOrders[_node][_maxPrice][0].amount;// adds the _amount to buyer's balance\n", '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockBuyOrders[_node][_maxPrice][0].amount, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _maxPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice;// adds the amount to buyer's balance \n", "\t\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_maxPrice][0].client] -= self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice;// subtracts amount from seller's frozen balance\n", '\t\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, self.stockBuyOrders[_node][_maxPrice][0].amount*_maxPrice);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, \n', '\t\t\t\t\t\t_maxPrice, self.stockBuyOrders[_node][_maxPrice][0].amount, self.stockBuyOrders[_node][_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_amount -= self.stockBuyOrders[_node][_maxPrice][0].amount;\n', '\t\t\t\t\t\t_results[0] += self.stockBuyOrders[_node][_maxPrice][0].amount;\n', '\t\t\t\t\t\t//delete stockBuyOrders[_node][_maxPrice][0] and move each element\n', '\t\t\t\t\t\tCommonLibrary.stockDeleteFirstOrder(self, _node, _maxPrice, false);\n', '\t\t\t\t\t\tif(_amount < 1) break;\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse {\n', '\t\t\t\t\t\t//edit stockBuyOrders[_node][_maxPrice][0]\n', '\t\t\t\t\t\tself.stockBuyOrders[_node][_maxPrice][0].amount -= _amount;\n', '\t\t\t\t\t\t//sell stocks for starcoins\n', "\t\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;// subtracts _amount from seller's balance \n", "\t\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_maxPrice][0].client][_node] += _amount;// adds the _amount to buyer's balance\n", '\t\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _maxPrice);\n', '\t\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\t\tself.balanceOf[msg.sender] += _amount*_maxPrice;// adds the _amount to buyer's balance \n", "\t\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_maxPrice][0].client] -= _amount*_maxPrice;// subtracts _amount from seller's frozen balance\n", '\t\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, _amount*_maxPrice);\n', '\t\t\t\t\t\t//save the transaction\n', '\t\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_maxPrice][0].client, msg.sender, \n', '\t\t\t\t\t\t_maxPrice, _amount, self.stockBuyOrders[_node][_maxPrice][0].orderId);\n', '\t\t\t\t\t\t_results[0] += _amount;\n', '\t\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\t\tbreak;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t\tif (_amount < 1) {\n', '\t\t\t\t\t_results[3] = 1;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (CommonLibrary.stockMaxBuyPrice(self, _sellPrice, _node) == _sellPrice - 1 && _amount >= 1) {\n', '\t\t\t//save new order\n', '\t\t\t_results[1] =  _amount;\n', '\t\t\tself.stockOrdersId += 1;\n', '\t\t\t_results[2] = self.stockOrdersId;\n', '\t\t\tself.stockSellOrders[_node][_sellPrice].push(StarCoinLibrary.stockOrderInfo(block.timestamp, msg.sender, _results[1], _sellPrice, false, self.stockOrdersId, _node));\n', '\t\t    _results[3] = 1;\n', '\t\t\t//transfer stocks to the frozen stock balance\n', '\t\t\tself.stockFrozen[msg.sender][_node] += _amount;\n', '\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;\n', '\t\t\t//Add _sellPrice to stockSellOrderPrices[_node][]\n', '\t\t\tit[0] = 99999;\n', '\t\t\tfor (it[1] = 0; it[1] < self.stockSellOrderPrices[_node].length; it[1]++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][it[1]] == _sellPrice) \n', '\t\t\t\t\tit[0] = it[1];\n', '\t\t\t}\n', '\t\t\tif (it[0] == 99999) \n', '\t\t\t\tself.stockSellOrderPrices[_node].push(_sellPrice);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockCancelBuyOrder(StarCoinLibrary.Data storage self, uint _node, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint iii = 0; iii < self.stockBuyOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockBuyOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.stockBuyOrders[_node][_price][iii].client);\n', '\t\t\t\t//return starcoins from the buyer`s frozen balance\n', '\t\t\t\tself.frozen[msg.sender] -= self.stockBuyOrders[_node][_price][iii].amount*_price;\n', '\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_price][iii].amount*_price;\n', '\t\t\t\t//delete stockBuyOrders[_node][_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.stockBuyOrders[_node][_price].length - 1; ii++) {\n', '\t\t\t\t\tself.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];\n', '\t\t\t\tself.stockBuyOrders[_node][_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', "\t\t//Delete _price from stockBuyOrderPrices[_node][] if it's the last order\n", '\t\tif (self.stockBuyOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (iii = 0; iii < self.stockBuyOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\tif (self.stockBuyOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];\n', '\t\t\tself.stockBuyOrderPrices[_node].length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction stockCancelSellOrder(StarCoinLibrary.Data storage self, uint _node, uint _thisOrderID, uint _price) public returns(bool) {\n', '\t\tfor (uint iii = 0; iii < self.stockSellOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockSellOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(msg.sender == self.stockSellOrders[_node][_price][iii].client);\n', '\t\t\t\t//return stocks from the seller`s frozen stock balance\n', '\t\t\t\tself.stockFrozen[msg.sender][_node] -= self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\t//delete stockSellOrders[_node][_price][iii] and move each element\n', '\t\t\t\tfor (uint ii = iii; ii < self.stockSellOrders[_node][_price].length - 1; ii++) {\n', '\t\t\t\t\tself.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];\n', '\t\t\t\t}\n', '\t\t\t\tdelete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];\n', '\t\t\t\tself.stockSellOrders[_node][_price].length--;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', "\t\t//Delete _price from stockSellOrderPrices[_node][] if it's the last order\n", '\t\tif (self.stockSellOrders[_node][_price].length == 0) {\n', '\t\t\tuint _fromArg = 99999;\n', '\t\t\tfor (iii = 0; iii < self.stockSellOrderPrices[_node].length - 1; iii++) {\n', '\t\t\t\tif (self.stockSellOrderPrices[_node][iii] == _price) {\n', '\t\t\t\t\t_fromArg = iii;\n', '\t\t\t\t}\n', '\t\t\t\tif (_fromArg != 99999 && iii >= _fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];\n', '\t\t\t}\n', '\t\t\tdelete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];\n', '\t\t\tself.stockSellOrderPrices[_node].length--;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'library StarmidLibraryExtra {\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\t\n', '\tfunction buyCertainOrder(StarCoinLibrary.Data storage self, uint _price, uint _thisOrderID) returns (bool) {\n', '\t\tuint _remainingValue = msg.value;\n', '\t\tfor (uint8 iii = 0; iii < self.sellOrders[_price].length; iii++) {\n', '\t\t\tif (self.sellOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\tuint _amount = _remainingValue/_price;\n', '\t\t\t\trequire(_amount <= self.sellOrders[_price][iii].amount);\n', '\t\t\t\tif (_amount == self.sellOrders[_price][iii].amount) {\n', '\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\tself.balanceOf[msg.sender] += self.sellOrders[_price][iii].amount;// adds the amount to buyer's balance\n", "\t\t\t\t\tself.frozen[self.sellOrders[_price][iii].client] -= self.sellOrders[_price][iii].amount;// subtracts the amount from seller's frozen balance\n", '\t\t\t\t\tTransfer(self.sellOrders[_price][iii].client, msg.sender, self.sellOrders[_price][iii].amount);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_price][iii].client] += _price*self.sellOrders[_price][iii].amount;\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_price][iii].client, _price, self.sellOrders[_price][iii].amount, \n', '\t\t\t\t\tself.sellOrders[_price][iii].orderId);\n', '\t\t\t\t\t_remainingValue -= _price*self.sellOrders[_price][iii].amount;\n', '\t\t\t\t\t//delete sellOrders[_price][iii] and move each element\n', '\t\t\t\t\tfor (uint ii = iii; ii < self.sellOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\t\tself.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];\n', '\t\t\t\t\t}\n', '\t\t\t\t\tdelete self.sellOrders[_price][self.sellOrders[_price].length - 1];\n', '\t\t\t\t\tself.sellOrders[_price].length--;\n', "\t\t\t\t\t//Delete _price from sellOrderPrices[] if it's the last order\n", '\t\t\t\t\tif (self.sellOrders[_price].length == 0) {\n', '\t\t\t\t\t\tuint fromArg = 99999;\n', '\t\t\t\t\t\tfor (ii = 0; ii < self.sellOrderPrices.length - 1; ii++) {\n', '\t\t\t\t\t\t\tif (self.sellOrderPrices[ii] == _price) {\n', '\t\t\t\t\t\t\t\tfromArg = ii;\n', '\t\t\t\t\t\t\t}\n', '\t\t\t\t\t\t\tif (fromArg != 99999 && ii >= fromArg) \n', '\t\t\t\t\t\t\t\tself.sellOrderPrices[ii] = self.sellOrderPrices[ii + 1];\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\tdelete self.sellOrderPrices[self.sellOrderPrices.length-1];\n', '\t\t\t\t\t\tself.sellOrderPrices.length--;\n', '\t\t\t\t\t}\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit sellOrders[_price][iii]\n', '\t\t\t\t\tself.sellOrders[_price][iii].amount = self.sellOrders[_price][iii].amount - _amount;\n', '\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\tself.balanceOf[msg.sender] += _amount;// adds the _amount to buyer's balance\n", "\t\t\t\t\tself.frozen[self.sellOrders[_price][iii].client] -= _amount;// subtracts the _amount from seller's frozen balance\n", '\t\t\t\t\tTransfer(self.sellOrders[_price][iii].client, msg.sender, _amount);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, msg.sender, self.sellOrders[_price][iii].client, _price, _amount, self.sellOrders[_price][iii].orderId);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[self.sellOrders[_price][iii].client] += _amount*_price;\n', '\t\t\t\t\t_remainingValue -= _amount*_price;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tself.pendingWithdrawals[msg.sender] += _remainingValue;//returns change to buyer\t\t\t\t\n', '\t}\n', '\t\n', '\tfunction sellCertainOrder(StarCoinLibrary.Data storage self, uint _amount, uint _price, uint _thisOrderID) returns (bool) {\n', '\t\tfor (uint8 iii = 0; iii < self.buyOrders[_price].length; iii++) {\n', '\t\t\tif (self.buyOrders[_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.buyOrders[_price][iii].amount && self.balanceOf[msg.sender] >= _amount);\n', '\t\t\t\tif (_amount == self.buyOrders[_price][iii].amount) {\n', '\t\t\t\t\t//sell starcoins for ether\n', "\t\t\t\t\tself.balanceOf[msg.sender] -= self.buyOrders[_price][iii].amount;// subtracts amount from seller's balance\n", "\t\t\t\t\tself.balanceOf[self.buyOrders[_price][iii].client] += self.buyOrders[_price][iii].amount;// adds the amount to buyer's balance\n", '\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_price][iii].client, self.buyOrders[_price][iii].amount);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tuint _amountTransfer = _price*self.buyOrders[_price][iii].amount;\n', '\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _amountTransfer;\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_price][iii].client, msg.sender, _price, self.buyOrders[_price][iii].amount, \n', '\t\t\t\t\tself.buyOrders[_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.buyOrders[_price][iii].amount;\n', '\t\t\t\t\t//delete buyOrders[_price][iii] and move each element\n', '\t\t\t\t\tfor (uint ii = iii; ii < self.buyOrders[_price].length - 1; ii++) {\n', '\t\t\t\t\t\tself.buyOrders[_price][ii] = self.buyOrders[_price][ii + 1];\n', '\t\t\t\t\t}\n', '\t\t\t\t\tdelete self.buyOrders[_price][self.buyOrders[_price].length - 1];\n', '\t\t\t\t\tself.buyOrders[_price].length--;\n', "\t\t\t\t\t//Delete _price from buyOrderPrices[] if it's the last order\n", '\t\t\t\t\tif (self.buyOrders[_price].length == 0) {\n', '\t\t\t\t\t\tuint _fromArg = 99999;\n', '\t\t\t\t\t\tfor (uint8 iiii = 0; iiii < self.buyOrderPrices.length - 1; iiii++) {\n', '\t\t\t\t\t\t\tif (self.buyOrderPrices[iiii] == _price) {\n', '\t\t\t\t\t\t\t\t_fromArg = iiii;\n', '\t\t\t\t\t\t\t}\n', '\t\t\t\t\t\t\tif (_fromArg != 99999 && iiii >= _fromArg) self.buyOrderPrices[iiii] = self.buyOrderPrices[iiii + 1];\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\tdelete self.buyOrderPrices[self.buyOrderPrices.length-1];\n', '\t\t\t\t\t\tself.buyOrderPrices.length--;\n', '\t\t\t\t\t}\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit buyOrders[_price][iii]\n', '\t\t\t\t\tself.buyOrders[_price][iii].amount = self.buyOrders[_price][iii].amount - _amount;\n', '\t\t\t\t\t//buy starcoins for ether\n', "\t\t\t\t\tself.balanceOf[msg.sender] -= _amount;// subtracts amount from seller's balance\n", "\t\t\t\t\tself.balanceOf[self.buyOrders[_price][iii].client] += _amount;// adds the amount to buyer's balance \n", '\t\t\t\t\tTransfer(msg.sender, self.buyOrders[_price][iii].client, _amount);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tTradeHistory(block.timestamp, self.buyOrders[_price][iii].client, msg.sender, _price, _amount, self.buyOrders[_price][iii].orderId);\n', '\t\t\t\t\t//transfer ether to seller\n', '\t\t\t\t\tself.pendingWithdrawals[msg.sender] += _price*_amount;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\t\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockBuyCertainOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, uint _amount, uint _thisOrderID) returns (bool) {\n', '\t\trequire(self.balanceOf[msg.sender] >= _price*_amount);\n', '\t\tfor (uint8 iii = 0; iii < self.stockSellOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockSellOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.stockSellOrders[_node][_price][iii].amount);\n', '\t\t\t\tif (_amount == self.stockSellOrders[_node][_price][iii].amount) {\n', '\t\t\t\t\t//buy stocks for starcoins\n', "\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += self.stockSellOrders[_node][_price][iii].amount;// add the amount to buyer's balance\n", "\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][_price][iii].client][_node] -= self.stockSellOrders[_node][_price][iii].amount;// subtracts amount from seller's frozen stock balance\n", '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockSellOrders[_node][_price][iii].amount, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\tself.balanceOf[msg.sender] -= self.stockSellOrders[_node][_price][iii].amount*_price;// subtracts amount from buyer's balance\n", "\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][_price][iii].client] += self.stockSellOrders[_node][_price][iii].amount*_price;// adds the amount to seller's balance\n", '\t\t\t\t\tTransfer(self.stockSellOrders[_node][_price][iii].client, msg.sender, self.stockSellOrders[_node][_price][iii].amount*_price);\n', '\t\t\t\t\t//save the transaction into event StocksTradeHistory;\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price, \n', '\t\t\t\t\tself.stockSellOrders[_node][_price][iii].amount, self.stockSellOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.stockSellOrders[_node][_price][iii].amount;\n', '\t\t\t\t\t//delete stockSellOrders[_node][_price][iii] and move each element\n', '\t\t\t\t\tCommonLibrary.deleteStockSellOrder(self, iii, _node, _price);\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit stockSellOrders[_node][_price][iii]\n', '\t\t\t\t\tself.stockSellOrders[_node][_price][iii].amount -= _amount;\n', '\t\t\t\t\t//buy stocks for starcoins\n', "\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] += _amount;// adds the amount to buyer's balance\n", "\t\t\t\t\tself.stockFrozen[self.stockSellOrders[_node][_price][iii].client][_node] -= _amount;// subtracts amount from seller's frozen stock balance\n", '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\tself.balanceOf[msg.sender] -= _amount*_price;// subtracts amount from buyer's balance\n", "\t\t\t\t\tself.balanceOf[self.stockSellOrders[_node][_price][iii].client] += _amount*_price;// adds the amount to seller's balance\n", '\t\t\t\t\tTransfer(self.stockSellOrders[_node][_price][iii].client, msg.sender, _amount*_price);\n', '\t\t\t\t\t//save the transaction  into event StocksTradeHistory;\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, msg.sender, self.stockSellOrders[_node][_price][iii].client, _price, \n', '\t\t\t\t\t_amount, self.stockSellOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\treturn true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockSellCertainOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, uint _amount, uint _thisOrderID) returns (bool results) {\n', '\t\tuint _remainingAmount = _amount;\n', '\t\tfor (uint8 iii = 0; iii < self.stockBuyOrders[_node][_price].length; iii++) {\n', '\t\t\tif (self.stockBuyOrders[_node][_price][iii].orderId == _thisOrderID) {\n', '\t\t\t\trequire(_amount <= self.stockBuyOrders[_node][_price][iii].amount && self.stockBalanceOf[msg.sender][_node] >= _amount);\n', '\t\t\t\tif (_remainingAmount == self.stockBuyOrders[_node][_price][iii].amount) {\n', '\t\t\t\t\t//sell stocks for starcoins\n', "\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= self.stockBuyOrders[_node][_price][iii].amount;// subtracts amount from seller's balance \n", "\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_price][iii].client][_node] += self.stockBuyOrders[_node][_price][iii].amount;// adds the amount to buyer's balance\n", '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, self.stockBuyOrders[_node][_price][iii].amount, self.stockBuyOrders[_node][_price][iii].client, msg.sender, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\tself.balanceOf[msg.sender] += self.stockBuyOrders[_node][_price][iii].amount*_price;// adds the amount to buyer's balance \n", "\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_price][iii].client] -= self.stockBuyOrders[_node][_price][iii].amount*_price;// subtracts amount from seller's frozen balance\n", '\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_price][iii].client, msg.sender, self.stockBuyOrders[_node][_price][iii].amount*_price);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_price][iii].client, msg.sender, \n', '\t\t\t\t\t_price, self.stockBuyOrders[_node][_price][iii].amount, self.stockBuyOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount -= self.stockBuyOrders[_node][_price][iii].amount;\n', '\t\t\t\t\t//delete stockBuyOrders[_node][_price][iii] and move each element\n', '\t\t\t\t\tCommonLibrary.deleteStockBuyOrder(self, iii, _node, _price);\n', '\t\t\t\t\tresults = true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t\t//edit stockBuyOrders[_node][_price][0]\n', '\t\t\t\t\tself.stockBuyOrders[_node][_price][iii].amount -= _amount;\n', '\t\t\t\t\t//sell stocks for starcoins\n', "\t\t\t\t\tself.stockBalanceOf[msg.sender][_node] -= _amount;// subtracts amount from seller's balance \n", "\t\t\t\t\tself.stockBalanceOf[self.stockBuyOrders[_node][_price][iii].client][_node] += _amount;// adds the amount to buyer's balance\n", '\t\t\t\t\t//write stockOwnerInfo and stockOwners for dividends\n', '\t\t\t\t\tCommonLibrary.stockSaveOwnerInfo(self, _node, _amount, self.stockBuyOrders[_node][_price][iii].client, msg.sender, _price);\n', '\t\t\t\t\t//transfer starcoins to seller\n', "\t\t\t\t\tself.balanceOf[msg.sender] += _amount*_price;// adds the amount to buyer's balance \n", "\t\t\t\t\tself.frozen[self.stockBuyOrders[_node][_price][iii].client] -= _amount*_price;// subtracts amount from seller's frozen balance\n", '\t\t\t\t\tTransfer(self.stockBuyOrders[_node][_price][iii].client, msg.sender, _amount*_price);\n', '\t\t\t\t\t//save the transaction\n', '\t\t\t\t\tStockTradeHistory(_node, block.timestamp, self.stockBuyOrders[_node][_price][iii].client, msg.sender, \n', '\t\t\t\t\t_price, _amount, self.stockBuyOrders[_node][_price][iii].orderId);\n', '\t\t\t\t\t_amount = 0;\n', '\t\t\t\t\tresults = true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\t\n', '\t\t}\n', '\t}\t\n', '}\n', '\n', '\n', 'contract Nodes {\n', '\taddress public owner;\n', '\tCommonLibrary.Data public vars;\n', '\tmapping (address => string) public confirmationNodes;\n', '\tuint confirmNodeId;\n', '\tuint40 changePercentId;\n', '\tuint40 pushNodeGroupId;\n', '\tuint40 deleteNodeGroupId;\n', '\tevent NewNode(\n', '\t\tuint256 id, \n', '\t\tstring nodeName, \n', '\t\tuint8 producersPercent, \n', '\t\taddress producer, \n', '\t\tuint date\n', '\t\t);\n', '\tevent OwnerNotation(uint256 id, uint date, string newNotation);\n', '\tevent NewNodeGroup(uint16 id, string newNodeGroup);\n', '\tevent AddNodeAddress(uint id, uint nodeID, address nodeAdress);\n', '\tevent EditNode(\n', '\t\tuint nodeID,\n', '\t\taddress nodeAdress, \n', '\t\taddress newProducer, \n', '\t\tuint8 newProducersPercent,\n', '\t\tbool starmidConfirmed\n', '\t\t);\n', '\tevent ConfirmNode(uint id, uint nodeID);\n', '\tevent OutsourceConfirmNode(uint nodeID, address confirmationNode);\n', '\tevent ChangePercent(uint id, uint nodeId, uint producersPercent);\n', '\tevent PushNodeGroup(uint id, uint nodeId, uint newNodeGroup);\n', '\tevent DeleteNodeGroup(uint id, uint nodeId, uint deleteNodeGroup);\n', '\t\n', '\tfunction Nodes() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t//-----------------------------------------------------Nodes---------------------------------------------------------------\n', '\tfunction changeOwner(string _changeOwnerPassword, address _newOwnerAddress) onlyOwner returns(bool) {\n', '\t\t//One-time tool for emergency owner change\n', '\t\tif (keccak256(_changeOwnerPassword) == 0xe17a112b6fc12fc80c9b241de72da0d27ce7e244100f3c4e9358162a11bed629) {\n', '\t\t\towner = _newOwnerAddress;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse \n', '\t\t\treturn false;\n', '\t}\n', '\t\n', '\tfunction addOwnerNotations(string _newNotation) onlyOwner {\n', '\t\tuint date = block.timestamp;\n', '\t\tvars.ownerNotationId += 1;\n', '\t\tOwnerNotation(vars.ownerNotationId, date, _newNotation);\n', '\t}\n', '\t\n', '\tfunction addConfirmationNode(string _newConfirmationNode) public returns(bool) {\n', '\t\tconfirmationNodes[msg.sender] = _newConfirmationNode;\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction addNodeGroup(string _newNodeGroup) onlyOwner returns(uint16 _id) {\n', '\t\tbool result;\n', '\t\t(result, _id) = CommonLibrary.addNodeGroup(vars, _newNodeGroup);\n', '\t\trequire(result);\n', '\t\tNewNodeGroup(_id, _newNodeGroup);\n', '\t}\n', '\t\n', '\tfunction addNode(string _newNode, uint8 _producersPercent) returns(bool) {\n', '\t\tbool result;\n', '\t\tuint _id;\n', '\t\t(result, _id) = CommonLibrary.addNode(vars, _newNode, _producersPercent);\n', '\t\trequire(result);\n', '\t\tNewNode(_id, _newNode, _producersPercent, msg.sender, block.timestamp);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction editNode(\n', '\t\tuint _nodeID, \n', '\t\taddress _nodeAddress, \n', '\t\tbool _isNewProducer, \n', '\t\taddress _newProducer, \n', '\t\tuint8 _newProducersPercent,\n', '\t\tbool _starmidConfirmed\n', '\t\t) onlyOwner returns(bool) {\n', '\t\tbool x = CommonLibrary.editNode(vars, _nodeID, _nodeAddress,_isNewProducer, _newProducer, _newProducersPercent, _starmidConfirmed);\n', '\t\trequire(x);\n', '\t\tEditNode(_nodeID, _nodeAddress, _newProducer, _newProducersPercent, _starmidConfirmed);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t\n', '\tfunction addNodeAddress(uint _nodeID, address _nodeAddress) public returns(bool) {\n', '\t\tbool _result;\n', '\t\tuint _id;\n', '\t\t(_result, _id) = CommonLibrary.addNodeAddress(vars, _nodeID, _nodeAddress);\n', '\t\trequire(_result);\n', '\t\tAddNodeAddress(_id, _nodeID, _nodeAddress);\n', '\t\treturn true; \n', '\t}\n', '\t\n', '\tfunction pushNodeGroup(uint _nodeID, uint16 _newNodeGroup) public returns(bool) {\n', '\t\trequire(msg.sender == vars.nodes[_nodeID].node);\n', '\t\tvars.nodes[_nodeID].nodeGroup.push(_newNodeGroup);\n', '\t\tpushNodeGroupId += 1;\n', '\t\tPushNodeGroup(pushNodeGroupId, _nodeID, _newNodeGroup);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction deleteNodeGroup(uint _nodeID, uint16 _deleteNodeGroup) public returns(bool) {\n', '\t\trequire(msg.sender == vars.nodes[_nodeID].node);\n', '\t\tfor(uint16 i = 0; i < vars.nodes[_nodeID].nodeGroup.length; i++) {\n', '\t\t\tif(_deleteNodeGroup == vars.nodes[_nodeID].nodeGroup[i]) {\n', '\t\t\t\tfor(uint16 ii = i; ii < vars.nodes[_nodeID].nodeGroup.length - 1; ii++) \n', '\t\t\t\t\tvars.nodes[_nodeID].nodeGroup[ii] = vars.nodes[_nodeID].nodeGroup[ii + 1];\n', '\t\t    \tdelete vars.nodes[_nodeID].nodeGroup[vars.nodes[_nodeID].nodeGroup.length - 1];\n', '\t\t\t\tvars.nodes[_nodeID].nodeGroup.length--;\n', '\t\t\t\tbreak;\n', '\t\t    }\n', '\t    }\n', '\t\tdeleteNodeGroupId += 1;\n', '\t\tDeleteNodeGroup(deleteNodeGroupId, _nodeID, _deleteNodeGroup);\n', '\t\treturn true;\n', '    }\n', '\t\n', '\tfunction confirmNode(uint _nodeID) onlyOwner returns(bool) {\n', '\t\tvars.nodes[_nodeID].starmidConfirmed = true;\n', '\t\tconfirmNodeId += 1;\n', '\t\tConfirmNode(confirmNodeId, _nodeID);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction outsourceConfirmNode(uint _nodeID) public returns(bool) {\n', '\t\tvars.nodes[_nodeID].outsourceConfirmed.push(msg.sender);\n', '\t\tOutsourceConfirmNode(_nodeID, msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction changePercent(uint _nodeId, uint8 _producersPercent) public returns(bool){\n', '\t\tif(msg.sender == vars.nodes[_nodeId].producer && vars.nodes[_nodeId].node == 0x0000000000000000000000000000000000000000) {\n', '\t\t\tvars.nodes[_nodeId].producersPercent = _producersPercent;\n', '\t\t\tchangePercentId += 1;\n', '\t\t\tChangePercent(changePercentId, _nodeId, _producersPercent);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction getNodeInfo(uint _nodeID) constant public returns(\n', '\t\taddress _producer, \n', '\t\taddress _node, \n', '\t\tuint _date, \n', '\t\tbool _starmidConfirmed, \n', '\t\tstring _nodeName, \n', '\t\taddress[] _outsourceConfirmed, \n', '\t\tuint16[] _nodeGroup, \n', '\t\tuint _producersPercent\n', '\t\t) {\n', '\t\t_producer = vars.nodes[_nodeID].producer;\n', '\t\t_node = vars.nodes[_nodeID].node;\n', '\t\t_date = vars.nodes[_nodeID].date;\n', '\t\t_starmidConfirmed = vars.nodes[_nodeID].starmidConfirmed;\n', '\t\t_nodeName = vars.nodes[_nodeID].nodeName;\n', '\t\t_outsourceConfirmed = vars.nodes[_nodeID].outsourceConfirmed;\n', '\t\t_nodeGroup = vars.nodes[_nodeID].nodeGroup;\n', '\t\t_producersPercent = vars.nodes[_nodeID].producersPercent;\n', '\t}\n', '}\t\n', '\n', '\n', 'contract Starmid {\n', '\taddress public owner;\n', '\tNodes public nodesVars;\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\tStarCoinLibrary.Data public sCVars;\n', '\t\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent BuyOrder(address indexed from, uint orderId, uint buyPrice);\n', '\tevent SellOrder(address indexed from, uint orderId, uint sellPrice);\n', '\tevent CancelBuyOrder(address indexed from, uint indexed orderId, uint price);\n', '\tevent CancelSellOrder(address indexed from, uint indexed orderId, uint price);\n', '\tevent TradeHistory(uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '    //----------------------------------------------------Starmid exchange\n', '\tevent StockTransfer(address indexed from, address indexed to, uint indexed node, uint256 value);\n', '\tevent StockBuyOrder(uint node, uint buyPrice);\n', '\tevent StockSellOrder(uint node, uint sellPrice);\n', '\tevent StockCancelBuyOrder(uint node, uint price);\n', '\tevent StockCancelSellOrder(uint node, uint price);\n', '\tevent StockTradeHistory(uint node, uint date, address buyer, address seller, uint price, uint amount, uint orderId);\n', '\t\n', '\tfunction Starmid(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {\n', '\t\towner = 0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8;\n', '\t\ttotalSupply = initialSupply;  \n', '\t\tsCVars.balanceOf[msg.sender] = 5000000000;\n', '\t\tsCVars.balanceOf[0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8] = initialSupply - 5000000000;                \n', '\t\tname = tokenName;                                   \n', '\t\tsymbol = tokenSymbol;                               \n', '\t\tdecimals = decimalUnits; \n', '\t\tsCVars.lastMint = block.timestamp;\n', '\t\tsCVars.emissionLimits[1] = 500000; sCVars.emissionLimits[2] = 500000; sCVars.emissionLimits[3] = 500000;\n', '\t\tsCVars.emissionLimits[4] = 500000; sCVars.emissionLimits[5] = 500000; sCVars.emissionLimits[6] = 500000;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t//-----------------------------------------------------StarCoin Exchange------------------------------------------------------\n', '\tfunction getWithdrawal() constant public returns(uint _amount) {\n', '        _amount = sCVars.pendingWithdrawals[msg.sender];\n', '    }\n', '\t\n', '\tfunction withdraw() public returns(bool _result, uint _amount) {\n', '        _amount = sCVars.pendingWithdrawals[msg.sender];\n', '        sCVars.pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(_amount);\n', '\t\t_result = true;\n', '    }\n', '\t\n', '\tfunction changeOwner(string _changeOwnerPassword, address _newOwnerAddress) onlyOwner returns(bool) {\n', '\t\t//One-time tool for emergency owner change\n', '\t\tif (keccak256(_changeOwnerPassword) == 0xe17a112b6fc12fc80c9b241de72da0d27ce7e244100f3c4e9358162a11bed629) {\n', '\t\t\towner = _newOwnerAddress;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\telse \n', '\t\t\treturn false;\n', '\t}\n', '\t\n', '\tfunction setNodesVars(address _addr) public {\n', '\t    require(msg.sender == 0xfCbA69eF1D63b0A4CcD9ceCeA429157bA48d6a9c);\n', '\t\tnodesVars = Nodes(_addr);\n', '\t}\n', '\t\n', '\tfunction getBalance(address _address) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.balanceOf[_address];\n', '\t}\n', '\t\n', '\tfunction getBuyOrderPrices() constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.buyOrderPrices;\n', '\t}\n', '\t\n', '\tfunction getSellOrderPrices() constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.sellOrderPrices;\n', '\t}\n', '\t\n', '\tfunction getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {\n', '\t\tif(_isBuyOrder == true) {\n', '\t\t\t_address = sCVars.buyOrders[_price][_number].client;\n', '\t\t\t_amount = sCVars.buyOrders[_price][_number].amount;\n', '\t\t\t_orderId = sCVars.buyOrders[_price][_number].orderId;\n', '\t\t}\n', '\t\telse {\n', '\t\t\t_address = sCVars.sellOrders[_price][_number].client;\n', '\t\t\t_amount = sCVars.sellOrders[_price][_number].amount;\n', '\t\t\t_orderId = sCVars.sellOrders[_price][_number].orderId;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction transfer(address _to, uint256 _value) public {\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '\tfunction mint() public onlyOwner returns(uint _mintedAmount) {\n', '\t\t//Minted amount does not exceed 8,5% per annum. Thus, minting does not greatly increase the total supply \n', '\t\t//and does not cause significant inflation and depreciation of the starcoin.\n', '\t\t_mintedAmount = (block.timestamp - sCVars.lastMint)*totalSupply/(12*31536000);//31536000 seconds in year\n', '\t\tsCVars.balanceOf[msg.sender] += _mintedAmount;\n', '\t\ttotalSupply += _mintedAmount;\n', '\t\tsCVars.lastMint = block.timestamp;\n', '\t\tTransfer(0, this, _mintedAmount);\n', '\t\tTransfer(this, msg.sender, _mintedAmount);\n', '\t}\n', '\t\n', '\tfunction buyOrder(uint256 _buyPrice) payable public returns (uint[4] _results) {\n', '\t\trequire(_buyPrice > 0 && msg.value > 0);\n', '\t\t_results = StarCoinLibrary.buyOrder(sCVars, _buyPrice);\n', '\t\trequire(_results[3] == 1);\n', '\t\tBuyOrder(msg.sender, _results[2], _buyPrice);\n', '\t}\n', '\t\n', '\tfunction sellOrder(uint256 _sellPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_sellPrice > 0 && _amount > 0);\n', '\t\t_results = StarCoinLibrary.sellOrder(sCVars, _sellPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tSellOrder(msg.sender, _results[2], _sellPrice);\n', '\t}\n', '\t\n', '\tfunction cancelBuyOrder(uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarCoinLibrary.cancelBuyOrder(sCVars, _thisOrderID, _price));\n', '\t\tCancelBuyOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction cancelSellOrder(uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarCoinLibrary.cancelSellOrder(sCVars, _thisOrderID, _price));\n', '\t\tCancelSellOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction _transfer(address _from, address _to, uint _value) internal {\n', '\t\trequire(_to != 0x0);\n', '        require(sCVars.balanceOf[_from] >= _value && sCVars.balanceOf[_to] + _value > sCVars.balanceOf[_to]);\n', '        sCVars.balanceOf[_from] -= _value;\n', '        sCVars.balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\t}\n', '\t\n', '\tfunction buyCertainOrder(uint _price, uint _thisOrderID) payable public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.buyCertainOrder(sCVars, _price, _thisOrderID);\n', '\t\trequire(_results && msg.value > 0);\n', '\t\tBuyOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t\n', '\tfunction sellCertainOrder(uint _amount, uint _price, uint _thisOrderID) public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.sellCertainOrder(sCVars, _amount, _price, _thisOrderID);\n', '\t\trequire(_results && _amount > 0);\n', '\t\tSellOrder(msg.sender, _thisOrderID, _price);\n', '\t}\n', '\t//------------------------------------------------------Starmid exchange----------------------------------------------------------\n', '\tfunction stockTransfer(address _to, uint _node, uint _value) public {\n', '\t\trequire(_to != 0x0);\n', '        require(sCVars.stockBalanceOf[msg.sender][_node] >= _value && sCVars.stockBalanceOf[_to][_node] + _value > sCVars.stockBalanceOf[_to][_node]);\n', '\t\tvar (x,y,) = nodesVars.getNodeInfo(_node);\n', '\t\trequire(msg.sender != y);//nodeOwner cannot transfer his stocks, only sell\n', '\t\tsCVars.stockBalanceOf[msg.sender][_node] -= _value;\n', '        sCVars.stockBalanceOf[_to][_node] += _value;\n', '        StockTransfer(msg.sender, _to, _node, _value);\n', '\t}\n', '\t\n', '\tfunction getEmission(uint _node) constant public returns(uint _emissionNumber, uint _emissionDate, uint _emissionAmount) {\n', '\t\t_emissionNumber = sCVars.emissions[_node].emissionNumber;\n', '\t\t_emissionDate = sCVars.emissions[_node].date;\n', '\t\t_emissionAmount = sCVars.emissionLimits[_emissionNumber];\n', '\t}\n', '\t\n', '\tfunction emission(uint _node) public returns(bool _result, uint _emissionNumber, uint _emissionAmount, uint _producersPercent) {\n', '\t\tvar (x,y,,,,,,z,) = nodesVars.getNodeInfo(_node);\n', '\t\taddress _nodeOwner = y;\n', '\t\taddress _nodeProducer = x;\n', '\t\t_producersPercent = z;\n', '\t\trequire(msg.sender == _nodeOwner || msg.sender == _nodeProducer);\n', '\t\tuint allStocks;\n', '\t\tfor (uint i = 1; i <= sCVars.emissions[_node].emissionNumber; i++) {\n', '\t\t\tallStocks += sCVars.emissionLimits[i];\n', '\t\t}\n', '\t\tif (_nodeOwner !=0x0000000000000000000000000000000000000000 && block.timestamp > sCVars.emissions[_node].date + 5184000 && \n', '\t\tsCVars.stockBalanceOf[_nodeOwner][_node] <= allStocks/2 ) {\n', '\t\t\t_emissionNumber = sCVars.emissions[_node].emissionNumber + 1;\n', '\t\t\tsCVars.stockBalanceOf[_nodeOwner][_node] += sCVars.emissionLimits[_emissionNumber]*(100 - _producersPercent)/100;\n', '\t\t\t//save stockOwnerInfo for _nodeOwner\n', '\t\t\tuint thisNode = 0;\n', '\t\t\tfor (i = 0; i < sCVars.stockOwnerInfo[_nodeOwner].nodes.length; i++) {\n', '\t\t\t\tif (sCVars.stockOwnerInfo[_nodeOwner].nodes[i] == _node) thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (thisNode == 0) sCVars.stockOwnerInfo[_nodeOwner].nodes.push(_node);\n', '\t\t\tsCVars.stockBalanceOf[_nodeProducer][_node] += sCVars.emissionLimits[_emissionNumber]*_producersPercent/100;\n', '\t\t\t//save stockOwnerInfo for _nodeProducer\n', '\t\t\tthisNode = 0;\n', '\t\t\tfor (i = 0; i < sCVars.stockOwnerInfo[_nodeProducer].nodes.length; i++) {\n', '\t\t\t\tif (sCVars.stockOwnerInfo[_nodeProducer].nodes[i] == _node) thisNode = 1;\n', '\t\t\t}\n', '\t\t\tif (thisNode == 0) sCVars.stockOwnerInfo[_nodeProducer].nodes.push(_node);\n', '\t\t\tsCVars.emissions[_node].date = block.timestamp;\n', '\t\t\tsCVars.emissions[_node].emissionNumber = _emissionNumber;\n', '\t\t\t_emissionAmount = sCVars.emissionLimits[_emissionNumber];\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t\telse _result = false;\n', '\t}\n', '\t\n', '\tfunction getStockOwnerInfo(address _address) constant public returns(uint[] _nodes) {\n', '\t\t_nodes = sCVars.stockOwnerInfo[_address].nodes;\n', '\t}\n', '\t\n', '\tfunction getStockBalance(address _address, uint _node) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.stockBalanceOf[_address][_node];\n', '\t}\n', '\t\n', '\tfunction getWithFrozenStockBalance(address _address, uint _node) constant public returns(uint _balance) {\n', '\t\t_balance = sCVars.stockBalanceOf[_address][_node] + sCVars.stockFrozen[_address][_node];\n', '\t}\n', '\t\n', '\tfunction getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {\n', '\t\tif(_isBuyOrder == true) {\n', '\t\t\t_address = sCVars.stockBuyOrders[_node][_price][_number].client;\n', '\t\t\t_amount = sCVars.stockBuyOrders[_node][_price][_number].amount;\n', '\t\t\t_orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;\n', '\t\t}\n', '\t\telse {\n', '\t\t\t_address = sCVars.stockSellOrders[_node][_price][_number].client;\n', '\t\t\t_amount = sCVars.stockSellOrders[_node][_price][_number].amount;\n', '\t\t\t_orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction getStockBuyOrderPrices(uint _node) constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.stockBuyOrderPrices[_node];\n', '\t}\n', '\t\n', '\tfunction getStockSellOrderPrices(uint _node) constant public returns(uint[] _prices) {\n', '\t\t_prices = sCVars.stockSellOrderPrices[_node];\n', '\t}\n', '\t\n', '\tfunction stockBuyOrder(uint _node, uint256 _buyPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_node > 0 && _buyPrice > 0 && _amount > 0);\n', '\t\t_results = StarmidLibrary.stockBuyOrder(sCVars, _node, _buyPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tStockBuyOrder(_node, _buyPrice);\n', '\t}\n', '\t\n', '\tfunction stockSellOrder(uint _node, uint256 _sellPrice, uint _amount) public returns (uint[4] _results) {\n', '\t\trequire(_node > 0 && _sellPrice > 0 && _amount > 0);\n', '\t\t_results = StarmidLibrary.stockSellOrder(sCVars, _node, _sellPrice, _amount);\n', '\t\trequire(_results[3] == 1);\n', '\t\tStockSellOrder(_node, _sellPrice);\n', '\t}\n', '\t\n', '\tfunction stockCancelBuyOrder(uint _node, uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarmidLibrary.stockCancelBuyOrder(sCVars, _node, _thisOrderID, _price));\n', '\t\tStockCancelBuyOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction stockCancelSellOrder(uint _node, uint _thisOrderID, uint _price) public {\n', '\t\trequire(StarmidLibrary.stockCancelSellOrder(sCVars, _node, _thisOrderID, _price));\n', '\t\tStockCancelSellOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction getLastDividends(uint _node) public constant returns (uint _lastDividents, uint _dividends) {\n', '\t\tuint stockAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tuint sumAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tif(sumAmount > 0) {\n', '\t\t\tuint stockAverageBuyPrice = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumPriceAmount/sumAmount;\n', '\t\t\tuint dividendsBase = stockAmount*stockAverageBuyPrice;\n', '\t\t\t_lastDividents = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount/sumAmount;\n', '\t\t\tif(_lastDividents > 0)_dividends = (block.timestamp - _lastDividents)*dividendsBase/(10*31536000);\n', '\t\t\telse _dividends = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t//--------------------------------Dividends (10% to stock owner, 2,5% to node owner per annum)------------------------------------\n', '\tfunction dividends(uint _node) public returns (bool _result, uint _dividends) {\n', '\t\tvar (x,y,) = nodesVars.getNodeInfo(_node);\n', '\t\tuint _stockAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tuint _sumAmount = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumAmount;\n', '\t\tif(_sumAmount > 0) {\n', '\t\t\tuint _stockAverageBuyPrice = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumPriceAmount/_sumAmount;\n', '\t\t\tuint _dividendsBase = _stockAmount*_stockAverageBuyPrice;\n', '\t\t\tuint _averageDate = sCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount/_sumAmount;\n', '\t\t\t//Stock owner`s dividends\n', '\t\t\tuint _div = (block.timestamp - _averageDate)*_dividendsBase/(10*31536000);//31536000 seconds in year\n', '\t\t\tsCVars.balanceOf[msg.sender] += _div;\n', '\t\t\t//Node owner`s dividends\n', '\t\t\tuint _nodeDividends = (block.timestamp - _averageDate)*_dividendsBase/(40*31536000);//31536000 seconds in year\n', '\t\t\tsCVars.balanceOf[y] += _nodeDividends;\n', '\t\t\tsCVars.StockOwnersBuyPrice[msg.sender][_node].sumDateAmount = block.timestamp*_stockAmount;//set new average dividends date\n', '\t\t\ttotalSupply += _div + _div/4;\n', '\t\t\t_dividends =  _div + _div/4;\n', '\t\t\tTransfer(this, msg.sender, _div);\t\n', '\t\t\tTransfer(this, y, _div/4);\t\n', '\t\t\t_result = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction stockBuyCertainOrder(uint _node, uint _price, uint _amount, uint _thisOrderID) payable public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.stockBuyCertainOrder(sCVars, _node, _price, _amount, _thisOrderID);\n', '\t\trequire(_results && _node > 0 && _amount > 0);\n', '\t\tStockBuyOrder(_node, _price);\n', '\t}\n', '\t\n', '\tfunction stockSellCertainOrder(uint _node, uint _price, uint _amount, uint _thisOrderID) public returns (bool _results) {\n', '\t\t_results = StarmidLibraryExtra.stockSellCertainOrder(sCVars, _node, _price, _amount, _thisOrderID);\n', '\t\trequire(_results && _node > 0 && _amount > 0);\n', '\t\tStockSellOrder(_node, _price);\n', '\t}\n', '}']
