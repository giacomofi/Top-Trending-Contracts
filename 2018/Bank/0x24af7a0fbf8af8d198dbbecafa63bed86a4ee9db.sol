['pragma solidity ^0.4.18;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract TestToken {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    uint256 public funds;\n', '    address public director;\n', '    bool public saleClosed;\n', '    bool public directorLock;\n', '    uint256 public claimAmount;\n', '    uint256 public payAmount;\n', '    uint256 public feeAmount;\n', '    uint256 public epoch;\n', '    uint256 public retentionMax;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping (address => bool) public buried;\n', '    mapping (address => uint256) public claimed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed _from, uint256 _value);\n', '    \n', '    event Bury(address indexed _target, uint256 _value);\n', '    \n', '    event Claim(address indexed _target, address indexed _payout, address indexed _fee);\n', '\n', '    function TestToken() public {\n', '        director = msg.sender;\n', '        name = "test token";\n', '        symbol = "TTT";\n', '        decimals = 8;\n', '        saleClosed = false;\n', '        directorLock = false;\n', '        funds = 0;\n', '        totalSupply = 0;\n', '        \n', '        // Token Supply: 4.000.000 TTT\n', '        totalSupply += 4000000 * 10 ** uint256(decimals);\n', '        \n', '\t\t// 1.000.000 TTT Reserved for donate\n', '        \n', '        balances[director] = totalSupply;\n', '        \n', '        claimAmount = 5 * 10 ** (uint256(decimals) - 1);\n', '        payAmount = 4 * 10 ** (uint256(decimals) - 1);\n', '        feeAmount = 1 * 10 ** (uint256(decimals) - 1);\n', '        epoch = 31536000;\n', '        \n', '        retentionMax = 40 * 10 ** uint256(decimals);\n', '    }\n', '    \n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    modifier onlyDirector {\n', '        require(!directorLock);\n', '        \n', '        require(msg.sender == director);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDirectorForce {\n', '        require(msg.sender == director);\n', '        _;\n', '    }\n', '    \n', '\n', '    function transferDirector(address newDirector) public onlyDirectorForce {\n', '        director = newDirector;\n', '    }\n', '    \n', '\n', '    function withdrawFunds() public onlyDirectorForce {\n', '        director.transfer(this.balance);\n', '    }\n', '\n', '\t\n', '    function selfLock() public payable onlyDirector {\n', '        require(saleClosed);\n', '        \n', '        require(msg.value == 10 ether);\n', '        \n', '        directorLock = true;\n', '    }\n', '    \n', '    function amendClaim(uint8 claimAmountSet, uint8 payAmountSet, uint8 feeAmountSet, uint8 accuracy) public onlyDirector returns (bool success) {\n', '        require(claimAmountSet == (payAmountSet + feeAmountSet));\n', '        \n', '        claimAmount = claimAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        payAmount = payAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        feeAmount = feeAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function amendEpoch(uint256 epochSet) public onlyDirector returns (bool success) {\n', '        epoch = epochSet;\n', '        return true;\n', '    }\n', '    \n', '\n', '    function amendRetention(uint8 retentionSet, uint8 accuracy) public onlyDirector returns (bool success) {\n', '        retentionMax = retentionSet * 10 ** (uint256(decimals) - accuracy);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function closeSale() public onlyDirector returns (bool success) {\n', '        require(!saleClosed);\n', '        \n', '\t\t\n', '        saleClosed = true;\n', '        return true;\n', '    }\n', '\n', '\n', '    function openSale() public onlyDirector returns (bool success) {\n', '        require(saleClosed);\n', '        \n', '        saleClosed = false;\n', '        return true;\n', '    }\n', '    \n', '\n', '    function bury() public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        require(balances[msg.sender] >= claimAmount);\n', '        \n', '        require(balances[msg.sender] <= retentionMax);\n', '        \n', '        buried[msg.sender] = true;\n', '        \n', '        claimed[msg.sender] = 1;\n', '        \n', '        Bury(msg.sender, balances[msg.sender]);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function claim(address _payout, address _fee) public returns (bool success) {\n', '        require(buried[msg.sender]);\n', '        \n', '        require(_payout != _fee);\n', '        \n', '        require(msg.sender != _payout);\n', '        \n', '        require(msg.sender != _fee);\n', '        \n', '        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= epoch);\n', '        \n', '        require(balances[msg.sender] >= claimAmount);\n', '        \n', '        claimed[msg.sender] = block.timestamp;\n', '        \n', '        uint256 previousBalances = balances[msg.sender] + balances[_payout] + balances[_fee];\n', '        \n', '        balances[msg.sender] -= claimAmount;\n', '        \n', '        balances[_payout] += payAmount;\n', '        \n', '        balances[_fee] += feeAmount;\n', '        \n', '        Claim(msg.sender, _payout, _fee);\n', '        Transfer(msg.sender, _payout, payAmount);\n', '        Transfer(msg.sender, _fee, feeAmount);\n', '        \n', '        assert(balances[msg.sender] + balances[_payout] + balances[_fee] == previousBalances);\n', '        return true;\n', '    }\n', '    \n', '    function () public payable {\n', '        require(!saleClosed);\n', '        \n', '        require(msg.value >= 1 finney);\n', '        \n', '        // Price is 1 ETH = 50000 TTT\n', '        uint256 amount = msg.value * 50000;\n', '        \n', '        // totalSupply limit is 5 million TTT\n', '        require(totalSupply + amount <= (5000000 * 10 ** uint256(decimals)));\n', '        \n', '        totalSupply += amount;\n', '        \n', '        balances[msg.sender] += amount;\n', '        \n', '        funds += msg.value;\n', '        \n', '        Transfer(this, msg.sender, amount);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(!buried[_from]);\n', '        \n', '        if (buried[_to]) {\n', '            require(balances[_to] + _value <= retentionMax);\n', '        }\n', '        \n', '        require(_to != 0x0);\n', '        \n', '        require(balances[_from] >= _value);\n', '        \n', '        require(balances[_to] + _value > balances[_to]);\n', '        \n', '        uint256 previousBalances = balances[_from] + balances[_to];\n', '        \n', '        balances[_from] -= _value;\n', '        \n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        \n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        require(balances[msg.sender] >= _value);\n', '        \n', '        balances[msg.sender] -= _value;\n', '        \n', '        totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(!buried[_from]);\n', '        \n', '        require(balances[_from] >= _value);\n', '        \n', '        require(_value <= allowance[_from][msg.sender]);\n', '        \n', '        balances[_from] -= _value;\n', '        \n', '        allowance[_from][msg.sender] -= _value;\n', '        \n', '        totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract TestToken {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    uint256 public funds;\n', '    address public director;\n', '    bool public saleClosed;\n', '    bool public directorLock;\n', '    uint256 public claimAmount;\n', '    uint256 public payAmount;\n', '    uint256 public feeAmount;\n', '    uint256 public epoch;\n', '    uint256 public retentionMax;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping (address => bool) public buried;\n', '    mapping (address => uint256) public claimed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed _from, uint256 _value);\n', '    \n', '    event Bury(address indexed _target, uint256 _value);\n', '    \n', '    event Claim(address indexed _target, address indexed _payout, address indexed _fee);\n', '\n', '    function TestToken() public {\n', '        director = msg.sender;\n', '        name = "test token";\n', '        symbol = "TTT";\n', '        decimals = 8;\n', '        saleClosed = false;\n', '        directorLock = false;\n', '        funds = 0;\n', '        totalSupply = 0;\n', '        \n', '        // Token Supply: 4.000.000 TTT\n', '        totalSupply += 4000000 * 10 ** uint256(decimals);\n', '        \n', '\t\t// 1.000.000 TTT Reserved for donate\n', '        \n', '        balances[director] = totalSupply;\n', '        \n', '        claimAmount = 5 * 10 ** (uint256(decimals) - 1);\n', '        payAmount = 4 * 10 ** (uint256(decimals) - 1);\n', '        feeAmount = 1 * 10 ** (uint256(decimals) - 1);\n', '        epoch = 31536000;\n', '        \n', '        retentionMax = 40 * 10 ** uint256(decimals);\n', '    }\n', '    \n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    modifier onlyDirector {\n', '        require(!directorLock);\n', '        \n', '        require(msg.sender == director);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDirectorForce {\n', '        require(msg.sender == director);\n', '        _;\n', '    }\n', '    \n', '\n', '    function transferDirector(address newDirector) public onlyDirectorForce {\n', '        director = newDirector;\n', '    }\n', '    \n', '\n', '    function withdrawFunds() public onlyDirectorForce {\n', '        director.transfer(this.balance);\n', '    }\n', '\n', '\t\n', '    function selfLock() public payable onlyDirector {\n', '        require(saleClosed);\n', '        \n', '        require(msg.value == 10 ether);\n', '        \n', '        directorLock = true;\n', '    }\n', '    \n', '    function amendClaim(uint8 claimAmountSet, uint8 payAmountSet, uint8 feeAmountSet, uint8 accuracy) public onlyDirector returns (bool success) {\n', '        require(claimAmountSet == (payAmountSet + feeAmountSet));\n', '        \n', '        claimAmount = claimAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        payAmount = payAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        feeAmount = feeAmountSet * 10 ** (uint256(decimals) - accuracy);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function amendEpoch(uint256 epochSet) public onlyDirector returns (bool success) {\n', '        epoch = epochSet;\n', '        return true;\n', '    }\n', '    \n', '\n', '    function amendRetention(uint8 retentionSet, uint8 accuracy) public onlyDirector returns (bool success) {\n', '        retentionMax = retentionSet * 10 ** (uint256(decimals) - accuracy);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function closeSale() public onlyDirector returns (bool success) {\n', '        require(!saleClosed);\n', '        \n', '\t\t\n', '        saleClosed = true;\n', '        return true;\n', '    }\n', '\n', '\n', '    function openSale() public onlyDirector returns (bool success) {\n', '        require(saleClosed);\n', '        \n', '        saleClosed = false;\n', '        return true;\n', '    }\n', '    \n', '\n', '    function bury() public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        require(balances[msg.sender] >= claimAmount);\n', '        \n', '        require(balances[msg.sender] <= retentionMax);\n', '        \n', '        buried[msg.sender] = true;\n', '        \n', '        claimed[msg.sender] = 1;\n', '        \n', '        Bury(msg.sender, balances[msg.sender]);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function claim(address _payout, address _fee) public returns (bool success) {\n', '        require(buried[msg.sender]);\n', '        \n', '        require(_payout != _fee);\n', '        \n', '        require(msg.sender != _payout);\n', '        \n', '        require(msg.sender != _fee);\n', '        \n', '        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= epoch);\n', '        \n', '        require(balances[msg.sender] >= claimAmount);\n', '        \n', '        claimed[msg.sender] = block.timestamp;\n', '        \n', '        uint256 previousBalances = balances[msg.sender] + balances[_payout] + balances[_fee];\n', '        \n', '        balances[msg.sender] -= claimAmount;\n', '        \n', '        balances[_payout] += payAmount;\n', '        \n', '        balances[_fee] += feeAmount;\n', '        \n', '        Claim(msg.sender, _payout, _fee);\n', '        Transfer(msg.sender, _payout, payAmount);\n', '        Transfer(msg.sender, _fee, feeAmount);\n', '        \n', '        assert(balances[msg.sender] + balances[_payout] + balances[_fee] == previousBalances);\n', '        return true;\n', '    }\n', '    \n', '    function () public payable {\n', '        require(!saleClosed);\n', '        \n', '        require(msg.value >= 1 finney);\n', '        \n', '        // Price is 1 ETH = 50000 TTT\n', '        uint256 amount = msg.value * 50000;\n', '        \n', '        // totalSupply limit is 5 million TTT\n', '        require(totalSupply + amount <= (5000000 * 10 ** uint256(decimals)));\n', '        \n', '        totalSupply += amount;\n', '        \n', '        balances[msg.sender] += amount;\n', '        \n', '        funds += msg.value;\n', '        \n', '        Transfer(this, msg.sender, amount);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(!buried[_from]);\n', '        \n', '        if (buried[_to]) {\n', '            require(balances[_to] + _value <= retentionMax);\n', '        }\n', '        \n', '        require(_to != 0x0);\n', '        \n', '        require(balances[_from] >= _value);\n', '        \n', '        require(balances[_to] + _value > balances[_to]);\n', '        \n', '        uint256 previousBalances = balances[_from] + balances[_to];\n', '        \n', '        balances[_from] -= _value;\n', '        \n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        \n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(!buried[msg.sender]);\n', '        \n', '        require(balances[msg.sender] >= _value);\n', '        \n', '        balances[msg.sender] -= _value;\n', '        \n', '        totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(!buried[_from]);\n', '        \n', '        require(balances[_from] >= _value);\n', '        \n', '        require(_value <= allowance[_from][msg.sender]);\n', '        \n', '        balances[_from] -= _value;\n', '        \n', '        allowance[_from][msg.sender] -= _value;\n', '        \n', '        totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']
