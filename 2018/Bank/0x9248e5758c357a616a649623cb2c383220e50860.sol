['contract PoolOwnersInterface {\n', '    bool public distributionActive;\n', '    function sendOwnership(address _receiver, uint256 _amount) public;\n', '    function sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) public;\n', '    function getOwnerTokens(address _owner) public returns (uint);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "Sender not authorised.");\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '    @title ItMap, a solidity iterable map\n', '    @dev Credit to: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1\n', ' */\n', 'library itmap {\n', '    struct entry {\n', '        // Equal to the index of the key of this item in keys, plus 1.\n', '        uint keyIndex;\n', '        uint value;\n', '    }\n', '\n', '    struct itmap {\n', '        mapping(uint => entry) data;\n', '        uint[] keys;\n', '    }\n', '\n', '    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\n', '        entry storage e = self.data[key];\n', '        e.value = value;\n', '        if (e.keyIndex > 0) {\n', '            return true;\n', '        } else {\n', '            e.keyIndex = ++self.keys.length;\n', '            self.keys[e.keyIndex - 1] = key;\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function remove(itmap storage self, uint key) internal returns (bool success) {\n', '        entry storage e = self.data[key];\n', '\n', '        if (e.keyIndex == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (e.keyIndex < self.keys.length) {\n', '            // Move an existing element into the vacated key slot.\n', '            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\n', '            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\n', '        }\n', '\n', '        self.keys.length -= 1;\n', '        delete self.data[key];\n', '        return true;\n', '    }\n', '\n', '    function contains(itmap storage self, uint key) internal view returns (bool exists) {\n', '        return self.data[key].keyIndex > 0;\n', '    }\n', '\n', '    function size(itmap storage self) internal view returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '\n', '    function get(itmap storage self, uint key) internal view returns (uint) {\n', '        return self.data[key].value;\n', '    }\n', '\n', '    function getKey(itmap storage self, uint idx) internal view returns (uint) {\n', '        return self.keys[idx];\n', '    }\n', '}\n', '\n', '/**\n', '    @title OwnersExchange\n', '    @dev Allow for trustless exchange of LP owners tokens\n', ' */\n', 'contract OwnersExchange is Ownable {\n', '\n', '    using SafeMath for uint;\n', '    using itmap for itmap.itmap;\n', '\n', '    enum ORDER_TYPE {\n', '        NULL, BUY, SELL\n', '    }\n', '    uint public orderCount;\n', '    uint public fee;\n', '    uint public lockedFees;\n', '    uint public totalFees;\n', '    mapping(uint => uint) public feeBalances;\n', '    address[] public addressRegistry; \n', '    mapping(address => uint) public addressIndex;\n', '\n', '    itmap.itmap orderBook;\n', '\n', '    PoolOwnersInterface public poolOwners;\n', '    ERC20 public feeToken;\n', '\n', '    event NewOrder(ORDER_TYPE indexed orderType, address indexed sender, uint price, uint amount);\n', '    event OrderRemoved(ORDER_TYPE indexed orderType, address indexed sender, uint price, uint amount);\n', '    event OrderFilled(ORDER_TYPE indexed orderType, address indexed sender, address receiver, uint price, uint amount);\n', '\n', '    /**\n', '        @dev Initialise the contract\n', '        @param _poolOwners Set the address of the PoolOwners contract used in this DEX\n', '     */\n', '    constructor(address _poolOwners, address _feeToken) public {\n', '        require(_poolOwners != address(0), "_poolOwners needs to be set");\n', '        poolOwners = PoolOwnersInterface(_poolOwners);\n', '        feeToken = ERC20(_feeToken);\n', '        addressRegistry.push(address(0));\n', '        orderCount = 1;\n', '    }\n', '\n', '    /**\n', '        @dev Register an address to a uint allowing packing in orders\n', '        @param _address The address to register\n', '     */\n', '    function addressRegister(address _address) private returns (uint) {\n', '        if (addressIndex[_address] != 0) {\n', '            return addressIndex[_address];\n', '        } else {\n', '            require(addressRegistry.length < 1 << 32, "Registered addresses hit maximum");\n', '            addressIndex[_address] = addressRegistry.length;\n', '            addressRegistry.push(_address);\n', '            return addressRegistry.length - 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev ERC677 Reciever for fee token transfer (Always expected to be LINK)\n', '        @param _sender The address of the sender of the token\n', '        @param _value The amount of token received\n', '        @param _data Extra data, not needed in this use-case\n', '     */\n', '    function onTokenTransfer(address _sender, uint256 _value, bytes _data) public {\n', '        require(msg.sender == address(feeToken), "Sender needs to be the fee token");\n', '        uint index = addressRegister(_sender);\n', '        feeBalances[index] = feeBalances[index].add(_value);\n', '        totalFees = totalFees.add(_value);\n', '    }\n', '\n', '    /**\n', '        @dev Allow users to withdraw any tokens used for fees\n', '        @param _value The amount wanting to be withdrawn\n', '     */\n', '    function withdrawFeeToken(uint256 _value) public {\n', '        uint index = addressRegister(msg.sender);\n', '        require(feeBalances[index] >= _value, "You\'re withdrawing more than your balance");\n', '        feeBalances[index] = feeBalances[index].sub(_value);\n', '        totalFees = totalFees.sub(_value);\n', '        if (feeBalances[index] == 0) {\n', '            delete feeBalances[index];\n', '        }\n', '        feeToken.transfer(msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '        @dev Set the fee percentage\n', '        @param _fee The percentage of fees to be taken in LINK\n', '     */\n', '    function setFee(uint _fee) public onlyOwner {\n', '        require(_fee <= 500 finney, "Fees can\'t be more than 50%");\n', '        fee = _fee;\n', '    }\n', '\n', '    /**\n', '        @dev Returns the fee cost based on a price & amount\n', '        @param _price The price of the order\n', '        @param _amount The amount requested\n', '     */\n', '    function feeForOrder(uint _price, uint _amount) public view returns (uint) {\n', '        return _price\n', '            .mul(_amount)\n', '            .div(1 ether)\n', '            .mul(fee)\n', '            .div(1 ether);\n', '    }\n', '\n', '    /**\n', '        @dev Returns the ETH cost of an order\n', '        @param _price The price of the order\n', '        @param _amount The amount requested\n', '     */\n', '    function costOfOrder(uint _price, uint _amount) public pure returns (uint) {\n', '        return _price.mul(_amount).div(1 ether);\n', '    }\n', '\n', '    /**\n', '        @dev Create a new sell order\n', '        @param _price The price of the order per 1 ether of token\n', '        @param _amount The amount of tokens being sent\n', '     */\n', '    function addSellOrder(uint _price, uint _amount) public {\n', '        require(is111bit(_price) && is111bit(_amount), "Price or amount exceeds 111 bits");\n', '\n', '        require(_price > 0, "Price needs to be greater than 0");\n', '        require(_amount > 0, "Amount needs to be greater than 0");\n', '\n', '        uint orderFee = feeForOrder(_price, _amount);\n', '        uint index = addressRegister(msg.sender);\n', '        if (orderFee > 0) {\n', '            require(feeBalances[index] >= orderFee, "You do not have enough deposited for fees");\n', '            feeBalances[index] = feeBalances[index].sub(orderFee);\n', '            feeBalances[0] = feeBalances[0].add(orderFee);\n', '            lockedFees = lockedFees.add(orderFee);\n', '        }\n', '        poolOwners.sendOwnershipFrom(msg.sender, this, _amount);\n', '\n', '        require(\n', '            !orderBook.insert(orderCount, (((uint(ORDER_TYPE.SELL) << 32 | index) << 111 | _price) << 111) | _amount), \n', '            "Map replacement detected"\n', '        );\n', '        orderCount += 1;\n', '    \n', '        emit NewOrder(ORDER_TYPE.SELL, msg.sender, _price, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Add a new buy order, ETH sent needs to equal: (price * amount) / 18\n', '        @param _price The price of the buy order per 1 ether of LP token\n', '        @param _amount The amount of tokens wanting to be purchased\n', '     */\n', '    function addBuyOrder(uint _price, uint _amount) public payable {\n', '        require(is111bit(_price) && is111bit(_amount), "Price or amount exceeds 111 bits");\n', '\n', '        require(_price > 0, "Price needs to be greater than 0");\n', '        require(_amount > 0, "Amount needs to be greater than 0");\n', '\n', '        uint orderFee = feeForOrder(_price, _amount);\n', '        uint index = addressRegister(msg.sender);\n', '        if (orderFee > 0) {\n', '            require(feeBalances[index] >= orderFee, "You do not have enough deposited for fees");\n', '            feeBalances[index] = feeBalances[index].sub(orderFee);\n', '            feeBalances[0] = feeBalances[0].add(orderFee);\n', '            lockedFees = lockedFees.add(orderFee);\n', '        }\n', '\n', '        uint cost = _price.mul(_amount).div(1 ether);\n', '        require(_price.mul(_amount) == cost.mul(1 ether), "The price and amount of this order is too small");\n', '        require(msg.value == cost, "ETH sent needs to equal the cost");\n', '\n', '        require(\n', '            !orderBook.insert(orderCount, (((uint(ORDER_TYPE.BUY) << 32 | index) << 111 | _price) << 111) | _amount), \n', '            "Map replacement detected"\n', '        );\n', '        orderCount += 1;\n', '    \n', '        emit NewOrder(ORDER_TYPE.BUY, msg.sender, _price, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Remove a buy order and refund ETH back to the sender\n', '        @param _key The key of the order in the book\n', '     */\n', '    function removeBuyOrder(uint _key) public {\n', '        uint order = orderBook.get(_key);\n', '        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\n', '        require(orderType == ORDER_TYPE.BUY, "This is not a buy order");\n', '        uint index = addressIndex[msg.sender];\n', '        require(index == (order << 2) >> 224, "You are not the sender of this order");\n', '\n', '        uint price = (order << 34) >> 145;\n', '        uint amount = (order << 145) >> 145;\n', '        require(orderBook.remove(_key), "Map remove failed");\n', '\n', '        uint orderFee = feeForOrder(price, amount);\n', '        feeBalances[index] = feeBalances[index].add(orderFee);\n', '        feeBalances[0] = feeBalances[0].sub(orderFee);\n', '        lockedFees = lockedFees.sub(orderFee);\n', '\n', '        uint cost = price.mul(amount).div(1 ether);\n', '        msg.sender.transfer(cost);\n', '\n', '        emit OrderRemoved(orderType, msg.sender, price, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Remove a sell order and refund the LP tokens back to the sender\n', '        @param _key The key of the order in the book\n', '     */\n', '    function removeSellOrder(uint _key) public {\n', '        uint order = orderBook.get(_key);\n', '        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\n', '        require(orderType == ORDER_TYPE.SELL, "This is not a sell order");\n', '        uint index = addressIndex[msg.sender];\n', '        require(index == (order << 2) >> 224, "You are not the sender of this order");\n', '\n', '        uint price = (order << 34) >> 145;\n', '        uint amount = (order << 145) >> 145;\n', '        require(orderBook.remove(_key), "Map remove failed");\n', '\n', '        uint orderFee = feeForOrder(price, amount);\n', '        feeBalances[index] = feeBalances[index].add(orderFee);\n', '        feeBalances[0] = feeBalances[0].sub(orderFee);\n', '        lockedFees = lockedFees.sub(orderFee);\n', '\n', '        poolOwners.sendOwnership(msg.sender, amount);\n', '\n', '        emit OrderRemoved(orderType, msg.sender, price, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Fill a sell order in the order book\n', '        @dev Orders have to be filled in whole amounts\n', '        @param _key Key of the order as per orderbook\n', '     */\n', '    function fillSellOrder(uint _key) public payable {\n', '        uint order = orderBook.get(_key);\n', '        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\n', '        require(orderType == ORDER_TYPE.SELL, "This is not a sell order");\n', '        uint index = addressRegister(msg.sender);\n', '        require(index != (order << 2) >> 224, "You cannot fill your own order");\n', '\n', '        uint price = (order << 34) >> 145;\n', '        uint amount = (order << 145) >> 145;\n', '\n', '        uint orderFee = feeForOrder(price, amount);\n', '        require(feeBalances[index] >= orderFee, "You do not have enough deposited fees to fill this order");\n', '\n', '        uint cost = price.mul(amount).div(1 ether);\n', '        require(msg.value == cost, "ETH sent needs to equal the cost");\n', '\n', '        require(orderBook.remove(_key), "Map remove failed");\n', '\n', '        addressRegistry[(order << 2) >> 224].transfer(msg.value);\n', '        poolOwners.sendOwnership(msg.sender, amount);\n', '\n', '        if (orderFee > 0) {\n', '            feeBalances[index] = feeBalances[index].sub(orderFee);\n', '            feeBalances[0] = feeBalances[0].add(orderFee);\n', '            lockedFees = lockedFees.sub(orderFee);\n', '        }\n', '\n', '        emit OrderFilled(orderType, addressRegistry[(order << 2) >> 224], msg.sender, price, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Fill a buy order in the order book\n', '        @dev Orders have to be filled in whole amounts\n', '        @param _key Key of the order, which is the buyers address\n', '     */\n', '    function fillBuyOrder(uint _key) public {\n', '        uint order = orderBook.get(_key);\n', '        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\n', '        require(orderType == ORDER_TYPE.BUY, "This is not a buy order");\n', '        uint index = addressRegister(msg.sender);\n', '        require(index != (order << 2) >> 224, "You cannot fill your own order");\n', '\n', '        uint price = (order << 34) >> 145;\n', '        uint amount = (order << 145) >> 145;\n', '\n', '        uint orderFee = feeForOrder(price, amount);\n', '        require(feeBalances[index] >= orderFee, "You do not have enough deposited fees to fill this order");\n', '\n', '        uint cost = price.mul(amount).div(1 ether);\n', '        \n', '        require(orderBook.remove(_key), "Map remove failed");\n', '\n', '        msg.sender.transfer(cost);\n', '        poolOwners.sendOwnershipFrom(msg.sender, addressRegistry[(order << 2) >> 224], amount);\n', '\n', '        if (orderFee > 0) {\n', '            feeBalances[index] = feeBalances[index].sub(orderFee);\n', '            feeBalances[0] = feeBalances[0].add(orderFee);\n', '            lockedFees = lockedFees.sub(orderFee);\n', '        }\n', '\n', '        emit OrderFilled(orderType, addressRegistry[(order << 2) >> 224], msg.sender, price, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Send tokens earned via fees back to PoolOwners to be re-distributed\n', '     */\n', '    function withdrawFeesToPoolOwners() public {\n', '        uint feeBalance = feeBalances[0];\n', '        require(feeBalance > lockedFees, "Contract doesn\'t have a withdrawable fee balance");\n', '        feeBalances[0] = lockedFees;\n', '        uint amount = feeBalance.sub(lockedFees);\n', '        totalFees = totalFees.sub(amount);\n', '        feeToken.transfer(poolOwners, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Send any fee token earned via PoolOwners distribution back to be re-distributed\n', '     */\n', '    function withdrawDistributedToPoolOwners() public {\n', '        uint balance = feeToken.balanceOf(this).sub(totalFees);\n', '        require(balance > 0, "There is no distributed fee token balance in the contract");\n', '        feeToken.transfer(poolOwners, balance);\n', '    }\n', '\n', '    /**\n', '        @dev Get a single order by its key\n', '        @param _key The key of the order as per the book\n', '     */\n', '    function getOrder(uint _key) public view returns (ORDER_TYPE, address, uint, uint) {\n', '        uint order = orderBook.get(_key);\n', '        return (\n', '            ORDER_TYPE(order >> 254), \n', '            addressRegistry[(order << 2) >> 224], \n', '            (order << 34) >> 145, \n', '            (order << 145) >> 145\n', '        );\n', '    }\n', '\n', '    /**\n', '        @dev Get a batch of 10 orders by a given array of keys\n', "        @dev ID's has to be equal or less than 10 in length, or an empty response is given\n", '        @param _start The starting index in the order book to return from\n', '     */\n', '    function getOrders(uint _start) public view returns (\n', '        uint[10] keys,\n', '        address[10] addresses, \n', '        ORDER_TYPE[10] orderTypes, \n', '        uint[10] prices, \n', '        uint[10] amounts\n', '    ) {\n', '        for (uint i = 0; i < 10; i++) {\n', '            if (orderBook.size() == _start + i) {\n', '                break;\n', '            }\n', '            uint key = orderBook.getKey(_start + i);\n', '            keys[i] = key;\n', '            uint order = orderBook.get(key);\n', '            addresses[i] = addressRegistry[(order << 2) >> 224];\n', '            orderTypes[i] = ORDER_TYPE(order >> 254);\n', '            prices[i] = (order << 34) >> 145;\n', '            amounts[i] = (order << 145) >> 145;\n', '        }\n', '        return (keys, addresses, orderTypes, prices, amounts);\n', '    }\n', '\n', '    /**\n', '        @dev Get an orderbook key from the orderbook index\n', '        @param _i The index to fetch the key for\n', '     */\n', '    function getOrderBookKey(uint _i) public view returns (uint key) {\n', '        if (_i < orderBook.size()) {\n', '            key = orderBook.getKey(_i);\n', '        } else {\n', '            key = 0;\n', '        }\n', '        return key;\n', '    }\n', '\n', '    /**\n', '        @dev Get orderbook keys in batches of 10\n', '        @param _start The start of the index for the batch\n', '     */\n', '    function getOrderBookKeys(uint _start) public view returns (uint[10] keys) {\n', '        for (uint i = 0; i < 10; i++) {\n', '            if (i + _start < orderBook.size()) {\n', '                keys[i] = orderBook.getKey(_start + i);\n', '            } else {\n', '                keys[i] = 0;\n', '            }\n', '        }\n', '        return keys;\n', '    }\n', '\n', '    /**\n', '        @dev Get the orderbook size to allow for batch fetching of keys\n', '     */\n', '    function getOrderBookSize() public view returns (uint) {\n', '        return orderBook.size();\n', '    }\n', '\n', '    /**\n', '        @dev Verify that the number being passed fits into 111 bits for packing\n', '        @param _val The value to check\n', '     */\n', '    function is111bit(uint _val) private pure returns (bool) {\n', '        return (_val < 1 << 111);\n', '    }\n', '\n', '}']