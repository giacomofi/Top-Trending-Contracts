['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * split income between shareholders\n', ' */\n', 'contract Share {\n', '  address public owner;\n', '  address[] public shares;\n', '  bool public pause;\n', '  mapping (address => uint256) public holds;\n', '\n', '  function Share() public {\n', '    owner = msg.sender;\n', '    shares.push(owner);\n', '    pause = false;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!pause);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyOwner {\n', '    pause = true;\n', '  }\n', '\n', '  function unpause() public onlyOwner {\n', '    pause = false;\n', '  }\n', '\n', '  function addShare(address _share) public onlyOwner {\n', '    for (uint i = 0; i < shares.length; i ++) {\n', '      if (shares[i] == _share) {\n', '        return;\n', '      }\n', '    }\n', '    shares.push(_share);\n', '  }\n', '\n', '  function removeShare(address _share) public onlyOwner {\n', '    uint i = 0;\n', '    for (; i < shares.length; i ++) {\n', '      if (shares[i] == _share) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (i > shares.length - 1) {\n', '      //not found\n', '      return;\n', '    } else {\n', '      shares[i] = shares[shares.length - 1];\n', '      shares.length = shares.length - 1;\n', '      return;\n', '    }\n', '  }\n', '\n', '  function split(uint256 value) internal {\n', '    uint256 each = value / shares.length;\n', '\n', '    for (uint i = 0; i < shares.length; i ++) {\n', '      holds[shares[i]] += each;\n', '    }\n', '\n', '    holds[owner] += value - each * shares.length;\n', '    return;\n', '  }\n', '\n', '  function withdrawal() public whenNotPaused {\n', '    if (holds[msg.sender] > 0) {\n', '      uint256 v = holds[msg.sender];\n', '      holds[msg.sender] = 0;\n', '      msg.sender.transfer(v);\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract AirDrop is Share {\n', '  // owner => (token addr => token amount)  \n', '  mapping(address => mapping(address => uint256)) toDrop;\n', '\n', '  uint256 public fee;\n', '\n', '  function AirDrop (uint256 _fee) public {\n', '      fee = _fee;\n', '  }\n', '   \n', '  function setFee(uint256 _fee) public onlyOwner {\n', '    fee = _fee;\n', '  }\n', '\n', '  function drop(address _token, address[] dsts, uint256 value) public payable whenNotPaused {\n', '    require(dsts.length > 0);\n', '    uint256 total = dsts.length * value;\n', '    assert(total / dsts.length == value);\n', '    require(msg.value >= fee);\n', '    \n', '    split(fee);\n', '    \n', '    uint256 i = 0;\n', '    if (_token == address(0)) {\n', '      //send ETH\n', '      require((fee + total) >= total);\n', '      require(msg.value >= (fee + total));\n', '      \n', '      while (i < dsts.length) {\n', '        dsts[i].transfer(value);        \n', '        i += 1;\n', '      }\n', '\n', '    } else {\n', '      ERC20 erc20 = ERC20(_token);\n', '      require(erc20.allowance(msg.sender, this) >= total);\n', '\n', '      while (i < dsts.length) {\n', '        erc20.transferFrom(msg.sender, dsts[i], value);\n', '        i += 1;\n', '      }\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * split income between shareholders\n', ' */\n', 'contract Share {\n', '  address public owner;\n', '  address[] public shares;\n', '  bool public pause;\n', '  mapping (address => uint256) public holds;\n', '\n', '  function Share() public {\n', '    owner = msg.sender;\n', '    shares.push(owner);\n', '    pause = false;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!pause);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyOwner {\n', '    pause = true;\n', '  }\n', '\n', '  function unpause() public onlyOwner {\n', '    pause = false;\n', '  }\n', '\n', '  function addShare(address _share) public onlyOwner {\n', '    for (uint i = 0; i < shares.length; i ++) {\n', '      if (shares[i] == _share) {\n', '        return;\n', '      }\n', '    }\n', '    shares.push(_share);\n', '  }\n', '\n', '  function removeShare(address _share) public onlyOwner {\n', '    uint i = 0;\n', '    for (; i < shares.length; i ++) {\n', '      if (shares[i] == _share) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (i > shares.length - 1) {\n', '      //not found\n', '      return;\n', '    } else {\n', '      shares[i] = shares[shares.length - 1];\n', '      shares.length = shares.length - 1;\n', '      return;\n', '    }\n', '  }\n', '\n', '  function split(uint256 value) internal {\n', '    uint256 each = value / shares.length;\n', '\n', '    for (uint i = 0; i < shares.length; i ++) {\n', '      holds[shares[i]] += each;\n', '    }\n', '\n', '    holds[owner] += value - each * shares.length;\n', '    return;\n', '  }\n', '\n', '  function withdrawal() public whenNotPaused {\n', '    if (holds[msg.sender] > 0) {\n', '      uint256 v = holds[msg.sender];\n', '      holds[msg.sender] = 0;\n', '      msg.sender.transfer(v);\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract AirDrop is Share {\n', '  // owner => (token addr => token amount)  \n', '  mapping(address => mapping(address => uint256)) toDrop;\n', '\n', '  uint256 public fee;\n', '\n', '  function AirDrop (uint256 _fee) public {\n', '      fee = _fee;\n', '  }\n', '   \n', '  function setFee(uint256 _fee) public onlyOwner {\n', '    fee = _fee;\n', '  }\n', '\n', '  function drop(address _token, address[] dsts, uint256 value) public payable whenNotPaused {\n', '    require(dsts.length > 0);\n', '    uint256 total = dsts.length * value;\n', '    assert(total / dsts.length == value);\n', '    require(msg.value >= fee);\n', '    \n', '    split(fee);\n', '    \n', '    uint256 i = 0;\n', '    if (_token == address(0)) {\n', '      //send ETH\n', '      require((fee + total) >= total);\n', '      require(msg.value >= (fee + total));\n', '      \n', '      while (i < dsts.length) {\n', '        dsts[i].transfer(value);        \n', '        i += 1;\n', '      }\n', '\n', '    } else {\n', '      ERC20 erc20 = ERC20(_token);\n', '      require(erc20.allowance(msg.sender, this) >= total);\n', '\n', '      while (i < dsts.length) {\n', '        erc20.transferFrom(msg.sender, dsts[i], value);\n', '        i += 1;\n', '      }\n', '    }\n', '  }\n', '}']
