['pragma solidity 0.4.23;\n', '\n', 'contract PasswordEscrow {\n', '  address public owner;\n', '  uint256 public commissionFee;\n', '  uint256 public totalFee;\n', '\n', '  //data\n', '  struct Transfer {\n', '    address from;\n', '    uint256 amount;\n', '  }\n', '\n', '  mapping(bytes32 => Transfer) private transferToPassword;\n', '\n', '  mapping(address => uint256) private indexToAddress;\n', '  mapping(address => mapping(uint256 => bytes32)) private passwordToAddress;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier passwordOwner(bytes32 _byte) {\n', '    require(\n', '      transferToPassword[_byte].from == msg.sender &&\n', '      transferToPassword[_byte].amount > 0\n', '    );\n', '    _;\n', '  }\n', '\n', '  event LogChangeCommissionFee(uint256 fee);\n', '  event LogChangeOwner(address indexed exOwner, address indexed newOwner);\n', '  event LogDeposit(address indexed from, uint256 amount);\n', '  event LogGetTransfer(address indexed from, address indexed recipient, uint256 amount);\n', '  event LogEmergency(address indexed from, uint256 amount);\n', '\n', '\n', '\n', '  constructor(uint256 _fee) public {\n', '    commissionFee = _fee;\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function changeCommissionFee(uint256 _fee) public onlyOwner {\n', '    commissionFee = _fee;\n', '\n', '    emit LogChangeCommissionFee(_fee);\n', '  }\n', '\n', '  function changeOwner(address _newOwner) public onlyOwner {\n', '    address exOwner = owner;\n', '    owner = _newOwner;\n', '\n', '    emit LogChangeOwner(exOwner, _newOwner);\n', '  }\n', '\n', '\n', '  //simple transfer\n', '  function deposit(bytes32 _password) public payable {\n', '    require(\n', '      msg.value > commissionFee &&\n', '      transferToPassword[sha3(_password)].amount == 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password);\n', '    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n', '\n', '    uint256 index = indexToAddress[msg.sender];\n', '\n', '    indexToAddress[msg.sender]++;\n', '    passwordToAddress[msg.sender][index] = pass;\n', '\n', '    emit LogDeposit(msg.sender, msg.value);\n', '  }\n', '\n', '  function getTransfer(bytes32 _password) public payable {\n', '    require(\n', '      transferToPassword[sha3(_password)].amount > 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password);\n', '    address from = transferToPassword[pass].from;\n', '    uint256 amount = transferToPassword[pass].amount - commissionFee;\n', '    totalFee += commissionFee;\n', '\n', '    transferToPassword[pass].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogGetTransfer(from, msg.sender, amount);\n', '  }\n', '\n', '\n', '\n', '  //advanced transfer\n', '  function AdvancedDeposit(bytes32 _password, bytes32 _num) public payable {\n', '    require(\n', '      msg.value >= commissionFee &&\n', '      transferToPassword[sha3(_password, _num)].amount == 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password, _num);\n', '    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n', '\n', '    uint256 index = indexToAddress[msg.sender];\n', '\n', '    indexToAddress[msg.sender]++;\n', '    passwordToAddress[msg.sender][index] = pass;\n', '\n', '\n', '    emit LogDeposit(msg.sender, msg.value);\n', '  }\n', '\n', '  function getAdvancedTransfer(bytes32 _password, bytes32 _num) public payable {\n', '    require(\n', '      transferToPassword[sha3(_password, _num)].amount > 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password, _num);\n', '    address from = transferToPassword[pass].from;\n', '    uint256 amount = transferToPassword[pass].amount - commissionFee;\n', '    totalFee += commissionFee;\n', '\n', '    transferToPassword[pass].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogGetTransfer(from, msg.sender, amount);\n', '  }\n', '\n', '  function viewIndexNumber() public view returns(uint256) {\n', '    return indexToAddress[msg.sender];\n', '  }\n', '\n', '  function viewPassword(uint256 _index) public view returns(bytes32, uint256) {\n', '    bytes32 hash = passwordToAddress[msg.sender][_index];\n', '    uint256 value = transferToPassword[hash].amount;\n', '\n', '    return (hash, value);\n', '  }\n', '\n', '  function emergency(bytes32 _byte) public payable passwordOwner(_byte) {\n', '\n', '    uint256 amount = transferToPassword[_byte].amount - commissionFee * 2;\n', '    totalFee += commissionFee * 2;\n', '    transferToPassword[_byte].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogEmergency(msg.sender, amount);\n', '  }\n', '\n', '  function withdrawFee() public payable onlyOwner {\n', '    require( totalFee > 0);\n', '\n', '    uint256 fee = totalFee;\n', '    totalFee = 0;\n', '\n', '    msg.sender.transfer(totalFee);\n', '  }\n', '\n', '  function withdraw() public payable onlyOwner {\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '\n', '}']
['pragma solidity 0.4.23;\n', '\n', 'contract PasswordEscrow {\n', '  address public owner;\n', '  uint256 public commissionFee;\n', '  uint256 public totalFee;\n', '\n', '  //data\n', '  struct Transfer {\n', '    address from;\n', '    uint256 amount;\n', '  }\n', '\n', '  mapping(bytes32 => Transfer) private transferToPassword;\n', '\n', '  mapping(address => uint256) private indexToAddress;\n', '  mapping(address => mapping(uint256 => bytes32)) private passwordToAddress;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier passwordOwner(bytes32 _byte) {\n', '    require(\n', '      transferToPassword[_byte].from == msg.sender &&\n', '      transferToPassword[_byte].amount > 0\n', '    );\n', '    _;\n', '  }\n', '\n', '  event LogChangeCommissionFee(uint256 fee);\n', '  event LogChangeOwner(address indexed exOwner, address indexed newOwner);\n', '  event LogDeposit(address indexed from, uint256 amount);\n', '  event LogGetTransfer(address indexed from, address indexed recipient, uint256 amount);\n', '  event LogEmergency(address indexed from, uint256 amount);\n', '\n', '\n', '\n', '  constructor(uint256 _fee) public {\n', '    commissionFee = _fee;\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function changeCommissionFee(uint256 _fee) public onlyOwner {\n', '    commissionFee = _fee;\n', '\n', '    emit LogChangeCommissionFee(_fee);\n', '  }\n', '\n', '  function changeOwner(address _newOwner) public onlyOwner {\n', '    address exOwner = owner;\n', '    owner = _newOwner;\n', '\n', '    emit LogChangeOwner(exOwner, _newOwner);\n', '  }\n', '\n', '\n', '  //simple transfer\n', '  function deposit(bytes32 _password) public payable {\n', '    require(\n', '      msg.value > commissionFee &&\n', '      transferToPassword[sha3(_password)].amount == 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password);\n', '    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n', '\n', '    uint256 index = indexToAddress[msg.sender];\n', '\n', '    indexToAddress[msg.sender]++;\n', '    passwordToAddress[msg.sender][index] = pass;\n', '\n', '    emit LogDeposit(msg.sender, msg.value);\n', '  }\n', '\n', '  function getTransfer(bytes32 _password) public payable {\n', '    require(\n', '      transferToPassword[sha3(_password)].amount > 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password);\n', '    address from = transferToPassword[pass].from;\n', '    uint256 amount = transferToPassword[pass].amount - commissionFee;\n', '    totalFee += commissionFee;\n', '\n', '    transferToPassword[pass].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogGetTransfer(from, msg.sender, amount);\n', '  }\n', '\n', '\n', '\n', '  //advanced transfer\n', '  function AdvancedDeposit(bytes32 _password, bytes32 _num) public payable {\n', '    require(\n', '      msg.value >= commissionFee &&\n', '      transferToPassword[sha3(_password, _num)].amount == 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password, _num);\n', '    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n', '\n', '    uint256 index = indexToAddress[msg.sender];\n', '\n', '    indexToAddress[msg.sender]++;\n', '    passwordToAddress[msg.sender][index] = pass;\n', '\n', '\n', '    emit LogDeposit(msg.sender, msg.value);\n', '  }\n', '\n', '  function getAdvancedTransfer(bytes32 _password, bytes32 _num) public payable {\n', '    require(\n', '      transferToPassword[sha3(_password, _num)].amount > 0\n', '    );\n', '\n', '    bytes32 pass = sha3(_password, _num);\n', '    address from = transferToPassword[pass].from;\n', '    uint256 amount = transferToPassword[pass].amount - commissionFee;\n', '    totalFee += commissionFee;\n', '\n', '    transferToPassword[pass].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogGetTransfer(from, msg.sender, amount);\n', '  }\n', '\n', '  function viewIndexNumber() public view returns(uint256) {\n', '    return indexToAddress[msg.sender];\n', '  }\n', '\n', '  function viewPassword(uint256 _index) public view returns(bytes32, uint256) {\n', '    bytes32 hash = passwordToAddress[msg.sender][_index];\n', '    uint256 value = transferToPassword[hash].amount;\n', '\n', '    return (hash, value);\n', '  }\n', '\n', '  function emergency(bytes32 _byte) public payable passwordOwner(_byte) {\n', '\n', '    uint256 amount = transferToPassword[_byte].amount - commissionFee * 2;\n', '    totalFee += commissionFee * 2;\n', '    transferToPassword[_byte].amount = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    emit LogEmergency(msg.sender, amount);\n', '  }\n', '\n', '  function withdrawFee() public payable onlyOwner {\n', '    require( totalFee > 0);\n', '\n', '    uint256 fee = totalFee;\n', '    totalFee = 0;\n', '\n', '    msg.sender.transfer(totalFee);\n', '  }\n', '\n', '  function withdraw() public payable onlyOwner {\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '\n', '}']
