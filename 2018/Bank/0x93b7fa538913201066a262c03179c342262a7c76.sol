['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract UnicornManagementInterface {\n', '\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    function blackBoxAddress() external view returns (address);\n', '    function unicornBreedingAddress() external view returns (address);\n', '    function geneLabAddress() external view returns (address);\n', '    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function candyPowerToken() external view returns (address);\n', '\n', '    function createDividendPercent() external view returns (uint);\n', '    function sellDividendPercent() external view returns (uint);\n', '    function subFreezingPrice() external view returns (uint);\n', '    function subFreezingTime() external view returns (uint64);\n', '    function subTourFreezingPrice() external view returns (uint);\n', '    function subTourFreezingTime() external view returns (uint64);\n', '    function createUnicornPrice() external view returns (uint);\n', '    function createUnicornPriceInCandy() external view returns (uint);\n', '    function oraclizeFee() external view returns (uint);\n', '\n', '    function paused() external view returns (bool);\n', '    //    function locked() external view returns (bool);\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool);\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint);\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint);\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint);\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint);\n', '\n', '\n', '    //service\n', '    function registerInit(address _contract) external;\n', '\n', '}\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract megaCandyInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', 'contract DividendManagerInterface {\n', '    function payDividend() external payable;\n', '}\n', '\n', 'contract BlackBoxInterface {\n', '    function createGen0(uint _unicornId) public payable;\n', '    function geneCore(uint _childUnicornId, uint _parent1UnicornId, uint _parent2UnicornId) public payable;\n', '}\n', '\n', 'contract UnicornTokenInterface {\n', '\n', '    //ERC721\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _unicornId) public view returns (address _owner);\n', '    function transfer(address _to, uint256 _unicornId) public;\n', '    function approve(address _to, uint256 _unicornId) public;\n', '    function takeOwnership(uint256 _unicornId) public;\n', '    function totalSupply() public constant returns (uint);\n', '    function owns(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function allowance(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _unicornId) public;\n', '\n', '    //specific\n', '    function createUnicorn(address _owner) external returns (uint);\n', '    //    function burnUnicorn(uint256 _unicornId) external;\n', '    function getGen(uint _unicornId) external view returns (bytes);\n', '    function setGene(uint _unicornId, bytes _gene) external;\n', '    function updateGene(uint _unicornId, bytes _gene) external;\n', '    function getUnicornGenByte(uint _unicornId, uint _byteNo) external view returns (uint8);\n', '\n', '    function setName(uint256 _unicornId, string _name ) external returns (bool);\n', '    function plusFreezingTime(uint _unicornId) external;\n', '    function plusTourFreezingTime(uint _unicornId) external;\n', '    function minusFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function minusTourFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function isUnfreezed(uint _unicornId) external view returns (bool);\n', '    function isTourUnfreezed(uint _unicornId) external view returns (bool);\n', '\n', '    function marketTransfer(address _from, address _to, uint256 _unicornId) external;\n', '}\n', '\n', '\n', '\n', 'contract UnicornAccessControl {\n', '\n', '    UnicornManagementInterface public unicornManagement;\n', '\n', '    function UnicornAccessControl(address _unicornManagementAddress) public {\n', '        unicornManagement = UnicornManagementInterface(_unicornManagementAddress);\n', '        unicornManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == unicornManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == unicornManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == unicornManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyTournament() {\n', '        require(unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '\n', '    modifier onlyManagement() {\n', '        require(msg.sender == address(unicornManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyBreeding() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyGeneLab() {\n', '        require(msg.sender == unicornManagement.geneLabAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyBlackBox() {\n', '        require(msg.sender == unicornManagement.blackBoxAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornToken() {\n', '        require(msg.sender == unicornManagement.unicornTokenAddress());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return unicornManagement.paused();\n', '    }\n', '}\n', '\n', 'contract UnicornBreeding is UnicornAccessControl {\n', '    using SafeMath for uint;\n', '    //onlyOwner\n', '    UnicornTokenInterface public unicornToken; //only on deploy\n', '    BlackBoxInterface public blackBox;\n', '\n', '    event HybridizationAdd(uint indexed unicornId, uint price);\n', '    event HybridizationAccept(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId);\n', '    event HybridizationDelete(uint indexed unicornId);\n', '    event FundsTransferred(address dividendManager, uint value);\n', '    event CreateUnicorn(address indexed owner, uint indexed unicornId, uint parent1, uint  parent2);\n', '    event NewGen0Limit(uint limit);\n', '    event NewGen0Step(uint step);\n', '\n', '\n', '    event OfferAdd(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event OfferDelete(uint256 indexed unicornId);\n', '    event UnicornSold(uint256 indexed unicornId);\n', '\n', '    event NewSellDividendPercent(uint percentCandy, uint percentCandyEth);\n', '\n', '    ERC20 public candyToken;\n', '    megaCandyInterface public megaCandyToken;\n', '\n', '    uint public sellDividendPercentCandy = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercentEth = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '\n', '    //counter for gen0\n', '    uint public gen0Limit = 30000;\n', '    uint public gen0Count = 1805;\n', '    uint public gen0Step = 1000;\n', '\n', '    //counter for presale gen0\n', '    uint public gen0PresaleLimit = 1000;\n', '    uint public gen0PresaleCount = 0;\n', '\n', '    struct Hybridization{\n', '        uint listIndex;\n', '        uint price;\n', '        //        uint second_unicorn_id;\n', '        //        bool accepted;\n', '        bool exists;\n', '    }\n', '\n', '    // Mapping from unicorn ID to Hybridization struct\n', '    mapping (uint => Hybridization) public hybridizations;\n', '    mapping(uint => uint) public hybridizationList;\n', '    uint public hybridizationListSize = 0;\n', '\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    function UnicornBreeding(address _unicornManagementAddress) UnicornAccessControl(_unicornManagementAddress) public {\n', '        candyToken = ERC20(unicornManagement.candyToken());\n', '\n', '    }\n', '\n', '    function init() onlyManagement whenPaused external {\n', '        unicornToken = UnicornTokenInterface(unicornManagement.unicornTokenAddress());\n', '        blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        megaCandyToken = megaCandyInterface(unicornManagement.candyPowerToken());\n', '    }\n', '\n', '    function makeHybridization(uint _unicornId, uint _price) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(unicornToken.isUnfreezed(_unicornId));\n', '        require(!hybridizations[_unicornId].exists);\n', '\n', '        hybridizations[_unicornId] = Hybridization({\n', '            price: _price,\n', '            exists: true,\n', '            listIndex: hybridizationListSize\n', '            });\n', '        hybridizationList[hybridizationListSize++] = _unicornId;\n', '\n', '        emit HybridizationAdd(_unicornId, _price);\n', '    }\n', '\n', '\n', '    function acceptHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(unicornToken.isUnfreezed(_firstUnicornId) && unicornToken.isUnfreezed(_secondUnicornId));\n', '        require(hybridizations[_firstUnicornId].exists);\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        if (hybridizations[_firstUnicornId].price > 0) {\n', '            require(candyToken.transferFrom(msg.sender, this, getHybridizationPrice(_firstUnicornId)));\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        //        BlackBoxInterface blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        if (hybridizations[_firstUnicornId].price > 0) {\n', '            candyToken.transfer(unicornToken.ownerOf(_firstUnicornId), hybridizations[_firstUnicornId].price);\n', '        }\n', '        emit HybridizationAccept(_firstUnicornId, _secondUnicornId, newUnicornId);\n', '        _deleteHybridization(_firstUnicornId);\n', '    }\n', '\n', '\n', '    function cancelHybridization (uint _unicornId) public {\n', '        require(unicornToken.owns(msg.sender,_unicornId));\n', '        require(hybridizations[_unicornId].exists);\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function deleteHybridization(uint _unicornId) onlyUnicornToken external {\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function _deleteHybridization(uint _unicornId) internal {\n', '        if (hybridizations[_unicornId].exists) {\n', '            hybridizations[hybridizationList[--hybridizationListSize]].listIndex = hybridizations[_unicornId].listIndex;\n', '            hybridizationList[hybridizations[_unicornId].listIndex] = hybridizationList[hybridizationListSize];\n', '            delete hybridizationList[hybridizationListSize];\n', '            delete hybridizations[_unicornId];\n', '            emit HybridizationDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '    //Create new 0 gen\n', '    function createUnicorn() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == getCreateUnicornPrice());\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createUnicornForCandy() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        require(candyToken.transferFrom(msg.sender, this, getCreateUnicornPriceInCandy()));\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createPresaleUnicorns(uint _count, address _owner) public payable onlyManager whenPaused returns(bool) {\n', '        require(gen0PresaleCount.add(_count) <= gen0PresaleLimit);\n', '        uint256 newUnicornId;\n', '        address owner = _owner == address(0) ? msg.sender : _owner;\n', '        for (uint i = 0; i < _count; i++){\n', '            newUnicornId = unicornToken.createUnicorn(owner);\n', '            blackBox.createGen0(newUnicornId);\n', '            emit CreateUnicorn(owner, newUnicornId, 0, 0);\n', '            gen0Count = gen0Count.add(1);\n', '            gen0PresaleCount = gen0PresaleCount.add(1);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _createUnicorn(address _owner) private returns(uint256) {\n', '        require(gen0Count < gen0Limit);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(_owner);\n', '        //        BlackBoxInterface blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        blackBox.createGen0.value(unicornManagement.oraclizeFee())(newUnicornId);\n', '        emit CreateUnicorn(_owner, newUnicornId, 0, 0);\n', '        gen0Count = gen0Count.add(1);\n', '        return newUnicornId;\n', '    }\n', '\n', '    function plusFreezingTime(uint _unicornId) private {\n', '        unicornToken.plusFreezingTime(_unicornId);\n', '    }\n', '\n', '    function plusTourFreezingTime(uint _unicornId) onlyTournament public {\n', '        unicornToken.plusTourFreezingTime(_unicornId);\n', '    }\n', '\n', '    //change freezing time for megacandy\n', '    function minusFreezingTime(uint _unicornId, uint _count) public { \n', '        require(megaCandyToken.burn(msg.sender,   unicornManagement.subFreezingPrice().mul(_count)));\n', '        unicornToken.minusFreezingTime(_unicornId,  unicornManagement.subFreezingTime() * uint64(_count));\n', '    }\n', '\n', '    //change tour freezing time for megacandy\n', '    function minusTourFreezingTime(uint _unicornId, uint _count) public { \n', '        require(megaCandyToken.burn(msg.sender, unicornManagement.subTourFreezingPrice().mul(_count)));\n', '        unicornToken.minusTourFreezingTime(_unicornId, unicornManagement.subTourFreezingTime() * uint64(_count));\n', '    }\n', '\n', '    function getHybridizationPrice(uint _unicornId) public view returns (uint) {\n', '        return unicornManagement.getHybridizationFullPrice(hybridizations[_unicornId].price);\n', '    }\n', '\n', '    function getEtherFeeForPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.oraclizeFee();\n', '    }\n', '\n', '    function getCreateUnicornPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPriceInCandy();\n', '    }\n', '\n', '\n', '    function getCreateUnicornPrice() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPrice();\n', '    }\n', '\n', '\n', '    function withdrawTokens() onlyManager public {\n', '        require(candyToken.balanceOf(this) > 0); \n', '        candyToken.transfer(unicornManagement.walletAddress(), candyToken.balanceOf(this)); \n', '    }\n', '\n', '\n', '    function transferEthersToDividendManager(uint _value) onlyManager public {\n', '        require(address(this).balance >= _value);\n', '        DividendManagerInterface dividendManager = DividendManagerInterface(unicornManagement.dividendManagerAddress());\n', '        dividendManager.payDividend.value(_value)();\n', '        emit FundsTransferred(unicornManagement.dividendManagerAddress(), _value);\n', '    }\n', '\n', '\n', '    function setGen0Limit() external onlyCommunity {\n', '        require(gen0Count == gen0Limit);\n', '        gen0Limit = gen0Limit.add(gen0Step);\n', '        emit NewGen0Limit(gen0Limit);\n', '    }\n', ' \n', '\n', '    ////MARKET\n', '    struct Offer{\n', '        uint marketIndex;\n', '        uint priceEth;\n', '        uint priceCandy;\n', '        bool exists;\n', '    }\n', '\n', '    // Mapping from unicorn ID to Offer struct\n', '    mapping (uint => Offer) public offers;\n', '    // Mapping from unicorn ID to offer ID\n', '    //    mapping (uint => uint) public unicornOffer;\n', '    // market index => offerId\n', '    mapping(uint => uint) public market;\n', '    uint public marketSize = 0;\n', '\n', '\n', '    function sellUnicorn(uint _unicornId, uint _priceEth, uint _priceCandy) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(!offers[_unicornId].exists);\n', '\n', '        offers[_unicornId] = Offer({\n', '            priceEth: _priceEth,\n', '            priceCandy: _priceCandy,\n', '            exists: true,\n', '            marketIndex: marketSize\n', '            });\n', '\n', '        market[marketSize++] = _unicornId;\n', '\n', '        emit OfferAdd(_unicornId, _priceEth, _priceCandy);\n', '    }\n', '\n', '\n', '    function buyUnicornWithEth(uint _unicornId) public payable {\n', '        require(offers[_unicornId].exists);\n', '        uint price = offers[_unicornId].priceEth;\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(offers[_unicornId].priceCandy == 0);\n', '        }\n', '        require(msg.value == getOfferPriceEth(_unicornId));\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        emit UnicornSold(_unicornId);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '        owner.transfer(price);\n', '    }\n', '\n', '\n', '    function buyUnicornWithCandy(uint _unicornId) public {\n', '        require(offers[_unicornId].exists);\n', '        uint price = offers[_unicornId].priceCandy;\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(offers[_unicornId].priceEth == 0);\n', '        }\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        if (price > 0) {\n', '            require(candyToken.transferFrom(msg.sender, this, getOfferPriceCandy(_unicornId)));\n', '            candyToken.transfer(owner, price);\n', '        }\n', '\n', '        emit UnicornSold(_unicornId);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '    }\n', '\n', '\n', '    function revokeUnicorn(uint _unicornId) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(offers[_unicornId].exists);\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function deleteOffer(uint _unicornId) onlyUnicornToken external {\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function _deleteOffer(uint _unicornId) internal {\n', '        if (offers[_unicornId].exists) {\n', '            offers[market[--marketSize]].marketIndex = offers[_unicornId].marketIndex;\n', '            market[offers[_unicornId].marketIndex] = market[marketSize];\n', '            delete market[marketSize];\n', '            delete offers[_unicornId];\n', '            emit OfferDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '\n', '    function getOfferPriceEth(uint _unicornId) public view returns (uint) {\n', '        return offers[_unicornId].priceEth.add(valueFromPercent(offers[_unicornId].priceEth, sellDividendPercentEth));\n', '    }\n', '\n', '\n', '    function getOfferPriceCandy(uint _unicornId) public view returns (uint) {\n', '        return offers[_unicornId].priceCandy.add(valueFromPercent(offers[_unicornId].priceCandy, sellDividendPercentCandy));\n', '    }\n', '\n', '\n', '    function setSellDividendPercent(uint _percentCandy, uint _percentEth) public onlyManager {\n', '        //no more then 25%\n', '        require(_percentCandy < 2500 && _percentEth < 2500);\n', '\n', '        sellDividendPercentCandy = _percentCandy;\n', '        sellDividendPercentEth = _percentEth;\n', '        emit NewSellDividendPercent(_percentCandy, _percentEth);\n', '    }\n', '\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract UnicornManagementInterface {\n', '\n', '    function ownerAddress() external view returns (address);\n', '    function managerAddress() external view returns (address);\n', '    function communityAddress() external view returns (address);\n', '    function dividendManagerAddress() external view returns (address);\n', '    function walletAddress() external view returns (address);\n', '    function blackBoxAddress() external view returns (address);\n', '    function unicornBreedingAddress() external view returns (address);\n', '    function geneLabAddress() external view returns (address);\n', '    function unicornTokenAddress() external view returns (address);\n', '    function candyToken() external view returns (address);\n', '    function candyPowerToken() external view returns (address);\n', '\n', '    function createDividendPercent() external view returns (uint);\n', '    function sellDividendPercent() external view returns (uint);\n', '    function subFreezingPrice() external view returns (uint);\n', '    function subFreezingTime() external view returns (uint64);\n', '    function subTourFreezingPrice() external view returns (uint);\n', '    function subTourFreezingTime() external view returns (uint64);\n', '    function createUnicornPrice() external view returns (uint);\n', '    function createUnicornPriceInCandy() external view returns (uint);\n', '    function oraclizeFee() external view returns (uint);\n', '\n', '    function paused() external view returns (bool);\n', '    //    function locked() external view returns (bool);\n', '\n', '    function isTournament(address _tournamentAddress) external view returns (bool);\n', '\n', '    function getCreateUnicornFullPrice() external view returns (uint);\n', '    function getHybridizationFullPrice(uint _price) external view returns (uint);\n', '    function getSellUnicornFullPrice(uint _price) external view returns (uint);\n', '    function getCreateUnicornFullPriceInCandy() external view returns (uint);\n', '\n', '\n', '    //service\n', '    function registerInit(address _contract) external;\n', '\n', '}\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract megaCandyInterface is ERC20 {\n', '    function transferFromSystem(address _from, address _to, uint256 _value) public returns (bool);\n', '    function burn(address _from, uint256 _value) public returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '\n', 'contract DividendManagerInterface {\n', '    function payDividend() external payable;\n', '}\n', '\n', 'contract BlackBoxInterface {\n', '    function createGen0(uint _unicornId) public payable;\n', '    function geneCore(uint _childUnicornId, uint _parent1UnicornId, uint _parent2UnicornId) public payable;\n', '}\n', '\n', 'contract UnicornTokenInterface {\n', '\n', '    //ERC721\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _unicornId) public view returns (address _owner);\n', '    function transfer(address _to, uint256 _unicornId) public;\n', '    function approve(address _to, uint256 _unicornId) public;\n', '    function takeOwnership(uint256 _unicornId) public;\n', '    function totalSupply() public constant returns (uint);\n', '    function owns(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function allowance(address _claimant, uint256 _unicornId) public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _unicornId) public;\n', '\n', '    //specific\n', '    function createUnicorn(address _owner) external returns (uint);\n', '    //    function burnUnicorn(uint256 _unicornId) external;\n', '    function getGen(uint _unicornId) external view returns (bytes);\n', '    function setGene(uint _unicornId, bytes _gene) external;\n', '    function updateGene(uint _unicornId, bytes _gene) external;\n', '    function getUnicornGenByte(uint _unicornId, uint _byteNo) external view returns (uint8);\n', '\n', '    function setName(uint256 _unicornId, string _name ) external returns (bool);\n', '    function plusFreezingTime(uint _unicornId) external;\n', '    function plusTourFreezingTime(uint _unicornId) external;\n', '    function minusFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function minusTourFreezingTime(uint _unicornId, uint64 _time) external;\n', '    function isUnfreezed(uint _unicornId) external view returns (bool);\n', '    function isTourUnfreezed(uint _unicornId) external view returns (bool);\n', '\n', '    function marketTransfer(address _from, address _to, uint256 _unicornId) external;\n', '}\n', '\n', '\n', '\n', 'contract UnicornAccessControl {\n', '\n', '    UnicornManagementInterface public unicornManagement;\n', '\n', '    function UnicornAccessControl(address _unicornManagementAddress) public {\n', '        unicornManagement = UnicornManagementInterface(_unicornManagementAddress);\n', '        unicornManagement.registerInit(this);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == unicornManagement.ownerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == unicornManagement.managerAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyCommunity() {\n', '        require(msg.sender == unicornManagement.communityAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyTournament() {\n', '        require(unicornManagement.isTournament(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(unicornManagement.paused());\n', '        _;\n', '    }\n', '\n', '\n', '    modifier onlyManagement() {\n', '        require(msg.sender == address(unicornManagement));\n', '        _;\n', '    }\n', '\n', '    modifier onlyBreeding() {\n', '        require(msg.sender == unicornManagement.unicornBreedingAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyGeneLab() {\n', '        require(msg.sender == unicornManagement.geneLabAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyBlackBox() {\n', '        require(msg.sender == unicornManagement.blackBoxAddress());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUnicornToken() {\n', '        require(msg.sender == unicornManagement.unicornTokenAddress());\n', '        _;\n', '    }\n', '\n', '    function isGamePaused() external view returns (bool) {\n', '        return unicornManagement.paused();\n', '    }\n', '}\n', '\n', 'contract UnicornBreeding is UnicornAccessControl {\n', '    using SafeMath for uint;\n', '    //onlyOwner\n', '    UnicornTokenInterface public unicornToken; //only on deploy\n', '    BlackBoxInterface public blackBox;\n', '\n', '    event HybridizationAdd(uint indexed unicornId, uint price);\n', '    event HybridizationAccept(uint indexed firstUnicornId, uint indexed secondUnicornId, uint newUnicornId);\n', '    event HybridizationDelete(uint indexed unicornId);\n', '    event FundsTransferred(address dividendManager, uint value);\n', '    event CreateUnicorn(address indexed owner, uint indexed unicornId, uint parent1, uint  parent2);\n', '    event NewGen0Limit(uint limit);\n', '    event NewGen0Step(uint step);\n', '\n', '\n', '    event OfferAdd(uint256 indexed unicornId, uint priceEth, uint priceCandy);\n', '    event OfferDelete(uint256 indexed unicornId);\n', '    event UnicornSold(uint256 indexed unicornId);\n', '\n', '    event NewSellDividendPercent(uint percentCandy, uint percentCandyEth);\n', '\n', '    ERC20 public candyToken;\n', '    megaCandyInterface public megaCandyToken;\n', '\n', '    uint public sellDividendPercentCandy = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '    uint public sellDividendPercentEth = 375; //OnlyManager 4 digits. 10.5% = 1050\n', '\n', '    //counter for gen0\n', '    uint public gen0Limit = 30000;\n', '    uint public gen0Count = 1805;\n', '    uint public gen0Step = 1000;\n', '\n', '    //counter for presale gen0\n', '    uint public gen0PresaleLimit = 1000;\n', '    uint public gen0PresaleCount = 0;\n', '\n', '    struct Hybridization{\n', '        uint listIndex;\n', '        uint price;\n', '        //        uint second_unicorn_id;\n', '        //        bool accepted;\n', '        bool exists;\n', '    }\n', '\n', '    // Mapping from unicorn ID to Hybridization struct\n', '    mapping (uint => Hybridization) public hybridizations;\n', '    mapping(uint => uint) public hybridizationList;\n', '    uint public hybridizationListSize = 0;\n', '\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    function UnicornBreeding(address _unicornManagementAddress) UnicornAccessControl(_unicornManagementAddress) public {\n', '        candyToken = ERC20(unicornManagement.candyToken());\n', '\n', '    }\n', '\n', '    function init() onlyManagement whenPaused external {\n', '        unicornToken = UnicornTokenInterface(unicornManagement.unicornTokenAddress());\n', '        blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        megaCandyToken = megaCandyInterface(unicornManagement.candyPowerToken());\n', '    }\n', '\n', '    function makeHybridization(uint _unicornId, uint _price) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(unicornToken.isUnfreezed(_unicornId));\n', '        require(!hybridizations[_unicornId].exists);\n', '\n', '        hybridizations[_unicornId] = Hybridization({\n', '            price: _price,\n', '            exists: true,\n', '            listIndex: hybridizationListSize\n', '            });\n', '        hybridizationList[hybridizationListSize++] = _unicornId;\n', '\n', '        emit HybridizationAdd(_unicornId, _price);\n', '    }\n', '\n', '\n', '    function acceptHybridization(uint _firstUnicornId, uint _secondUnicornId) whenNotPaused public payable {\n', '        require(unicornToken.owns(msg.sender, _secondUnicornId));\n', '        require(_secondUnicornId != _firstUnicornId);\n', '        require(unicornToken.isUnfreezed(_firstUnicornId) && unicornToken.isUnfreezed(_secondUnicornId));\n', '        require(hybridizations[_firstUnicornId].exists);\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        if (hybridizations[_firstUnicornId].price > 0) {\n', '            require(candyToken.transferFrom(msg.sender, this, getHybridizationPrice(_firstUnicornId)));\n', '        }\n', '\n', '        plusFreezingTime(_firstUnicornId);\n', '        plusFreezingTime(_secondUnicornId);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(msg.sender);\n', '        //        BlackBoxInterface blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        blackBox.geneCore.value(unicornManagement.oraclizeFee())(newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        emit CreateUnicorn(msg.sender, newUnicornId, _firstUnicornId, _secondUnicornId);\n', '        if (hybridizations[_firstUnicornId].price > 0) {\n', '            candyToken.transfer(unicornToken.ownerOf(_firstUnicornId), hybridizations[_firstUnicornId].price);\n', '        }\n', '        emit HybridizationAccept(_firstUnicornId, _secondUnicornId, newUnicornId);\n', '        _deleteHybridization(_firstUnicornId);\n', '    }\n', '\n', '\n', '    function cancelHybridization (uint _unicornId) public {\n', '        require(unicornToken.owns(msg.sender,_unicornId));\n', '        require(hybridizations[_unicornId].exists);\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function deleteHybridization(uint _unicornId) onlyUnicornToken external {\n', '        _deleteHybridization(_unicornId);\n', '    }\n', '\n', '    function _deleteHybridization(uint _unicornId) internal {\n', '        if (hybridizations[_unicornId].exists) {\n', '            hybridizations[hybridizationList[--hybridizationListSize]].listIndex = hybridizations[_unicornId].listIndex;\n', '            hybridizationList[hybridizations[_unicornId].listIndex] = hybridizationList[hybridizationListSize];\n', '            delete hybridizationList[hybridizationListSize];\n', '            delete hybridizations[_unicornId];\n', '            emit HybridizationDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '    //Create new 0 gen\n', '    function createUnicorn() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == getCreateUnicornPrice());\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createUnicornForCandy() public payable whenNotPaused returns(uint256)   {\n', '        require(msg.value == unicornManagement.oraclizeFee());\n', '        require(candyToken.transferFrom(msg.sender, this, getCreateUnicornPriceInCandy()));\n', '        return _createUnicorn(msg.sender);\n', '    }\n', '\n', '    function createPresaleUnicorns(uint _count, address _owner) public payable onlyManager whenPaused returns(bool) {\n', '        require(gen0PresaleCount.add(_count) <= gen0PresaleLimit);\n', '        uint256 newUnicornId;\n', '        address owner = _owner == address(0) ? msg.sender : _owner;\n', '        for (uint i = 0; i < _count; i++){\n', '            newUnicornId = unicornToken.createUnicorn(owner);\n', '            blackBox.createGen0(newUnicornId);\n', '            emit CreateUnicorn(owner, newUnicornId, 0, 0);\n', '            gen0Count = gen0Count.add(1);\n', '            gen0PresaleCount = gen0PresaleCount.add(1);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _createUnicorn(address _owner) private returns(uint256) {\n', '        require(gen0Count < gen0Limit);\n', '        uint256 newUnicornId = unicornToken.createUnicorn(_owner);\n', '        //        BlackBoxInterface blackBox = BlackBoxInterface(unicornManagement.blackBoxAddress());\n', '        blackBox.createGen0.value(unicornManagement.oraclizeFee())(newUnicornId);\n', '        emit CreateUnicorn(_owner, newUnicornId, 0, 0);\n', '        gen0Count = gen0Count.add(1);\n', '        return newUnicornId;\n', '    }\n', '\n', '    function plusFreezingTime(uint _unicornId) private {\n', '        unicornToken.plusFreezingTime(_unicornId);\n', '    }\n', '\n', '    function plusTourFreezingTime(uint _unicornId) onlyTournament public {\n', '        unicornToken.plusTourFreezingTime(_unicornId);\n', '    }\n', '\n', '    //change freezing time for megacandy\n', '    function minusFreezingTime(uint _unicornId, uint _count) public { \n', '        require(megaCandyToken.burn(msg.sender,   unicornManagement.subFreezingPrice().mul(_count)));\n', '        unicornToken.minusFreezingTime(_unicornId,  unicornManagement.subFreezingTime() * uint64(_count));\n', '    }\n', '\n', '    //change tour freezing time for megacandy\n', '    function minusTourFreezingTime(uint _unicornId, uint _count) public { \n', '        require(megaCandyToken.burn(msg.sender, unicornManagement.subTourFreezingPrice().mul(_count)));\n', '        unicornToken.minusTourFreezingTime(_unicornId, unicornManagement.subTourFreezingTime() * uint64(_count));\n', '    }\n', '\n', '    function getHybridizationPrice(uint _unicornId) public view returns (uint) {\n', '        return unicornManagement.getHybridizationFullPrice(hybridizations[_unicornId].price);\n', '    }\n', '\n', '    function getEtherFeeForPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.oraclizeFee();\n', '    }\n', '\n', '    function getCreateUnicornPriceInCandy() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPriceInCandy();\n', '    }\n', '\n', '\n', '    function getCreateUnicornPrice() public view returns (uint) {\n', '        return unicornManagement.getCreateUnicornFullPrice();\n', '    }\n', '\n', '\n', '    function withdrawTokens() onlyManager public {\n', '        require(candyToken.balanceOf(this) > 0); \n', '        candyToken.transfer(unicornManagement.walletAddress(), candyToken.balanceOf(this)); \n', '    }\n', '\n', '\n', '    function transferEthersToDividendManager(uint _value) onlyManager public {\n', '        require(address(this).balance >= _value);\n', '        DividendManagerInterface dividendManager = DividendManagerInterface(unicornManagement.dividendManagerAddress());\n', '        dividendManager.payDividend.value(_value)();\n', '        emit FundsTransferred(unicornManagement.dividendManagerAddress(), _value);\n', '    }\n', '\n', '\n', '    function setGen0Limit() external onlyCommunity {\n', '        require(gen0Count == gen0Limit);\n', '        gen0Limit = gen0Limit.add(gen0Step);\n', '        emit NewGen0Limit(gen0Limit);\n', '    }\n', ' \n', '\n', '    ////MARKET\n', '    struct Offer{\n', '        uint marketIndex;\n', '        uint priceEth;\n', '        uint priceCandy;\n', '        bool exists;\n', '    }\n', '\n', '    // Mapping from unicorn ID to Offer struct\n', '    mapping (uint => Offer) public offers;\n', '    // Mapping from unicorn ID to offer ID\n', '    //    mapping (uint => uint) public unicornOffer;\n', '    // market index => offerId\n', '    mapping(uint => uint) public market;\n', '    uint public marketSize = 0;\n', '\n', '\n', '    function sellUnicorn(uint _unicornId, uint _priceEth, uint _priceCandy) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(!offers[_unicornId].exists);\n', '\n', '        offers[_unicornId] = Offer({\n', '            priceEth: _priceEth,\n', '            priceCandy: _priceCandy,\n', '            exists: true,\n', '            marketIndex: marketSize\n', '            });\n', '\n', '        market[marketSize++] = _unicornId;\n', '\n', '        emit OfferAdd(_unicornId, _priceEth, _priceCandy);\n', '    }\n', '\n', '\n', '    function buyUnicornWithEth(uint _unicornId) public payable {\n', '        require(offers[_unicornId].exists);\n', '        uint price = offers[_unicornId].priceEth;\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(offers[_unicornId].priceCandy == 0);\n', '        }\n', '        require(msg.value == getOfferPriceEth(_unicornId));\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        emit UnicornSold(_unicornId);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '        owner.transfer(price);\n', '    }\n', '\n', '\n', '    function buyUnicornWithCandy(uint _unicornId) public {\n', '        require(offers[_unicornId].exists);\n', '        uint price = offers[_unicornId].priceCandy;\n', '        //Выставлять на продажу за 0 можно. Но нужно проверить чтобы и вторая цена также была 0\n', '        if (price == 0) {\n', '            require(offers[_unicornId].priceEth == 0);\n', '        }\n', '\n', '        address owner = unicornToken.ownerOf(_unicornId);\n', '\n', '        if (price > 0) {\n', '            require(candyToken.transferFrom(msg.sender, this, getOfferPriceCandy(_unicornId)));\n', '            candyToken.transfer(owner, price);\n', '        }\n', '\n', '        emit UnicornSold(_unicornId);\n', '        //deleteoffer вызовется внутри transfer\n', '        unicornToken.marketTransfer(owner, msg.sender, _unicornId);\n', '    }\n', '\n', '\n', '    function revokeUnicorn(uint _unicornId) public {\n', '        require(unicornToken.owns(msg.sender, _unicornId));\n', '        require(offers[_unicornId].exists);\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function deleteOffer(uint _unicornId) onlyUnicornToken external {\n', '        _deleteOffer(_unicornId);\n', '    }\n', '\n', '\n', '    function _deleteOffer(uint _unicornId) internal {\n', '        if (offers[_unicornId].exists) {\n', '            offers[market[--marketSize]].marketIndex = offers[_unicornId].marketIndex;\n', '            market[offers[_unicornId].marketIndex] = market[marketSize];\n', '            delete market[marketSize];\n', '            delete offers[_unicornId];\n', '            emit OfferDelete(_unicornId);\n', '        }\n', '    }\n', '\n', '\n', '    function getOfferPriceEth(uint _unicornId) public view returns (uint) {\n', '        return offers[_unicornId].priceEth.add(valueFromPercent(offers[_unicornId].priceEth, sellDividendPercentEth));\n', '    }\n', '\n', '\n', '    function getOfferPriceCandy(uint _unicornId) public view returns (uint) {\n', '        return offers[_unicornId].priceCandy.add(valueFromPercent(offers[_unicornId].priceCandy, sellDividendPercentCandy));\n', '    }\n', '\n', '\n', '    function setSellDividendPercent(uint _percentCandy, uint _percentEth) public onlyManager {\n', '        //no more then 25%\n', '        require(_percentCandy < 2500 && _percentEth < 2500);\n', '\n', '        sellDividendPercentCandy = _percentCandy;\n', '        sellDividendPercentEth = _percentEth;\n', '        emit NewSellDividendPercent(_percentCandy, _percentEth);\n', '    }\n', '\n', '\n', '    //1% - 100, 10% - 1000 50% - 5000\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(10000);\n', '        return (_amount);\n', '    }\n', '\n', '}']
