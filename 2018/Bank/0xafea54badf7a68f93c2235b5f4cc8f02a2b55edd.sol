['// File: contracts/generic/Restricted.sol\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'contract Restricted {\n', '\n', "    // NB: using bytes32 rather than the string type because it's cheaper gas-wise:\n", '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/generic/SafeMath.sol\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '\n', '    TODO: check against ds-math: https://blog.dapphub.com/ds-math/\n', '    TODO: move roundedDiv to a sep lib? (eg. Math.sol)\n', '    TODO: more unit tests!\n', '*/\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    // Division, round to nearest integer, round half up\n', '    function roundedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 halfB = (b % 2 == 0) ? (b / 2) : (b / 2 + 1);\n', '        return (a % b >= halfB) ? (a / b + 1) : (a / b);\n', '    }\n', '\n', '    // Division, always rounds up\n', '    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        return (a % b != 0) ? (a / b + 1) : (a / b);\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? b : a;\n', '    }    \n', '}\n', '\n', '// File: contracts/Rates.sol\n', '\n', '/*\n', ' Generic symbol / WEI rates contract.\n', ' only callable by trusted price oracles.\n', ' Being regularly called by a price oracle\n', '    TODO: trustless/decentrilezed price Oracle\n', '    TODO: shall we use blockNumber instead of now for lastUpdated?\n', '    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n', '    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n', '*/\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', 'contract Rates is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    struct RateInfo {\n', '        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n', '                    // 0 rate means no rate info available\n', '        uint lastUpdated;\n', '    }\n', '\n', '    // mapping currency symbol => rate. all rates are stored with 2 decimals. i.e. EUR/ETH = 989.12 then rate = 98912\n', '    mapping(bytes32 => RateInfo) public rates;\n', '\n', '    event RateChanged(bytes32 symbol, uint newRate);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function setRate(bytes32 symbol, uint newRate) external restrict("RatesFeeder") {\n', '        rates[symbol] = RateInfo(newRate, now);\n', '        emit RateChanged(symbol, newRate);\n', '    }\n', '\n', '    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict("RatesFeeder") {\n', '        require(symbols.length == newRates.length, "symobls and newRates lengths must be equal");\n', '        for (uint256 i = 0; i < symbols.length; i++) {\n', '            rates[symbols[i]] = RateInfo(newRates[i], now);\n', '            emit RateChanged(symbols[i], newRates[i]);\n', '        }\n', '    }\n', '\n', '    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n', '    }\n', '\n', '    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n', '        // next line would revert with div by zero but require to emit reason\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        /* TODO: can we make this not loosing max scale? */\n', '        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/interfaces/TransferFeeInterface.sol\n', '\n', '/*\n', ' *  transfer fee calculation interface\n', ' *\n', ' */\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'interface TransferFeeInterface {\n', '    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee);\n', '}\n', '\n', '// File: contracts/interfaces/ERC20Interface.sol\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'interface ERC20Interface {\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '\n', '}\n', '\n', '// File: contracts/interfaces/TokenReceiver.sol\n', '\n', '/*\n', ' *  receiver contract interface\n', ' * see https://github.com/ethereum/EIPs/issues/677\n', ' */\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'interface TokenReceiver {\n', '    function transferNotification(address from, uint256 amount, uint data) external;\n', '}\n', '\n', '// File: contracts/interfaces/AugmintTokenInterface.sol\n', '\n', '/* Augmint Token interface (abstract contract)\n', '\n', 'TODO: overload transfer() & transferFrom() instead of transferWithNarrative() & transferFromWithNarrative()\n', '      when this fix available in web3& truffle also uses that web3: https://github.com/ethereum/web3.js/pull/1185\n', 'TODO: shall we use bytes for narrative?\n', ' */\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AugmintTokenInterface is Restricted, ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    bytes32 public peggedSymbol;\n', '    uint8 public decimals;\n', '\n', '    uint public totalSupply;\n', '    mapping(address => uint256) public balances; // Balances for each account\n', '    mapping(address => mapping (address => uint256)) public allowed; // allowances added with approve()\n', '\n', '    TransferFeeInterface public feeAccount;\n', '    mapping(bytes32 => bool) public delegatedTxHashesUsed; // record txHashes used by delegatedTransfer\n', '\n', '    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event AugmintTransfer(address indexed from, address indexed to, uint amount, string narrative, uint fee);\n', '    event TokenIssued(uint amount);\n', '    event TokenBurned(uint amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function increaseApproval(address spender, uint addedValue) external returns (bool);\n', '    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\n', '\n', '    function issueTo(address to, uint amount) external; // restrict it to "MonetarySupervisor" in impl.;\n', '    function burn(uint amount) external;\n', '\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external;\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external;\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external;\n', '\n', '    function setName(string _name) external;\n', '    function setSymbol(string _symbol) external;\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    function balanceOf(address who) external view returns (uint);\n', '\n', '\n', '}\n', '\n', '// File: contracts/Exchange.sol\n', '\n', "/* Augmint's Internal Exchange\n", '\n', '  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n', '\n', '    TODO:\n', '        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n', '        - deduct fee\n', '        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n', '        - use Rates interface?\n', '*/\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Exchange is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    Rates public rates;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    struct Order {\n', '        uint64 index;\n', '        address maker;\n', '\n', '        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n', '        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n', '        uint32 price;\n', '\n', '        // buy order: amount in wei\n', '        // sell order: token amount\n', '        uint amount;\n', '    }\n', '\n', '    uint64 public orderCount;\n', '    mapping(uint64 => Order) public buyTokenOrders;\n', '    mapping(uint64 => Order) public sellTokenOrders;\n', '\n', '    uint64[] private activeBuyOrders;\n', '    uint64[] private activeSellOrders;\n', '\n', '    /* used to stop executing matchMultiple when running out of gas.\n', '        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n', '    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n', '\n', '    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n', '\n', '    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n', '        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n', '\n', '    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n', '\n', '    event RatesContractChanged(Rates newRatesContract);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        rates = _rates;\n', '    }\n', '\n', '    /* to allow upgrade of Rates  contract */\n', '    function setRatesContract(Rates newRatesContract)\n', '    external restrict("StabilityBoard") {\n', '        rates = newRatesContract;\n', '        emit RatesContractChanged(newRatesContract);\n', '    }\n', '\n', '    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n', '        require(price > 0, "price must be > 0");\n', '        require(msg.value > 0, "msg.value must be > 0");\n', '\n', '        orderId = ++orderCount;\n', '        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n', '        activeBuyOrders.push(orderId);\n', '\n', '        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n', '    }\n', '\n', '    /* this function requires previous approval to transfer tokens */\n', '    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n', '        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n', '        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n', '    }\n', '\n', "    /* place sell token order called from AugmintToken's transferAndNotify\n", '     Flow:\n', "        1) user calls token contract's transferAndNotify price passed in data arg\n", '        2) transferAndNotify transfers tokens to the Exchange contract\n', '        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n', '    */\n', '    function transferNotification(address maker, uint tokenAmount, uint price) external {\n', '        require(msg.sender == address(augmintToken), "msg.sender must be augmintToken");\n', '        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n', '    }\n', '\n', '    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n', '        Order storage order = buyTokenOrders[buyTokenId];\n', '        require(order.maker == msg.sender, "msg.sender must be order.maker");\n', '        require(order.amount > 0, "buy order already removed");\n', '\n', '        uint amount = order.amount;\n', '        order.amount = 0;\n', '        _removeBuyOrder(order);\n', '\n', '        msg.sender.transfer(amount);\n', '\n', '        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n', '    }\n', '\n', '    function cancelSellTokenOrder(uint64 sellTokenId) external {\n', '        Order storage order = sellTokenOrders[sellTokenId];\n', '        require(order.maker == msg.sender, "msg.sender must be order.maker");\n', '        require(order.amount > 0, "sell order already removed");\n', '\n', '        uint amount = order.amount;\n', '        order.amount = 0;\n', '        _removeSellOrder(order);\n', '\n', '        augmintToken.transferWithNarrative(msg.sender, amount, "Sell token order cancelled");\n', '\n', '        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n', '    }\n', '\n', '    /* matches any two orders if the sell price >= buy price\n', '        trade price is the price of the maker (the order placed earlier)\n', '        reverts if any of the orders have been removed\n', '    */\n', '    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n', '        require(_fillOrder(buyTokenId, sellTokenId), "fill order failed");\n', '    }\n', '\n', '    /*  matches as many orders as possible from the passed orders\n', '        Runs as long as gas is available for the call.\n', '        Reverts if any match is invalid (e.g sell price > buy price)\n', '        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n', '    */\n', '    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n', '        uint len = buyTokenIds.length;\n', '        require(len == sellTokenIds.length, "buyTokenIds and sellTokenIds lengths must be equal");\n', '\n', '        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n', '            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n', '                matchCount++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n', '        return(activeBuyOrders.length, activeSellOrders.length);\n', '    }\n', '\n', '    // returns CHUNK_SIZE orders starting from offset\n', '    // orders are encoded as [id, maker, price, amount]\n', '    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n', '            uint64 orderId = activeBuyOrders[offset + i];\n', '            Order storage order = buyTokenOrders[orderId];\n', '            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n', '        }\n', '    }\n', '\n', '    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n', '            uint64 orderId = activeSellOrders[offset + i];\n', '            Order storage order = sellTokenOrders[orderId];\n', '            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n', '        }\n', '    }\n', '\n', '    uint private constant E12 = 1000000000000;\n', '\n', '    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n', '        Order storage buy = buyTokenOrders[buyTokenId];\n', '        Order storage sell = sellTokenOrders[sellTokenId];\n', '        if( buy.amount == 0 || sell.amount == 0 ) {\n', '            return false; // one order is already filled and removed.\n', '                          // we let matchMultiple continue, indivudal match will revert\n', '        }\n', '\n', '        require(buy.price >= sell.price, "buy price must be >= sell price");\n', '\n', "        // pick maker's price (whoever placed order sooner considered as maker)\n", '        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n', '\n', '        uint publishedRate;\n', '        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n', '        // fillRate = publishedRate * 1000000 / price\n', '\n', '        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n', '\n', '        uint tradedWei;\n', '        uint tradedTokens;\n', '        if (sellWei <= buy.amount) {\n', '            tradedWei = sellWei;\n', '            tradedTokens = sell.amount;\n', '        } else {\n', '            tradedWei = buy.amount;\n', '            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n', '        }\n', '\n', '        buy.amount = buy.amount.sub(tradedWei);\n', '        if (buy.amount == 0) {\n', '            _removeBuyOrder(buy);\n', '        }\n', '\n', '        sell.amount = sell.amount.sub(tradedTokens);\n', '        if (sell.amount == 0) {\n', '            _removeSellOrder(sell);\n', '        }\n', '\n', '        augmintToken.transferWithNarrative(buy.maker, tradedTokens, "Buy token order fill");\n', '        sell.maker.transfer(tradedWei);\n', '\n', '        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n', '            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n', '    private returns (uint64 orderId) {\n', '        require(price > 0, "price must be > 0");\n', '        require(tokenAmount > 0, "tokenAmount must be > 0");\n', '\n', '        orderId = ++orderCount;\n', '        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n', '        activeSellOrders.push(orderId);\n', '\n', '        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n', '    }\n', '\n', '    function _removeBuyOrder(Order storage order) private {\n', '        uint lastIndex = activeBuyOrders.length - 1;\n', '        if (order.index < lastIndex) {\n', '            uint64 movedOrderId = activeBuyOrders[lastIndex];\n', '            activeBuyOrders[order.index] = movedOrderId;\n', '            buyTokenOrders[movedOrderId].index = order.index;\n', '        }\n', '        activeBuyOrders.length--;\n', '    }\n', '\n', '    function _removeSellOrder(Order storage order) private {\n', '        uint lastIndex = activeSellOrders.length - 1;\n', '        if (order.index < lastIndex) {\n', '            uint64 movedOrderId = activeSellOrders[lastIndex];\n', '            activeSellOrders[order.index] = movedOrderId;\n', '            sellTokenOrders[movedOrderId].index = order.index;\n', '        }\n', '        activeSellOrders.length--;\n', '    }\n', '}']