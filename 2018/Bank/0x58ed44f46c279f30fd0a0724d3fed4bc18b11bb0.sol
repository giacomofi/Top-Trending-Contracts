['pragma solidity ^0.4.21;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract POWH {\n', '    \n', '    function buy(address) public payable returns(uint256){}\n', '    function withdraw() public {}\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public ownerCandidate;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        ownerCandidate = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == ownerCandidate);  \n', '        owner = ownerCandidate;\n', '    }\n', '    \n', '}\n', '\n', 'contract BoomerangLiquidity is Owned {\n', '    \n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notPowh(address aContract){\n', '        require(aContract != powh_address);\n', '        _;\n', '    }\n', '\n', '    uint public multiplier;\n', '    uint public payoutOrder = 0;\n', '    address powh_address;\n', '    POWH weak_hands;\n', '\n', '    function BoomerangLiquidity(uint multiplierPercent, address powh) public {\n', '        multiplier = multiplierPercent;\n', '        powh_address = powh;\n', '        weak_hands = POWH(powh_address);\n', '    }\n', '    \n', '    \n', '    struct Participant {\n', '        address etherAddress;\n', '        uint payout;\n', '    }\n', '\n', '    Participant[] public participants;\n', '\n', '    \n', '    function() payable public {\n', '        deposit();\n', '    }\n', '    \n', '    function deposit() payable public {\n', '        participants.push(Participant(msg.sender, (msg.value * multiplier) / 100));\n', '        payout();\n', '    }\n', '    \n', '    function payout() public {\n', '        uint balance = address(this).balance;\n', '        require(balance > 1);\n', '        uint investment = balance / 2;\n', '        balance -= investment;\n', '        weak_hands.buy.value(investment).gas(1000000)(msg.sender);\n', '        while (balance > 0) {\n', '            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n', '            if(payoutToSend > 0){\n', '                participants[payoutOrder].payout -= payoutToSend;\n', '                balance -= payoutToSend;\n', '                if(!participants[payoutOrder].etherAddress.send(payoutToSend)){\n', '                    participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n', '                }\n', '            }\n', '            if(balance > 0){\n', '                payoutOrder += 1;\n', '            }\n', '            if(payoutOrder >= participants.length){\n', '                return;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function withdraw() public {\n', '        weak_hands.withdraw.gas(3000000)();\n', '    }\n', '    \n', '    function donate() payable public {\n', '    }\n', '    \n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner notPowh(tokenAddress) returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '\n', '    \n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract POWH {\n', '    \n', '    function buy(address) public payable returns(uint256){}\n', '    function withdraw() public {}\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public ownerCandidate;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        ownerCandidate = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == ownerCandidate);  \n', '        owner = ownerCandidate;\n', '    }\n', '    \n', '}\n', '\n', 'contract BoomerangLiquidity is Owned {\n', '    \n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notPowh(address aContract){\n', '        require(aContract != powh_address);\n', '        _;\n', '    }\n', '\n', '    uint public multiplier;\n', '    uint public payoutOrder = 0;\n', '    address powh_address;\n', '    POWH weak_hands;\n', '\n', '    function BoomerangLiquidity(uint multiplierPercent, address powh) public {\n', '        multiplier = multiplierPercent;\n', '        powh_address = powh;\n', '        weak_hands = POWH(powh_address);\n', '    }\n', '    \n', '    \n', '    struct Participant {\n', '        address etherAddress;\n', '        uint payout;\n', '    }\n', '\n', '    Participant[] public participants;\n', '\n', '    \n', '    function() payable public {\n', '        deposit();\n', '    }\n', '    \n', '    function deposit() payable public {\n', '        participants.push(Participant(msg.sender, (msg.value * multiplier) / 100));\n', '        payout();\n', '    }\n', '    \n', '    function payout() public {\n', '        uint balance = address(this).balance;\n', '        require(balance > 1);\n', '        uint investment = balance / 2;\n', '        balance -= investment;\n', '        weak_hands.buy.value(investment).gas(1000000)(msg.sender);\n', '        while (balance > 0) {\n', '            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n', '            if(payoutToSend > 0){\n', '                participants[payoutOrder].payout -= payoutToSend;\n', '                balance -= payoutToSend;\n', '                if(!participants[payoutOrder].etherAddress.send(payoutToSend)){\n', '                    participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n', '                }\n', '            }\n', '            if(balance > 0){\n', '                payoutOrder += 1;\n', '            }\n', '            if(payoutOrder >= participants.length){\n', '                return;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function withdraw() public {\n', '        weak_hands.withdraw.gas(3000000)();\n', '    }\n', '    \n', '    function donate() payable public {\n', '    }\n', '    \n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner notPowh(tokenAddress) returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '\n', '    \n', '}']
