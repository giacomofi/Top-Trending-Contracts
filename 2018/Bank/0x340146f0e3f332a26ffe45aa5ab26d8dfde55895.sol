['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ExchangeHandler.sol\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'interface ExchangeHandler {\n', '\n', '    /// @dev Get the available amount left to fill for an order\n', '    /// @param orderAddresses Array of address values needed for this DEX order\n', '    /// @param orderValues Array of uint values needed for this DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Available amount left to fill for this order\n', '    function getAvailableAmount(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '\n', '    /// @dev Perform a buy order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable returns (uint256);\n', '\n', '    /// @dev Perform a sell order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '}\n', '\n', '// File: contracts/WETH9.sol\n', '\n', '// Copyright (C) 2015, 2016, 2017 Dapphub\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() public payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/AirSwapHandler.sol\n', '\n', '/**\n', ' * @title AirSwap interface.\n', ' */\n', 'interface AirSwapInterface {\n', '    /// @dev Mapping of order hash to bool (true = already filled).\n', '    function fills(\n', '        bytes32 hash\n', '    ) external view returns (bool);\n', '\n', '    /// @dev Fills an order by transferring tokens between (maker or escrow) and taker.\n', '    /// Maker is given tokenA to taker.\n', '    function fill(\n', '        address makerAddress,\n', '        uint makerAmount,\n', '        address makerToken,\n', '        address takerAddress,\n', '        uint takerAmount,\n', '        address takerToken,\n', '        uint256 expiration,\n', '        uint256 nonce,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable;\n', '}\n', '\n', '/**\n', ' * @title AirSwap wrapper contract.\n', ' * @dev Assumes makers and takers have approved this contract to access their balances.\n', ' */\n', 'contract AirSwapHandler is ExchangeHandler, Ownable {\n', '    /// @dev AirSwap exhange address\n', '    AirSwapInterface public airSwap;\n', '    WETH9 public weth;\n', '    address public totle;\n', '    uint256 constant MAX_UINT = 2**256 - 1;\n', '\n', '    modifier onlyTotle() {\n', '        require(msg.sender == totle, "AirSwapHandler - Only TotlePrimary allowed to call this function");\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    constructor(\n', '        address _airSwap,\n', '        address _wethAddress,\n', '        address _totle\n', '    ) public {\n', '        require(_airSwap != address(0x0));\n', '        require(_wethAddress != address(0x0));\n', '        require(_totle != address(0x0));\n', '\n', '        airSwap = AirSwapInterface(_airSwap);\n', '        weth = WETH9(_wethAddress);\n', '        totle = _totle;\n', '    }\n', '\n', '    /// @dev Get the available amount left to fill for an order\n', '    /// @param orderValues Array of uint values needed for this DEX order\n', '    /// @return Available amount left to fill for this order\n', '    function getAvailableAmount(\n', '        address[8],\n', '        uint256[6] orderValues,\n', '        uint256,\n', '        uint8,\n', '        bytes32,\n', '        bytes32\n', '    ) external returns (uint256) {\n', '        return orderValues[1];\n', '    }\n', '\n', '    /// @dev Perform a buy order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '    external\n', '    onlyTotle\n', '    payable\n', '    returns (uint256) {\n', '        return fillBuy(orderAddresses, orderValues, v, r, s);\n', '    }\n', '\n', '    /// @dev Perform a sell order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '    external\n', '    onlyTotle\n', '    returns (uint256) {\n', '        return fillSell(orderAddresses, orderValues, v, r, s);\n', '    }\n', '\n', '    function setTotle(address _totle)\n', '    external\n', '    onlyOwner {\n', '        require(_totle != address(0), "Invalid address for totlePrimary");\n', '        totle = _totle;\n', '    }\n', '\n', '    /// @dev The contract is not designed to hold and/or manage tokens.\n', '    /// Withdraws token in the case of emergency. Only an owner is allowed to call this.\n', '    function withdrawToken(address _token, uint _amount)\n', '    external\n', '    onlyOwner\n', '    returns (bool) {\n', '        return ERC20(_token).transfer(owner, _amount);\n', '    }\n', '\n', '    /// @dev The contract is not designed to hold ETH.\n', '    /// Withdraws ETH in the case of emergency. Only an owner is allowed to call this.\n', '    function withdrawETH(uint _amount)\n', '    external\n', '    onlyOwner\n', '    returns (bool) {\n', '        owner.transfer(_amount);\n', '    }\n', '\n', '    function approveToken(address _token, uint amount) external onlyOwner {\n', '        require(ERC20(_token).approve(address(airSwap), amount), "Approve failed");\n', '    }\n', '\n', '    function() public payable {\n', '    }\n', '\n', '    /** Validates order arguments for fill() and cancel() functions. */\n', '    function validateOrder(\n', '        address makerAddress,\n', '        uint makerAmount,\n', '        address makerToken,\n', '        address takerAddress,\n', '        uint takerAmount,\n', '        address takerToken,\n', '        uint256 expiration,\n', '        uint256 nonce)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        // Hash arguments to identify the order.\n', '        bytes32 hashV = keccak256(makerAddress, makerAmount, makerToken,\n', '                                  takerAddress, takerAmount, takerToken,\n', '                                  expiration, nonce);\n', '        return airSwap.fills(hashV);\n', '    }\n', '\n', '    /// orderAddresses[0] == makerAddress\n', '    /// orderAddresses[1] == makerToken\n', '    /// orderAddresses[2] == takerAddress\n', '    /// orderAddresses[3] == takerToken\n', '    /// orderValues[0] = makerAmount\n', '    /// orderValues[1] = takerAmount\n', '    /// orderValues[2] = expiration\n', '    /// orderValues[3] = nonce\n', '    function fillBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) private returns (uint) {\n', '        airSwap.fill.value(msg.value)(orderAddresses[0], orderValues[0], orderAddresses[1],\n', '                                      address(this), orderValues[1], orderAddresses[3],\n', '                                      orderValues[2], orderValues[3], v, r, s);\n', '\n', '        require(validateOrder(orderAddresses[0], orderValues[0], orderAddresses[1],\n', '                              address(this), orderValues[1], orderAddresses[3],\n', '                              orderValues[2], orderValues[3]), "AirSwapHandler - Buy order validation failed.");\n', '\n', '        require(ERC20(orderAddresses[1]).transfer(orderAddresses[2], orderValues[0]), "AirSwapHandler - Failed to transfer token to taker");\n', '\n', '        return orderValues[0];\n', '    }\n', '\n', '    /// orderAddresses[0] == makerAddress\n', '    /// orderAddresses[1] == makerToken\n', '    /// orderAddresses[2] == takerAddress\n', '    /// orderAddresses[3] == takerToken\n', '    /// orderValues[0] = makerAmount\n', '    /// orderValues[1] = takerAmount\n', '    /// orderValues[2] = expiration\n', '    /// orderValues[3] = nonce\n', '    function fillSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) private\n', '    returns (uint)\n', '    {\n', '        require(orderAddresses[1] == address(weth), "AirSwapHandler - makerToken is not WETH for sell order");\n', '\n', '        uint takerAmount = orderValues[1];\n', '\n', '        if(ERC20(orderAddresses[3]).allowance(address(this), address(airSwap)) == 0) {\n', '            require(ERC20(orderAddresses[3]).approve(address(airSwap), MAX_UINT), "AirSwapHandler - unable to set token approval for sell order");\n', '        }\n', '\n', '        airSwap.fill(orderAddresses[0], orderValues[0], orderAddresses[1],\n', '                     address(this), takerAmount, orderAddresses[3],\n', '                     orderValues[2], orderValues[3], v, r, s);\n', '\n', '        require(validateOrder(orderAddresses[0], orderValues[0], orderAddresses[1],\n', '                              address(this), takerAmount, orderAddresses[3],\n', '                              orderValues[2], orderValues[3]), "AirSwapHandler - sell order validation failed.");\n', '\n', '        weth.withdraw(orderValues[0]);\n', '        msg.sender.transfer(orderValues[0]);\n', '\n', '        return orderValues[0];\n', '    }\n', '}']