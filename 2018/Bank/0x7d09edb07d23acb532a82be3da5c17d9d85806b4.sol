['pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PoCGame\n', '{\n', '    \n', '    /**\n', '     * Modifiers\n', '     */\n', '     \n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '   modifier isOpenToPublic()\n', '    {\n', '        require(openToPublic);\n', '        _;\n', '    }\n', '\n', '    modifier onlyRealPeople()\n', '    {\n', '          require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    modifier  onlyPlayers()\n', '    { \n', '        require (wagers[msg.sender] > 0); \n', '        _; \n', '    }\n', '    \n', '   \n', '    /**\n', '     * Events\n', '     */\n', '    event Wager(uint256 amount, address depositer);\n', '    event Win(uint256 amount, address paidTo);\n', '    event Lose(uint256 amount, address loser);\n', '    event Donate(uint256 amount, address paidTo, address donator);\n', '    event DifficultyChanged(uint256 currentDifficulty);\n', '    event BetLimitChanged(uint256 currentBetLimit);\n', '\n', '    /**\n', '     * Global Variables\n', '     */\n', '    address private whale;\n', '    uint256 betLimit;\n', '    uint difficulty;\n', '    uint private randomSeed;\n', '    address owner;\n', '    mapping(address => uint256) timestamps;\n', '    mapping(address => uint256) wagers;\n', '    bool openToPublic;\n', '    uint256 totalDonated;\n', '\n', '    /**\n', '     * Constructor\n', '     */\n', '    constructor(address whaleAddress, uint256 wagerLimit) \n', '    onlyRealPeople()\n', '    public \n', '    {\n', '        openToPublic = false;\n', '        owner = msg.sender;\n', '        whale = whaleAddress;\n', '        totalDonated = 0;\n', '        betLimit = wagerLimit;\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '     * Let the public play\n', '     */\n', '    function OpenToThePublic() \n', '    onlyOwner()\n', '    public\n', '    {\n', '        openToPublic = true;\n', '    }\n', '    \n', '    /**\n', '     * Adjust the bet amounts\n', '     */\n', '    function AdjustBetAmounts(uint256 amount) \n', '    onlyOwner()\n', '    public\n', '    {\n', '        betLimit = amount;\n', '        \n', '        emit BetLimitChanged(betLimit);\n', '    }\n', '    \n', '     /**\n', '     * Adjust the difficulty\n', '     */\n', '    function AdjustDifficulty(uint256 amount) \n', '    onlyOwner()\n', '    public\n', '    {\n', '        difficulty = amount;\n', '        \n', '        emit DifficultyChanged(difficulty);\n', '    }\n', '    \n', '    \n', '    function() public payable { }\n', '\n', '    /**\n', '     * Wager your bet\n', '     */\n', '    function wager()\n', '    isOpenToPublic()\n', '    onlyRealPeople() \n', '    payable\n', '    public \n', '    {\n', '        //You have to send exactly 0.01 ETH.\n', '        require(msg.value == betLimit);\n', '\n', '        //log the wager and timestamp(block number)\n', '        timestamps[msg.sender] = block.number;\n', '        wagers[msg.sender] = msg.value;\n', '        emit Wager(msg.value, msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * method to determine winners and losers\n', '     */\n', '    function play()\n', '    isOpenToPublic()\n', '    onlyRealPeople()\n', '    onlyPlayers()\n', '    public\n', '    {\n', '        uint256 blockNumber = timestamps[msg.sender];\n', '        if(blockNumber < block.number)\n', '        {\n', '            timestamps[msg.sender] = 0;\n', '            wagers[msg.sender] = 0;\n', '    \n', '            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n', '    \n', '            if(winningNumber == difficulty / 2)\n', '            {\n', '                payout(msg.sender);\n', '            }\n', '            else \n', '            {\n', '                //player loses\n', '                loseWager(betLimit / 2);\n', '            }    \n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * For those that just want to donate to the whale\n', '     */\n', '    function donate()\n', '    isOpenToPublic()\n', '    public \n', '    payable\n', '    {\n', '        donateToWhale(msg.value);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to winner\n', '     */\n', '    function payout(address winner) \n', '    internal \n', '    {\n', '        uint256 ethToTransfer = address(this).balance / 2;\n', '        \n', '        winner.transfer(ethToTransfer);\n', '        emit Win(ethToTransfer, winner);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to whale\n', '     */\n', '    function donateToWhale(uint256 amount) \n', '    internal \n', '    {\n', '        whale.call.value(amount)(bytes4(keccak256("donate()")));\n', '        totalDonated += amount;\n', '        emit Donate(amount, whale, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to whale when player loses\n', '     */\n', '    function loseWager(uint256 amount) \n', '    internal \n', '    {\n', '        whale.call.value(amount)(bytes4(keccak256("donate()")));\n', '        totalDonated += amount;\n', '        emit Lose(amount, msg.sender);\n', '    }\n', '    \n', '\n', '    /**\n', '     * ETH balance of contract\n', '     */\n', '    function ethBalance() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * current difficulty of the game\n', '     */\n', '    function currentDifficulty() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return difficulty;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * current bet amount for the game\n', '     */\n', '    function currentBetLimit() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return betLimit;\n', '    }\n', '    \n', '    function hasPlayerWagered(address player)\n', '    public \n', '    view \n', '    returns (bool)\n', '    {\n', '        if(wagers[player] > 0)\n', '        {\n', '            return true;\n', '        }\n', '        else\n', '        {\n', '            return false;\n', '        }\n', '        \n', '    }\n', '\n', '    /**\n', '     * For the UI to properly display the winner&#39;s pot\n', '     */\n', '    function winnersPot() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return address(this).balance / 2;\n', '    }\n', '\n', '    /**\n', '     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n', '     */\n', '    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n', '    public \n', '    onlyOwner() \n', '    returns (bool success) \n', '    {\n', '        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '    }\n', '}\n', '\n', '//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\n', 'contract ERC20Interface \n', '{\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PoCGame\n', '{\n', '    \n', '    /**\n', '     * Modifiers\n', '     */\n', '     \n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '   modifier isOpenToPublic()\n', '    {\n', '        require(openToPublic);\n', '        _;\n', '    }\n', '\n', '    modifier onlyRealPeople()\n', '    {\n', '          require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    modifier  onlyPlayers()\n', '    { \n', '        require (wagers[msg.sender] > 0); \n', '        _; \n', '    }\n', '    \n', '   \n', '    /**\n', '     * Events\n', '     */\n', '    event Wager(uint256 amount, address depositer);\n', '    event Win(uint256 amount, address paidTo);\n', '    event Lose(uint256 amount, address loser);\n', '    event Donate(uint256 amount, address paidTo, address donator);\n', '    event DifficultyChanged(uint256 currentDifficulty);\n', '    event BetLimitChanged(uint256 currentBetLimit);\n', '\n', '    /**\n', '     * Global Variables\n', '     */\n', '    address private whale;\n', '    uint256 betLimit;\n', '    uint difficulty;\n', '    uint private randomSeed;\n', '    address owner;\n', '    mapping(address => uint256) timestamps;\n', '    mapping(address => uint256) wagers;\n', '    bool openToPublic;\n', '    uint256 totalDonated;\n', '\n', '    /**\n', '     * Constructor\n', '     */\n', '    constructor(address whaleAddress, uint256 wagerLimit) \n', '    onlyRealPeople()\n', '    public \n', '    {\n', '        openToPublic = false;\n', '        owner = msg.sender;\n', '        whale = whaleAddress;\n', '        totalDonated = 0;\n', '        betLimit = wagerLimit;\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '     * Let the public play\n', '     */\n', '    function OpenToThePublic() \n', '    onlyOwner()\n', '    public\n', '    {\n', '        openToPublic = true;\n', '    }\n', '    \n', '    /**\n', '     * Adjust the bet amounts\n', '     */\n', '    function AdjustBetAmounts(uint256 amount) \n', '    onlyOwner()\n', '    public\n', '    {\n', '        betLimit = amount;\n', '        \n', '        emit BetLimitChanged(betLimit);\n', '    }\n', '    \n', '     /**\n', '     * Adjust the difficulty\n', '     */\n', '    function AdjustDifficulty(uint256 amount) \n', '    onlyOwner()\n', '    public\n', '    {\n', '        difficulty = amount;\n', '        \n', '        emit DifficultyChanged(difficulty);\n', '    }\n', '    \n', '    \n', '    function() public payable { }\n', '\n', '    /**\n', '     * Wager your bet\n', '     */\n', '    function wager()\n', '    isOpenToPublic()\n', '    onlyRealPeople() \n', '    payable\n', '    public \n', '    {\n', '        //You have to send exactly 0.01 ETH.\n', '        require(msg.value == betLimit);\n', '\n', '        //log the wager and timestamp(block number)\n', '        timestamps[msg.sender] = block.number;\n', '        wagers[msg.sender] = msg.value;\n', '        emit Wager(msg.value, msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * method to determine winners and losers\n', '     */\n', '    function play()\n', '    isOpenToPublic()\n', '    onlyRealPeople()\n', '    onlyPlayers()\n', '    public\n', '    {\n', '        uint256 blockNumber = timestamps[msg.sender];\n', '        if(blockNumber < block.number)\n', '        {\n', '            timestamps[msg.sender] = 0;\n', '            wagers[msg.sender] = 0;\n', '    \n', '            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n', '    \n', '            if(winningNumber == difficulty / 2)\n', '            {\n', '                payout(msg.sender);\n', '            }\n', '            else \n', '            {\n', '                //player loses\n', '                loseWager(betLimit / 2);\n', '            }    \n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * For those that just want to donate to the whale\n', '     */\n', '    function donate()\n', '    isOpenToPublic()\n', '    public \n', '    payable\n', '    {\n', '        donateToWhale(msg.value);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to winner\n', '     */\n', '    function payout(address winner) \n', '    internal \n', '    {\n', '        uint256 ethToTransfer = address(this).balance / 2;\n', '        \n', '        winner.transfer(ethToTransfer);\n', '        emit Win(ethToTransfer, winner);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to whale\n', '     */\n', '    function donateToWhale(uint256 amount) \n', '    internal \n', '    {\n', '        whale.call.value(amount)(bytes4(keccak256("donate()")));\n', '        totalDonated += amount;\n', '        emit Donate(amount, whale, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Payout ETH to whale when player loses\n', '     */\n', '    function loseWager(uint256 amount) \n', '    internal \n', '    {\n', '        whale.call.value(amount)(bytes4(keccak256("donate()")));\n', '        totalDonated += amount;\n', '        emit Lose(amount, msg.sender);\n', '    }\n', '    \n', '\n', '    /**\n', '     * ETH balance of contract\n', '     */\n', '    function ethBalance() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * current difficulty of the game\n', '     */\n', '    function currentDifficulty() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return difficulty;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * current bet amount for the game\n', '     */\n', '    function currentBetLimit() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return betLimit;\n', '    }\n', '    \n', '    function hasPlayerWagered(address player)\n', '    public \n', '    view \n', '    returns (bool)\n', '    {\n', '        if(wagers[player] > 0)\n', '        {\n', '            return true;\n', '        }\n', '        else\n', '        {\n', '            return false;\n', '        }\n', '        \n', '    }\n', '\n', '    /**\n', "     * For the UI to properly display the winner's pot\n", '     */\n', '    function winnersPot() \n', '    public \n', '    view \n', '    returns (uint256)\n', '    {\n', '        return address(this).balance / 2;\n', '    }\n', '\n', '    /**\n', '     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n', '     */\n', '    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n', '    public \n', '    onlyOwner() \n', '    returns (bool success) \n', '    {\n', '        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '    }\n', '}\n', '\n', '//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\n', 'contract ERC20Interface \n', '{\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}']
