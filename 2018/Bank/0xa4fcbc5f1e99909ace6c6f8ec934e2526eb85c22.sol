['pragma solidity ^0.4.21;\n', '\n', 'interface IERC20Token {\n', '    function balanceOf(address owner) public returns (uint256);\n', '    function transfer(address to, uint256 amount) public returns (bool);\n', '    function decimals() public returns (uint256);\n', '}\n', '\n', 'contract TokenSale {\n', '    IERC20Token public tokenContract;  // the token being sold\n', '    uint256 public price;              // the price, in wei, per token\n', '    address owner;\n', '\n', '    uint256 public tokensSold;\n', '\n', '    event Sold(address buyer, uint256 amount);\n', '\n', '    function TokenSale(IERC20Token _tokenContract, uint256 _price) public {\n', '        owner = msg.sender;\n', '        tokenContract = _tokenContract;\n', '        price = _price;\n', '    }\n', '\n', '    // Guards against integer overflows\n', '    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        } else {\n', '            uint256 c = a * b;\n', '            assert(c / a == b);\n', '            return c;\n', '        }\n', '    }\n', '\n', '    function buyTokens(uint256 numberOfTokens) public payable {\n', '        require(msg.value == safeMultiply(numberOfTokens, price));\n', '\n', '        uint256 scaledAmount = safeMultiply(numberOfTokens,\n', '            uint256(10) ** tokenContract.decimals());\n', '\n', '        require(tokenContract.balanceOf(this) >= scaledAmount);\n', '\n', '        emit Sold(msg.sender, numberOfTokens);\n', '        tokensSold += numberOfTokens;\n', '\n', '        require(tokenContract.transfer(msg.sender, scaledAmount));\n', '    }\n', '\n', '    function endSale() public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send unsold tokens to the owner.\n', '        require(tokenContract.transfer(owner, tokenContract.balanceOf(this)));\n', '\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '}']