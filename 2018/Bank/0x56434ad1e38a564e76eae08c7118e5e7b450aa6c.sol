['pragma solidity ^0.4.23;\n', '\n', '/*\n', '* The Blockchain Football network presents....\n', '* https://fantasyfootballfund.co/\n', '* https://discord.gg/qPjA6Tx\n', '*\n', '* Build your fantasy player portfolio. Earn crypto daily based on player performance.\n', '*\n', '* 4 Ways to earn\n', '* [1] Price Fluctuations - buy and sell at the right moments\n', '* [2] Match day Divs - allocated to shareholders of top performing players every day\n', '* [3] Fame Divs - allocated to shareholders of infamous players on non-match days\n', '* [4] Original Owner - allocated to owners of original player cards on blockchainfootball.co (2% per share sold)\n', '*/\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract PlayerToken is ERC20 {\n', '\n', '    // Ownable\n', '    address public owner;\n', '    bool public paused = false;\n', '\n', '    // Events\n', '    event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol);\n', '    event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol);\n', '\n', '    // Libs\n', '    using SafeMath for uint256;\n', '\n', '    // Core token attributes\n', '    uint256 public initialTokenPrice_;  // Typically = 1 Finney (0.001 Ether)\n', '    uint256 public incrementalTokenPrice_; // Typically = 0.01 Finney (0.00001 Ether)\n', '\n', '    // Token Properties - set via the constructor for each player\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 0;\n', '\n', '    // Exchange Contract - used to hold the dividend pool across all ERC20 player contracts\n', '    // when shares are brought or sold the dividend fee gets transfered here\n', '    address public exchangeContract_;\n', '    \n', '    // Blockchainfootball.co attributes - if this is set the owner receieves a fee for owning the original card\n', '    BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F);\n', '    uint256 public playerId_;\n', '    address public originalOwner_;\n', '\n', '    // Fees - denoted in %\n', '    uint8 constant internal processingFee_ = 5; // inc. fees to cover DAILY gas usage to assign divs to token holders\n', '    uint8 constant internal originalOwnerFee_ = 2; // of all token buys per original player owned + set on blockchainfootball.co\n', '    uint8 internal dividendBuyPoolFee_ = 15; // buys AND sells go into the div pool to promote gameplay - can be updated\n', '    uint8 internal dividendSellPoolFee_ = 20;\n', '    uint8 constant internal referrerFee_ = 1; // for all token buys (but not sells)\n', '\n', '    // ERC20 data structures\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    // Player Exchange Data Structures\n', '    address[] public tokenHolders;\n', '    mapping(address => uint256) public addressToTokenHolderIndex; // Helps to gas-efficiently remove shareholders, by swapping last index\n', '    mapping(address => int256) public totalCost; // To hold the total expenditure of each address, profit tracking\n', '\n', '    // ERC20 Properties\n', '    uint256 totalSupply_;\n', '\n', '    // Additional accessors\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrExchange() {\n', '        require(msg.sender == owner || msg.sender == exchangeContract_);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '    constructor(\n', '        string _name, \n', '        string _symbol, \n', '        uint _startPrice, \n', '        uint _incrementalPrice, \n', '        address _owner, \n', '        address _exchangeContract, \n', '        uint256 _playerId,\n', '        uint8 _promoSharesQuantity\n', '    ) \n', '        public\n', '        payable\n', '    {\n', '        require(_exchangeContract != address(0));\n', '        require(_owner != address(0));\n', '\n', '        exchangeContract_ = _exchangeContract;\n', '        playerId_ = _playerId;\n', '\n', '        // Set initial starting exchange values\n', '        initialTokenPrice_ = _startPrice;\n', '        incrementalTokenPrice_ = _incrementalPrice; // In most cases this will be 1 finney, 0.001 ETH\n', '\n', '        // Initial token properties\n', '        paused = true;\n', '        owner = _owner;\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        // Purchase promotional player shares - we purchase initial shares (the same way users do) as prizes for promos/competitions/giveaways\n', '        if (_promoSharesQuantity > 0) {\n', '            _buyTokens(msg.value, _promoSharesQuantity, _owner, address(0));\n', '        }\n', '    }\n', '\n', '    // **External Exchange**\n', '    function buyTokens(uint8 _amount, address _referredBy) payable external whenNotPaused {\n', '        require(_amount > 0 && _amount <= 100, "Valid token amount required between 1 and 100");\n', '        require(msg.value > 0, "Provide a valid fee"); \n', '        // solium-disable-next-line security/no-tx-origin\n', '        require(msg.sender == tx.origin, "Only valid users are allowed to buy tokens"); \n', '        _buyTokens(msg.value, _amount, msg.sender, _referredBy);\n', '    }\n', '\n', '    function sellTokens(uint8 _amount) external {\n', '        require(_amount > 0, "Valid sell amount required");\n', '        require(_amount <= balances[msg.sender]);\n', '        _sellTokens(_amount, msg.sender);\n', '    }\n', '\n', '    // **Internal Exchange**\n', '    function _buyTokens(uint _ethSent, uint8 _amount, address _buyer, address _referredBy) internal {\n', '        \n', '        uint _totalCost;\n', '        uint _processingFee;\n', '        uint _originalOwnerFee;\n', '        uint _dividendPoolFee;\n', '        uint _referrerFee;\n', '\n', '        (_totalCost, _processingFee, _originalOwnerFee, _dividendPoolFee, _referrerFee) = calculateTokenBuyPrice(_amount);\n', '\n', '        require(_ethSent >= _totalCost, "Invalid fee to buy tokens");\n', '\n', '        // Send to original card owner if available\n', '        // If we don&#39;t have an original owner we move this fee into the dividend pool\n', '        if (originalOwner_ != address(0)) {\n', '            originalOwner_.transfer(_originalOwnerFee);\n', '        } else {\n', '            _dividendPoolFee = _dividendPoolFee.add(_originalOwnerFee);\n', '        }\n', '\n', '        // Send to the referrer - if we don&#39;t have a referrer we move this fee into the dividend pool\n', '        if (_referredBy != address(0)) {\n', '            _referredBy.transfer(_referrerFee);\n', '        } else {\n', '            _dividendPoolFee = _dividendPoolFee.add(_referrerFee);\n', '        }\n', '\n', '        // These will always be available\n', '        owner.transfer(_processingFee);\n', '        exchangeContract_.transfer(_dividendPoolFee);\n', '\n', '        // Refund excess\n', '        uint excess = _ethSent.sub(_totalCost);\n', '        _buyer.transfer(excess);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_buyer) == 0) {\n', '            tokenHolders.push(_buyer);\n', '            addressToTokenHolderIndex[_buyer] = tokenHolders.length - 1;\n', '        }\n', '        \n', '        // Provide users with the shares\n', '        _allocatePlayerTokensTo(_buyer, _amount);\n', '\n', '        // Track costs\n', '        totalCost[_buyer] = totalCost[_buyer] + int256(_totalCost); // No need for safe maths here, just holds profit tracking\n', '\n', '        // Event tracking\n', '        emit PlayerTokenBuy(_buyer, _referredBy, _amount, _totalCost, symbol);\n', '    }\n', '\n', '    function _sellTokens(uint8 _amount, address _seller) internal {\n', '        \n', '        uint _totalSellerProceeds;\n', '        uint _processingFee;\n', '        uint _dividendPoolFee;\n', '\n', '        (_totalSellerProceeds, _processingFee, _dividendPoolFee) = calculateTokenSellPrice(_amount);\n', '\n', '        // Burn the sellers shares\n', '        _burnPlayerTokensFrom(_seller, _amount);\n', '\n', '        // Track ownership of token holders if the user no longer has tokens let&#39;s remove them\n', '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(_seller) == 0) {\n', '            removeFromTokenHolders(_seller);\n', '        }\n', '\n', '        // Transfer to processor, seller and dividend pool\n', '        owner.transfer(_processingFee);\n', '        _seller.transfer(_totalSellerProceeds);\n', '        exchangeContract_.transfer(_dividendPoolFee);\n', '\n', '        // Track costs\n', '        totalCost[_seller] = totalCost[_seller] - int256(_totalSellerProceeds); // No need for safe maths here, just holds profit tracking\n', '\n', '        // Event tracking\n', '        emit PlayerTokenSell(_seller, _amount, _totalSellerProceeds, symbol);\n', '    }\n', '\n', '    // **Calculations - these factor in all fees**\n', '    function calculateTokenBuyPrice(uint _amount) \n', '        public \n', '        view \n', '        returns (\n', '        uint _totalCost, \n', '        uint _processingFee, \n', '        uint _originalOwnerFee, \n', '        uint _dividendPoolFee, \n', '        uint _referrerFee\n', '    ) {    \n', '        uint tokenCost = calculateTokenOnlyBuyPrice(_amount);\n', '\n', '        // We now need to apply fees on top of this\n', '        // In all cases we apply fees - but if there&#39;s no original owner or referrer\n', '        // these go into the dividend pool\n', '        _processingFee = SafeMath.div(SafeMath.mul(tokenCost, processingFee_), 100);\n', '        _originalOwnerFee = SafeMath.div(SafeMath.mul(tokenCost, originalOwnerFee_), 100);\n', '        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenCost, dividendBuyPoolFee_), 100);\n', '        _referrerFee = SafeMath.div(SafeMath.mul(tokenCost, referrerFee_), 100);\n', '\n', '        _totalCost = tokenCost.add(_processingFee).add(_originalOwnerFee).add(_dividendPoolFee).add(_referrerFee);\n', '    }\n', '\n', '    function calculateTokenSellPrice(uint _amount) \n', '        public \n', '        view \n', '        returns (\n', '        uint _totalSellerProceeds,\n', '        uint _processingFee,\n', '        uint _dividendPoolFee\n', '    ) {\n', '        uint tokenSellCost = calculateTokenOnlySellPrice(_amount);\n', '\n', '        // We remove the processing and dividend fees on the final sell price\n', '        // this represents the difference between the buy and sell price on the UI\n', '        _processingFee = SafeMath.div(SafeMath.mul(tokenSellCost, processingFee_), 100);\n', '        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenSellCost, dividendSellPoolFee_), 100);\n', '\n', '        _totalSellerProceeds = tokenSellCost.sub(_processingFee).sub(_dividendPoolFee);\n', '    }\n', '\n', '    // **Calculate total cost of tokens without fees**\n', '    function calculateTokenOnlyBuyPrice(uint _amount) public view returns(uint) {\n', '        \n', '        // We use a simple arithmetic progression series, summing the incremental prices\n', '\t    // ((n / 2) * (2 * a + (n - 1) * d))\n', '\t    // a = starting value (1st term), d = price increment (diff.), n = amount of shares (no. of terms)\n', '\n', '        // NOTE: we use a mutiplier to avoid issues with an odd number of shares, dividing and limited fixed point support in Solidity\n', '        uint8 multiplier = 10;\n', '        uint amountMultiplied = _amount * multiplier; \n', '        uint startingPrice = initialTokenPrice_ + (totalSupply_ * incrementalTokenPrice_);\n', '        uint totalBuyPrice = (amountMultiplied / 2) * (2 * startingPrice + (_amount - 1) * incrementalTokenPrice_) / multiplier;\n', '\n', '        // Should never *concievably* occur, but more effecient than Safemaths on the entire formula\n', '        assert(totalBuyPrice >= startingPrice); \n', '        return totalBuyPrice;\n', '    }\n', '\n', '    function calculateTokenOnlySellPrice(uint _amount) public view returns(uint) {\n', '        // Similar to calculateTokenBuyPrice, but we abs() the incrementalTokenPrice so we get a reverse arithmetic series\n', '        uint8 multiplier = 10;\n', '        uint amountMultiplied = _amount * multiplier; \n', '        uint startingPrice = initialTokenPrice_ + ((totalSupply_-1) * incrementalTokenPrice_);\n', '        int absIncrementalTokenPrice = int(incrementalTokenPrice_) * -1;\n', '        uint totalSellPrice = uint((int(amountMultiplied) / 2) * (2 * int(startingPrice) + (int(_amount) - 1) * absIncrementalTokenPrice) / multiplier);\n', '        return totalSellPrice;\n', '    }\n', '\n', '    // **UI Helpers**\n', '    function buySellPrices() public view returns(uint _buyPrice, uint _sellPrice) {\n', '        (_buyPrice,,,,) = calculateTokenBuyPrice(1);\n', '        (_sellPrice,,) = calculateTokenSellPrice(1);\n', '    }\n', '\n', '    function portfolioSummary(address _address) public view returns(uint _tokenBalance, int _cost, uint _value) {\n', '        _tokenBalance = balanceOf(_address);\n', '        _cost = totalCost[_address];\n', '        (_value,,) = calculateTokenSellPrice(_tokenBalance);       \n', '    }\n', '\n', '    function totalTokenHolders() public view returns(uint) {\n', '        return tokenHolders.length;\n', '    }\n', '\n', '    function tokenHoldersByIndex() public view returns(address[] _addresses, uint[] _shares) {\n', '        \n', '        // This will only be called offchain to take snapshots of share count at cut off points for divs\n', '        uint tokenHolderCount = tokenHolders.length;\n', '        address[] memory addresses = new address[](tokenHolderCount);\n', '        uint[] memory shares = new uint[](tokenHolderCount);\n', '\n', '        for (uint i = 0; i < tokenHolderCount; i++) {\n', '            addresses[i] = tokenHolders[i];\n', '            shares[i] = balanceOf(tokenHolders[i]);\n', '        }\n', '\n', '        return (addresses, shares);\n', '    }\n', '\n', '    // In cases where there&#39;s bugs in the exchange contract we need a way to re-point\n', '    function setExchangeContractAddress(address _exchangeContract) external onlyOwner {\n', '        exchangeContract_ = _exchangeContract;\n', '    }\n', '\n', '    // **Blockchainfootball.co Support**\n', '    function setBCFContractAddress(address _address) external onlyOwner {\n', '        BCFMain candidateContract = BCFMain(_address);\n', '        require(candidateContract.implementsERC721());\n', '        bcfContract_ = candidateContract;\n', '    }\n', '\n', '    function setPlayerId(uint256 _playerId) external onlyOwner {\n', '        playerId_ = _playerId;\n', '    }\n', '\n', '    function setSellDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\n', '        // We&#39;ll need some flexibility to alter this as the right dividend structure helps promote gameplay\n', '        // This pushes users to buy players who are performing well to grab divs rather than just getting in early to new players being released\n', '        require(_dividendPoolFee <= 50, "Max of 50% is assignable to the pool");\n', '        dividendSellPoolFee_ = _dividendPoolFee;\n', '    }\n', '\n', '    function setBuyDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\n', '        require(_dividendPoolFee <= 50, "Max of 50% is assignable to the pool");\n', '        dividendBuyPoolFee_ = _dividendPoolFee;\n', '    }\n', '\n', '    // Can be called by anyone, in which case we could use a another contract to set the original owner whenever it changes on blockchainfootball.co\n', '    function setOriginalOwner(uint256 _playerCardId, address _address) external {\n', '        require(playerId_ > 0, "Player ID must be set on the contract");\n', '        \n', '        // As we call .transfer() on buys to send original owners divs we need to make sure this can&#39;t be DOS&#39;d through setting the\n', '        // original owner as a smart contract and then reverting any transfer() calls\n', '        // while it would be silly to reject divs it is a valid DOS scenario\n', '        // solium-disable-next-line security/no-tx-origin\n', '        require(msg.sender == tx.origin, "Only valid users are able to set original ownership"); \n', '       \n', '        address _cardOwner;\n', '        uint256 _playerId;\n', '        bool _isFirstGeneration;\n', '\n', '        (_playerId,_cardOwner,,_isFirstGeneration) = bcfContract_.playerCards(_playerCardId);\n', '\n', '        require(_isFirstGeneration, "Card must be an original");\n', '        require(_playerId == playerId_, "Card must tbe the same player this contract relates to");\n', '        require(_cardOwner == _address, "Card must be owned by the address provided");\n', '        \n', '        // All good, set the address as the original owner, happy div day \\o/\n', '        originalOwner_ = _address;\n', '    }\n', '\n', '    // ** Internal Token Handling - validation completed by callers **\n', '    function _allocatePlayerTokensTo(address _to, uint256 _amount) internal {\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '    function _burnPlayerTokensFrom(address _from, uint256 _amount) internal {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        totalSupply_ = totalSupply_.sub(_amount);\n', '        emit Transfer(_from, address(0), _amount);\n', '    }\n', '\n', '    function removeFromTokenHolders(address _seller) internal {\n', '        \n', '        uint256 tokenIndex = addressToTokenHolderIndex[_seller];\n', '        uint256 lastAddressIndex = tokenHolders.length.sub(1);\n', '        address lastAddress = tokenHolders[lastAddressIndex];\n', '        \n', '        tokenHolders[tokenIndex] = lastAddress;\n', '        tokenHolders[lastAddressIndex] = address(0);\n', '        tokenHolders.length--;\n', '\n', '        addressToTokenHolderIndex[lastAddress] = tokenIndex;\n', '    }\n', '\n', '    // ** ERC20 Support **\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_to) == 0) {\n', '            tokenHolders.push(_to);\n', '            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // Track ownership of token holders if the user no longer has tokens let&#39;s remove them\n', '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(msg.sender) == 0) {\n', '            removeFromTokenHolders(msg.sender);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_to) == 0) {\n', '            tokenHolders.push(_to);\n', '            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\n', '        }\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        // Track ownership of token holders if the user no longer has tokens let&#39;s remove them\n', '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(_from) == 0) {\n', '            removeFromTokenHolders(_from);\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Utilities\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '    function pause() onlyOwnerOrExchange whenNotPaused public {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() onlyOwnerOrExchange whenPaused public {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract BCFMain {\n', '    function playerCards(uint256 playerCardId) public view returns (uint256 playerId, address owner, address approvedForTransfer, bool isFirstGeneration);\n', '    function implementsERC721() public pure returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract PlayerExchangeCore {\n', '\n', '    // Events\n', '    event InitialPlayerOffering(address indexed contractAddress, string name, string symbol);\n', '    event DividendWithdrawal(address indexed user, uint amount);\n', '\n', '    // Libs\n', '    using SafeMath for uint256;\n', '\n', '    // Ownership\n', '    address public owner;\n', '    address public referee; // Used to pay out divs and initiate an IPO\n', '\n', '    // Structs\n', '    struct DividendWinner {\n', '        uint playerTokenContractId;\n', '        uint perTokenEthValue;\n', '        uint totalTokens;\n', '        uint tokensProcessed; // So we can determine when all tokens have been allocated divs + settled\n', '    }\n', '\n', '    // State management\n', '    uint internal balancePendingWithdrawal_; // this.balance - balancePendingWithdrawal_ = div prize pool\n', '\n', '    // Data Store\n', '    PlayerToken[] public playerTokenContracts_; // Holds a list of all player token contracts\n', '    DividendWinner[] public dividendWinners_; // Holds a list of dividend winners (player contract id&#39;s, not users)\n', '    mapping(address => uint256) public addressToDividendBalance;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyReferee() {\n', '        require(msg.sender == referee);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrReferee() {\n', '        require(msg.sender == owner || msg.sender == referee);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setReferee(address newReferee) public onlyOwner {\n', '        require(newReferee != address(0));\n', '        referee = newReferee;\n', '    }\n', '\n', '    constructor(address _owner, address _referee) public {\n', '        owner = _owner;\n', '        referee = _referee;\n', '    }\n', '\n', '    // Create new instances of a PlayerToken contract and pass along msg.value (so the referee pays and not the contract)\n', '    function newInitialPlayerOffering(\n', '        string _name, \n', '        string _symbol, \n', '        uint _startPrice, \n', '        uint _incrementalPrice, \n', '        address _owner,\n', '        uint256 _playerId,\n', '        uint8 _promoSharesQuantity\n', '    ) \n', '        external \n', '        onlyOwnerOrReferee\n', '        payable\n', '    {\n', '        PlayerToken playerTokenContract = (new PlayerToken).value(msg.value)(\n', '            _name, \n', '            _symbol, \n', '            _startPrice, \n', '            _incrementalPrice, \n', '            _owner, \n', '            address(this), \n', '            _playerId, \n', '            _promoSharesQuantity\n', '        );\n', '\n', '        // Add it to a local storage so we can iterate over it to pull portfolio stats\n', '        playerTokenContracts_.push(playerTokenContract);\n', '\n', '        // Event handling\n', '        emit InitialPlayerOffering(address(playerTokenContract), _name, _symbol);\n', '    }\n', '\n', '    // Empty fallback - any Ether here just goes straight into the Dividend pool\n', '    // this is useful as it provides a mechanism for the other blockchain football games\n', '    // to top the fund up for special events / promotions\n', '    function() payable public { }\n', '\n', '    function getTotalDividendPool() public view returns (uint) {\n', '        return address(this).balance.sub(balancePendingWithdrawal_);\n', '    }\n', '\n', '    function totalPlayerTokenContracts() public view returns (uint) {\n', '        return playerTokenContracts_.length;\n', '    }\n', '\n', '    function totalDividendWinners() public view returns (uint) {\n', '        return dividendWinners_.length;\n', '    }\n', '\n', '    // Called off-chain to manage UI state so no gas concerns - also never likely to be more than 50-200ish player contracts\n', '    function allPlayerTokenContracts() external view returns (address[]) {\n', '        uint playerContractCount = totalPlayerTokenContracts();\n', '        address[] memory addresses = new address[](playerContractCount);\n', '\n', '        for (uint i = 0; i < playerContractCount; i++) {\n', '            addresses[i] = address(playerTokenContracts_[i]);\n', '        }\n', '\n', '        return addresses;\n', '    }\n', '\n', '    /* Safeguard function to quickly pause a stack of contracts */\n', '    function pausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            if (!playerTokenContract.paused()) {\n', '                playerTokenContract.pause();\n', '            }\n', '        }\n', '    }\n', '\n', '    function unpausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            if (playerTokenContract.paused()) {\n', '                playerTokenContract.unpause();\n', '            }\n', '        }\n', '    }\n', '\n', '    function setSellDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContract.setSellDividendPercentageFee(_fee);\n', '        }\n', '    }\n', '\n', '    function setBuyDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContract.setBuyDividendPercentageFee(_fee);\n', '        }\n', '    }\n', '\n', '    /* Portfolio Support */\n', '    // Only called offchain - so we can omit additional pagination/optimizations here\n', '    function portfolioSummary(address _address) \n', '        external \n', '        view \n', '    returns (\n', '        uint[] _playerTokenContractId, \n', '        uint[] _totalTokens, \n', '        int[] _totalCost, \n', '        uint[] _totalValue) \n', '    {\n', '        uint playerContractCount = totalPlayerTokenContracts();\n', '\n', '        uint[] memory playerTokenContractIds = new uint[](playerContractCount);\n', '        uint[] memory totalTokens = new uint[](playerContractCount);\n', '        int[] memory totalCost = new int[](playerContractCount);\n', '        uint[] memory totalValue = new uint[](playerContractCount);\n', '\n', '        PlayerToken playerTokenContract;\n', '\n', '        for (uint i = 0; i < playerContractCount; i++) {\n', '            playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContractIds[i] = i;\n', '            (totalTokens[i], totalCost[i], totalValue[i]) = playerTokenContract.portfolioSummary(_address);\n', '        }\n', '\n', '        return (playerTokenContractIds, totalTokens, totalCost, totalValue);\n', '    }\n', '\n', '    /* Dividend Handling */\n', '    // These are all handled based on their corresponding index\n', '    // Takes a snapshot of the current dividend pool balance and allocates a per share div award\n', '    function setDividendWinners(\n', '        uint[] _playerContractIds, \n', '        uint[] _totalPlayerTokens, \n', '        uint8[] _individualPlayerAllocationPcs, \n', '        uint _totalPrizePoolAllocationPc\n', '    ) \n', '        external \n', '        onlyOwnerOrReferee \n', '    {\n', '        require(_playerContractIds.length > 0, "Must have valid player contracts to award divs to");\n', '        require(_playerContractIds.length == _totalPlayerTokens.length);\n', '        require(_totalPlayerTokens.length == _individualPlayerAllocationPcs.length);\n', '        require(_totalPrizePoolAllocationPc > 0);\n', '        require(_totalPrizePoolAllocationPc <= 100);\n', '        \n', '        // Calculate how much dividends we have allocated\n', '        uint dailyDivPrizePool = SafeMath.div(SafeMath.mul(getTotalDividendPool(), _totalPrizePoolAllocationPc), 100);\n', '\n', '        // Iteration here should be fine as there should concievably only ever be 3 or 4 winning players each day\n', '        uint8 totalPlayerAllocationPc = 0;\n', '        for (uint8 i = 0; i < _playerContractIds.length; i++) {\n', '            totalPlayerAllocationPc += _individualPlayerAllocationPcs[i];\n', '\n', '            // Calculate from the total daily pool how much is assigned to owners of this player\n', '            // e.g. a typical day might = Total Dividend pool: 100 ETH, _totalPrizePoolAllocationPc: 20 (%)\n', '            // therefore the total dailyDivPrizePool = 20 ETH\n', '            // Which could be allocated as follows\n', '            // 1. 50% MVP Player - (Attacker) (10 ETH total)\n', '            // 2. 25% Player - (Midfielder) (5 ETH total)\n', '            // 3. 25% Player - (Defender) (5 ETH total)\n', '            uint playerPrizePool = SafeMath.div(SafeMath.mul(dailyDivPrizePool, _individualPlayerAllocationPcs[i]), 100);\n', '\n', '            // Calculate total div-per-share\n', '            uint totalPlayerTokens = _totalPlayerTokens[i];\n', '            uint perTokenEthValue = playerPrizePool.div(totalPlayerTokens);\n', '\n', '            // Add to the winners array so it can then be picked up by the div payment processor\n', '            DividendWinner memory divWinner = DividendWinner({\n', '                playerTokenContractId: _playerContractIds[i],\n', '                perTokenEthValue: perTokenEthValue,\n', '                totalTokens: totalPlayerTokens,\n', '                tokensProcessed: 0\n', '            });\n', '\n', '            dividendWinners_.push(divWinner);\n', '        }\n', '\n', '        // We need to make sure we are allocating a valid set of dividend totals (i.e. not more than 100%)\n', '        // this is just to cover us for basic errors, this should never occur\n', '        require(totalPlayerAllocationPc == 100);\n', '    }\n', '\n', '    function allocateDividendsToWinners(uint _dividendWinnerId, address[] _winners, uint[] _tokenAllocation) external onlyOwnerOrReferee {\n', '        DividendWinner storage divWinner = dividendWinners_[_dividendWinnerId];\n', '        require(divWinner.totalTokens > 0); // Basic check to make sure we don&#39;t access a 0&#39;d struct\n', '        require(divWinner.tokensProcessed < divWinner.totalTokens);\n', '        require(_winners.length == _tokenAllocation.length);\n', '\n', '        uint totalEthAssigned;\n', '        uint totalTokensAllocatedEth;\n', '        uint ethAllocation;\n', '        address winner;\n', '\n', '        for (uint i = 0; i < _winners.length; i++) {\n', '            winner = _winners[i];\n', '            ethAllocation = _tokenAllocation[i].mul(divWinner.perTokenEthValue);\n', '            addressToDividendBalance[winner] = addressToDividendBalance[winner].add(ethAllocation);\n', '            totalTokensAllocatedEth = totalTokensAllocatedEth.add(_tokenAllocation[i]);\n', '            totalEthAssigned = totalEthAssigned.add(ethAllocation);\n', '        }\n', '\n', '        // Update balancePendingWithdrawal_ - this allows us to get an accurate reflection of the div pool\n', '        balancePendingWithdrawal_ = balancePendingWithdrawal_.add(totalEthAssigned);\n', '\n', '        // As we will likely cause this function in batches this allows us to make sure we don&#39;t oversettle (failsafe)\n', '        divWinner.tokensProcessed = divWinner.tokensProcessed.add(totalTokensAllocatedEth);\n', '\n', '        // This should never occur, but a failsafe for when automated div payments are rolled out\n', '        require(divWinner.tokensProcessed <= divWinner.totalTokens);\n', '    }\n', '\n', '    function withdrawDividends() external {\n', '        require(addressToDividendBalance[msg.sender] > 0, "Must have a valid dividend balance");\n', '        uint senderBalance = addressToDividendBalance[msg.sender];\n', '        addressToDividendBalance[msg.sender] = 0;\n', '        balancePendingWithdrawal_ = balancePendingWithdrawal_.sub(senderBalance);\n', '        msg.sender.transfer(senderBalance);\n', '        emit DividendWithdrawal(msg.sender, senderBalance);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/*\n', '* The Blockchain Football network presents....\n', '* https://fantasyfootballfund.co/\n', '* https://discord.gg/qPjA6Tx\n', '*\n', '* Build your fantasy player portfolio. Earn crypto daily based on player performance.\n', '*\n', '* 4 Ways to earn\n', '* [1] Price Fluctuations - buy and sell at the right moments\n', '* [2] Match day Divs - allocated to shareholders of top performing players every day\n', '* [3] Fame Divs - allocated to shareholders of infamous players on non-match days\n', '* [4] Original Owner - allocated to owners of original player cards on blockchainfootball.co (2% per share sold)\n', '*/\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract PlayerToken is ERC20 {\n', '\n', '    // Ownable\n', '    address public owner;\n', '    bool public paused = false;\n', '\n', '    // Events\n', '    event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol);\n', '    event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol);\n', '\n', '    // Libs\n', '    using SafeMath for uint256;\n', '\n', '    // Core token attributes\n', '    uint256 public initialTokenPrice_;  // Typically = 1 Finney (0.001 Ether)\n', '    uint256 public incrementalTokenPrice_; // Typically = 0.01 Finney (0.00001 Ether)\n', '\n', '    // Token Properties - set via the constructor for each player\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 0;\n', '\n', '    // Exchange Contract - used to hold the dividend pool across all ERC20 player contracts\n', '    // when shares are brought or sold the dividend fee gets transfered here\n', '    address public exchangeContract_;\n', '    \n', '    // Blockchainfootball.co attributes - if this is set the owner receieves a fee for owning the original card\n', '    BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F);\n', '    uint256 public playerId_;\n', '    address public originalOwner_;\n', '\n', '    // Fees - denoted in %\n', '    uint8 constant internal processingFee_ = 5; // inc. fees to cover DAILY gas usage to assign divs to token holders\n', '    uint8 constant internal originalOwnerFee_ = 2; // of all token buys per original player owned + set on blockchainfootball.co\n', '    uint8 internal dividendBuyPoolFee_ = 15; // buys AND sells go into the div pool to promote gameplay - can be updated\n', '    uint8 internal dividendSellPoolFee_ = 20;\n', '    uint8 constant internal referrerFee_ = 1; // for all token buys (but not sells)\n', '\n', '    // ERC20 data structures\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    // Player Exchange Data Structures\n', '    address[] public tokenHolders;\n', '    mapping(address => uint256) public addressToTokenHolderIndex; // Helps to gas-efficiently remove shareholders, by swapping last index\n', '    mapping(address => int256) public totalCost; // To hold the total expenditure of each address, profit tracking\n', '\n', '    // ERC20 Properties\n', '    uint256 totalSupply_;\n', '\n', '    // Additional accessors\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrExchange() {\n', '        require(msg.sender == owner || msg.sender == exchangeContract_);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '    constructor(\n', '        string _name, \n', '        string _symbol, \n', '        uint _startPrice, \n', '        uint _incrementalPrice, \n', '        address _owner, \n', '        address _exchangeContract, \n', '        uint256 _playerId,\n', '        uint8 _promoSharesQuantity\n', '    ) \n', '        public\n', '        payable\n', '    {\n', '        require(_exchangeContract != address(0));\n', '        require(_owner != address(0));\n', '\n', '        exchangeContract_ = _exchangeContract;\n', '        playerId_ = _playerId;\n', '\n', '        // Set initial starting exchange values\n', '        initialTokenPrice_ = _startPrice;\n', '        incrementalTokenPrice_ = _incrementalPrice; // In most cases this will be 1 finney, 0.001 ETH\n', '\n', '        // Initial token properties\n', '        paused = true;\n', '        owner = _owner;\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        // Purchase promotional player shares - we purchase initial shares (the same way users do) as prizes for promos/competitions/giveaways\n', '        if (_promoSharesQuantity > 0) {\n', '            _buyTokens(msg.value, _promoSharesQuantity, _owner, address(0));\n', '        }\n', '    }\n', '\n', '    // **External Exchange**\n', '    function buyTokens(uint8 _amount, address _referredBy) payable external whenNotPaused {\n', '        require(_amount > 0 && _amount <= 100, "Valid token amount required between 1 and 100");\n', '        require(msg.value > 0, "Provide a valid fee"); \n', '        // solium-disable-next-line security/no-tx-origin\n', '        require(msg.sender == tx.origin, "Only valid users are allowed to buy tokens"); \n', '        _buyTokens(msg.value, _amount, msg.sender, _referredBy);\n', '    }\n', '\n', '    function sellTokens(uint8 _amount) external {\n', '        require(_amount > 0, "Valid sell amount required");\n', '        require(_amount <= balances[msg.sender]);\n', '        _sellTokens(_amount, msg.sender);\n', '    }\n', '\n', '    // **Internal Exchange**\n', '    function _buyTokens(uint _ethSent, uint8 _amount, address _buyer, address _referredBy) internal {\n', '        \n', '        uint _totalCost;\n', '        uint _processingFee;\n', '        uint _originalOwnerFee;\n', '        uint _dividendPoolFee;\n', '        uint _referrerFee;\n', '\n', '        (_totalCost, _processingFee, _originalOwnerFee, _dividendPoolFee, _referrerFee) = calculateTokenBuyPrice(_amount);\n', '\n', '        require(_ethSent >= _totalCost, "Invalid fee to buy tokens");\n', '\n', '        // Send to original card owner if available\n', "        // If we don't have an original owner we move this fee into the dividend pool\n", '        if (originalOwner_ != address(0)) {\n', '            originalOwner_.transfer(_originalOwnerFee);\n', '        } else {\n', '            _dividendPoolFee = _dividendPoolFee.add(_originalOwnerFee);\n', '        }\n', '\n', "        // Send to the referrer - if we don't have a referrer we move this fee into the dividend pool\n", '        if (_referredBy != address(0)) {\n', '            _referredBy.transfer(_referrerFee);\n', '        } else {\n', '            _dividendPoolFee = _dividendPoolFee.add(_referrerFee);\n', '        }\n', '\n', '        // These will always be available\n', '        owner.transfer(_processingFee);\n', '        exchangeContract_.transfer(_dividendPoolFee);\n', '\n', '        // Refund excess\n', '        uint excess = _ethSent.sub(_totalCost);\n', '        _buyer.transfer(excess);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_buyer) == 0) {\n', '            tokenHolders.push(_buyer);\n', '            addressToTokenHolderIndex[_buyer] = tokenHolders.length - 1;\n', '        }\n', '        \n', '        // Provide users with the shares\n', '        _allocatePlayerTokensTo(_buyer, _amount);\n', '\n', '        // Track costs\n', '        totalCost[_buyer] = totalCost[_buyer] + int256(_totalCost); // No need for safe maths here, just holds profit tracking\n', '\n', '        // Event tracking\n', '        emit PlayerTokenBuy(_buyer, _referredBy, _amount, _totalCost, symbol);\n', '    }\n', '\n', '    function _sellTokens(uint8 _amount, address _seller) internal {\n', '        \n', '        uint _totalSellerProceeds;\n', '        uint _processingFee;\n', '        uint _dividendPoolFee;\n', '\n', '        (_totalSellerProceeds, _processingFee, _dividendPoolFee) = calculateTokenSellPrice(_amount);\n', '\n', '        // Burn the sellers shares\n', '        _burnPlayerTokensFrom(_seller, _amount);\n', '\n', "        // Track ownership of token holders if the user no longer has tokens let's remove them\n", '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(_seller) == 0) {\n', '            removeFromTokenHolders(_seller);\n', '        }\n', '\n', '        // Transfer to processor, seller and dividend pool\n', '        owner.transfer(_processingFee);\n', '        _seller.transfer(_totalSellerProceeds);\n', '        exchangeContract_.transfer(_dividendPoolFee);\n', '\n', '        // Track costs\n', '        totalCost[_seller] = totalCost[_seller] - int256(_totalSellerProceeds); // No need for safe maths here, just holds profit tracking\n', '\n', '        // Event tracking\n', '        emit PlayerTokenSell(_seller, _amount, _totalSellerProceeds, symbol);\n', '    }\n', '\n', '    // **Calculations - these factor in all fees**\n', '    function calculateTokenBuyPrice(uint _amount) \n', '        public \n', '        view \n', '        returns (\n', '        uint _totalCost, \n', '        uint _processingFee, \n', '        uint _originalOwnerFee, \n', '        uint _dividendPoolFee, \n', '        uint _referrerFee\n', '    ) {    \n', '        uint tokenCost = calculateTokenOnlyBuyPrice(_amount);\n', '\n', '        // We now need to apply fees on top of this\n', "        // In all cases we apply fees - but if there's no original owner or referrer\n", '        // these go into the dividend pool\n', '        _processingFee = SafeMath.div(SafeMath.mul(tokenCost, processingFee_), 100);\n', '        _originalOwnerFee = SafeMath.div(SafeMath.mul(tokenCost, originalOwnerFee_), 100);\n', '        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenCost, dividendBuyPoolFee_), 100);\n', '        _referrerFee = SafeMath.div(SafeMath.mul(tokenCost, referrerFee_), 100);\n', '\n', '        _totalCost = tokenCost.add(_processingFee).add(_originalOwnerFee).add(_dividendPoolFee).add(_referrerFee);\n', '    }\n', '\n', '    function calculateTokenSellPrice(uint _amount) \n', '        public \n', '        view \n', '        returns (\n', '        uint _totalSellerProceeds,\n', '        uint _processingFee,\n', '        uint _dividendPoolFee\n', '    ) {\n', '        uint tokenSellCost = calculateTokenOnlySellPrice(_amount);\n', '\n', '        // We remove the processing and dividend fees on the final sell price\n', '        // this represents the difference between the buy and sell price on the UI\n', '        _processingFee = SafeMath.div(SafeMath.mul(tokenSellCost, processingFee_), 100);\n', '        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenSellCost, dividendSellPoolFee_), 100);\n', '\n', '        _totalSellerProceeds = tokenSellCost.sub(_processingFee).sub(_dividendPoolFee);\n', '    }\n', '\n', '    // **Calculate total cost of tokens without fees**\n', '    function calculateTokenOnlyBuyPrice(uint _amount) public view returns(uint) {\n', '        \n', '        // We use a simple arithmetic progression series, summing the incremental prices\n', '\t    // ((n / 2) * (2 * a + (n - 1) * d))\n', '\t    // a = starting value (1st term), d = price increment (diff.), n = amount of shares (no. of terms)\n', '\n', '        // NOTE: we use a mutiplier to avoid issues with an odd number of shares, dividing and limited fixed point support in Solidity\n', '        uint8 multiplier = 10;\n', '        uint amountMultiplied = _amount * multiplier; \n', '        uint startingPrice = initialTokenPrice_ + (totalSupply_ * incrementalTokenPrice_);\n', '        uint totalBuyPrice = (amountMultiplied / 2) * (2 * startingPrice + (_amount - 1) * incrementalTokenPrice_) / multiplier;\n', '\n', '        // Should never *concievably* occur, but more effecient than Safemaths on the entire formula\n', '        assert(totalBuyPrice >= startingPrice); \n', '        return totalBuyPrice;\n', '    }\n', '\n', '    function calculateTokenOnlySellPrice(uint _amount) public view returns(uint) {\n', '        // Similar to calculateTokenBuyPrice, but we abs() the incrementalTokenPrice so we get a reverse arithmetic series\n', '        uint8 multiplier = 10;\n', '        uint amountMultiplied = _amount * multiplier; \n', '        uint startingPrice = initialTokenPrice_ + ((totalSupply_-1) * incrementalTokenPrice_);\n', '        int absIncrementalTokenPrice = int(incrementalTokenPrice_) * -1;\n', '        uint totalSellPrice = uint((int(amountMultiplied) / 2) * (2 * int(startingPrice) + (int(_amount) - 1) * absIncrementalTokenPrice) / multiplier);\n', '        return totalSellPrice;\n', '    }\n', '\n', '    // **UI Helpers**\n', '    function buySellPrices() public view returns(uint _buyPrice, uint _sellPrice) {\n', '        (_buyPrice,,,,) = calculateTokenBuyPrice(1);\n', '        (_sellPrice,,) = calculateTokenSellPrice(1);\n', '    }\n', '\n', '    function portfolioSummary(address _address) public view returns(uint _tokenBalance, int _cost, uint _value) {\n', '        _tokenBalance = balanceOf(_address);\n', '        _cost = totalCost[_address];\n', '        (_value,,) = calculateTokenSellPrice(_tokenBalance);       \n', '    }\n', '\n', '    function totalTokenHolders() public view returns(uint) {\n', '        return tokenHolders.length;\n', '    }\n', '\n', '    function tokenHoldersByIndex() public view returns(address[] _addresses, uint[] _shares) {\n', '        \n', '        // This will only be called offchain to take snapshots of share count at cut off points for divs\n', '        uint tokenHolderCount = tokenHolders.length;\n', '        address[] memory addresses = new address[](tokenHolderCount);\n', '        uint[] memory shares = new uint[](tokenHolderCount);\n', '\n', '        for (uint i = 0; i < tokenHolderCount; i++) {\n', '            addresses[i] = tokenHolders[i];\n', '            shares[i] = balanceOf(tokenHolders[i]);\n', '        }\n', '\n', '        return (addresses, shares);\n', '    }\n', '\n', "    // In cases where there's bugs in the exchange contract we need a way to re-point\n", '    function setExchangeContractAddress(address _exchangeContract) external onlyOwner {\n', '        exchangeContract_ = _exchangeContract;\n', '    }\n', '\n', '    // **Blockchainfootball.co Support**\n', '    function setBCFContractAddress(address _address) external onlyOwner {\n', '        BCFMain candidateContract = BCFMain(_address);\n', '        require(candidateContract.implementsERC721());\n', '        bcfContract_ = candidateContract;\n', '    }\n', '\n', '    function setPlayerId(uint256 _playerId) external onlyOwner {\n', '        playerId_ = _playerId;\n', '    }\n', '\n', '    function setSellDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\n', "        // We'll need some flexibility to alter this as the right dividend structure helps promote gameplay\n", '        // This pushes users to buy players who are performing well to grab divs rather than just getting in early to new players being released\n', '        require(_dividendPoolFee <= 50, "Max of 50% is assignable to the pool");\n', '        dividendSellPoolFee_ = _dividendPoolFee;\n', '    }\n', '\n', '    function setBuyDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\n', '        require(_dividendPoolFee <= 50, "Max of 50% is assignable to the pool");\n', '        dividendBuyPoolFee_ = _dividendPoolFee;\n', '    }\n', '\n', '    // Can be called by anyone, in which case we could use a another contract to set the original owner whenever it changes on blockchainfootball.co\n', '    function setOriginalOwner(uint256 _playerCardId, address _address) external {\n', '        require(playerId_ > 0, "Player ID must be set on the contract");\n', '        \n', "        // As we call .transfer() on buys to send original owners divs we need to make sure this can't be DOS'd through setting the\n", '        // original owner as a smart contract and then reverting any transfer() calls\n', '        // while it would be silly to reject divs it is a valid DOS scenario\n', '        // solium-disable-next-line security/no-tx-origin\n', '        require(msg.sender == tx.origin, "Only valid users are able to set original ownership"); \n', '       \n', '        address _cardOwner;\n', '        uint256 _playerId;\n', '        bool _isFirstGeneration;\n', '\n', '        (_playerId,_cardOwner,,_isFirstGeneration) = bcfContract_.playerCards(_playerCardId);\n', '\n', '        require(_isFirstGeneration, "Card must be an original");\n', '        require(_playerId == playerId_, "Card must tbe the same player this contract relates to");\n', '        require(_cardOwner == _address, "Card must be owned by the address provided");\n', '        \n', '        // All good, set the address as the original owner, happy div day \\o/\n', '        originalOwner_ = _address;\n', '    }\n', '\n', '    // ** Internal Token Handling - validation completed by callers **\n', '    function _allocatePlayerTokensTo(address _to, uint256 _amount) internal {\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '    function _burnPlayerTokensFrom(address _from, uint256 _amount) internal {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        totalSupply_ = totalSupply_.sub(_amount);\n', '        emit Transfer(_from, address(0), _amount);\n', '    }\n', '\n', '    function removeFromTokenHolders(address _seller) internal {\n', '        \n', '        uint256 tokenIndex = addressToTokenHolderIndex[_seller];\n', '        uint256 lastAddressIndex = tokenHolders.length.sub(1);\n', '        address lastAddress = tokenHolders[lastAddressIndex];\n', '        \n', '        tokenHolders[tokenIndex] = lastAddress;\n', '        tokenHolders[lastAddressIndex] = address(0);\n', '        tokenHolders.length--;\n', '\n', '        addressToTokenHolderIndex[lastAddress] = tokenIndex;\n', '    }\n', '\n', '    // ** ERC20 Support **\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_to) == 0) {\n', '            tokenHolders.push(_to);\n', '            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', "        // Track ownership of token holders if the user no longer has tokens let's remove them\n", '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(msg.sender) == 0) {\n', '            removeFromTokenHolders(msg.sender);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Track ownership of token holders - only if this is the first time the user is buying these player shares\n', '        if (balanceOf(_to) == 0) {\n', '            tokenHolders.push(_to);\n', '            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\n', '        }\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', "        // Track ownership of token holders if the user no longer has tokens let's remove them\n", '        // we do this semi-efficently by swapping the last index\n', '        if (balanceOf(_from) == 0) {\n', '            removeFromTokenHolders(_from);\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Utilities\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '    function pause() onlyOwnerOrExchange whenNotPaused public {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() onlyOwnerOrExchange whenPaused public {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract BCFMain {\n', '    function playerCards(uint256 playerCardId) public view returns (uint256 playerId, address owner, address approvedForTransfer, bool isFirstGeneration);\n', '    function implementsERC721() public pure returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract PlayerExchangeCore {\n', '\n', '    // Events\n', '    event InitialPlayerOffering(address indexed contractAddress, string name, string symbol);\n', '    event DividendWithdrawal(address indexed user, uint amount);\n', '\n', '    // Libs\n', '    using SafeMath for uint256;\n', '\n', '    // Ownership\n', '    address public owner;\n', '    address public referee; // Used to pay out divs and initiate an IPO\n', '\n', '    // Structs\n', '    struct DividendWinner {\n', '        uint playerTokenContractId;\n', '        uint perTokenEthValue;\n', '        uint totalTokens;\n', '        uint tokensProcessed; // So we can determine when all tokens have been allocated divs + settled\n', '    }\n', '\n', '    // State management\n', '    uint internal balancePendingWithdrawal_; // this.balance - balancePendingWithdrawal_ = div prize pool\n', '\n', '    // Data Store\n', '    PlayerToken[] public playerTokenContracts_; // Holds a list of all player token contracts\n', "    DividendWinner[] public dividendWinners_; // Holds a list of dividend winners (player contract id's, not users)\n", '    mapping(address => uint256) public addressToDividendBalance;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyReferee() {\n', '        require(msg.sender == referee);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrReferee() {\n', '        require(msg.sender == owner || msg.sender == referee);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setReferee(address newReferee) public onlyOwner {\n', '        require(newReferee != address(0));\n', '        referee = newReferee;\n', '    }\n', '\n', '    constructor(address _owner, address _referee) public {\n', '        owner = _owner;\n', '        referee = _referee;\n', '    }\n', '\n', '    // Create new instances of a PlayerToken contract and pass along msg.value (so the referee pays and not the contract)\n', '    function newInitialPlayerOffering(\n', '        string _name, \n', '        string _symbol, \n', '        uint _startPrice, \n', '        uint _incrementalPrice, \n', '        address _owner,\n', '        uint256 _playerId,\n', '        uint8 _promoSharesQuantity\n', '    ) \n', '        external \n', '        onlyOwnerOrReferee\n', '        payable\n', '    {\n', '        PlayerToken playerTokenContract = (new PlayerToken).value(msg.value)(\n', '            _name, \n', '            _symbol, \n', '            _startPrice, \n', '            _incrementalPrice, \n', '            _owner, \n', '            address(this), \n', '            _playerId, \n', '            _promoSharesQuantity\n', '        );\n', '\n', '        // Add it to a local storage so we can iterate over it to pull portfolio stats\n', '        playerTokenContracts_.push(playerTokenContract);\n', '\n', '        // Event handling\n', '        emit InitialPlayerOffering(address(playerTokenContract), _name, _symbol);\n', '    }\n', '\n', '    // Empty fallback - any Ether here just goes straight into the Dividend pool\n', '    // this is useful as it provides a mechanism for the other blockchain football games\n', '    // to top the fund up for special events / promotions\n', '    function() payable public { }\n', '\n', '    function getTotalDividendPool() public view returns (uint) {\n', '        return address(this).balance.sub(balancePendingWithdrawal_);\n', '    }\n', '\n', '    function totalPlayerTokenContracts() public view returns (uint) {\n', '        return playerTokenContracts_.length;\n', '    }\n', '\n', '    function totalDividendWinners() public view returns (uint) {\n', '        return dividendWinners_.length;\n', '    }\n', '\n', '    // Called off-chain to manage UI state so no gas concerns - also never likely to be more than 50-200ish player contracts\n', '    function allPlayerTokenContracts() external view returns (address[]) {\n', '        uint playerContractCount = totalPlayerTokenContracts();\n', '        address[] memory addresses = new address[](playerContractCount);\n', '\n', '        for (uint i = 0; i < playerContractCount; i++) {\n', '            addresses[i] = address(playerTokenContracts_[i]);\n', '        }\n', '\n', '        return addresses;\n', '    }\n', '\n', '    /* Safeguard function to quickly pause a stack of contracts */\n', '    function pausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            if (!playerTokenContract.paused()) {\n', '                playerTokenContract.pause();\n', '            }\n', '        }\n', '    }\n', '\n', '    function unpausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            if (playerTokenContract.paused()) {\n', '                playerTokenContract.unpause();\n', '            }\n', '        }\n', '    }\n', '\n', '    function setSellDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContract.setSellDividendPercentageFee(_fee);\n', '        }\n', '    }\n', '\n', '    function setBuyDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            PlayerToken playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContract.setBuyDividendPercentageFee(_fee);\n', '        }\n', '    }\n', '\n', '    /* Portfolio Support */\n', '    // Only called offchain - so we can omit additional pagination/optimizations here\n', '    function portfolioSummary(address _address) \n', '        external \n', '        view \n', '    returns (\n', '        uint[] _playerTokenContractId, \n', '        uint[] _totalTokens, \n', '        int[] _totalCost, \n', '        uint[] _totalValue) \n', '    {\n', '        uint playerContractCount = totalPlayerTokenContracts();\n', '\n', '        uint[] memory playerTokenContractIds = new uint[](playerContractCount);\n', '        uint[] memory totalTokens = new uint[](playerContractCount);\n', '        int[] memory totalCost = new int[](playerContractCount);\n', '        uint[] memory totalValue = new uint[](playerContractCount);\n', '\n', '        PlayerToken playerTokenContract;\n', '\n', '        for (uint i = 0; i < playerContractCount; i++) {\n', '            playerTokenContract = playerTokenContracts_[i];\n', '            playerTokenContractIds[i] = i;\n', '            (totalTokens[i], totalCost[i], totalValue[i]) = playerTokenContract.portfolioSummary(_address);\n', '        }\n', '\n', '        return (playerTokenContractIds, totalTokens, totalCost, totalValue);\n', '    }\n', '\n', '    /* Dividend Handling */\n', '    // These are all handled based on their corresponding index\n', '    // Takes a snapshot of the current dividend pool balance and allocates a per share div award\n', '    function setDividendWinners(\n', '        uint[] _playerContractIds, \n', '        uint[] _totalPlayerTokens, \n', '        uint8[] _individualPlayerAllocationPcs, \n', '        uint _totalPrizePoolAllocationPc\n', '    ) \n', '        external \n', '        onlyOwnerOrReferee \n', '    {\n', '        require(_playerContractIds.length > 0, "Must have valid player contracts to award divs to");\n', '        require(_playerContractIds.length == _totalPlayerTokens.length);\n', '        require(_totalPlayerTokens.length == _individualPlayerAllocationPcs.length);\n', '        require(_totalPrizePoolAllocationPc > 0);\n', '        require(_totalPrizePoolAllocationPc <= 100);\n', '        \n', '        // Calculate how much dividends we have allocated\n', '        uint dailyDivPrizePool = SafeMath.div(SafeMath.mul(getTotalDividendPool(), _totalPrizePoolAllocationPc), 100);\n', '\n', '        // Iteration here should be fine as there should concievably only ever be 3 or 4 winning players each day\n', '        uint8 totalPlayerAllocationPc = 0;\n', '        for (uint8 i = 0; i < _playerContractIds.length; i++) {\n', '            totalPlayerAllocationPc += _individualPlayerAllocationPcs[i];\n', '\n', '            // Calculate from the total daily pool how much is assigned to owners of this player\n', '            // e.g. a typical day might = Total Dividend pool: 100 ETH, _totalPrizePoolAllocationPc: 20 (%)\n', '            // therefore the total dailyDivPrizePool = 20 ETH\n', '            // Which could be allocated as follows\n', '            // 1. 50% MVP Player - (Attacker) (10 ETH total)\n', '            // 2. 25% Player - (Midfielder) (5 ETH total)\n', '            // 3. 25% Player - (Defender) (5 ETH total)\n', '            uint playerPrizePool = SafeMath.div(SafeMath.mul(dailyDivPrizePool, _individualPlayerAllocationPcs[i]), 100);\n', '\n', '            // Calculate total div-per-share\n', '            uint totalPlayerTokens = _totalPlayerTokens[i];\n', '            uint perTokenEthValue = playerPrizePool.div(totalPlayerTokens);\n', '\n', '            // Add to the winners array so it can then be picked up by the div payment processor\n', '            DividendWinner memory divWinner = DividendWinner({\n', '                playerTokenContractId: _playerContractIds[i],\n', '                perTokenEthValue: perTokenEthValue,\n', '                totalTokens: totalPlayerTokens,\n', '                tokensProcessed: 0\n', '            });\n', '\n', '            dividendWinners_.push(divWinner);\n', '        }\n', '\n', '        // We need to make sure we are allocating a valid set of dividend totals (i.e. not more than 100%)\n', '        // this is just to cover us for basic errors, this should never occur\n', '        require(totalPlayerAllocationPc == 100);\n', '    }\n', '\n', '    function allocateDividendsToWinners(uint _dividendWinnerId, address[] _winners, uint[] _tokenAllocation) external onlyOwnerOrReferee {\n', '        DividendWinner storage divWinner = dividendWinners_[_dividendWinnerId];\n', "        require(divWinner.totalTokens > 0); // Basic check to make sure we don't access a 0'd struct\n", '        require(divWinner.tokensProcessed < divWinner.totalTokens);\n', '        require(_winners.length == _tokenAllocation.length);\n', '\n', '        uint totalEthAssigned;\n', '        uint totalTokensAllocatedEth;\n', '        uint ethAllocation;\n', '        address winner;\n', '\n', '        for (uint i = 0; i < _winners.length; i++) {\n', '            winner = _winners[i];\n', '            ethAllocation = _tokenAllocation[i].mul(divWinner.perTokenEthValue);\n', '            addressToDividendBalance[winner] = addressToDividendBalance[winner].add(ethAllocation);\n', '            totalTokensAllocatedEth = totalTokensAllocatedEth.add(_tokenAllocation[i]);\n', '            totalEthAssigned = totalEthAssigned.add(ethAllocation);\n', '        }\n', '\n', '        // Update balancePendingWithdrawal_ - this allows us to get an accurate reflection of the div pool\n', '        balancePendingWithdrawal_ = balancePendingWithdrawal_.add(totalEthAssigned);\n', '\n', "        // As we will likely cause this function in batches this allows us to make sure we don't oversettle (failsafe)\n", '        divWinner.tokensProcessed = divWinner.tokensProcessed.add(totalTokensAllocatedEth);\n', '\n', '        // This should never occur, but a failsafe for when automated div payments are rolled out\n', '        require(divWinner.tokensProcessed <= divWinner.totalTokens);\n', '    }\n', '\n', '    function withdrawDividends() external {\n', '        require(addressToDividendBalance[msg.sender] > 0, "Must have a valid dividend balance");\n', '        uint senderBalance = addressToDividendBalance[msg.sender];\n', '        addressToDividendBalance[msg.sender] = 0;\n', '        balancePendingWithdrawal_ = balancePendingWithdrawal_.sub(senderBalance);\n', '        msg.sender.transfer(senderBalance);\n', '        emit DividendWithdrawal(msg.sender, senderBalance);\n', '    }\n', '}']
