['pragma solidity ^0.4.21;\n', '\n', 'contract OneMillionToken{\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '        }\n', '    \n', '    struct PixelToken{\n', '        uint256 price;\n', '        uint24 color;\n', '        address pixelOwner;\n', '    }\n', '    \n', '    struct pixelWallet{\n', '        mapping (uint24 => uint) indexList;\n', '        uint24[] pixelOwned;\n', '        uint24 pixelListlength;\n', '        string name; \n', '        string link;\n', '    }\n', '    \n', '    address public owner;\n', '    \n', '    string public constant symbol = "1MT";\n', '    string public constant name = "OneMillionToken";\n', '    uint8 public constant decimals = 0;\n', '    \n', '    uint private startPrice = 1000000000000000;\n', '    \n', '    uint public constant maxPrice = 100000000000000000000;\n', '    uint public constant minPrice = 1000000000000;\n', '    \n', '    \n', '    mapping (uint24 => PixelToken) private Image;\n', '    \n', '    mapping (address => pixelWallet) balance;\n', '    \n', '    function getPixelToken(uint24 _id) public view returns(uint256,string,string,uint24,address){\n', '        return(Image[_id].pixelOwner == address(0) ? startPrice : Image[_id].price,balance[Image[_id].pixelOwner].name,balance[Image[_id].pixelOwner].link,Image[_id].color,Image[_id].pixelOwner);\n', '    }\n', '    \n', '    function buyPixelTokenFor(uint24 _id,uint256 _price,uint24 _color, address _to) public payable returns (bool) {\n', '        require(_id>=0&&_id<1000000);\n', '        \n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        require(msg.value>=minPrice&&msg.value<=maxPrice);\n', '        \n', '        if(Image[_id].pixelOwner== address(0)){\n', '            \n', '            require(msg.value>=startPrice);\n', '            \n', '            Transfer(owner, _to, _id);\n', '            \n', '            Image[_id].pixelOwner = _to;\n', '            balance[_to].pixelOwned.push(_id);\n', '            balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '            balance[_to].pixelListlength++;\n', '            \n', '            require(owner.send(msg.value));\n', '            \n', '            Image[_id].price = _price;\n', '            Image[_id].color = _color;\n', '            \n', '            ChangePixel(_id);\n', '            \n', '            return true;\n', '            \n', '        }else{\n', '            require(msg.value>=Image[_id].price);\n', '            \n', '            address prevOwner =Image[_id].pixelOwner; \n', '            \n', '            balance[Image[_id].pixelOwner].indexList[_id] = 0;\n', '            balance[Image[_id].pixelOwner].pixelListlength--;\n', '            \n', '            \n', '            Transfer(Image[_id].pixelOwner, _to, _id);\n', '            \n', '            Image[_id].pixelOwner = _to;\n', '            balance[_to].pixelOwned.push(_id);\n', '            balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '            balance[_to].pixelListlength++;\n', '            \n', '            require(prevOwner.send(msg.value));\n', '            \n', '            Image[_id].price = _price;\n', '            Image[_id].color = _color;\n', '            \n', '            ChangePixel(_id);\n', '            \n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function buyPixelToken(uint24 _id,uint256 _price,uint24 _color) public payable returns (bool){\n', '        return buyPixelTokenFor(_id, _price, _color, msg.sender);\n', '    }\n', '    \n', '    function setPixelToken(uint24 _id,uint256 _price,uint24 _color) public returns (bool){\n', '        require(_id>=0&&_id<1000000);\n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        \n', '        require(msg.sender==Image[_id].pixelOwner);\n', '        \n', '        Image[_id].price = _price;\n', '        Image[_id].color = _color;\n', '        \n', '        ChangePixel(_id);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function OneMillionToken() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function setNameLink(string _name,string _link) public{\n', '        balance[msg.sender].name = _name;\n', '        balance[msg.sender].link = _link;\n', '    }\n', '    \n', '    function totalSupply() public pure returns (uint) {\n', '        return 1000000;    \n', '    }\n', '\n', '    function balanceOf(address _tokenOwner) public constant returns (uint){\n', '        return balance[_tokenOwner].pixelListlength;\n', '    }\n', '    \n', '    function myBalance() public view returns (uint24[]){\n', '        uint24[] memory list = new uint24[](balance[msg.sender].pixelListlength);\n', '        \n', '        uint24 index = 0;\n', '        \n', '        for(uint24 i = 0; i < balance[msg.sender].pixelOwned.length;i++){\n', '            if(balance[msg.sender].indexList[balance[msg.sender].pixelOwned[i]]==i+1){\n', '                list[index]=balance[msg.sender].pixelOwned[i];\n', '                index++;\n', '            }\n', '        }\n', '        return list;\n', '    }\n', '\n', '    function transfer(address _to, uint24 _id) public returns (bool success){\n', '        require(_id>=0&&_id<1000000);\n', '        require(Image[_id].pixelOwner == msg.sender);\n', '        \n', '        balance[Image[_id].pixelOwner].indexList[_id] = 0;\n', '        balance[Image[_id].pixelOwner].pixelListlength--;\n', '        \n', '        Transfer(Image[_id].pixelOwner, _to, _id);\n', '        \n', '        Image[_id].pixelOwner = _to;\n', '        \n', '        balance[_to].pixelOwned.push(_id);\n', '        balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '        balance[_to].pixelListlength++;\n', '        return true;\n', '    }\n', '    \n', '    function pixelblockPrice (uint24 _startx,uint24 _starty,uint24 _endx,uint24 _endy) public view returns (uint){\n', '        require(_startx>=0&&_startx<625);\n', '        require(_starty>=0&&_starty<1600);\n', '        require(_endx>=_startx&&_endx<625);\n', '        require(_endy>=_starty&&_endy<1600);\n', '        \n', '        uint256 price = 0;\n', '        for(uint24 x = _startx; x<= _endx;x++){\n', '            for(uint24 y = _starty;y<=_endy;y++ ){\n', '                uint24 id = y*1600+x;\n', '                if(Image[id].pixelOwner==address(0)){\n', '                    price=add(price,startPrice);\n', '                }else{\n', '                    price=add(price,Image[id].price);\n', '                }\n', '            }\n', '        }\n', '        return price;\n', '    }\n', '    \n', '    function setStartPrice(uint _price) public onlyOwner returns (bool){\n', '        \n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        startPrice = _price;\n', '        return true;\n', '    }\n', '    \n', '    function getStartPrice() public view returns (uint){\n', '        return startPrice;\n', '    }\n', '    \n', '    modifier onlyOwner{\n', '        require(msg.sender==owner);\n', '        _;\n', '    }\n', '    \n', '    event ChangePixel(uint tokens);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract OneMillionToken{\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '        }\n', '    \n', '    struct PixelToken{\n', '        uint256 price;\n', '        uint24 color;\n', '        address pixelOwner;\n', '    }\n', '    \n', '    struct pixelWallet{\n', '        mapping (uint24 => uint) indexList;\n', '        uint24[] pixelOwned;\n', '        uint24 pixelListlength;\n', '        string name; \n', '        string link;\n', '    }\n', '    \n', '    address public owner;\n', '    \n', '    string public constant symbol = "1MT";\n', '    string public constant name = "OneMillionToken";\n', '    uint8 public constant decimals = 0;\n', '    \n', '    uint private startPrice = 1000000000000000;\n', '    \n', '    uint public constant maxPrice = 100000000000000000000;\n', '    uint public constant minPrice = 1000000000000;\n', '    \n', '    \n', '    mapping (uint24 => PixelToken) private Image;\n', '    \n', '    mapping (address => pixelWallet) balance;\n', '    \n', '    function getPixelToken(uint24 _id) public view returns(uint256,string,string,uint24,address){\n', '        return(Image[_id].pixelOwner == address(0) ? startPrice : Image[_id].price,balance[Image[_id].pixelOwner].name,balance[Image[_id].pixelOwner].link,Image[_id].color,Image[_id].pixelOwner);\n', '    }\n', '    \n', '    function buyPixelTokenFor(uint24 _id,uint256 _price,uint24 _color, address _to) public payable returns (bool) {\n', '        require(_id>=0&&_id<1000000);\n', '        \n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        require(msg.value>=minPrice&&msg.value<=maxPrice);\n', '        \n', '        if(Image[_id].pixelOwner== address(0)){\n', '            \n', '            require(msg.value>=startPrice);\n', '            \n', '            Transfer(owner, _to, _id);\n', '            \n', '            Image[_id].pixelOwner = _to;\n', '            balance[_to].pixelOwned.push(_id);\n', '            balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '            balance[_to].pixelListlength++;\n', '            \n', '            require(owner.send(msg.value));\n', '            \n', '            Image[_id].price = _price;\n', '            Image[_id].color = _color;\n', '            \n', '            ChangePixel(_id);\n', '            \n', '            return true;\n', '            \n', '        }else{\n', '            require(msg.value>=Image[_id].price);\n', '            \n', '            address prevOwner =Image[_id].pixelOwner; \n', '            \n', '            balance[Image[_id].pixelOwner].indexList[_id] = 0;\n', '            balance[Image[_id].pixelOwner].pixelListlength--;\n', '            \n', '            \n', '            Transfer(Image[_id].pixelOwner, _to, _id);\n', '            \n', '            Image[_id].pixelOwner = _to;\n', '            balance[_to].pixelOwned.push(_id);\n', '            balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '            balance[_to].pixelListlength++;\n', '            \n', '            require(prevOwner.send(msg.value));\n', '            \n', '            Image[_id].price = _price;\n', '            Image[_id].color = _color;\n', '            \n', '            ChangePixel(_id);\n', '            \n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function buyPixelToken(uint24 _id,uint256 _price,uint24 _color) public payable returns (bool){\n', '        return buyPixelTokenFor(_id, _price, _color, msg.sender);\n', '    }\n', '    \n', '    function setPixelToken(uint24 _id,uint256 _price,uint24 _color) public returns (bool){\n', '        require(_id>=0&&_id<1000000);\n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        \n', '        require(msg.sender==Image[_id].pixelOwner);\n', '        \n', '        Image[_id].price = _price;\n', '        Image[_id].color = _color;\n', '        \n', '        ChangePixel(_id);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function OneMillionToken() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function setNameLink(string _name,string _link) public{\n', '        balance[msg.sender].name = _name;\n', '        balance[msg.sender].link = _link;\n', '    }\n', '    \n', '    function totalSupply() public pure returns (uint) {\n', '        return 1000000;    \n', '    }\n', '\n', '    function balanceOf(address _tokenOwner) public constant returns (uint){\n', '        return balance[_tokenOwner].pixelListlength;\n', '    }\n', '    \n', '    function myBalance() public view returns (uint24[]){\n', '        uint24[] memory list = new uint24[](balance[msg.sender].pixelListlength);\n', '        \n', '        uint24 index = 0;\n', '        \n', '        for(uint24 i = 0; i < balance[msg.sender].pixelOwned.length;i++){\n', '            if(balance[msg.sender].indexList[balance[msg.sender].pixelOwned[i]]==i+1){\n', '                list[index]=balance[msg.sender].pixelOwned[i];\n', '                index++;\n', '            }\n', '        }\n', '        return list;\n', '    }\n', '\n', '    function transfer(address _to, uint24 _id) public returns (bool success){\n', '        require(_id>=0&&_id<1000000);\n', '        require(Image[_id].pixelOwner == msg.sender);\n', '        \n', '        balance[Image[_id].pixelOwner].indexList[_id] = 0;\n', '        balance[Image[_id].pixelOwner].pixelListlength--;\n', '        \n', '        Transfer(Image[_id].pixelOwner, _to, _id);\n', '        \n', '        Image[_id].pixelOwner = _to;\n', '        \n', '        balance[_to].pixelOwned.push(_id);\n', '        balance[_to].indexList[_id] = balance[_to].pixelOwned.length;\n', '        balance[_to].pixelListlength++;\n', '        return true;\n', '    }\n', '    \n', '    function pixelblockPrice (uint24 _startx,uint24 _starty,uint24 _endx,uint24 _endy) public view returns (uint){\n', '        require(_startx>=0&&_startx<625);\n', '        require(_starty>=0&&_starty<1600);\n', '        require(_endx>=_startx&&_endx<625);\n', '        require(_endy>=_starty&&_endy<1600);\n', '        \n', '        uint256 price = 0;\n', '        for(uint24 x = _startx; x<= _endx;x++){\n', '            for(uint24 y = _starty;y<=_endy;y++ ){\n', '                uint24 id = y*1600+x;\n', '                if(Image[id].pixelOwner==address(0)){\n', '                    price=add(price,startPrice);\n', '                }else{\n', '                    price=add(price,Image[id].price);\n', '                }\n', '            }\n', '        }\n', '        return price;\n', '    }\n', '    \n', '    function setStartPrice(uint _price) public onlyOwner returns (bool){\n', '        \n', '        require(_price>=minPrice&&_price<=maxPrice);\n', '        startPrice = _price;\n', '        return true;\n', '    }\n', '    \n', '    function getStartPrice() public view returns (uint){\n', '        return startPrice;\n', '    }\n', '    \n', '    modifier onlyOwner{\n', '        require(msg.sender==owner);\n', '        _;\n', '    }\n', '    \n', '    event ChangePixel(uint tokens);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '}']
