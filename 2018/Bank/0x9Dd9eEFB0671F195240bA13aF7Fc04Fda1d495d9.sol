['pragma solidity ^0.4.24;\n', '\n', 'contract _2Percent {\n', '    address public owner;\n', '    uint public investedAmount;\n', '    address[] public addresses;\n', '    uint public lastPaymentDate;\n', '    uint constant public interest = 2;\n', '    uint constant public transactions_limit = 100;\n', '    mapping(address => Member) public members;\n', '    uint constant public min_withdraw = 100000000000000 wei;\n', '    uint constant public min_invest = 10000000000000000 wei;\n', '\n', '    struct Member\n', '    {\n', '        uint id;\n', '        address referrer;\n', '        uint deposit;\n', '        uint deposits;\n', '        uint date;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        addresses.length = 1;\n', '    }\n', '\n', '    function getMemberCount() public view returns (uint) {\n', '        return addresses.length - 1;\n', '    }\n', '\n', '    function getMemberDividendsAmount(address addr) public view returns (uint) {\n', '        return members[addr].deposit / 100 * interest * (now - members[addr].date) / 1 days;\n', '    }\n', '\n', '    function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '\n', '    function selfPayout() private {\n', '        require(members[msg.sender].id > 0, "Member not found.");\n', '        uint amount = getMemberDividendsAmount(msg.sender);\n', '        require(amount >= min_withdraw, "Too small amount, minimum 0.0001 ether");\n', '        members[msg.sender].date = now;\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function() payable public {\n', '        if (owner == msg.sender) {\n', '            return;\n', '        }\n', '\n', '        if (0 == msg.value) {\n', '            selfPayout();\n', '            return;\n', '        }\n', '\n', '        require(msg.value >= min_invest, "Too small amount, minimum 0.01 ether");\n', '\n', '        Member storage user = members[msg.sender];\n', '\n', '        if (user.id == 0) {\n', '            msg.sender.transfer(0 wei);\n', '            user.date = now;\n', '            user.id = addresses.length;\n', '            addresses.push(msg.sender);\n', '\n', '            address referrer = bytesToAddress(msg.data);\n', '\n', '            if (members[referrer].deposit > 0 && referrer != msg.sender) {\n', '                user.referrer = referrer;\n', '            }\n', '        } else {\n', '            selfPayout();\n', '        }\n', '\n', '        user.deposits += 1;\n', '        user.deposit += msg.value;\n', '\n', '        lastPaymentDate = now;\n', '        investedAmount += msg.value;\n', '\n', '        owner.transfer(msg.value / 5);\n', '\n', '        if (user.referrer > 0x0) {\n', '            uint bonusAmount = (msg.value / 100) * interest;\n', '            user.referrer.send(bonusAmount);\n', '\n', '            if (user.deposits == 1) {\n', '                msg.sender.send(bonusAmount);\n', '            }\n', '        }\n', '    }\n', '}']