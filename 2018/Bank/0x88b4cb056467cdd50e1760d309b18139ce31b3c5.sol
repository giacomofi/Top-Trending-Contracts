['// Welcome to Reserve Token.\n', '//\n', '\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', '\n', 'contract ReserveToken {\n', '\n', '    address public tank; //SBC - The tank of the contract\n', '    uint256 public tankAllowance = 0;\n', '    uint256 public tankOut = 0;\n', '    uint256 public valueOfContract = 0;\n', '    string public name;         //Name of the contract\n', '    string public symbol;       //Symbol of the contract\n', '    uint8 public decimals = 18;      //The amount of decimals\n', '\n', '    uint256 public totalSupply; //The current total supply.\n', '    uint256 public maxSupply = uint256(0) - 10; //We let the max amount be the most the variable can handle. well... basically.\n', '    uint256 public tankImposedMax = 100000000000000000000000; //SBC - 10 million maximum tokens at first\n', '    uint256 public priceOfToken;    //The current price of a token\n', '    uint256 public divForSellBack = 2; //SBC - The split for when a sell back occurs\n', '    uint256 public divForTank = 200; //SBC - 20=5%. 100=1% 1000=.1% The amount given to the Abby.\n', '    uint256 public divForPrice = 200; //SBC - The rate in which we grow. 2x this is our possible spread.\n', '    uint256 public divForTransfer = 2; //SBC - The rate in which we grow. 2x this is our possible spread.\n', '    uint256 public firstTTax = 10000; //SBC - The amount added to cost of transfer if firstTTaxAmount\n', '    uint256 public firstTTaxAmount = 10000; //SBC - The sender amount must be greater than this amount.\n', '    uint256 public secondTTax = 20000; //SBC -\n', '    uint256 public secondTTaxAmount = 20000; //SBC\n', '    uint256 public minTokens = 100;     //SBC  - minimum amount of tickets a person may mixssxnt at once\n', '    uint256 public maxTokens = 1000;    //SBC -max amount of tickets a person may mint at once\n', '    uint256 public coinprice; //This is calculated on the fly in the sellprice. This is the last buy price. not the current.\n', '\n', '    //Standard Token\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) public allowed;\n', '\n', '\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function ReserveToken() payable public {\n', '        name = "Reserve Token";\n', '        //Setting the name of the contract\n', '        symbol = "RSRV";\n', '        //Setting the symbol\n', '        tank = msg.sender;\n', '        //setting the tank\n', '        priceOfToken = 1 szabo;\n', '    }\n', '\n', '    function MintTokens() public payable {\n', '        //Just some requirements for BuyTokens -- The Tank needs no requirements. (Tank is still subjected to fees)\n', '        address inAddress = msg.sender;\n', '        uint256 inMsgValue = msg.value;\n', '\n', '        if (inAddress != tank) {\n', '            require(inMsgValue > 1000); //The minimum money supplied\n', '            require(inMsgValue > priceOfToken * minTokens); //The minimum amount of tokens you can buy\n', '            require(inMsgValue < priceOfToken * maxTokens); //The maximum amount of tokens.\n', '        }\n', '\n', '\n', '        //Add the incoming tank allowance to tankAllowance\n', '        tankAllowance += (inMsgValue / divForTank);\n', '        //add to the value of contact the incoming value - what the tank got.\n', '        valueOfContract += (inMsgValue - (inMsgValue / divForTank));\n', '        //new coins are equalal to teh new value of contract divided by the current price of token\n', '        uint256 newcoins = ((inMsgValue - (inMsgValue / divForTank)) * 1 ether) / (priceOfToken);\n', '\n', '\n', '\n', '         //Ensure that we dont go over the max the tank has set.\n', '        require(totalSupply + newcoins < maxSupply);\n', '        //Ensure that we don&#39;t go oever the maximum amount of coins.\n', '        require(totalSupply + newcoins < tankImposedMax);\n', '\n', '        \n', '\n', '        //Update use balance, total supply, price of token.\n', '        totalSupply += newcoins;\n', '        priceOfToken += valueOfContract / (totalSupply / 1 ether) / divForPrice;\n', '        balances[inAddress] += newcoins;\n', '    }\n', '\n', '    function BurnAllTokens() public {\n', '        address inAddress = msg.sender;\n', '        uint256 theirBalance = balances[inAddress];\n', '        //Get their balance without any crap code\n', '        require(theirBalance > 0);\n', '        //Make sure that they have enough money to cover this.\n', '        balances[inAddress] = 0;\n', '        //Remove the amount now, for re entry prevention\n', '        coinprice = valueOfContract / (totalSupply / 1 ether);\n', '        //Updating the coin price (buy back price)\n', '        uint256 amountGoingOut = coinprice * (theirBalance / 1 ether); //amount going out in etheruem\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '        //Amount going out minus theW\n', '        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\n', '        //Add the the tank allowance, here we are functionally making the coin worth more.\n', '        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\n', '        //Updating the new value of our contract. what we will have after the transfer\n', '        msg.sender.transfer(amountGoingOut);\n', '        //Transfer the money\n', '        totalSupply -= theirBalance;\n', '\n', '    }\n', '\n', '    function BurnTokens(uint256 _amount) public {\n', '        address inAddress = msg.sender;\n', '        uint256 theirBalance = balances[inAddress];\n', '        //Get their balance without any crap code\n', '        require(_amount <= theirBalance);\n', '        //Make sure that they have enough money to cover this.\n', '        balances[inAddress] -= _amount;\n', '        //Remove the amount now, for re entry prevention\n', '        coinprice = valueOfContract / (totalSupply / 1 ether);\n', '        //Updating the coin price (buy back price)\n', '        uint256 amountGoingOut = coinprice * (_amount / 1 ether); //amount going out in etheruem\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '        //Amount going out minus theW\n', '        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\n', '        //Add the the tank allowance, here we are functionally making the coin worth more.\n', '        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\n', '        //Updating the new value of our contract. what we will have after the transfer\n', '        msg.sender.transfer(amountGoingOut);\n', '        //Transfer the money\n', '        totalSupply -= _amount;\n', '\n', '    }\n', '\n', '    function CurrentCoinPrice() view public returns (uint256) {\n', '        uint256 amountGoingOut = valueOfContract / (totalSupply / 1 ether);\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        return amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '    }\n', '\n', '\n', '    function TankWithdrawSome(uint256 _amount) public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        //Require person to be the tank\n', '\n', '        //if our allowance is greater than the value of the contract then the contract must be empty.\n', '        if (tankAllowance < valueOfContract) {\n', '            require(_amount <= tankAllowance - tankOut);\n', '        }\n', '\n', '        //Require the amount to be less than the amount for tank0.\n', '\n', '        tankOut += _amount;\n', '        //Adding in new tank withdraw.\n', '        tank.transfer(_amount);\n', '        //transfering amount to tank&#39;s balance.\n', '    }\n', '\n', '    //This is an ethereum withdraw for the tank.\n', '    function TankWithdrawAll() public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        //Require person to be the tank\n', '\n', '        //if our allowance is greater than the value of the contract then the contract must be empty.\n', '        if (tankAllowance < valueOfContract) {\n', '            require(tankAllowance - tankOut > 0); //Tank allowance - tankout = whats left for tank. and it must be over zero\n', '        }\n', '\n', '        //Require the amount to be less than the amount for tank0.\n', '\n', '        tankOut += tankAllowance - tankOut; //We give whats left to our tankout makeing whats left zero. so tank cant double withdraw.\n', '        //Adding in new tank withdraw.\n', '        tank.transfer(tankAllowance - tankOut);\n', '        //transfering amount to tank&#39;s balance.\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '    function TankDeposit() payable public {\n', '        address inAddress = msg.sender;\n', '        uint256 inValue = msg.value;\n', '\n', '        require(inAddress == tank);\n', '        //require the person to be a the tank\n', '\n', '        if (inValue < tankOut) {\n', '            tankOut -= inValue;\n', '            // We cant underflow here because it has to be less.\n', '        }\n', '        else\n', '        {\n', '            //Add the excess to the contract value\n', '            valueOfContract += (inValue - tankOut) * 1 ether;\n', '            //We DO NOT INCREASE ALLOWANCE, we only allow the tank to go to zero.\n', '            tankOut = 0;\n', '\n', '        }\n', '    }\n', '\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFee(uint256 _amount) view internal returns (uint256){\n', '        //If Amount is above the tax amount return the tax\n', '        if (_amount > secondTTaxAmount)\n', '            return secondTTax;\n', '\n', '        if (_amount > firstTTaxAmount)\n', '            return firstTTax;\n', '    }\n', '\n', '    // Transfer the balance from tank&#39;s account to another account\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '        //variables we are working with.\n', '        uint256 fromBalance = balances[msg.sender];\n', '        uint256 toBalance = balances[_to];\n', '        uint256 tFee = transferFee(_amount);\n', '\n', '\n', '        //Require the balance be greater than the amount + fee\n', '        require(fromBalance >= _amount + tFee);\n', '        //Require the amount ot be greater than 0.\n', '        require(_amount > 0);\n', '        //Require the toBalance to be greater than the current amount. w\n', '        require(toBalance + _amount > toBalance);\n', '\n', '        balances[msg.sender] -= _amount + tFee;\n', '        balances[_to] += _amount;\n', '        balances[tank] += tFee / divForTransfer;\n', '        totalSupply -= tFee - (tFee / divForTransfer);\n', '\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        //Create Event\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        uint256 fromBalance = balances[_from];  //The current balance of from\n', '        uint256 toBalance = balances[_to];      //The current blance for to\n', '        uint256 tFee = transferFee(_amount);    //The transaction fee that will be accociated with this transaction\n', '\n', '        //Require the from balance to have more than the amount they want to send + the current fee\n', '        require(fromBalance >= _amount + tFee);\n', '        //Require the allowed balance to be greater than that amount as well.\n', '        require(allowed[_from][msg.sender] >= _amount + tFee);\n', '        //Require the current amount to be greater than 0.\n', '        require(_amount > 0);\n', '        //Require the to balance to gain an amount. protect against under and over flows\n', '        require(toBalance + _amount > toBalance);\n', '\n', '        //Update from balance, allowed balance, to balance, tank balance, total supply. create Transfer event.\n', '        balances[_from] -= _amount + tFee;\n', '        allowed[_from][msg.sender] -= _amount + tFee;\n', '        balances[_to] += _amount;\n', '        balances[tank] += tFee / divForTransfer;\n', '        totalSupply -= tFee - (tFee / divForTransfer);\n', '        emit Transfer(_from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '     function GrabUnallocatedValue() public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         //Sometimes someone sends money straight to the contract but that isn&#39;t recorded in the value of teh contract.\n', '         //So here we allow tank to withdraw those extra funds\n', '         address walletaddress = this;\n', '         if (walletaddress.balance * 1 ether > valueOfContract) {\n', '            tank.transfer(walletaddress.balance - (valueOfContract / 1 ether));\n', '         }\n', '    }\n', '\n', '\n', '    function TankTransfer(address _NewTank) public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        tank = _NewTank;\n', '    }\n', '\n', '    function SettankImposedMax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         tankImposedMax = _input;\n', '    }\n', '\n', '    function SetdivForSellBack(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForSellBack = _input;\n', '    }\n', '\n', '    function SetdivForTank(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForTank = _input;\n', '    }\n', '\n', '    function SetdivForPrice(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForPrice = _input;\n', '    }\n', '\n', '    function SetfirstTTax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         firstTTax = _input;\n', '    }\n', '\n', '    function SetfirstTTaxAmount(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         firstTTaxAmount = _input;\n', '    }\n', '\n', '    function SetsecondTTax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         secondTTax = _input;\n', '    }\n', '\n', '    function SetsecondTTaxAmount(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         secondTTaxAmount = _input;\n', '    }\n', '\n', '    function SetminTokens(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         minTokens = _input;\n', '    }\n', '\n', '    function SetmaxTokens(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         maxTokens = _input;\n', '    }\n', '\n', '    function SetdivForTransfer(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForTransfer = _input;\n', '    }\n', '\n', '\n', '\n', '}']
['// Welcome to Reserve Token.\n', '//\n', '\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', '\n', 'contract ReserveToken {\n', '\n', '    address public tank; //SBC - The tank of the contract\n', '    uint256 public tankAllowance = 0;\n', '    uint256 public tankOut = 0;\n', '    uint256 public valueOfContract = 0;\n', '    string public name;         //Name of the contract\n', '    string public symbol;       //Symbol of the contract\n', '    uint8 public decimals = 18;      //The amount of decimals\n', '\n', '    uint256 public totalSupply; //The current total supply.\n', '    uint256 public maxSupply = uint256(0) - 10; //We let the max amount be the most the variable can handle. well... basically.\n', '    uint256 public tankImposedMax = 100000000000000000000000; //SBC - 10 million maximum tokens at first\n', '    uint256 public priceOfToken;    //The current price of a token\n', '    uint256 public divForSellBack = 2; //SBC - The split for when a sell back occurs\n', '    uint256 public divForTank = 200; //SBC - 20=5%. 100=1% 1000=.1% The amount given to the Abby.\n', '    uint256 public divForPrice = 200; //SBC - The rate in which we grow. 2x this is our possible spread.\n', '    uint256 public divForTransfer = 2; //SBC - The rate in which we grow. 2x this is our possible spread.\n', '    uint256 public firstTTax = 10000; //SBC - The amount added to cost of transfer if firstTTaxAmount\n', '    uint256 public firstTTaxAmount = 10000; //SBC - The sender amount must be greater than this amount.\n', '    uint256 public secondTTax = 20000; //SBC -\n', '    uint256 public secondTTaxAmount = 20000; //SBC\n', '    uint256 public minTokens = 100;     //SBC  - minimum amount of tickets a person may mixssxnt at once\n', '    uint256 public maxTokens = 1000;    //SBC -max amount of tickets a person may mint at once\n', '    uint256 public coinprice; //This is calculated on the fly in the sellprice. This is the last buy price. not the current.\n', '\n', '    //Standard Token\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) public allowed;\n', '\n', '\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function ReserveToken() payable public {\n', '        name = "Reserve Token";\n', '        //Setting the name of the contract\n', '        symbol = "RSRV";\n', '        //Setting the symbol\n', '        tank = msg.sender;\n', '        //setting the tank\n', '        priceOfToken = 1 szabo;\n', '    }\n', '\n', '    function MintTokens() public payable {\n', '        //Just some requirements for BuyTokens -- The Tank needs no requirements. (Tank is still subjected to fees)\n', '        address inAddress = msg.sender;\n', '        uint256 inMsgValue = msg.value;\n', '\n', '        if (inAddress != tank) {\n', '            require(inMsgValue > 1000); //The minimum money supplied\n', '            require(inMsgValue > priceOfToken * minTokens); //The minimum amount of tokens you can buy\n', '            require(inMsgValue < priceOfToken * maxTokens); //The maximum amount of tokens.\n', '        }\n', '\n', '\n', '        //Add the incoming tank allowance to tankAllowance\n', '        tankAllowance += (inMsgValue / divForTank);\n', '        //add to the value of contact the incoming value - what the tank got.\n', '        valueOfContract += (inMsgValue - (inMsgValue / divForTank));\n', '        //new coins are equalal to teh new value of contract divided by the current price of token\n', '        uint256 newcoins = ((inMsgValue - (inMsgValue / divForTank)) * 1 ether) / (priceOfToken);\n', '\n', '\n', '\n', '         //Ensure that we dont go over the max the tank has set.\n', '        require(totalSupply + newcoins < maxSupply);\n', "        //Ensure that we don't go oever the maximum amount of coins.\n", '        require(totalSupply + newcoins < tankImposedMax);\n', '\n', '        \n', '\n', '        //Update use balance, total supply, price of token.\n', '        totalSupply += newcoins;\n', '        priceOfToken += valueOfContract / (totalSupply / 1 ether) / divForPrice;\n', '        balances[inAddress] += newcoins;\n', '    }\n', '\n', '    function BurnAllTokens() public {\n', '        address inAddress = msg.sender;\n', '        uint256 theirBalance = balances[inAddress];\n', '        //Get their balance without any crap code\n', '        require(theirBalance > 0);\n', '        //Make sure that they have enough money to cover this.\n', '        balances[inAddress] = 0;\n', '        //Remove the amount now, for re entry prevention\n', '        coinprice = valueOfContract / (totalSupply / 1 ether);\n', '        //Updating the coin price (buy back price)\n', '        uint256 amountGoingOut = coinprice * (theirBalance / 1 ether); //amount going out in etheruem\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '        //Amount going out minus theW\n', '        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\n', '        //Add the the tank allowance, here we are functionally making the coin worth more.\n', '        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\n', '        //Updating the new value of our contract. what we will have after the transfer\n', '        msg.sender.transfer(amountGoingOut);\n', '        //Transfer the money\n', '        totalSupply -= theirBalance;\n', '\n', '    }\n', '\n', '    function BurnTokens(uint256 _amount) public {\n', '        address inAddress = msg.sender;\n', '        uint256 theirBalance = balances[inAddress];\n', '        //Get their balance without any crap code\n', '        require(_amount <= theirBalance);\n', '        //Make sure that they have enough money to cover this.\n', '        balances[inAddress] -= _amount;\n', '        //Remove the amount now, for re entry prevention\n', '        coinprice = valueOfContract / (totalSupply / 1 ether);\n', '        //Updating the coin price (buy back price)\n', '        uint256 amountGoingOut = coinprice * (_amount / 1 ether); //amount going out in etheruem\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '        //Amount going out minus theW\n', '        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\n', '        //Add the the tank allowance, here we are functionally making the coin worth more.\n', '        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\n', '        //Updating the new value of our contract. what we will have after the transfer\n', '        msg.sender.transfer(amountGoingOut);\n', '        //Transfer the money\n', '        totalSupply -= _amount;\n', '\n', '    }\n', '\n', '    function CurrentCoinPrice() view public returns (uint256) {\n', '        uint256 amountGoingOut = valueOfContract / (totalSupply / 1 ether);\n', '        //We convert amount going out to amount without divforTank\n', '        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\n', '        return amountGoingOut - tankAmount; //the new amount for our going out without the tank\n', '    }\n', '\n', '\n', '    function TankWithdrawSome(uint256 _amount) public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        //Require person to be the tank\n', '\n', '        //if our allowance is greater than the value of the contract then the contract must be empty.\n', '        if (tankAllowance < valueOfContract) {\n', '            require(_amount <= tankAllowance - tankOut);\n', '        }\n', '\n', '        //Require the amount to be less than the amount for tank0.\n', '\n', '        tankOut += _amount;\n', '        //Adding in new tank withdraw.\n', '        tank.transfer(_amount);\n', "        //transfering amount to tank's balance.\n", '    }\n', '\n', '    //This is an ethereum withdraw for the tank.\n', '    function TankWithdrawAll() public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        //Require person to be the tank\n', '\n', '        //if our allowance is greater than the value of the contract then the contract must be empty.\n', '        if (tankAllowance < valueOfContract) {\n', '            require(tankAllowance - tankOut > 0); //Tank allowance - tankout = whats left for tank. and it must be over zero\n', '        }\n', '\n', '        //Require the amount to be less than the amount for tank0.\n', '\n', '        tankOut += tankAllowance - tankOut; //We give whats left to our tankout makeing whats left zero. so tank cant double withdraw.\n', '        //Adding in new tank withdraw.\n', '        tank.transfer(tankAllowance - tankOut);\n', "        //transfering amount to tank's balance.\n", '    }\n', '\n', '\n', '\n', '\n', '\n', '    function TankDeposit() payable public {\n', '        address inAddress = msg.sender;\n', '        uint256 inValue = msg.value;\n', '\n', '        require(inAddress == tank);\n', '        //require the person to be a the tank\n', '\n', '        if (inValue < tankOut) {\n', '            tankOut -= inValue;\n', '            // We cant underflow here because it has to be less.\n', '        }\n', '        else\n', '        {\n', '            //Add the excess to the contract value\n', '            valueOfContract += (inValue - tankOut) * 1 ether;\n', '            //We DO NOT INCREASE ALLOWANCE, we only allow the tank to go to zero.\n', '            tankOut = 0;\n', '\n', '        }\n', '    }\n', '\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFee(uint256 _amount) view internal returns (uint256){\n', '        //If Amount is above the tax amount return the tax\n', '        if (_amount > secondTTaxAmount)\n', '            return secondTTax;\n', '\n', '        if (_amount > firstTTaxAmount)\n', '            return firstTTax;\n', '    }\n', '\n', "    // Transfer the balance from tank's account to another account\n", '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '        //variables we are working with.\n', '        uint256 fromBalance = balances[msg.sender];\n', '        uint256 toBalance = balances[_to];\n', '        uint256 tFee = transferFee(_amount);\n', '\n', '\n', '        //Require the balance be greater than the amount + fee\n', '        require(fromBalance >= _amount + tFee);\n', '        //Require the amount ot be greater than 0.\n', '        require(_amount > 0);\n', '        //Require the toBalance to be greater than the current amount. w\n', '        require(toBalance + _amount > toBalance);\n', '\n', '        balances[msg.sender] -= _amount + tFee;\n', '        balances[_to] += _amount;\n', '        balances[tank] += tFee / divForTransfer;\n', '        totalSupply -= tFee - (tFee / divForTransfer);\n', '\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        //Create Event\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        uint256 fromBalance = balances[_from];  //The current balance of from\n', '        uint256 toBalance = balances[_to];      //The current blance for to\n', '        uint256 tFee = transferFee(_amount);    //The transaction fee that will be accociated with this transaction\n', '\n', '        //Require the from balance to have more than the amount they want to send + the current fee\n', '        require(fromBalance >= _amount + tFee);\n', '        //Require the allowed balance to be greater than that amount as well.\n', '        require(allowed[_from][msg.sender] >= _amount + tFee);\n', '        //Require the current amount to be greater than 0.\n', '        require(_amount > 0);\n', '        //Require the to balance to gain an amount. protect against under and over flows\n', '        require(toBalance + _amount > toBalance);\n', '\n', '        //Update from balance, allowed balance, to balance, tank balance, total supply. create Transfer event.\n', '        balances[_from] -= _amount + tFee;\n', '        allowed[_from][msg.sender] -= _amount + tFee;\n', '        balances[_to] += _amount;\n', '        balances[tank] += tFee / divForTransfer;\n', '        totalSupply -= tFee - (tFee / divForTransfer);\n', '        emit Transfer(_from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '     function GrabUnallocatedValue() public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', "         //Sometimes someone sends money straight to the contract but that isn't recorded in the value of teh contract.\n", '         //So here we allow tank to withdraw those extra funds\n', '         address walletaddress = this;\n', '         if (walletaddress.balance * 1 ether > valueOfContract) {\n', '            tank.transfer(walletaddress.balance - (valueOfContract / 1 ether));\n', '         }\n', '    }\n', '\n', '\n', '    function TankTransfer(address _NewTank) public {\n', '        address inAddress = msg.sender;\n', '        require(inAddress == tank);\n', '        tank = _NewTank;\n', '    }\n', '\n', '    function SettankImposedMax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         tankImposedMax = _input;\n', '    }\n', '\n', '    function SetdivForSellBack(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForSellBack = _input;\n', '    }\n', '\n', '    function SetdivForTank(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForTank = _input;\n', '    }\n', '\n', '    function SetdivForPrice(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForPrice = _input;\n', '    }\n', '\n', '    function SetfirstTTax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         firstTTax = _input;\n', '    }\n', '\n', '    function SetfirstTTaxAmount(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         firstTTaxAmount = _input;\n', '    }\n', '\n', '    function SetsecondTTax(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         secondTTax = _input;\n', '    }\n', '\n', '    function SetsecondTTaxAmount(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         secondTTaxAmount = _input;\n', '    }\n', '\n', '    function SetminTokens(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         minTokens = _input;\n', '    }\n', '\n', '    function SetmaxTokens(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         maxTokens = _input;\n', '    }\n', '\n', '    function SetdivForTransfer(uint256 _input) public {\n', '         address inAddress = msg.sender;\n', '         require(inAddress == tank);\n', '         divForTransfer = _input;\n', '    }\n', '\n', '\n', '\n', '}']
