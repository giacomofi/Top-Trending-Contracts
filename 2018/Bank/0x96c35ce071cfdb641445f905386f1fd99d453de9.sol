['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SplitPayment\n', ' * @dev Base contract that supports multiple payees claiming funds sent to this contract\n', ' * according to the proportion they own.\n', ' */\n', 'contract SplitPayment {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalShares = 0;\n', '  uint256 public totalReleased = 0;\n', '\n', '  mapping(address => uint256) public shares;\n', '  mapping(address => uint256) public released;\n', '  address[] public payees;\n', '\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  constructor(address[] _payees, uint256[] _shares) public payable {\n', '    require(_payees.length == _shares.length);\n', '\n', '    for (uint256 i = 0; i < _payees.length; i++) {\n', '      addPayee(_payees[i], _shares[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev payable fallback\n', '   */\n', '  function () public payable {}\n', '\n', '  /**\n', '   * @dev Claim your share of the balance.\n', '   */\n', '  function claim() public {\n', '    address payee = msg.sender;\n', '\n', '    require(shares[payee] > 0);\n', '\n', '    uint256 totalReceived = address(this).balance.add(totalReleased);\n', '    uint256 payment = totalReceived.mul(shares[payee]).div(totalShares).sub(released[payee]);\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    released[payee] = released[payee].add(payment);\n', '    totalReleased = totalReleased.add(payment);\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '   * @dev Check your share of the balance.\n', '   */\n', '  function checkMyBalance() public view returns(uint256) {\n', '    uint256 totalReceived = address(this).balance.add(totalReleased);\n', '    uint256 payment = totalReceived.mul(shares[msg.sender]).div(totalShares).sub(released[msg.sender]);\n', '\n', '    return payment;\n', '  }\n', '\n', '  /**\n', '   * @dev Add a new payee to the contract.\n', '   * @param _payee The address of the payee to add.\n', '   * @param _shares The number of shares owned by the payee.\n', '   */\n', '  function addPayee(address _payee, uint256 _shares) internal {\n', '    require(_payee != address(0));\n', '    require(_shares > 0);\n', '    require(shares[_payee] == 0);\n', '\n', '    payees.push(_payee);\n', '    shares[_payee] = _shares;\n', '    totalShares = totalShares.add(_shares);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SplitPayment\n', ' * @dev Base contract that supports multiple payees claiming funds sent to this contract\n', ' * according to the proportion they own.\n', ' */\n', 'contract SplitPayment {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalShares = 0;\n', '  uint256 public totalReleased = 0;\n', '\n', '  mapping(address => uint256) public shares;\n', '  mapping(address => uint256) public released;\n', '  address[] public payees;\n', '\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  constructor(address[] _payees, uint256[] _shares) public payable {\n', '    require(_payees.length == _shares.length);\n', '\n', '    for (uint256 i = 0; i < _payees.length; i++) {\n', '      addPayee(_payees[i], _shares[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev payable fallback\n', '   */\n', '  function () public payable {}\n', '\n', '  /**\n', '   * @dev Claim your share of the balance.\n', '   */\n', '  function claim() public {\n', '    address payee = msg.sender;\n', '\n', '    require(shares[payee] > 0);\n', '\n', '    uint256 totalReceived = address(this).balance.add(totalReleased);\n', '    uint256 payment = totalReceived.mul(shares[payee]).div(totalShares).sub(released[payee]);\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    released[payee] = released[payee].add(payment);\n', '    totalReleased = totalReleased.add(payment);\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '   * @dev Check your share of the balance.\n', '   */\n', '  function checkMyBalance() public view returns(uint256) {\n', '    uint256 totalReceived = address(this).balance.add(totalReleased);\n', '    uint256 payment = totalReceived.mul(shares[msg.sender]).div(totalShares).sub(released[msg.sender]);\n', '\n', '    return payment;\n', '  }\n', '\n', '  /**\n', '   * @dev Add a new payee to the contract.\n', '   * @param _payee The address of the payee to add.\n', '   * @param _shares The number of shares owned by the payee.\n', '   */\n', '  function addPayee(address _payee, uint256 _shares) internal {\n', '    require(_payee != address(0));\n', '    require(_shares > 0);\n', '    require(shares[_payee] == 0);\n', '\n', '    payees.push(_payee);\n', '    shares[_payee] = _shares;\n', '    totalShares = totalShares.add(_shares);\n', '  }\n', '}']
