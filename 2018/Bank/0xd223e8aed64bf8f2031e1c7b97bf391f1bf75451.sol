['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '  ____      _   _ _   _               _       \n', ' |  _ \\ ___| |_(_) |_(_) ___  _ __   (_) ___  \n', ' | |_) / _ \\ __| | __| |/ _ \\| &#39;_ \\  | |/ _ \\ \n', ' |  __/  __/ |_| | |_| | (_) | | | |_| | (_) |\n', ' |_|   \\___|\\__|_|\\__|_|\\___/|_| |_(_)_|\\___/ \n', '\n', '*/\n', '\n', 'contract PetitionFactory is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    event NewPetition(uint petitionId, string name, string message, address creator, uint signaturesNeeded, bool featured, uint featuredExpires, uint totalSignatures, uint created, string connectingHash, uint advertisingBudget);\n', '    event NewPetitionSigner(uint petitionSignerId, uint petitionId, address petitionSignerAddress, uint signed);\n', '    event NewPetitionShareholder(uint PetitionShareholderId, address PetitionShareholderAddress, uint shares, uint sharesListedForSale, uint lastDividend);\n', '    event DividendClaim(uint divId, uint PetitionShareholderId, uint amt, uint time, address userAddress);\n', '    event NewShareholderListing(uint shareholderListingId, uint petitionShareholderId, uint sharesForSale, uint price, bool sold);\n', '\n', '    struct Petition {\n', '        string name;\n', '        string message;\n', '        address creator;\n', '        uint signaturesNeeded;\n', '        bool featured;\n', '        uint featuredExpires;\n', '        uint totalSignatures;\n', '        uint created;\n', '        string connectingHash;\n', '        uint advertisingBudget; // an easy way for people to donate to the petition cause. We will use this budget for CPC, CPM text and banner ads around petition.io\n', '    }\n', '\n', '    struct PetitionSigner {\n', '        uint petitionId;\n', '        address petitionSignerAddress;\n', '        uint signed;\n', '    }\n', '\n', '    struct PetitionShareholder {\n', '        address PetitionShareholderAddress;\n', '        uint shares;\n', '        uint sharesListedForSale; // prevent being able to double list shares for sale\n', '        uint lastDividend;\n', '    }\n', '\n', '    struct DividendHistory {\n', '        uint PetitionShareholderId;\n', '        uint amt;\n', '        uint time;\n', '        address userAddress;\n', '    }\n', '\n', '    struct ShareholderListing {\n', '        uint petitionShareholderId;\n', '        uint sharesForSale;\n', '        uint price;\n', '        bool sold;\n', '    }\n', '\n', '    Petition[] public petitions;\n', '\n', '    PetitionSigner[] public petitionsigners;\n', '    mapping(address => mapping(uint => uint)) ownerPetitionSignerArrayCreated;\n', '    mapping(address => mapping(uint => uint)) petitionSignerMap;\n', '\n', '    PetitionShareholder[] public PetitionShareholders;\n', '    mapping(address => uint) ownerPetitionShareholderArrayCreated;\n', '    mapping(address => uint) PetitionShareholderMap;\n', '\n', '    DividendHistory[] public divs;\n', '\n', '    ShareholderListing[] public listings;\n', '\n', '    uint createPetitionFee = 1000000000000000; // 0.001 ETH\n', '    uint featurePetitionFee = 100000000000000000; // 0.1 ETH\n', '    uint featuredLength = 604800; // 1 week\n', '\n', '    /********************************* */\n', '    // shareholder details\n', '\n', '    //uint petitionIoShares = 1000000; // 1,000,000 (20%) of shares given to Petition.io Inc. This is needed so Petition.io Inc can collect 20% of the fees to keep the lights on and continually improve the platform\n', '\n', '    uint sharesSold = 0;\n', '\n', '    uint maxShares = 5000000; // 5,000,000 shares exist\n', '\n', '    // initial price per share from Petition.io (until all shares are sold). But can also be listed and sold p2p on our marketplace at the price set by shareholder\n', '    uint initialPricePerShare  = 5000000000000000; // 0.005 ETH -> \n', '        // notice of bonuses: \n', '        // 10 ETH + get a 10% bonus\n', '        // 50 ETH + get a 20% bonus \n', '        // 100 ETH + get a 30% bonus\n', '        // 500 ETH + get a 40% bonus\n', '        // 1000 ETH + get a 50% bonus\n', '    \n', '    uint initialOwnerSharesClaimed = 0; // owner can only claim their 1,000,000 shares once\n', '    address ownerShareAddress;\n', '\n', '    uint dividendCooldown = 604800; // 1 week\n', '\n', '    uint peerToPeerMarketplaceTransactionFee = 100; // 1% (1 / 100 = 0.01, 2 / 100 = 0.02, etc)\n', '\n', '    uint dividendPoolStarts = 0;\n', '    uint dividendPoolEnds = 0;\n', '    uint claimableDividendPool = 0; // (from the last dividendCooldown time pool)\n', '    uint claimedThisPool = 0;\n', '    uint currentDividendPool = 0; // (from this dividendCooldown pool)\n', '\n', '    uint availableForWithdraw = 0;\n', '\n', '    /********************************* */\n', '    // shareholder functions\n', '\n', '    function invest() payable public {\n', '        require(sharesSold < maxShares);\n', '        // calc how many shares\n', '        uint numberOfShares = SafeMath.div(msg.value, initialPricePerShare); // example is 1 ETH (1000000000000000000) / 0.01 ETH (10000000000000000) = 100 shares\n', '\n', '        // calc bonus\n', '        uint numberOfSharesBonus;\n', '        uint numberOfSharesBonusOne;\n', '        uint numberOfSharesBonusTwo;\n', '        if (msg.value >= 1000000000000000000000) { // 1000 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 2); // 50%\n', '            numberOfShares = SafeMath.add(numberOfShares, numberOfSharesBonus);\n', '\n', '        } else if (msg.value >= 500000000000000000000) { // 500 ETH\n', '            numberOfSharesBonusOne = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfSharesBonusTwo = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfShares = numberOfShares + numberOfSharesBonusOne + numberOfSharesBonusTwo; // 40%\n', '\n', '        } else if (msg.value >= 100000000000000000000) { // 100 ETH\n', '            numberOfSharesBonusOne = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfSharesBonusTwo = SafeMath.div(numberOfShares, 10); // 10%\n', '            numberOfShares = numberOfShares + numberOfSharesBonusOne + numberOfSharesBonusTwo; // 30%\n', '        \n', '        } else if (msg.value >= 50000000000000000000) { // 50 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfShares = numberOfShares + numberOfSharesBonus; // 20%\n', '\n', '        } else if (msg.value >= 10000000000000000000) { // 10 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 10); // 10%\n', '            numberOfShares = numberOfShares + numberOfSharesBonus; // 10%\n', '        \n', '        }\n', '\n', '        require((numberOfShares + sharesSold) < maxShares);\n', '\n', '        if (ownerPetitionShareholderArrayCreated[msg.sender] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, numberOfShares, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, msg.sender, numberOfShares, 0, now);\n', '            PetitionShareholderMap[msg.sender] = id;\n', '            ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '            \n', '            sharesSold = sharesSold + numberOfShares;\n', '\n', '            availableForWithdraw = availableForWithdraw + msg.value;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares + numberOfShares;\n', '            \n', '            sharesSold = sharesSold + numberOfShares;\n', '\n', '            availableForWithdraw = availableForWithdraw + msg.value;\n', '\n', '        }\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    function viewSharesSold() public view returns(uint) {\n', '        return sharesSold;\n', '    }\n', '\n', '    function viewMaxShares() public view returns(uint) {\n', '        return maxShares;\n', '    }\n', '\n', '    function viewPetitionShareholderWithAddress(address _investorAddress) view public returns (uint, address, uint, uint) {\n', '        require (ownerPetitionShareholderArrayCreated[_investorAddress] > 0);\n', '\n', '        PetitionShareholder storage investors = PetitionShareholders[PetitionShareholderMap[_investorAddress]];\n', '        return (PetitionShareholderMap[_investorAddress], investors.PetitionShareholderAddress, investors.shares, investors.lastDividend);\n', '    }\n', '\n', '    function viewPetitionShareholder(uint _PetitionShareholderId) view public returns (uint, address, uint, uint) {\n', '        PetitionShareholder storage investors = PetitionShareholders[_PetitionShareholderId];\n', '        return (_PetitionShareholderId, investors.PetitionShareholderAddress, investors.shares, investors.lastDividend);\n', '    }\n', '\n', '    /********************************* */\n', '    // dividend functions\n', '\n', '    function endDividendPool() public {\n', '        // we do if instead of require so we can call it throughout the smart contract. This way if someone signs, creates a petition, etc. It can ding to the next dividend pool.\n', '        if (now > dividendPoolEnds) {\n', '\n', '            // unclaimed dividends go to admin available\n', '            availableForWithdraw = availableForWithdraw + (claimableDividendPool - claimedThisPool);\n', '\n', '            // current div pool to claimable div pool\n', '            claimableDividendPool = currentDividendPool;\n', '            claimedThisPool = 0;\n', '\n', '            // reset current div pool\n', '            currentDividendPool = 0;\n', '\n', '            // start new pool period\n', '            dividendPoolStarts = now;\n', '            dividendPoolEnds = (now + dividendCooldown);\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function collectDividend() payable public {\n', '        require (ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require ((PetitionShareholders[PetitionShareholderMap[msg.sender]].lastDividend + dividendCooldown) < now);\n', '        require (claimableDividendPool > 0);\n', '\n', '        // calc amount\n', '        uint divAmt = claimableDividendPool / (sharesSold / PetitionShareholders[PetitionShareholderMap[msg.sender]].shares);\n', '\n', '        claimedThisPool = claimedThisPool + divAmt;\n', '\n', '        //\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].lastDividend = now;\n', '\n', '        // the actual ETH transfer\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress.transfer(divAmt);\n', '\n', '        uint id = divs.push(DividendHistory(PetitionShareholderMap[msg.sender], divAmt, now, PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress)) - 1;\n', '        emit DividendClaim(id, PetitionShareholderMap[msg.sender], divAmt, now, PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress);\n', '    }\n', '\n', '    function viewInvestorDividendHistory(uint _divId) public view returns(uint, uint, uint, uint, address) {\n', '        return(_divId, divs[_divId].PetitionShareholderId, divs[_divId].amt, divs[_divId].time, divs[_divId].userAddress);\n', '    }\n', '\n', '    function viewInvestorDividendPool() public view returns(uint) {\n', '        return currentDividendPool;\n', '    }\n', '\n', '    function viewClaimableInvestorDividendPool() public view returns(uint) {\n', '        return claimableDividendPool;\n', '    }\n', '\n', '    function viewClaimedThisPool() public view returns(uint) {\n', '        return claimedThisPool;\n', '    }\n', '\n', '    function viewLastClaimedDividend(address _address) public view returns(uint) {\n', '        return PetitionShareholders[PetitionShareholderMap[_address]].lastDividend;\n', '    }\n', '\n', '    function ViewDividendPoolEnds() public view returns(uint) {\n', '        return dividendPoolEnds;\n', '    }\n', '\n', '    function viewDividendCooldown() public view returns(uint) {\n', '        return dividendCooldown;\n', '    }\n', '\n', '\n', '    // transfer shares\n', '    function transferShares(uint _amount, address _to) public {\n', '        require(ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require((PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale) >= _amount);\n', '\n', '        // give to receiver\n', '        if (ownerPetitionShareholderArrayCreated[_to] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(_to, _amount, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, _to, _amount, 0, now);\n', '            PetitionShareholderMap[_to] = id;\n', '            ownerPetitionShareholderArrayCreated[_to] = 1;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[_to]].shares = PetitionShareholders[PetitionShareholderMap[_to]].shares + _amount;\n', '\n', '        }\n', '\n', '        // take from sender\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - _amount;\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale = PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale - _amount;\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    // p2p share listing, selling and buying\n', '    function listSharesForSale(uint _amount, uint _price) public {\n', '        require(ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require((PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale) >= _amount);\n', '        \n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale = PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale + _amount;\n', '\n', '        uint id = listings.push(ShareholderListing(PetitionShareholderMap[msg.sender], _amount, _price, false)) - 1;\n', '        emit NewShareholderListing(id, PetitionShareholderMap[msg.sender], _amount, _price, false);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '        \n', '    }\n', '\n', '    function viewShareholderListing(uint _shareholderListingId)view public returns (uint, uint, uint, uint, bool) {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        return (_shareholderListingId, listing.petitionShareholderId, listing.sharesForSale, listing.price, listing.sold);\n', '    }\n', '\n', '    function removeShareholderListing(uint _shareholderListingId) public {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        require(PetitionShareholderMap[msg.sender] == listing.petitionShareholderId);\n', '\n', '        PetitionShareholders[listing.petitionShareholderId].sharesListedForSale = PetitionShareholders[listing.petitionShareholderId].sharesListedForSale - listing.sharesForSale;\n', '\n', '        delete listings[_shareholderListingId];\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '        \n', '    }\n', '\n', '    function buySharesFromListing(uint _shareholderListingId) payable public {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        require(msg.value >= listing.price);\n', '        require(listing.sold == false);\n', '        require(listing.sharesForSale > 0);\n', '        \n', '        // give to buyer\n', '        if (ownerPetitionShareholderArrayCreated[msg.sender] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, listing.sharesForSale, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, msg.sender, listing.sharesForSale, 0, now);\n', '            PetitionShareholderMap[msg.sender] = id;\n', '            ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares + listing.sharesForSale;\n', '\n', '        }\n', '\n', '        listing.sold = true;\n', '\n', '        // take from seller\n', '        PetitionShareholders[listing.petitionShareholderId].shares = PetitionShareholders[listing.petitionShareholderId].shares - listing.sharesForSale;\n', '        PetitionShareholders[listing.petitionShareholderId].sharesListedForSale = PetitionShareholders[listing.petitionShareholderId].sharesListedForSale - listing.sharesForSale;\n', '\n', '        // 1% fee\n', '        uint calcFee = SafeMath.div(msg.value, peerToPeerMarketplaceTransactionFee);\n', '        cutToInvestorsDividendPool(calcFee);\n', '\n', '        // transfer funds to seller\n', '        uint toSeller = SafeMath.sub(msg.value, calcFee);\n', '        PetitionShareholders[listing.petitionShareholderId].PetitionShareholderAddress.transfer(toSeller);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // petition functions\n', '\n', '    function createPetition(string _name, string _message, uint _signaturesNeeded, bool _featured, string _connectingHash) payable public {\n', '        require(msg.value >= createPetitionFee);\n', '        uint featuredExpires = 0;\n', '        uint totalPaid = createPetitionFee;\n', '        if (_featured) {\n', '            require(msg.value >= (createPetitionFee + featurePetitionFee));\n', '            featuredExpires = now + featuredLength;\n', '            totalPaid = totalPaid + featurePetitionFee;\n', '        }\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool:\n', '        cutToInvestorsDividendPool(totalPaid);\n', '\n', '        //////////\n', '\n', '        uint id = petitions.push(Petition(_name, _message, msg.sender, _signaturesNeeded, _featured, featuredExpires, 0, now, _connectingHash, 0)) - 1;\n', '        emit NewPetition(id, _name, _message, msg.sender, _signaturesNeeded, _featured, featuredExpires, 0, now, _connectingHash, 0);\n', '\n', '    }\n', '\n', '    function renewFeatured(uint _petitionId) payable public {\n', '        require(msg.value >= featurePetitionFee);\n', '\n', '        uint featuredExpires = 0;\n', '        if (now > petitions[_petitionId].featuredExpires) {\n', '            featuredExpires = now + featuredLength;\n', '        }else {\n', '            featuredExpires = petitions[_petitionId].featuredExpires + featuredLength;\n', '        }\n', '\n', '        petitions[_petitionId].featuredExpires = featuredExpires;\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool:\n', '        cutToInvestorsDividendPool(msg.value);\n', '\n', '    }\n', '\n', '    function viewPetition(uint _petitionId) view public returns (uint, string, string, address, uint, bool, uint, uint, uint, string, uint) {\n', '        Petition storage petition = petitions[_petitionId];\n', '        return (_petitionId, petition.name, petition.message, petition.creator, petition.signaturesNeeded, petition.featured, petition.featuredExpires, petition.totalSignatures, petition.created, petition.connectingHash, petition.advertisingBudget);\n', '    }\n', '\n', '    function viewPetitionSignerWithAddress(address _ownerAddress, uint _petitionId) view public returns (uint, uint, address, uint) {\n', '        require (ownerPetitionSignerArrayCreated[_ownerAddress][_petitionId] > 0);\n', '\n', '        PetitionSigner storage signers = petitionsigners[petitionSignerMap[_ownerAddress][_petitionId]];\n', '        return (petitionSignerMap[_ownerAddress][_petitionId], signers.petitionId, signers.petitionSignerAddress, signers.signed);\n', '    }\n', '\n', '    function viewPetitionSigner(uint _petitionSignerId) view public returns (uint, uint, address, uint) {\n', '        PetitionSigner storage signers = petitionsigners[_petitionSignerId];\n', '        return (_petitionSignerId, signers.petitionId, signers.petitionSignerAddress, signers.signed);\n', '    }\n', '\n', '    function advertisingDeposit (uint _petitionId) payable public {\n', '        petitions[_petitionId].advertisingBudget = SafeMath.add(petitions[_petitionId].advertisingBudget, msg.value);\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool -> since its advertising we can cut 100% of the msg.value to everyone\n', '        cutToInvestorsDividendPool(msg.value);\n', '\n', '    }\n', '\n', '    function cutToInvestorsDividendPool(uint totalPaid) internal {\n', '        //\n', '        // removed this because as petition.io we still have to claim owned shares % worth from the dividendpool.\n', '\n', '        // calc cut for Petition.io\n', '        //uint firstDiv = SafeMath.div(PetitionShareholders[PetitionShareholderMap[ownerShareAddress]].shares, sharesSold);\n', '        //uint petitionIoDivAmt = SafeMath.mul(totalPaid, firstDiv);\n', '        //availableForWithdraw = availableForWithdraw + petitionIoDivAmt;\n', '        // calc for shareholders\n', '        //uint divAmt = SafeMath.sub(totalPaid, petitionIoDivAmt);\n', '        // add to investors dividend pool\n', '        //currentDividendPool = SafeMath.add(currentDividendPool, divAmt);\n', '\n', '        currentDividendPool = SafeMath.add(currentDividendPool, totalPaid);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    function advertisingUse (uint _petitionId, uint amount) public {\n', '        require(petitions[_petitionId].creator == msg.sender);\n', '        require(petitions[_petitionId].advertisingBudget >= amount);\n', '        // (fills out advertising information on website and funds it here)\n', '        petitions[_petitionId].advertisingBudget = petitions[_petitionId].advertisingBudget - amount;\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // sign function\n', '\n', '    function sign (uint _petitionId) public {\n', '        // cant send it to a non existing petition\n', '        require (keccak256(petitions[_petitionId].name) != keccak256(""));\n', '        require (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 0);\n', '\n', '        //if (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 0) {\n', '            \n', '        uint id = petitionsigners.push(PetitionSigner(_petitionId, msg.sender, now)) - 1;\n', '        emit NewPetitionSigner(id, _petitionId, msg.sender, now);\n', '        petitionSignerMap[msg.sender][_petitionId] = id;\n', '        ownerPetitionSignerArrayCreated[msg.sender][_petitionId] = 1;\n', '        \n', '        petitions[_petitionId].totalSignatures = petitions[_petitionId].totalSignatures + 1;\n', '\n', '        //}\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // unsign function\n', '\n', '    function unsign (uint _petitionId) public {\n', '        require (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 1);\n', '\n', '        ownerPetitionSignerArrayCreated[msg.sender][_petitionId] = 0;\n', '\n', '        petitions[_petitionId].totalSignatures = petitions[_petitionId].totalSignatures - 1;\n', '\n', '        delete petitionsigners[petitionSignerMap[msg.sender][_petitionId]];\n', '\n', '        delete petitionSignerMap[msg.sender][_petitionId];\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // start admin functions\n', '\n', '    function initialOwnersShares() public onlyOwner(){\n', '        require(initialOwnerSharesClaimed == 0);\n', '\n', '        uint numberOfShares = 1000000;\n', '\n', '        uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, numberOfShares, 0, now)) - 1;\n', '        emit NewPetitionShareholder(id, msg.sender, numberOfShares, 0, now);\n', '        PetitionShareholderMap[msg.sender] = id;\n', '        ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '        \n', '        sharesSold = sharesSold + numberOfShares;\n', '\n', '        ownerShareAddress = msg.sender;\n', '\n', '        // dividend pool\n', '        dividendPoolStarts = now;\n', '        dividendPoolEnds = (now + dividendCooldown);\n', '\n', '        initialOwnerSharesClaimed = 1; // owner can only claim the intial 1,000,000 shares once\n', '    }\n', '\n', '    function companyShares() public view returns(uint){\n', '        return PetitionShareholders[PetitionShareholderMap[ownerShareAddress]].shares;\n', '    }\n', '    \n', '    function alterDividendCooldown (uint _dividendCooldown) public onlyOwner() {\n', '        dividendCooldown = _dividendCooldown;\n', '    }\n', '\n', '    function spendAdvertising(uint _petitionId, uint amount) public onlyOwner() {\n', '        require(petitions[_petitionId].advertisingBudget >= amount);\n', '\n', '        petitions[_petitionId].advertisingBudget = petitions[_petitionId].advertisingBudget - amount;\n', '    }\n', '\n', '    function viewFeaturedLength() public view returns(uint) {\n', '        return featuredLength;\n', '    }\n', '\n', '    function alterFeaturedLength (uint _newFeaturedLength) public onlyOwner() {\n', '        featuredLength = _newFeaturedLength;\n', '    }\n', '\n', '    function viewInitialPricePerShare() public view returns(uint) {\n', '        return initialPricePerShare;\n', '    }\n', '\n', '    function alterInitialPricePerShare (uint _initialPricePerShare) public onlyOwner() {\n', '        initialPricePerShare = _initialPricePerShare;\n', '    }\n', '\n', '    function viewCreatePetitionFee() public view returns(uint) {\n', '        return createPetitionFee;\n', '    }\n', '\n', '    function alterCreatePetitionFee (uint _createPetitionFee) public onlyOwner() {\n', '        createPetitionFee = _createPetitionFee;\n', '    }\n', '\n', '    function alterPeerToPeerMarketplaceTransactionFee (uint _peerToPeerMarketplaceTransactionFee) public onlyOwner() {\n', '        peerToPeerMarketplaceTransactionFee = _peerToPeerMarketplaceTransactionFee;\n', '    }\n', '\n', '    function viewPeerToPeerMarketplaceTransactionFee() public view returns(uint) {\n', '        return peerToPeerMarketplaceTransactionFee;\n', '    }\n', '\n', '    function viewFeaturePetitionFee() public view returns(uint) {\n', '        return featurePetitionFee;\n', '    }\n', '\n', '    function alterFeaturePetitionFee (uint _featurePetitionFee) public onlyOwner() {\n', '        featurePetitionFee = _featurePetitionFee;\n', '    }\n', '\n', '    function withdrawFromAmt() public view returns(uint) {\n', '        return availableForWithdraw;\n', '    }\n', '\n', '    function withdrawFromContract(address _to, uint _amount) payable external onlyOwner() {\n', '        require(_amount <= availableForWithdraw);\n', '        availableForWithdraw = availableForWithdraw - _amount;\n', '        _to.transfer(_amount);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /*\n', '    NOTE: Instead of adding this function to the smart contract and have the power of deleting a petition (having this power doesnt sound very decentralized), in case of anything inappropriate: Petition.io will instead flag the said petition from showing up on the website. Sure someone can make their own website and link to our smart contract and show all the dirty stuff people will inevitably post.. go for it.\n', '    function deletePetition(uint _petitionId) public onlyOwner() {\n', '        delete petitions[_petitionId];\n', '    }*/\n', '\n', '}']
['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '  ____      _   _ _   _               _       \n', ' |  _ \\ ___| |_(_) |_(_) ___  _ __   (_) ___  \n', " | |_) / _ \\ __| | __| |/ _ \\| '_ \\  | |/ _ \\ \n", ' |  __/  __/ |_| | |_| | (_) | | | |_| | (_) |\n', ' |_|   \\___|\\__|_|\\__|_|\\___/|_| |_(_)_|\\___/ \n', '\n', '*/\n', '\n', 'contract PetitionFactory is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    event NewPetition(uint petitionId, string name, string message, address creator, uint signaturesNeeded, bool featured, uint featuredExpires, uint totalSignatures, uint created, string connectingHash, uint advertisingBudget);\n', '    event NewPetitionSigner(uint petitionSignerId, uint petitionId, address petitionSignerAddress, uint signed);\n', '    event NewPetitionShareholder(uint PetitionShareholderId, address PetitionShareholderAddress, uint shares, uint sharesListedForSale, uint lastDividend);\n', '    event DividendClaim(uint divId, uint PetitionShareholderId, uint amt, uint time, address userAddress);\n', '    event NewShareholderListing(uint shareholderListingId, uint petitionShareholderId, uint sharesForSale, uint price, bool sold);\n', '\n', '    struct Petition {\n', '        string name;\n', '        string message;\n', '        address creator;\n', '        uint signaturesNeeded;\n', '        bool featured;\n', '        uint featuredExpires;\n', '        uint totalSignatures;\n', '        uint created;\n', '        string connectingHash;\n', '        uint advertisingBudget; // an easy way for people to donate to the petition cause. We will use this budget for CPC, CPM text and banner ads around petition.io\n', '    }\n', '\n', '    struct PetitionSigner {\n', '        uint petitionId;\n', '        address petitionSignerAddress;\n', '        uint signed;\n', '    }\n', '\n', '    struct PetitionShareholder {\n', '        address PetitionShareholderAddress;\n', '        uint shares;\n', '        uint sharesListedForSale; // prevent being able to double list shares for sale\n', '        uint lastDividend;\n', '    }\n', '\n', '    struct DividendHistory {\n', '        uint PetitionShareholderId;\n', '        uint amt;\n', '        uint time;\n', '        address userAddress;\n', '    }\n', '\n', '    struct ShareholderListing {\n', '        uint petitionShareholderId;\n', '        uint sharesForSale;\n', '        uint price;\n', '        bool sold;\n', '    }\n', '\n', '    Petition[] public petitions;\n', '\n', '    PetitionSigner[] public petitionsigners;\n', '    mapping(address => mapping(uint => uint)) ownerPetitionSignerArrayCreated;\n', '    mapping(address => mapping(uint => uint)) petitionSignerMap;\n', '\n', '    PetitionShareholder[] public PetitionShareholders;\n', '    mapping(address => uint) ownerPetitionShareholderArrayCreated;\n', '    mapping(address => uint) PetitionShareholderMap;\n', '\n', '    DividendHistory[] public divs;\n', '\n', '    ShareholderListing[] public listings;\n', '\n', '    uint createPetitionFee = 1000000000000000; // 0.001 ETH\n', '    uint featurePetitionFee = 100000000000000000; // 0.1 ETH\n', '    uint featuredLength = 604800; // 1 week\n', '\n', '    /********************************* */\n', '    // shareholder details\n', '\n', '    //uint petitionIoShares = 1000000; // 1,000,000 (20%) of shares given to Petition.io Inc. This is needed so Petition.io Inc can collect 20% of the fees to keep the lights on and continually improve the platform\n', '\n', '    uint sharesSold = 0;\n', '\n', '    uint maxShares = 5000000; // 5,000,000 shares exist\n', '\n', '    // initial price per share from Petition.io (until all shares are sold). But can also be listed and sold p2p on our marketplace at the price set by shareholder\n', '    uint initialPricePerShare  = 5000000000000000; // 0.005 ETH -> \n', '        // notice of bonuses: \n', '        // 10 ETH + get a 10% bonus\n', '        // 50 ETH + get a 20% bonus \n', '        // 100 ETH + get a 30% bonus\n', '        // 500 ETH + get a 40% bonus\n', '        // 1000 ETH + get a 50% bonus\n', '    \n', '    uint initialOwnerSharesClaimed = 0; // owner can only claim their 1,000,000 shares once\n', '    address ownerShareAddress;\n', '\n', '    uint dividendCooldown = 604800; // 1 week\n', '\n', '    uint peerToPeerMarketplaceTransactionFee = 100; // 1% (1 / 100 = 0.01, 2 / 100 = 0.02, etc)\n', '\n', '    uint dividendPoolStarts = 0;\n', '    uint dividendPoolEnds = 0;\n', '    uint claimableDividendPool = 0; // (from the last dividendCooldown time pool)\n', '    uint claimedThisPool = 0;\n', '    uint currentDividendPool = 0; // (from this dividendCooldown pool)\n', '\n', '    uint availableForWithdraw = 0;\n', '\n', '    /********************************* */\n', '    // shareholder functions\n', '\n', '    function invest() payable public {\n', '        require(sharesSold < maxShares);\n', '        // calc how many shares\n', '        uint numberOfShares = SafeMath.div(msg.value, initialPricePerShare); // example is 1 ETH (1000000000000000000) / 0.01 ETH (10000000000000000) = 100 shares\n', '\n', '        // calc bonus\n', '        uint numberOfSharesBonus;\n', '        uint numberOfSharesBonusOne;\n', '        uint numberOfSharesBonusTwo;\n', '        if (msg.value >= 1000000000000000000000) { // 1000 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 2); // 50%\n', '            numberOfShares = SafeMath.add(numberOfShares, numberOfSharesBonus);\n', '\n', '        } else if (msg.value >= 500000000000000000000) { // 500 ETH\n', '            numberOfSharesBonusOne = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfSharesBonusTwo = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfShares = numberOfShares + numberOfSharesBonusOne + numberOfSharesBonusTwo; // 40%\n', '\n', '        } else if (msg.value >= 100000000000000000000) { // 100 ETH\n', '            numberOfSharesBonusOne = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfSharesBonusTwo = SafeMath.div(numberOfShares, 10); // 10%\n', '            numberOfShares = numberOfShares + numberOfSharesBonusOne + numberOfSharesBonusTwo; // 30%\n', '        \n', '        } else if (msg.value >= 50000000000000000000) { // 50 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 5); // 20%\n', '            numberOfShares = numberOfShares + numberOfSharesBonus; // 20%\n', '\n', '        } else if (msg.value >= 10000000000000000000) { // 10 ETH\n', '            numberOfSharesBonus = SafeMath.div(numberOfShares, 10); // 10%\n', '            numberOfShares = numberOfShares + numberOfSharesBonus; // 10%\n', '        \n', '        }\n', '\n', '        require((numberOfShares + sharesSold) < maxShares);\n', '\n', '        if (ownerPetitionShareholderArrayCreated[msg.sender] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, numberOfShares, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, msg.sender, numberOfShares, 0, now);\n', '            PetitionShareholderMap[msg.sender] = id;\n', '            ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '            \n', '            sharesSold = sharesSold + numberOfShares;\n', '\n', '            availableForWithdraw = availableForWithdraw + msg.value;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares + numberOfShares;\n', '            \n', '            sharesSold = sharesSold + numberOfShares;\n', '\n', '            availableForWithdraw = availableForWithdraw + msg.value;\n', '\n', '        }\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    function viewSharesSold() public view returns(uint) {\n', '        return sharesSold;\n', '    }\n', '\n', '    function viewMaxShares() public view returns(uint) {\n', '        return maxShares;\n', '    }\n', '\n', '    function viewPetitionShareholderWithAddress(address _investorAddress) view public returns (uint, address, uint, uint) {\n', '        require (ownerPetitionShareholderArrayCreated[_investorAddress] > 0);\n', '\n', '        PetitionShareholder storage investors = PetitionShareholders[PetitionShareholderMap[_investorAddress]];\n', '        return (PetitionShareholderMap[_investorAddress], investors.PetitionShareholderAddress, investors.shares, investors.lastDividend);\n', '    }\n', '\n', '    function viewPetitionShareholder(uint _PetitionShareholderId) view public returns (uint, address, uint, uint) {\n', '        PetitionShareholder storage investors = PetitionShareholders[_PetitionShareholderId];\n', '        return (_PetitionShareholderId, investors.PetitionShareholderAddress, investors.shares, investors.lastDividend);\n', '    }\n', '\n', '    /********************************* */\n', '    // dividend functions\n', '\n', '    function endDividendPool() public {\n', '        // we do if instead of require so we can call it throughout the smart contract. This way if someone signs, creates a petition, etc. It can ding to the next dividend pool.\n', '        if (now > dividendPoolEnds) {\n', '\n', '            // unclaimed dividends go to admin available\n', '            availableForWithdraw = availableForWithdraw + (claimableDividendPool - claimedThisPool);\n', '\n', '            // current div pool to claimable div pool\n', '            claimableDividendPool = currentDividendPool;\n', '            claimedThisPool = 0;\n', '\n', '            // reset current div pool\n', '            currentDividendPool = 0;\n', '\n', '            // start new pool period\n', '            dividendPoolStarts = now;\n', '            dividendPoolEnds = (now + dividendCooldown);\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function collectDividend() payable public {\n', '        require (ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require ((PetitionShareholders[PetitionShareholderMap[msg.sender]].lastDividend + dividendCooldown) < now);\n', '        require (claimableDividendPool > 0);\n', '\n', '        // calc amount\n', '        uint divAmt = claimableDividendPool / (sharesSold / PetitionShareholders[PetitionShareholderMap[msg.sender]].shares);\n', '\n', '        claimedThisPool = claimedThisPool + divAmt;\n', '\n', '        //\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].lastDividend = now;\n', '\n', '        // the actual ETH transfer\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress.transfer(divAmt);\n', '\n', '        uint id = divs.push(DividendHistory(PetitionShareholderMap[msg.sender], divAmt, now, PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress)) - 1;\n', '        emit DividendClaim(id, PetitionShareholderMap[msg.sender], divAmt, now, PetitionShareholders[PetitionShareholderMap[msg.sender]].PetitionShareholderAddress);\n', '    }\n', '\n', '    function viewInvestorDividendHistory(uint _divId) public view returns(uint, uint, uint, uint, address) {\n', '        return(_divId, divs[_divId].PetitionShareholderId, divs[_divId].amt, divs[_divId].time, divs[_divId].userAddress);\n', '    }\n', '\n', '    function viewInvestorDividendPool() public view returns(uint) {\n', '        return currentDividendPool;\n', '    }\n', '\n', '    function viewClaimableInvestorDividendPool() public view returns(uint) {\n', '        return claimableDividendPool;\n', '    }\n', '\n', '    function viewClaimedThisPool() public view returns(uint) {\n', '        return claimedThisPool;\n', '    }\n', '\n', '    function viewLastClaimedDividend(address _address) public view returns(uint) {\n', '        return PetitionShareholders[PetitionShareholderMap[_address]].lastDividend;\n', '    }\n', '\n', '    function ViewDividendPoolEnds() public view returns(uint) {\n', '        return dividendPoolEnds;\n', '    }\n', '\n', '    function viewDividendCooldown() public view returns(uint) {\n', '        return dividendCooldown;\n', '    }\n', '\n', '\n', '    // transfer shares\n', '    function transferShares(uint _amount, address _to) public {\n', '        require(ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require((PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale) >= _amount);\n', '\n', '        // give to receiver\n', '        if (ownerPetitionShareholderArrayCreated[_to] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(_to, _amount, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, _to, _amount, 0, now);\n', '            PetitionShareholderMap[_to] = id;\n', '            ownerPetitionShareholderArrayCreated[_to] = 1;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[_to]].shares = PetitionShareholders[PetitionShareholderMap[_to]].shares + _amount;\n', '\n', '        }\n', '\n', '        // take from sender\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - _amount;\n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale = PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale - _amount;\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    // p2p share listing, selling and buying\n', '    function listSharesForSale(uint _amount, uint _price) public {\n', '        require(ownerPetitionShareholderArrayCreated[msg.sender] > 0);\n', '        require((PetitionShareholders[PetitionShareholderMap[msg.sender]].shares - PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale) >= _amount);\n', '        \n', '        PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale = PetitionShareholders[PetitionShareholderMap[msg.sender]].sharesListedForSale + _amount;\n', '\n', '        uint id = listings.push(ShareholderListing(PetitionShareholderMap[msg.sender], _amount, _price, false)) - 1;\n', '        emit NewShareholderListing(id, PetitionShareholderMap[msg.sender], _amount, _price, false);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '        \n', '    }\n', '\n', '    function viewShareholderListing(uint _shareholderListingId)view public returns (uint, uint, uint, uint, bool) {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        return (_shareholderListingId, listing.petitionShareholderId, listing.sharesForSale, listing.price, listing.sold);\n', '    }\n', '\n', '    function removeShareholderListing(uint _shareholderListingId) public {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        require(PetitionShareholderMap[msg.sender] == listing.petitionShareholderId);\n', '\n', '        PetitionShareholders[listing.petitionShareholderId].sharesListedForSale = PetitionShareholders[listing.petitionShareholderId].sharesListedForSale - listing.sharesForSale;\n', '\n', '        delete listings[_shareholderListingId];\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '        \n', '    }\n', '\n', '    function buySharesFromListing(uint _shareholderListingId) payable public {\n', '        ShareholderListing storage listing = listings[_shareholderListingId];\n', '        require(msg.value >= listing.price);\n', '        require(listing.sold == false);\n', '        require(listing.sharesForSale > 0);\n', '        \n', '        // give to buyer\n', '        if (ownerPetitionShareholderArrayCreated[msg.sender] == 0) {\n', '            // new investor\n', '            uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, listing.sharesForSale, 0, now)) - 1;\n', '            emit NewPetitionShareholder(id, msg.sender, listing.sharesForSale, 0, now);\n', '            PetitionShareholderMap[msg.sender] = id;\n', '            ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '\n', '        } else {\n', '            // add to amount\n', '            PetitionShareholders[PetitionShareholderMap[msg.sender]].shares = PetitionShareholders[PetitionShareholderMap[msg.sender]].shares + listing.sharesForSale;\n', '\n', '        }\n', '\n', '        listing.sold = true;\n', '\n', '        // take from seller\n', '        PetitionShareholders[listing.petitionShareholderId].shares = PetitionShareholders[listing.petitionShareholderId].shares - listing.sharesForSale;\n', '        PetitionShareholders[listing.petitionShareholderId].sharesListedForSale = PetitionShareholders[listing.petitionShareholderId].sharesListedForSale - listing.sharesForSale;\n', '\n', '        // 1% fee\n', '        uint calcFee = SafeMath.div(msg.value, peerToPeerMarketplaceTransactionFee);\n', '        cutToInvestorsDividendPool(calcFee);\n', '\n', '        // transfer funds to seller\n', '        uint toSeller = SafeMath.sub(msg.value, calcFee);\n', '        PetitionShareholders[listing.petitionShareholderId].PetitionShareholderAddress.transfer(toSeller);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // petition functions\n', '\n', '    function createPetition(string _name, string _message, uint _signaturesNeeded, bool _featured, string _connectingHash) payable public {\n', '        require(msg.value >= createPetitionFee);\n', '        uint featuredExpires = 0;\n', '        uint totalPaid = createPetitionFee;\n', '        if (_featured) {\n', '            require(msg.value >= (createPetitionFee + featurePetitionFee));\n', '            featuredExpires = now + featuredLength;\n', '            totalPaid = totalPaid + featurePetitionFee;\n', '        }\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool:\n', '        cutToInvestorsDividendPool(totalPaid);\n', '\n', '        //////////\n', '\n', '        uint id = petitions.push(Petition(_name, _message, msg.sender, _signaturesNeeded, _featured, featuredExpires, 0, now, _connectingHash, 0)) - 1;\n', '        emit NewPetition(id, _name, _message, msg.sender, _signaturesNeeded, _featured, featuredExpires, 0, now, _connectingHash, 0);\n', '\n', '    }\n', '\n', '    function renewFeatured(uint _petitionId) payable public {\n', '        require(msg.value >= featurePetitionFee);\n', '\n', '        uint featuredExpires = 0;\n', '        if (now > petitions[_petitionId].featuredExpires) {\n', '            featuredExpires = now + featuredLength;\n', '        }else {\n', '            featuredExpires = petitions[_petitionId].featuredExpires + featuredLength;\n', '        }\n', '\n', '        petitions[_petitionId].featuredExpires = featuredExpires;\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool:\n', '        cutToInvestorsDividendPool(msg.value);\n', '\n', '    }\n', '\n', '    function viewPetition(uint _petitionId) view public returns (uint, string, string, address, uint, bool, uint, uint, uint, string, uint) {\n', '        Petition storage petition = petitions[_petitionId];\n', '        return (_petitionId, petition.name, petition.message, petition.creator, petition.signaturesNeeded, petition.featured, petition.featuredExpires, petition.totalSignatures, petition.created, petition.connectingHash, petition.advertisingBudget);\n', '    }\n', '\n', '    function viewPetitionSignerWithAddress(address _ownerAddress, uint _petitionId) view public returns (uint, uint, address, uint) {\n', '        require (ownerPetitionSignerArrayCreated[_ownerAddress][_petitionId] > 0);\n', '\n', '        PetitionSigner storage signers = petitionsigners[petitionSignerMap[_ownerAddress][_petitionId]];\n', '        return (petitionSignerMap[_ownerAddress][_petitionId], signers.petitionId, signers.petitionSignerAddress, signers.signed);\n', '    }\n', '\n', '    function viewPetitionSigner(uint _petitionSignerId) view public returns (uint, uint, address, uint) {\n', '        PetitionSigner storage signers = petitionsigners[_petitionSignerId];\n', '        return (_petitionSignerId, signers.petitionId, signers.petitionSignerAddress, signers.signed);\n', '    }\n', '\n', '    function advertisingDeposit (uint _petitionId) payable public {\n', '        petitions[_petitionId].advertisingBudget = SafeMath.add(petitions[_petitionId].advertisingBudget, msg.value);\n', '\n', '        /////////////\n', '        // cut to shareholders dividend pool -> since its advertising we can cut 100% of the msg.value to everyone\n', '        cutToInvestorsDividendPool(msg.value);\n', '\n', '    }\n', '\n', '    function cutToInvestorsDividendPool(uint totalPaid) internal {\n', '        //\n', '        // removed this because as petition.io we still have to claim owned shares % worth from the dividendpool.\n', '\n', '        // calc cut for Petition.io\n', '        //uint firstDiv = SafeMath.div(PetitionShareholders[PetitionShareholderMap[ownerShareAddress]].shares, sharesSold);\n', '        //uint petitionIoDivAmt = SafeMath.mul(totalPaid, firstDiv);\n', '        //availableForWithdraw = availableForWithdraw + petitionIoDivAmt;\n', '        // calc for shareholders\n', '        //uint divAmt = SafeMath.sub(totalPaid, petitionIoDivAmt);\n', '        // add to investors dividend pool\n', '        //currentDividendPool = SafeMath.add(currentDividendPool, divAmt);\n', '\n', '        currentDividendPool = SafeMath.add(currentDividendPool, totalPaid);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    function advertisingUse (uint _petitionId, uint amount) public {\n', '        require(petitions[_petitionId].creator == msg.sender);\n', '        require(petitions[_petitionId].advertisingBudget >= amount);\n', '        // (fills out advertising information on website and funds it here)\n', '        petitions[_petitionId].advertisingBudget = petitions[_petitionId].advertisingBudget - amount;\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // sign function\n', '\n', '    function sign (uint _petitionId) public {\n', '        // cant send it to a non existing petition\n', '        require (keccak256(petitions[_petitionId].name) != keccak256(""));\n', '        require (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 0);\n', '\n', '        //if (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 0) {\n', '            \n', '        uint id = petitionsigners.push(PetitionSigner(_petitionId, msg.sender, now)) - 1;\n', '        emit NewPetitionSigner(id, _petitionId, msg.sender, now);\n', '        petitionSignerMap[msg.sender][_petitionId] = id;\n', '        ownerPetitionSignerArrayCreated[msg.sender][_petitionId] = 1;\n', '        \n', '        petitions[_petitionId].totalSignatures = petitions[_petitionId].totalSignatures + 1;\n', '\n', '        //}\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // unsign function\n', '\n', '    function unsign (uint _petitionId) public {\n', '        require (ownerPetitionSignerArrayCreated[msg.sender][_petitionId] == 1);\n', '\n', '        ownerPetitionSignerArrayCreated[msg.sender][_petitionId] = 0;\n', '\n', '        petitions[_petitionId].totalSignatures = petitions[_petitionId].totalSignatures - 1;\n', '\n', '        delete petitionsigners[petitionSignerMap[msg.sender][_petitionId]];\n', '\n', '        delete petitionSignerMap[msg.sender][_petitionId];\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // start admin functions\n', '\n', '    function initialOwnersShares() public onlyOwner(){\n', '        require(initialOwnerSharesClaimed == 0);\n', '\n', '        uint numberOfShares = 1000000;\n', '\n', '        uint id = PetitionShareholders.push(PetitionShareholder(msg.sender, numberOfShares, 0, now)) - 1;\n', '        emit NewPetitionShareholder(id, msg.sender, numberOfShares, 0, now);\n', '        PetitionShareholderMap[msg.sender] = id;\n', '        ownerPetitionShareholderArrayCreated[msg.sender] = 1;\n', '        \n', '        sharesSold = sharesSold + numberOfShares;\n', '\n', '        ownerShareAddress = msg.sender;\n', '\n', '        // dividend pool\n', '        dividendPoolStarts = now;\n', '        dividendPoolEnds = (now + dividendCooldown);\n', '\n', '        initialOwnerSharesClaimed = 1; // owner can only claim the intial 1,000,000 shares once\n', '    }\n', '\n', '    function companyShares() public view returns(uint){\n', '        return PetitionShareholders[PetitionShareholderMap[ownerShareAddress]].shares;\n', '    }\n', '    \n', '    function alterDividendCooldown (uint _dividendCooldown) public onlyOwner() {\n', '        dividendCooldown = _dividendCooldown;\n', '    }\n', '\n', '    function spendAdvertising(uint _petitionId, uint amount) public onlyOwner() {\n', '        require(petitions[_petitionId].advertisingBudget >= amount);\n', '\n', '        petitions[_petitionId].advertisingBudget = petitions[_petitionId].advertisingBudget - amount;\n', '    }\n', '\n', '    function viewFeaturedLength() public view returns(uint) {\n', '        return featuredLength;\n', '    }\n', '\n', '    function alterFeaturedLength (uint _newFeaturedLength) public onlyOwner() {\n', '        featuredLength = _newFeaturedLength;\n', '    }\n', '\n', '    function viewInitialPricePerShare() public view returns(uint) {\n', '        return initialPricePerShare;\n', '    }\n', '\n', '    function alterInitialPricePerShare (uint _initialPricePerShare) public onlyOwner() {\n', '        initialPricePerShare = _initialPricePerShare;\n', '    }\n', '\n', '    function viewCreatePetitionFee() public view returns(uint) {\n', '        return createPetitionFee;\n', '    }\n', '\n', '    function alterCreatePetitionFee (uint _createPetitionFee) public onlyOwner() {\n', '        createPetitionFee = _createPetitionFee;\n', '    }\n', '\n', '    function alterPeerToPeerMarketplaceTransactionFee (uint _peerToPeerMarketplaceTransactionFee) public onlyOwner() {\n', '        peerToPeerMarketplaceTransactionFee = _peerToPeerMarketplaceTransactionFee;\n', '    }\n', '\n', '    function viewPeerToPeerMarketplaceTransactionFee() public view returns(uint) {\n', '        return peerToPeerMarketplaceTransactionFee;\n', '    }\n', '\n', '    function viewFeaturePetitionFee() public view returns(uint) {\n', '        return featurePetitionFee;\n', '    }\n', '\n', '    function alterFeaturePetitionFee (uint _featurePetitionFee) public onlyOwner() {\n', '        featurePetitionFee = _featurePetitionFee;\n', '    }\n', '\n', '    function withdrawFromAmt() public view returns(uint) {\n', '        return availableForWithdraw;\n', '    }\n', '\n', '    function withdrawFromContract(address _to, uint _amount) payable external onlyOwner() {\n', '        require(_amount <= availableForWithdraw);\n', '        availableForWithdraw = availableForWithdraw - _amount;\n', '        _to.transfer(_amount);\n', '\n', '        // new div pool?\n', '        endDividendPool();\n', '\n', '    }\n', '\n', '    /*\n', '    NOTE: Instead of adding this function to the smart contract and have the power of deleting a petition (having this power doesnt sound very decentralized), in case of anything inappropriate: Petition.io will instead flag the said petition from showing up on the website. Sure someone can make their own website and link to our smart contract and show all the dirty stuff people will inevitably post.. go for it.\n', '    function deletePetition(uint _petitionId) public onlyOwner() {\n', '        delete petitions[_petitionId];\n', '    }*/\n', '\n', '}']
