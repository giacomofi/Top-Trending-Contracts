['pragma solidity ^0.4.19; // solhint-disable-line\n', '\n', 'library FifoLib {\n', '\n', '    uint constant HEAD = 0;\n', '    \n', '    struct LinkedList {\n', '        mapping (uint => uint) list;\n', '        uint tail;\n', '        uint size;\n', '    }\n', '\n', '    function size(LinkedList storage self)\n', '        internal view returns (uint r) {\n', '        return self.size;\n', '    }\n', '\n', '    function next(LinkedList storage self, uint n)\n', '        internal view returns (uint) {\n', '        return self.list[n];\n', '    }\n', '\n', '    // insert n after prev\n', '    function insert(LinkedList storage self, uint prev, uint n) internal returns (uint) {\n', '        require(n != HEAD && self.list[n] == HEAD && n != self.tail);\n', '        self.list[n] = self.list[prev];\n', '        self.list[prev] = n;\n', '        self.size++;\n', '        if (self.tail == prev) {\n', '            self.tail = n;\n', '        }\n', '        return n;\n', '    }\n', '    \n', '    // Remove node n preceded by prev\n', '    function remove(LinkedList storage self, uint prev, uint n) internal returns (uint) {\n', '        require(n != HEAD && self.list[prev] == n);\n', '        self.list[prev] = self.list[n];\n', '        delete self.list[n];\n', '        self.size--;\n', '        if (self.tail == n) {\n', '            self.tail = prev;\n', '        }\n', '        return n;\n', '    }\n', '\n', '    function pushTail(LinkedList storage self, uint n) internal returns (uint) {\n', '        return insert(self, self.tail, n);\n', '    }\n', '    \n', '    function popHead(LinkedList storage self) internal returns (uint) {\n', '        require(self.size > 0);\n', '        return remove(self, HEAD, self.list[HEAD]);\n', '    }\n', '}\n', '\n', 'contract CompanyToken {\n', '    event Founded(uint256 tokenId, string name, address owner, uint256 price);\n', '    event SharesSold(uint256 tokenId, uint256 shares, uint256 price, address prevOwner, address newOnwer, string name);\n', '    event Transfer(address from, address to, uint256 tokenId, uint256 shares);\n', '\n', '    string public constant NAME = "CryptoCompanies"; // solhint-disable-line\n', '    string public constant SYMBOL = "CompanyToken"; // solhint-disable-line\n', '\n', '    uint256 private constant HEAD = 0;\n', '\n', '    uint256 private startingPrice = 0.001 ether;\n', '    uint256 private constant PROMO_CREATION_LIMIT = 5000;\n', '    uint256 private firstStepLimit =  0.05 ether;\n', '    uint256 private secondStepLimit = 0.5 ether;\n', '\n', '    uint256 public commissionPoints = 5;\n', '\n', '    // @dev max number of shares per company\n', '    uint256 private constant TOTAL_SHARES = 100;\n', '\n', '    // @dev companyIndex => (ownerAddress => numberOfShares)\n', '    mapping (uint256 => mapping (address => uint256)) public companyIndexToOwners;\n', '\n', '    struct Holding {\n', '        address owner;\n', '        uint256 shares;\n', '    }\n', '\n', '    // tokenId => holding fifo\n', '    mapping (uint256 => FifoLib.LinkedList) private fifo;\n', '    // tokenId => map(fifoIndex => holding)\n', '    mapping (uint256 => mapping (uint256 => Holding)) private fifoStorage;\n', '\n', '    mapping (uint256 => uint256) private fifoStorageKey;\n', '\n', '    // number of shares traded\n', '    // tokenId => circulatationCount\n', '    mapping (uint256 => uint256) private circulationCounters;\n', '\n', '    // @dev A mapping from CompanyIDs to the price of the token.\n', '    mapping (uint256 => uint256) private companyIndexToPrice;\n', '\n', '    // @dev Owner who has most shares \n', '    mapping (uint256 => address) private companyIndexToChairman;\n', '\n', '    // @dev Whether buying shares is allowed. if false, only whole purchase is allowed.\n', '    mapping (uint256 => bool) private shareTradingEnabled;\n', '\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cooAddress;\n', '\n', '    uint256 public promoCreatedCount;\n', '\n', '    struct Company {\n', '        string name;\n', '    }\n', '\n', '    Company[] private companies;\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cooAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    function CompanyToken() public {\n', '        ceoAddress = msg.sender;\n', '        cooAddress = msg.sender;\n', '    }\n', '\n', '    function createPromoCompany(address _owner, string _name, uint256 _price) public onlyCOO {\n', '        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '\n', '        address companyOwner = _owner;\n', '        if (companyOwner == address(0)) {\n', '            companyOwner = cooAddress;\n', '        }\n', '\n', '        if (_price <= 0) {\n', '            _price = startingPrice;\n', '        }\n', '\n', '        promoCreatedCount++;\n', '        _createCompany(_name, companyOwner, _price);\n', '    }\n', '\n', '    function createContractCompany(string _name) public onlyCOO {\n', '        _createCompany(_name, address(this), startingPrice);\n', '    }\n', '\n', '    function setShareTradingEnabled(uint256 _tokenId, bool _enabled) public onlyCOO {\n', '        shareTradingEnabled[_tokenId] = _enabled;\n', '    }\n', '\n', '    function setCommissionPoints(uint256 _point) public onlyCOO {\n', '        require(_point >= 0 && _point <= 10);\n', '        commissionPoints = _point;\n', '    }\n', '\n', '    function getCompany(uint256 _tokenId) public view returns (\n', '        string companyName,\n', '        bool isShareTradingEnabled,\n', '        uint256 price,\n', '        uint256 _nextPrice,\n', '        address chairman,\n', '        uint256 circulations\n', '    ) {\n', '        Company storage company = companies[_tokenId];\n', '        companyName = company.name;\n', '        isShareTradingEnabled = shareTradingEnabled[_tokenId];\n', '        price = companyIndexToPrice[_tokenId];\n', '        _nextPrice = nextPrice(_tokenId, price);\n', '        chairman = companyIndexToChairman[_tokenId];\n', '        circulations = circulationCounters[_tokenId];\n', '    }\n', '\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '\n', '    function shareHoldersOf(uint256 _tokenId) public view returns (address[] memory addrs, uint256[] memory shares) {\n', '        addrs = new address[](fifo[_tokenId].size);\n', '        shares = new uint256[](fifo[_tokenId].size);\n', '\n', '        uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\n', '        uint256 i;\n', '        while (fifoKey != HEAD) {\n', '            addrs[i] = fifoStorage[_tokenId][fifoKey].owner;\n', '            shares[i] = fifoStorage[_tokenId][fifoKey].shares;\n', '            fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\n', '            i++;\n', '        }\n', '        return (addrs, shares);\n', '    }\n', '\n', '    function chairmanOf(uint256 _tokenId)\n', '        public\n', '        view\n', '        returns (address chairman)\n', '    {\n', '        chairman = companyIndexToChairman[_tokenId];\n', '        require(chairman != address(0));\n', '    }\n', '\n', '    function sharesOwned(address _owner, uint256 _tokenId) public view returns (uint256 shares) {\n', '        return companyIndexToOwners[_tokenId][_owner];\n', '    }\n', '\n', '    function payout(address _to) public onlyCLevel {\n', '        _payout(_to);\n', '    }\n', '\n', '    function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '        return companyIndexToPrice[_tokenId];\n', '    }\n', '\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function totalCompanies() public view returns (uint256 total) {\n', '        return companies.length;\n', '    }\n', '\n', '\n', '    function _addressNotNull(address _to) private pure returns (bool) {\n', '        return _to != address(0);\n', '    }\n', '\n', '    /// For creating Company\n', '    function _createCompany(string _name, address _owner, uint256 _price) private {\n', '        require(_price % 100 == 0);\n', '\n', '        Company memory _company = Company({\n', '            name: _name\n', '        });\n', '        uint256 newCompanyId = companies.push(_company) - 1;\n', '\n', '        // It&#39;s probably never going to happen, 4 billion tokens are A LOT, but\n', '        // let&#39;s just be 100% sure we never let this happen.\n', '        require(newCompanyId == uint256(uint32(newCompanyId)));\n', '\n', '        Founded(newCompanyId, _name, _owner, _price);\n', '\n', '        companyIndexToPrice[newCompanyId] = _price;\n', '\n', '        _transfer(address(0), _owner, newCompanyId, TOTAL_SHARES);\n', '    }\n', '\n', '    /// Check for token ownership\n', '    function _owns(address claimant, uint256 _tokenId, uint256 _shares) private view returns (bool) {\n', '        return companyIndexToOwners[_tokenId][claimant] >= _shares;\n', '    }\n', '\n', '    /// For paying out balance on contract\n', '    function _payout(address _to) private {\n', '        if (_to == address(0)) {\n', '            ceoAddress.transfer(this.balance);\n', '        } else {\n', '            _to.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '    function _purchaseProcessFifoItem(uint256 _tokenId, Holding storage _holding, uint256 _sharesToFulfill)\n', '        private\n', '        returns (uint256 sharesFulfilled, uint256 payment) {\n', '\n', '        sharesFulfilled = Math.min(_holding.shares, _sharesToFulfill);\n', '\n', '        // underflow is not possible because decution is the minimun of the two\n', '        _holding.shares -= sharesFulfilled;\n', '\n', '        companyIndexToOwners[_tokenId][_holding.owner] = SafeMath.sub(companyIndexToOwners[_tokenId][_holding.owner], sharesFulfilled);\n', '\n', '        uint256 currentTierLeft = SafeMath.sub(TOTAL_SHARES, circulationCounters[_tokenId] % TOTAL_SHARES);\n', '        uint256 currentPriceShares = Math.min(currentTierLeft, sharesFulfilled);\n', '        payment = SafeMath.div(SafeMath.mul(companyIndexToPrice[_tokenId], currentPriceShares), TOTAL_SHARES);\n', '\n', '        SharesSold(_tokenId, currentPriceShares, companyIndexToPrice[_tokenId], _holding.owner, msg.sender, companies[_tokenId].name);\n', '\n', '        if (sharesFulfilled >= currentTierLeft) {\n', '            uint256 newPrice = nextPrice(_tokenId, companyIndexToPrice[_tokenId]);\n', '            companyIndexToPrice[_tokenId] = newPrice;\n', '\n', '            if (sharesFulfilled > currentTierLeft) {\n', '                uint256 newPriceShares = sharesFulfilled - currentTierLeft;\n', '                payment += SafeMath.div(SafeMath.mul(newPrice, newPriceShares), TOTAL_SHARES);\n', '                SharesSold(_tokenId, newPriceShares, newPrice, _holding.owner, msg.sender, companies[_tokenId].name);\n', '            }\n', '        }\n', '\n', '        circulationCounters[_tokenId] = SafeMath.add(circulationCounters[_tokenId], sharesFulfilled);\n', '\n', '        // no need to transfer if seller is the contract\n', '        if (_holding.owner != address(this)) {\n', '            _holding.owner.transfer(SafeMath.div(SafeMath.mul(payment, 100 - commissionPoints), 100));\n', '        }\n', '\n', '        Transfer(_holding.owner, msg.sender, _tokenId, sharesFulfilled);\n', '    }\n', '\n', '    function _purchaseLoopFifo(uint256 _tokenId, uint256 _sharesToFulfill)\n', '        private\n', '        returns (uint256 sharesFulfilled, uint256 totalPayment) {\n', '        uint256 prevFifoKey = HEAD;\n', '        uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\n', '        while (fifoKey != HEAD) {\n', '            Holding storage holding = fifoStorage[_tokenId][fifoKey];\n', '\n', '            assert(holding.shares > 0);\n', '\n', '            if (holding.owner != msg.sender) {\n', '                uint256 itemSharesFulfilled;\n', '                uint256 itemPayment;\n', '                (itemSharesFulfilled, itemPayment) = _purchaseProcessFifoItem(_tokenId, holding, SafeMath.sub(_sharesToFulfill, sharesFulfilled));\n', '\n', '                sharesFulfilled += itemSharesFulfilled;\n', '                totalPayment += itemPayment;\n', '\n', '                if (holding.shares == 0) {\n', '                    // delete the record from fifo\n', '                    FifoLib.remove(fifo[_tokenId], prevFifoKey, fifoKey);\n', '                    fifoKey = prevFifoKey;\n', '                }\n', '            }\n', '\n', '            if (sharesFulfilled == _sharesToFulfill) break;\n', '\n', '            prevFifoKey = fifoKey;\n', '            fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\n', '        }  \n', '    }\n', '\n', '    function purchase(uint256 _tokenId, uint256 _shares) public payable {\n', '        require(_sharesValid(_tokenId, _shares));\n', '        require(companyIndexToOwners[_tokenId][msg.sender] + _shares <= TOTAL_SHARES);\n', '\n', '        uint256 estimatedPayment = estimatePurchasePayment(_tokenId, _shares);\n', '\n', '        require(msg.value >= estimatedPayment);\n', '\n', '        uint256 sharesFulfilled;\n', '        uint256 totalPayment;\n', '        (sharesFulfilled, totalPayment) = _purchaseLoopFifo(_tokenId, _shares);\n', '\n', '        assert(sharesFulfilled == _shares);\n', '        assert(totalPayment == estimatedPayment);\n', '\n', '        uint256 purchaseExess = SafeMath.sub(msg.value, totalPayment);\n', '        assert(purchaseExess >= 0);\n', '\n', '        if (purchaseExess > 0) {\n', '            msg.sender.transfer(purchaseExess);\n', '        }\n', '\n', '        fifoStorage[_tokenId][FifoLib.pushTail(fifo[_tokenId], _nextFifoStorageKey(_tokenId))] = Holding({owner: msg.sender, shares: _shares});\n', '\n', '        companyIndexToOwners[_tokenId][msg.sender] += _shares;\n', '\n', '        if (companyIndexToOwners[_tokenId][msg.sender] > companyIndexToOwners[_tokenId][companyIndexToChairman[_tokenId]]) {\n', '            companyIndexToChairman[_tokenId] = msg.sender;\n', '        }\n', '    }\n', '\n', '    function estimatePurchasePayment(uint256 _tokenId, uint256 _shares) public view returns (uint256) {\n', '        require(_shares <= TOTAL_SHARES);\n', '\n', '        uint256 currentPrice = companyIndexToPrice[_tokenId];\n', '\n', '        uint256 currentPriceShares = Math.min(_shares, TOTAL_SHARES - circulationCounters[_tokenId] % TOTAL_SHARES);\n', '        return SafeMath.add(\n', '            SafeMath.div(SafeMath.mul(currentPrice, currentPriceShares), TOTAL_SHARES),\n', '            SafeMath.div(SafeMath.mul(nextPrice(_tokenId, currentPrice), _shares - currentPriceShares), TOTAL_SHARES)\n', '        );\n', '    }\n', '\n', '    function nextPrice(uint256 _tokenId, uint256 _currentPrice) public view returns (uint256) {\n', '        uint256 price;\n', '        if (_currentPrice < firstStepLimit) {\n', '          // first stage\n', '          price = SafeMath.div(SafeMath.mul(_currentPrice, 200), 100);\n', '        } else if (_currentPrice < secondStepLimit) {\n', '          // second stage\n', '          price = SafeMath.div(SafeMath.mul(_currentPrice, 120), 100);\n', '        } else {\n', '          // third stage\n', '          price = SafeMath.div(SafeMath.mul(_currentPrice, 115), 100);\n', '        }\n', '\n', '        return price - price % 100;\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        uint256 _shares\n', '    ) public {\n', '        require(_addressNotNull(_to));\n', '        require(_sharesValid(_tokenId, _shares));\n', '        require(_owns(msg.sender, _tokenId, _shares));\n', '\n', '        _transfer(msg.sender, _to, _tokenId, _shares);\n', '    }\n', '\n', '    function transferFromContract(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        uint256 _shares\n', '    ) public onlyCOO {\n', '        address from = address(this);\n', '        require(_addressNotNull(_to));\n', '        require(_sharesValid(_tokenId, _shares));\n', '        require(_owns(from, _tokenId, _shares));\n', '\n', '        _transfer(from, _to, _tokenId, _shares);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId, uint256 _shares) private {\n', '        if (_from != address(0)) {\n', '            uint256 sharesToFulfill = _shares;\n', '\n', '            uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\n', '            while (fifoKey != HEAD) {\n', '                Holding storage holding = fifoStorage[_tokenId][fifoKey];\n', '\n', '                assert(holding.shares > 0);\n', '\n', '                if (holding.owner == _from) {\n', '                    uint256 fulfilled = Math.min(holding.shares, sharesToFulfill);\n', '\n', '                    if (holding.shares == fulfilled) {\n', '                        // if all shares are taken, just modify the owner address in place\n', '                        holding.owner = _to;\n', '                    } else {\n', '                        // underflow is not possible because deduction is the minimun of the two\n', '                        holding.shares -= fulfilled;\n', '\n', '                        // insert a new holding record\n', '                        fifoStorage[_tokenId][FifoLib.insert(fifo[_tokenId], fifoKey, _nextFifoStorageKey(_tokenId))] = Holding({owner: _to, shares: fulfilled});\n', '\n', '                        fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\n', '                        // now fifoKey points to the newly inserted one \n', '                    }\n', '\n', '                    // underflow is not possible because deduction is the minimun of the two\n', '                    sharesToFulfill -= fulfilled;\n', '                }\n', '\n', '                if (sharesToFulfill == 0) break;\n', '\n', '                fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\n', '            }\n', '\n', '            require(sharesToFulfill == 0);\n', '\n', '            companyIndexToOwners[_tokenId][_from] -= _shares;\n', '        } else {\n', '            // genesis transfer\n', '            fifoStorage[_tokenId][FifoLib.pushTail(fifo[_tokenId], _nextFifoStorageKey(_tokenId))] = Holding({owner: _to, shares: _shares});\n', '        }\n', '\n', '        companyIndexToOwners[_tokenId][_to] += _shares;\n', '\n', '        if (companyIndexToOwners[_tokenId][_to] > companyIndexToOwners[_tokenId][companyIndexToChairman[_tokenId]]) {\n', '            companyIndexToChairman[_tokenId] = _to;\n', '        }\n', '\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId, _shares);\n', '    }\n', '\n', '    function _sharesValid(uint256 _tokenId, uint256 _shares) private view returns (bool) {\n', '        return (_shares > 0 && _shares <= TOTAL_SHARES) &&\n', '            (shareTradingEnabled[_tokenId] || _shares == TOTAL_SHARES);\n', '    }\n', '\n', '    function _nextFifoStorageKey(uint256 _tokenId) private returns (uint256) {\n', '        return ++fifoStorageKey[_tokenId];\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Math {\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a > b) return a;\n', '        else return b;\n', '    }\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a < b) return a;\n', '        else return b;\n', '    }\n', '}']