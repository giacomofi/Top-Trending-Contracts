['pragma solidity ^0.4.25;\n', '\n', '/*\n', '* METADOLLAR SMART CONTRACT \n', '* https://www.metadollar.org/ETH/contract-status/0005\n', '* See website for contract status and features\n', '*/\n', '\n', 'contract METADOLLAR {\n', '\n', '    /**\n', '     * Only with tokens\n', '     */\n', '    modifier onlyBagholders {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Only with dividends\n', '     */\n', '    modifier onlyStronghands {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '\n', '    string public name = "Metadollar Dynamic Fund";\n', '    string public symbol = "MDY";\n', '    uint public createdAt;\n', '    \n', '    bool public started = true;\n', '    modifier onlyStarted {\n', '        require(started);\n', '        _;\n', '    }\n', '    modifier onlyNotStarted {\n', '        require(!started);\n', '        _;\n', '    }\n', '\n', '    uint8 constant public decimals = 18;\n', '\n', '    /**\n', '     * fees\n', '     */\n', '    uint8 constant internal entryFee_ = 15;\n', '    uint8 constant internal ownerFee_ = 4;\n', '    uint8 constant internal transferFee_ = 5;\n', '    uint8 constant internal exitFeeD0_ = 50;\n', '    uint8 constant internal exitFee_ = 6;\n', '    uint8 constant internal refferalFee_ = 33;\n', '\n', '    address internal _ownerAddress;\n', '\n', '    /**\n', '     * Initial token values\n', '     */\n', '    uint256 constant internal tokenPriceInitial_ = 1 ether;\n', '    uint256 constant internal tokenPriceIncremental_ = 0.0001 ether;\n', '\n', '    uint256 constant internal magnitude = 2 ** 64;\n', '\n', '\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal summaryReferralProfit_;\n', '    mapping(address => uint256) internal dividendsUsed_;\n', '\n', '    uint256 internal tokenSupply_;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    uint public blockCreation;\n', '    \n', '    /**\n', '     * Admins. Only rename tokens, change referral settings and add new admins\n', '     */\n', '    mapping(bytes32 => bool) public administrators;\n', '    modifier onlyAdministrator(){\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[keccak256(_customerAddress)]);\n', '        _;\n', '    }\n', '\n', '    function isAdmin() public view returns (bool) {\n', '        return administrators[keccak256(msg.sender)];\n', '    }\n', '\n', '    function setAdministrator(address _id, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        if (_id != _ownerAddress) {\n', '            administrators[keccak256(_id)] = _status;\n', '        }\n', '    } \n', '\n', '    function setName(string _name)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '\n', '    function setSymbol(string _symbol)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        symbol = _symbol;\n', '    }\n', '\n', '    constructor() public {\n', '        _ownerAddress = msg.sender;\n', '        administrators[keccak256(_ownerAddress)] = true;\n', '        blockCreation = block.number;\n', '    }\n', '    \n', '    function start() onlyNotStarted() onlyAdministrator() public {\n', '        started = true;\n', '        createdAt = block.timestamp;\n', '    }\n', '    \n', '    function getLifetime() public view returns (uint8) {\n', '        if (!started)\n', '        {\n', '            return 0;\n', '        }\n', '        return (uint8) ((now - createdAt) / 60 / 60 / 24);\n', '    }\n', '    \n', '    \n', '    function getSupply() public view returns (uint256) {\n', '        if (!started)\n', '        {\n', '            return 0;\n', '        }\n', '        return totalSupply();\n', '    }\n', '    \n', '    function getExitFee() public view returns (uint8) {\n', '        uint tsupply = getSupply();\n', '        if (tsupply <= 1e18) { \n', '            return exitFeeD0_; // 50%\n', '        } else if (tsupply > 2e18 && tsupply <= 3e18) {\n', '            return (uint8) (exitFeeD0_  - 15); // 35%\n', '        } else if (tsupply > 3e18 && tsupply <= 4e18) {\n', '            return (uint8) (exitFeeD0_  -20); // 30%\n', '        } else if (tsupply > 4e18 && tsupply <= 5e18) {\n', '            return (uint8) (exitFeeD0_  - 25); // 25%\n', '        } else if (tsupply > 5e18 && tsupply <= 10e18) {\n', '            return (uint8) (exitFeeD0_  - 30); // 20%\n', '        } else if (tsupply > 10e18 && tsupply <= 20e18) {\n', '            return (uint8) (exitFeeD0_  - 32); // 18%\n', '        } else if (tsupply > 20e18 && tsupply <= 50e18) {\n', '            return (uint8) (exitFeeD0_  - 35); // 15%\n', '        } else if (tsupply > 50e18 && tsupply <= 100e18) {\n', '            return (uint8) (exitFeeD0_  - 38); // 12%\n', '        } else if (tsupply > 100e18 && tsupply <= 500e18) {\n', '            return (uint8) (exitFeeD0_  - 40); // 10%\n', '        } else if (tsupply > 500e18 && tsupply <= 1000e18) {\n', '            return (uint8) (exitFeeD0_  - 41); // 9%\n', '        } else if (tsupply > 1000e18 && tsupply <= 2500e18) {\n', '            return (uint8) (exitFeeD0_  - 42); // 8%\n', '        } else if (tsupply > 2500e18 && tsupply <= 5000e18) {\n', '            return (uint8) (exitFeeD0_  - 43); // 7%\n', '        } else if (tsupply > 5000e18 && tsupply <= 10000e18) {\n', '            return (uint8) (exitFeeD0_  - 44); // 6%\n', '        } else {\n', '            return exitFee_; // 6%\n', '        }\n', '    }\n', '\n', '    function buy(address _r1, address _r2, address _r3, address _r4, address _r5) onlyStarted() public payable returns (uint256) {\n', '        purchaseTokens(msg.value, _r1, _r2, _r3, _r4, _r5);\n', '    }\n', '\n', '    function reinvest() onlyStronghands public {\n', '        uint256 _dividends = myDividends(false);\n', '        address _customerAddress = msg.sender;\n', '        dividendsUsed_[_customerAddress] += _dividends;\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        purchaseTokens(_dividends, 0x0, 0x0, 0x0, 0x0, 0x0);\n', '        emit onReinvestment(_customerAddress, _dividends);\n', '    }\n', '\n', '    function exit() public {\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if (_tokens > 0) sell(_tokens);\n', '        withdraw();\n', '    }\n', '\n', '    function withdraw() onlyStronghands public {\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(false);\n', '        dividendsUsed_[_customerAddress] += _dividends;\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '        \n', '        uint256 _fee = SafeMath.div(SafeMath.mul(_dividends, getExitFee() - 3), 100);\n', '        \n', '        uint256 _ownerFee = SafeMath.div(SafeMath.mul(_dividends, 3), 100);\n', '        \n', '        uint256 _dividendsTaxed = SafeMath.sub(_dividends, _fee + _ownerFee);\n', '        \n', '        if (_customerAddress != _ownerAddress) {\n', '            referralBalance_[_ownerAddress] += _ownerFee;\n', '            summaryReferralProfit_[_ownerAddress] += _ownerFee;\n', '        } else {\n', '            _dividendsTaxed += _ownerFee;\n', '        }\n', '        \n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (_fee * magnitude) / tokenSupply_);\n', '    \n', '        _customerAddress.transfer(_dividendsTaxed);\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '    function sell(uint256 _amountOfTokens) onlyBagholders public {\n', '        address _customerAddress = msg.sender;\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_ethereum * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '        emit onTokenSell(_customerAddress, _tokens, _ethereum, now, buyPrice());\n', '    }\n', '\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders public returns (bool) {\n', '        address _customerAddress = msg.sender;\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        if (myDividends(true) > 0) {\n', '            withdraw();\n', '        }\n', '\n', '        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '    }\n', '\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    function dividendsOf(address _customerAddress) public view returns (uint256) {\n', '        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '    \n', '    function dividendsFull(address _customerAddress) public view returns (uint256) {\n', '        return dividendsOf(_customerAddress) + dividendsUsed_[_customerAddress] + summaryReferralProfit_[_customerAddress];\n', '    }\n', '\n', '    function sellPrice() public view returns (uint256) {\n', '        return sellPriceAt(tokenSupply_);\n', '    }\n', '\n', '    function buyPrice() public view returns (uint256) {\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, entryFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    function calculateTokensReceived(uint256 _incomingEthereum) public view returns (uint256) {\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n', '        \n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        return tokensToEthereum_(_tokensToSell);\n', '    }\n', '    \n', '    uint256 public I_S = 0.25 ether;\n', '    uint256 public I_R1 = 30;\n', '\n', '    function setI_S(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        I_S = _v;\n', '    }\n', '\n', '    function setI_R1(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        I_R1 = _v;\n', '    }\n', '\n', '    \n', '    uint256 public II_S = 5 ether;\n', '    uint256 public II_R1 = 30;\n', '    uint256 public II_R2 = 10;\n', '\n', '    function setII_S(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        II_S = _v;\n', '    }\n', '\n', '    function setII_R1(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        II_R1 = _v;\n', '    }\n', '\n', '    function setII_R2(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        II_R2 = _v;\n', '    }\n', '    \n', '    uint256 public III_S = 10 ether;\n', '    uint256 public III_R1 = 30;\n', '    uint256 public III_R2 = 10;\n', '    uint256 public III_R3 = 10;\n', '\n', '    function setIII_S(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        III_S = _v;\n', '    }\n', '\n', '    function setIII_R1(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        III_R1 = _v;\n', '    }\n', '\n', '    function setIII_R2(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        III_R2 = _v;\n', '    }\n', '\n', '    function setIII_R3(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        III_R3 = _v;\n', '    }\n', '    \n', '    uint256 public IV_S = 20 ether;\n', '    uint256 public IV_R1 = 30;\n', '    uint256 public IV_R2 = 20;\n', '    uint256 public IV_R3 = 10;\n', '    uint256 public IV_R4 = 10;\n', '\n', '    function setIV_S(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        IV_S = _v;\n', '    }\n', '\n', '    function setIV_R1(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        IV_R1 = _v;\n', '    }\n', '\n', '    function setIV_R2(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        IV_R2 = _v;\n', '    }\n', '\n', '    function setIV_R3(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        IV_R3 = _v;\n', '    }\n', '\n', '    function setIV_R4(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        IV_R4 = _v;\n', '    }\n', '    \n', '    uint256 public V_S = 100 ether;\n', '    uint256 public V_R1 = 40;\n', '    uint256 public V_R2 = 20;\n', '    uint256 public V_R3 = 10;\n', '    uint256 public V_R4 = 10;\n', '    uint256 public V_R5 = 10;\n', '\n', '    function setV_S(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_S = _v;\n', '    }\n', '\n', '    function setV_R1(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_R1 = _v;\n', '    }\n', '\n', '    function setV_R2(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_R2 = _v;\n', '    }\n', '\n', '    function setV_R3(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_R3 = _v;\n', '    }\n', '\n', '    function setV_R4(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_R4 = _v;\n', '    }\n', '\n', '    function setV_R5(uint256 _v)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        V_R5 = _v;\n', '    }\n', '    \n', '    function canRef(address _r, address _c, uint256 _m) internal returns (bool) {\n', '        return _r != 0x0000000000000000000000000000000000000000 && _r != _c && tokenBalanceLedger_[_r] >= _m;\n', '    }\n', '    \n', '    function etherBalance(address r) internal returns (uint256) {\n', '        uint _v = tokenBalanceLedger_[r];\n', '        if (_v < 0.00000001 ether) {\n', '            return 0;\n', '        } else {\n', '            return tokensToEthereum_(_v);\n', '        }\n', '    }\n', '    \n', '    function getLevel(address _cb) public view returns (uint256) {\n', '        uint256 _b = etherBalance(_cb);\n', '        uint256 _o = 0;\n', '        \n', '        if (_b >= V_S) {\n', '            _o = 5;\n', '        } else if (_b >= IV_S) {\n', '            _o = 4;\n', '        } else if (_b >= III_S) {\n', '            _o = 3;\n', '        } else if (_b >= II_S) {\n', '            _o = 2;\n', '        } else if (_b >= I_S) {\n', '            _o = 1;\n', '        }\n', '        \n', '        return _o;\n', '    }\n', '\n', '    function purchaseTokens(uint256 _incomingEthereum, address _r1, address _r2, address _r3, address _r4, address _r5) internal {\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n', '        uint256 _dividends = _undividedDividends;\n', '\n', '        uint256 __bC = 0;\n', '        uint256 _b = 0;\n', '        \n', '        if (canRef(_r1, msg.sender, I_S)) {\n', '            __bC = I_R1;\n', '\n', '            if (etherBalance(_r1) >= V_S) {\n', '                __bC = V_R1;\n', '            } else if (etherBalance(_r1) >= IV_S) {\n', '                __bC = IV_R1;\n', '            } else if (etherBalance(_r1) >= III_S) {\n', '                __bC = III_R1;\n', '            } else if (etherBalance(_r1) >= II_S) {\n', '                __bC = II_R1;\n', '            }\n', '            \n', '            _b = SafeMath.div(SafeMath.mul(_incomingEthereum, __bC), 1000);\n', '            referralBalance_[_r1] = SafeMath.add(referralBalance_[_r1], _b);\n', '            addReferralProfit(_r1, msg.sender, _b);\n', '            _dividends = SafeMath.sub(_dividends, _b);\n', '        }\n', '        \n', '        if (canRef(_r2, msg.sender, II_S)) {\n', '            __bC = II_R2;\n', '\n', '            if (etherBalance(_r2) >= V_S) {\n', '                __bC = V_R2;\n', '            } else if (etherBalance(_r2) >= IV_S) {\n', '                __bC = IV_R2;\n', '            } else if (etherBalance(_r2) >= III_S) {\n', '                __bC = III_R2;\n', '            }\n', '            \n', '            _b = SafeMath.div(SafeMath.mul(_incomingEthereum, __bC), 1000);\n', '            referralBalance_[_r2] = SafeMath.add(referralBalance_[_r2], _b);\n', '            addReferralProfit(_r2, _r1, _b);\n', '            _dividends = SafeMath.sub(_dividends, _b);\n', '        }\n', '        \n', '        if (canRef(_r3, msg.sender, III_S)) {\n', '            __bC = III_R3;\n', '\n', '            if (etherBalance(_r3) >= V_S) {\n', '                __bC = V_R3;\n', '            } else if (etherBalance(_r3) >= IV_S) {\n', '                __bC = IV_R3;\n', '            }\n', '            \n', '            _b = SafeMath.div(SafeMath.mul(_incomingEthereum, __bC), 1000);\n', '            referralBalance_[_r3] = SafeMath.add(referralBalance_[_r3], _b);\n', '            addReferralProfit(_r3, _r2, _b);\n', '            _dividends = SafeMath.sub(_dividends, _b);\n', '        }\n', '        \n', '        if (canRef(_r4, msg.sender, IV_S)) {\n', '            __bC = IV_R4;\n', '\n', '            if (etherBalance(_r4) >= V_S) {\n', '                __bC = V_R4;\n', '            }\n', '            \n', '            _b = SafeMath.div(SafeMath.mul(_incomingEthereum, __bC), 1000);\n', '            referralBalance_[_r4] = SafeMath.add(referralBalance_[_r4], _b);\n', '            addReferralProfit(_r4, _r3, _b);\n', '            _dividends = SafeMath.sub(_dividends, _b);\n', '        }\n', '        \n', '        if (canRef(_r5, msg.sender, V_S)) {\n', '            _b = SafeMath.div(SafeMath.mul(_incomingEthereum, V_R5), 1000);\n', '            referralBalance_[_r5] = SafeMath.add(referralBalance_[_r5], _b);\n', '            addReferralProfit(_r5, _r4, _b);\n', '            _dividends = SafeMath.sub(_dividends, _b);\n', '        }\n', '\n', '        uint256 _amountOfTokens = ethereumToTokens_(SafeMath.sub(_incomingEthereum, _undividedDividends));\n', '        uint256 _fee = _dividends * magnitude;\n', '\n', '        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '        if (tokenSupply_ > 0) {\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '            profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n', '            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n', '        } else {\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '\n', '        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\n', '        payoutsTo_[msg.sender] += (int256) (profitPerShare_ * _amountOfTokens - _fee);\n', '        emit onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, now, buyPrice());\n', '    }\n', '\n', '    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256) {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '            (\n', '                (\n', '                    SafeMath.sub(\n', '                        (sqrt\n', '                            (\n', '                                (_tokenPriceInitial ** 2)\n', '                                +\n', '                                (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\n', '                                +\n', '                                ((tokenPriceIncremental_ ** 2) * (tokenSupply_ ** 2))\n', '                                +\n', '                                (2 * tokenPriceIncremental_ * _tokenPriceInitial*tokenSupply_)\n', '                            )\n', '                        ), _tokenPriceInitial\n', '                    )\n', '                ) / (tokenPriceIncremental_)\n', '            ) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    function sellPriceAt(uint256 _atSupply) public view returns (uint256) {\n', '        if (_atSupply == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereumAtSupply_(1e18, _atSupply);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', ' \n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '   \n', '    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256) {\n', '        return tokensToEthereumAtSupply_(_tokens, tokenSupply_);\n', '    }\n', ' \n', '    function tokensToEthereumAtSupply_(uint256 _tokens, uint256 _atSupply) public view returns (uint256) {\n', '        if (_tokens < 0.00000001 ether) {\n', '            return 0;\n', '        }\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (_atSupply + 1e18);\n', '        uint256 _etherReceived =\n', '            (\n', '                SafeMath.sub(\n', '                    (\n', '                        (\n', '                            (\n', '                                tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n', '                            ) - tokenPriceIncremental_\n', '                        ) * (tokens_ - 1e18)\n', '                    ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\n', '                )\n', '                / 1e18);\n', ' \n', '        return _etherReceived;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = (x + 1) / 2;\n', '        y = x;\n', '\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '    \n', '    mapping(address => mapping(address => uint256)) internal referralProfit_;\n', '    \n', '    function addReferralProfit(address _referredBy, address _referral, uint256 _profit) internal {\n', '        referralProfit_[_referredBy][_referral] += _profit;\n', '        summaryReferralProfit_[_referredBy] += _profit;\n', '    }\n', '    \n', '    function getReferralProfit(address _referredBy, address _referral) public view returns (uint256) {\n', '        return referralProfit_[_referredBy][_referral];\n', '    }\n', '    \n', '    function getSummaryReferralProfit(address _referredBy) public view returns (uint256) {\n', '        if (_ownerAddress == _referredBy) {\n', '            return 0;\n', '        } else {\n', '            return summaryReferralProfit_[_referredBy];\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']