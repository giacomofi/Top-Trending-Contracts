['pragma solidity ^0.4.23;\n', '\n', 'contract Admin {\n', '\n', '\taddress public\tadmin;\n', '\taddress public\tfeeAccount; // address feeAccount, which will receive fee.\n', '\taddress public \tnextVersionAddress; // this is next address exchange\n', '\tbool \tpublic\torderEnd; // this is var use when Admin want close exchange\n', '\tstring  public \tversion; // number version example 1.0, test_1.0\n', '\tuint \tpublic\tfeeTake; //percentage times (1 ether)\n', '\tbool\tpublic\tpause;\n', '\n', '\tmodifier assertAdmin() {\n', '\t\tif ( msg.sender != admin ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\t_;\n', '\t}\n', '\n', '\t/*\n', '\t*\tThis is function, is needed to change address admin.\n', '\t*/\n', '\tfunction setAdmin( address _admin ) assertAdmin public {\n', '\t\tadmin = _admin;\n', '\t}\n', '\tfunction setPause (bool state) assertAdmin public {\n', '\t\tpause = state;\n', '\t}\n', '\t/*\n', '\t* \tThis is function, is needed to change version smart-contract.\n', '\t*/\n', '\tfunction setVersion(string _version) assertAdmin public {\n', '\t\tversion = _version;\t\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to set address, next smart-contracts.\n', '\t*/\n', '\tfunction setNextVersionAddress(address _nextVersionAddress) assertAdmin public{\n', '\t\tnextVersionAddress = _nextVersionAddress;\t\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to stop, news orders.\n', '\t*\tCan not turn off it.\n', '\t*/\n', '\tfunction setOrderEnd() assertAdmin public {\n', '\t\torderEnd = true;\n', '\t}\n', '\n', '\t/*\n', '\t*\tThis is function, is needed to change address feeAccount.\n', '\t*/\n', '\tfunction setFeeAccount( address _feeAccount ) assertAdmin public {\n', '\t\tfeeAccount = _feeAccount;\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to set new fee.\n', '\t*\tCan only be changed down.\n', '\t*/\n', '\t\n', '\tfunction setFeeTake( uint _feeTake ) assertAdmin public {\n', '\t\tfeeTake = _feeTake;\n', '\t}\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeMul( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tuint \tc;\n', '\t\t\n', '\t\tc = a * b;\n', '\t\tassert( a == 0 || c / a == b );\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeSub( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tassert( b <= a );\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tuint \tc;\n', '\t\n', '\t\tc = a + b;\n', '\t\tassert( c >= a && c >= b );\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '/*\n', '* Interface ERC20\n', '*/\n', '\n', 'contract Token {\n', '\n', '\tfunction transfer( address _to, uint256 _value ) public returns ( bool success );\n', '\t\n', '\tfunction transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success );\n', '\t\n', '\tevent Transfer( address indexed _from, address indexed _to, uint256 _value );\n', '\n', '}\n', '\n', 'contract Exchange is SafeMath, Admin {\n', '\n', '\tmapping( address => mapping( address => uint )) public tokens;\n', '\tmapping( address => mapping( bytes32 => bool )) public orders;\n', '\tmapping( bytes32 => mapping( address => uint )) public ordersBalance;\n', '\n', '\tevent Deposit( address token, address user, uint amount, uint balance );\n', '\tevent Withdraw( address token, address user, uint amount, uint balance );\n', '\tevent Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce );\n', '\tevent OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce );\n', '\tevent Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder );\n', '\tevent HashOutput(bytes32 hash);\n', '\n', '\tconstructor( address _admin, address _feeAccount, uint _feeTake, string _version) public {\n', '\t\tadmin = _admin;\n', '\t\tfeeAccount = _feeAccount;\n', '\t\tfeeTake = _feeTake;\n', '\t\torderEnd = false;\n', '\t\tversion = _version;\n', '\t\tpause = false;\n', '\t}\n', '\n', ' \tfunction \tdepositEth() payable public {\n', ' \t\tassertQuantity( msg.value );\n', '\t\ttokens[0][msg.sender] = safeAdd( tokens[0][msg.sender], msg.value );\n', '\t\temit Deposit( 0, msg.sender, msg.value, tokens[0][msg.sender] );\n', ' \t}\n', '\n', '\tfunction \twithdrawEth( uint amount ) public {\n', '\t\tassertQuantity( amount );\n', '\t\ttokens[0][msg.sender] = safeSub( tokens[0][msg.sender], amount );\n', '\t\tmsg.sender.transfer( amount );\n', '\t\temit Withdraw( 0, msg.sender, amount, tokens[0][msg.sender] );\n', '\t}\n', '\n', '\tfunction \tdepositToken( address token, uint amount ) public {\n', '\t\tassertToken( token );\n', '\t\tassertQuantity( amount );\n', '\t\ttokens[token][msg.sender] = safeAdd( tokens[token][msg.sender], amount );\n', '\t\tif ( Token( token ).transferFrom( msg.sender, this, amount ) == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t    emit\tDeposit( token, msg.sender, amount , tokens[token][msg.sender] );\n', '\t}\n', '\n', '\tfunction \twithdrawToken( address token, uint amount ) public {\n', '\t\tassertToken( token );\n', '\t\tassertQuantity( amount );\n', '\t\tif ( Token( token ).transfer( msg.sender, amount ) == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\ttokens[token][msg.sender] = safeSub( tokens[token][msg.sender], amount ); // уязвимость двойного входа?\n', '\t    emit Withdraw( token, msg.sender, amount, tokens[token][msg.sender] );\n', '\t}\n', '\t\n', '\tfunction \torder( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public {\n', '\t\tbytes32 \thash;\n', '\n', '\t\tassertQuantity( amountTake );\n', '\t\tassertQuantity( amountMake );\n', '\t\tassertCompareBalance( amountMake, tokens[tokenMake][msg.sender] );\n', '\t\tif ( orderEnd == true )\n', '\t\t\trevert();\n', '\t\t\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\t\n', '\t\torders[msg.sender][hash] = true;\n', '\t\ttokens[tokenMake][msg.sender] = safeSub( tokens[tokenMake][msg.sender], amountMake );\n', '\t\tordersBalance[hash][msg.sender] = amountMake;\n', '\n', '\t\temit HashOutput(hash);\n', '\t\temit Order( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce );\n', '\t}\n', '\n', '\tfunction \torderCancel( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public {\n', '\t\tbytes32 \thash;\n', '\n', '\t\tassertQuantity( amountTake );\n', '\t\tassertQuantity( amountMake );\n', '\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\torders[msg.sender][hash] = false;\n', '\n', '\t\ttokens[tokenMake][msg.sender] = safeAdd( tokens[tokenMake][msg.sender], ordersBalance[hash][msg.sender]);\n', '\t\tordersBalance[hash][msg.sender] = 0;\n', '\t\temit OrderCancel( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce );\n', '\t}\n', '\n', '\tfunction \ttrade( address tokenTake, address tokenMake, uint amountTake, uint amountMake, uint nonce, address makeAddress, uint quantityTake ) public { \n', '\n', '\t\tbytes32 \thash;\n', '\t\tuint \t\tamountGiveMake;\n', '\n', '\t\tassertPause();\n', '\t\tassertQuantity( quantityTake );\n', '\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\tassertOrders( makeAddress, hash );\n', '\t\t\n', '\t\tamountGiveMake = safeMul( amountMake, quantityTake ) / amountTake;\n', '\t\tassertCompareBalance ( amountGiveMake, ordersBalance[hash][makeAddress] );\n', '\t\n', '\t\ttradeBalances( tokenTake, tokenMake, amountTake, amountMake, makeAddress, quantityTake, hash);\n', '\t\temit HashOutput(hash);\n', '\t}\n', '\n', '\tfunction \ttradeBalances( address tokenGet, address tokenGive, uint amountGet, uint amountGive, address user, uint amount, bytes32 hash) private {\n', '\t\tuint \t\tfeeTakeXfer;\n', '\t\tuint \t\tamountGiveMake;\n', '\n', '\t\tfeeTakeXfer = safeMul( amount, feeTake ) / ( 1 ether );\n', '\t\tamountGiveMake = safeMul( amountGive, amount ) / amountGet; \n', '\n', '\t\ttokens[tokenGet][msg.sender] = safeSub( tokens[tokenGet][msg.sender], safeAdd( amount, feeTakeXfer ) );\n', '\t\ttokens[tokenGet][user] = safeAdd( tokens[tokenGet][user], amount );\n', '\t\ttokens[tokenGet][feeAccount] = safeAdd( tokens[tokenGet][feeAccount], feeTakeXfer );\n', '\t\tordersBalance[hash][user] = safeSub( ordersBalance[hash][user], safeMul( amountGive, amount ) / amountGet );\n', '\t\ttokens[tokenGive][msg.sender] = safeAdd( tokens[tokenGive][msg.sender], safeMul( amountGive, amount ) / amountGet );\n', '\n', '\t\temit Trade( user, tokenGive, amountGiveMake, msg.sender, tokenGet, amount, feeTakeXfer, ordersBalance[hash][user] );\n', '\t\temit HashOutput(hash);\n', '\t}\n', '\n', '\tfunction \tassertQuantity( uint amount ) pure private {\n', '\t\tif ( amount == 0 ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction\tassertPause() view private {\n', '\t\tif ( pause == true ) {\n', '\t\t\trevert();\n', '\t\t}\t\n', '\t}\n', '\n', '\tfunction \tassertToken( address token ) pure private { \n', '\t\tif ( token == 0 ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\n', '\tfunction \tassertOrders( address makeAddress, bytes32 hash ) view private {\n', '\t\tif ( orders[makeAddress][hash] == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction \tassertCompareBalance( uint a, uint b ) pure private {\n', '\t\tif ( a > b ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Admin {\n', '\n', '\taddress public\tadmin;\n', '\taddress public\tfeeAccount; // address feeAccount, which will receive fee.\n', '\taddress public \tnextVersionAddress; // this is next address exchange\n', '\tbool \tpublic\torderEnd; // this is var use when Admin want close exchange\n', '\tstring  public \tversion; // number version example 1.0, test_1.0\n', '\tuint \tpublic\tfeeTake; //percentage times (1 ether)\n', '\tbool\tpublic\tpause;\n', '\n', '\tmodifier assertAdmin() {\n', '\t\tif ( msg.sender != admin ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\t_;\n', '\t}\n', '\n', '\t/*\n', '\t*\tThis is function, is needed to change address admin.\n', '\t*/\n', '\tfunction setAdmin( address _admin ) assertAdmin public {\n', '\t\tadmin = _admin;\n', '\t}\n', '\tfunction setPause (bool state) assertAdmin public {\n', '\t\tpause = state;\n', '\t}\n', '\t/*\n', '\t* \tThis is function, is needed to change version smart-contract.\n', '\t*/\n', '\tfunction setVersion(string _version) assertAdmin public {\n', '\t\tversion = _version;\t\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to set address, next smart-contracts.\n', '\t*/\n', '\tfunction setNextVersionAddress(address _nextVersionAddress) assertAdmin public{\n', '\t\tnextVersionAddress = _nextVersionAddress;\t\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to stop, news orders.\n', '\t*\tCan not turn off it.\n', '\t*/\n', '\tfunction setOrderEnd() assertAdmin public {\n', '\t\torderEnd = true;\n', '\t}\n', '\n', '\t/*\n', '\t*\tThis is function, is needed to change address feeAccount.\n', '\t*/\n', '\tfunction setFeeAccount( address _feeAccount ) assertAdmin public {\n', '\t\tfeeAccount = _feeAccount;\n', '\t}\n', '\n', '\t/*\n', '\t* \tThis is function, is needed to set new fee.\n', '\t*\tCan only be changed down.\n', '\t*/\n', '\t\n', '\tfunction setFeeTake( uint _feeTake ) assertAdmin public {\n', '\t\tfeeTake = _feeTake;\n', '\t}\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeMul( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tuint \tc;\n', '\t\t\n', '\t\tc = a * b;\n', '\t\tassert( a == 0 || c / a == b );\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeSub( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tassert( b <= a );\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd( uint a, uint b ) pure internal returns ( uint ) {\n', '\t\t\n', '\t\tuint \tc;\n', '\t\n', '\t\tc = a + b;\n', '\t\tassert( c >= a && c >= b );\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '/*\n', '* Interface ERC20\n', '*/\n', '\n', 'contract Token {\n', '\n', '\tfunction transfer( address _to, uint256 _value ) public returns ( bool success );\n', '\t\n', '\tfunction transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success );\n', '\t\n', '\tevent Transfer( address indexed _from, address indexed _to, uint256 _value );\n', '\n', '}\n', '\n', 'contract Exchange is SafeMath, Admin {\n', '\n', '\tmapping( address => mapping( address => uint )) public tokens;\n', '\tmapping( address => mapping( bytes32 => bool )) public orders;\n', '\tmapping( bytes32 => mapping( address => uint )) public ordersBalance;\n', '\n', '\tevent Deposit( address token, address user, uint amount, uint balance );\n', '\tevent Withdraw( address token, address user, uint amount, uint balance );\n', '\tevent Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce );\n', '\tevent OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce );\n', '\tevent Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder );\n', '\tevent HashOutput(bytes32 hash);\n', '\n', '\tconstructor( address _admin, address _feeAccount, uint _feeTake, string _version) public {\n', '\t\tadmin = _admin;\n', '\t\tfeeAccount = _feeAccount;\n', '\t\tfeeTake = _feeTake;\n', '\t\torderEnd = false;\n', '\t\tversion = _version;\n', '\t\tpause = false;\n', '\t}\n', '\n', ' \tfunction \tdepositEth() payable public {\n', ' \t\tassertQuantity( msg.value );\n', '\t\ttokens[0][msg.sender] = safeAdd( tokens[0][msg.sender], msg.value );\n', '\t\temit Deposit( 0, msg.sender, msg.value, tokens[0][msg.sender] );\n', ' \t}\n', '\n', '\tfunction \twithdrawEth( uint amount ) public {\n', '\t\tassertQuantity( amount );\n', '\t\ttokens[0][msg.sender] = safeSub( tokens[0][msg.sender], amount );\n', '\t\tmsg.sender.transfer( amount );\n', '\t\temit Withdraw( 0, msg.sender, amount, tokens[0][msg.sender] );\n', '\t}\n', '\n', '\tfunction \tdepositToken( address token, uint amount ) public {\n', '\t\tassertToken( token );\n', '\t\tassertQuantity( amount );\n', '\t\ttokens[token][msg.sender] = safeAdd( tokens[token][msg.sender], amount );\n', '\t\tif ( Token( token ).transferFrom( msg.sender, this, amount ) == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t    emit\tDeposit( token, msg.sender, amount , tokens[token][msg.sender] );\n', '\t}\n', '\n', '\tfunction \twithdrawToken( address token, uint amount ) public {\n', '\t\tassertToken( token );\n', '\t\tassertQuantity( amount );\n', '\t\tif ( Token( token ).transfer( msg.sender, amount ) == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\ttokens[token][msg.sender] = safeSub( tokens[token][msg.sender], amount ); // уязвимость двойного входа?\n', '\t    emit Withdraw( token, msg.sender, amount, tokens[token][msg.sender] );\n', '\t}\n', '\t\n', '\tfunction \torder( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public {\n', '\t\tbytes32 \thash;\n', '\n', '\t\tassertQuantity( amountTake );\n', '\t\tassertQuantity( amountMake );\n', '\t\tassertCompareBalance( amountMake, tokens[tokenMake][msg.sender] );\n', '\t\tif ( orderEnd == true )\n', '\t\t\trevert();\n', '\t\t\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\t\n', '\t\torders[msg.sender][hash] = true;\n', '\t\ttokens[tokenMake][msg.sender] = safeSub( tokens[tokenMake][msg.sender], amountMake );\n', '\t\tordersBalance[hash][msg.sender] = amountMake;\n', '\n', '\t\temit HashOutput(hash);\n', '\t\temit Order( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce );\n', '\t}\n', '\n', '\tfunction \torderCancel( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public {\n', '\t\tbytes32 \thash;\n', '\n', '\t\tassertQuantity( amountTake );\n', '\t\tassertQuantity( amountMake );\n', '\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\torders[msg.sender][hash] = false;\n', '\n', '\t\ttokens[tokenMake][msg.sender] = safeAdd( tokens[tokenMake][msg.sender], ordersBalance[hash][msg.sender]);\n', '\t\tordersBalance[hash][msg.sender] = 0;\n', '\t\temit OrderCancel( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce );\n', '\t}\n', '\n', '\tfunction \ttrade( address tokenTake, address tokenMake, uint amountTake, uint amountMake, uint nonce, address makeAddress, uint quantityTake ) public { \n', '\n', '\t\tbytes32 \thash;\n', '\t\tuint \t\tamountGiveMake;\n', '\n', '\t\tassertPause();\n', '\t\tassertQuantity( quantityTake );\n', '\n', '\t\thash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce );\n', '\t\tassertOrders( makeAddress, hash );\n', '\t\t\n', '\t\tamountGiveMake = safeMul( amountMake, quantityTake ) / amountTake;\n', '\t\tassertCompareBalance ( amountGiveMake, ordersBalance[hash][makeAddress] );\n', '\t\n', '\t\ttradeBalances( tokenTake, tokenMake, amountTake, amountMake, makeAddress, quantityTake, hash);\n', '\t\temit HashOutput(hash);\n', '\t}\n', '\n', '\tfunction \ttradeBalances( address tokenGet, address tokenGive, uint amountGet, uint amountGive, address user, uint amount, bytes32 hash) private {\n', '\t\tuint \t\tfeeTakeXfer;\n', '\t\tuint \t\tamountGiveMake;\n', '\n', '\t\tfeeTakeXfer = safeMul( amount, feeTake ) / ( 1 ether );\n', '\t\tamountGiveMake = safeMul( amountGive, amount ) / amountGet; \n', '\n', '\t\ttokens[tokenGet][msg.sender] = safeSub( tokens[tokenGet][msg.sender], safeAdd( amount, feeTakeXfer ) );\n', '\t\ttokens[tokenGet][user] = safeAdd( tokens[tokenGet][user], amount );\n', '\t\ttokens[tokenGet][feeAccount] = safeAdd( tokens[tokenGet][feeAccount], feeTakeXfer );\n', '\t\tordersBalance[hash][user] = safeSub( ordersBalance[hash][user], safeMul( amountGive, amount ) / amountGet );\n', '\t\ttokens[tokenGive][msg.sender] = safeAdd( tokens[tokenGive][msg.sender], safeMul( amountGive, amount ) / amountGet );\n', '\n', '\t\temit Trade( user, tokenGive, amountGiveMake, msg.sender, tokenGet, amount, feeTakeXfer, ordersBalance[hash][user] );\n', '\t\temit HashOutput(hash);\n', '\t}\n', '\n', '\tfunction \tassertQuantity( uint amount ) pure private {\n', '\t\tif ( amount == 0 ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction\tassertPause() view private {\n', '\t\tif ( pause == true ) {\n', '\t\t\trevert();\n', '\t\t}\t\n', '\t}\n', '\n', '\tfunction \tassertToken( address token ) pure private { \n', '\t\tif ( token == 0 ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\n', '\tfunction \tassertOrders( address makeAddress, bytes32 hash ) view private {\n', '\t\tif ( orders[makeAddress][hash] == false ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction \tassertCompareBalance( uint a, uint b ) pure private {\n', '\t\tif ( a > b ) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '}']
