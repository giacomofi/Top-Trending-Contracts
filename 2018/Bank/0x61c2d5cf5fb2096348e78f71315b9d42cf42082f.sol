['pragma solidity ^0.4.16;\n', '\n', 'contract TestERC721 {\n', '    \n', '    address private _admin;\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint) private balances;\n', '    uint256 private index;\n', '\n', '    mapping(uint256 => address) private tokenOwners;\n', '    mapping(uint256 => bool) private tokenExists;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    mapping(uint256 => token) tokens;\n', '\n', '    struct token {\n', '        string name;\n', '        string link;\n', '        uint256 price;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    constructor() public {\n', '        _admin = 0xa06507041083cFfC7aB1E89f3c59d0AD49Bf384D;\n', '    }\n', '    \n', '    function admin() public constant returns (address) {\n', '        return _admin;\n', '    }\n', '    \n', '    function name() public pure returns (string) {\n', '        return "Test Token";\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return "TTE";\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _address) public constant returns (uint) {\n', '        return balances[_address];\n', '    }\n', '\n', '    function changeAdmin(address _address) public {\n', '        require(msg.sender == _admin);\n', '        _admin = _address;\n', '    }\n', '    function ownerOf(uint256 _tokenId) public constant returns (address) {\n', '        require(tokenExists[_tokenId]);\n', '        return tokenOwners[_tokenId];\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public {\n', '        require(msg.sender == ownerOf(_tokenId));\n', '        require(msg.sender != _to);\n', '        allowed[msg.sender][_to] = _tokenId;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(tokenExists[_tokenId]);\n', '        address oldOwner = ownerOf(_tokenId);\n', '        address newOwner = msg.sender;\n', '        require(newOwner != oldOwner);\n', '        require(allowed[oldOwner][newOwner] == _tokenId);\n', '        balances[oldOwner] -= 1;\n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public {\n', '        address currentOwner = msg.sender;\n', '        address newOwner = _to;\n', '        require(tokenExists[_tokenId]);\n', '        require(currentOwner == ownerOf(_tokenId));\n', '        require(currentOwner != newOwner);\n', '        require(newOwner != address(0));\n', '        balances[currentOwner] -= 1;\n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(currentOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function tokenMetadata(uint256 _tokenId) public constant returns (string, string, uint256) {\n', '        return (tokens[_tokenId].name, tokens[_tokenId].link, tokens[_tokenId].price);\n', '    }\n', '    \n', '    function createtoken(string _name, string _link, uint256 _price) public returns (bool success) {\n', '        require(msg.sender == _admin);\n', '        tokens[index] = token(_name, _link, _price);\n', '        tokenOwners[index] = msg.sender;\n', '        tokenExists[index] = true;\n', '        index += 1;\n', '        balances[msg.sender] += 1;\n', '        _totalSupply += 1;\n', '        return true;\n', '    }\n', '\n', '    function updatetoken(uint256 _tokenId, string _name, string _link, uint256 _price) public returns (bool success) {\n', '        require(tokenExists[_tokenId]);\n', '        tokens[_tokenId] = token(_name, _link, _price);\n', '        return true;\n', '    }\n', '\n', '    function buytoken(uint256 _tokenId) payable public {\n', '        address newOwner = msg.sender;\n', '        address oldOwner = tokenOwners[_tokenId];\n', '        require(tokenExists[_tokenId]);\n', '        require(newOwner != ownerOf(_tokenId));\n', '        require(msg.value >= tokens[_tokenId].price);\n', '        uint256 _remainder = msg.value - tokens[_tokenId].price;\n', '        newOwner.transfer(_remainder);\n', '        uint256 price20 = tokens[_tokenId].price/5;\n', '        _admin.transfer(price20/20);\n', '        oldOwner.transfer(tokens[_tokenId].price - price20/20);\n', '        tokens[_tokenId].price += price20; \n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[oldOwner] -= 1;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract TestERC721 {\n', '    \n', '    address private _admin;\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint) private balances;\n', '    uint256 private index;\n', '\n', '    mapping(uint256 => address) private tokenOwners;\n', '    mapping(uint256 => bool) private tokenExists;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    mapping(uint256 => token) tokens;\n', '\n', '    struct token {\n', '        string name;\n', '        string link;\n', '        uint256 price;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    constructor() public {\n', '        _admin = 0xa06507041083cFfC7aB1E89f3c59d0AD49Bf384D;\n', '    }\n', '    \n', '    function admin() public constant returns (address) {\n', '        return _admin;\n', '    }\n', '    \n', '    function name() public pure returns (string) {\n', '        return "Test Token";\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return "TTE";\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _address) public constant returns (uint) {\n', '        return balances[_address];\n', '    }\n', '\n', '    function changeAdmin(address _address) public {\n', '        require(msg.sender == _admin);\n', '        _admin = _address;\n', '    }\n', '    function ownerOf(uint256 _tokenId) public constant returns (address) {\n', '        require(tokenExists[_tokenId]);\n', '        return tokenOwners[_tokenId];\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public {\n', '        require(msg.sender == ownerOf(_tokenId));\n', '        require(msg.sender != _to);\n', '        allowed[msg.sender][_to] = _tokenId;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        require(tokenExists[_tokenId]);\n', '        address oldOwner = ownerOf(_tokenId);\n', '        address newOwner = msg.sender;\n', '        require(newOwner != oldOwner);\n', '        require(allowed[oldOwner][newOwner] == _tokenId);\n', '        balances[oldOwner] -= 1;\n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public {\n', '        address currentOwner = msg.sender;\n', '        address newOwner = _to;\n', '        require(tokenExists[_tokenId]);\n', '        require(currentOwner == ownerOf(_tokenId));\n', '        require(currentOwner != newOwner);\n', '        require(newOwner != address(0));\n', '        balances[currentOwner] -= 1;\n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(currentOwner, newOwner, _tokenId);\n', '    }\n', '\n', '    function tokenMetadata(uint256 _tokenId) public constant returns (string, string, uint256) {\n', '        return (tokens[_tokenId].name, tokens[_tokenId].link, tokens[_tokenId].price);\n', '    }\n', '    \n', '    function createtoken(string _name, string _link, uint256 _price) public returns (bool success) {\n', '        require(msg.sender == _admin);\n', '        tokens[index] = token(_name, _link, _price);\n', '        tokenOwners[index] = msg.sender;\n', '        tokenExists[index] = true;\n', '        index += 1;\n', '        balances[msg.sender] += 1;\n', '        _totalSupply += 1;\n', '        return true;\n', '    }\n', '\n', '    function updatetoken(uint256 _tokenId, string _name, string _link, uint256 _price) public returns (bool success) {\n', '        require(tokenExists[_tokenId]);\n', '        tokens[_tokenId] = token(_name, _link, _price);\n', '        return true;\n', '    }\n', '\n', '    function buytoken(uint256 _tokenId) payable public {\n', '        address newOwner = msg.sender;\n', '        address oldOwner = tokenOwners[_tokenId];\n', '        require(tokenExists[_tokenId]);\n', '        require(newOwner != ownerOf(_tokenId));\n', '        require(msg.value >= tokens[_tokenId].price);\n', '        uint256 _remainder = msg.value - tokens[_tokenId].price;\n', '        newOwner.transfer(_remainder);\n', '        uint256 price20 = tokens[_tokenId].price/5;\n', '        _admin.transfer(price20/20);\n', '        oldOwner.transfer(tokens[_tokenId].price - price20/20);\n', '        tokens[_tokenId].price += price20; \n', '        tokenOwners[_tokenId] = newOwner;\n', '        balances[oldOwner] -= 1;\n', '        balances[newOwner] += 1;\n', '        emit Transfer(oldOwner, newOwner, _tokenId);\n', '    }\n', '}']
