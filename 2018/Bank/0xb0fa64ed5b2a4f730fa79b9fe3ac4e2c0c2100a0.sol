['pragma solidity ^0.4.25;\n', '\n', 'contract IMDEX {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    function transfer(address _to, uint256 _value)public returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract IMDEXchange is SafeMath {\n', '\n', '  address public owner;\n', '  mapping (address => uint256) public invalidOrder;\n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function IMDEXsetOwner(address newOwner)public onlyOwner {\n', '    emit SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  function IMDEXinvalidateOrdersBefore(address user, uint256 nonce) public onlyAdmin {\n', '    require(nonce > invalidOrder[user]);\n', '    invalidOrder[user] = nonce;\n', '  }\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\n', '  mapping (address => bool) public admins;\n', '  mapping (address => uint256) public lastActiveTransaction;\n', '  address public feeAccount;\n', '  uint256 public inactivityReleasePeriod;\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '\n', '  function IMDEXsetInactivityReleasePeriod(uint256 expiry) public onlyAdmin returns (bool success) {\n', '    require(expiry < 1000000);\n', '    inactivityReleasePeriod = expiry;\n', '    return true;\n', '  }\n', '\n', '  constructor(address feeAccount_) public {\n', '    owner = msg.sender;\n', '    feeAccount = feeAccount_;\n', '    inactivityReleasePeriod = 100000;\n', '  }\n', '\n', '  function IMDEXsetAdmin(address admin, bool isAdmin) public onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '   require(msg.sender == owner && admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function() external {\n', '    revert();\n', '  }\n', '\n', '\n', '\n', '  function IMDEXdepositToken(address token, uint256 amount) public {\n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    require(IMDEX(token).transferFrom(msg.sender, this, amount));\n', '    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function IMDEXdeposit() public payable {\n', '    tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', 'function IMDEXwithdrawToken(address token, uint256 amount) public returns (bool) {\n', '    require(safeSub(block.number, lastActiveTransaction[msg.sender]) > inactivityReleasePeriod);\n', '    require(tokens[token][msg.sender] > amount);\n', '    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '    if (token == address(0)) {\n', '      msg.sender.transfer(amount);\n', '    } else {\n', '      require(IMDEX(token).transfer(msg.sender, amount));\n', '    }\n', '    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function IMDEXadminWithdraw(address token, uint256 amount, address user, uint256 feeWithdrawal) public onlyAdmin returns (bool) {\n', '    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n', '    require(tokens[token][user] > amount);\n', '    tokens[token][user] = safeSub(tokens[token][user], amount);\n', '    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n', '    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n', '    if (token == address(0)) {\n', '      user.transfer(amount);\n', '    } else {\n', '      require(IMDEX(token).transfer(user, amount));\n', '    }\n', '    lastActiveTransaction[user] = block.number;\n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '  }\n', '\n', '  function balanceOf(address token, address user) public constant returns (uint256) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  function IMDEXtrade(uint256[8] X, address[4] Y) public onlyAdmin returns (bool) {\n', '    /* amount is in amountBuy terms */\n', '    /* X\n', '       [0] amountBuy\n', '       [1] amountSell\n', '       [2] expires\n', '       [3] nonce\n', '       [4] amount\n', '       [5] tradeNonce\n', '       [6] feeMake\n', '       [7] feeTake\n', '     Y\n', '       [0] tokenBuy\n', '       [1] tokenSell\n', '       [2] maker\n', '       [3] taker\n', '     */\n', '    require(invalidOrder[Y[2]] < X[3]);\n', '    if (X[6] > 100 finney) X[6] = 100 finney;\n', '    if (X[7] > 100 finney) X[7] = 100 finney;\n', '    require(tokens[Y[0]][Y[3]] > X[4]);\n', '    require(tokens[Y[1]][Y[2]] > (safeMul(X[1], X[4]) / X[0]));\n', '    tokens[Y[0]][Y[3]] = safeSub(tokens[Y[0]][Y[3]], X[4]);\n', '    tokens[Y[0]][Y[2]] = safeAdd(tokens[Y[0]][Y[2]], safeMul(X[4], ((1 ether) - X[6])) / (1 ether));\n', '    tokens[Y[0]][feeAccount] = safeAdd(tokens[Y[0]][feeAccount], safeMul(X[4], X[6]) / (1 ether));\n', '    tokens[Y[1]][Y[2]] = safeSub(tokens[Y[1]][Y[2]], safeMul(X[1], X[4]) / X[0]);\n', '    tokens[Y[1]][Y[3]] = safeAdd(tokens[Y[1]][Y[3]], safeMul(safeMul(((1 ether) - X[7]), X[1]), X[4]) / X[0] / (1 ether));\n', '    tokens[Y[1]][feeAccount] = safeAdd(tokens[Y[1]][feeAccount], safeMul(safeMul(X[7], X[1]), X[4]) / X[0] / (1 ether));\n', '    lastActiveTransaction[Y[2]] = block.number;\n', '    lastActiveTransaction[Y[3]] = block.number;\n', '  }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract IMDEX {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    function transfer(address _to, uint256 _value)public returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract IMDEXchange is SafeMath {\n', '\n', '  address public owner;\n', '  mapping (address => uint256) public invalidOrder;\n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function IMDEXsetOwner(address newOwner)public onlyOwner {\n', '    emit SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  function IMDEXinvalidateOrdersBefore(address user, uint256 nonce) public onlyAdmin {\n', '    require(nonce > invalidOrder[user]);\n', '    invalidOrder[user] = nonce;\n', '  }\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\n', '  mapping (address => bool) public admins;\n', '  mapping (address => uint256) public lastActiveTransaction;\n', '  address public feeAccount;\n', '  uint256 public inactivityReleasePeriod;\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '\n', '  function IMDEXsetInactivityReleasePeriod(uint256 expiry) public onlyAdmin returns (bool success) {\n', '    require(expiry < 1000000);\n', '    inactivityReleasePeriod = expiry;\n', '    return true;\n', '  }\n', '\n', '  constructor(address feeAccount_) public {\n', '    owner = msg.sender;\n', '    feeAccount = feeAccount_;\n', '    inactivityReleasePeriod = 100000;\n', '  }\n', '\n', '  function IMDEXsetAdmin(address admin, bool isAdmin) public onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '   require(msg.sender == owner && admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function() external {\n', '    revert();\n', '  }\n', '\n', '\n', '\n', '  function IMDEXdepositToken(address token, uint256 amount) public {\n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    require(IMDEX(token).transferFrom(msg.sender, this, amount));\n', '    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function IMDEXdeposit() public payable {\n', '    tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', 'function IMDEXwithdrawToken(address token, uint256 amount) public returns (bool) {\n', '    require(safeSub(block.number, lastActiveTransaction[msg.sender]) > inactivityReleasePeriod);\n', '    require(tokens[token][msg.sender] > amount);\n', '    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '    if (token == address(0)) {\n', '      msg.sender.transfer(amount);\n', '    } else {\n', '      require(IMDEX(token).transfer(msg.sender, amount));\n', '    }\n', '    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function IMDEXadminWithdraw(address token, uint256 amount, address user, uint256 feeWithdrawal) public onlyAdmin returns (bool) {\n', '    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n', '    require(tokens[token][user] > amount);\n', '    tokens[token][user] = safeSub(tokens[token][user], amount);\n', '    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n', '    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n', '    if (token == address(0)) {\n', '      user.transfer(amount);\n', '    } else {\n', '      require(IMDEX(token).transfer(user, amount));\n', '    }\n', '    lastActiveTransaction[user] = block.number;\n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '  }\n', '\n', '  function balanceOf(address token, address user) public constant returns (uint256) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  function IMDEXtrade(uint256[8] X, address[4] Y) public onlyAdmin returns (bool) {\n', '    /* amount is in amountBuy terms */\n', '    /* X\n', '       [0] amountBuy\n', '       [1] amountSell\n', '       [2] expires\n', '       [3] nonce\n', '       [4] amount\n', '       [5] tradeNonce\n', '       [6] feeMake\n', '       [7] feeTake\n', '     Y\n', '       [0] tokenBuy\n', '       [1] tokenSell\n', '       [2] maker\n', '       [3] taker\n', '     */\n', '    require(invalidOrder[Y[2]] < X[3]);\n', '    if (X[6] > 100 finney) X[6] = 100 finney;\n', '    if (X[7] > 100 finney) X[7] = 100 finney;\n', '    require(tokens[Y[0]][Y[3]] > X[4]);\n', '    require(tokens[Y[1]][Y[2]] > (safeMul(X[1], X[4]) / X[0]));\n', '    tokens[Y[0]][Y[3]] = safeSub(tokens[Y[0]][Y[3]], X[4]);\n', '    tokens[Y[0]][Y[2]] = safeAdd(tokens[Y[0]][Y[2]], safeMul(X[4], ((1 ether) - X[6])) / (1 ether));\n', '    tokens[Y[0]][feeAccount] = safeAdd(tokens[Y[0]][feeAccount], safeMul(X[4], X[6]) / (1 ether));\n', '    tokens[Y[1]][Y[2]] = safeSub(tokens[Y[1]][Y[2]], safeMul(X[1], X[4]) / X[0]);\n', '    tokens[Y[1]][Y[3]] = safeAdd(tokens[Y[1]][Y[3]], safeMul(safeMul(((1 ether) - X[7]), X[1]), X[4]) / X[0] / (1 ether));\n', '    tokens[Y[1]][feeAccount] = safeAdd(tokens[Y[1]][feeAccount], safeMul(safeMul(X[7], X[1]), X[4]) / X[0] / (1 ether));\n', '    lastActiveTransaction[Y[2]] = block.number;\n', '    lastActiveTransaction[Y[3]] = block.number;\n', '  }\n', '}']
