['pragma solidity ^0.4.18;\n', '\n', '//\n', '// LimeEyes\n', '// Decentralized art on the Ethereum blockchain!\n', '// (https://limeeyes.com/)\n', '/*\n', '             ___                  ___        \n', '         .-&#39;&#39;   &#39;&#39;-.          .-&#39;&#39;   &#39;&#39;-.    \n', '       .&#39;           &#39;.      .&#39;           &#39;.  \n', '      /   . -  ;  - . \\    /   . -  ;  - . \\ \n', '     (  &#39; `-._|_,&#39;_,.- )  (  &#39; `-._|_,&#39;_,.- )\n', '      &#39;,,.--_,4"-;_  ,&#39;    &#39;,,.--_,4"-;_  ,&#39; \n', '        &#39;-.;   \\ _.-&#39;        &#39;-.;   \\ _.-&#39;   \n', '            &#39;&#39;&#39;&#39;&#39;                &#39;&#39;&#39;&#39;&#39;       \n', '*/\n', '// Welcome to LimeEyes!\n', '//\n', '// This smart contract allows users to purchase shares of any artwork that&#39;s\n', '// been added to the system and it will pay dividends to all shareholders\n', '// upon the purchasing of new shares! It&#39;s special in the way it works because\n', '// the shares can only be bought in certain amounts and the price of those \n', '// shares is dependant on how many other shares there are already. Each\n', '// artwork starts with 1 share available for purchase and upon each sale,\n', '// the number of shares for purchase will increase by one (1 -> 2 -> 3...),\n', '// each artwork also has an owner and they will always get the dividends from \n', '// the number of shares up for purchase, for example;\n', '/*\n', '    If the artwork has had shares purchased 4 times, the next purchase will\n', '    be for 5 shares of the artwork. Upon the purchasing of these shares, the\n', '    owner will receive the dividends equivelent to 5 shares worth of the sale\n', '    value. It&#39;s also important to note that the artwork owner cannot purchase\n', '    shares of their own art, instead they just inherit the shares for purchase\n', '    and pass it onto the next buyer at each sale.\n', '*/ \n', '// The price of the shares also follows a special formula in order to maintain\n', '// stability over time, it uses the base price of an artwork (set by the dev \n', '// upon the creation of the artwork) and the total number of shares purchased\n', '// of the artwork. From here you simply treat the number of shares as a percentage\n', '// and add that much on top of your base price, for example;\n', '/*\n', '    If the artwork has a base price of 0.01 ETH and there have been 250 shares \n', '    purchased so far, it would mean that the base price will gain 250% of it&#39;s\n', '    value which comes to 0.035 ETH (100% + 250% of the base price).\n', '*/\n', '// The special thing about this is because the shares are intrinsicly linked with\n', '// the price, the dividends from your shares will trend to a constant value instead\n', '// of continually decreasing over time. Because our sequence of shares is a triangular\n', '// number (1 + 2 + 3...) the steady state of any purchased shares will equal the number\n', '// of shares owned (as a percentage) * the artworks base price, for example;\n', '/*\n', '    If the artwork has a base price of 0.01 ETH and you own 5 shares, in the long run\n', '    you should expect to see 5% * 0.01 ETH = 0.0005 ETH each time the artwork has any\n', '    shares purchased. In contrast, if you own 250 shares of the artwork, you should \n', '    expect to see 250% * 0.01 ETH = 0.025 ETH each time the artwork has shares bought.\n', '  \n', '    It&#39;s good to point out that if you were the first buyer and owned 1 share, the next\n', '    buyer is going to be purchasing 2 shares which means you have 1 out of the 3 shares\n', '    total and hence you will receive 33% of that sale, at the next step there will be\n', '    6 shares total and your 1 share is now worth 16% of the sale price, as mentioned\n', '    above though, your earnings upon the purchasing of new shares from your original\n', '    1 share will trend towards 1% of the base price over a long period of time.\n', '*/\n', '//\n', '// If you&#39;re an artist and are interested in listing some of your works on the site\n', '// and in this contract, please visit the website (https://limeeyes.com/) and contact\n', '// the main developer via the links on the site!\n', '//\n', '\n', 'contract LimeEyes {\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Variables, Storage and Events\n', '\n', '\n', '\taddress private _dev;\n', '\n', '\tstruct Artwork {\n', '\t\tstring _title;\n', '\t\taddress _owner;\n', '\t\tbool _visible;\n', '\t\tuint256 _basePrice;\n', '\t\tuint256 _purchases;\n', '\t\taddress[] _shareholders;\n', '\t\tmapping (address => bool) _hasShares;\n', '\t\tmapping (address => uint256) _shares;\n', '\t}\n', '\tArtwork[] private _artworks;\n', '\n', '\tevent ArtworkCreated(\n', '\t\tuint256 artworkId,\n', '\t\tstring title,\n', '\t\taddress owner,\n', '\t\tuint256 basePrice);\n', '\tevent ArtworkSharesPurchased(\n', '\t\tuint256 artworkId,\n', '\t\tstring title,\n', '\t\taddress buyer,\n', '\t\tuint256 sharesBought);\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Constructor and Admin Functions\n', '\n', '\n', '\tfunction LimeEyes() public {\n', '\t\t_dev = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyDev() {\n', '\t\trequire(msg.sender == _dev);\n', '\t\t_;\n', '\t}\n', '\n', '\t// This function will create a new artwork within the contract,\n', '\t// the title is changeable later by the dev but the owner and\n', '\t// basePrice cannot be changed once it&#39;s been created.\n', '\t// The owner of the artwork will start off with 1 share and any\n', '\t// other addresses may now purchase shares for it.\n', '\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n', '\n', '\t\trequire(basePrice != 0);\n', '\t\t_artworks.push(Artwork({\n', '\t\t\t_title: title,\n', '\t\t\t_owner: owner,\n', '\t\t\t_visible: true,\n', '\t\t\t_basePrice: basePrice,\n', '\t\t\t_purchases: 0,\n', '\t\t\t_shareholders: new address[](0)\n', '\t\t}));\n', '\t\tuint256 artworkId = _artworks.length - 1;\n', '\t\tArtwork storage newArtwork = _artworks[artworkId];\n', '\t\tnewArtwork._hasShares[owner] = true;\n', '\t\tnewArtwork._shareholders.push(owner);\n', '\t\tnewArtwork._shares[owner] = 1;\n', '\n', '\t\tArtworkCreated(artworkId, title, owner, basePrice);\n', '\n', '\t}\n', '\n', '\t// Simple renaming function for the artworks, it is good to\n', '\t// keep in mind that when the website syncs with the blockchain,\n', '\t// any titles over 32 characters will be clipped.\n', '\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\t\tartwork._title = newTitle;\n', '\n', '\t}\n', '\n', '\t// This function is only for the website and whether or not\n', '\t// it displays a certain artwork, any user may still buy shares\n', '\t// for an invisible artwork although it&#39;s not really art unless\n', '\t// you can view it.\n', '\t// This is exclusively reserved for copyright cases should any\n', '\t// artworks be flagged as such.\n', '\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\t\tartwork._visible = !artwork._visible;\n', '\n', '\t}\n', '\n', '\t// The two withdrawal functions below are here so that the dev\n', '\t// can access the dividends of the contract if it owns any\n', '\t// artworks. As all ETH is transferred straight away upon the\n', '\t// purchasing of shares, the only ETH left in the contract will\n', '\t// be from dividends or the rounding errors (although the error\n', '\t// will only be a few wei each transaction) due to the nature\n', '\t// of dividing and working with integers.\n', '\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n', '\n', '\t\trequire(amount != 0);\n', '\t\trequire(amount <= this.balance);\n', '\t\ttoAddress.transfer(amount);\n', '\n', '\t}\n', '\n', '\t// Used to empty the contracts balance to an address.\n', '\tfunction withdrawAll(address toAddress) public onlyDev {\n', '\t\ttoAddress.transfer(this.balance);\n', '\t}\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Main Artwork Share Purchasing Function\n', '\n', '\n', '\t// This is the main point of interaction in this contract,\n', '\t// it will allow a user to purchase shares in an artwork\n', '\t// and hence with their investment, they pay dividends to\n', '\t// all the current shareholders and then the user themselves\n', '\t// will become a shareholder and earn dividends on any future\n', '\t// purchases of shares.\n', '\t// See the getArtwork() function for more information on pricing\n', '\t// and how shares work.\n', '\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n', '\n', '\t\t// This makes sure only people, and not contracts, can buy shares.\n', '\t\trequire(msg.sender == tx.origin);\n', '\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\n', '\t\t// The artwork owner is not allowed to purchase shares of their\n', '\t\t// own art, instead they will earn dividends automatically.\n', '\t\trequire(msg.sender != artwork._owner);\n', '\n', '\t\tuint256 totalShares;\n', '\t\tuint256[3] memory prices;\n', '\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n', '\t\tuint256 currentPrice = prices[1];\n', '\n', '\t\t// Make sure the buyer sent enough ETH\n', '\t\trequire(msg.value >= currentPrice);\n', '\n', '\t\t// Send back the excess if there&#39;s any.\n', '\t\tuint256 purchaseExcess = msg.value - currentPrice;\n', '\t\tif (purchaseExcess > 0)\n', '\t\t\tmsg.sender.transfer(purchaseExcess);\n', '\n', '\t\t// Now pay all the shareholders accordingly.\n', '\t\t// (this will potentially cost a lot of gas)\n', '\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n', '\t\t\taddress shareholder = artwork._shareholders[i];\n', '\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn&#39;t this contract\n', '\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// Add the buyer to the registry.\n', '\t\tif (!artwork._hasShares[msg.sender]) {\n', '\t\t\tartwork._hasShares[msg.sender] = true;\n', '\t\t\tartwork._shareholders.push(msg.sender);\n', '\t\t}\n', '\n', '\t\tartwork._purchases++; // track our purchase\n', '\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n', '\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n', '\n', '\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n', '\t\t\n', '\t}\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Getters\n', '\n', '\n', '\tfunction _exists(uint256 artworkId) private view returns (bool) {\n', '\t\treturn artworkId < _artworks.length;\n', '\t}\n', '\n', '\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\n', '\t\tArtwork memory artwork = _artworks[artworkId];\n', '\n', '\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n', '\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n', '\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n', '\t\t// Tn = (n * (n + 1)) / 2\n', '\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n', '\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n', '\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n', '\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n', '\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n', '\t\t// number formula slightly to get;\n', '\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n', '\t\t// Let&#39;s say the art is being purchased for a second time which means the purchaser is\n', '\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n', '\t\t// overall purchase value. As it&#39;s the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n', '\t\t// according to our formula which is as expected.\n', '\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n', '\n', '\t\t// Set up our prices array;\n', '\t\t// 0: base price\n', '\t\t// 1: current price\n', '\t\t// 2: next price\n', '\t\tuint256[3] memory prices;\n', '\t\tprices[0] = artwork._basePrice;\n', '\t\t// The current price is also directly related the total number of shares, it simply treats\n', '\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n', '\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n', '\t\t// that the price would gain 250% of it&#39;s value = 0.035 ETH (100% + 250%);\n', '\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n', '\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n', '\t\t// The next price would just be the same as the current price but we have a few extra shares.\n', '\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n', '\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n', '\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n', '\n', '\t\treturn (\n', '\t\t\t\tartwork._title,\n', '\t\t\t\tartwork._owner,\n', '\t\t\t\tartwork._visible,\n', '\t\t\t\tprices,\n', '\t\t\t\ttotalShares,\n', '\t\t\t\tartwork._purchases,\n', '\t\t\t\tartwork._shareholders.length\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n', '\n', '\t\trequire(_exists(artworkId));\n', '\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\n', '\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n', '\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n', '\t\t\taddress shareholder = artwork._shareholders[i];\n', '\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n', '\t\t}\n', '\n', '\t\treturn (\n', '\t\t\t\tartwork._shareholders,\n', '\t\t\t\tshareholderShares\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n', '\n', '\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n', '\t\taddress[] memory allOwners = new address[](_artworks.length);\n', '\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n', '\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n', '\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n', '\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n', '\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n', '\n', '\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n', '\t\t\tstring memory tmpTitle;\n', '\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n', '\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n', '\t\t}\n', '\n', '\t\treturn (\n', '\t\t\t\tallTitles,\n', '\t\t\t\tallOwners,\n', '\t\t\t\tallIsVisible,\n', '\t\t\t\tallPrices,\n', '\t\t\t\tallShares,\n', '\t\t\t\tallPurchases,\n', '\t\t\t\tallShareholders\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '\t\tbytes memory tmpEmptyStringTest = bytes(source);\n', '\t\tif (tmpEmptyStringTest.length == 0) {\n', '\t\t\treturn 0x0;\n', '\t\t}\n', '\n', '\t\tassembly {\n', '\t\t\tresult := mload(add(source, 32))\n', '\t\t}\n', '\t}\n', '\n', '\t\n', '\t//////////////////////////////////////////////////////////////////////\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '//\n', '// LimeEyes\n', '// Decentralized art on the Ethereum blockchain!\n', '// (https://limeeyes.com/)\n', '/*\n', '             ___                  ___        \n', "         .-''   ''-.          .-''   ''-.    \n", "       .'           '.      .'           '.  \n", '      /   . -  ;  - . \\    /   . -  ;  - . \\ \n', "     (  ' `-._|_,'_,.- )  (  ' `-._|_,'_,.- )\n", '      \',,.--_,4"-;_  ,\'    \',,.--_,4"-;_  ,\' \n', "        '-.;   \\ _.-'        '-.;   \\ _.-'   \n", "            '''''                '''''       \n", '*/\n', '// Welcome to LimeEyes!\n', '//\n', "// This smart contract allows users to purchase shares of any artwork that's\n", '// been added to the system and it will pay dividends to all shareholders\n', "// upon the purchasing of new shares! It's special in the way it works because\n", '// the shares can only be bought in certain amounts and the price of those \n', '// shares is dependant on how many other shares there are already. Each\n', '// artwork starts with 1 share available for purchase and upon each sale,\n', '// the number of shares for purchase will increase by one (1 -> 2 -> 3...),\n', '// each artwork also has an owner and they will always get the dividends from \n', '// the number of shares up for purchase, for example;\n', '/*\n', '    If the artwork has had shares purchased 4 times, the next purchase will\n', '    be for 5 shares of the artwork. Upon the purchasing of these shares, the\n', '    owner will receive the dividends equivelent to 5 shares worth of the sale\n', "    value. It's also important to note that the artwork owner cannot purchase\n", '    shares of their own art, instead they just inherit the shares for purchase\n', '    and pass it onto the next buyer at each sale.\n', '*/ \n', '// The price of the shares also follows a special formula in order to maintain\n', '// stability over time, it uses the base price of an artwork (set by the dev \n', '// upon the creation of the artwork) and the total number of shares purchased\n', '// of the artwork. From here you simply treat the number of shares as a percentage\n', '// and add that much on top of your base price, for example;\n', '/*\n', '    If the artwork has a base price of 0.01 ETH and there have been 250 shares \n', "    purchased so far, it would mean that the base price will gain 250% of it's\n", '    value which comes to 0.035 ETH (100% + 250% of the base price).\n', '*/\n', '// The special thing about this is because the shares are intrinsicly linked with\n', '// the price, the dividends from your shares will trend to a constant value instead\n', '// of continually decreasing over time. Because our sequence of shares is a triangular\n', '// number (1 + 2 + 3...) the steady state of any purchased shares will equal the number\n', '// of shares owned (as a percentage) * the artworks base price, for example;\n', '/*\n', '    If the artwork has a base price of 0.01 ETH and you own 5 shares, in the long run\n', '    you should expect to see 5% * 0.01 ETH = 0.0005 ETH each time the artwork has any\n', '    shares purchased. In contrast, if you own 250 shares of the artwork, you should \n', '    expect to see 250% * 0.01 ETH = 0.025 ETH each time the artwork has shares bought.\n', '  \n', "    It's good to point out that if you were the first buyer and owned 1 share, the next\n", '    buyer is going to be purchasing 2 shares which means you have 1 out of the 3 shares\n', '    total and hence you will receive 33% of that sale, at the next step there will be\n', '    6 shares total and your 1 share is now worth 16% of the sale price, as mentioned\n', '    above though, your earnings upon the purchasing of new shares from your original\n', '    1 share will trend towards 1% of the base price over a long period of time.\n', '*/\n', '//\n', "// If you're an artist and are interested in listing some of your works on the site\n", '// and in this contract, please visit the website (https://limeeyes.com/) and contact\n', '// the main developer via the links on the site!\n', '//\n', '\n', 'contract LimeEyes {\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Variables, Storage and Events\n', '\n', '\n', '\taddress private _dev;\n', '\n', '\tstruct Artwork {\n', '\t\tstring _title;\n', '\t\taddress _owner;\n', '\t\tbool _visible;\n', '\t\tuint256 _basePrice;\n', '\t\tuint256 _purchases;\n', '\t\taddress[] _shareholders;\n', '\t\tmapping (address => bool) _hasShares;\n', '\t\tmapping (address => uint256) _shares;\n', '\t}\n', '\tArtwork[] private _artworks;\n', '\n', '\tevent ArtworkCreated(\n', '\t\tuint256 artworkId,\n', '\t\tstring title,\n', '\t\taddress owner,\n', '\t\tuint256 basePrice);\n', '\tevent ArtworkSharesPurchased(\n', '\t\tuint256 artworkId,\n', '\t\tstring title,\n', '\t\taddress buyer,\n', '\t\tuint256 sharesBought);\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Constructor and Admin Functions\n', '\n', '\n', '\tfunction LimeEyes() public {\n', '\t\t_dev = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyDev() {\n', '\t\trequire(msg.sender == _dev);\n', '\t\t_;\n', '\t}\n', '\n', '\t// This function will create a new artwork within the contract,\n', '\t// the title is changeable later by the dev but the owner and\n', "\t// basePrice cannot be changed once it's been created.\n", '\t// The owner of the artwork will start off with 1 share and any\n', '\t// other addresses may now purchase shares for it.\n', '\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n', '\n', '\t\trequire(basePrice != 0);\n', '\t\t_artworks.push(Artwork({\n', '\t\t\t_title: title,\n', '\t\t\t_owner: owner,\n', '\t\t\t_visible: true,\n', '\t\t\t_basePrice: basePrice,\n', '\t\t\t_purchases: 0,\n', '\t\t\t_shareholders: new address[](0)\n', '\t\t}));\n', '\t\tuint256 artworkId = _artworks.length - 1;\n', '\t\tArtwork storage newArtwork = _artworks[artworkId];\n', '\t\tnewArtwork._hasShares[owner] = true;\n', '\t\tnewArtwork._shareholders.push(owner);\n', '\t\tnewArtwork._shares[owner] = 1;\n', '\n', '\t\tArtworkCreated(artworkId, title, owner, basePrice);\n', '\n', '\t}\n', '\n', '\t// Simple renaming function for the artworks, it is good to\n', '\t// keep in mind that when the website syncs with the blockchain,\n', '\t// any titles over 32 characters will be clipped.\n', '\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\t\tartwork._title = newTitle;\n', '\n', '\t}\n', '\n', '\t// This function is only for the website and whether or not\n', '\t// it displays a certain artwork, any user may still buy shares\n', "\t// for an invisible artwork although it's not really art unless\n", '\t// you can view it.\n', '\t// This is exclusively reserved for copyright cases should any\n', '\t// artworks be flagged as such.\n', '\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\t\tartwork._visible = !artwork._visible;\n', '\n', '\t}\n', '\n', '\t// The two withdrawal functions below are here so that the dev\n', '\t// can access the dividends of the contract if it owns any\n', '\t// artworks. As all ETH is transferred straight away upon the\n', '\t// purchasing of shares, the only ETH left in the contract will\n', '\t// be from dividends or the rounding errors (although the error\n', '\t// will only be a few wei each transaction) due to the nature\n', '\t// of dividing and working with integers.\n', '\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n', '\n', '\t\trequire(amount != 0);\n', '\t\trequire(amount <= this.balance);\n', '\t\ttoAddress.transfer(amount);\n', '\n', '\t}\n', '\n', '\t// Used to empty the contracts balance to an address.\n', '\tfunction withdrawAll(address toAddress) public onlyDev {\n', '\t\ttoAddress.transfer(this.balance);\n', '\t}\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Main Artwork Share Purchasing Function\n', '\n', '\n', '\t// This is the main point of interaction in this contract,\n', '\t// it will allow a user to purchase shares in an artwork\n', '\t// and hence with their investment, they pay dividends to\n', '\t// all the current shareholders and then the user themselves\n', '\t// will become a shareholder and earn dividends on any future\n', '\t// purchases of shares.\n', '\t// See the getArtwork() function for more information on pricing\n', '\t// and how shares work.\n', '\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n', '\n', '\t\t// This makes sure only people, and not contracts, can buy shares.\n', '\t\trequire(msg.sender == tx.origin);\n', '\n', '\t\trequire(_exists(artworkId));\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\n', '\t\t// The artwork owner is not allowed to purchase shares of their\n', '\t\t// own art, instead they will earn dividends automatically.\n', '\t\trequire(msg.sender != artwork._owner);\n', '\n', '\t\tuint256 totalShares;\n', '\t\tuint256[3] memory prices;\n', '\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n', '\t\tuint256 currentPrice = prices[1];\n', '\n', '\t\t// Make sure the buyer sent enough ETH\n', '\t\trequire(msg.value >= currentPrice);\n', '\n', "\t\t// Send back the excess if there's any.\n", '\t\tuint256 purchaseExcess = msg.value - currentPrice;\n', '\t\tif (purchaseExcess > 0)\n', '\t\t\tmsg.sender.transfer(purchaseExcess);\n', '\n', '\t\t// Now pay all the shareholders accordingly.\n', '\t\t// (this will potentially cost a lot of gas)\n', '\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n', '\t\t\taddress shareholder = artwork._shareholders[i];\n', "\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n", '\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// Add the buyer to the registry.\n', '\t\tif (!artwork._hasShares[msg.sender]) {\n', '\t\t\tartwork._hasShares[msg.sender] = true;\n', '\t\t\tartwork._shareholders.push(msg.sender);\n', '\t\t}\n', '\n', '\t\tartwork._purchases++; // track our purchase\n', '\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n', '\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n', '\n', '\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n', '\t\t\n', '\t}\n', '\n', '\n', '\t//////////////////////////////////////////////////////////////////////\n', '\t//  Getters\n', '\n', '\n', '\tfunction _exists(uint256 artworkId) private view returns (bool) {\n', '\t\treturn artworkId < _artworks.length;\n', '\t}\n', '\n', '\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n', '\t\t\n', '\t\trequire(_exists(artworkId));\n', '\n', '\t\tArtwork memory artwork = _artworks[artworkId];\n', '\n', '\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n', '\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n', '\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n', '\t\t// Tn = (n * (n + 1)) / 2\n', '\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n', '\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n', '\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n', '\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n', '\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n', '\t\t// number formula slightly to get;\n', '\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n', "\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n", '\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n', "\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n", '\t\t// according to our formula which is as expected.\n', '\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n', '\n', '\t\t// Set up our prices array;\n', '\t\t// 0: base price\n', '\t\t// 1: current price\n', '\t\t// 2: next price\n', '\t\tuint256[3] memory prices;\n', '\t\tprices[0] = artwork._basePrice;\n', '\t\t// The current price is also directly related the total number of shares, it simply treats\n', '\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n', '\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n', "\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n", '\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n', '\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n', '\t\t// The next price would just be the same as the current price but we have a few extra shares.\n', '\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n', '\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n', '\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n', '\n', '\t\treturn (\n', '\t\t\t\tartwork._title,\n', '\t\t\t\tartwork._owner,\n', '\t\t\t\tartwork._visible,\n', '\t\t\t\tprices,\n', '\t\t\t\ttotalShares,\n', '\t\t\t\tartwork._purchases,\n', '\t\t\t\tartwork._shareholders.length\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n', '\n', '\t\trequire(_exists(artworkId));\n', '\n', '\t\tArtwork storage artwork = _artworks[artworkId];\n', '\n', '\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n', '\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n', '\t\t\taddress shareholder = artwork._shareholders[i];\n', '\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n', '\t\t}\n', '\n', '\t\treturn (\n', '\t\t\t\tartwork._shareholders,\n', '\t\t\t\tshareholderShares\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n', '\n', '\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n', '\t\taddress[] memory allOwners = new address[](_artworks.length);\n', '\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n', '\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n', '\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n', '\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n', '\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n', '\n', '\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n', '\t\t\tstring memory tmpTitle;\n', '\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n', '\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n', '\t\t}\n', '\n', '\t\treturn (\n', '\t\t\t\tallTitles,\n', '\t\t\t\tallOwners,\n', '\t\t\t\tallIsVisible,\n', '\t\t\t\tallPrices,\n', '\t\t\t\tallShares,\n', '\t\t\t\tallPurchases,\n', '\t\t\t\tallShareholders\n', '\t\t\t);\n', '\n', '\t}\n', '\n', '\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '\t\tbytes memory tmpEmptyStringTest = bytes(source);\n', '\t\tif (tmpEmptyStringTest.length == 0) {\n', '\t\t\treturn 0x0;\n', '\t\t}\n', '\n', '\t\tassembly {\n', '\t\t\tresult := mload(add(source, 32))\n', '\t\t}\n', '\t}\n', '\n', '\t\n', '\t//////////////////////////////////////////////////////////////////////\n', '\n', '}']
