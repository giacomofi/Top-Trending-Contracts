['pragma solidity ^0.4.18;\n', '\n', '/*\n', ' * Ownable\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) internal onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title TradeFeeCalculator - Returns the calculated Fee Based on the Trade Value   \n', ' * @dev Fee Calculation contract. All the units are dealt at wei level.\n', ' * @author Dinesh\n', ' */\n', 'contract TradeFeeCalculator is Ownable { \n', '    using SafeMath for uint256; \n', '    \n', '    // array to store optional fee by category: 0 - Base Token Fee, 1 - Ether Fee, 2 - External token Fee\n', '    // its numbers and its for every 1 token/1 Ether (should be only wei values)\n', '    uint256[3] public exFees;\n', '    \n', '    /**\n', '     * @dev constructor sets up owner\n', '     */\n', '    function TradeFeeCalculator() public {\n', '        // set up the owner\n', '        owner = msg.sender; \n', '    }\n', '    \n', '    /**\n', '     * @dev function updates the fees charged by the exchange. Fees will be mentioned per Ether (3792 Wand) \n', '     * @param _baseTokenFee is for the trades who pays fees in Native Tokens\n', '     */\n', '    function updateFeeSchedule(uint256 _baseTokenFee, uint256 _etherFee, uint256 _normalTokenFee) public onlyOwner {\n', '        // Base token fee should not exceed 1 ether worth of tokens (ex: 3792 wand = 1 ether), since 1 ether is our fee unit\n', '        require(_baseTokenFee >= 0 && _baseTokenFee <=  1 * 1 ether);\n', '        \n', '        // If the incoming trade is on Ether, then fee should not exceed 1 Ether\n', '        require(_etherFee >= 0 && _etherFee <=  1 * 1 ether);\n', '       \n', '        // If the incoming trade is on diffrent coins and if the exchange should allow diff tokens as fee, then \n', '        // input must be in wei converted value to suppport decimal - Special Case \n', '        /** Caution: Max value check must be done by Owner who is updating this value */\n', '        require(_normalTokenFee >= 0);\n', '        require(exFees.length == 3);\n', '        \n', '        // Stores the fee structure\n', '        exFees[0] = _baseTokenFee;  \n', '        exFees[1] = _etherFee; \n', '        exFees[2] = _normalTokenFee; \n', '    }\n', '    \n', '    /**\n', '     * @dev function to calculate transaction fees for given value and token\n', '     * @param _value is the given trade overall value\n', '     * @param _feeIndex indicates token pay options\n', '     * @return calculated trade fee\n', '     * Caution: _value is expected to be in wei units and it works for single token payment\n', '     */\n', '    function calcTradeFee(uint256 _value, uint256 _feeIndex) public view returns (uint256) {\n', '        require(_feeIndex >= 0 && _feeIndex <= 2);\n', '        require(_value > 0);\n', '        require(exFees.length == 3 && exFees[_feeIndex] > 0 );\n', '        \n', '        //Calculation Formula TotalFees = (_value * exFees[_feeIndex])/ (1 ether) \n', '        uint256 _totalFees = (_value.mul(exFees[_feeIndex])).div(1 ether);\n', '        \n', '        // Calculated total fee must be gretae than 0 for a given base fee > 0\n', '        require(_totalFees > 0);\n', '        \n', '        return _totalFees;\n', '    } \n', '    \n', '    /**\n', '     * @dev function to calculate transaction fees for given list of values and tokens\n', '     * @param _values is the list of given trade overall values\n', '     * @param _feeIndexes indicates list token pay options for each value \n', '     * @return list of calculated trade fees each value\n', '     * Caution: _values is expected to be in wei units and it works for multiple token payment\n', '     */\n', '    function calcTradeFeeMulti(uint256[] _values, uint256[] _feeIndexes) public view returns (uint256[]) {\n', '        require(_values.length > 0); \n', '        require(_feeIndexes.length > 0);  \n', '        require(_values.length == _feeIndexes.length); \n', '        require(exFees.length == 3);\n', '        \n', '        uint256[] memory _totalFees = new uint256[](_values.length);\n', '        // For Every token Value \n', '        for (uint256 i = 0; i < _values.length; i++){  \n', '            _totalFees[i] =  calcTradeFee(_values[i], _feeIndexes[i]);\n', '        }\n', '        require(_totalFees.length > 0);\n', '        require(_values.length == _totalFees.length);  \n', '        return _totalFees;\n', '    }\n', '}']