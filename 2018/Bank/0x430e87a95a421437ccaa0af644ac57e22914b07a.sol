['pragma solidity ^0.4.3;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "Sender not authorised.");\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC677 is ERC20 {\n', '    function transferAndCall(address to, uint value, bytes data) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '    @title ItMap, a solidity iterable map\n', '    @dev Credit to: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1\n', ' */\n', 'library itmap {\n', '    struct entry {\n', '        // Equal to the index of the key of this item in keys, plus 1.\n', '        uint keyIndex;\n', '        uint value;\n', '    }\n', '\n', '    struct itmap {\n', '        mapping(uint => entry) data;\n', '        uint[] keys;\n', '    }\n', '    \n', '    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\n', '        entry storage e = self.data[key];\n', '        e.value = value;\n', '        if (e.keyIndex > 0) {\n', '            return true;\n', '        } else {\n', '            e.keyIndex = ++self.keys.length;\n', '            self.keys[e.keyIndex - 1] = key;\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function remove(itmap storage self, uint key) internal returns (bool success) {\n', '        entry storage e = self.data[key];\n', '        if (e.keyIndex == 0)\n', '            return false;\n', '        \n', '        if (e.keyIndex < self.keys.length) {\n', '            // Move an existing element into the vacated key slot.\n', '            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\n', '            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\n', '            self.keys.length -= 1;\n', '            delete self.data[key];\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function contains(itmap storage self, uint key) internal view returns (bool exists) {\n', '        return self.data[key].keyIndex > 0;\n', '    }\n', '    \n', '    function size(itmap storage self) internal view returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '    \n', '    function get(itmap storage self, uint key) internal view returns (uint) {\n', '        return self.data[key].value;\n', '    }\n', '    \n', '    function getKey(itmap storage self, uint idx) internal view returns (uint) {\n', '        return self.keys[idx];\n', '    }\n', '}\n', '\n', '/**\n', '    @title PoolOwners, the crowdsale contract for LinkPool ownership\n', ' */\n', 'contract PoolOwners is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    using itmap for itmap.itmap;\n', '\n', '    struct Owner {\n', '        uint256 key;\n', '        uint256 percentage;\n', '        uint256 shareTokens;\n', '        mapping(address => uint256) balance;\n', '    }\n', '    mapping(address => Owner) public owners;\n', '\n', '    struct Distribution {\n', '        address token;\n', '        uint256 amount;\n', '        uint256 owners;\n', '        uint256 claimed;\n', '        mapping(address => bool) claimedAddresses;\n', '    }\n', '    mapping(uint256 => Distribution) public distributions;\n', '\n', '    mapping(address => uint256) public tokenBalance;\n', '    mapping(address => uint256) public totalReturned;\n', '\n', '    mapping(address => bool) private whitelist;\n', '\n', '    itmap.itmap ownerMap;\n', '    \n', '    uint256 public totalContributed     = 0;\n', '    uint256 public totalOwners          = 0;\n', '    uint256 public totalDistributions   = 0;\n', '    bool    public distributionActive   = false;\n', '    uint256 public distributionMinimum  = 20 ether;\n', '    uint256 public precisionMinimum     = 0.04 ether;\n', '    bool    public locked               = false;\n', '    address public wallet;\n', '\n', '    bool    private contributionStarted = false;\n', '    uint256 private valuation           = 4000 ether;\n', '    uint256 private hardCap             = 996.96 ether;\n', '\n', '    event Contribution(address indexed sender, uint256 share, uint256 amount);\n', '    event ClaimedTokens(address indexed owner, address indexed token, uint256 amount, uint256 claimedStakers, uint256 distributionId);\n', '    event TokenDistributionActive(address indexed token, uint256 amount, uint256 distributionId, uint256 amountOfOwners);\n', '    event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount);\n', '    event TokenDistributionComplete(address indexed token, uint256 amountOfOwners);\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev Constructor set set the wallet initally\n', '        @param _wallet Address of the ETH wallet\n', '     */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '        @dev Fallback function, redirects to contribution\n', '        @dev Transfers tokens to LP wallet address\n', '     */\n', '    function() public payable {\n', '        require(contributionStarted, "Contribution phase hasn&#39;t started");\n', '        require(whitelist[msg.sender], "You are not whitelisted");\n', '        contribute(msg.sender, msg.value); \n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '        @dev Manually set a contribution, used by owners to increase owners amounts\n', '        @param _sender The address of the sender to set the contribution for you\n', '        @param _amount The amount that the owner has sent\n', '     */\n', '    function setContribution(address _sender, uint256 _amount) public onlyOwner() { contribute(_sender, _amount); }\n', '\n', '    /**\n', '        @dev Registers a new contribution, sets their share\n', '        @param _sender The address of the wallet contributing\n', '        @param _amount The amount that the owner has sent\n', '     */\n', '    function contribute(address _sender, uint256 _amount) private {\n', '        require(!locked, "Crowdsale period over, contribution is locked");\n', '        require(!distributionActive, "Cannot contribute when distribution is active");\n', '        require(_amount >= precisionMinimum, "Amount needs to be above the minimum contribution");\n', '        require(hardCap >= _amount, "Your contribution is greater than the hard cap");\n', '        require(_amount % precisionMinimum == 0, "Your amount isn&#39;t divisible by the minimum precision");\n', '        require(hardCap >= totalContributed.add(_amount), "Your contribution would cause the total to exceed the hardcap");\n', '\n', '        totalContributed = totalContributed.add(_amount);\n', '        uint256 share = percent(_amount, valuation, 5);\n', '\n', '        Owner storage o = owners[_sender];\n', '        if (o.percentage != 0) { // Existing owner\n', '            o.shareTokens = o.shareTokens.add(_amount);\n', '            o.percentage = o.percentage.add(share);\n', '        } else { // New owner\n', '            require(ownerMap.insert(totalOwners, uint(_sender)) == false);\n', '            o.key = totalOwners;\n', '            totalOwners += 1;\n', '            o.shareTokens = _amount;\n', '            o.percentage = share;\n', '        }\n', '\n', '        if (!whitelist[msg.sender]) {\n', '            whitelist[msg.sender] = true;\n', '        }\n', '\n', '        emit Contribution(_sender, share, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Whitelist a wallet address\n', '        @param _owner Wallet of the owner\n', '     */\n', '    function whitelistWallet(address _owner) external onlyOwner() {\n', '        require(!locked, "Can&#39;t whitelist when the contract is locked");\n', '        require(_owner != address(0), "Empty address");\n', '        whitelist[_owner] = true;\n', '    }\n', '\n', '    /**\n', '        @dev Start the distribution phase\n', '     */\n', '    function startContribution() external onlyOwner() {\n', '        require(!contributionStarted, "Contribution has started");\n', '        contributionStarted = true;\n', '    }\n', '\n', '    /**\n', '        @dev Manually set a share directly, used to set the LinkPool members as owners\n', '        @param _owner Wallet address of the owner\n', '        @param _value The equivalent contribution value\n', '     */\n', '    function setOwnerShare(address _owner, uint256 _value) public onlyOwner() {\n', '        require(!locked, "Can&#39;t manually set shares, it&#39;s locked");\n', '        require(!distributionActive, "Cannot set owners share when distribution is active");\n', '\n', '        Owner storage o = owners[_owner];\n', '        if (o.shareTokens == 0) {\n', '            whitelist[_owner] = true;\n', '            require(ownerMap.insert(totalOwners, uint(_owner)) == false);\n', '            o.key = totalOwners;\n', '            totalOwners += 1;\n', '        }\n', '        o.shareTokens = _value;\n', '        o.percentage = percent(_value, valuation, 5);\n', '    }\n', '\n', '    /**\n', '        @dev Transfer part or all of your ownership to another address\n', '        @param _receiver The address that you&#39;re sending to\n', '        @param _amount The amount of ownership to send, for your balance refer to `ownerShareTokens`\n', '     */\n', '    function sendOwnership(address _receiver, uint256 _amount) public onlyWhitelisted() {\n', '        Owner storage o = owners[msg.sender];\n', '        Owner storage r = owners[_receiver];\n', '\n', '        require(o.shareTokens > 0, "You don&#39;t have any ownership");\n', '        require(o.shareTokens >= _amount, "The amount exceeds what you have");\n', '        require(!distributionActive, "Distribution cannot be active when sending ownership");\n', '        require(_amount % precisionMinimum == 0, "Your amount isn&#39;t divisible by the minimum precision amount");\n', '\n', '        o.shareTokens = o.shareTokens.sub(_amount);\n', '\n', '        if (o.shareTokens == 0) {\n', '            o.percentage = 0;\n', '            require(ownerMap.remove(o.key) == true);\n', '        } else {\n', '            o.percentage = percent(o.shareTokens, valuation, 5);\n', '        }\n', '        if (r.shareTokens == 0) {\n', '            whitelist[_receiver] = true;\n', '            require(ownerMap.insert(totalOwners, uint(_receiver)) == false);\n', '            totalOwners += 1;\n', '        }\n', '        r.shareTokens = r.shareTokens.add(_amount);\n', '        r.percentage = r.percentage.add(percent(_amount, valuation, 5));\n', '\n', '        emit OwnershipTransferred(msg.sender, _receiver, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Lock the contribution/shares methods\n', '     */\n', '    function lockShares() public onlyOwner() {\n', '        require(!locked, "Shares already locked");\n', '        locked = true;\n', '    }\n', '\n', '    /**\n', '        @dev Start the distribution phase in the contract so owners can claim their tokens\n', '        @param _token The token address to start the distribution of\n', '     */\n', '    function distributeTokens(address _token) public onlyWhitelisted() {\n', '        require(!distributionActive, "Distribution is already active");\n', '        distributionActive = true;\n', '\n', '        ERC677 erc677 = ERC677(_token);\n', '\n', '        uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[_token];\n', '        require(currentBalance > distributionMinimum, "Amount in the contract isn&#39;t above the minimum distribution limit");\n', '\n', '        totalDistributions++;\n', '        Distribution storage d = distributions[totalDistributions]; \n', '        d.owners = ownerMap.size();\n', '        d.amount = currentBalance;\n', '        d.token = _token;\n', '        d.claimed = 0;\n', '        totalReturned[_token] += currentBalance;\n', '\n', '        emit TokenDistributionActive(_token, currentBalance, totalDistributions, d.owners);\n', '    }\n', '\n', '    /**\n', '        @dev Claim tokens by a owner address to add them to their balance\n', '        @param _owner The address of the owner to claim tokens for\n', '     */\n', '    function claimTokens(address _owner) public {\n', '        Owner storage o = owners[_owner];\n', '        Distribution storage d = distributions[totalDistributions]; \n', '\n', '        require(o.shareTokens > 0, "You need to have a share to claim tokens");\n', '        require(distributionActive, "Distribution isn&#39;t active");\n', '        require(!d.claimedAddresses[_owner], "Tokens already claimed for this address");\n', '\n', '        address token = d.token;\n', '        uint256 tokenAmount = d.amount.mul(o.percentage).div(100000);\n', '        o.balance[token] = o.balance[token].add(tokenAmount);\n', '        tokenBalance[token] = tokenBalance[token].add(tokenAmount);\n', '\n', '        d.claimed++;\n', '        d.claimedAddresses[_owner] = true;\n', '\n', '        emit ClaimedTokens(_owner, token, tokenAmount, d.claimed, totalDistributions);\n', '\n', '        if (d.claimed == d.owners) {\n', '            distributionActive = false;\n', '            emit TokenDistributionComplete(token, totalOwners);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev Withdraw tokens from your contract balance\n', '        @param _token The token address for token claiming\n', '        @param _amount The amount of tokens to withdraw\n', '     */\n', '    function withdrawTokens(address _token, uint256 _amount) public {\n', '        require(_amount > 0, "You have requested for 0 tokens to be withdrawn");\n', '\n', '        Owner storage o = owners[msg.sender];\n', '        Distribution storage d = distributions[totalDistributions]; \n', '\n', '        if (distributionActive && !d.claimedAddresses[msg.sender]) {\n', '            claimTokens(msg.sender);\n', '        }\n', '        require(o.balance[_token] >= _amount, "Amount requested is higher than your balance");\n', '\n', '        o.balance[_token] = o.balance[_token].sub(_amount);\n', '        tokenBalance[_token] = tokenBalance[_token].sub(_amount);\n', '\n', '        ERC677 erc677 = ERC677(_token);\n', '        require(erc677.transfer(msg.sender, _amount) == true);\n', '\n', '        emit TokenWithdrawal(_token, msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Set the minimum amount to be of transfered in this contract to start distribution\n', '        @param _minimum The minimum amount\n', '     */\n', '    function setDistributionMinimum(uint256 _minimum) public onlyOwner() {\n', '        distributionMinimum = _minimum;\n', '    }\n', '\n', '    /**\n', '        @dev Set the wallet address to receive the crowdsale contributions\n', '        @param _wallet The wallet address\n', '     */\n', '    function setEthWallet(address _wallet) public onlyOwner() {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '        @dev Returns whether the address is whitelisted\n', '        @param _owner The address of the owner\n', '     */\n', '    function isWhitelisted(address _owner) public view returns (bool) {\n', '        return whitelist[_owner];\n', '    }\n', '\n', '    /**\n', '        @dev Returns the contract balance of the sender for a given token\n', '        @param _token The address of the ERC token\n', '     */\n', '    function getOwnerBalance(address _token) public view returns (uint256) {\n', '        Owner storage o = owners[msg.sender];\n', '        return o.balance[_token];\n', '    }\n', '\n', '    /**\n', '        @dev Returns a owner, all the values in the struct\n', '        @param _owner Address of the owner\n', '     */\n', '    function getOwner(address _owner) public view returns (uint256, uint256, uint256) {\n', '        Owner storage o = owners[_owner];\n', '        return (o.key, o.shareTokens, o.percentage);\n', '    }\n', '\n', '    /**\n', '        @dev Returns the current amount of active owners, ie share above 0\n', '     */\n', '    function getCurrentOwners() public view returns (uint) {\n', '        return ownerMap.size();\n', '    }\n', '\n', '    /**\n', '        @dev Returns owner address based on the key\n', '        @param _key The key of the address in the map\n', '     */\n', '    function getOwnerAddress(uint _key) public view returns (address) {\n', '        return address(ownerMap.get(_key));\n', '    }\n', '\n', '    /**\n', '        @dev Returns whether a owner has claimed their tokens\n', '        @param _owner The address of the owner\n', '        @param _dId The distribution id\n', '     */\n', '    function hasClaimed(address _owner, uint256 _dId) public view returns (bool) {\n', '        Distribution storage d = distributions[_dId]; \n', '        return d.claimedAddresses[_owner];\n', '    }\n', '\n', '    /**\n', '        @dev Credit to Rob Hitchens: https://stackoverflow.com/a/42739843\n', '     */\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns (uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '        return ( _quotient);\n', '    }\n', '}']
['pragma solidity ^0.4.3;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "Sender not authorised.");\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC677 is ERC20 {\n', '    function transferAndCall(address to, uint value, bytes data) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '    @title ItMap, a solidity iterable map\n', '    @dev Credit to: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1\n', ' */\n', 'library itmap {\n', '    struct entry {\n', '        // Equal to the index of the key of this item in keys, plus 1.\n', '        uint keyIndex;\n', '        uint value;\n', '    }\n', '\n', '    struct itmap {\n', '        mapping(uint => entry) data;\n', '        uint[] keys;\n', '    }\n', '    \n', '    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\n', '        entry storage e = self.data[key];\n', '        e.value = value;\n', '        if (e.keyIndex > 0) {\n', '            return true;\n', '        } else {\n', '            e.keyIndex = ++self.keys.length;\n', '            self.keys[e.keyIndex - 1] = key;\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function remove(itmap storage self, uint key) internal returns (bool success) {\n', '        entry storage e = self.data[key];\n', '        if (e.keyIndex == 0)\n', '            return false;\n', '        \n', '        if (e.keyIndex < self.keys.length) {\n', '            // Move an existing element into the vacated key slot.\n', '            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\n', '            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\n', '            self.keys.length -= 1;\n', '            delete self.data[key];\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function contains(itmap storage self, uint key) internal view returns (bool exists) {\n', '        return self.data[key].keyIndex > 0;\n', '    }\n', '    \n', '    function size(itmap storage self) internal view returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '    \n', '    function get(itmap storage self, uint key) internal view returns (uint) {\n', '        return self.data[key].value;\n', '    }\n', '    \n', '    function getKey(itmap storage self, uint idx) internal view returns (uint) {\n', '        return self.keys[idx];\n', '    }\n', '}\n', '\n', '/**\n', '    @title PoolOwners, the crowdsale contract for LinkPool ownership\n', ' */\n', 'contract PoolOwners is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    using itmap for itmap.itmap;\n', '\n', '    struct Owner {\n', '        uint256 key;\n', '        uint256 percentage;\n', '        uint256 shareTokens;\n', '        mapping(address => uint256) balance;\n', '    }\n', '    mapping(address => Owner) public owners;\n', '\n', '    struct Distribution {\n', '        address token;\n', '        uint256 amount;\n', '        uint256 owners;\n', '        uint256 claimed;\n', '        mapping(address => bool) claimedAddresses;\n', '    }\n', '    mapping(uint256 => Distribution) public distributions;\n', '\n', '    mapping(address => uint256) public tokenBalance;\n', '    mapping(address => uint256) public totalReturned;\n', '\n', '    mapping(address => bool) private whitelist;\n', '\n', '    itmap.itmap ownerMap;\n', '    \n', '    uint256 public totalContributed     = 0;\n', '    uint256 public totalOwners          = 0;\n', '    uint256 public totalDistributions   = 0;\n', '    bool    public distributionActive   = false;\n', '    uint256 public distributionMinimum  = 20 ether;\n', '    uint256 public precisionMinimum     = 0.04 ether;\n', '    bool    public locked               = false;\n', '    address public wallet;\n', '\n', '    bool    private contributionStarted = false;\n', '    uint256 private valuation           = 4000 ether;\n', '    uint256 private hardCap             = 996.96 ether;\n', '\n', '    event Contribution(address indexed sender, uint256 share, uint256 amount);\n', '    event ClaimedTokens(address indexed owner, address indexed token, uint256 amount, uint256 claimedStakers, uint256 distributionId);\n', '    event TokenDistributionActive(address indexed token, uint256 amount, uint256 distributionId, uint256 amountOfOwners);\n', '    event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount);\n', '    event TokenDistributionComplete(address indexed token, uint256 amountOfOwners);\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev Constructor set set the wallet initally\n', '        @param _wallet Address of the ETH wallet\n', '     */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '        @dev Fallback function, redirects to contribution\n', '        @dev Transfers tokens to LP wallet address\n', '     */\n', '    function() public payable {\n', '        require(contributionStarted, "Contribution phase hasn\'t started");\n', '        require(whitelist[msg.sender], "You are not whitelisted");\n', '        contribute(msg.sender, msg.value); \n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '        @dev Manually set a contribution, used by owners to increase owners amounts\n', '        @param _sender The address of the sender to set the contribution for you\n', '        @param _amount The amount that the owner has sent\n', '     */\n', '    function setContribution(address _sender, uint256 _amount) public onlyOwner() { contribute(_sender, _amount); }\n', '\n', '    /**\n', '        @dev Registers a new contribution, sets their share\n', '        @param _sender The address of the wallet contributing\n', '        @param _amount The amount that the owner has sent\n', '     */\n', '    function contribute(address _sender, uint256 _amount) private {\n', '        require(!locked, "Crowdsale period over, contribution is locked");\n', '        require(!distributionActive, "Cannot contribute when distribution is active");\n', '        require(_amount >= precisionMinimum, "Amount needs to be above the minimum contribution");\n', '        require(hardCap >= _amount, "Your contribution is greater than the hard cap");\n', '        require(_amount % precisionMinimum == 0, "Your amount isn\'t divisible by the minimum precision");\n', '        require(hardCap >= totalContributed.add(_amount), "Your contribution would cause the total to exceed the hardcap");\n', '\n', '        totalContributed = totalContributed.add(_amount);\n', '        uint256 share = percent(_amount, valuation, 5);\n', '\n', '        Owner storage o = owners[_sender];\n', '        if (o.percentage != 0) { // Existing owner\n', '            o.shareTokens = o.shareTokens.add(_amount);\n', '            o.percentage = o.percentage.add(share);\n', '        } else { // New owner\n', '            require(ownerMap.insert(totalOwners, uint(_sender)) == false);\n', '            o.key = totalOwners;\n', '            totalOwners += 1;\n', '            o.shareTokens = _amount;\n', '            o.percentage = share;\n', '        }\n', '\n', '        if (!whitelist[msg.sender]) {\n', '            whitelist[msg.sender] = true;\n', '        }\n', '\n', '        emit Contribution(_sender, share, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Whitelist a wallet address\n', '        @param _owner Wallet of the owner\n', '     */\n', '    function whitelistWallet(address _owner) external onlyOwner() {\n', '        require(!locked, "Can\'t whitelist when the contract is locked");\n', '        require(_owner != address(0), "Empty address");\n', '        whitelist[_owner] = true;\n', '    }\n', '\n', '    /**\n', '        @dev Start the distribution phase\n', '     */\n', '    function startContribution() external onlyOwner() {\n', '        require(!contributionStarted, "Contribution has started");\n', '        contributionStarted = true;\n', '    }\n', '\n', '    /**\n', '        @dev Manually set a share directly, used to set the LinkPool members as owners\n', '        @param _owner Wallet address of the owner\n', '        @param _value The equivalent contribution value\n', '     */\n', '    function setOwnerShare(address _owner, uint256 _value) public onlyOwner() {\n', '        require(!locked, "Can\'t manually set shares, it\'s locked");\n', '        require(!distributionActive, "Cannot set owners share when distribution is active");\n', '\n', '        Owner storage o = owners[_owner];\n', '        if (o.shareTokens == 0) {\n', '            whitelist[_owner] = true;\n', '            require(ownerMap.insert(totalOwners, uint(_owner)) == false);\n', '            o.key = totalOwners;\n', '            totalOwners += 1;\n', '        }\n', '        o.shareTokens = _value;\n', '        o.percentage = percent(_value, valuation, 5);\n', '    }\n', '\n', '    /**\n', '        @dev Transfer part or all of your ownership to another address\n', "        @param _receiver The address that you're sending to\n", '        @param _amount The amount of ownership to send, for your balance refer to `ownerShareTokens`\n', '     */\n', '    function sendOwnership(address _receiver, uint256 _amount) public onlyWhitelisted() {\n', '        Owner storage o = owners[msg.sender];\n', '        Owner storage r = owners[_receiver];\n', '\n', '        require(o.shareTokens > 0, "You don\'t have any ownership");\n', '        require(o.shareTokens >= _amount, "The amount exceeds what you have");\n', '        require(!distributionActive, "Distribution cannot be active when sending ownership");\n', '        require(_amount % precisionMinimum == 0, "Your amount isn\'t divisible by the minimum precision amount");\n', '\n', '        o.shareTokens = o.shareTokens.sub(_amount);\n', '\n', '        if (o.shareTokens == 0) {\n', '            o.percentage = 0;\n', '            require(ownerMap.remove(o.key) == true);\n', '        } else {\n', '            o.percentage = percent(o.shareTokens, valuation, 5);\n', '        }\n', '        if (r.shareTokens == 0) {\n', '            whitelist[_receiver] = true;\n', '            require(ownerMap.insert(totalOwners, uint(_receiver)) == false);\n', '            totalOwners += 1;\n', '        }\n', '        r.shareTokens = r.shareTokens.add(_amount);\n', '        r.percentage = r.percentage.add(percent(_amount, valuation, 5));\n', '\n', '        emit OwnershipTransferred(msg.sender, _receiver, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Lock the contribution/shares methods\n', '     */\n', '    function lockShares() public onlyOwner() {\n', '        require(!locked, "Shares already locked");\n', '        locked = true;\n', '    }\n', '\n', '    /**\n', '        @dev Start the distribution phase in the contract so owners can claim their tokens\n', '        @param _token The token address to start the distribution of\n', '     */\n', '    function distributeTokens(address _token) public onlyWhitelisted() {\n', '        require(!distributionActive, "Distribution is already active");\n', '        distributionActive = true;\n', '\n', '        ERC677 erc677 = ERC677(_token);\n', '\n', '        uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[_token];\n', '        require(currentBalance > distributionMinimum, "Amount in the contract isn\'t above the minimum distribution limit");\n', '\n', '        totalDistributions++;\n', '        Distribution storage d = distributions[totalDistributions]; \n', '        d.owners = ownerMap.size();\n', '        d.amount = currentBalance;\n', '        d.token = _token;\n', '        d.claimed = 0;\n', '        totalReturned[_token] += currentBalance;\n', '\n', '        emit TokenDistributionActive(_token, currentBalance, totalDistributions, d.owners);\n', '    }\n', '\n', '    /**\n', '        @dev Claim tokens by a owner address to add them to their balance\n', '        @param _owner The address of the owner to claim tokens for\n', '     */\n', '    function claimTokens(address _owner) public {\n', '        Owner storage o = owners[_owner];\n', '        Distribution storage d = distributions[totalDistributions]; \n', '\n', '        require(o.shareTokens > 0, "You need to have a share to claim tokens");\n', '        require(distributionActive, "Distribution isn\'t active");\n', '        require(!d.claimedAddresses[_owner], "Tokens already claimed for this address");\n', '\n', '        address token = d.token;\n', '        uint256 tokenAmount = d.amount.mul(o.percentage).div(100000);\n', '        o.balance[token] = o.balance[token].add(tokenAmount);\n', '        tokenBalance[token] = tokenBalance[token].add(tokenAmount);\n', '\n', '        d.claimed++;\n', '        d.claimedAddresses[_owner] = true;\n', '\n', '        emit ClaimedTokens(_owner, token, tokenAmount, d.claimed, totalDistributions);\n', '\n', '        if (d.claimed == d.owners) {\n', '            distributionActive = false;\n', '            emit TokenDistributionComplete(token, totalOwners);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev Withdraw tokens from your contract balance\n', '        @param _token The token address for token claiming\n', '        @param _amount The amount of tokens to withdraw\n', '     */\n', '    function withdrawTokens(address _token, uint256 _amount) public {\n', '        require(_amount > 0, "You have requested for 0 tokens to be withdrawn");\n', '\n', '        Owner storage o = owners[msg.sender];\n', '        Distribution storage d = distributions[totalDistributions]; \n', '\n', '        if (distributionActive && !d.claimedAddresses[msg.sender]) {\n', '            claimTokens(msg.sender);\n', '        }\n', '        require(o.balance[_token] >= _amount, "Amount requested is higher than your balance");\n', '\n', '        o.balance[_token] = o.balance[_token].sub(_amount);\n', '        tokenBalance[_token] = tokenBalance[_token].sub(_amount);\n', '\n', '        ERC677 erc677 = ERC677(_token);\n', '        require(erc677.transfer(msg.sender, _amount) == true);\n', '\n', '        emit TokenWithdrawal(_token, msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev Set the minimum amount to be of transfered in this contract to start distribution\n', '        @param _minimum The minimum amount\n', '     */\n', '    function setDistributionMinimum(uint256 _minimum) public onlyOwner() {\n', '        distributionMinimum = _minimum;\n', '    }\n', '\n', '    /**\n', '        @dev Set the wallet address to receive the crowdsale contributions\n', '        @param _wallet The wallet address\n', '     */\n', '    function setEthWallet(address _wallet) public onlyOwner() {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '        @dev Returns whether the address is whitelisted\n', '        @param _owner The address of the owner\n', '     */\n', '    function isWhitelisted(address _owner) public view returns (bool) {\n', '        return whitelist[_owner];\n', '    }\n', '\n', '    /**\n', '        @dev Returns the contract balance of the sender for a given token\n', '        @param _token The address of the ERC token\n', '     */\n', '    function getOwnerBalance(address _token) public view returns (uint256) {\n', '        Owner storage o = owners[msg.sender];\n', '        return o.balance[_token];\n', '    }\n', '\n', '    /**\n', '        @dev Returns a owner, all the values in the struct\n', '        @param _owner Address of the owner\n', '     */\n', '    function getOwner(address _owner) public view returns (uint256, uint256, uint256) {\n', '        Owner storage o = owners[_owner];\n', '        return (o.key, o.shareTokens, o.percentage);\n', '    }\n', '\n', '    /**\n', '        @dev Returns the current amount of active owners, ie share above 0\n', '     */\n', '    function getCurrentOwners() public view returns (uint) {\n', '        return ownerMap.size();\n', '    }\n', '\n', '    /**\n', '        @dev Returns owner address based on the key\n', '        @param _key The key of the address in the map\n', '     */\n', '    function getOwnerAddress(uint _key) public view returns (address) {\n', '        return address(ownerMap.get(_key));\n', '    }\n', '\n', '    /**\n', '        @dev Returns whether a owner has claimed their tokens\n', '        @param _owner The address of the owner\n', '        @param _dId The distribution id\n', '     */\n', '    function hasClaimed(address _owner, uint256 _dId) public view returns (bool) {\n', '        Distribution storage d = distributions[_dId]; \n', '        return d.claimedAddresses[_owner];\n', '    }\n', '\n', '    /**\n', '        @dev Credit to Rob Hitchens: https://stackoverflow.com/a/42739843\n', '     */\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns (uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '        return ( _quotient);\n', '    }\n', '}']
