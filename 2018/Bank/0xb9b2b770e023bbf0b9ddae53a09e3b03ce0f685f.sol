['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '// NOTE: BasicToken only has partial ERC20 support\n', 'contract Ico is BasicToken {\n', '  address owner;\n', '  uint256 public teamNum;\n', '  mapping(address => bool) team;\n', '\n', '  // expose these for ERC20 tools\n', '  string public constant name = "LUNA";\n', '  string public constant symbol = "LUNA";\n', '  uint8 public constant decimals = 18;\n', '\n', '  // Significant digits tokenPrecision\n', '  uint256 private constant tokenPrecision = 10e17;\n', '\n', '  // Tokens frozen supply\n', '  uint256 public tokensFrozen = 0;\n', '\n', '  uint256 public tokenValue = 1 * tokenPrecision;\n', '\n', '  // struct representing a dividends snapshot\n', '  struct DividendSnapshot {\n', '    uint256 totalSupply;\n', '    uint256 dividendsIssued;\n', '    uint256 managementDividends;\n', '  }\n', '  // An array of all the DividendSnapshot so far\n', '  DividendSnapshot[] dividendSnapshots;\n', '\n', '  // Mapping of user to the index of the last dividend that was awarded to zhie\n', '  mapping(address => uint256) lastDividend;\n', '\n', '  // Management fees share express as 100/%: eg. 20% => 100/20 = 5\n', '  uint256 public constant managementFees = 10;\n', '\n', '  // Assets under management in USD\n', '  uint256 public aum = 0;\n', '\n', '  // Amount of tokens in circulation\n', '  uint256 public totalSupply = 0;\n', '\n', '  // drip percent in 100 / percentage\n', '  uint256 public dripRate = 50;\n', '\n', '  // current registred change address\n', '  address public currentSaleAddress;\n', '\n', '  // custom events\n', '  event Freeze(address indexed from, uint256 value);\n', '  event Reconcile(address indexed from, uint256 period, uint256 value);\n', '\n', '  /**\n', '   * Luna constructor\n', '   * Define Luna details and contribution period\n', '   */\n', '  constructor(address[] _team, address[] shareholders, uint256[] shares, uint256 _aum, uint256 _tokensFrozen) public {\n', '    owner = msg.sender;\n', '\n', '    // reset from old contract\n', '    aum = _aum;\n', '    tokensFrozen = _tokensFrozen;\n', '\n', '    uint256 shareholderNum = shareholders.length;\n', '    for (uint256 i = 0; i < shareholderNum; i++) {\n', '      balances[shareholders[i]] = shares[i];\n', '      totalSupply = totalSupply.add(shares[i]);\n', '      emit Transfer(0x0, shareholders[i], shares[i]);\n', '    }\n', '\n', '    // initialize the team mapping with true when part of the team\n', '    teamNum = _team.length;\n', '    for (i = 0; i < teamNum; i++) {\n', '      team[_team[i]] = true;\n', '    }\n', '\n', '    // as a safety measure tempory set the sale address to something else than 0x0\n', '    currentSaleAddress = owner;\n', '  }\n', '\n', '  /**\n', '   * Modifiers\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTeam() {\n', '    require (team[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  modifier onlySaleAddress() {\n', '    require (msg.sender == currentSaleAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Internal burn function, only callable by team\n', '   *\n', '   * @param _amount is the amount of tokens to burn.\n', '   */\n', '  function freeze(uint256 _amount) public onlySaleAddress returns (bool) {\n', '    reconcileDividend(msg.sender);\n', '    require(_amount <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    totalSupply = totalSupply.sub(_amount);\n', '    tokensFrozen = tokensFrozen.add(_amount);\n', '\n', '    aum = aum.sub(tokenValue.mul(_amount).div(tokenPrecision));\n', '\n', '    emit Freeze(msg.sender, _amount);\n', '    emit Transfer(msg.sender, 0x0, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Calculate the divends for the current period given the AUM profit\n', '   *\n', '   * @param totalProfit is the amount of total profit in USD.\n', '   */\n', '  function reportProfit(int256 totalProfit, bool shouldDrip, address saleAddress) public onlyTeam returns (bool) {\n', '    // first we new dividends if this period was profitable\n', '    if (totalProfit > 0) {\n', '      // We only care about 50% of this, as the rest is reinvested right away\n', '      uint256 profit = uint256(totalProfit).mul(tokenPrecision).div(2);\n', '\n', '      // this will throw if there are not enough tokens\n', '      addNewDividends(profit);\n', '    }\n', '\n', '    if (shouldDrip) {\n', '      // then we drip\n', '      drip(saleAddress);\n', '    }\n', '\n', '    // adjust AUM\n', '    if (totalProfit > 0) {\n', '      aum = aum.add(uint256(totalProfit).mul(tokenPrecision));\n', '    } else if (totalProfit < 0) {\n', '      aum = aum.sub(uint256(-totalProfit).mul(tokenPrecision));\n', '    }\n', '\n', '    // register the sale address\n', '    currentSaleAddress = saleAddress;\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function drip(address saleAddress) internal {\n', '    uint256 dripTokens = tokensFrozen.div(dripRate);\n', '\n', '    tokensFrozen = tokensFrozen.sub(dripTokens);\n', '    totalSupply = totalSupply.add(dripTokens);\n', '    aum = aum.add(tokenValue.mul(dripTokens).div(tokenPrecision));\n', '\n', '    reconcileDividend(saleAddress);\n', '    balances[saleAddress] = balances[saleAddress].add(dripTokens);\n', '    emit Transfer(0x0, saleAddress, dripTokens);\n', '  }\n', '\n', '  /**\n', '   * Calculate the divends for the current period given the dividend\n', '   * amounts (USD * tokenPrecision).\n', '   */\n', '  function addNewDividends(uint256 profit) internal {\n', '    uint256 newAum = aum.add(profit); // 18 sig digits\n', '    tokenValue = newAum.mul(tokenPrecision).div(totalSupply); // 18 sig digits\n', '    uint256 totalDividends = profit.mul(tokenPrecision).div(tokenValue); // 18 sig digits\n', '    uint256 managementDividends = totalDividends.div(managementFees); // 17 sig digits\n', '    uint256 dividendsIssued = totalDividends.sub(managementDividends); // 18 sig digits\n', '\n', '    // make sure we have enough in the frozen fund\n', '    require(tokensFrozen >= totalDividends);\n', '\n', '    dividendSnapshots.push(DividendSnapshot(totalSupply, dividendsIssued, managementDividends));\n', '\n', '    // add the previous amount of given dividends to the totalSupply\n', '    totalSupply = totalSupply.add(totalDividends);\n', '    tokensFrozen = tokensFrozen.sub(totalDividends);\n', '  }\n', '\n', '  /**\n', '   * Withdraw all funds and kill fund smart contract\n', '   */\n', '  function liquidate() public onlyTeam returns (bool) {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  /**\n', '   * Manually update AUM, need (for example) when the drip was sold\n', '   * for anything other than NAV.\n', '   */\n', '  function setAUM(uint256 _aum) public onlyTeam returns (bool) {\n', '    aum = _aum;\n', '    return true;\n', '  }\n', '\n', '\n', '  // getter to retrieve divident owed\n', '  function getOwedDividend(address _owner) public view returns (uint256 total, uint256[]) {\n', '    uint256[] memory noDividends = new uint256[](0);\n', '    // And the address&#39; current balance\n', '    uint256 balance = BasicToken.balanceOf(_owner);\n', '    // retrieve index of last dividend this address received\n', '    // NOTE: the default return value of a mapping is 0 in this case\n', '    uint idx = lastDividend[_owner];\n', '    if (idx == dividendSnapshots.length) return (total, noDividends);\n', '    if (balance == 0 && team[_owner] != true) return (total, noDividends);\n', '\n', '    uint256[] memory dividends = new uint256[](dividendSnapshots.length - idx - i);\n', '    uint256 currBalance = balance;\n', '    for (uint i = idx; i < dividendSnapshots.length; i++) {\n', '      // We should be able to remove the .mul(tokenPrecision) and .div(tokenPrecision) and apply them once\n', '      // at the beginning and once at the end, but we need to math it out\n', '      uint256 dividend = currBalance.mul(tokenPrecision).div(dividendSnapshots[i].totalSupply).mul(dividendSnapshots[i].dividendsIssued).div(tokenPrecision);\n', '\n', '      // Add the management dividends in equal parts if the current address is part of the team\n', '      if (team[_owner] == true) {\n', '        dividend = dividend.add(dividendSnapshots[i].managementDividends.div(teamNum));\n', '      }\n', '\n', '      total = total.add(dividend);\n', '\n', '      dividends[i - idx] = dividend;\n', '\n', '      currBalance = currBalance.add(dividend);\n', '    }\n', '\n', '    return (total, dividends);\n', '  }\n', '\n', '  // monkey patches\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    uint256 owedDividend;\n', '    (owedDividend,) = getOwedDividend(_owner);\n', '    return BasicToken.balanceOf(_owner).add(owedDividend);\n', '  }\n', '\n', '\n', '  // Reconcile all outstanding dividends for an address\n', '  // into its balance.\n', '  function reconcileDividend(address _owner) internal {\n', '    uint256 owedDividend;\n', '    uint256[] memory dividends;\n', '    (owedDividend, dividends) = getOwedDividend(_owner);\n', '\n', '    for (uint i = 0; i < dividends.length; i++) {\n', '      if (dividends[i] > 0) {\n', '        emit Reconcile(_owner, lastDividend[_owner] + i, dividends[i]);\n', '        emit Transfer(0x0, _owner, dividends[i]);\n', '      }\n', '    }\n', '\n', '    if(owedDividend > 0) {\n', '      balances[_owner] = balances[_owner].add(owedDividend);\n', '    }\n', '\n', '    // register this user as being owed no further dividends\n', '    lastDividend[_owner] = dividendSnapshots.length;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _amount) public returns (bool) {\n', '    reconcileDividend(msg.sender);\n', '    reconcileDividend(_to);\n', '    return BasicToken.transfer(_to, _amount);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '// NOTE: BasicToken only has partial ERC20 support\n', 'contract Ico is BasicToken {\n', '  address owner;\n', '  uint256 public teamNum;\n', '  mapping(address => bool) team;\n', '\n', '  // expose these for ERC20 tools\n', '  string public constant name = "LUNA";\n', '  string public constant symbol = "LUNA";\n', '  uint8 public constant decimals = 18;\n', '\n', '  // Significant digits tokenPrecision\n', '  uint256 private constant tokenPrecision = 10e17;\n', '\n', '  // Tokens frozen supply\n', '  uint256 public tokensFrozen = 0;\n', '\n', '  uint256 public tokenValue = 1 * tokenPrecision;\n', '\n', '  // struct representing a dividends snapshot\n', '  struct DividendSnapshot {\n', '    uint256 totalSupply;\n', '    uint256 dividendsIssued;\n', '    uint256 managementDividends;\n', '  }\n', '  // An array of all the DividendSnapshot so far\n', '  DividendSnapshot[] dividendSnapshots;\n', '\n', '  // Mapping of user to the index of the last dividend that was awarded to zhie\n', '  mapping(address => uint256) lastDividend;\n', '\n', '  // Management fees share express as 100/%: eg. 20% => 100/20 = 5\n', '  uint256 public constant managementFees = 10;\n', '\n', '  // Assets under management in USD\n', '  uint256 public aum = 0;\n', '\n', '  // Amount of tokens in circulation\n', '  uint256 public totalSupply = 0;\n', '\n', '  // drip percent in 100 / percentage\n', '  uint256 public dripRate = 50;\n', '\n', '  // current registred change address\n', '  address public currentSaleAddress;\n', '\n', '  // custom events\n', '  event Freeze(address indexed from, uint256 value);\n', '  event Reconcile(address indexed from, uint256 period, uint256 value);\n', '\n', '  /**\n', '   * Luna constructor\n', '   * Define Luna details and contribution period\n', '   */\n', '  constructor(address[] _team, address[] shareholders, uint256[] shares, uint256 _aum, uint256 _tokensFrozen) public {\n', '    owner = msg.sender;\n', '\n', '    // reset from old contract\n', '    aum = _aum;\n', '    tokensFrozen = _tokensFrozen;\n', '\n', '    uint256 shareholderNum = shareholders.length;\n', '    for (uint256 i = 0; i < shareholderNum; i++) {\n', '      balances[shareholders[i]] = shares[i];\n', '      totalSupply = totalSupply.add(shares[i]);\n', '      emit Transfer(0x0, shareholders[i], shares[i]);\n', '    }\n', '\n', '    // initialize the team mapping with true when part of the team\n', '    teamNum = _team.length;\n', '    for (i = 0; i < teamNum; i++) {\n', '      team[_team[i]] = true;\n', '    }\n', '\n', '    // as a safety measure tempory set the sale address to something else than 0x0\n', '    currentSaleAddress = owner;\n', '  }\n', '\n', '  /**\n', '   * Modifiers\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTeam() {\n', '    require (team[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  modifier onlySaleAddress() {\n', '    require (msg.sender == currentSaleAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Internal burn function, only callable by team\n', '   *\n', '   * @param _amount is the amount of tokens to burn.\n', '   */\n', '  function freeze(uint256 _amount) public onlySaleAddress returns (bool) {\n', '    reconcileDividend(msg.sender);\n', '    require(_amount <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    totalSupply = totalSupply.sub(_amount);\n', '    tokensFrozen = tokensFrozen.add(_amount);\n', '\n', '    aum = aum.sub(tokenValue.mul(_amount).div(tokenPrecision));\n', '\n', '    emit Freeze(msg.sender, _amount);\n', '    emit Transfer(msg.sender, 0x0, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Calculate the divends for the current period given the AUM profit\n', '   *\n', '   * @param totalProfit is the amount of total profit in USD.\n', '   */\n', '  function reportProfit(int256 totalProfit, bool shouldDrip, address saleAddress) public onlyTeam returns (bool) {\n', '    // first we new dividends if this period was profitable\n', '    if (totalProfit > 0) {\n', '      // We only care about 50% of this, as the rest is reinvested right away\n', '      uint256 profit = uint256(totalProfit).mul(tokenPrecision).div(2);\n', '\n', '      // this will throw if there are not enough tokens\n', '      addNewDividends(profit);\n', '    }\n', '\n', '    if (shouldDrip) {\n', '      // then we drip\n', '      drip(saleAddress);\n', '    }\n', '\n', '    // adjust AUM\n', '    if (totalProfit > 0) {\n', '      aum = aum.add(uint256(totalProfit).mul(tokenPrecision));\n', '    } else if (totalProfit < 0) {\n', '      aum = aum.sub(uint256(-totalProfit).mul(tokenPrecision));\n', '    }\n', '\n', '    // register the sale address\n', '    currentSaleAddress = saleAddress;\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function drip(address saleAddress) internal {\n', '    uint256 dripTokens = tokensFrozen.div(dripRate);\n', '\n', '    tokensFrozen = tokensFrozen.sub(dripTokens);\n', '    totalSupply = totalSupply.add(dripTokens);\n', '    aum = aum.add(tokenValue.mul(dripTokens).div(tokenPrecision));\n', '\n', '    reconcileDividend(saleAddress);\n', '    balances[saleAddress] = balances[saleAddress].add(dripTokens);\n', '    emit Transfer(0x0, saleAddress, dripTokens);\n', '  }\n', '\n', '  /**\n', '   * Calculate the divends for the current period given the dividend\n', '   * amounts (USD * tokenPrecision).\n', '   */\n', '  function addNewDividends(uint256 profit) internal {\n', '    uint256 newAum = aum.add(profit); // 18 sig digits\n', '    tokenValue = newAum.mul(tokenPrecision).div(totalSupply); // 18 sig digits\n', '    uint256 totalDividends = profit.mul(tokenPrecision).div(tokenValue); // 18 sig digits\n', '    uint256 managementDividends = totalDividends.div(managementFees); // 17 sig digits\n', '    uint256 dividendsIssued = totalDividends.sub(managementDividends); // 18 sig digits\n', '\n', '    // make sure we have enough in the frozen fund\n', '    require(tokensFrozen >= totalDividends);\n', '\n', '    dividendSnapshots.push(DividendSnapshot(totalSupply, dividendsIssued, managementDividends));\n', '\n', '    // add the previous amount of given dividends to the totalSupply\n', '    totalSupply = totalSupply.add(totalDividends);\n', '    tokensFrozen = tokensFrozen.sub(totalDividends);\n', '  }\n', '\n', '  /**\n', '   * Withdraw all funds and kill fund smart contract\n', '   */\n', '  function liquidate() public onlyTeam returns (bool) {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  /**\n', '   * Manually update AUM, need (for example) when the drip was sold\n', '   * for anything other than NAV.\n', '   */\n', '  function setAUM(uint256 _aum) public onlyTeam returns (bool) {\n', '    aum = _aum;\n', '    return true;\n', '  }\n', '\n', '\n', '  // getter to retrieve divident owed\n', '  function getOwedDividend(address _owner) public view returns (uint256 total, uint256[]) {\n', '    uint256[] memory noDividends = new uint256[](0);\n', "    // And the address' current balance\n", '    uint256 balance = BasicToken.balanceOf(_owner);\n', '    // retrieve index of last dividend this address received\n', '    // NOTE: the default return value of a mapping is 0 in this case\n', '    uint idx = lastDividend[_owner];\n', '    if (idx == dividendSnapshots.length) return (total, noDividends);\n', '    if (balance == 0 && team[_owner] != true) return (total, noDividends);\n', '\n', '    uint256[] memory dividends = new uint256[](dividendSnapshots.length - idx - i);\n', '    uint256 currBalance = balance;\n', '    for (uint i = idx; i < dividendSnapshots.length; i++) {\n', '      // We should be able to remove the .mul(tokenPrecision) and .div(tokenPrecision) and apply them once\n', '      // at the beginning and once at the end, but we need to math it out\n', '      uint256 dividend = currBalance.mul(tokenPrecision).div(dividendSnapshots[i].totalSupply).mul(dividendSnapshots[i].dividendsIssued).div(tokenPrecision);\n', '\n', '      // Add the management dividends in equal parts if the current address is part of the team\n', '      if (team[_owner] == true) {\n', '        dividend = dividend.add(dividendSnapshots[i].managementDividends.div(teamNum));\n', '      }\n', '\n', '      total = total.add(dividend);\n', '\n', '      dividends[i - idx] = dividend;\n', '\n', '      currBalance = currBalance.add(dividend);\n', '    }\n', '\n', '    return (total, dividends);\n', '  }\n', '\n', '  // monkey patches\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    uint256 owedDividend;\n', '    (owedDividend,) = getOwedDividend(_owner);\n', '    return BasicToken.balanceOf(_owner).add(owedDividend);\n', '  }\n', '\n', '\n', '  // Reconcile all outstanding dividends for an address\n', '  // into its balance.\n', '  function reconcileDividend(address _owner) internal {\n', '    uint256 owedDividend;\n', '    uint256[] memory dividends;\n', '    (owedDividend, dividends) = getOwedDividend(_owner);\n', '\n', '    for (uint i = 0; i < dividends.length; i++) {\n', '      if (dividends[i] > 0) {\n', '        emit Reconcile(_owner, lastDividend[_owner] + i, dividends[i]);\n', '        emit Transfer(0x0, _owner, dividends[i]);\n', '      }\n', '    }\n', '\n', '    if(owedDividend > 0) {\n', '      balances[_owner] = balances[_owner].add(owedDividend);\n', '    }\n', '\n', '    // register this user as being owed no further dividends\n', '    lastDividend[_owner] = dividendSnapshots.length;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _amount) public returns (bool) {\n', '    reconcileDividend(msg.sender);\n', '    reconcileDividend(_to);\n', '    return BasicToken.transfer(_to, _amount);\n', '  }\n', '\n', '}']
