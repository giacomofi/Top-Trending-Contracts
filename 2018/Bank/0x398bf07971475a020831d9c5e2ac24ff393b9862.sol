['pragma solidity ^0.4.0;\n', '\n', 'contract FairPonzi {\n', '    struct Investment {\n', '        uint initamount;\n', '        uint inittime;\n', '        \n', '        uint refbonus;\n', '        address refaddress;\n', '        uint refcount;\n', '    }\n', '    struct Payment {\n', '        address receiver;\n', '        uint inamount;\n', '        uint outamount;\n', '    }\n', '    mapping(uint => mapping(address => Investment)) public investmentTable;\n', '    mapping(uint => Payment) public payoutList;\n', '    \n', '    uint public rewardinterval = 3600 * 24; // 1day\n', '    //uint public rewardinterval = 60; // 1min\n', '    uint public constant minbid = 1000000000000; // 1uETH\n', '    uint public payoutcount = 0;\n', '    uint public constant startblock = 5646372; // this disables preinvest advantage\n', '    uint public payincount = 0;\n', '    uint roundcount = 0;\n', '    uint constant maxdays = 365 * 3; // max 3 years, to cap gas costs\n', '    \n', '    address constant restaddress = 0x9feA38edD1875cefD3D071C549a3f7Cc7983B455;\n', '    address constant nulladdress = 0x0000000000000000000000000000000000000000;\n', '    \n', '    constructor() public {\n', '    }\n', '    \n', '    function () public payable {\n', '        buyin(nulladdress); // if normal transaction, nobody get referral\n', '    }\n', '    function buyin(address refaddr)public payable{\n', '        if(block.number < startblock) revert();\n', '        if(msg.value < minbid) { // wants a payout\n', '            redeemPayout();\n', '            return;\n', '        }\n', '        Investment storage acc = investmentTable[roundcount][msg.sender];\n', '        uint addreward = getAccountBalance(msg.sender);\n', '        uint win = addreward - acc.initamount;\n', '        if(win > 0){\n', '            investmentTable[roundcount][acc.refaddress].refbonus += win / 10; // Referral get 10%\n', '        }\n', '        \n', '        acc.initamount = msg.value + addreward;\n', '        acc.inittime = block.timestamp;\n', '        if(refaddr != msg.sender && acc.refaddress == nulladdress){\n', '            acc.refaddress = refaddr;\n', '            investmentTable[roundcount][refaddr].refcount++;\n', '        }\n', '        \n', '        payincount++;\n', '    }\n', '    function redeemPayout() public {\n', '        Investment storage acc = investmentTable[roundcount][msg.sender];\n', '        uint addreward = getAccountBalance(msg.sender);\n', '        uint win = addreward - acc.initamount;\n', '        uint payamount = addreward + acc.refbonus;\n', '        if(payamount <= 0) return;\n', '        if(address(this).balance < payamount){\n', '            reset();\n', '        }else{\n', '            payoutList[payoutcount++] = Payment(msg.sender, acc.initamount, payamount);\n', '            acc.initamount = 0;\n', '            acc.refbonus = 0;\n', '            msg.sender.transfer(payamount);\n', '            investmentTable[roundcount][acc.refaddress].refbonus += win / 10; // Referral get 10%\n', '        }\n', '    }\n', '    function reset() private {\n', '        // todo reset list\n', '        if(restaddress.send(address(this).balance)){\n', '            // Should always be possible, otherwise new payers have good luck ;)\n', '        }\n', '        roundcount++;\n', '        payincount = 0;\n', '    }\n', '    function getAccountBalance(address addr)public constant returns (uint amount){\n', '        Investment storage acc = investmentTable[roundcount][addr];\n', '        uint ret = acc.initamount;\n', '        if(acc.initamount > 0){\n', '            uint rewardcount = (block.timestamp - acc.inittime) / rewardinterval;\n', '            if(rewardcount > maxdays) rewardcount = maxdays;\n', '            while(rewardcount > 0){\n', '                ret += ret / 200; // 0.5%\n', '                rewardcount--;\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '    function getPayout(uint idrel) public constant returns (address bidder, uint inamount, uint outamount) {\n', '        Payment storage cur =  payoutList[idrel];\n', '        return (cur.receiver, cur.inamount, cur.outamount);\n', '    }\n', '    function getBlocksUntilStart() public constant returns (uint count){\n', '        if(startblock <= block.number) return 0;\n', '        else return startblock - block.number;\n', '    }\n', '    function getAccountInfo(address addr) public constant returns (address retaddr, uint initamount, uint investmenttime, uint currentbalance, uint _timeuntilnextreward, uint _refbonus, address _refaddress, uint _refcount) {\n', '        Investment storage acc = investmentTable[roundcount][addr];\n', '        uint nextreward = rewardinterval - ((block.timestamp - acc.inittime) % rewardinterval);\n', '        if(acc.initamount <= 0) nextreward = 0;\n', '        return (addr, acc.initamount, block.timestamp - acc.inittime, getAccountBalance(addr), nextreward, acc.refbonus, acc.refaddress, acc.refcount);\n', '    }\n', '    function getAccountInfo() public constant returns (address retaddr, uint initamount, uint investmenttime, uint currentbalance, uint _timeuntilnextreward, uint _refbonus, address _refaddress, uint _refcount) {\n', '        return getAccountInfo(msg.sender);\n', '    }\n', '    function getStatus() public constant returns (uint _payoutcount, uint _blocksUntilStart, uint _payincount){\n', '        return (payoutcount, getBlocksUntilStart(), payincount);\n', '    }\n', '}']
['pragma solidity ^0.4.0;\n', '\n', 'contract FairPonzi {\n', '    struct Investment {\n', '        uint initamount;\n', '        uint inittime;\n', '        \n', '        uint refbonus;\n', '        address refaddress;\n', '        uint refcount;\n', '    }\n', '    struct Payment {\n', '        address receiver;\n', '        uint inamount;\n', '        uint outamount;\n', '    }\n', '    mapping(uint => mapping(address => Investment)) public investmentTable;\n', '    mapping(uint => Payment) public payoutList;\n', '    \n', '    uint public rewardinterval = 3600 * 24; // 1day\n', '    //uint public rewardinterval = 60; // 1min\n', '    uint public constant minbid = 1000000000000; // 1uETH\n', '    uint public payoutcount = 0;\n', '    uint public constant startblock = 5646372; // this disables preinvest advantage\n', '    uint public payincount = 0;\n', '    uint roundcount = 0;\n', '    uint constant maxdays = 365 * 3; // max 3 years, to cap gas costs\n', '    \n', '    address constant restaddress = 0x9feA38edD1875cefD3D071C549a3f7Cc7983B455;\n', '    address constant nulladdress = 0x0000000000000000000000000000000000000000;\n', '    \n', '    constructor() public {\n', '    }\n', '    \n', '    function () public payable {\n', '        buyin(nulladdress); // if normal transaction, nobody get referral\n', '    }\n', '    function buyin(address refaddr)public payable{\n', '        if(block.number < startblock) revert();\n', '        if(msg.value < minbid) { // wants a payout\n', '            redeemPayout();\n', '            return;\n', '        }\n', '        Investment storage acc = investmentTable[roundcount][msg.sender];\n', '        uint addreward = getAccountBalance(msg.sender);\n', '        uint win = addreward - acc.initamount;\n', '        if(win > 0){\n', '            investmentTable[roundcount][acc.refaddress].refbonus += win / 10; // Referral get 10%\n', '        }\n', '        \n', '        acc.initamount = msg.value + addreward;\n', '        acc.inittime = block.timestamp;\n', '        if(refaddr != msg.sender && acc.refaddress == nulladdress){\n', '            acc.refaddress = refaddr;\n', '            investmentTable[roundcount][refaddr].refcount++;\n', '        }\n', '        \n', '        payincount++;\n', '    }\n', '    function redeemPayout() public {\n', '        Investment storage acc = investmentTable[roundcount][msg.sender];\n', '        uint addreward = getAccountBalance(msg.sender);\n', '        uint win = addreward - acc.initamount;\n', '        uint payamount = addreward + acc.refbonus;\n', '        if(payamount <= 0) return;\n', '        if(address(this).balance < payamount){\n', '            reset();\n', '        }else{\n', '            payoutList[payoutcount++] = Payment(msg.sender, acc.initamount, payamount);\n', '            acc.initamount = 0;\n', '            acc.refbonus = 0;\n', '            msg.sender.transfer(payamount);\n', '            investmentTable[roundcount][acc.refaddress].refbonus += win / 10; // Referral get 10%\n', '        }\n', '    }\n', '    function reset() private {\n', '        // todo reset list\n', '        if(restaddress.send(address(this).balance)){\n', '            // Should always be possible, otherwise new payers have good luck ;)\n', '        }\n', '        roundcount++;\n', '        payincount = 0;\n', '    }\n', '    function getAccountBalance(address addr)public constant returns (uint amount){\n', '        Investment storage acc = investmentTable[roundcount][addr];\n', '        uint ret = acc.initamount;\n', '        if(acc.initamount > 0){\n', '            uint rewardcount = (block.timestamp - acc.inittime) / rewardinterval;\n', '            if(rewardcount > maxdays) rewardcount = maxdays;\n', '            while(rewardcount > 0){\n', '                ret += ret / 200; // 0.5%\n', '                rewardcount--;\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '    function getPayout(uint idrel) public constant returns (address bidder, uint inamount, uint outamount) {\n', '        Payment storage cur =  payoutList[idrel];\n', '        return (cur.receiver, cur.inamount, cur.outamount);\n', '    }\n', '    function getBlocksUntilStart() public constant returns (uint count){\n', '        if(startblock <= block.number) return 0;\n', '        else return startblock - block.number;\n', '    }\n', '    function getAccountInfo(address addr) public constant returns (address retaddr, uint initamount, uint investmenttime, uint currentbalance, uint _timeuntilnextreward, uint _refbonus, address _refaddress, uint _refcount) {\n', '        Investment storage acc = investmentTable[roundcount][addr];\n', '        uint nextreward = rewardinterval - ((block.timestamp - acc.inittime) % rewardinterval);\n', '        if(acc.initamount <= 0) nextreward = 0;\n', '        return (addr, acc.initamount, block.timestamp - acc.inittime, getAccountBalance(addr), nextreward, acc.refbonus, acc.refaddress, acc.refcount);\n', '    }\n', '    function getAccountInfo() public constant returns (address retaddr, uint initamount, uint investmenttime, uint currentbalance, uint _timeuntilnextreward, uint _refbonus, address _refaddress, uint _refcount) {\n', '        return getAccountInfo(msg.sender);\n', '    }\n', '    function getStatus() public constant returns (uint _payoutcount, uint _blocksUntilStart, uint _payincount){\n', '        return (payoutcount, getBlocksUntilStart(), payincount);\n', '    }\n', '}']
