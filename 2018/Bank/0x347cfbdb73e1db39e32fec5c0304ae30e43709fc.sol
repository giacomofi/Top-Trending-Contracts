['pragma solidity  ^0.4.21;\n', '\n', '\n', 'contract DSMath {\n', '    uint constant DENOMINATOR = 10000;\n', '    uint constant DECIMALS = 18;\n', '    uint constant WAD = 10**DECIMALS;\n', '\n', '    modifier condition(bool _condition) {\n', '        require(_condition);\n', '        _;\n', '    }\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\t\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\t\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '}\n', '\n', '\n', 'contract Token is DSMath {\n', '    string  public symbol;\n', '    uint256 public decimals;\n', '    string  public name;\n', '    address public owner;\n', '\n', '    uint256 internal _supply;\n', '    mapping (address => uint256) internal _balances;\n', '    mapping (address => mapping (address => uint256)) private _approvals;\n', '\n', '    event LogSetOwner(address indexed owner_);\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner_, address indexed spender, uint value);\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Token() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _supply;\n', '    }\n', '\n', '    function balanceOf(address src) public constant returns (uint256) {\n', '        return _balances[src];\n', '    }\n', '\n', '    function allowance(address src, address guy) public constant returns (uint256) {\n', '        return _approvals[src][guy];\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        require(_balances[msg.sender] >= wad);\n', '\n', '        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(msg.sender, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool) {\n', '        require(_balances[src] >= wad);\n', '        require(_approvals[src][msg.sender] >= wad);\n', '\n', '        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address guy, uint256 wad) public returns (bool) {\n', '        _approvals[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function mint(uint wad)\n', '    public\n', '    auth\n', '    {\n', '        _balances[msg.sender] = add(_balances[msg.sender], wad);\n', '        _supply = add(_supply, wad);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function isAuthorized(address src) internal constant returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Universal Token\n', 'contract UniversalToken is Token {\n', '    uint public xactionFeeNumerator;\n', '    uint public xactionFeeShare;\n', '\n', '    function UniversalToken( \n', '        uint initialSupply,\n', '        uint feeMult,\n', '        uint feeShare ) public\n', '        condition(initialSupply > 1000)\n', '        condition(feeMult > 0)\n', '    {\n', '        symbol = "PMT";\n', '        name = "Universal Evangelist Token - by Pure Money Tech";\n', '        decimals = DECIMALS;\n', '\t\t_supply = mul(initialSupply, WAD);\n', '\t\towner = msg.sender;\n', '        xactionFeeNumerator = feeMult;\n', '        xactionFeeShare = feeShare;\n', '\t\t_balances[owner] = _supply;\n', '    }\n', '\n', '    function modifyTransFee(uint _xactionFeeMult) public\n', '        auth\n', '        condition(_xactionFeeMult >= 0)\n', '        condition(DENOMINATOR > 4 * _xactionFeeMult)\n', '    {\n', '        xactionFeeNumerator = _xactionFeeMult;\n', '    }\n', '\n', '    function modifyFeeShare(uint _share) public\n', '        auth\n', '        condition(_share >= 0)\n', '        condition(DENOMINATOR > 3 * _share)\n', '    {\n', '        xactionFeeShare = _share;\n', '    }\n', '}']