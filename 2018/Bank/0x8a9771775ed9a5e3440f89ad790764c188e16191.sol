['pragma solidity ^0.4.24;\n', '\n', 'interface ERC721 /* is ERC165 */ {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function ownerOf(uint256 _tokenId) external view returns (address);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function approve(address _approved, uint256 _tokenId) external payable;\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev SafeMath library implemented for uint32\n', ' */\n', 'library SafeMath32 {\n', '\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev SafeMath library implemented for uint16\n', ' */\n', 'library SafeMath16 {\n', '\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owner {\n', '\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev set the owner of contract\n', '   */\n', '  constructor() public {\n', '      owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev only the owner\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title GreedyCoin\n', ' */\n', 'contract GreedyCoin is Owner,ERC721 {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // total supply\n', '  uint16  constant ISSUE_MAX = 2100;\n', '\n', '  // init price\n', '  uint256 constant START_PRICE = 0.1 ether;\n', '\n', '  // min price\n', '  uint256 constant PRICE_MIN = 0.000000000000000001 ether;\n', '\n', '  // max price\n', '  uint256 constant PRICE_LIMIT = 100000000 ether;\n', '\n', '  // percent of fee\n', '  uint256 constant PROCEDURE_FEE_PERCENT = 10;\n', '\n', '  // GreedyCoin token\n', '  struct TokenGDC{\n', '    bytes32 token_hash;\n', '    uint256 last_deal_time;\n', '    uint256 buying_price;\n', '    uint256 price;\n', '  }\n', '\n', '  /**\n', '   * @dev token structure\n', '  */\n', '  TokenGDC[] stTokens;\n', '\n', '  /**\n', '   * @dev owner of tokens ( index => address )\n', '  */\n', '  mapping (uint256 => address) stTokenIndexToOwner;\n', '\n', '  /**\n', '   * @dev GreedyCoin count of one address\n', '  */\n', '  mapping (address => uint256) stOwnerTokenCount;\n', '\n', '  /**\n', '   * @dev set transfer token permission\n', '  */\n', '  mapping (uint256 => address) stTokenApprovals;\n', '\n', '  /**\n', '  * @dev set approved address\n', '  */\n', '  mapping (address => mapping (address => bool) ) stApprovalForAll;\n', '\n', '\n', '  /*\n', '   * @dev (ERC721)\n', '   */\n', '  function balanceOf(address owner) external view returns (uint256 balance){\n', '    balance = stOwnerTokenCount[owner];\n', '  }\n', '  \n', '  /**\n', '   * @dev query the owner of one GreedyCoin\n', '   */\n', '  function ownerOf(uint256 token_id) external view returns (address owner){\n', '    owner = stTokenIndexToOwner[token_id];\n', '  }\n', '\n', '  /**\n', '   * @dev transfer from\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    require(msg.sender == _from);\n', '    require(_to != address(0));\n', '    require(_tokenId >= 0 && _tokenId < ISSUE_MAX - 1);\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev approve before transfer\n', '   */\n', '  function approve(address to, uint256 token_id) external payable {\n', '    require(msg.sender == stTokenIndexToOwner[token_id]);\n', '    stTokenApprovals[token_id] = to;\n', '    emit Approval(msg.sender, to, token_id);\n', '  }\n', '\n', '  /**\n', '   * @dev get approve\n', '   */\n', '  function getApproved(uint256 _tokenId) external view returns (address){\n', '    return stTokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev setApprovalForAll\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved) external {\n', '    stApprovalForAll[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev isApprovedForAll\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '    return stApprovalForAll[_owner][_operator] == true;\n', '  }\n', '\n', '  /**\n', '   * @dev _transfer\n', '   */\n', '  function _transfer(address from, address to, uint256 token_id) private {\n', '    require(stTokenApprovals[token_id] == to || stApprovalForAll[from][to]);\n', '    stOwnerTokenCount[to] = stOwnerTokenCount[to].add(1);\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].sub(1);\n', '    stTokenIndexToOwner[token_id] = to;\n', '    emit Transfer(from, to, token_id);\n', '  }\n', '\n', '  /**\n', '   * @dev query detail of one GreedyCoin\n', '   */\n', '  function queryToken(uint256 _tokenId) external view returns ( uint256 price, uint256 last_deal_time ) {\n', '    TokenGDC memory token = stTokens[_tokenId];\n', '    price = token.price;\n', '    last_deal_time = token.last_deal_time;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev get all GreedyCoins of msg.sender\n', '   */\n', '  function getMyTokens() external view returns ( uint256[] arr_token_id, uint256[] arr_last_deal_time, uint256[] buying_price_arr, uint256[] price_arr ){\n', '\n', '    TokenGDC memory token;\n', '\n', '    uint256 count = stOwnerTokenCount[msg.sender];\n', '    arr_last_deal_time = new uint256[](count);\n', '    buying_price_arr = new uint256[](count);\n', '    price_arr = new uint256[](count);\n', '    arr_token_id = new uint256[](count);\n', '\n', '    uint256 index = 0;\n', '    for ( uint i = 0; i < stTokens.length; i++ ){\n', '      if ( stTokenIndexToOwner[i] == msg.sender ) {\n', '        token = stTokens[i];\n', '        arr_last_deal_time[index] = token.last_deal_time;\n', '        buying_price_arr[index] = token.buying_price;\n', '        price_arr[index] = token.price;\n', '        arr_token_id[index] = i;\n', '        index = index + 1;\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'contract Market is GreedyCoin {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  event Bought (address indexed purchaser,uint256 indexed token_price, uint256 indexed next_price);\n', '  event HitFunds (address indexed purchaser,uint256 indexed funds, uint256 indexed hit_time);\n', '  event Recommended (address indexed recommender, uint256 indexed agency_fee);\n', '\n', '  // buy (only accept normal address)\n', '  function buy(uint256 next_price, bool is_recommend, uint256 recommend_token_id) external payable mustCommonAddress {\n', '\n', '    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\n', '\n', '    _checkRecommend(is_recommend,recommend_token_id);\n', '    if (stTokens.length < ISSUE_MAX ){\n', '      _buyAndCreateToken(next_price,is_recommend,recommend_token_id);\n', '    } else {\n', '      _buyFromMarket(next_price,is_recommend,recommend_token_id);\n', '    }\n', '  }\n', '\n', '  // query current blance of fees\n', '  function queryCurrentContractFunds() external view returns (uint256) {\n', '    return (address)(this).balance;\n', '  }\n', '\n', '  // query the lowest price\n', '  function queryCurrentTradablePrice() external view returns (uint256 token_id,uint256 price) {\n', '    if (stTokens.length < ISSUE_MAX){\n', '      token_id = stTokens.length;\n', '      price = START_PRICE;\n', '    } else {\n', '      token_id = _getCurrentTradableToken();\n', '      price = stTokens[token_id].price;\n', '    }\n', '  }\n', '\n', '  // get the cheapest GreedyCoin\n', '  function _getCurrentTradableToken() private view returns(uint256 token_id) {\n', '    uint256 token_count = stTokens.length;\n', '    uint256 min_price = stTokens[0].price;\n', '    token_id = 0;\n', '    for ( uint i = 0; i < token_count; i++ ){\n', '      // token = stTokens[i];\n', '      uint256 price = stTokens[i].price;\n', '      if (price < min_price) {\n', '        // token = stTokens[i];\n', '        min_price = price;\n', '        token_id = i;\n', '      }\n', '    }\n', '  }\n', '\n', '  // create GreedyCoin\n', '  function _buyAndCreateToken(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\n', '\n', '    require( msg.value >= START_PRICE );\n', '\n', '    // create\n', '    uint256 now_time = now;\n', '    uint256 token_id = stTokens.length;\n', '    TokenGDC memory token;\n', '    token = TokenGDC({\n', '      token_hash: keccak256(abi.encodePacked((address)(this), token_id)),\n', '      last_deal_time: now_time,\n', '      buying_price: START_PRICE,\n', '      price: next_price\n', '    });\n', '    stTokens.push(token);\n', '\n', '    stTokenIndexToOwner[token_id] = msg.sender;\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\n', '\n', '    // 10% fee\n', '    uint256 current_fund = START_PRICE.div(100 / PROCEDURE_FEE_PERCENT);\n', '\n', '    // hash of GreedyCoin\n', '    bytes32 current_token_hash = token.token_hash;\n', '\n', '    owner.transfer( START_PRICE - current_fund );\n', '\n', '    // if get all fees\n', '    _gambling(current_fund, current_token_hash, now_time);\n', '\n', '    // recommendation\n', '    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\n', '\n', '    _refund(msg.value - START_PRICE);\n', '\n', '    // emit event\n', '    emit Bought(msg.sender, START_PRICE, next_price);\n', '\n', '  }\n', '\n', '// buy GreedyCoin from each other,after all GreedyCoins has been created\n', '  function _buyFromMarket(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\n', '\n', '    uint256 current_tradable_token_id = _getCurrentTradableToken();\n', '    TokenGDC storage token = stTokens[current_tradable_token_id];\n', '\n', '    uint256 current_token_price = token.price;\n', '\n', '    bytes32 current_token_hash = token.token_hash;\n', '\n', '    uint256 last_deal_time = token.last_deal_time;\n', '\n', '    require( msg.value >= current_token_price );\n', '\n', '    uint256 refund_amount = msg.value - current_token_price;\n', '\n', '    token.price = next_price;\n', '\n', '    token.buying_price = current_token_price;\n', '\n', '    token.last_deal_time = now;\n', '\n', '    address origin_owner = stTokenIndexToOwner[current_tradable_token_id];\n', '\n', '    stOwnerTokenCount[origin_owner] =  stOwnerTokenCount[origin_owner].sub(1);\n', '\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\n', '\n', '    stTokenIndexToOwner[current_tradable_token_id] = msg.sender;\n', '\n', '    uint256 current_fund = current_token_price.div(100 / PROCEDURE_FEE_PERCENT);\n', '\n', '    origin_owner.transfer( current_token_price - current_fund );\n', '\n', '    _gambling(current_fund, current_token_hash, last_deal_time);\n', '\n', '    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\n', '\n', '    _refund(refund_amount);\n', '\n', '    emit Bought(msg.sender, current_token_price, next_price);\n', '  }\n', '\n', '  function _awardForRecommender(bool is_recommend, uint256 recommend_token_id, uint256 current_fund) private {\n', '\n', '    if ( is_recommend && stTokens.length >= recommend_token_id) {\n', '\n', '      address recommender = stTokenIndexToOwner[recommend_token_id];\n', '\n', '      // 50% of fee\n', '      uint256 agency_fee = current_fund.div(2);\n', '\n', '      recommender.transfer(agency_fee);\n', '\n', '      emit Recommended(recommender,agency_fee);\n', '    }\n', '  }\n', '\n', '  function _refund(uint256 refund_amount) private {\n', '    if ( refund_amount > 0 ) {\n', '      msg.sender.transfer(refund_amount);\n', '    }\n', '  }\n', '\n', '  // 10% change of getting all blance of fees\n', '  function _gambling(uint256 current_fund, bytes32 current_token_hash, uint256 last_deal_time) private {\n', '\n', '    // random 0 - 99\n', '    uint256 random_number = _createRandomNumber(current_token_hash,last_deal_time);\n', '\n', '    if ( random_number < 10 ) {\n', '\n', '      // contract address\n', '      address contract_address = (address)(this);\n', '\n', '      uint256 hit_funds = contract_address.balance.sub(current_fund);\n', '\n', '      msg.sender.transfer(hit_funds);\n', '\n', '      emit HitFunds(msg.sender, hit_funds, now);\n', '    }\n', '  }\n', '\n', '  function _createRandomNumber(bytes32 current_token_hash, uint256 last_deal_time) private pure returns (uint256) {\n', '    return (uint256)(keccak256(abi.encodePacked(current_token_hash, last_deal_time))) % 100;\n', '  }\n', '\n', '  function _checkRecommend(bool is_recommend, uint256 recommend_token_id) private view {\n', '    if ( is_recommend ) {\n', '      if ( stTokens.length > 0 ) {\n', '        require(recommend_token_id >= 0 && recommend_token_id < stTokens.length);\n', '      } \n', '    }\n', '  }\n', '\n', '  modifier aboveMinNextPrice(uint next_price) { \n', '    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\n', '    _;\n', '  }\n', '\n', '  // must be a normal address\n', '  modifier mustCommonAddress() { \n', '    require (_isContract(msg.sender) == false);\n', '    _; \n', '  }\n', '\n', '  // check if it is the address of contract\n', '  function _isContract(address addr) private view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface ERC721 /* is ERC165 */ {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function ownerOf(uint256 _tokenId) external view returns (address);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function approve(address _approved, uint256 _tokenId) external payable;\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev SafeMath library implemented for uint32\n', ' */\n', 'library SafeMath32 {\n', '\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev SafeMath library implemented for uint16\n', ' */\n', 'library SafeMath16 {\n', '\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owner {\n', '\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev set the owner of contract\n', '   */\n', '  constructor() public {\n', '      owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev only the owner\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title GreedyCoin\n', ' */\n', 'contract GreedyCoin is Owner,ERC721 {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // total supply\n', '  uint16  constant ISSUE_MAX = 2100;\n', '\n', '  // init price\n', '  uint256 constant START_PRICE = 0.1 ether;\n', '\n', '  // min price\n', '  uint256 constant PRICE_MIN = 0.000000000000000001 ether;\n', '\n', '  // max price\n', '  uint256 constant PRICE_LIMIT = 100000000 ether;\n', '\n', '  // percent of fee\n', '  uint256 constant PROCEDURE_FEE_PERCENT = 10;\n', '\n', '  // GreedyCoin token\n', '  struct TokenGDC{\n', '    bytes32 token_hash;\n', '    uint256 last_deal_time;\n', '    uint256 buying_price;\n', '    uint256 price;\n', '  }\n', '\n', '  /**\n', '   * @dev token structure\n', '  */\n', '  TokenGDC[] stTokens;\n', '\n', '  /**\n', '   * @dev owner of tokens ( index => address )\n', '  */\n', '  mapping (uint256 => address) stTokenIndexToOwner;\n', '\n', '  /**\n', '   * @dev GreedyCoin count of one address\n', '  */\n', '  mapping (address => uint256) stOwnerTokenCount;\n', '\n', '  /**\n', '   * @dev set transfer token permission\n', '  */\n', '  mapping (uint256 => address) stTokenApprovals;\n', '\n', '  /**\n', '  * @dev set approved address\n', '  */\n', '  mapping (address => mapping (address => bool) ) stApprovalForAll;\n', '\n', '\n', '  /*\n', '   * @dev (ERC721)\n', '   */\n', '  function balanceOf(address owner) external view returns (uint256 balance){\n', '    balance = stOwnerTokenCount[owner];\n', '  }\n', '  \n', '  /**\n', '   * @dev query the owner of one GreedyCoin\n', '   */\n', '  function ownerOf(uint256 token_id) external view returns (address owner){\n', '    owner = stTokenIndexToOwner[token_id];\n', '  }\n', '\n', '  /**\n', '   * @dev transfer from\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    require(msg.sender == _from);\n', '    require(_to != address(0));\n', '    require(_tokenId >= 0 && _tokenId < ISSUE_MAX - 1);\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev approve before transfer\n', '   */\n', '  function approve(address to, uint256 token_id) external payable {\n', '    require(msg.sender == stTokenIndexToOwner[token_id]);\n', '    stTokenApprovals[token_id] = to;\n', '    emit Approval(msg.sender, to, token_id);\n', '  }\n', '\n', '  /**\n', '   * @dev get approve\n', '   */\n', '  function getApproved(uint256 _tokenId) external view returns (address){\n', '    return stTokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev setApprovalForAll\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved) external {\n', '    stApprovalForAll[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev isApprovedForAll\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '    return stApprovalForAll[_owner][_operator] == true;\n', '  }\n', '\n', '  /**\n', '   * @dev _transfer\n', '   */\n', '  function _transfer(address from, address to, uint256 token_id) private {\n', '    require(stTokenApprovals[token_id] == to || stApprovalForAll[from][to]);\n', '    stOwnerTokenCount[to] = stOwnerTokenCount[to].add(1);\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].sub(1);\n', '    stTokenIndexToOwner[token_id] = to;\n', '    emit Transfer(from, to, token_id);\n', '  }\n', '\n', '  /**\n', '   * @dev query detail of one GreedyCoin\n', '   */\n', '  function queryToken(uint256 _tokenId) external view returns ( uint256 price, uint256 last_deal_time ) {\n', '    TokenGDC memory token = stTokens[_tokenId];\n', '    price = token.price;\n', '    last_deal_time = token.last_deal_time;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev get all GreedyCoins of msg.sender\n', '   */\n', '  function getMyTokens() external view returns ( uint256[] arr_token_id, uint256[] arr_last_deal_time, uint256[] buying_price_arr, uint256[] price_arr ){\n', '\n', '    TokenGDC memory token;\n', '\n', '    uint256 count = stOwnerTokenCount[msg.sender];\n', '    arr_last_deal_time = new uint256[](count);\n', '    buying_price_arr = new uint256[](count);\n', '    price_arr = new uint256[](count);\n', '    arr_token_id = new uint256[](count);\n', '\n', '    uint256 index = 0;\n', '    for ( uint i = 0; i < stTokens.length; i++ ){\n', '      if ( stTokenIndexToOwner[i] == msg.sender ) {\n', '        token = stTokens[i];\n', '        arr_last_deal_time[index] = token.last_deal_time;\n', '        buying_price_arr[index] = token.buying_price;\n', '        price_arr[index] = token.price;\n', '        arr_token_id[index] = i;\n', '        index = index + 1;\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'contract Market is GreedyCoin {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  event Bought (address indexed purchaser,uint256 indexed token_price, uint256 indexed next_price);\n', '  event HitFunds (address indexed purchaser,uint256 indexed funds, uint256 indexed hit_time);\n', '  event Recommended (address indexed recommender, uint256 indexed agency_fee);\n', '\n', '  // buy (only accept normal address)\n', '  function buy(uint256 next_price, bool is_recommend, uint256 recommend_token_id) external payable mustCommonAddress {\n', '\n', '    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\n', '\n', '    _checkRecommend(is_recommend,recommend_token_id);\n', '    if (stTokens.length < ISSUE_MAX ){\n', '      _buyAndCreateToken(next_price,is_recommend,recommend_token_id);\n', '    } else {\n', '      _buyFromMarket(next_price,is_recommend,recommend_token_id);\n', '    }\n', '  }\n', '\n', '  // query current blance of fees\n', '  function queryCurrentContractFunds() external view returns (uint256) {\n', '    return (address)(this).balance;\n', '  }\n', '\n', '  // query the lowest price\n', '  function queryCurrentTradablePrice() external view returns (uint256 token_id,uint256 price) {\n', '    if (stTokens.length < ISSUE_MAX){\n', '      token_id = stTokens.length;\n', '      price = START_PRICE;\n', '    } else {\n', '      token_id = _getCurrentTradableToken();\n', '      price = stTokens[token_id].price;\n', '    }\n', '  }\n', '\n', '  // get the cheapest GreedyCoin\n', '  function _getCurrentTradableToken() private view returns(uint256 token_id) {\n', '    uint256 token_count = stTokens.length;\n', '    uint256 min_price = stTokens[0].price;\n', '    token_id = 0;\n', '    for ( uint i = 0; i < token_count; i++ ){\n', '      // token = stTokens[i];\n', '      uint256 price = stTokens[i].price;\n', '      if (price < min_price) {\n', '        // token = stTokens[i];\n', '        min_price = price;\n', '        token_id = i;\n', '      }\n', '    }\n', '  }\n', '\n', '  // create GreedyCoin\n', '  function _buyAndCreateToken(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\n', '\n', '    require( msg.value >= START_PRICE );\n', '\n', '    // create\n', '    uint256 now_time = now;\n', '    uint256 token_id = stTokens.length;\n', '    TokenGDC memory token;\n', '    token = TokenGDC({\n', '      token_hash: keccak256(abi.encodePacked((address)(this), token_id)),\n', '      last_deal_time: now_time,\n', '      buying_price: START_PRICE,\n', '      price: next_price\n', '    });\n', '    stTokens.push(token);\n', '\n', '    stTokenIndexToOwner[token_id] = msg.sender;\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\n', '\n', '    // 10% fee\n', '    uint256 current_fund = START_PRICE.div(100 / PROCEDURE_FEE_PERCENT);\n', '\n', '    // hash of GreedyCoin\n', '    bytes32 current_token_hash = token.token_hash;\n', '\n', '    owner.transfer( START_PRICE - current_fund );\n', '\n', '    // if get all fees\n', '    _gambling(current_fund, current_token_hash, now_time);\n', '\n', '    // recommendation\n', '    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\n', '\n', '    _refund(msg.value - START_PRICE);\n', '\n', '    // emit event\n', '    emit Bought(msg.sender, START_PRICE, next_price);\n', '\n', '  }\n', '\n', '// buy GreedyCoin from each other,after all GreedyCoins has been created\n', '  function _buyFromMarket(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\n', '\n', '    uint256 current_tradable_token_id = _getCurrentTradableToken();\n', '    TokenGDC storage token = stTokens[current_tradable_token_id];\n', '\n', '    uint256 current_token_price = token.price;\n', '\n', '    bytes32 current_token_hash = token.token_hash;\n', '\n', '    uint256 last_deal_time = token.last_deal_time;\n', '\n', '    require( msg.value >= current_token_price );\n', '\n', '    uint256 refund_amount = msg.value - current_token_price;\n', '\n', '    token.price = next_price;\n', '\n', '    token.buying_price = current_token_price;\n', '\n', '    token.last_deal_time = now;\n', '\n', '    address origin_owner = stTokenIndexToOwner[current_tradable_token_id];\n', '\n', '    stOwnerTokenCount[origin_owner] =  stOwnerTokenCount[origin_owner].sub(1);\n', '\n', '    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\n', '\n', '    stTokenIndexToOwner[current_tradable_token_id] = msg.sender;\n', '\n', '    uint256 current_fund = current_token_price.div(100 / PROCEDURE_FEE_PERCENT);\n', '\n', '    origin_owner.transfer( current_token_price - current_fund );\n', '\n', '    _gambling(current_fund, current_token_hash, last_deal_time);\n', '\n', '    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\n', '\n', '    _refund(refund_amount);\n', '\n', '    emit Bought(msg.sender, current_token_price, next_price);\n', '  }\n', '\n', '  function _awardForRecommender(bool is_recommend, uint256 recommend_token_id, uint256 current_fund) private {\n', '\n', '    if ( is_recommend && stTokens.length >= recommend_token_id) {\n', '\n', '      address recommender = stTokenIndexToOwner[recommend_token_id];\n', '\n', '      // 50% of fee\n', '      uint256 agency_fee = current_fund.div(2);\n', '\n', '      recommender.transfer(agency_fee);\n', '\n', '      emit Recommended(recommender,agency_fee);\n', '    }\n', '  }\n', '\n', '  function _refund(uint256 refund_amount) private {\n', '    if ( refund_amount > 0 ) {\n', '      msg.sender.transfer(refund_amount);\n', '    }\n', '  }\n', '\n', '  // 10% change of getting all blance of fees\n', '  function _gambling(uint256 current_fund, bytes32 current_token_hash, uint256 last_deal_time) private {\n', '\n', '    // random 0 - 99\n', '    uint256 random_number = _createRandomNumber(current_token_hash,last_deal_time);\n', '\n', '    if ( random_number < 10 ) {\n', '\n', '      // contract address\n', '      address contract_address = (address)(this);\n', '\n', '      uint256 hit_funds = contract_address.balance.sub(current_fund);\n', '\n', '      msg.sender.transfer(hit_funds);\n', '\n', '      emit HitFunds(msg.sender, hit_funds, now);\n', '    }\n', '  }\n', '\n', '  function _createRandomNumber(bytes32 current_token_hash, uint256 last_deal_time) private pure returns (uint256) {\n', '    return (uint256)(keccak256(abi.encodePacked(current_token_hash, last_deal_time))) % 100;\n', '  }\n', '\n', '  function _checkRecommend(bool is_recommend, uint256 recommend_token_id) private view {\n', '    if ( is_recommend ) {\n', '      if ( stTokens.length > 0 ) {\n', '        require(recommend_token_id >= 0 && recommend_token_id < stTokens.length);\n', '      } \n', '    }\n', '  }\n', '\n', '  modifier aboveMinNextPrice(uint next_price) { \n', '    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\n', '    _;\n', '  }\n', '\n', '  // must be a normal address\n', '  modifier mustCommonAddress() { \n', '    require (_isContract(msg.sender) == false);\n', '    _; \n', '  }\n', '\n', '  // check if it is the address of contract\n', '  function _isContract(address addr) private view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}']
