['/*\n', '&#39;We are a gaming and entertainment network our blockChain launch product is HDX20 (http://hdx20.io)&#39;\n', '\n', 'HDX20 tokens can be bought & sold on our exchange and are distributed every time someone is playing a HDX20 POWERED GAME. \n', 'With 4% IN and 4% OUT fee only, price of the HDX20 can only go up by design, cannot be dumped on holders and is fueled\n', 'by both the volume of transactions and HDX20 POWERED GAMES.\n', '\n', 'The 4 principles of the HDX20 are :\n', '\n', '1) Buy it, its price will increase.\n', '2) Sell it, its price will increase.\n', '3) Transfer it, its price will increase.\n', '4) Play our HDX20 powered games, its price will increase.\n', '\n', 'Our Blockchain SmartContract IS the market and makes sure that the HDX20 Price never fall below its current selling price\n', 'thus offering an unique CONTEXT where risk is known at all time and limited to the IN and OUT fees only.\n', '\n', 'We have designed a vault where your HDX20 value while still indexed on the Ethereum Price will appreciate automatically over time.\n', '\n', 'This product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\n', '\n', 'Copyright 2018 HyperDevbox\n', '\n', 'fees distribution:\n', '.1% for developer / 3% for HDX20 price appreciation during BUY and SELL\n', '.1% for developer / 1% for HDX20 price appreciation during token Transfer\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', 'interface HDX20Interface\n', '{\n', '   \n', '    function moveAccountIn( address _customerAddress ) payable external;\n', '  \n', '}\n', '\n', 'contract HDX20\n', '{\n', '     using SafeMath for uint256;\n', '     \n', '     //address of a future contract to move in, by default set to 0\n', '     HDX20Interface private NewHDX20Contract = HDX20Interface(0);\n', '     \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event OwnershipTransferred(\n', '         address indexed previousOwner,\n', '         address indexed nextOwner\n', '         );\n', '         \n', '   \n', '         \n', '         \n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '  \n', '         \n', '    event onBuyEvent(\n', '        address from,\n', '        uint256 tokens\n', '    );\n', '   \n', '     event onSellEvent(\n', '        address from,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '         \n', '    event onAccountMovedOut(\n', '        address indexed from,\n', '        address to,\n', '        uint256 tokens,\n', '        uint256 eth\n', '    );\n', '    \n', '    event onAccountMovedIn(\n', '        address indexed from,\n', '        address to,\n', '        uint256 tokens,\n', '        uint256 eth\n', '    );\n', '    \n', '    event HDXcontractChanged(\n', '        \n', '         address previous,\n', '         address next,\n', '         uint256 timeStamp\n', '         );\n', '    \n', '    /*==============================\n', '    =            MODIFIERS         =\n', '    ==============================*/\n', '    modifier onlyOwner\n', '    {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyFromGameWhiteListed\n', '    {\n', '        require (gameWhiteListed[ msg.sender ] == true);\n', '        _;\n', '    }\n', '    \n', '  \n', '    \n', '    modifier onlyGameWhiteListed(address who)\n', '    {\n', '        require (gameWhiteListed[ who ] == true);\n', '        _;\n', '    }\n', '    \n', '    \n', '    modifier onlyTokenHolders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '  \n', ' \n', '  \n', '    address public owner;\n', '    \n', '     /// Contract governance.\n', '\n', '    constructor () public\n', '    {\n', '        owner = msg.sender;\n', '       \n', '        \n', '        if ( address(this).balance > 0)\n', '        {\n', '            owner.transfer( address(this).balance );\n', '        }\n', '    }\n', '\n', '  \n', '   \n', '\n', '    /*==============================\n', '    =       TOKEN VARIABLES        =\n', '    ==============================*/\n', '\n', '    string public name = "HDX20 token";\n', '    string public symbol = "HDX20";\n', '    uint8 constant public decimals = 18;\n', '    uint256 constant internal magnitude = 1e18;\n', '    \n', '    \n', '    \n', '    uint8 constant internal referrerFee = 50;    //that is 50% of the buyInFee fee \n', '    uint8 constant internal transferFee = 2;     //50% for the community 50% for developer\n', '    uint8 constant internal buyInFee = 3;        \n', '    uint8 constant internal sellOutFee = 3;      \n', '    uint8 constant internal devFee = 1;          //actually since dev is receiving fees in HDX20 exclusively, he is also taxed on the buyinfee so this not 1%\n', '    \n', '    \n', '    mapping(address => uint256) private tokenBalanceLedger;\n', '  \n', '    \n', '    uint256 private tokenSupply = 0;  \n', '    uint256 private contractValue = 0;\n', '    uint256 private tokenPrice = 0.001 ether;   //starting price\n', '  \n', '  \n', '   /*================================\n', '    =       HDX20 VARIABLES         =\n', '    ================================*/\n', '    \n', '    mapping(address => bool)   private gameWhiteListed;\n', '    mapping(address => uint8)  private superReferrerRate;\n', '   \n', '    \n', '    /*================================\n', '    =       PUBLIC FUNCTIONS         =\n', '    ================================*/\n', '    \n', '     /**\n', '     * Fallback function to process ethereum \n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        buyToken(address(0));\n', '    }\n', '    \n', '    \n', '    \n', '    function changeOwner(address _nextOwner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextOwner != owner);\n', '        require(_nextOwner != address(0));\n', '         \n', '        emit OwnershipTransferred(owner, _nextOwner);\n', '         \n', '        owner = _nextOwner;\n', '    }\n', '    \n', '    \n', ' \n', '    \n', '    function changeName(string _name) public\n', '    onlyOwner\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '  \n', '    function changeSymbol(string _symbol) public\n', '    onlyOwner\n', '    {\n', '        symbol = _symbol;\n', '    }\n', ' \n', '    \n', '    function addGame(address _contractAddress ) public\n', '    onlyOwner\n', '    {\n', '        gameWhiteListed[ _contractAddress ] = true;\n', '    }\n', '    \n', '    function addSuperReferrer(address _contractAddress , uint8 extra_rate) public\n', '    onlyOwner\n', '    {\n', '       superReferrerRate[ _contractAddress ] = extra_rate;\n', '    }\n', '    \n', '    function removeGame(address _contractAddress ) public\n', '    onlyOwner\n', '    {\n', '        gameWhiteListed[ _contractAddress ] = false;\n', '    }\n', '    \n', '    function changeNewHDX20Contract(address _next) public\n', '    onlyOwner\n', '    {\n', '        require (_next != address( NewHDX20Contract ));\n', '        require( _next != address(0));\n', '         \n', '        emit HDXcontractChanged(address(NewHDX20Contract), _next , now);\n', '         \n', '        NewHDX20Contract  = HDX20Interface( _next);\n', '    }\n', '    \n', '    function buyTokenSub( uint256 _eth , address _customerAddress ) private\n', '    returns(uint256)\n', '    {\n', '        \n', '        uint256 _nb_token = (_eth.mul( magnitude)) / tokenPrice;\n', '        \n', '        \n', '        tokenBalanceLedger[ _customerAddress ] =  tokenBalanceLedger[ _customerAddress ].add( _nb_token);\n', '        tokenSupply = tokenSupply.add(_nb_token);\n', '        \n', '        emit onBuyEvent( _customerAddress , _nb_token);\n', '        \n', '        return( _nb_token );\n', '     \n', '    }\n', '    \n', '    function buyTokenFromGame( address _customerAddress , address _referrer_address ) public payable\n', '    onlyFromGameWhiteListed\n', '    returns(uint256)\n', '    {\n', '        uint256 _eth = msg.value;\n', '        \n', '        if (_eth==0) return(0);\n', '        \n', '        \n', '        uint256 _devfee = (_eth.mul( devFee )) / 100;\n', '        \n', '        uint256 _fee = (_eth.mul( buyInFee )) / 100;\n', '        \n', '        if (_referrer_address != address(0) && _referrer_address != _customerAddress )\n', '        {\n', '             uint256 _ethReferrer = (_fee.mul(referrerFee + superReferrerRate[_referrer_address])) / 100;\n', '\n', '             buyTokenSub( _ethReferrer , _referrer_address);\n', '             \n', '             //substract what is given to referrer\n', '             _fee = _fee.sub( _ethReferrer );\n', '             \n', '        }\n', '        \n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '        \n', '        buyTokenSub( (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        //finally buy for the buyer\n', '     \n', '        uint256 _nb_token = buyTokenSub( _eth - _fee -_devfee , _customerAddress);\n', '        \n', '        //add the value to the contract\n', '        contractValue = contractValue.add( _eth );\n', '        \n', '      \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '       \n', '        \n', '        return( _nb_token );\n', '        \n', '    }\n', '  \n', '  \n', '    function buyToken( address _referrer_address ) public payable\n', '    returns(uint256)\n', '    {\n', '        uint256 _eth = msg.value;\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require( _eth>0);\n', '        \n', '        uint256 _devfee = (_eth.mul( devFee )) / 100;\n', '         \n', '        uint256 _fee = (_eth.mul( buyInFee )) / 100;\n', '        \n', '        if (_referrer_address != address(0) && _referrer_address != _customerAddress )\n', '        {\n', '             uint256 _ethReferrer = (_fee.mul(referrerFee + superReferrerRate[_referrer_address])) / 100;\n', '\n', '             buyTokenSub( _ethReferrer , _referrer_address);\n', '             \n', '            //substract what is given to referrer\n', '             _fee = _fee.sub( _ethReferrer );\n', '             \n', '        }\n', '\n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '\n', '        buyTokenSub( (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        //finally buy for the buyer\n', '      \n', '        uint256 _nb_token = buyTokenSub( _eth - _fee -_devfee , _customerAddress);\n', '        \n', '        //add the value to the contract\n', '        contractValue = contractValue.add( _eth );\n', '        \n', '     \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        return( _nb_token );\n', '        \n', '    }\n', '    \n', '    function sellToken( uint256 _amount ) public\n', '    onlyTokenHolders\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        uint256 balance = tokenBalanceLedger[ _customerAddress ];\n', '        \n', '        require( _amount <= balance);\n', '        \n', '        uint256 _eth = (_amount.mul( tokenPrice )) / magnitude;\n', '        \n', '        uint256 _fee = (_eth.mul( sellOutFee)) / 100;\n', '        \n', '        uint256 _devfee = (_eth.mul( devFee)) / 100;\n', '        \n', '        tokenSupply = tokenSupply.sub( _amount );\n', '       \n', '     \n', '        balance = balance.sub( _amount );\n', '        \n', '        tokenBalanceLedger[ _customerAddress] = balance;\n', '        \n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '        buyTokenSub(  (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        \n', '        //calculate what is really leaving the contract, basically _eth - _fee -devfee\n', '        _eth = _eth - _fee - _devfee; \n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '       \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '         emit onSellEvent( _customerAddress , _amount);\n', '        \n', '         //finally transfer the money\n', '        _customerAddress.transfer( _eth );\n', '        \n', '    }\n', '   \n', '    //there is no fee using token to play HDX20 powered games \n', '  \n', '    function payWithToken( uint256 _eth , address _player_address ) public\n', '    onlyFromGameWhiteListed\n', '    returns(uint256)\n', '    {\n', '        require( _eth>0 && _eth <= ethBalanceOfNoFee(_player_address ));\n', '        \n', '        address _game_contract = msg.sender;\n', '        \n', '        uint256 balance = tokenBalanceLedger[ _player_address ];\n', '        \n', '        uint256 _nb_token = (_eth.mul( magnitude) ) / tokenPrice;\n', '        \n', '        require( _nb_token <= balance);\n', '        \n', '        //confirm the ETH value\n', '        _eth = (_nb_token.mul( tokenPrice)) / magnitude;\n', '        \n', '        balance = balance.sub(_nb_token);\n', '        \n', '        tokenSupply = tokenSupply.sub( _nb_token);\n', '        \n', '        tokenBalanceLedger[ _player_address ] = balance;\n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '       \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        //send the money to the game contract   \n', '        _game_contract.transfer( _eth );\n', '      \n', '      \n', '        return( _eth );\n', '    }\n', '    \n', '    function moveAccountOut() public\n', '    onlyTokenHolders\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require( ethBalanceOfNoFee( _customerAddress )>0 && address(NewHDX20Contract) != address(0));\n', '    \n', '        uint256 balance = tokenBalanceLedger[ _customerAddress ];\n', '    \n', '        uint256 _eth = (balance.mul( tokenPrice )) / magnitude;\n', '        \n', '       \n', '        tokenSupply = tokenSupply.sub( balance );\n', '        \n', '        tokenBalanceLedger[ _customerAddress ] = 0;\n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '     \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        emit onAccountMovedOut( _customerAddress , address(NewHDX20Contract), balance , _eth );\n', '      \n', '        //send the money to the new HDX20 contract which will buy on customer behalf at no fee converting eth for eth\n', '        //notice this could give more or less HDX20 however the eth value should be preserved\n', '        NewHDX20Contract.moveAccountIn.value(_eth)(_customerAddress);\n', '      \n', '    }\n', '    \n', '    function moveAccountIn(address _customerAddress) public\n', '    payable\n', '    onlyFromGameWhiteListed\n', '    {\n', '        \n', '        \n', '        uint256 _eth = msg.value;\n', '      \n', '        //buy token at no fee\n', '        uint256 _nb_token = buyTokenSub( _eth , _customerAddress );\n', '        \n', '        contractValue = contractValue.add( _eth );\n', '    \n', '      \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        emit onAccountMovedIn( msg.sender, _customerAddress , _nb_token , _eth );\n', '     \n', '    }\n', '    \n', '    \n', '    function appreciateTokenPrice() public payable\n', '    onlyFromGameWhiteListed\n', '    {\n', '        uint256 _eth =  msg.value;\n', '       \n', '        contractValue = contractValue.add( _eth );\n', '            \n', '        //we need a minimum of 1 HDX20 before appreciation is activated    \n', '        if (tokenSupply>magnitude)\n', '        {\n', '                tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '    }\n', '    \n', '  \n', '    \n', '    function transferSub(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\n', '    private\n', '    returns(bool)\n', '    {\n', '       \n', '        require( _amountOfTokens <= tokenBalanceLedger[_customerAddress] );\n', '        \n', '        //actually a transfer of 0 token is valid in ERC20\n', '        if (_amountOfTokens>0)\n', '        {\n', '            \n', '           \n', '            {\n', '            \n', '                uint256 _token_fee =  (_amountOfTokens.mul( transferFee )) / 100;\n', '               \n', '                _token_fee /= 2;\n', '               \n', '                \n', '                //now proceed the transfer\n', '                tokenBalanceLedger[ _customerAddress] = tokenBalanceLedger[ _customerAddress].sub( _amountOfTokens );\n', '                tokenBalanceLedger[ _toAddress] = tokenBalanceLedger[ _toAddress].add( _amountOfTokens - (_token_fee*2) );\n', '              \n', '                //half fee in HDX20 directly credited to developer\n', '                tokenBalanceLedger[ owner ] += _token_fee;\n', '                \n', '                //burning the other half of token to drive the price up\n', '                tokenSupply = tokenSupply.sub( _token_fee );\n', '              \n', '             \n', '                if (tokenSupply>magnitude)\n', '                {\n', '                    tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '                }\n', '               \n', '            }\n', '           \n', '           \n', '          \n', '        \n', '        }\n', '      \n', '      \n', '        // fire event\n', '        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n', '        \n', '        // ERC20\n', '        return true;\n', '       \n', '    }\n', '    \n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '    public\n', '    returns(bool)\n', '    {\n', '        \n', '        return( transferSub( msg.sender ,  _toAddress, _amountOfTokens));\n', '       \n', '    }\n', '    \n', '  \n', '    \n', '    \n', '    /*================================\n', '    =  VIEW AND HELPERS FUNCTIONS    =\n', '    ================================*/\n', '    \n', '  \n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function totalContractBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return contractValue;\n', '    }\n', '    \n', '  \n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply;\n', '    }\n', '    \n', '  \n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '    \n', '   \n', '    function balanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger[_customerAddress];\n', '    }\n', '    \n', '    function sellingPrice( bool includeFees)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _fee = 0;\n', '        uint256 _devfee=0;\n', '        \n', '        if (includeFees)\n', '        {\n', '            _fee = (tokenPrice.mul( sellOutFee ) ) / 100;\n', '            _devfee = (tokenPrice.mul( devFee ) ) / 100;\n', '        }\n', '        \n', '        return( tokenPrice - _fee - _devfee );\n', '        \n', '    }\n', '    \n', '    function buyingPrice( bool includeFees)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _fee = 0;\n', '        uint256 _devfee=0;\n', '        \n', '        if (includeFees)\n', '        {\n', '            _fee = (tokenPrice.mul( buyInFee ) ) / 100;\n', '            _devfee = (tokenPrice.mul( devFee ) ) / 100;\n', '        }\n', '        \n', '        return( tokenPrice + _fee + _devfee );\n', '        \n', '    }\n', '    \n', '    function ethBalanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        uint256 _price = sellingPrice( true );\n', '        \n', '        uint256 _balance = tokenBalanceLedger[ _customerAddress];\n', '        \n', '        uint256 _value = (_balance.mul( _price )) / magnitude;\n', '        \n', '        \n', '        return( _value );\n', '    }\n', '    \n', '  \n', '   \n', '    function myEthBalanceOf()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return ethBalanceOf(_customerAddress);\n', '    }\n', '   \n', '   \n', '    function ethBalanceOfNoFee(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        uint256 _price = sellingPrice( false );\n', '        \n', '        uint256 _balance = tokenBalanceLedger[ _customerAddress];\n', '        \n', '        uint256 _value = (_balance.mul( _price )) / magnitude;\n', '        \n', '        \n', '        return( _value );\n', '    }\n', '    \n', '  \n', '   \n', '    function myEthBalanceOfNoFee()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return ethBalanceOfNoFee(_customerAddress);\n', '    }\n', '    \n', '    function checkGameListed(address _contract)\n', '        view\n', '        public\n', '        returns(bool)\n', '    {\n', '      \n', '      return( gameWhiteListed[ _contract]);\n', '    }\n', '    \n', '    function getSuperReferrerRate(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint8)\n', '    {\n', '      \n', '      return( referrerFee+superReferrerRate[ _customerAddress]);\n', '    }\n', '    \n', '  \n', '    \n', '}\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}']
['/*\n', "'We are a gaming and entertainment network our blockChain launch product is HDX20 (http://hdx20.io)'\n", '\n', 'HDX20 tokens can be bought & sold on our exchange and are distributed every time someone is playing a HDX20 POWERED GAME. \n', 'With 4% IN and 4% OUT fee only, price of the HDX20 can only go up by design, cannot be dumped on holders and is fueled\n', 'by both the volume of transactions and HDX20 POWERED GAMES.\n', '\n', 'The 4 principles of the HDX20 are :\n', '\n', '1) Buy it, its price will increase.\n', '2) Sell it, its price will increase.\n', '3) Transfer it, its price will increase.\n', '4) Play our HDX20 powered games, its price will increase.\n', '\n', 'Our Blockchain SmartContract IS the market and makes sure that the HDX20 Price never fall below its current selling price\n', 'thus offering an unique CONTEXT where risk is known at all time and limited to the IN and OUT fees only.\n', '\n', 'We have designed a vault where your HDX20 value while still indexed on the Ethereum Price will appreciate automatically over time.\n', '\n', 'This product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\n', '\n', 'Copyright 2018 HyperDevbox\n', '\n', 'fees distribution:\n', '.1% for developer / 3% for HDX20 price appreciation during BUY and SELL\n', '.1% for developer / 1% for HDX20 price appreciation during token Transfer\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', 'interface HDX20Interface\n', '{\n', '   \n', '    function moveAccountIn( address _customerAddress ) payable external;\n', '  \n', '}\n', '\n', 'contract HDX20\n', '{\n', '     using SafeMath for uint256;\n', '     \n', '     //address of a future contract to move in, by default set to 0\n', '     HDX20Interface private NewHDX20Contract = HDX20Interface(0);\n', '     \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event OwnershipTransferred(\n', '         address indexed previousOwner,\n', '         address indexed nextOwner\n', '         );\n', '         \n', '   \n', '         \n', '         \n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '  \n', '         \n', '    event onBuyEvent(\n', '        address from,\n', '        uint256 tokens\n', '    );\n', '   \n', '     event onSellEvent(\n', '        address from,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '         \n', '    event onAccountMovedOut(\n', '        address indexed from,\n', '        address to,\n', '        uint256 tokens,\n', '        uint256 eth\n', '    );\n', '    \n', '    event onAccountMovedIn(\n', '        address indexed from,\n', '        address to,\n', '        uint256 tokens,\n', '        uint256 eth\n', '    );\n', '    \n', '    event HDXcontractChanged(\n', '        \n', '         address previous,\n', '         address next,\n', '         uint256 timeStamp\n', '         );\n', '    \n', '    /*==============================\n', '    =            MODIFIERS         =\n', '    ==============================*/\n', '    modifier onlyOwner\n', '    {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyFromGameWhiteListed\n', '    {\n', '        require (gameWhiteListed[ msg.sender ] == true);\n', '        _;\n', '    }\n', '    \n', '  \n', '    \n', '    modifier onlyGameWhiteListed(address who)\n', '    {\n', '        require (gameWhiteListed[ who ] == true);\n', '        _;\n', '    }\n', '    \n', '    \n', '    modifier onlyTokenHolders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '  \n', ' \n', '  \n', '    address public owner;\n', '    \n', '     /// Contract governance.\n', '\n', '    constructor () public\n', '    {\n', '        owner = msg.sender;\n', '       \n', '        \n', '        if ( address(this).balance > 0)\n', '        {\n', '            owner.transfer( address(this).balance );\n', '        }\n', '    }\n', '\n', '  \n', '   \n', '\n', '    /*==============================\n', '    =       TOKEN VARIABLES        =\n', '    ==============================*/\n', '\n', '    string public name = "HDX20 token";\n', '    string public symbol = "HDX20";\n', '    uint8 constant public decimals = 18;\n', '    uint256 constant internal magnitude = 1e18;\n', '    \n', '    \n', '    \n', '    uint8 constant internal referrerFee = 50;    //that is 50% of the buyInFee fee \n', '    uint8 constant internal transferFee = 2;     //50% for the community 50% for developer\n', '    uint8 constant internal buyInFee = 3;        \n', '    uint8 constant internal sellOutFee = 3;      \n', '    uint8 constant internal devFee = 1;          //actually since dev is receiving fees in HDX20 exclusively, he is also taxed on the buyinfee so this not 1%\n', '    \n', '    \n', '    mapping(address => uint256) private tokenBalanceLedger;\n', '  \n', '    \n', '    uint256 private tokenSupply = 0;  \n', '    uint256 private contractValue = 0;\n', '    uint256 private tokenPrice = 0.001 ether;   //starting price\n', '  \n', '  \n', '   /*================================\n', '    =       HDX20 VARIABLES         =\n', '    ================================*/\n', '    \n', '    mapping(address => bool)   private gameWhiteListed;\n', '    mapping(address => uint8)  private superReferrerRate;\n', '   \n', '    \n', '    /*================================\n', '    =       PUBLIC FUNCTIONS         =\n', '    ================================*/\n', '    \n', '     /**\n', '     * Fallback function to process ethereum \n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        buyToken(address(0));\n', '    }\n', '    \n', '    \n', '    \n', '    function changeOwner(address _nextOwner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextOwner != owner);\n', '        require(_nextOwner != address(0));\n', '         \n', '        emit OwnershipTransferred(owner, _nextOwner);\n', '         \n', '        owner = _nextOwner;\n', '    }\n', '    \n', '    \n', ' \n', '    \n', '    function changeName(string _name) public\n', '    onlyOwner\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '  \n', '    function changeSymbol(string _symbol) public\n', '    onlyOwner\n', '    {\n', '        symbol = _symbol;\n', '    }\n', ' \n', '    \n', '    function addGame(address _contractAddress ) public\n', '    onlyOwner\n', '    {\n', '        gameWhiteListed[ _contractAddress ] = true;\n', '    }\n', '    \n', '    function addSuperReferrer(address _contractAddress , uint8 extra_rate) public\n', '    onlyOwner\n', '    {\n', '       superReferrerRate[ _contractAddress ] = extra_rate;\n', '    }\n', '    \n', '    function removeGame(address _contractAddress ) public\n', '    onlyOwner\n', '    {\n', '        gameWhiteListed[ _contractAddress ] = false;\n', '    }\n', '    \n', '    function changeNewHDX20Contract(address _next) public\n', '    onlyOwner\n', '    {\n', '        require (_next != address( NewHDX20Contract ));\n', '        require( _next != address(0));\n', '         \n', '        emit HDXcontractChanged(address(NewHDX20Contract), _next , now);\n', '         \n', '        NewHDX20Contract  = HDX20Interface( _next);\n', '    }\n', '    \n', '    function buyTokenSub( uint256 _eth , address _customerAddress ) private\n', '    returns(uint256)\n', '    {\n', '        \n', '        uint256 _nb_token = (_eth.mul( magnitude)) / tokenPrice;\n', '        \n', '        \n', '        tokenBalanceLedger[ _customerAddress ] =  tokenBalanceLedger[ _customerAddress ].add( _nb_token);\n', '        tokenSupply = tokenSupply.add(_nb_token);\n', '        \n', '        emit onBuyEvent( _customerAddress , _nb_token);\n', '        \n', '        return( _nb_token );\n', '     \n', '    }\n', '    \n', '    function buyTokenFromGame( address _customerAddress , address _referrer_address ) public payable\n', '    onlyFromGameWhiteListed\n', '    returns(uint256)\n', '    {\n', '        uint256 _eth = msg.value;\n', '        \n', '        if (_eth==0) return(0);\n', '        \n', '        \n', '        uint256 _devfee = (_eth.mul( devFee )) / 100;\n', '        \n', '        uint256 _fee = (_eth.mul( buyInFee )) / 100;\n', '        \n', '        if (_referrer_address != address(0) && _referrer_address != _customerAddress )\n', '        {\n', '             uint256 _ethReferrer = (_fee.mul(referrerFee + superReferrerRate[_referrer_address])) / 100;\n', '\n', '             buyTokenSub( _ethReferrer , _referrer_address);\n', '             \n', '             //substract what is given to referrer\n', '             _fee = _fee.sub( _ethReferrer );\n', '             \n', '        }\n', '        \n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '        \n', '        buyTokenSub( (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        //finally buy for the buyer\n', '     \n', '        uint256 _nb_token = buyTokenSub( _eth - _fee -_devfee , _customerAddress);\n', '        \n', '        //add the value to the contract\n', '        contractValue = contractValue.add( _eth );\n', '        \n', '      \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '       \n', '        \n', '        return( _nb_token );\n', '        \n', '    }\n', '  \n', '  \n', '    function buyToken( address _referrer_address ) public payable\n', '    returns(uint256)\n', '    {\n', '        uint256 _eth = msg.value;\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require( _eth>0);\n', '        \n', '        uint256 _devfee = (_eth.mul( devFee )) / 100;\n', '         \n', '        uint256 _fee = (_eth.mul( buyInFee )) / 100;\n', '        \n', '        if (_referrer_address != address(0) && _referrer_address != _customerAddress )\n', '        {\n', '             uint256 _ethReferrer = (_fee.mul(referrerFee + superReferrerRate[_referrer_address])) / 100;\n', '\n', '             buyTokenSub( _ethReferrer , _referrer_address);\n', '             \n', '            //substract what is given to referrer\n', '             _fee = _fee.sub( _ethReferrer );\n', '             \n', '        }\n', '\n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '\n', '        buyTokenSub( (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        //finally buy for the buyer\n', '      \n', '        uint256 _nb_token = buyTokenSub( _eth - _fee -_devfee , _customerAddress);\n', '        \n', '        //add the value to the contract\n', '        contractValue = contractValue.add( _eth );\n', '        \n', '     \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        return( _nb_token );\n', '        \n', '    }\n', '    \n', '    function sellToken( uint256 _amount ) public\n', '    onlyTokenHolders\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        uint256 balance = tokenBalanceLedger[ _customerAddress ];\n', '        \n', '        require( _amount <= balance);\n', '        \n', '        uint256 _eth = (_amount.mul( tokenPrice )) / magnitude;\n', '        \n', '        uint256 _fee = (_eth.mul( sellOutFee)) / 100;\n', '        \n', '        uint256 _devfee = (_eth.mul( devFee)) / 100;\n', '        \n', '        tokenSupply = tokenSupply.sub( _amount );\n', '       \n', '     \n', '        balance = balance.sub( _amount );\n', '        \n', '        tokenBalanceLedger[ _customerAddress] = balance;\n', '        \n', '        //for the developer as HDX20 token and also help to increase the price because taxed also on his own share like everybody else\n', '        buyTokenSub(  (_devfee.mul(100-buyInFee)) / 100 , owner );\n', '        \n', '        \n', '        //calculate what is really leaving the contract, basically _eth - _fee -devfee\n', '        _eth = _eth - _fee - _devfee; \n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '       \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '         emit onSellEvent( _customerAddress , _amount);\n', '        \n', '         //finally transfer the money\n', '        _customerAddress.transfer( _eth );\n', '        \n', '    }\n', '   \n', '    //there is no fee using token to play HDX20 powered games \n', '  \n', '    function payWithToken( uint256 _eth , address _player_address ) public\n', '    onlyFromGameWhiteListed\n', '    returns(uint256)\n', '    {\n', '        require( _eth>0 && _eth <= ethBalanceOfNoFee(_player_address ));\n', '        \n', '        address _game_contract = msg.sender;\n', '        \n', '        uint256 balance = tokenBalanceLedger[ _player_address ];\n', '        \n', '        uint256 _nb_token = (_eth.mul( magnitude) ) / tokenPrice;\n', '        \n', '        require( _nb_token <= balance);\n', '        \n', '        //confirm the ETH value\n', '        _eth = (_nb_token.mul( tokenPrice)) / magnitude;\n', '        \n', '        balance = balance.sub(_nb_token);\n', '        \n', '        tokenSupply = tokenSupply.sub( _nb_token);\n', '        \n', '        tokenBalanceLedger[ _player_address ] = balance;\n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '       \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        //send the money to the game contract   \n', '        _game_contract.transfer( _eth );\n', '      \n', '      \n', '        return( _eth );\n', '    }\n', '    \n', '    function moveAccountOut() public\n', '    onlyTokenHolders\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require( ethBalanceOfNoFee( _customerAddress )>0 && address(NewHDX20Contract) != address(0));\n', '    \n', '        uint256 balance = tokenBalanceLedger[ _customerAddress ];\n', '    \n', '        uint256 _eth = (balance.mul( tokenPrice )) / magnitude;\n', '        \n', '       \n', '        tokenSupply = tokenSupply.sub( balance );\n', '        \n', '        tokenBalanceLedger[ _customerAddress ] = 0;\n', '        \n', '        contractValue = contractValue.sub( _eth );\n', '        \n', '     \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        emit onAccountMovedOut( _customerAddress , address(NewHDX20Contract), balance , _eth );\n', '      \n', '        //send the money to the new HDX20 contract which will buy on customer behalf at no fee converting eth for eth\n', '        //notice this could give more or less HDX20 however the eth value should be preserved\n', '        NewHDX20Contract.moveAccountIn.value(_eth)(_customerAddress);\n', '      \n', '    }\n', '    \n', '    function moveAccountIn(address _customerAddress) public\n', '    payable\n', '    onlyFromGameWhiteListed\n', '    {\n', '        \n', '        \n', '        uint256 _eth = msg.value;\n', '      \n', '        //buy token at no fee\n', '        uint256 _nb_token = buyTokenSub( _eth , _customerAddress );\n', '        \n', '        contractValue = contractValue.add( _eth );\n', '    \n', '      \n', '        if (tokenSupply>magnitude)\n', '        {\n', '            tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '        emit onAccountMovedIn( msg.sender, _customerAddress , _nb_token , _eth );\n', '     \n', '    }\n', '    \n', '    \n', '    function appreciateTokenPrice() public payable\n', '    onlyFromGameWhiteListed\n', '    {\n', '        uint256 _eth =  msg.value;\n', '       \n', '        contractValue = contractValue.add( _eth );\n', '            \n', '        //we need a minimum of 1 HDX20 before appreciation is activated    \n', '        if (tokenSupply>magnitude)\n', '        {\n', '                tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '        }\n', '       \n', '        \n', '    }\n', '    \n', '  \n', '    \n', '    function transferSub(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\n', '    private\n', '    returns(bool)\n', '    {\n', '       \n', '        require( _amountOfTokens <= tokenBalanceLedger[_customerAddress] );\n', '        \n', '        //actually a transfer of 0 token is valid in ERC20\n', '        if (_amountOfTokens>0)\n', '        {\n', '            \n', '           \n', '            {\n', '            \n', '                uint256 _token_fee =  (_amountOfTokens.mul( transferFee )) / 100;\n', '               \n', '                _token_fee /= 2;\n', '               \n', '                \n', '                //now proceed the transfer\n', '                tokenBalanceLedger[ _customerAddress] = tokenBalanceLedger[ _customerAddress].sub( _amountOfTokens );\n', '                tokenBalanceLedger[ _toAddress] = tokenBalanceLedger[ _toAddress].add( _amountOfTokens - (_token_fee*2) );\n', '              \n', '                //half fee in HDX20 directly credited to developer\n', '                tokenBalanceLedger[ owner ] += _token_fee;\n', '                \n', '                //burning the other half of token to drive the price up\n', '                tokenSupply = tokenSupply.sub( _token_fee );\n', '              \n', '             \n', '                if (tokenSupply>magnitude)\n', '                {\n', '                    tokenPrice = (contractValue.mul( magnitude)) / tokenSupply;\n', '                }\n', '               \n', '            }\n', '           \n', '           \n', '          \n', '        \n', '        }\n', '      \n', '      \n', '        // fire event\n', '        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n', '        \n', '        // ERC20\n', '        return true;\n', '       \n', '    }\n', '    \n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '    public\n', '    returns(bool)\n', '    {\n', '        \n', '        return( transferSub( msg.sender ,  _toAddress, _amountOfTokens));\n', '       \n', '    }\n', '    \n', '  \n', '    \n', '    \n', '    /*================================\n', '    =  VIEW AND HELPERS FUNCTIONS    =\n', '    ================================*/\n', '    \n', '  \n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function totalContractBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return contractValue;\n', '    }\n', '    \n', '  \n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply;\n', '    }\n', '    \n', '  \n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '    \n', '   \n', '    function balanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger[_customerAddress];\n', '    }\n', '    \n', '    function sellingPrice( bool includeFees)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _fee = 0;\n', '        uint256 _devfee=0;\n', '        \n', '        if (includeFees)\n', '        {\n', '            _fee = (tokenPrice.mul( sellOutFee ) ) / 100;\n', '            _devfee = (tokenPrice.mul( devFee ) ) / 100;\n', '        }\n', '        \n', '        return( tokenPrice - _fee - _devfee );\n', '        \n', '    }\n', '    \n', '    function buyingPrice( bool includeFees)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _fee = 0;\n', '        uint256 _devfee=0;\n', '        \n', '        if (includeFees)\n', '        {\n', '            _fee = (tokenPrice.mul( buyInFee ) ) / 100;\n', '            _devfee = (tokenPrice.mul( devFee ) ) / 100;\n', '        }\n', '        \n', '        return( tokenPrice + _fee + _devfee );\n', '        \n', '    }\n', '    \n', '    function ethBalanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        uint256 _price = sellingPrice( true );\n', '        \n', '        uint256 _balance = tokenBalanceLedger[ _customerAddress];\n', '        \n', '        uint256 _value = (_balance.mul( _price )) / magnitude;\n', '        \n', '        \n', '        return( _value );\n', '    }\n', '    \n', '  \n', '   \n', '    function myEthBalanceOf()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return ethBalanceOf(_customerAddress);\n', '    }\n', '   \n', '   \n', '    function ethBalanceOfNoFee(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        uint256 _price = sellingPrice( false );\n', '        \n', '        uint256 _balance = tokenBalanceLedger[ _customerAddress];\n', '        \n', '        uint256 _value = (_balance.mul( _price )) / magnitude;\n', '        \n', '        \n', '        return( _value );\n', '    }\n', '    \n', '  \n', '   \n', '    function myEthBalanceOfNoFee()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return ethBalanceOfNoFee(_customerAddress);\n', '    }\n', '    \n', '    function checkGameListed(address _contract)\n', '        view\n', '        public\n', '        returns(bool)\n', '    {\n', '      \n', '      return( gameWhiteListed[ _contract]);\n', '    }\n', '    \n', '    function getSuperReferrerRate(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint8)\n', '    {\n', '      \n', '      return( referrerFee+superReferrerRate[ _customerAddress]);\n', '    }\n', '    \n', '  \n', '    \n', '}\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}']
