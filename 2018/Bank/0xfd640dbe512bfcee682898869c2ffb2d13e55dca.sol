['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = true;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract CryptoPhoenixes is Ownable, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  address public subDev;\n', '  Phoenix[] private phoenixes;\n', '  uint256 public PHOENIX_POOL;\n', '  uint256 public EXPLOSION_DENOMINATOR = 1000; //Eg explosivePower = 30 -> 3%\n', '  bool public ALLOW_BETA = true;\n', '  uint BETA_CUTOFF;\n', '\n', '  // devFunds\n', '  mapping (address => uint256) public devFunds;\n', '\n', '  // dividends\n', '  mapping (address => uint256) public userFunds;\n', '\n', '  // Events\n', '  event PhoenixPurchased(\n', '    uint256 _phoenixId,\n', '    address oldOwner,\n', '    address newOwner,\n', '    uint256 price,\n', '    uint256 nextPrice\n', '  );\n', '  \n', '  event PhoenixExploded(\n', '      uint256 phoenixId,\n', '      address owner,\n', '      uint256 payout,\n', '      uint256 price,\n', '      uint nextExplosionTime\n', '  );\n', '\n', '  event WithdrewFunds(\n', '    address owner\n', '  );\n', '\n', '  // Caps for price changes and cutoffs\n', '  uint256 constant private QUARTER_ETH_CAP  = 0.25 ether;\n', '  uint256 constant private ONE_ETH_CAP  = 1.0 ether;\n', '  uint256 public BASE_PRICE = 0.0025 ether;\n', '  uint256 public PRICE_CUTOFF = 1.0 ether;\n', '  uint256 public HIGHER_PRICE_RESET_PERCENTAGE = 20;\n', '  uint256 public LOWER_PRICE_RESET_PERCENTAGE = 10;\n', '\n', '  // Struct to store Phoenix Data\n', '  struct Phoenix {\n', '    uint256 price;  // Current price of phoenix\n', '    uint256 dividendPayout; // The percent of the dividends pool rewarded\n', '    uint256 explosivePower; // Percentage that phoenix can claim from PHOENIX_POOL after explode() function is called\n', '    uint cooldown; // Time it takes for phoenix to recharge till next explosion\n', '    uint nextExplosionTime; // Time of next explosion\n', '    address previousOwner;  // Owner of the phoenix who triggered explosion in previous round\n', '    address currentOwner; // Owner of phoenix in current round\n', '  }\n', '\n', '// Check if game is in beta or not. Certain functions will be disabled after beta period ends.\n', '  modifier inBeta() {\n', '    require(ALLOW_BETA);\n', '    _;\n', '  }\n', '\n', '// Main function to set the beta period and sub developer\n', '  function CryptoPhoenixes(address _subDev) {\n', '    BETA_CUTOFF = now + 90 * 1 days; //Allow 3 months to tweak parameters\n', '    subDev = _subDev;\n', '  }\n', '  \n', '// Function anyone can call to turn off beta, thus disabling some functions\n', '  function closeBeta() {\n', '    require(now >= BETA_CUTOFF);\n', '    ALLOW_BETA = false;\n', '  }\n', '\n', '  function createPhoenix(uint256 _payoutPercentage, uint256 _explosivePower, uint _cooldown) onlyOwner public {\n', '    \n', '    var phoenix = Phoenix({\n', '    price: BASE_PRICE,\n', '    dividendPayout: _payoutPercentage,\n', '    explosivePower: _explosivePower,\n', '    cooldown: _cooldown,\n', '    nextExplosionTime: now,\n', '    previousOwner: address(0),\n', '    currentOwner: this\n', '    });\n', '\n', '    phoenixes.push(phoenix);\n', '  }\n', '\n', '  function createMultiplePhoenixes(uint256[] _payoutPercentages, uint256[] _explosivePowers, uint[] _cooldowns) onlyOwner public {\n', '    require(_payoutPercentages.length == _explosivePowers.length);\n', '    require(_explosivePowers.length == _cooldowns.length);\n', '    \n', '    for (uint256 i = 0; i < _payoutPercentages.length; i++) {\n', '      createPhoenix(_payoutPercentages[i],_explosivePowers[i],_cooldowns[i]);\n', '    }\n', '  }\n', '\n', '  function getPhoenix(uint256 _phoenixId) public view returns (\n', '    uint256 price,\n', '    uint256 nextPrice,\n', '    uint256 dividendPayout,\n', '    uint256 effectivePayout,\n', '    uint256 explosivePower,\n', '    uint cooldown,\n', '    uint nextExplosionTime,\n', '    address previousOwner,\n', '    address currentOwner\n', '  ) {\n', '    var phoenix = phoenixes[_phoenixId];\n', '    price = phoenix.price;\n', '    nextPrice = getNextPrice(phoenix.price);\n', '    dividendPayout = phoenix.dividendPayout;\n', '    effectivePayout = phoenix.dividendPayout.mul(10000).div(getTotalPayout());\n', '    explosivePower = phoenix.explosivePower;\n', '    cooldown = phoenix.cooldown;\n', '    nextExplosionTime = phoenix.nextExplosionTime;\n', '    previousOwner = phoenix.previousOwner;\n', '    currentOwner = phoenix.currentOwner;\n', '  }\n', '\n', '/**\n', '  * @dev Determines next price of token\n', '  * @param _price uint256 ID of current price\n', '*/\n', '  function getNextPrice (uint256 _price) private pure returns (uint256 _nextPrice) {\n', '    if (_price < QUARTER_ETH_CAP) {\n', '      return _price.mul(140).div(100); //1.4x\n', '    } else if (_price < ONE_ETH_CAP) {\n', '      return _price.mul(130).div(100); //1.3x\n', '    } else {\n', '      return _price.mul(125).div(100); //1.25x\n', '    }\n', '  }\n', '\n', '/**\n', '  * @dev Set dividend payout of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _payoutPercentage uint256 Desired payout percentage\n', '*/\n', '  function setDividendPayout (uint256 _phoenixId, uint256 _payoutPercentage) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.dividendPayout = _payoutPercentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set explosive power of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _explosivePower uint256 Desired claimable percentage from PHOENIX_POOL\n', '*/\n', '  function setExplosivePower (uint256 _phoenixId, uint256 _explosivePower) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.explosivePower = _explosivePower;\n', '  }\n', '\n', '/**\n', '  * @dev Set cooldown of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _cooldown uint256 Desired cooldown time\n', '*/\n', '  function setCooldown (uint256 _phoenixId, uint256 _cooldown) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.cooldown = _cooldown;\n', '  }\n', '\n', '/**\n', '  * @dev Set price cutoff when determining phoenix price after explosion. To adjust for ETH price fluctuations\n', '  * @param _price uint256 Price cutoff in wei\n', '*/\n', '  function setPriceCutoff (uint256 _price) onlyOwner {\n', '    PRICE_CUTOFF = _price;\n', '  }\n', '\n', '/**\n', '  * @dev Set price percentage for when price exceeds or equates to price cutoff to reset to\n', '  * @param _percentage uint256 Desired percentage\n', '*/\n', '  function setHigherPricePercentage (uint256 _percentage) onlyOwner inBeta {\n', '    require(_percentage > 0);\n', '    require(_percentage < 100);\n', '    HIGHER_PRICE_RESET_PERCENTAGE = _percentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set price percentage for when price is lower than price cutoff to reset to\n', '  * @param _percentage uint256 Desired percentage\n', '*/\n', '  function setLowerPricePercentage (uint256 _percentage) onlyOwner inBeta {\n', '    require(_percentage > 0);\n', '    require(_percentage < 100);\n', '    LOWER_PRICE_RESET_PERCENTAGE = _percentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set base price for phoenixes. To adjust for ETH price fluctuations\n', '  * @param _amount uint256 Desired amount in wei\n', '*/\n', '  function setBasePrice (uint256 _amount) onlyOwner {\n', '    require(_amount > 0);\n', '    BASE_PRICE = _amount;\n', '  }\n', '\n', '/**\n', '  * @dev Purchase show from previous owner\n', '  * @param _phoenixId uint256 of token\n', '*/\n', '  function purchasePhoenix(uint256 _phoenixId) whenNotPaused public payable {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    //Get current price of phoenix\n', '    uint256 price = phoenix.price;\n', '\n', '    // revert checks\n', '    require(price > 0);\n', '    require(msg.value >= price);\n', '    //prevent multiple subsequent purchases\n', '    require(outgoingOwner != msg.sender);\n', '\n', '    //Get owners of phoenixes\n', '    address previousOwner = phoenix.previousOwner;\n', '    address outgoingOwner = phoenix.currentOwner;\n', '\n', '    //Define Cut variables\n', '    uint256 devCut;  \n', '    uint256 dividendsCut; \n', '    uint256 previousOwnerCut;\n', '    uint256 phoenixPoolCut;\n', '    uint256 phoenixPoolPurchaseExcessCut;\n', '    \n', '    //Calculate excess\n', '    uint256 purchaseExcess = msg.value.sub(price);\n', '\n', '    //handle boundary case where we assign previousOwner to the user\n', '    if (previousOwner == address(0)) {\n', '        phoenix.previousOwner = msg.sender;\n', '    }\n', '    \n', '    //Calculate cuts\n', '    (devCut,dividendsCut,previousOwnerCut,phoenixPoolCut) = calculateCuts(price);\n', '\n', '    // Amount payable to old owner minus the developer&#39;s and pools&#39; cuts.\n', '    uint256 outgoingOwnerCut = price.sub(devCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(dividendsCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(previousOwnerCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(phoenixPoolCut);\n', '    \n', '    // Take 2% cut from leftovers of overbidding\n', '    phoenixPoolPurchaseExcessCut = purchaseExcess.mul(2).div(100);\n', '    purchaseExcess = purchaseExcess.sub(phoenixPoolPurchaseExcessCut);\n', '    phoenixPoolCut = phoenixPoolCut.add(phoenixPoolPurchaseExcessCut);\n', '\n', '    // set new price\n', '    phoenix.price = getNextPrice(price);\n', '\n', '    // set new owner\n', '    phoenix.currentOwner = msg.sender;\n', '\n', '    //Actual transfer\n', '    devFunds[owner] = devFunds[owner].add(devCut.mul(7).div(10)); //70% of dev cut goes to owner\n', '    devFunds[subDev] = devFunds[subDev].add(devCut.mul(3).div(10)); //30% goes to other dev\n', '    distributeDividends(dividendsCut);\n', '    userFunds[previousOwner] = userFunds[previousOwner].add(previousOwnerCut);\n', '    PHOENIX_POOL = PHOENIX_POOL.add(phoenixPoolCut);\n', '\n', '    //handle boundary case where we exclude currentOwner == address(this) when transferring funds\n', '    if (outgoingOwner != address(this)) {\n', '      sendFunds(outgoingOwner,outgoingOwnerCut);\n', '    }\n', '\n', '    // Send refund to owner if needed\n', '    if (purchaseExcess > 0) {\n', '      sendFunds(msg.sender,purchaseExcess);\n', '    }\n', '\n', '    // raise event\n', '    PhoenixPurchased(_phoenixId, outgoingOwner, msg.sender, price, phoenix.price);\n', '  }\n', '\n', '  function calculateCuts(uint256 _price) private pure returns (\n', '    uint256 devCut, \n', '    uint256 dividendsCut,\n', '    uint256 previousOwnerCut,\n', '    uint256 phoenixPoolCut\n', '    ) {\n', '      // Calculate cuts\n', '      // 2% goes to developers\n', '      devCut = _price.mul(2).div(100);\n', '\n', '      // 2.5% goes to dividends\n', '      dividendsCut = _price.mul(25).div(1000); \n', '\n', '      // 0.5% goes to owner of phoenix in previous exploded round\n', '      previousOwnerCut = _price.mul(5).div(1000);\n', '\n', '      // 10-12% goes to phoenix pool\n', '      phoenixPoolCut = calculatePhoenixPoolCut(_price);\n', '    }\n', '\n', '  function calculatePhoenixPoolCut (uint256 _price) private pure returns (uint256 _poolCut) {\n', '      if (_price < QUARTER_ETH_CAP) {\n', '          return _price.mul(12).div(100); //12%\n', '      } else if (_price < ONE_ETH_CAP) {\n', '          return _price.mul(11).div(100); //11%\n', '      } else {\n', '          return _price.mul(10).div(100); //10%\n', '      }\n', '  }\n', '\n', '  function distributeDividends(uint256 _dividendsCut) private {\n', '    uint256 totalPayout = getTotalPayout();\n', '\n', '    for (uint256 i = 0; i < phoenixes.length; i++) {\n', '      var phoenix = phoenixes[i];\n', '      var payout = _dividendsCut.mul(phoenix.dividendPayout).div(totalPayout);\n', '      userFunds[phoenix.currentOwner] = userFunds[phoenix.currentOwner].add(payout);\n', '    }\n', '  }\n', '\n', '  function getTotalPayout() private view returns(uint256) {\n', '    uint256 totalPayout = 0;\n', '\n', '    for (uint256 i = 0; i < phoenixes.length; i++) {\n', '      var phoenix = phoenixes[i];\n', '      totalPayout = totalPayout.add(phoenix.dividendPayout);\n', '    }\n', '\n', '    return totalPayout;\n', '  }\n', '    \n', '//Note that the previous and current owner will be the same person after this function is called\n', '  function explodePhoenix(uint256 _phoenixId) whenNotPaused public {\n', '      Phoenix phoenix = phoenixes[_phoenixId];\n', '      require(msg.sender == phoenix.currentOwner);\n', '      require(PHOENIX_POOL > 0);\n', '      require(now >= phoenix.nextExplosionTime);\n', '      \n', '      uint256 payout = phoenix.explosivePower.mul(PHOENIX_POOL).div(EXPLOSION_DENOMINATOR);\n', '\n', '      //subtract from phoenix_POOL\n', '      PHOENIX_POOL = PHOENIX_POOL.sub(payout);\n', '      \n', '      //decrease phoenix price\n', '      if (phoenix.price >= PRICE_CUTOFF) {\n', '        phoenix.price = phoenix.price.mul(HIGHER_PRICE_RESET_PERCENTAGE).div(100);\n', '      } else {\n', '        phoenix.price = phoenix.price.mul(LOWER_PRICE_RESET_PERCENTAGE).div(100);\n', '        if (phoenix.price < BASE_PRICE) {\n', '          phoenix.price = BASE_PRICE;\n', '          }\n', '      }\n', '\n', '      // set previous owner to be current owner, so he can get extra dividends next round\n', '      phoenix.previousOwner = msg.sender;\n', '      // reset cooldown\n', '      phoenix.nextExplosionTime = now + (phoenix.cooldown * 1 minutes);\n', '      \n', '      // Finally, payout to user\n', '      sendFunds(msg.sender,payout);\n', '      \n', '      //raise event\n', '      PhoenixExploded(_phoenixId, msg.sender, payout, phoenix.price, phoenix.nextExplosionTime);\n', '  }\n', '  \n', '/**\n', '* @dev Try to send funds immediately\n', '* If it fails, user has to manually withdraw.\n', '*/\n', '  function sendFunds(address _user, uint256 _payout) private {\n', '    if (!_user.send(_payout)) {\n', '      userFunds[_user] = userFunds[_user].add(_payout);\n', '    }\n', '  }\n', '\n', '/**\n', '* @dev Withdraw dev cut.\n', '*/\n', '  function devWithdraw() public {\n', '    uint256 funds = devFunds[msg.sender];\n', '    require(funds > 0);\n', '    devFunds[msg.sender] = 0;\n', '    msg.sender.transfer(funds);\n', '  }\n', '\n', '/**\n', '* @dev Users can withdraw their accumulated dividends\n', '*/\n', '  function withdrawFunds() public {\n', '    uint256 funds = userFunds[msg.sender];\n', '    require(funds > 0);\n', '    userFunds[msg.sender] = 0;\n', '    msg.sender.transfer(funds);\n', '    WithdrewFunds(msg.sender);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = true;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract CryptoPhoenixes is Ownable, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  address public subDev;\n', '  Phoenix[] private phoenixes;\n', '  uint256 public PHOENIX_POOL;\n', '  uint256 public EXPLOSION_DENOMINATOR = 1000; //Eg explosivePower = 30 -> 3%\n', '  bool public ALLOW_BETA = true;\n', '  uint BETA_CUTOFF;\n', '\n', '  // devFunds\n', '  mapping (address => uint256) public devFunds;\n', '\n', '  // dividends\n', '  mapping (address => uint256) public userFunds;\n', '\n', '  // Events\n', '  event PhoenixPurchased(\n', '    uint256 _phoenixId,\n', '    address oldOwner,\n', '    address newOwner,\n', '    uint256 price,\n', '    uint256 nextPrice\n', '  );\n', '  \n', '  event PhoenixExploded(\n', '      uint256 phoenixId,\n', '      address owner,\n', '      uint256 payout,\n', '      uint256 price,\n', '      uint nextExplosionTime\n', '  );\n', '\n', '  event WithdrewFunds(\n', '    address owner\n', '  );\n', '\n', '  // Caps for price changes and cutoffs\n', '  uint256 constant private QUARTER_ETH_CAP  = 0.25 ether;\n', '  uint256 constant private ONE_ETH_CAP  = 1.0 ether;\n', '  uint256 public BASE_PRICE = 0.0025 ether;\n', '  uint256 public PRICE_CUTOFF = 1.0 ether;\n', '  uint256 public HIGHER_PRICE_RESET_PERCENTAGE = 20;\n', '  uint256 public LOWER_PRICE_RESET_PERCENTAGE = 10;\n', '\n', '  // Struct to store Phoenix Data\n', '  struct Phoenix {\n', '    uint256 price;  // Current price of phoenix\n', '    uint256 dividendPayout; // The percent of the dividends pool rewarded\n', '    uint256 explosivePower; // Percentage that phoenix can claim from PHOENIX_POOL after explode() function is called\n', '    uint cooldown; // Time it takes for phoenix to recharge till next explosion\n', '    uint nextExplosionTime; // Time of next explosion\n', '    address previousOwner;  // Owner of the phoenix who triggered explosion in previous round\n', '    address currentOwner; // Owner of phoenix in current round\n', '  }\n', '\n', '// Check if game is in beta or not. Certain functions will be disabled after beta period ends.\n', '  modifier inBeta() {\n', '    require(ALLOW_BETA);\n', '    _;\n', '  }\n', '\n', '// Main function to set the beta period and sub developer\n', '  function CryptoPhoenixes(address _subDev) {\n', '    BETA_CUTOFF = now + 90 * 1 days; //Allow 3 months to tweak parameters\n', '    subDev = _subDev;\n', '  }\n', '  \n', '// Function anyone can call to turn off beta, thus disabling some functions\n', '  function closeBeta() {\n', '    require(now >= BETA_CUTOFF);\n', '    ALLOW_BETA = false;\n', '  }\n', '\n', '  function createPhoenix(uint256 _payoutPercentage, uint256 _explosivePower, uint _cooldown) onlyOwner public {\n', '    \n', '    var phoenix = Phoenix({\n', '    price: BASE_PRICE,\n', '    dividendPayout: _payoutPercentage,\n', '    explosivePower: _explosivePower,\n', '    cooldown: _cooldown,\n', '    nextExplosionTime: now,\n', '    previousOwner: address(0),\n', '    currentOwner: this\n', '    });\n', '\n', '    phoenixes.push(phoenix);\n', '  }\n', '\n', '  function createMultiplePhoenixes(uint256[] _payoutPercentages, uint256[] _explosivePowers, uint[] _cooldowns) onlyOwner public {\n', '    require(_payoutPercentages.length == _explosivePowers.length);\n', '    require(_explosivePowers.length == _cooldowns.length);\n', '    \n', '    for (uint256 i = 0; i < _payoutPercentages.length; i++) {\n', '      createPhoenix(_payoutPercentages[i],_explosivePowers[i],_cooldowns[i]);\n', '    }\n', '  }\n', '\n', '  function getPhoenix(uint256 _phoenixId) public view returns (\n', '    uint256 price,\n', '    uint256 nextPrice,\n', '    uint256 dividendPayout,\n', '    uint256 effectivePayout,\n', '    uint256 explosivePower,\n', '    uint cooldown,\n', '    uint nextExplosionTime,\n', '    address previousOwner,\n', '    address currentOwner\n', '  ) {\n', '    var phoenix = phoenixes[_phoenixId];\n', '    price = phoenix.price;\n', '    nextPrice = getNextPrice(phoenix.price);\n', '    dividendPayout = phoenix.dividendPayout;\n', '    effectivePayout = phoenix.dividendPayout.mul(10000).div(getTotalPayout());\n', '    explosivePower = phoenix.explosivePower;\n', '    cooldown = phoenix.cooldown;\n', '    nextExplosionTime = phoenix.nextExplosionTime;\n', '    previousOwner = phoenix.previousOwner;\n', '    currentOwner = phoenix.currentOwner;\n', '  }\n', '\n', '/**\n', '  * @dev Determines next price of token\n', '  * @param _price uint256 ID of current price\n', '*/\n', '  function getNextPrice (uint256 _price) private pure returns (uint256 _nextPrice) {\n', '    if (_price < QUARTER_ETH_CAP) {\n', '      return _price.mul(140).div(100); //1.4x\n', '    } else if (_price < ONE_ETH_CAP) {\n', '      return _price.mul(130).div(100); //1.3x\n', '    } else {\n', '      return _price.mul(125).div(100); //1.25x\n', '    }\n', '  }\n', '\n', '/**\n', '  * @dev Set dividend payout of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _payoutPercentage uint256 Desired payout percentage\n', '*/\n', '  function setDividendPayout (uint256 _phoenixId, uint256 _payoutPercentage) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.dividendPayout = _payoutPercentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set explosive power of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _explosivePower uint256 Desired claimable percentage from PHOENIX_POOL\n', '*/\n', '  function setExplosivePower (uint256 _phoenixId, uint256 _explosivePower) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.explosivePower = _explosivePower;\n', '  }\n', '\n', '/**\n', '  * @dev Set cooldown of phoenix\n', '  * @param _phoenixId id of phoenix\n', '  * @param _cooldown uint256 Desired cooldown time\n', '*/\n', '  function setCooldown (uint256 _phoenixId, uint256 _cooldown) onlyOwner inBeta {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    phoenix.cooldown = _cooldown;\n', '  }\n', '\n', '/**\n', '  * @dev Set price cutoff when determining phoenix price after explosion. To adjust for ETH price fluctuations\n', '  * @param _price uint256 Price cutoff in wei\n', '*/\n', '  function setPriceCutoff (uint256 _price) onlyOwner {\n', '    PRICE_CUTOFF = _price;\n', '  }\n', '\n', '/**\n', '  * @dev Set price percentage for when price exceeds or equates to price cutoff to reset to\n', '  * @param _percentage uint256 Desired percentage\n', '*/\n', '  function setHigherPricePercentage (uint256 _percentage) onlyOwner inBeta {\n', '    require(_percentage > 0);\n', '    require(_percentage < 100);\n', '    HIGHER_PRICE_RESET_PERCENTAGE = _percentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set price percentage for when price is lower than price cutoff to reset to\n', '  * @param _percentage uint256 Desired percentage\n', '*/\n', '  function setLowerPricePercentage (uint256 _percentage) onlyOwner inBeta {\n', '    require(_percentage > 0);\n', '    require(_percentage < 100);\n', '    LOWER_PRICE_RESET_PERCENTAGE = _percentage;\n', '  }\n', '\n', '/**\n', '  * @dev Set base price for phoenixes. To adjust for ETH price fluctuations\n', '  * @param _amount uint256 Desired amount in wei\n', '*/\n', '  function setBasePrice (uint256 _amount) onlyOwner {\n', '    require(_amount > 0);\n', '    BASE_PRICE = _amount;\n', '  }\n', '\n', '/**\n', '  * @dev Purchase show from previous owner\n', '  * @param _phoenixId uint256 of token\n', '*/\n', '  function purchasePhoenix(uint256 _phoenixId) whenNotPaused public payable {\n', '    Phoenix phoenix = phoenixes[_phoenixId];\n', '    //Get current price of phoenix\n', '    uint256 price = phoenix.price;\n', '\n', '    // revert checks\n', '    require(price > 0);\n', '    require(msg.value >= price);\n', '    //prevent multiple subsequent purchases\n', '    require(outgoingOwner != msg.sender);\n', '\n', '    //Get owners of phoenixes\n', '    address previousOwner = phoenix.previousOwner;\n', '    address outgoingOwner = phoenix.currentOwner;\n', '\n', '    //Define Cut variables\n', '    uint256 devCut;  \n', '    uint256 dividendsCut; \n', '    uint256 previousOwnerCut;\n', '    uint256 phoenixPoolCut;\n', '    uint256 phoenixPoolPurchaseExcessCut;\n', '    \n', '    //Calculate excess\n', '    uint256 purchaseExcess = msg.value.sub(price);\n', '\n', '    //handle boundary case where we assign previousOwner to the user\n', '    if (previousOwner == address(0)) {\n', '        phoenix.previousOwner = msg.sender;\n', '    }\n', '    \n', '    //Calculate cuts\n', '    (devCut,dividendsCut,previousOwnerCut,phoenixPoolCut) = calculateCuts(price);\n', '\n', "    // Amount payable to old owner minus the developer's and pools' cuts.\n", '    uint256 outgoingOwnerCut = price.sub(devCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(dividendsCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(previousOwnerCut);\n', '    outgoingOwnerCut = outgoingOwnerCut.sub(phoenixPoolCut);\n', '    \n', '    // Take 2% cut from leftovers of overbidding\n', '    phoenixPoolPurchaseExcessCut = purchaseExcess.mul(2).div(100);\n', '    purchaseExcess = purchaseExcess.sub(phoenixPoolPurchaseExcessCut);\n', '    phoenixPoolCut = phoenixPoolCut.add(phoenixPoolPurchaseExcessCut);\n', '\n', '    // set new price\n', '    phoenix.price = getNextPrice(price);\n', '\n', '    // set new owner\n', '    phoenix.currentOwner = msg.sender;\n', '\n', '    //Actual transfer\n', '    devFunds[owner] = devFunds[owner].add(devCut.mul(7).div(10)); //70% of dev cut goes to owner\n', '    devFunds[subDev] = devFunds[subDev].add(devCut.mul(3).div(10)); //30% goes to other dev\n', '    distributeDividends(dividendsCut);\n', '    userFunds[previousOwner] = userFunds[previousOwner].add(previousOwnerCut);\n', '    PHOENIX_POOL = PHOENIX_POOL.add(phoenixPoolCut);\n', '\n', '    //handle boundary case where we exclude currentOwner == address(this) when transferring funds\n', '    if (outgoingOwner != address(this)) {\n', '      sendFunds(outgoingOwner,outgoingOwnerCut);\n', '    }\n', '\n', '    // Send refund to owner if needed\n', '    if (purchaseExcess > 0) {\n', '      sendFunds(msg.sender,purchaseExcess);\n', '    }\n', '\n', '    // raise event\n', '    PhoenixPurchased(_phoenixId, outgoingOwner, msg.sender, price, phoenix.price);\n', '  }\n', '\n', '  function calculateCuts(uint256 _price) private pure returns (\n', '    uint256 devCut, \n', '    uint256 dividendsCut,\n', '    uint256 previousOwnerCut,\n', '    uint256 phoenixPoolCut\n', '    ) {\n', '      // Calculate cuts\n', '      // 2% goes to developers\n', '      devCut = _price.mul(2).div(100);\n', '\n', '      // 2.5% goes to dividends\n', '      dividendsCut = _price.mul(25).div(1000); \n', '\n', '      // 0.5% goes to owner of phoenix in previous exploded round\n', '      previousOwnerCut = _price.mul(5).div(1000);\n', '\n', '      // 10-12% goes to phoenix pool\n', '      phoenixPoolCut = calculatePhoenixPoolCut(_price);\n', '    }\n', '\n', '  function calculatePhoenixPoolCut (uint256 _price) private pure returns (uint256 _poolCut) {\n', '      if (_price < QUARTER_ETH_CAP) {\n', '          return _price.mul(12).div(100); //12%\n', '      } else if (_price < ONE_ETH_CAP) {\n', '          return _price.mul(11).div(100); //11%\n', '      } else {\n', '          return _price.mul(10).div(100); //10%\n', '      }\n', '  }\n', '\n', '  function distributeDividends(uint256 _dividendsCut) private {\n', '    uint256 totalPayout = getTotalPayout();\n', '\n', '    for (uint256 i = 0; i < phoenixes.length; i++) {\n', '      var phoenix = phoenixes[i];\n', '      var payout = _dividendsCut.mul(phoenix.dividendPayout).div(totalPayout);\n', '      userFunds[phoenix.currentOwner] = userFunds[phoenix.currentOwner].add(payout);\n', '    }\n', '  }\n', '\n', '  function getTotalPayout() private view returns(uint256) {\n', '    uint256 totalPayout = 0;\n', '\n', '    for (uint256 i = 0; i < phoenixes.length; i++) {\n', '      var phoenix = phoenixes[i];\n', '      totalPayout = totalPayout.add(phoenix.dividendPayout);\n', '    }\n', '\n', '    return totalPayout;\n', '  }\n', '    \n', '//Note that the previous and current owner will be the same person after this function is called\n', '  function explodePhoenix(uint256 _phoenixId) whenNotPaused public {\n', '      Phoenix phoenix = phoenixes[_phoenixId];\n', '      require(msg.sender == phoenix.currentOwner);\n', '      require(PHOENIX_POOL > 0);\n', '      require(now >= phoenix.nextExplosionTime);\n', '      \n', '      uint256 payout = phoenix.explosivePower.mul(PHOENIX_POOL).div(EXPLOSION_DENOMINATOR);\n', '\n', '      //subtract from phoenix_POOL\n', '      PHOENIX_POOL = PHOENIX_POOL.sub(payout);\n', '      \n', '      //decrease phoenix price\n', '      if (phoenix.price >= PRICE_CUTOFF) {\n', '        phoenix.price = phoenix.price.mul(HIGHER_PRICE_RESET_PERCENTAGE).div(100);\n', '      } else {\n', '        phoenix.price = phoenix.price.mul(LOWER_PRICE_RESET_PERCENTAGE).div(100);\n', '        if (phoenix.price < BASE_PRICE) {\n', '          phoenix.price = BASE_PRICE;\n', '          }\n', '      }\n', '\n', '      // set previous owner to be current owner, so he can get extra dividends next round\n', '      phoenix.previousOwner = msg.sender;\n', '      // reset cooldown\n', '      phoenix.nextExplosionTime = now + (phoenix.cooldown * 1 minutes);\n', '      \n', '      // Finally, payout to user\n', '      sendFunds(msg.sender,payout);\n', '      \n', '      //raise event\n', '      PhoenixExploded(_phoenixId, msg.sender, payout, phoenix.price, phoenix.nextExplosionTime);\n', '  }\n', '  \n', '/**\n', '* @dev Try to send funds immediately\n', '* If it fails, user has to manually withdraw.\n', '*/\n', '  function sendFunds(address _user, uint256 _payout) private {\n', '    if (!_user.send(_payout)) {\n', '      userFunds[_user] = userFunds[_user].add(_payout);\n', '    }\n', '  }\n', '\n', '/**\n', '* @dev Withdraw dev cut.\n', '*/\n', '  function devWithdraw() public {\n', '    uint256 funds = devFunds[msg.sender];\n', '    require(funds > 0);\n', '    devFunds[msg.sender] = 0;\n', '    msg.sender.transfer(funds);\n', '  }\n', '\n', '/**\n', '* @dev Users can withdraw their accumulated dividends\n', '*/\n', '  function withdrawFunds() public {\n', '    uint256 funds = userFunds[msg.sender];\n', '    require(funds > 0);\n', '    userFunds[msg.sender] = 0;\n', '    msg.sender.transfer(funds);\n', '    WithdrewFunds(msg.sender);\n', '  }\n', '}']
