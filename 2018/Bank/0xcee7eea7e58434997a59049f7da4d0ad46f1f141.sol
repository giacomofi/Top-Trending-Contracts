['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev The ERC20 interface has an standard functions and event\n', ' * for erc20 compatible token on Ethereum blockchain.\n', ' */\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '    function transfer(address _to, uint _value) external; // Some ERC20 doesn&#39;t have return\n', '    function transferFrom(address _from, address _to, uint _value) external; // Some ERC20 doesn&#39;t have return\n', '    function approve(address _spender, uint _value) external; // Some ERC20 doesn&#39;t have return\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title KULAP Trading Proxy\n', ' * @dev The KULAP trading proxy interface has an standard functions and event\n', ' * for other smart contract to implement to join KULAP Dex as Market Maker. \n', ' */\n', 'interface KULAPTradingProxy {\n', '    // Trade event\n', '    /// @dev when new trade occure (and success), this event will be boardcast. \n', '    /// @param src Source token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @param dest   Destination token\n', '    /// @return amount of actual destination tokens\n', '    event Trade( ERC20 src, uint256 srcAmount, ERC20 dest, uint256 destAmount);\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Source token\n', '    /// @param dest   Destination token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @return amount of actual destination tokens\n', '    function trade(\n', '        ERC20 src,\n', '        ERC20 dest,\n', '        uint256 srcAmount\n', '    )\n', '        external\n', '        payable\n', '        returns(uint256);\n', '    \n', '    /// @dev provite current rate between source and destination token \n', '    ///      for given source amount\n', '    /// @param src Source token\n', '    /// @param dest   Destination token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @return current reserve and rate\n', '    function rate(\n', '        ERC20 src, \n', '        ERC20 dest, \n', '        uint256 srcAmount\n', '    ) \n', '        external \n', '        view \n', '        returns(uint256, uint256);\n', '}\n', '\n', 'contract KulapDex is Ownable {\n', '    event Trade(\n', '        // Source\n', '        address indexed _srcAsset,\n', '        uint256         _srcAmount,\n', '\n', '        // Destination\n', '        address indexed _destAsset,\n', '        uint256         _destAmount,\n', '\n', '        // User\n', '        address indexed _trader, \n', '\n', '        // System\n', '        uint256          fee\n', '    );\n', '\n', '    using SafeMath for uint256;\n', '    ERC20 public etherERC20 = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '\n', '    // address public dexWallet = 0x7ff0F1919424F0D2B6A109E3139ae0f1d836D468; // To receive fee of the KULAP Dex network\n', '\n', '    // list of trading proxies\n', '    KULAPTradingProxy[] public tradingProxies;\n', '\n', '    function _tradeEtherToToken(\n', '        uint256 tradingProxyIndex, \n', '        uint256 srcAmount, \n', '        ERC20 dest\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Trade to proxy\n', '        uint256 destAmount = tradingProxy.trade.value(srcAmount)(\n', '            etherERC20,\n', '            dest,\n', '            srcAmount\n', '        );\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Receive ETH in case of trade Token -> ETH, will get ETH back from trading proxy\n', '    function () public payable {\n', '\n', '    }\n', '\n', '    function _tradeTokenToEther(\n', '        uint256 tradingProxyIndex,\n', '        ERC20 src,\n', '        uint256 srcAmount\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, srcAmount);\n', '\n', '        // Trande to proxy\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            etherERC20,\n', '            srcAmount\n', '        );\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    function _tradeTokenToToken(\n', '        uint256 tradingProxyIndex,\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, srcAmount);\n', '\n', '        // Trande to proxy\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            dest,\n', '            srcAmount\n', '        );\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function _trade(\n', '        uint256             _tradingProxyIndex, \n', '        ERC20               _src, \n', '        uint256             _srcAmount, \n', '        ERC20               _dest, \n', '        uint256             _minDestAmount\n', '    ) private returns(uint256)  {\n', '        // Destination amount\n', '        uint256 destAmount;\n', '\n', '        // Record src/dest asset for later consistency check.\n', '        uint256 srcAmountBefore;\n', '        uint256 destAmountBefore;\n', '        // Source\n', '        if (etherERC20 == _src) {\n', '            srcAmountBefore = address(this).balance;\n', '        } else {\n', '            srcAmountBefore = _src.balanceOf(this);\n', '        }\n', '        // Dest\n', '        if (etherERC20 == _dest) {\n', '            destAmountBefore = address(this).balance;\n', '        } else {\n', '            destAmountBefore = _dest.balanceOf(this);\n', '        }\n', '\n', '        // Trade ETH -> Token\n', '        if (etherERC20 == _src) {\n', '            destAmount = _tradeEtherToToken(_tradingProxyIndex, _srcAmount, _dest);\n', '        \n', '        // Trade Token -> ETH\n', '        } else if (etherERC20 == _dest) {\n', '            destAmount = _tradeTokenToEther(_tradingProxyIndex, _src, _srcAmount);\n', '\n', '        // Trade Token -> Token\n', '        } else {\n', '            destAmount = _tradeTokenToToken(_tradingProxyIndex, _src, _srcAmount, _dest);\n', '        }\n', '\n', '        // Recheck if src/dest amount correct\n', '        // Source\n', '        if (etherERC20 == _src) {\n', '            require(address(this).balance == srcAmountBefore.sub(_srcAmount), "source amount mismatch after trade");\n', '        } else {\n', '            require(_src.balanceOf(this) == srcAmountBefore.sub(_srcAmount), "source amount mismatch after trade");\n', '        }\n', '        // Dest\n', '        if (etherERC20 == _dest) {\n', '            require(address(this).balance == destAmountBefore.add(destAmount), "destination amount mismatch after trade");\n', '        } else {\n', '            require(_dest.balanceOf(this) == destAmountBefore.add(destAmount), "destination amount mismatch after trade");\n', '        }\n', '\n', '        // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '        require(destAmount >= _minDestAmount, "destination amount is too low.");\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        // Prepare source&#39;s asset\n', '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        // Trade with proxy\n', '        destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', '        // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '        require(destAmount >= minDestAmount, "destination amount is too low.");\n', '\n', '        // Send back ether to sender\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // Throws on failure\n', '            msg.sender.transfer(destAmount);\n', '        \n', '        // Send back token to sender\n', '        } else {\n', '            // Some ERC20 Smart contract not return Bool, so we can&#39;t check here\n', '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        emit Trade(src, srcAmount, dest, destAmount, msg.sender, 0);\n', '        \n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 50 OMG -> ETH -> EOS\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> EOS\n', '    // "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "30000000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "1", ["0x0000000000000000000000000000000000000000", "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x0000000000000000000000000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817"]\n', '    //\n', '    // Ex2: trade 50 OMG -> ETH -> DAI\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> DAI\n', '    // "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "30000000000000000000", "0x45ad02b30930cad22ff7921c111d22943c6c822f", "1", ["0x0000000000000000000000000000000000000000", "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x0000000000000000000000000000000000000001", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x45ad02b30930cad22ff7921c111d22943c6c822f"]\n', '    function tradeRoutes(\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest,\n', '        uint256 minDestAmount,\n', '        address[] _tradingPaths)\n', '\n', '        public payable returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        uint256 pathSrcAmount = srcAmount;\n', '        for (uint i = 0; i < _tradingPaths.length; i += 3) {\n', '            uint256 tradingProxyIndex =         uint256(_tradingPaths[i]);\n', '            ERC20 pathSrc =                     ERC20(_tradingPaths[i+1]);\n', '            ERC20 pathDest =                    ERC20(_tradingPaths[i+2]);\n', '\n', '            destAmount = _trade(tradingProxyIndex, pathSrc, pathSrcAmount, pathDest, 1);\n', '            pathSrcAmount = destAmount;\n', '        }\n', '\n', '        // Throw exception if destination amount doesn&#39;t meet user requirement.\n', '        require(destAmount >= minDestAmount, "destination amount is too low.");\n', '\n', '        // Trade Any -> ETH\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // Throws on failure\n', '            msg.sender.transfer(destAmount);\n', '        \n', '        // Trade Any -> Token\n', '        } else {\n', '            // Send back token to sender\n', '            // Some ERC20 Smart contract not return Bool, so we can&#39;t check here\n', '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        emit Trade(src, srcAmount, dest, destAmount, msg.sender, 0);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param tradingProxyIndex index of trading proxy\n', '    /// @param src Source token\n', '    /// @param dest Destination token\n', '    /// @param srcAmount Srouce amount\n', '    /* solhint-disable code-complexity */\n', '    function rate(uint256 tradingProxyIndex, ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint, uint) {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        return tradingProxy.rate(src, dest, srcAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Function for adding new trading proxy\n', '    * @param _proxyAddress The address of trading proxy.\n', '    * @return index of this proxy.\n', '    */\n', '    function addTradingProxy(\n', '        KULAPTradingProxy _proxyAddress\n', '    ) public onlyOwner returns (uint256) {\n', '\n', '        tradingProxies.push(_proxyAddress);\n', '\n', '        return tradingProxies.length;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev The ERC20 interface has an standard functions and event\n', ' * for erc20 compatible token on Ethereum blockchain.\n', ' */\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', "    function transfer(address _to, uint _value) external; // Some ERC20 doesn't have return\n", "    function transferFrom(address _from, address _to, uint _value) external; // Some ERC20 doesn't have return\n", "    function approve(address _spender, uint _value) external; // Some ERC20 doesn't have return\n", '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title KULAP Trading Proxy\n', ' * @dev The KULAP trading proxy interface has an standard functions and event\n', ' * for other smart contract to implement to join KULAP Dex as Market Maker. \n', ' */\n', 'interface KULAPTradingProxy {\n', '    // Trade event\n', '    /// @dev when new trade occure (and success), this event will be boardcast. \n', '    /// @param src Source token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @param dest   Destination token\n', '    /// @return amount of actual destination tokens\n', '    event Trade( ERC20 src, uint256 srcAmount, ERC20 dest, uint256 destAmount);\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Source token\n', '    /// @param dest   Destination token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @return amount of actual destination tokens\n', '    function trade(\n', '        ERC20 src,\n', '        ERC20 dest,\n', '        uint256 srcAmount\n', '    )\n', '        external\n', '        payable\n', '        returns(uint256);\n', '    \n', '    /// @dev provite current rate between source and destination token \n', '    ///      for given source amount\n', '    /// @param src Source token\n', '    /// @param dest   Destination token\n', '    /// @param srcAmount amount of source tokens\n', '    /// @return current reserve and rate\n', '    function rate(\n', '        ERC20 src, \n', '        ERC20 dest, \n', '        uint256 srcAmount\n', '    ) \n', '        external \n', '        view \n', '        returns(uint256, uint256);\n', '}\n', '\n', 'contract KulapDex is Ownable {\n', '    event Trade(\n', '        // Source\n', '        address indexed _srcAsset,\n', '        uint256         _srcAmount,\n', '\n', '        // Destination\n', '        address indexed _destAsset,\n', '        uint256         _destAmount,\n', '\n', '        // User\n', '        address indexed _trader, \n', '\n', '        // System\n', '        uint256          fee\n', '    );\n', '\n', '    using SafeMath for uint256;\n', '    ERC20 public etherERC20 = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '\n', '    // address public dexWallet = 0x7ff0F1919424F0D2B6A109E3139ae0f1d836D468; // To receive fee of the KULAP Dex network\n', '\n', '    // list of trading proxies\n', '    KULAPTradingProxy[] public tradingProxies;\n', '\n', '    function _tradeEtherToToken(\n', '        uint256 tradingProxyIndex, \n', '        uint256 srcAmount, \n', '        ERC20 dest\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Trade to proxy\n', '        uint256 destAmount = tradingProxy.trade.value(srcAmount)(\n', '            etherERC20,\n', '            dest,\n', '            srcAmount\n', '        );\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Receive ETH in case of trade Token -> ETH, will get ETH back from trading proxy\n', '    function () public payable {\n', '\n', '    }\n', '\n', '    function _tradeTokenToEther(\n', '        uint256 tradingProxyIndex,\n', '        ERC20 src,\n', '        uint256 srcAmount\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, srcAmount);\n', '\n', '        // Trande to proxy\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            etherERC20,\n', '            srcAmount\n', '        );\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    function _tradeTokenToToken(\n', '        uint256 tradingProxyIndex,\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest\n', '        ) \n', '        private \n', '        returns(uint256)  {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        // Approve to TradingProxy\n', '        src.approve(tradingProxy, srcAmount);\n', '\n', '        // Trande to proxy\n', '        uint256 destAmount = tradingProxy.trade(\n', '            src, \n', '            dest,\n', '            srcAmount\n', '        );\n', '        \n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function _trade(\n', '        uint256             _tradingProxyIndex, \n', '        ERC20               _src, \n', '        uint256             _srcAmount, \n', '        ERC20               _dest, \n', '        uint256             _minDestAmount\n', '    ) private returns(uint256)  {\n', '        // Destination amount\n', '        uint256 destAmount;\n', '\n', '        // Record src/dest asset for later consistency check.\n', '        uint256 srcAmountBefore;\n', '        uint256 destAmountBefore;\n', '        // Source\n', '        if (etherERC20 == _src) {\n', '            srcAmountBefore = address(this).balance;\n', '        } else {\n', '            srcAmountBefore = _src.balanceOf(this);\n', '        }\n', '        // Dest\n', '        if (etherERC20 == _dest) {\n', '            destAmountBefore = address(this).balance;\n', '        } else {\n', '            destAmountBefore = _dest.balanceOf(this);\n', '        }\n', '\n', '        // Trade ETH -> Token\n', '        if (etherERC20 == _src) {\n', '            destAmount = _tradeEtherToToken(_tradingProxyIndex, _srcAmount, _dest);\n', '        \n', '        // Trade Token -> ETH\n', '        } else if (etherERC20 == _dest) {\n', '            destAmount = _tradeTokenToEther(_tradingProxyIndex, _src, _srcAmount);\n', '\n', '        // Trade Token -> Token\n', '        } else {\n', '            destAmount = _tradeTokenToToken(_tradingProxyIndex, _src, _srcAmount, _dest);\n', '        }\n', '\n', '        // Recheck if src/dest amount correct\n', '        // Source\n', '        if (etherERC20 == _src) {\n', '            require(address(this).balance == srcAmountBefore.sub(_srcAmount), "source amount mismatch after trade");\n', '        } else {\n', '            require(_src.balanceOf(this) == srcAmountBefore.sub(_srcAmount), "source amount mismatch after trade");\n', '        }\n', '        // Dest\n', '        if (etherERC20 == _dest) {\n', '            require(address(this).balance == destAmountBefore.add(destAmount), "destination amount mismatch after trade");\n', '        } else {\n', '            require(_dest.balanceOf(this) == destAmountBefore.add(destAmount), "destination amount mismatch after trade");\n', '        }\n', '\n', "        // Throw exception if destination amount doesn't meet user requirement.\n", '        require(destAmount >= _minDestAmount, "destination amount is too low.");\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 0.5 ETH -> EOS\n', '    // 0, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "500000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "21003850000000000000"\n', '    //\n', '    // Ex2: trade 30 EOS -> ETH\n', '    // 0, "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "30000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "740825000000000000"\n', '    function trade(uint256 tradingProxyIndex, ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minDestAmount) payable public returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', "        // Prepare source's asset\n", '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        // Trade with proxy\n', '        destAmount = _trade(tradingProxyIndex, src, srcAmount, dest, 1);\n', '\n', "        // Throw exception if destination amount doesn't meet user requirement.\n", '        require(destAmount >= minDestAmount, "destination amount is too low.");\n', '\n', '        // Send back ether to sender\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // Throws on failure\n', '            msg.sender.transfer(destAmount);\n', '        \n', '        // Send back token to sender\n', '        } else {\n', "            // Some ERC20 Smart contract not return Bool, so we can't check here\n", '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        emit Trade(src, srcAmount, dest, destAmount, msg.sender, 0);\n', '        \n', '\n', '        return destAmount;\n', '    }\n', '\n', '    // Ex1: trade 50 OMG -> ETH -> EOS\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> EOS\n', '    // "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "30000000000000000000", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817", "1", ["0x0000000000000000000000000000000000000000", "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x0000000000000000000000000000000000000000", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0xd3c64BbA75859Eb808ACE6F2A6048ecdb2d70817"]\n', '    //\n', '    // Ex2: trade 50 OMG -> ETH -> DAI\n', '    // Step1: trade 50 OMG -> ETH\n', '    // Step2: trade xx ETH -> DAI\n', '    // "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "30000000000000000000", "0x45ad02b30930cad22ff7921c111d22943c6c822f", "1", ["0x0000000000000000000000000000000000000000", "0x5b9a857e0C3F2acc5b94f6693536d3Adf5D6e6Be", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x0000000000000000000000000000000000000001", "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "0x45ad02b30930cad22ff7921c111d22943c6c822f"]\n', '    function tradeRoutes(\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest,\n', '        uint256 minDestAmount,\n', '        address[] _tradingPaths)\n', '\n', '        public payable returns(uint256)  {\n', '        uint256 destAmount;\n', '\n', '        if (etherERC20 != src) {\n', '            // Transfer token to This address\n', '            src.transferFrom(msg.sender, address(this), srcAmount);\n', '        }\n', '\n', '        uint256 pathSrcAmount = srcAmount;\n', '        for (uint i = 0; i < _tradingPaths.length; i += 3) {\n', '            uint256 tradingProxyIndex =         uint256(_tradingPaths[i]);\n', '            ERC20 pathSrc =                     ERC20(_tradingPaths[i+1]);\n', '            ERC20 pathDest =                    ERC20(_tradingPaths[i+2]);\n', '\n', '            destAmount = _trade(tradingProxyIndex, pathSrc, pathSrcAmount, pathDest, 1);\n', '            pathSrcAmount = destAmount;\n', '        }\n', '\n', "        // Throw exception if destination amount doesn't meet user requirement.\n", '        require(destAmount >= minDestAmount, "destination amount is too low.");\n', '\n', '        // Trade Any -> ETH\n', '        if (etherERC20 == dest) {\n', '            // Send back ether to sender\n', '            // Throws on failure\n', '            msg.sender.transfer(destAmount);\n', '        \n', '        // Trade Any -> Token\n', '        } else {\n', '            // Send back token to sender\n', "            // Some ERC20 Smart contract not return Bool, so we can't check here\n", '            // require(dest.transfer(msg.sender, destAmount));\n', '            dest.transfer(msg.sender, destAmount);\n', '        }\n', '\n', '        emit Trade(src, srcAmount, dest, destAmount, msg.sender, 0);\n', '\n', '        return destAmount;\n', '    }\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n', '    /// @param tradingProxyIndex index of trading proxy\n', '    /// @param src Source token\n', '    /// @param dest Destination token\n', '    /// @param srcAmount Srouce amount\n', '    /* solhint-disable code-complexity */\n', '    function rate(uint256 tradingProxyIndex, ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint, uint) {\n', '        // Load trading proxy\n', '        KULAPTradingProxy tradingProxy = tradingProxies[tradingProxyIndex];\n', '\n', '        return tradingProxy.rate(src, dest, srcAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Function for adding new trading proxy\n', '    * @param _proxyAddress The address of trading proxy.\n', '    * @return index of this proxy.\n', '    */\n', '    function addTradingProxy(\n', '        KULAPTradingProxy _proxyAddress\n', '    ) public onlyOwner returns (uint256) {\n', '\n', '        tradingProxies.push(_proxyAddress);\n', '\n', '        return tradingProxies.length;\n', '    }\n', '}']
