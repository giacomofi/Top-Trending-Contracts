['pragma solidity ^0.4.19;\n', '\n', 'contract AccessControl {\n', '    address public owner;\n', '    address[] public admins;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmins {\n', '        bool found = false;\n', '\n', '        for (uint i = 0; i < admins.length; i++) {\n', '            if (admins[i] == msg.sender) {\n', '                found = true;\n', '                break;\n', '            }\n', '        }\n', '        require(found);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address _adminAddress) public onlyOwner {\n', '        admins.push(_adminAddress);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract ERC721 {\n', '    // Required Functions\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) public view returns (address);\n', '    function transfer(address _to, uint _tokenId) public;\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '\n', '    // Optional Functions\n', '    function name() public pure returns (string);\n', '    function symbol() public pure returns (string);\n', '\n', '    // Required Events\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '}\n', '\n', '\n', 'contract CryptoBeauty is AccessControl, ERC721 {\n', '    // Event fired for every new beauty created\n', '    event Creation(uint256 tokenId, string name, address owner);\n', '\n', '    // Event fired whenever beauty is sold\n', '    event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId);\n', '\n', '    // Event fired when price of beauty changes\n', '    event PriceChange(uint256 tokenId, uint256 price);\n', '\n', '    // Event fired when charities are modified\n', '    event Charity(uint256 charityId, address charity);\n', '\n', '    string public constant NAME = "Crypto Beauty"; \n', '    string public constant SYMBOL = "BEAUTY"; \n', '\n', '    // Initial price of card\n', '    uint256 private startingPrice = 0.005 ether;\n', '    uint256 private increaseLimit1 = 0.5 ether;\n', '    uint256 private increaseLimit2 = 50.0  ether;\n', '    uint256 private increaseLimit3 = 100.0  ether;\n', '\n', '    // Charities enabled in the future\n', '    bool charityEnabled;\n', '\n', '    // Beauty card\n', '    struct Beauty {\n', '        // unique name of beauty\n', '        string name;\n', '\n', '        // selling price\n', '        uint256 price;\n', '\n', '        // maximum price\n', '        uint256 maxPrice;\n', '    }\n', '\n', '    Beauty[] public beauties;\n', '\n', '    address[] public charities;\n', '    \n', '    mapping (uint256 => address) public beautyToOwner;\n', '    mapping (address => uint256) public beautyOwnershipCount;\n', '    mapping (uint256 => address) public beautyToApproved;\n', '\n', '    function CryptoBeauty() public {\n', '        owner = msg.sender;\n', '        admins.push(msg.sender);\n', '        charityEnabled = false;\n', '    }\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return beauties.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return beautyOwnershipCount[_owner];\n', '    }\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n', '        owner = beautyToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public {\n', '        require(_to != address(0));\n', '        require(beautyToOwner[_tokenId] == msg.sender);\n', '\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    function approve(address _to, uint256 _tokenId) public {\n', '        require(beautyToOwner[_tokenId] == msg.sender);\n', '        beautyToApproved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '        require(beautyToApproved[_tokenId] == _to);\n', '        require(_to != address(0));\n', '        require(beautyToOwner[_tokenId] == _from);\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function addCharity(address _charity) public onlyAdmins {\n', '        require(_charity != address(0));\n', '\n', '        uint256 newCharityId = charities.push(_charity) - 1;\n', '\n', '        // emit charity event\n', '        Charity(newCharityId, _charity);\n', '    }\n', '\n', '    function deleteCharity(uint256 _charityId) public onlyAdmins {\n', '        delete charities[_charityId];\n', '\n', '        // emit charity event\n', '        Charity(_charityId, address(0));\n', '    }\n', '\n', '    function getCharity(uint256 _charityId) public view returns (address) {\n', '        return charities[_charityId];\n', '    }\n', '\n', '    function createBeauty(string _name, address _owner, uint256 _price) public onlyAdmins {\n', '        if (_price <= 0.005 ether) {\n', '            _price = startingPrice;\n', '        }\n', '        \n', '        Beauty memory _beauty = Beauty({\n', '            name: _name,\n', '            price: _price,\n', '            maxPrice: _price\n', '        });\n', '        uint256 newBeautyId = beauties.push(_beauty) - 1;\n', '\n', '        Creation(newBeautyId, _name, _owner);\n', '\n', '        _transfer(address(0), _owner, newBeautyId);\n', '\n', '\n', '    }\n', '    \n', '    function newBeauty(string _name, uint256 _price) public onlyAdmins {\n', '        createBeauty(_name, msg.sender, _price);\n', '    }\n', '\n', '    function getBeauty(uint256 _tokenId) public view returns (\n', '        string beautyName,\n', '        uint256 sellingPrice,\n', '        uint256 maxPrice,\n', '        address owner\n', '    ) {\n', '        Beauty storage beauty = beauties[_tokenId];\n', '        beautyName = beauty.name;\n', '        sellingPrice = beauty.price;\n', '        maxPrice = beauty.maxPrice;\n', '        owner = beautyToOwner[_tokenId];\n', '    }\n', '\n', '\n', '    function purchase(uint256 _tokenId, uint256 _charityId) public payable {\n', '        // seller\n', '        address oldOwner = beautyToOwner[_tokenId];\n', '        // current price\n', '        uint sellingPrice = beauties[_tokenId].price;\n', '        // buyer\n', '        address newOwner = msg.sender;\n', '        \n', '        require(oldOwner != newOwner);\n', '        require(newOwner != address(0));\n', '        require(msg.value >= sellingPrice);\n', '        \n', '        uint256 devCut;\n', '        uint256 nextPrice;\n', '\n', '        if (sellingPrice < increaseLimit1) {\n', '          devCut = SafeMath.div(SafeMath.mul(sellingPrice, 5), 100); // 5%\n', '          nextPrice = SafeMath.div(SafeMath.mul(sellingPrice, 200), 95);\n', '        } else if (sellingPrice < increaseLimit2) {\n', '          devCut = SafeMath.div(SafeMath.mul(sellingPrice, 4), 100); // 4%\n', '          nextPrice = SafeMath.div(SafeMath.mul(sellingPrice, 135), 96);\n', '        } else if (sellingPrice < increaseLimit3) {\n', '          devCut = SafeMath.div(SafeMath.mul(sellingPrice, 3), 100); // 3%\n', '          nextPrice = SafeMath.div(SafeMath.mul(sellingPrice, 125), 97);\n', '        } else {\n', '          devCut = SafeMath.div(SafeMath.mul(sellingPrice, 2), 100); // 2%\n', '          nextPrice = SafeMath.div(SafeMath.mul(sellingPrice, 115), 98);\n', '        }\n', '\n', '        uint256 excess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '        if (charityEnabled == true) {\n', '            \n', '            // address of choosen charity\n', '            address charity = charities[_charityId];\n', '\n', '            // check if charity address is not null\n', '            require(charity != address(0));\n', '            \n', '            // 1% of selling price\n', '            uint256 donate = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 1), 100));\n', '\n', '            // transfer money to charity\n', '            charity.transfer(donate);\n', '            \n', '        }\n', '\n', '        // set new price\n', '        beauties[_tokenId].price = nextPrice;\n', '        \n', '        // set maximum price\n', '        beauties[_tokenId].maxPrice = nextPrice;\n', '\n', '        // transfer card to buyer\n', '        _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '        // transfer money to seller\n', '        if (oldOwner != address(this)) {\n', '            oldOwner.transfer(SafeMath.sub(sellingPrice, devCut));\n', '        }\n', '\n', '        // emit event that beauty was sold;\n', '        Purchase(_tokenId, sellingPrice, beauties[_tokenId].price, oldOwner, newOwner, _charityId);\n', '        \n', '        // transfer excess back to buyer\n', '        if (excess > 0) {\n', '            newOwner.transfer(excess);\n', '        }  \n', '    }\n', '\n', '    // owner can change price\n', '    function changePrice(uint256 _tokenId, uint256 _price) public {\n', '        // only owner can change price\n', '        require(beautyToOwner[_tokenId] == msg.sender);\n', '\n', '        // price cannot be higher than maximum price\n', '        require(beauties[_tokenId].maxPrice >= _price);\n', '\n', '        // set new price\n', '        beauties[_tokenId].price = _price;\n', '        \n', '        // emit event\n', '        PriceChange(_tokenId, _price);\n', '    }\n', '\n', '    function priceOfBeauty(uint256 _tokenId) public view returns (uint256) {\n', '        return beauties[_tokenId].price;\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) public view returns(uint256[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint256[] memory result = new uint256[](tokenCount);\n', '        uint256 total = totalSupply();\n', '        uint256 resultIndex = 0;\n', '\n', '        for(uint256 i = 0; i <= total; i++) {\n', '            if (beautyToOwner[i] == _owner) {\n', '                result[resultIndex] = i;\n', '                resultIndex++;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        beautyOwnershipCount[_to]++;\n', '        beautyToOwner[_tokenId] = _to;\n', '\n', '        if (_from != address(0)) {\n', '            beautyOwnershipCount[_from]--;\n', '            delete beautyToApproved[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function enableCharity() external onlyOwner {\n', '        require(!charityEnabled);\n', '        charityEnabled = true;\n', '    }\n', '\n', '    function disableCharity() external onlyOwner {\n', '        require(charityEnabled);\n', '        charityEnabled = false;\n', '    }\n', '\n', '    function withdrawAll() external onlyAdmins {\n', '        msg.sender.transfer(this.balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 _amount) external onlyAdmins {\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']