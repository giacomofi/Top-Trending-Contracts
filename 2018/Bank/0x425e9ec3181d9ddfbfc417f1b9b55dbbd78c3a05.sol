['pragma solidity ^0.4.20;\n', '\n', '/*\n', '* Team Proof of Long Hodl presents..\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract ProofOfLongHodl {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    address owner;\n', '    mapping(address => bool) preauthorized;\n', '    bool gameStarted;\n', '\n', '    uint constant depositTaxDivisor = 29;\t\t// 29% of  deposits goes to  divs\n', '    uint constant withdrawalTaxDivisor = 29;\t// 29% of  withdrawals goes to  divs\n', '    uint constant lotteryFee = 25; \t\t\t\t// 4% of deposits and withdrawals goes to lotteryPool\n', '\n', '    mapping(address => uint) public investment;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfLongHodl() public {\n', '        owner = msg.sender;\n', '        preauthorized[owner] = true;\n', '    }\n', '\n', '    function preauthorize(address _user) public {\n', '        require(msg.sender == owner);\n', '        preauthorized[_user] = true;\n', '    }\n', '\n', '    function startGame() public {\n', '        require(msg.sender == owner);\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '    \trequire(_amount > 0);\n', '        uint _tax = _amount.mul(depositTaxDivisor).div(100);\n', '        uint _lotteryPool = _amount.div(lotteryFee); // add to lottery fee\n', '        uint _amountAfterTax = _amount.sub(_tax).sub(_lotteryPool);\n', '\n', '        lotteryPool = lotteryPool.add(_lotteryPool);\n', '\n', '        // check if first deposit, and greater than and make user eligable for lottery\n', '        if (isEligable[msg.sender] == false &&  _amount > 0.1 ether) {\n', '        \tisEligable[msg.sender] = true;\n', '        \thasWithdrawed[msg.sender] = false;\n', '\n', '        \tlotteryAddresses.push(msg.sender);\n', '        \teligableIndex[msg.sender] = lotteryAddresses.length - 1;      \t\n', '        }\n', '\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit() public payable {\n', '        require(preauthorized[msg.sender] || gameStarted);\n', '        depositHelper(msg.value);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.mul(withdrawalTaxDivisor).div(100);\n', '        uint _lotteryPool = _amount.div(lotteryFee); // add to lottery fee\n', '        uint _amountAfterTax = _amount.sub(_tax).sub(_lotteryPool);\n', '\n', '        lotteryPool = lotteryPool.add(_lotteryPool);\n', '\n', '        // removing user from lotteryAddresses if it is first withdraw\n', '        if (lotteryAddresses.length != 0 && !hasWithdrawed[msg.sender] ) {\n', '        \thasWithdrawed[msg.sender] = true;\n', '        \tisEligable[msg.sender] = false;\n', '        \ttotalWithdrawals = totalWithdrawals.add(_amountAfterTax);\n', '        \twithdrawalsCTR++;\n', '\n', '        \t// delete user from lottery addresses index to delete\n', '        \tuint indexToDelete = eligableIndex[msg.sender]; \n', '        \taddress lastAddress = lotteryAddresses[lotteryAddresses.length - 1];\n', '        \tlotteryAddresses[indexToDelete] = lastAddress;\n', '        \tlotteryAddresses.length--;\n', '\n', '        \teligableIndex[lastAddress] = indexToDelete;\n', '        \teligableIndex[msg.sender] = 0;\n', '\n', '        \tif (withdrawalsCTR > 9 && totalWithdrawals > 1 ether) {\n', '        \t\t// pick lottery winner and sent reward\n', '\t\t\t    uint256 winnerIndex = rand(lotteryAddresses.length);\n', '\t\t\t    address winner = lotteryAddresses[winnerIndex];\n', '\n', '\t\t\t    winner.transfer(lotteryPool);\n', '\t\t\t    totalWithdrawals = 0;\n', '\t\t\t    withdrawalsCTR = 0;\n', '\t\t\t    lotteryPool = 0;\n', '\t\t\t    lotteryRound++;\n', '\t\t\t    lastWinner = winner;\n', '        \t}\n', '        }\n', '\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '\n', '        msg.sender.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        msg.sender.transfer(_dividends);\n', '\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '\n', '        emit Reinvest(msg.sender, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    // LOTTERY MODULE\n', '    uint private lotteryPool = 0;\n', '    uint private lotteryRound = 1;\n', '    address private lastWinner;\n', '\n', '    uint public withdrawalsCTR = 0;\n', '    uint public totalWithdrawals = 0;\n', '\n', '    mapping(address => uint256) internal eligableIndex; // \n', '    mapping(address => bool) internal isEligable; // for first deposit check\n', '    mapping(address => bool) internal hasWithdrawed; // check if user already withdrawed\n', '\n', '    address[] public lotteryAddresses;\n', '\n', '    // Generate random number between 0 & max\n', '    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n', '    function rand(uint max) constant public returns (uint256 result){\n', '        uint256 factor = FACTOR * 100 / max;\n', '        uint256 lastBlockNumber = block.number - 1;\n', '        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n', '    \n', '        return uint256((uint256(hashVal) / factor)) % max;\n', '    }\n', '\n', '    // check if address is withdrawed\n', '    function checkIfEligable(address _address) public view returns (bool) {\n', '    \treturn (isEligable[_address] && !hasWithdrawed[_address]) ;\n', '    }\n', '\n', '    function getLotteryData() public view returns( uint256, uint256, address) {\n', '    \treturn (lotteryPool, lotteryRound, lastWinner);\n', '    }\n', '\n', '    function lotteryParticipants() public view returns(uint256) {\n', '    \treturn lotteryAddresses.length;\n', '    }\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold                                                                                                                       \n', '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/*\n', '* Team Proof of Long Hodl presents..\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract ProofOfLongHodl {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    address owner;\n', '    mapping(address => bool) preauthorized;\n', '    bool gameStarted;\n', '\n', '    uint constant depositTaxDivisor = 29;\t\t// 29% of  deposits goes to  divs\n', '    uint constant withdrawalTaxDivisor = 29;\t// 29% of  withdrawals goes to  divs\n', '    uint constant lotteryFee = 25; \t\t\t\t// 4% of deposits and withdrawals goes to lotteryPool\n', '\n', '    mapping(address => uint) public investment;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfLongHodl() public {\n', '        owner = msg.sender;\n', '        preauthorized[owner] = true;\n', '    }\n', '\n', '    function preauthorize(address _user) public {\n', '        require(msg.sender == owner);\n', '        preauthorized[_user] = true;\n', '    }\n', '\n', '    function startGame() public {\n', '        require(msg.sender == owner);\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '    \trequire(_amount > 0);\n', '        uint _tax = _amount.mul(depositTaxDivisor).div(100);\n', '        uint _lotteryPool = _amount.div(lotteryFee); // add to lottery fee\n', '        uint _amountAfterTax = _amount.sub(_tax).sub(_lotteryPool);\n', '\n', '        lotteryPool = lotteryPool.add(_lotteryPool);\n', '\n', '        // check if first deposit, and greater than and make user eligable for lottery\n', '        if (isEligable[msg.sender] == false &&  _amount > 0.1 ether) {\n', '        \tisEligable[msg.sender] = true;\n', '        \thasWithdrawed[msg.sender] = false;\n', '\n', '        \tlotteryAddresses.push(msg.sender);\n', '        \teligableIndex[msg.sender] = lotteryAddresses.length - 1;      \t\n', '        }\n', '\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit() public payable {\n', '        require(preauthorized[msg.sender] || gameStarted);\n', '        depositHelper(msg.value);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.mul(withdrawalTaxDivisor).div(100);\n', '        uint _lotteryPool = _amount.div(lotteryFee); // add to lottery fee\n', '        uint _amountAfterTax = _amount.sub(_tax).sub(_lotteryPool);\n', '\n', '        lotteryPool = lotteryPool.add(_lotteryPool);\n', '\n', '        // removing user from lotteryAddresses if it is first withdraw\n', '        if (lotteryAddresses.length != 0 && !hasWithdrawed[msg.sender] ) {\n', '        \thasWithdrawed[msg.sender] = true;\n', '        \tisEligable[msg.sender] = false;\n', '        \ttotalWithdrawals = totalWithdrawals.add(_amountAfterTax);\n', '        \twithdrawalsCTR++;\n', '\n', '        \t// delete user from lottery addresses index to delete\n', '        \tuint indexToDelete = eligableIndex[msg.sender]; \n', '        \taddress lastAddress = lotteryAddresses[lotteryAddresses.length - 1];\n', '        \tlotteryAddresses[indexToDelete] = lastAddress;\n', '        \tlotteryAddresses.length--;\n', '\n', '        \teligableIndex[lastAddress] = indexToDelete;\n', '        \teligableIndex[msg.sender] = 0;\n', '\n', '        \tif (withdrawalsCTR > 9 && totalWithdrawals > 1 ether) {\n', '        \t\t// pick lottery winner and sent reward\n', '\t\t\t    uint256 winnerIndex = rand(lotteryAddresses.length);\n', '\t\t\t    address winner = lotteryAddresses[winnerIndex];\n', '\n', '\t\t\t    winner.transfer(lotteryPool);\n', '\t\t\t    totalWithdrawals = 0;\n', '\t\t\t    withdrawalsCTR = 0;\n', '\t\t\t    lotteryPool = 0;\n', '\t\t\t    lotteryRound++;\n', '\t\t\t    lastWinner = winner;\n', '        \t}\n', '        }\n', '\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '\n', '        msg.sender.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        msg.sender.transfer(_dividends);\n', '\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '\n', '        emit Reinvest(msg.sender, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    // LOTTERY MODULE\n', '    uint private lotteryPool = 0;\n', '    uint private lotteryRound = 1;\n', '    address private lastWinner;\n', '\n', '    uint public withdrawalsCTR = 0;\n', '    uint public totalWithdrawals = 0;\n', '\n', '    mapping(address => uint256) internal eligableIndex; // \n', '    mapping(address => bool) internal isEligable; // for first deposit check\n', '    mapping(address => bool) internal hasWithdrawed; // check if user already withdrawed\n', '\n', '    address[] public lotteryAddresses;\n', '\n', '    // Generate random number between 0 & max\n', '    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n', '    function rand(uint max) constant public returns (uint256 result){\n', '        uint256 factor = FACTOR * 100 / max;\n', '        uint256 lastBlockNumber = block.number - 1;\n', '        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n', '    \n', '        return uint256((uint256(hashVal) / factor)) % max;\n', '    }\n', '\n', '    // check if address is withdrawed\n', '    function checkIfEligable(address _address) public view returns (bool) {\n', '    \treturn (isEligable[_address] && !hasWithdrawed[_address]) ;\n', '    }\n', '\n', '    function getLotteryData() public view returns( uint256, uint256, address) {\n', '    \treturn (lotteryPool, lotteryRound, lastWinner);\n', '    }\n', '\n', '    function lotteryParticipants() public view returns(uint256) {\n', '    \treturn lotteryAddresses.length;\n', '    }\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold                                                                                                                       \n", '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
