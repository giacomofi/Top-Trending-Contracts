['contract EtherModifierTigro\n', '{\n', '    struct Person \n', '    {\n', '        address etherAddress;\n', '        uint amount;\n', '    }\n', '\n', '    Person[] public persons;\n', '\n', '    uint public payoutIdx = 0;\n', '    uint public collectedFees;\n', '    uint public balance = 0;\n', '    uint amount;\n', '    uint maximum = (1 ether)/2;\n', '    uint minimum = (1 ether)/10+(1 ether)/100;\n', '    uint exchangemod = 125  ; \n', '    \n', '    address public owner;\n', '    address public developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\n', '\n', '    modifier _onlyowner\n', '    {\n', '        if (msg.sender == owner) \n', '        _\n', '    }\n', '    function EtherModifierTigro() \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function() \n', '    {\n', '        enter();\n', '    }\n', '  \n', '    function enter()\n', '    {\n', '        if (msg.value >= minimum && msg.value <= maximum) //if value is between 0.01 and 0.025\n', '        {\n', '\t        //if value is correct\n', '            collectedFees += ((msg.value/100) * 5) ;\n', '\t        owner.send(collectedFees/2);\n', '\t        developer.send(collectedFees/2);\n', '\t        collectedFees = 0;\n', '\t        amount = msg.value;\n', '\t        canSort();\n', '        }\n', '\t    else\n', '\t    {\n', '            //if value isnt correct\n', '\t\t    collectedFees += ((msg.value/100) * 5); //add fee to fee counter\n', '\t        owner.send(collectedFees/2);    //send halved fee to owner\n', '\t        developer.send(collectedFees/2);//send halved fee to developer\n', '\t        collectedFees = 0;\n', '\t        msg.sender.send(msg.value - ((msg.value/100) * 5)); //return icome - fee to sender\n', '\t    }\n', '    }\n', '    function canSort()\n', '    {\n', '        uint idx = persons.length;\n', '        persons.length += 1;\n', '        persons[idx].etherAddress = msg.sender;\n', '        persons[idx].amount = amount;\n', '        balance += amount - amount/10;\n', '    \n', '        while (balance > persons[payoutIdx].amount / 100 * exchangemod ) \n', '        {\n', '            uint transactionAmount = persons[payoutIdx].amount / 100 * exchangemod;\n', '            persons[payoutIdx].etherAddress.send(transactionAmount);\n', '    \n', '            balance -= transactionAmount;\n', '            payoutIdx += 1;\n', '        }\n', '    }\n', '    function setOwner(address _owner) _onlyowner \n', '    {\n', '        owner = _owner;\n', '    }\n', '}']
['contract EtherModifierTigro\n', '{\n', '    struct Person \n', '    {\n', '        address etherAddress;\n', '        uint amount;\n', '    }\n', '\n', '    Person[] public persons;\n', '\n', '    uint public payoutIdx = 0;\n', '    uint public collectedFees;\n', '    uint public balance = 0;\n', '    uint amount;\n', '    uint maximum = (1 ether)/2;\n', '    uint minimum = (1 ether)/10+(1 ether)/100;\n', '    uint exchangemod = 125  ; \n', '    \n', '    address public owner;\n', '    address public developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\n', '\n', '    modifier _onlyowner\n', '    {\n', '        if (msg.sender == owner) \n', '        _\n', '    }\n', '    function EtherModifierTigro() \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function() \n', '    {\n', '        enter();\n', '    }\n', '  \n', '    function enter()\n', '    {\n', '        if (msg.value >= minimum && msg.value <= maximum) //if value is between 0.01 and 0.025\n', '        {\n', '\t        //if value is correct\n', '            collectedFees += ((msg.value/100) * 5) ;\n', '\t        owner.send(collectedFees/2);\n', '\t        developer.send(collectedFees/2);\n', '\t        collectedFees = 0;\n', '\t        amount = msg.value;\n', '\t        canSort();\n', '        }\n', '\t    else\n', '\t    {\n', '            //if value isnt correct\n', '\t\t    collectedFees += ((msg.value/100) * 5); //add fee to fee counter\n', '\t        owner.send(collectedFees/2);    //send halved fee to owner\n', '\t        developer.send(collectedFees/2);//send halved fee to developer\n', '\t        collectedFees = 0;\n', '\t        msg.sender.send(msg.value - ((msg.value/100) * 5)); //return icome - fee to sender\n', '\t    }\n', '    }\n', '    function canSort()\n', '    {\n', '        uint idx = persons.length;\n', '        persons.length += 1;\n', '        persons[idx].etherAddress = msg.sender;\n', '        persons[idx].amount = amount;\n', '        balance += amount - amount/10;\n', '    \n', '        while (balance > persons[payoutIdx].amount / 100 * exchangemod ) \n', '        {\n', '            uint transactionAmount = persons[payoutIdx].amount / 100 * exchangemod;\n', '            persons[payoutIdx].etherAddress.send(transactionAmount);\n', '    \n', '            balance -= transactionAmount;\n', '            payoutIdx += 1;\n', '        }\n', '    }\n', '    function setOwner(address _owner) _onlyowner \n', '    {\n', '        owner = _owner;\n', '    }\n', '}']
