['pragma solidity ^0.4.18;\n', '\n', '\n', '// EthernityFinancialOracle v0.2\n', '// @ethernity.live\n', '\n', '\n', 'contract Caller {\n', '    function EFOcallBack(string _response);\n', '}\n', '\n', '\n', 'contract EthernityFinancialOracle{\n', '    \n', '    address public owner;\n', '    address public oracleAddress;\n', '    uint public collectedFee; \n', '    uint public feePrice = 0.0005 ether;\n', '    uint public gasLimit = 50000;\n', '    uint public gasPrice = 40000000000 wei;\n', '    \n', '    struct User {\n', '    \tstring response;\n', '    \tbool callBack;\n', '    \tbool asked;\n', '    \tuint balance;\n', '    \tbool banned;\n', '    }\n', '\n', '    mapping(address => User) public users;\n', '\n', '    \n', '    modifier onlyOwner{\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOracle{\n', '        require(msg.sender == oracleAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrOracle {\n', '    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n', '    \t_;\n', '    }\n', '\n', '    modifier notBanned {\n', '        require( users[msg.sender].banned == false );\n', '        _;\n', '    }\n', '\n', '    modifier receivePayment {\n', '        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n', '        _;\n', '    }\n', '\n', '    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n', '    event Response (address _address , string _response);\n', '    event Error (string _error);\n', '    \n', '\n', '    // Main constructor\n', '    function EthernityFinancialOracle() {\n', '        owner = msg.sender;\n', '        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n', '    }   \n', '\n', '    // Payable to receive payments and stores into the mapping through modifier\n', '    function () payable receivePayment {\n', '    }\n', '\n', '    // REQUESTS\n', '    \n', '    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', '        Request (&#39;ETH&#39;, &#39;USD&#39;, msg.sender , _gasPrice , _gasLimit );\n', '    }\n', '    \n', '    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', '        Request (_coin, &#39;USD&#39;, msg.sender , _gasPrice , _gasLimit );\n', '    }\n', '    \n', '    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', '        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n', '    }\n', '\n', '\n', '    function getRefund() {\n', '        if (msg.sender == owner) {\n', '            uint a = collectedFee;\n', '            collectedFee = 0; \n', '            require(owner.send(a));\n', '        } else {\n', '\t        uint b = users[msg.sender].balance;\n', '\t        users[msg.sender].balance = 0;\n', '\t        require(msg.sender.send(b));\n', '\t    \t}\n', '    }\n', '\n', '\n', '    // GETTERS\n', '\n', '    function getResponse() public constant returns(string _response){\n', '        return users[msg.sender].response;\n', '    }\n', '\n', '    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n', '        if (_gasPrice == 0) _gasPrice = gasPrice;\n', '        if (_gasLimit == 0) _gasLimit = gasLimit;\n', '    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n', '    \treturn feePrice + _gasLimit * _gasPrice;\n', '    }\n', '\n', '    function getBalance() public constant returns(uint _balance) {\n', '    \treturn users[msg.sender].balance;\n', '    }\n', '\n', '    function getBalance(address _address) public constant returns(uint _balance) {\n', '\t\treturn users[_address].balance;\n', '    }\n', '\n', '\n', '\n', '    // SET RESPONSE FROM ORACLE\n', '    function setResponse (address _user, string _result) onlyOracle {\n', '\n', '\t\trequire( users[_user].asked );\n', '\t\tusers[_user].asked = false;\n', '\n', '    \tif ( users[_user].callBack ) {\n', '    \t\t// Callback function: passive, expensive, somewhat private\n', '        \tCaller _caller = Caller(_user);\n', '        \t_caller.EFOcallBack(_result);\n', '    \t\t} else {\n', '    \t// Mapping: active, cheap, public\n', '        users[_user].response = _result;\n', '        Response( _user , _result );\n', '    \t}\n', '\n', '    }\n', '\n', '\n', '    // INTERNAL FUNCTIONS\n', '\n', '    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n', '        if (_gasPrice == 0) _gasPrice = gasPrice;\n', '        if (_gasLimit == 0) _gasLimit = gasLimit;\n', '\n', '        uint gp = getPrice(_gasPrice,_gasLimit);\n', '\n', '        require (users[msg.sender].balance >= gp );\n', '\n', '        collectedFee += feePrice;\n', '        users[msg.sender].balance -= gp;\n', '\n', '        require(oracleAddress.send(gp - feePrice));\n', '        return(_gasPrice,_gasLimit);\n', '    }\n', '\n', '\n', '    // ADMIN FUNCTIONS\n', '    \n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n', '        oracleAddress = _newOracleAdd;\n', '    }\n', '\n', '    function setFeePrice(uint _feePrice) onlyOwner {\n', '        feePrice = _feePrice;\n', '    }\n', '\n', '    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n', '    \tgasPrice = _gasPrice;\n', '    }\n', '\n', '    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n', '    \tgasLimit = _gasLimit;\n', '    }\n', '\n', '    function emergencyFlush() onlyOwner {\n', '        require(owner.send(this.balance));\n', '    }\n', '\n', '    function ban(address _user) onlyOwner{\n', '        users[_user].banned = true;\n', '    }\n', '    \n', '    function desBan(address _user) onlyOwner{\n', '        users[_user].banned = false;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '// EthernityFinancialOracle v0.2\n', '// @ethernity.live\n', '\n', '\n', 'contract Caller {\n', '    function EFOcallBack(string _response);\n', '}\n', '\n', '\n', 'contract EthernityFinancialOracle{\n', '    \n', '    address public owner;\n', '    address public oracleAddress;\n', '    uint public collectedFee; \n', '    uint public feePrice = 0.0005 ether;\n', '    uint public gasLimit = 50000;\n', '    uint public gasPrice = 40000000000 wei;\n', '    \n', '    struct User {\n', '    \tstring response;\n', '    \tbool callBack;\n', '    \tbool asked;\n', '    \tuint balance;\n', '    \tbool banned;\n', '    }\n', '\n', '    mapping(address => User) public users;\n', '\n', '    \n', '    modifier onlyOwner{\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOracle{\n', '        require(msg.sender == oracleAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrOracle {\n', '    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n', '    \t_;\n', '    }\n', '\n', '    modifier notBanned {\n', '        require( users[msg.sender].banned == false );\n', '        _;\n', '    }\n', '\n', '    modifier receivePayment {\n', '        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n', '        _;\n', '    }\n', '\n', '    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n', '    event Response (address _address , string _response);\n', '    event Error (string _error);\n', '    \n', '\n', '    // Main constructor\n', '    function EthernityFinancialOracle() {\n', '        owner = msg.sender;\n', '        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n', '    }   \n', '\n', '    // Payable to receive payments and stores into the mapping through modifier\n', '    function () payable receivePayment {\n', '    }\n', '\n', '    // REQUESTS\n', '    \n', '    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', "        Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n", '    }\n', '    \n', '    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', "        Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n", '    }\n', '    \n', '    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n', '    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n', '        users[msg.sender].callBack = _callBack;\n', '        users[msg.sender].asked = true;\n', '        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n', '    }\n', '\n', '\n', '    function getRefund() {\n', '        if (msg.sender == owner) {\n', '            uint a = collectedFee;\n', '            collectedFee = 0; \n', '            require(owner.send(a));\n', '        } else {\n', '\t        uint b = users[msg.sender].balance;\n', '\t        users[msg.sender].balance = 0;\n', '\t        require(msg.sender.send(b));\n', '\t    \t}\n', '    }\n', '\n', '\n', '    // GETTERS\n', '\n', '    function getResponse() public constant returns(string _response){\n', '        return users[msg.sender].response;\n', '    }\n', '\n', '    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n', '        if (_gasPrice == 0) _gasPrice = gasPrice;\n', '        if (_gasLimit == 0) _gasLimit = gasLimit;\n', '    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n', '    \treturn feePrice + _gasLimit * _gasPrice;\n', '    }\n', '\n', '    function getBalance() public constant returns(uint _balance) {\n', '    \treturn users[msg.sender].balance;\n', '    }\n', '\n', '    function getBalance(address _address) public constant returns(uint _balance) {\n', '\t\treturn users[_address].balance;\n', '    }\n', '\n', '\n', '\n', '    // SET RESPONSE FROM ORACLE\n', '    function setResponse (address _user, string _result) onlyOracle {\n', '\n', '\t\trequire( users[_user].asked );\n', '\t\tusers[_user].asked = false;\n', '\n', '    \tif ( users[_user].callBack ) {\n', '    \t\t// Callback function: passive, expensive, somewhat private\n', '        \tCaller _caller = Caller(_user);\n', '        \t_caller.EFOcallBack(_result);\n', '    \t\t} else {\n', '    \t// Mapping: active, cheap, public\n', '        users[_user].response = _result;\n', '        Response( _user , _result );\n', '    \t}\n', '\n', '    }\n', '\n', '\n', '    // INTERNAL FUNCTIONS\n', '\n', '    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n', '        if (_gasPrice == 0) _gasPrice = gasPrice;\n', '        if (_gasLimit == 0) _gasLimit = gasLimit;\n', '\n', '        uint gp = getPrice(_gasPrice,_gasLimit);\n', '\n', '        require (users[msg.sender].balance >= gp );\n', '\n', '        collectedFee += feePrice;\n', '        users[msg.sender].balance -= gp;\n', '\n', '        require(oracleAddress.send(gp - feePrice));\n', '        return(_gasPrice,_gasLimit);\n', '    }\n', '\n', '\n', '    // ADMIN FUNCTIONS\n', '    \n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n', '        oracleAddress = _newOracleAdd;\n', '    }\n', '\n', '    function setFeePrice(uint _feePrice) onlyOwner {\n', '        feePrice = _feePrice;\n', '    }\n', '\n', '    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n', '    \tgasPrice = _gasPrice;\n', '    }\n', '\n', '    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n', '    \tgasLimit = _gasLimit;\n', '    }\n', '\n', '    function emergencyFlush() onlyOwner {\n', '        require(owner.send(this.balance));\n', '    }\n', '\n', '    function ban(address _user) onlyOwner{\n', '        users[_user].banned = true;\n', '    }\n', '    \n', '    function desBan(address _user) onlyOwner{\n', '        users[_user].banned = false;\n', '    }\n', '}']
