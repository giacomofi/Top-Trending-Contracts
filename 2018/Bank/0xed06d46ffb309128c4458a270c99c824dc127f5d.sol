['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/EtherDeltaI.sol\n', '\n', 'contract EtherDeltaI {\n', '\n', '  uint public feeMake; //percentage times (1 ether)\n', '  uint public feeTake; //percentage times (1 ether)\n', '\n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  function deposit() payable;\n', '\n', '  function withdraw(uint amount);\n', '\n', '  function depositToken(address token, uint amount);\n', '\n', '  function withdrawToken(address token, uint amount);\n', '\n', '  function balanceOf(address token, address user) constant returns (uint);\n', '\n', '  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce);\n', '\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\n', '\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool);\n', '\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s);\n', '\n', '}\n', '\n', '// File: contracts/KindMath.sol\n', '\n', '/**\n', ' * @title KindMath\n', ' * @dev Math operations with safety checks that fail\n', ' */\n', 'library KindMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/KeyValueStorage.sol\n', '\n', 'contract KeyValueStorage {\n', '\n', '  mapping(address => mapping(bytes32 => uint256)) _uintStorage;\n', '  mapping(address => mapping(bytes32 => address)) _addressStorage;\n', '  mapping(address => mapping(bytes32 => bool)) _boolStorage;\n', '  mapping(address => mapping(bytes32 => bytes32)) _bytes32Storage;\n', '\n', '  /**** Get Methods ***********/\n', '\n', '  function getAddress(bytes32 key) public view returns (address) {\n', '      return _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function getUint(bytes32 key) public view returns (uint) {\n', '      return _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBool(bytes32 key) public view returns (bool) {\n', '      return _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBytes32(bytes32 key) public view returns (bytes32) {\n', '      return _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '  /**** Set Methods ***********/\n', '\n', '  function setAddress(bytes32 key, address value) public {\n', '      _addressStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setUint(bytes32 key, uint value) public {\n', '      _uintStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBool(bytes32 key, bool value) public {\n', '      _boolStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBytes32(bytes32 key, bytes32 value) public {\n', '      _bytes32Storage[msg.sender][key] = value;\n', '  }\n', '\n', '  /**** Delete Methods ***********/\n', '\n', '  function deleteAddress(bytes32 key) public {\n', '      delete _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteUint(bytes32 key) public {\n', '      delete _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBool(bytes32 key) public {\n', '      delete _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBytes32(bytes32 key) public {\n', '      delete _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/StorageStateful.sol\n', '\n', 'contract StorageStateful {\n', '  KeyValueStorage public keyValueStorage;\n', '}\n', '\n', '// File: contracts/TokenI.sol\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() public returns (uint256);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public returns (uint256);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public returns (uint256);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint256 public decimals;\n', '  string public name;\n', '}\n', '\n', '// File: contracts/EnclavesDEX.sol\n', '\n', 'contract EnclavesDEX is StorageStateful {\n', '  using KindMath for uint256;\n', '\n', '  address public admin; //the admin address\n', '  address public feeAccount; //the account that will receive fees\n', '\n', '  struct EtherDeltaInfo {\n', '    uint256 feeMake;\n', '    uint256 feeTake;\n', '  }\n', '\n', '  EtherDeltaInfo public etherDeltaInfo;\n', '\n', '  uint256 public feeTake; //percentage times 1 ether\n', '  uint256 public feeAmountThreshold; //gasPrice amount under which no fees are charged\n', '\n', '  address public etherDelta;\n', '\n', '  bool public useEIP712 = true;\n', '  bytes32 public tradeABIHash;\n', '  bytes32 public withdrawABIHash;\n', '\n', '  bool freezeTrading;\n', '  bool depositTokenLock;\n', '\n', '  mapping (address => mapping (uint256 => bool)) nonceCheck;\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  //Unused here - used in Proxy\n', '  address internal implementation;\n', '  address public proposedImplementation;\n', '  uint256 public proposedTimestamp;\n', '\n', '  event Order(address indexed tokenGet, uint256 amountGet, address indexed tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address indexed user);\n', '  event Cancel(address indexed tokenGet, uint256 amountGet, address indexed tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address indexed user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, address indexed get, address indexed give, uint8 exchange);\n', '  event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '  event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '  event WithdrawPreSigned(address indexed feeToken, uint256 feeValue, address indexed feeReceiver);\n', '  event Rebalance(address indexed dex, address indexed token, uint256 amount);\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  modifier onlyEtherDelta {\n', '    require(msg.sender == etherDelta);\n', '    _;\n', '  }\n', '\n', '  modifier markTokenDeposit {\n', '    depositTokenLock = true;\n', '    _;\n', '    depositTokenLock = false;\n', '  }\n', '\n', '  modifier inTokenDeposit {\n', '    require(depositTokenLock);\n', '    _;\n', '  }\n', '\n', '  modifier notFrozen {\n', '    require(!freezeTrading);\n', '    _;\n', '  }\n', '\n', '  function setEtherDeltaFees() public onlyAdmin {\n', '    etherDeltaInfo.feeMake = EtherDeltaI(etherDelta).feeMake();\n', '    etherDeltaInfo.feeTake = EtherDeltaI(etherDelta).feeTake();\n', '  }\n', '\n', '  function() public payable onlyEtherDelta {\n', '  }\n', '\n', '  function setTradeABIHash(bytes32 _tradeABIHash) public onlyAdmin {\n', '    tradeABIHash = _tradeABIHash;\n', '  }\n', '\n', '  function setWithdrawABIHash(bytes32 _withdrawABIHash) public onlyAdmin {\n', '    withdrawABIHash = _withdrawABIHash;\n', '  }\n', '\n', '  function setUseEIP712(bool _useEIP712) public onlyAdmin {\n', '    useEIP712 = _useEIP712;\n', '  }\n', '\n', '  function changeAdmin(address _admin) public onlyAdmin {\n', '    admin = _admin;\n', '  }\n', '\n', '  function changeFeeAccount(address _feeAccount) public onlyAdmin {\n', '    require(_feeAccount != address(0));\n', '    feeAccount = _feeAccount;\n', '  }\n', '\n', '  function changeFeeTake(uint256 _feeTake) public onlyAdmin {\n', '    feeTake = _feeTake;\n', '  }\n', '\n', '  function changeFeeAmountThreshold(uint256 _feeAmountThreshold) public onlyAdmin {\n', '    feeAmountThreshold = _feeAmountThreshold;\n', '  }\n', '\n', '  function changeFreezeTrading(bool _freezeTrading) public onlyAdmin {\n', '    freezeTrading = _freezeTrading;\n', '  }\n', '\n', '  function deposit() public payable {\n', '    if (msg.value > 0) {\n', '      tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\n', '      Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '    }\n', '  }\n', '\n', '  function depositEther(uint256 _amount) internal {\n', '    //Will throw if not enough ether sent\n', '    uint256 refund = msg.value.sub(_amount);\n', '    if (_amount != 0) {\n', '      tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(_amount);\n', '      Deposit(address(0), msg.sender, _amount, tokens[address(0)][msg.sender]);\n', '    }\n', '    if (refund > 0) {\n', '      msg.sender.transfer(refund);\n', '    }\n', '  }\n', '\n', '  function depositToken(address _token, uint256 _amount) public markTokenDeposit {\n', '    require(_token != address(0));\n', '    require(Token(_token).transferFrom(msg.sender, address(this), _amount));\n', '    tokens[_token][msg.sender] = tokens[_token][msg.sender].add(_amount);\n', '    Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\n', '  }\n', '\n', '  function depositBoth(address _token, uint256 _amount) public payable {\n', '    depositToken(_token, _amount);\n', '    deposit();\n', '  }\n', '\n', '  function processDeposits(address _token, uint256 _amount) internal {\n', '    //Always need to deal with possible non-zero msg.value\n', '    uint256 etherAmount = 0;\n', '    if ((_token == address(0)) && (tokens[address(0)][msg.sender] < _amount)) {\n', '      etherAmount = _amount.sub(tokens[address(0)][msg.sender]);\n', '    }\n', '    depositEther(etherAmount);\n', '    //Only pull tokens if needed\n', '    if ((_token != address(0)) && (tokens[_token][msg.sender] < _amount)) {\n', '      depositToken(_token, _amount.sub(tokens[_token][msg.sender]));\n', '    }\n', '  }\n', '\n', '  function withdraw(uint256 _amount) public {\n', '    withdrawUser(_amount, msg.sender);\n', '  }\n', '\n', '  function withdrawUser(uint256 _amount, address _user) internal {\n', '    tokens[address(0)][_user] = tokens[address(0)][_user].sub(_amount);\n', '    if (this.balance < _amount) {\n', '      rebalanceEnclaves(address(0), _amount);\n', '    }\n', '    _user.transfer(_amount);\n', '    Withdraw(address(0), _user, _amount, tokens[address(0)][_user]);\n', '  }\n', '\n', '  function withdrawToken(address _token, uint256 _amount) public {\n', '    withdrawTokenUser(_token, _amount, msg.sender);\n', '  }\n', '\n', '  function withdrawTokenUser(address _token, uint256 _amount, address _user) internal {\n', '    require(_token != 0);\n', '    tokens[_token][_user] = tokens[_token][_user].sub(_amount);\n', '    if (Token(_token).balanceOf(address(this)) < _amount) {\n', '      rebalanceEnclaves(_token, _amount);\n', '    }\n', '    require(Token(_token).transfer(_user, _amount));\n', '    Withdraw(_token, _user, _amount, tokens[_token][_user]);\n', '  }\n', '\n', '  function withdrawTokenMulti(address[] _tokens, uint256[] _amounts) public {\n', '    require(_tokens.length == _amounts.length);\n', '    for (uint256 i = 0; i < _tokens.length; i++) {\n', '      withdrawToken(_tokens[i], _amounts[i]);\n', '    }\n', '  }\n', '\n', '  function withdrawBoth(address _token, uint256 _tokenAmount, uint256 _ethAmount) public {\n', '    withdrawToken(_token, _tokenAmount);\n', '    withdraw(_ethAmount);\n', '  }\n', '\n', '  function tokenFallback(address /* _from */, uint256 /* _value */, bytes /* _data */) public view inTokenDeposit {\n', '    //Having this function allows ERC23 tokens to be deposited via the usual approve / transferFrom methods\n', '    //It should only be called whilst a depositToken is occurring\n', '  }\n', '\n', '  function balanceOf(address _token, address _user) public view returns (uint256) {\n', '    return tokens[_token][_user];\n', '  }\n', '\n', '  function order(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce) public {\n', '    bytes32 orderHash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    orders[msg.sender][orderHash] = true;\n', '    Order(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender);\n', '  }\n', '\n', '  function rebalanceEtherDelta(address _token, uint256 _amount) internal {\n', '    uint256 enclavesBalance;\n', '    if (_token == address(0)) {\n', '      enclavesBalance = this.balance;\n', '      if (enclavesBalance < _amount) {\n', '        _amount = enclavesBalance;\n', '      }\n', '      EtherDeltaI(etherDelta).deposit.value(_amount)();\n', '    } else {\n', '      enclavesBalance = Token(_token).balanceOf(address(this));\n', '      if (enclavesBalance < _amount) {\n', '        _amount = enclavesBalance;\n', '      }\n', '      Token(_token).approve(etherDelta, _amount);\n', '      EtherDeltaI(etherDelta).depositToken(_token, _amount);\n', '    }\n', '    Rebalance(etherDelta, _token, _amount);\n', '  }\n', '\n', '  function rebalanceEnclaves(address _token, uint256 _amount) internal {\n', '    uint256 edBalance = EtherDeltaI(etherDelta).balanceOf(_token, address(this));\n', '    if (edBalance < _amount) {\n', '      _amount = edBalance;\n', '    }\n', '    if (_token == address(0)) {\n', '      EtherDeltaI(etherDelta).withdraw(_amount);\n', '    } else {\n', '      EtherDeltaI(etherDelta).withdrawToken(_token, _amount);\n', '    }\n', '    Rebalance(address(this), _token, _amount);\n', '  }\n', '\n', '  function tradeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount, bool _withdraw) public notFrozen payable returns (uint256) {\n', '    _amount = availableVolumeEtherDelta(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _amount);\n', '    require(_amount > 0);\n', '    _tradeEtherDelta(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount);\n', '    if (_withdraw) {\n', '      if (_tokenGive == address(0)) {\n', '        withdraw(_amountGive.mul(_amount) / _amountGet);\n', '      } else {\n', '        withdrawToken(_tokenGive, _amountGive.mul(_amount) / _amountGet);\n', '      }\n', '    }\n', '    return _amount;\n', '  }\n', '\n', '  //amount is denominated in tokenGet\n', '  function _tradeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount) internal {\n', '    uint256 cost = _amount.add(_amount.mul(etherDeltaInfo.feeTake) / 1 ether);\n', '    processDeposits(_tokenGet, cost);\n', '    tokens[_tokenGet][msg.sender] = tokens[_tokenGet][msg.sender].sub(cost);\n', '    if (EtherDeltaI(etherDelta).balanceOf(_tokenGet, address(this)) < cost) {\n', '      rebalanceEtherDelta(_tokenGet, cost);\n', '    }\n', '    EtherDeltaI(etherDelta).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount);\n', '    //Reuse cost to avoid "CompilerError: Stack too deep, try removing local variables."\n', '    cost = _amountGive.mul(_amount) / _amountGet;\n', '    tokens[_tokenGive][msg.sender] = tokens[_tokenGive][msg.sender].add(cost);\n', '    Trade(_tokenGet, _amount, _tokenGive, cost, _user, msg.sender, 1);\n', '  }\n', '\n', '  function trade(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount, bool _withdraw) public notFrozen payable returns (uint256) {\n', '    uint256 availableVolume;\n', '    //Reuse _r to avoid "CompilerError: Stack too deep, try removing local variables."\n', '    (availableVolume, _r) = availableVolumeEnclaves(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s);\n', '    _amount = (availableVolume < _amount) ? availableVolume : _amount;\n', '    require(_amount > 0);\n', '    _trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _user, _amount, _r);\n', '    if (_withdraw) {\n', '      if (_tokenGive == address(0)) {\n', '        withdraw(_amountGive.mul(_amount) / _amountGet);\n', '      } else {\n', '        withdrawToken(_tokenGive, _amountGive.mul(_amount) / _amountGet);\n', '      }\n', '    }\n', '    return _amount;\n', '  }\n', '\n', '  //_amount is denominated in tokenGet\n', '  function _trade(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, address _user, uint256 _amount, bytes32 _orderHash) internal {\n', '    uint256 ethAmount = (_tokenGet == address(0)) ? _amount : _amountGive.mul(_amount) / _amountGet;\n', '    uint256 feeTakeXfer = (ethAmount <= feeAmountThreshold) ? 0 : _amount.mul(feeTake) / (1 ether);\n', '    uint256 cost = _amount.add(feeTakeXfer);\n', '    processDeposits(_tokenGet, cost);\n', '    tokens[_tokenGet][msg.sender] = tokens[_tokenGet][msg.sender].sub(cost);\n', '    //\n', '    tokens[_tokenGet][_user] = tokens[_tokenGet][_user].add(_amount);\n', '    if (feeTakeXfer > 0) {\n', '      tokens[_tokenGet][feeAccount] = tokens[_tokenGet][feeAccount].add(feeTakeXfer);\n', '    }\n', '    tokens[_tokenGive][_user] = tokens[_tokenGive][_user].sub(_amountGive.mul(_amount) / _amountGet);\n', '    //\n', '    //Reuse cost to avoid "CompilerError: Stack too deep, try removing local variables."\n', '    cost = _amountGive.mul(_amount) / _amountGet;\n', '    tokens[_tokenGive][msg.sender] = tokens[_tokenGive][msg.sender].add(cost);\n', '    orderFills[_user][_orderHash] = orderFills[_user][_orderHash].add(_amount);\n', '    Trade(_tokenGet, _amount, _tokenGive, cost, _user, msg.sender, 0);\n', '  }\n', '\n', '  function checkSig(bytes32 _abiHash, bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s, address _user) public view returns(bool) {\n', '    if (useEIP712) {\n', '      return (ecrecover(keccak256(_abiHash, _hash), _v, _r, _s) == _user);\n', '    } else {\n', '      return (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", _hash), _v, _r, _s) == _user);\n', '    }\n', '  }\n', '\n', '  function availableVolumeEnclaves(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) public view returns (uint256, bytes32) {\n', '    bytes32 orderHash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    if (!(\n', '      (orders[_user][orderHash] || checkSig(tradeABIHash, orderHash, _v, _r, _s, _user)) &&\n', '      block.number <= _expires\n', '    )) return (0, orderHash);\n', '    //Reuse amountGet/Give to avoid "CompilerError: Stack too deep, try removing local variables."\n', '    _amountGive = tokens[_tokenGive][_user].mul(_amountGet) / _amountGive;\n', '    _amountGet = _amountGet.sub(orderFills[_user][orderHash]);\n', '    _amountGet = (_amountGive < _amountGet) ? _amountGive : _amountGet;\n', '    return (_amountGet, orderHash);\n', '  }\n', '\n', '  function availableVolumeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint256 _amount) public view returns (uint256) {\n', '    if (block.number > _expires) {\n', '      return 0;\n', '    }\n', '    bytes32 orderHash = sha256(etherDelta, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    //Reuse amountGet/Give to avoid "CompilerError: Stack too deep, try removing local variables."\n', '    _amountGive = EtherDeltaI(etherDelta).tokens(_tokenGive, _user).mul(_amountGet) / _amountGive;\n', '    _amountGet = _amountGet.sub(EtherDeltaI(etherDelta).orderFills(_user, orderHash));\n', '    if (_amountGet > _amountGive) {\n', '      _amountGet = _amountGive;\n', '    }\n', '    if (_amountGet > _amount) {\n', '      _amountGet = _amount;\n', '    }\n', '    return _amountGet;\n', '  }\n', '\n', '  function amountFilled(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user) public view returns(uint256) {\n', '    bytes32 hash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    return orderFills[_user][hash];\n', '  }\n', '\n', '  function cancelOrder(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public {\n', '    bytes32 hash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    require(orders[msg.sender][hash] || checkSig(tradeABIHash, hash, _v, _r, _s, msg.sender));\n', '    orderFills[msg.sender][hash] = _amountGet;\n', '    Cancel(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender, _v, _r, _s);\n', '  }\n', '\n', '  function withdrawPreSigned(address _token, uint256 _value, address _feeToken, uint256 _feeValue, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) public {\n', '    require(nonceCheck[_user][_nonce] == false);\n', '    bytes32 hash = keccak256(address(this), _token, _value, _feeToken, _feeValue, _nonce);\n', '    require(checkSig(withdrawABIHash, hash, _v, _r, _s, _user));\n', '    nonceCheck[_user][_nonce] = true;\n', '    //Debit fee to sender\n', '    tokens[_feeToken][_user] = tokens[_feeToken][_user].sub(_feeValue);\n', '    tokens[_feeToken][msg.sender] = tokens[_feeToken][msg.sender].add(_feeValue);\n', '    if (_token == address(0)) {\n', '      withdrawUser(_value, _user);\n', '    } else {\n', '      withdrawTokenUser(_token, _value, _user);\n', '    }\n', '    WithdrawPreSigned(_feeToken, _feeValue, msg.sender);\n', '  }\n', '\n', '}']