['pragma solidity ^0.4.21;\n', '\n', 'contract ProofOfStableCoin {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    address owner;\n', '    mapping(address => bool) preauthorized;\n', '    bool gameStarted;\n', '\n', '    uint constant depositTaxDivisor = 3;\n', '    uint constant withdrawalTaxDivisor = 3;\n', '\n', '    mapping(address => uint) public investment;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfStableCoin() public {\n', '        owner = msg.sender;\n', '        preauthorized[owner] = true;\n', '    }\n', '\n', '    function preauthorize(address _user) public {\n', '        require(msg.sender == owner);\n', '        preauthorized[_user] = true;\n', '    }\n', '\n', '    function startGame() public {\n', '        require(msg.sender == owner);\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '        uint _tax = _amount.div(depositTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit(uint _amount, address _referrer) public payable {\n', '        require(preauthorized[msg.sender] || gameStarted);\n', '        uint256 _depositAmount = _amount;\n', '        address referralAddress = _referrer;\n', '        address uninitializedAddress = address(0);\n', '       \n', '        // If the referral address is defined then deduct 5% and transfer to the referral address otherwise skip it\n', '        if(_referrer != uninitializedAddress){\n', '         \n', '        // Calculate the 5% of referral commission\n', '\t\tuint256 referralCommission = (_depositAmount / 20); // => 5%\n', '\t\t// Transfer the 5% commission to the referral address\n', '\t    referralAddress.transfer(referralCommission);\n', '\t    \n', '\t    // Amount after deduct the referral commission - 5%\n', '\t    uint256 depostAmountAfterReferralFee = msg.value - referralCommission;\n', '        \n', '        // Push 95% of the deposit amount to depositHelper method\n', '        depositHelper(depostAmountAfterReferralFee);    \n', '        \n', '        }\n', '        \n', '        else {\n', '            \n', '        // Push 100% of the deposit amount to depositHelper method if there is no referral address\n', '        depositHelper(_depositAmount);\n', '    \n', '        }\n', '    \n', '        emit Deposit(msg.sender, msg.value);\n', '    \n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.div(withdrawalTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '        msg.sender.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        msg.sender.transfer(_dividends);\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '        emit Reinvest(msg.sender, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold                                                                                                                       \n', '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract ProofOfStableCoin {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    address owner;\n', '    mapping(address => bool) preauthorized;\n', '    bool gameStarted;\n', '\n', '    uint constant depositTaxDivisor = 3;\n', '    uint constant withdrawalTaxDivisor = 3;\n', '\n', '    mapping(address => uint) public investment;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfStableCoin() public {\n', '        owner = msg.sender;\n', '        preauthorized[owner] = true;\n', '    }\n', '\n', '    function preauthorize(address _user) public {\n', '        require(msg.sender == owner);\n', '        preauthorized[_user] = true;\n', '    }\n', '\n', '    function startGame() public {\n', '        require(msg.sender == owner);\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '        uint _tax = _amount.div(depositTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit(uint _amount, address _referrer) public payable {\n', '        require(preauthorized[msg.sender] || gameStarted);\n', '        uint256 _depositAmount = _amount;\n', '        address referralAddress = _referrer;\n', '        address uninitializedAddress = address(0);\n', '       \n', '        // If the referral address is defined then deduct 5% and transfer to the referral address otherwise skip it\n', '        if(_referrer != uninitializedAddress){\n', '         \n', '        // Calculate the 5% of referral commission\n', '\t\tuint256 referralCommission = (_depositAmount / 20); // => 5%\n', '\t\t// Transfer the 5% commission to the referral address\n', '\t    referralAddress.transfer(referralCommission);\n', '\t    \n', '\t    // Amount after deduct the referral commission - 5%\n', '\t    uint256 depostAmountAfterReferralFee = msg.value - referralCommission;\n', '        \n', '        // Push 95% of the deposit amount to depositHelper method\n', '        depositHelper(depostAmountAfterReferralFee);    \n', '        \n', '        }\n', '        \n', '        else {\n', '            \n', '        // Push 100% of the deposit amount to depositHelper method if there is no referral address\n', '        depositHelper(_depositAmount);\n', '    \n', '        }\n', '    \n', '        emit Deposit(msg.sender, msg.value);\n', '    \n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.div(withdrawalTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '        msg.sender.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        msg.sender.transfer(_dividends);\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '        emit Reinvest(msg.sender, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold                                                                                                                       \n", '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
