['/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="95f4f8fce7d5a5edc5e7fafff0f6e1bbf6faf8">[email&#160;protected]</a>>, Will Warren - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7d0a1411113d4d052d0f1217181e09531e1210">[email&#160;protected]</a>>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    function TokenTransferProxy() Ownable() {\n', '      // This is here for our verification code only\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return Token(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract Whitelist is Ownable {\n', '    mapping (address => uint128) whitelist;\n', '\n', '    event Whitelisted(address who, uint128 nonce);\n', '\n', '    function Whitelist() Ownable() {\n', '      // This is here for our verification code only\n', '    }\n', '\n', '    function setWhitelisting(address who, uint128 nonce) internal {\n', '        whitelist[who] = nonce;\n', '\n', '        Whitelisted(who, nonce);\n', '    }\n', '\n', '    function whitelistUser(address who, uint128 nonce) external onlyOwner {\n', '        setWhitelisting(who, nonce);\n', '    }\n', '\n', '    function whitelistMe(uint128 nonce, uint8 v, bytes32 r, bytes32 s) external {\n', '        bytes32 hash = keccak256(msg.sender, nonce);\n', '        require(ecrecover(hash, v, r, s) == owner);\n', '        require(whitelist[msg.sender] == 0);\n', '\n', '        setWhitelisting(msg.sender, nonce);\n', '    }\n', '\n', '    function isWhitelisted(address who) external view returns(bool) {\n', '        return whitelist[who] > 0;\n', '    }\n', '}\n', '\n', '/// @title Exchange - Facilitates exchange of ERC20 tokens.\n', '/// @author Amir Bandeali - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="56373b3f2416662e0624393c3335227835393b">[email&#160;protected]</a>>, Will Warren - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6b1c0207072b5b133b1904010e081f45080406">[email&#160;protected]</a>>\n', 'contract Exchange is SafeMath, Ownable {\n', '\n', '    // Error Codes\n', '    enum Errors {\n', '        ORDER_EXPIRED,                    // Order has already expired\n', '        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n', '        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n', '        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n', '    }\n', '\n', '    string constant public VERSION = "1.0.0";\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    address public ZRX_TOKEN_CONTRACT;\n', '    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n', '\n', '    Whitelist public whitelist; // Maybe we need to make this mutable?\n', '\n', '    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n', '    mapping (bytes32 => uint) public filled;\n', '    mapping (bytes32 => uint) public cancelled;\n', '\n', '    event LogFill(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint filledMakerTokenAmount,\n', '        uint filledTakerTokenAmount,\n', '        uint paidMakerFee,\n', '        uint paidTakerFee,\n', '        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogCancel(\n', '        address indexed maker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint cancelledMakerTokenAmount,\n', '        uint cancelledTakerTokenAmount,\n', '        bytes32 indexed tokens,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    modifier onlyWhitelisted() {\n', '      require(whitelist.isWhitelisted(msg.sender));\n', '\n', '      _;\n', '    }\n', '\n', '    function Exchange(address _zrxToken, address _tokenTransferProxy, Whitelist _whitelist) {\n', '        ZRX_TOKEN_CONTRACT = _zrxToken;\n', '        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\n', '        whitelist = _whitelist;\n', '    }\n', '\n', '    /*\n', '    * Core exchange functions\n', '    */\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Total amount of takerToken filled in trade.\n', '    function fillOrder(\n', '          address[5] orderAddresses,\n', '          uint[6] orderValues,\n', '          uint fillTakerTokenAmount,\n', '          bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '          uint8 v,\n', '          bytes32 r,\n', '          bytes32 s)\n', '          public\n', '          onlyWhitelisted\n', '          returns (uint filledTakerTokenAmount)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(0) || order.taker == msg.sender);\n', '\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\n', '\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (filledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\n', '            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\n', '            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '        uint paidMakerFee;\n', '        uint paidTakerFee;\n', '        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\n', '\n', '        require(transferViaTokenTransferProxy(\n', '            order.makerToken,\n', '            order.maker,\n', '            msg.sender,\n', '            filledMakerTokenAmount\n', '        ));\n', '\n', '        require(transferViaTokenTransferProxy(\n', '            order.takerToken,\n', '            msg.sender,\n', '            order.maker,\n', '            filledTakerTokenAmount\n', '        ));\n', '\n', '        if (order.feeRecipient != address(0)) {\n', '            if (order.makerFee > 0) {\n', '                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    order.maker,\n', '                    order.feeRecipient,\n', '                    paidMakerFee\n', '                ));\n', '            }\n', '            if (order.takerFee > 0) {\n', '                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    msg.sender,\n', '                    order.feeRecipient,\n', '                    paidTakerFee\n', '                ));\n', '            }\n', '        }\n', '\n', '        LogFill(\n', '            order.maker,\n', '            msg.sender,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            filledMakerTokenAmount,\n', '            filledTakerTokenAmount,\n', '            paidMakerFee,\n', '            paidTakerFee,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Cancels the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n', '    /// @return Amount of takerToken cancelled.\n', '    function cancelOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint cancelTakerTokenAmount)\n', '        public\n', '        onlyWhitelisted\n', '        returns (uint)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.maker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (cancelledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\n', '\n', '        LogCancel(\n', '            order.maker,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\n', '            cancelledTakerTokenAmount,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return cancelledTakerTokenAmount;\n', '    }\n', '\n', '    /*\n', '    * Wrapper functions\n', '    */\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    function fillOrKillOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '    {\n', '        require(fillOrder(\n', '            orderAddresses,\n', '            orderValues,\n', '            fillTakerTokenAmount,\n', '            false,\n', '            v,\n', '            r,\n', '            s\n', '        ) == fillTakerTokenAmount);\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrKillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrKillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    /// @return Total amount of fillTakerTokenAmount filled in orders.\n', '    function fillOrdersUpTo(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '        returns (uint)\n', '    {\n', '        uint filledTakerTokenAmount = 0;\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\n', '            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            ));\n', '            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\n', '        }\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n', '    function batchCancelOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] cancelTakerTokenAmounts)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            cancelOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                cancelTakerTokenAmounts[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Constant public functions\n', '    */\n', '\n', '    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @return Keccak-256 hash of order.\n', '    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            orderAddresses[0], // maker\n', '            orderAddresses[1], // taker\n', '            orderAddresses[2], // makerToken\n', '            orderAddresses[3], // takerToken\n', '            orderAddresses[4], // feeRecipient\n', '            orderValues[0],    // makerTokenAmount\n', '            orderValues[1],    // takerTokenAmount\n', '            orderValues[2],    // makerFee\n', '            orderValues[3],    // takerFee\n', '            orderValues[4],    // expirationTimestampInSec\n', '            orderValues[5]     // salt\n', '        );\n', '    }\n', '\n', '    function getKeccak(bytes32 hash) public constant returns(bytes32) {\n', '        return keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '    }\n', '\n', '    function getSigner(\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (address)\n', '    {\n', '        return ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) returns (address) {\n', '        /* prefix might be needed for geth only\n', '         * https://github.com/ethereum/go-ethereum/issues/3731\n', '         */\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        h = sha3(prefix, h);\n', '\n', '        address addr = ecrecover(h, v, r, s);\n', '\n', '        return addr;\n', '    }\n', '\n', '     function checkSigned(\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (address)\n', '    {\n', '        return ecrecover(\n', '            hash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param signer address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if rounding error > 0.1%.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingError(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) return false; // No rounding error.\n', '\n', '        uint errPercentageTimes1000000 = safeDiv(\n', '            safeMul(remainder, 1000000),\n', '            safeMul(numerator, target)\n', '        );\n', '        return errPercentageTimes1000000 > 1000;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeDiv(safeMul(numerator, target), denominator);\n', '    }\n', '\n', '    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n', '    /// @param orderHash The Keccak-256 hash of the given order.\n', '    /// @return Sum of values already filled and cancelled.\n', '    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeAdd(filled[orderHash], cancelled[orderHash]);\n', '    }\n', '\n', '\n', '    /*\n', '    * Internal functions\n', '    */\n', '\n', '    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\n', '    /// @param token Address of token to transferFrom.\n', '    /// @param from Address transfering token.\n', '    /// @param to Address receiving token.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of token transfer.\n', '    function transferViaTokenTransferProxy(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return TokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\n', '    }\n', '\n', '    /// @dev Checks if any order transfers will fail.\n', '    /// @param order Order struct of params that will be checked.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @return Predicted result of transfers.\n', '    function isTransferable(Order order, uint fillTakerTokenAmount)\n', '        internal\n', '        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\n', '        returns (bool)\n', '    {\n', '        address taker = msg.sender;\n', '        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '\n', '        if (order.feeRecipient != address(0)) {\n', '            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\n', '            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\n', '            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\n', '            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\n', '\n', '            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '            ) return false;\n', '\n', '            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don&#39;t double check makerToken if ZRX\n', '                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\n', '            ) return false;\n', '            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don&#39;t double check takerToken if ZRX\n', '                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\n', '            ) return false;\n', '        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\n', '                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\n', '        ) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Get token balance of an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Token balance of owner.\n', '    function getBalance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\n', '    }\n', '\n', '    /// @dev Get allowance of token given to TokenTransferProxy by an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Allowance of token given to TokenTransferProxy by owner.\n', '    function getAllowance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\n', '    }\n', '\n', '    /// @dev This function permits setting the Whitelist address\n', '    /// @param _whitelist Whitelist address\n', '    function setWhitelist(Whitelist _whitelist) public onlyOwner\n', '    {\n', '        whitelist = _whitelist;\n', '    }\n', '}']