['pragma solidity ^0.4.16;\n', '//创建一个基础合约，有些操作只能是当前合约的创建者才能操作\n', 'contract owned{\n', '    //声明一个用来接收合约创建者的状态变量\n', '    address public owner;\n', '    //构造函数，把当前交易的发送者（合约的创建者）赋予owner变量\n', '    function owned(){\n', '        owner=msg.sender;\n', '    }\n', '    //声明一个修改器，用于有些方法只有合约的创建者才能操作\n', '    modifier onlyOwner{\n', '        if(msg.sender != owner){\n', '            revert();\n', '        }else{\n', '            _;\n', '        }\n', '    }\n', '    //把该合约的拥有者转移给其他人\n', '    function transferOwner(address newOwner) onlyOwner {\n', '        owner=newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract tokenDemo is owned{\n', '    string public name;//代币名字\n', '    string public symbol;//代币符号\n', '    uint8 public decimals=18;//代币小数位\n', '    uint public totalSupply;//代币总量\n', '    \n', '    uint public sellPrice=0.01 ether;//卖价，持有的人卖给智能合约持有者\n', '    uint public buyPrice=0.01 ether;//买价，向持有人买代币\n', '    \n', '    //用一个映射类型的变量，来记录所有帐户的代币的余额\n', '    mapping(address => uint) public balanceOf;\n', '    //用一个映射类型的变量，来记录被冻结的帐户\n', '    mapping(address => bool) public frozenAccount;\n', '    \n', '    \n', '    //构造函数，初始化代币的变量和初始化总量\n', '    function tokenDemo(\n', '        uint initialSupply,\n', '        string _name,\n', '        string _symbol,\n', '        address centralMinter\n', '        ) payable {\n', '        //手动指定代币的的拥有者，如果不填，则默认为合约的部署者\n', '        if(centralMinter !=0){\n', '            owner=centralMinter;\n', '        }\n', '        \n', '        totalSupply=initialSupply * 10 ** uint256(decimals);\n', '        balanceOf[owner]=totalSupply;\n', '        name=_name;\n', '        symbol=_symbol;\n', '    }\n', '    \n', '    function rename(string newTokenName,string newSymbolName) public onlyOwner\n', '    {\n', '        name = newTokenName;\n', '        symbol = newSymbolName;\n', '    }\n', '    \n', '    //发行代币，向指定的目标帐户添加代币\n', '    function mintToken(address target,uint mintedAmount) onlyOwner{\n', '        //判断目标帐户是否存在\n', '        if(target !=0){\n', '            //目标帐户增加相应的的代币\n', '            balanceOf[target] += mintedAmount;\n', '            //增加总量\n', '            totalSupply +=mintedAmount;\n', '        }else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    //实现帐户的冻结和解冻\n', '    function freezeAccount(address target,bool _bool) onlyOwner{\n', '        if(target != 0){\n', '            frozenAccount[target]=_bool;\n', '        }\n', '    }\n', '        \n', '    function transfer(address _to,uint _value){\n', '        //检测交易的发起者的帐户是不是被冻结了\n', '        if(frozenAccount[msg.sender]){\n', '            revert();\n', '        }\n', '        //检测交易发起者的帐户代币余额是否足够\n', '        if(balanceOf[msg.sender]<_value){\n', '            revert();\n', '        }\n', '        //检测溢出\n', '        if((balanceOf[_to]+_value)<balanceOf[_to]){\n', '            revert();\n', '        }\n', '        //实现代币转移\n', '        balanceOf[msg.sender] -=_value;\n', '        balanceOf[_to] +=_value;\n', '    }\n', '    \n', '    \n', '    //设置代币的买卖价格    \n', '    function setPrice(uint newSellPrice,uint newBuyPrice)onlyOwner{\n', '        sellPrice=newSellPrice;\n', '        buyPrice=newBuyPrice;\n', '    }   \n', '    \n', '    \n', '    //持有代币的用户卖代币给合约的拥有者，以获得以太币\n', '    function sell(uint amount) returns(uint revenue){\n', '        //检测交易的发起者的帐户是不是被冻结\n', '        if(frozenAccount[msg.sender]){\n', '            revert();\n', '        }\n', '        //检测交易发起者的帐户的代币余额是否够用\n', '        if(balanceOf[msg.sender]<amount){\n', '            revert();\n', '        }\n', '        //把相应数量的代币给合约的拥有者\n', '        balanceOf[owner] +=amount;\n', '        //卖家的帐户减去相应的余额\n', '        balanceOf[msg.sender] -=amount;\n', '        //计算对应的以太币的价值 \n', '        revenue=amount*sellPrice;\n', '        //向卖家的的帐户发送对应数量的以太币\n', '        if(msg.sender.send(revenue)){\n', '            return revenue;\n', '            \n', '        }else{\n', '            //如果以太币发送失败，则终止程序，并且恢复状态变量\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    \n', '    //向合约的拥有者购买代币\n', '    function buy() payable returns(uint amount){\n', '        //检测买价是不是大于0\n', '        if(buyPrice<=0){\n', '            //如果不是，则终止\n', '            revert();\n', '        }\n', '        //根据用户发送的以太币的数量和代币的买价，计算出代币的数量\n', '        amount=msg.value/buyPrice;\n', '        //检测合约拥有者是否有足够多的代币\n', '        if(balanceOf[owner]<amount){\n', '            revert();\n', '        }\n', '        //向合约的拥有者转移以太币\n', '        if(!owner.send(msg.value)){\n', '            //如果失败，则终止\n', '            revert();\n', '        }\n', '        //合约拥有者的帐户减去相应的代币\n', '        balanceOf[owner] -=amount;\n', '        //买家的帐户增加相应的代币\n', '        balanceOf[msg.sender] +=amount;\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    \n', '}']
['pragma solidity ^0.4.16;\n', '//创建一个基础合约，有些操作只能是当前合约的创建者才能操作\n', 'contract owned{\n', '    //声明一个用来接收合约创建者的状态变量\n', '    address public owner;\n', '    //构造函数，把当前交易的发送者（合约的创建者）赋予owner变量\n', '    function owned(){\n', '        owner=msg.sender;\n', '    }\n', '    //声明一个修改器，用于有些方法只有合约的创建者才能操作\n', '    modifier onlyOwner{\n', '        if(msg.sender != owner){\n', '            revert();\n', '        }else{\n', '            _;\n', '        }\n', '    }\n', '    //把该合约的拥有者转移给其他人\n', '    function transferOwner(address newOwner) onlyOwner {\n', '        owner=newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract tokenDemo is owned{\n', '    string public name;//代币名字\n', '    string public symbol;//代币符号\n', '    uint8 public decimals=18;//代币小数位\n', '    uint public totalSupply;//代币总量\n', '    \n', '    uint public sellPrice=0.01 ether;//卖价，持有的人卖给智能合约持有者\n', '    uint public buyPrice=0.01 ether;//买价，向持有人买代币\n', '    \n', '    //用一个映射类型的变量，来记录所有帐户的代币的余额\n', '    mapping(address => uint) public balanceOf;\n', '    //用一个映射类型的变量，来记录被冻结的帐户\n', '    mapping(address => bool) public frozenAccount;\n', '    \n', '    \n', '    //构造函数，初始化代币的变量和初始化总量\n', '    function tokenDemo(\n', '        uint initialSupply,\n', '        string _name,\n', '        string _symbol,\n', '        address centralMinter\n', '        ) payable {\n', '        //手动指定代币的的拥有者，如果不填，则默认为合约的部署者\n', '        if(centralMinter !=0){\n', '            owner=centralMinter;\n', '        }\n', '        \n', '        totalSupply=initialSupply * 10 ** uint256(decimals);\n', '        balanceOf[owner]=totalSupply;\n', '        name=_name;\n', '        symbol=_symbol;\n', '    }\n', '    \n', '    function rename(string newTokenName,string newSymbolName) public onlyOwner\n', '    {\n', '        name = newTokenName;\n', '        symbol = newSymbolName;\n', '    }\n', '    \n', '    //发行代币，向指定的目标帐户添加代币\n', '    function mintToken(address target,uint mintedAmount) onlyOwner{\n', '        //判断目标帐户是否存在\n', '        if(target !=0){\n', '            //目标帐户增加相应的的代币\n', '            balanceOf[target] += mintedAmount;\n', '            //增加总量\n', '            totalSupply +=mintedAmount;\n', '        }else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    //实现帐户的冻结和解冻\n', '    function freezeAccount(address target,bool _bool) onlyOwner{\n', '        if(target != 0){\n', '            frozenAccount[target]=_bool;\n', '        }\n', '    }\n', '        \n', '    function transfer(address _to,uint _value){\n', '        //检测交易的发起者的帐户是不是被冻结了\n', '        if(frozenAccount[msg.sender]){\n', '            revert();\n', '        }\n', '        //检测交易发起者的帐户代币余额是否足够\n', '        if(balanceOf[msg.sender]<_value){\n', '            revert();\n', '        }\n', '        //检测溢出\n', '        if((balanceOf[_to]+_value)<balanceOf[_to]){\n', '            revert();\n', '        }\n', '        //实现代币转移\n', '        balanceOf[msg.sender] -=_value;\n', '        balanceOf[_to] +=_value;\n', '    }\n', '    \n', '    \n', '    //设置代币的买卖价格    \n', '    function setPrice(uint newSellPrice,uint newBuyPrice)onlyOwner{\n', '        sellPrice=newSellPrice;\n', '        buyPrice=newBuyPrice;\n', '    }   \n', '    \n', '    \n', '    //持有代币的用户卖代币给合约的拥有者，以获得以太币\n', '    function sell(uint amount) returns(uint revenue){\n', '        //检测交易的发起者的帐户是不是被冻结\n', '        if(frozenAccount[msg.sender]){\n', '            revert();\n', '        }\n', '        //检测交易发起者的帐户的代币余额是否够用\n', '        if(balanceOf[msg.sender]<amount){\n', '            revert();\n', '        }\n', '        //把相应数量的代币给合约的拥有者\n', '        balanceOf[owner] +=amount;\n', '        //卖家的帐户减去相应的余额\n', '        balanceOf[msg.sender] -=amount;\n', '        //计算对应的以太币的价值 \n', '        revenue=amount*sellPrice;\n', '        //向卖家的的帐户发送对应数量的以太币\n', '        if(msg.sender.send(revenue)){\n', '            return revenue;\n', '            \n', '        }else{\n', '            //如果以太币发送失败，则终止程序，并且恢复状态变量\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    \n', '    //向合约的拥有者购买代币\n', '    function buy() payable returns(uint amount){\n', '        //检测买价是不是大于0\n', '        if(buyPrice<=0){\n', '            //如果不是，则终止\n', '            revert();\n', '        }\n', '        //根据用户发送的以太币的数量和代币的买价，计算出代币的数量\n', '        amount=msg.value/buyPrice;\n', '        //检测合约拥有者是否有足够多的代币\n', '        if(balanceOf[owner]<amount){\n', '            revert();\n', '        }\n', '        //向合约的拥有者转移以太币\n', '        if(!owner.send(msg.value)){\n', '            //如果失败，则终止\n', '            revert();\n', '        }\n', '        //合约拥有者的帐户减去相应的代币\n', '        balanceOf[owner] -=amount;\n', '        //买家的帐户增加相应的代币\n', '        balanceOf[msg.sender] +=amount;\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    \n', '}']
