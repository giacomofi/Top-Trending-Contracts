['pragma solidity ^0.4.18;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', 'contract UpfiringStore is Ownable {\n', '  using SafeMath for uint;\n', '  mapping(bytes32 => mapping(address => uint)) private payments;\n', '  mapping(bytes32 => mapping(address => uint)) private paymentDates;\n', '  mapping(address => uint) private balances;\n', '  mapping(address => uint) private totalReceiving;\n', '  mapping(address => uint) private totalSpending;\n', '  function UpfiringStore() public {}\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  function totalReceivingOf(address _owner) public view returns (uint balance) {\n', '    return totalReceiving[_owner];\n', '  }\n', '  function totalSpendingOf(address _owner) public view returns (uint balance) {\n', '    return totalSpending[_owner];\n', '  }\n', '  function check(bytes32 _hash, address _from, uint _availablePaymentTime) public view returns (uint amount) {\n', '    uint _amount = payments[_hash][_from];\n', '    uint _date = paymentDates[_hash][_from];\n', '    if (_amount > 0 && (_date + _availablePaymentTime) > now) {\n', '      return _amount;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '  function payment(bytes32 _hash, address _from, uint _amount) onlyOwner public returns (bool result) {\n', '    payments[_hash][_from] = payments[_hash][_from].add(_amount);\n', '    paymentDates[_hash][_from] = now;\n', '    return true;\n', '  }\n', '  function subBalance(address _owner, uint _amount) onlyOwner public returns (bool result) {\n', '    require(balances[_owner] >= _amount);\n', '    balances[_owner] = balances[_owner].sub(_amount);\n', '    totalSpending[_owner] = totalSpending[_owner].add(_amount);\n', '    return true;\n', '  }\n', '  function addBalance(address _owner, uint _amount) onlyOwner public returns (bool result) {\n', '    balances[_owner] = balances[_owner].add(_amount);\n', '    totalReceiving[_owner] = totalReceiving[_owner].add(_amount);\n', '    return true;\n', '  }\n', '}\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'contract Upfiring is Ownable {\n', '  using SafeMath for uint;\n', '  ERC20 public token;\n', '  UpfiringStore public store;\n', '  uint8 public torrentOwnerPercent = 50;\n', '  uint8 public seedersProfitMargin = 3;\n', '  uint public availablePaymentTime = 86400; //seconds\n', '  uint public minWithdraw = 0;\n', '  event Payment(string _torrent, uint _amount, address indexed _from);\n', '  event Refill(address indexed _to, uint _amount);\n', '  event Withdraw(address indexed _to, uint _amount);\n', '  event Pay(address indexed _to, uint _amount, bytes32 _hash);\n', '  event ChangeBalance(address indexed _to, uint _balance);\n', '  event LogEvent(string _log);\n', '  function Upfiring(UpfiringStore _store, ERC20 _token, uint8 _torrentOwnerPercent, uint8 _seedersProfitMargin, uint _minWithdraw) public {\n', '    require(_store != address(0));\n', '    require(_token != address(0));\n', '    require(_torrentOwnerPercent != 0);\n', '    require(_seedersProfitMargin != 0);\n', '    store = _store;\n', '    token = _token;\n', '    torrentOwnerPercent = _torrentOwnerPercent;\n', '    seedersProfitMargin = _seedersProfitMargin;\n', '    minWithdraw = _minWithdraw;\n', '  }\n', '  function() external payable {\n', '    revert();\n', '  }\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return store.balanceOf(_owner);\n', '  }\n', '  function totalReceivingOf(address _owner) public view returns (uint balance) {\n', '    return store.totalReceivingOf(_owner);\n', '  }\n', '  function totalSpendingOf(address _owner) public view returns (uint balance) {\n', '    return store.totalSpendingOf(_owner);\n', '  }\n', '  function check(string _torrent, address _from) public view returns (uint amount) {\n', '    return store.check(torrentToHash(_torrent), _from, availablePaymentTime);\n', '  }\n', '  function torrentToHash(string _torrent) internal pure returns (bytes32 _hash)  {\n', '    return sha256(_torrent);\n', '  }\n', '  function refill(uint _amount) external {\n', '    require(_amount != uint(0));\n', '    require(token.transferFrom(msg.sender, address(this), _amount));\n', '    store.addBalance(msg.sender, _amount);\n', '    ChangeBalance(msg.sender, store.balanceOf(msg.sender));\n', '    Refill(msg.sender, _amount);\n', '  }\n', '  function withdraw(uint _amount) external {\n', '    require(_amount >= minWithdraw);\n', '    require(token.balanceOf(address(this)) >= _amount);\n', '    require(token.transfer(msg.sender, _amount));\n', '    require(store.subBalance(msg.sender, _amount));\n', '    ChangeBalance(msg.sender, store.balanceOf(msg.sender));\n', '    Withdraw(msg.sender, _amount);\n', '  }\n', '  function pay(string _torrent, uint _amount, address _owner, address[] _seeders, address[] _freeSeeders) external {\n', '    require(_amount != uint(0));\n', '    require(_owner != address(0));\n', '    bytes32 _hash = torrentToHash(_torrent);\n', '    require(store.subBalance(msg.sender, _amount));\n', '    store.payment(_hash, msg.sender, _amount);\n', '    Payment(_torrent, _amount, msg.sender);\n', '    ChangeBalance(msg.sender, store.balanceOf(msg.sender));\n', '    sharePayment(_hash, _amount, _owner, _seeders, _freeSeeders);\n', '  }\n', '  function sharePayment(bytes32 _hash, uint _amount, address _owner, address[] _seeders, address[] _freeSeeders) internal {\n', '    if ((_seeders.length + _freeSeeders.length) == 0) {\n', '      payTo(_owner, _amount, _hash);\n', '    } else {\n', '      uint _ownerAmount = _amount.mul(torrentOwnerPercent).div(100);\n', '      uint _otherAmount = _amount.sub(_ownerAmount);\n', '      uint _realOtherAmount = shareSeeders(_seeders, _freeSeeders, _otherAmount, _hash);\n', '      payTo(_owner, _amount.sub(_realOtherAmount), _hash);\n', '    }\n', '  }\n', '  function shareSeeders(address[] _seeders, address[] _freeSeeders, uint _amount, bytes32 _hash) internal returns (uint){\n', '    uint _dLength = _freeSeeders.length.add(_seeders.length.mul(seedersProfitMargin));\n', '    uint _dAmount = _amount.div(_dLength);\n', '    payToList(_seeders, _dAmount.mul(seedersProfitMargin), _hash);\n', '    payToList(_freeSeeders, _dAmount, _hash);\n', '    return _dLength.mul(_dAmount);\n', '  }\n', '  function payToList(address[] _seeders, uint _amount, bytes32 _hash) internal {\n', '    if (_seeders.length > 0) {\n', '      for (uint i = 0; i < _seeders.length; i++) {\n', '        address _seeder = _seeders[i];\n', '        payTo(_seeder, _amount, _hash);\n', '      }\n', '    }\n', '  }\n', '  function payTo(address _to, uint _amount, bytes32 _hash) internal {\n', '    require(store.addBalance(_to, _amount));\n', '    Pay(_to, _amount, _hash);\n', '    ChangeBalance(_to, store.balanceOf(_to));\n', '  }\n', '  function migrateStore(address _to) onlyOwner public {\n', '    store.transferOwnership(_to);\n', '  }\n', '  function setAvailablePaymentTime(uint _availablePaymentTime) onlyOwner public {\n', '    availablePaymentTime = _availablePaymentTime;\n', '  }\n', '  function setSeedersProfitMargin(uint8 _seedersProfitMargin) onlyOwner public {\n', '    seedersProfitMargin = _seedersProfitMargin;\n', '  }\n', '  function setTorrentOwnerPercent(uint8 _torrentOwnerPercent) onlyOwner public {\n', '    torrentOwnerPercent = _torrentOwnerPercent;\n', '  }\n', '  function setMinWithdraw(uint _minWithdraw) onlyOwner public {\n', '    minWithdraw = _minWithdraw;\n', '  }\n', '}']