['pragma solidity ^0.4.24;\n', '\n', '// File: contracts\\interfaces\\ERC20_Interface.sol\n', '\n', '//ERC20 function interface\n', 'interface ERC20_Interface {\n', '  function totalSupply() external constant returns (uint);\n', '  function balanceOf(address _owner) external constant returns (uint);\n', '  function transfer(address _to, uint _amount) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint _amount) external returns (bool);\n', '  function approve(address _spender, uint _amount) external returns (bool);\n', '  function allowance(address _owner, address _spender) external constant returns (uint);\n', '}\n', '\n', '// File: contracts\\libraries\\SafeMath.sol\n', '\n', '//Slightly modified SafeMath library - includes a min function\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function min(uint a, uint b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: contracts\\Exchange.sol\n', '\n', '/**\n', '*Exchange creates an exchange for the swaps.\n', '*/\n', 'contract Exchange{ \n', '    using SafeMath for uint256;\n', '\n', '    /*Variables*/\n', '\n', '    \n', '    /*Structs*/\n', '    //This is the base data structure for an order (the maker of the order and the price)\n', '    struct Order {\n', '        address maker;// the placer of the order\n', '        uint price;// The price in wei\n', '        uint amount;\n', '        address asset;\n', '    }\n', '\n', '    struct ListAsset {\n', '        uint price;\n', '        uint amount;\n', '        bool isLong;  \n', '    }\n', '\n', '    //order_nonce;\n', '    uint internal order_nonce;\n', '    address public owner; //The owner of the market contract\n', '    address[] public openDdaListAssets;\n', '    //Index telling where a specific tokenId is in the forSale array\n', '    address[] public openBooks;\n', '    mapping (address => uint) public openDdaListIndex;\n', '    mapping(address => ListAsset) public listOfAssets;\n', '    //Maps an OrderID to the list of orders\n', '    mapping(uint256 => Order) public orders;\n', "    //An mapping of a token address to the orderID's\n", '    mapping(address =>  uint256[]) public forSale;\n', '    //Index telling where a specific tokenId is in the forSale array\n', '    mapping(uint256 => uint256) internal forSaleIndex;\n', '    \n', '    //mapping of address to position in openBooks\n', '    mapping (address => uint) internal openBookIndex;\n', '    //mapping of user to their orders\n', '    mapping(address => uint[]) public userOrders;\n', '    //mapping from orderId to userOrder position\n', '    mapping(uint => uint) internal userOrderIndex;\n', '    //A list of the blacklisted addresses\n', '    mapping(address => bool) internal blacklist;\n', '    \n', '\n', '    /*Events*/\n', '    event OrderPlaced(address _sender,address _token, uint256 _amount, uint256 _price);\n', '    event Sale(address _sender,address _token, uint256 _amount, uint256 _price);\n', '    event OrderRemoved(address _sender,address _token, uint256 _amount, uint256 _price);\n', '\n', '    /*Modifiers*/\n', '    /**\n', '    *@dev Access modifier for Owner functionality\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /*Functions*/\n', '    /**\n', '    *@dev the constructor argument to set the owner and initialize the array.\n', '    */\n', '    constructor() public{\n', '        owner = msg.sender;\n', '        openBooks.push(address(0));\n', '        order_nonce = 1;\n', '    }\n', '\n', '    /**\n', '    *@dev list allows a party to place an order on the orderbook\n', '    *@param _tokenadd address of the drct tokens\n', '    *@param _amount number of DRCT tokens\n', '    *@param _price uint256 price of all tokens in wei\n', '    */\n', '    function list(address _tokenadd, uint256 _amount, uint256 _price) external {\n', '        require(blacklist[msg.sender] == false);\n', '        require(_price > 0);\n', '        ERC20_Interface token = ERC20_Interface(_tokenadd);\n', '        require(token.allowance(msg.sender,address(this)) >= _amount);\n', '        if(forSale[_tokenadd].length == 0){\n', '            forSale[_tokenadd].push(0);\n', '            }\n', '        forSaleIndex[order_nonce] = forSale[_tokenadd].length;\n', '        forSale[_tokenadd].push(order_nonce);\n', '        orders[order_nonce] = Order({\n', '            maker: msg.sender,\n', '            asset: _tokenadd,\n', '            price: _price,\n', '            amount:_amount\n', '        });\n', '        emit OrderPlaced(msg.sender,_tokenadd,_amount,_price);\n', '        if(openBookIndex[_tokenadd] == 0 ){    \n', '            openBookIndex[_tokenadd] = openBooks.length;\n', '            openBooks.push(_tokenadd);\n', '        }\n', '        userOrderIndex[order_nonce] = userOrders[msg.sender].length;\n', '        userOrders[msg.sender].push(order_nonce);\n', '        order_nonce += 1;\n', '    }\n', '\n', '    /**\n', '    *@dev list allows DDA to list an order \n', '    *@param _asset address \n', '    *@param _amount of asset\n', '    *@param _price uint256 price per unit in wei\n', '    *@param _isLong true if it is long\n', '    */\n', '    //Then you would have a mapping from an asset to its price/ quantity when you list it.\n', '    function listDda(address _asset, uint256 _amount, uint256 _price, bool _isLong) public onlyOwner() {\n', '        require(blacklist[msg.sender] == false);\n', '        ListAsset storage listing = listOfAssets[_asset];\n', '        listing.price = _price;\n', '        listing.amount= _amount;\n', '        listing.isLong= _isLong;\n', '        openDdaListIndex[_asset] = openDdaListAssets.length;\n', '        openDdaListAssets.push(_asset);\n', '        \n', '    }\n', '\n', '    /**\n', '    *@dev list allows a DDA to remove asset \n', '    *@param _asset address \n', '    */\n', '    function unlistDda(address _asset) public onlyOwner() {\n', '        require(blacklist[msg.sender] == false);\n', '        uint256 indexToDelete;\n', '        uint256 lastAcctIndex;\n', '        address lastAdd;\n', '        ListAsset storage listing = listOfAssets[_asset];\n', '        listing.price = 0;\n', '        listing.amount= 0;\n', '        listing.isLong= false;\n', '        indexToDelete = openDdaListIndex[_asset];\n', '        lastAcctIndex = openDdaListAssets.length.sub(1);\n', '        lastAdd = openDdaListAssets[lastAcctIndex];\n', '        openDdaListAssets[indexToDelete]=lastAdd;\n', '        openDdaListIndex[lastAdd]= indexToDelete;\n', '        openDdaListAssets.length--;\n', '        openDdaListIndex[_asset] = 0;\n', '    }\n', '\n', '    /**\n', '    *@dev buy allows a party to partially fill an order\n', '    *@param _asset is the address of the assset listed\n', '    *@param _amount is the amount of tokens to buy\n', '    */\n', '    function buyPerUnit(address _asset, uint256 _amount) external payable {\n', '        require(blacklist[msg.sender] == false);\n', '        ListAsset storage listing = listOfAssets[_asset];\n', '        require(_amount <= listing.amount);\n', '        uint totalPrice = _amount.mul(listing.price);\n', '        require(msg.value == totalPrice);\n', '        ERC20_Interface token = ERC20_Interface(_asset);\n', '        if(token.allowance(owner,address(this)) >= _amount){\n', '            assert(token.transferFrom(owner,msg.sender, _amount));\n', '            owner.transfer(totalPrice);\n', '            listing.amount= listing.amount.sub(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    *@dev unlist allows a party to remove their order from the orderbook\n', '    *@param _orderId is the uint256 ID of order\n', '    */\n', '    function unlist(uint256 _orderId) external{\n', '        require(forSaleIndex[_orderId] > 0);\n', '        Order memory _order = orders[_orderId];\n', '        require(msg.sender== _order.maker || msg.sender == owner);\n', '        unLister(_orderId,_order);\n', '        emit OrderRemoved(msg.sender,_order.asset,_order.amount,_order.price);\n', '    }\n', '\n', '    /**\n', '    *@dev buy allows a party to fill an order\n', '    *@param _orderId is the uint256 ID of order\n', '    */\n', '    function buy(uint256 _orderId) external payable {\n', '        Order memory _order = orders[_orderId];\n', '        require(_order.price != 0 && _order.maker != address(0) && _order.asset != address(0) && _order.amount != 0);\n', '        require(msg.value == _order.price);\n', '        require(blacklist[msg.sender] == false);\n', '        address maker = _order.maker;\n', '        ERC20_Interface token = ERC20_Interface(_order.asset);\n', '        if(token.allowance(_order.maker,address(this)) >= _order.amount){\n', '            assert(token.transferFrom(_order.maker,msg.sender, _order.amount));\n', '            maker.transfer(_order.price);\n', '        }\n', '        unLister(_orderId,_order);\n', '        emit Sale(msg.sender,_order.asset,_order.amount,_order.price);\n', '    }\n', '\n', '    /**\n', '    *@dev getOrder lists the price,amount, and maker of a specific token for a sale\n', '    *@param _orderId uint256 ID of order\n', '    *@return address of the party selling\n', '    *@return uint of the price of the sale (in wei)\n', '    *@return uint of the order amount of the sale\n', '    *@return address of the token\n', '    */\n', '    function getOrder(uint256 _orderId) external view returns(address,uint,uint,address){\n', '        Order storage _order = orders[_orderId];\n', '        return (_order.maker,_order.price,_order.amount,_order.asset);\n', '    }\n', '\n', '    /**\n', '    *@dev allows the owner to change who the owner is\n', '    *@param _owner is the address of the new owner\n', '    */\n', '    function setOwner(address _owner) public onlyOwner() {\n', '        owner = _owner;\n', '    }\n', '\n', '    /**\n', '    *@notice This allows the owner to stop a malicious party from spamming the orderbook\n', '    *@dev Allows the owner to blacklist addresses from using this exchange\n', '    *@param _address the address of the party to blacklist\n', '    *@param _motion true or false depending on if blacklisting or not\n', '    */\n', '    function blacklistParty(address _address, bool _motion) public onlyOwner() {\n', '        blacklist[_address] = _motion;\n', '    }\n', '\n', '    /**\n', '    *@dev Allows parties to see if one is blacklisted\n', '    *@param _address the address of the party to blacklist\n', '    *@return bool true for is blacklisted\n', '    */\n', '    function isBlacklist(address _address) public view returns(bool) {\n', '        return blacklist[_address];\n', '    }\n', '\n', '    /**\n', '    *@dev getOrderCount allows parties to query how many orders are on the book\n', '    *@param _token address used to count the number of orders\n', '    *@return _uint of the number of orders in the orderbook\n', '    */\n', '    function getOrderCount(address _token) public constant returns(uint) {\n', '        return forSale[_token].length;\n', '    }\n', '\n', '    /**\n', '    *@dev Gets number of open orderbooks\n', '    *@return _uint of the number of tokens with open orders\n', '    */\n', '    function getBookCount() public constant returns(uint) {\n', '        return openBooks.length;\n', '    }\n', '\n', '    /**\n', "    *@dev getOrders allows parties to get an array of all orderId's open for a given token\n", '    *@param _token address of the drct token\n', '    *@return _uint[] an array of the orders in the orderbook\n', '    */\n', '    function getOrders(address _token) public constant returns(uint[]) {\n', '        return forSale[_token];\n', '    }\n', '\n', '    /**\n', "    *@dev getUserOrders allows parties to get an array of all orderId's open for a given user\n", '    *@param _user address \n', '    *@return _uint[] an array of the orders in the orderbook for the user\n', '    */\n', '    function getUserOrders(address _user) public constant returns(uint[]) {\n', '        return userOrders[_user];\n', '    }\n', '\n', '    /**\n', '    *@dev getter function to get all openDdaListAssets\n', '    */\n', '    function getopenDdaListAssets() view public returns (address[]){\n', '        return openDdaListAssets;\n', '    }\n', '    /**\n', '    *@dev Gets the DDA List Asset information for the specifed \n', '    *asset address\n', '    *@param _assetAddress for DDA list\n', '    *@return price, amount and true if isLong\n', '    */\n', '    function getDdaListAssetInfo(address _assetAddress) public view returns(uint, uint, bool){\n', '        return(listOfAssets[_assetAddress].price,listOfAssets[_assetAddress].amount,listOfAssets[_assetAddress].isLong);\n', '    }\n', '    /**\n', '    *@dev An internal function to update mappings when an order is removed from the book\n', '    *@param _orderId is the uint256 ID of order\n', '    *@param _order is the struct containing the details of the order\n', '    */\n', '    function unLister(uint256 _orderId, Order _order) internal{\n', '            uint256 tokenIndex;\n', '            uint256 lastTokenIndex;\n', '            address lastAdd;\n', '            uint256  lastToken;\n', '        if(forSale[_order.asset].length == 2){\n', '            tokenIndex = openBookIndex[_order.asset];\n', '            lastTokenIndex = openBooks.length.sub(1);\n', '            lastAdd = openBooks[lastTokenIndex];\n', '            openBooks[tokenIndex] = lastAdd;\n', '            openBookIndex[lastAdd] = tokenIndex;\n', '            openBooks.length--;\n', '            openBookIndex[_order.asset] = 0;\n', '            forSale[_order.asset].length -= 2;\n', '        }\n', '        else{\n', '            tokenIndex = forSaleIndex[_orderId];\n', '            lastTokenIndex = forSale[_order.asset].length.sub(1);\n', '            lastToken = forSale[_order.asset][lastTokenIndex];\n', '            forSale[_order.asset][tokenIndex] = lastToken;\n', '            forSaleIndex[lastToken] = tokenIndex;\n', '            forSale[_order.asset].length--;\n', '        }\n', '        forSaleIndex[_orderId] = 0;\n', '        orders[_orderId] = Order({\n', '            maker: address(0),\n', '            price: 0,\n', '            amount:0,\n', '            asset: address(0)\n', '        });\n', '        if(userOrders[_order.maker].length > 1){\n', '            tokenIndex = userOrderIndex[_orderId];\n', '            lastTokenIndex = userOrders[_order.maker].length.sub(1);\n', '            lastToken = userOrders[_order.maker][lastTokenIndex];\n', '            userOrders[_order.maker][tokenIndex] = lastToken;\n', '            userOrderIndex[lastToken] = tokenIndex;\n', '        }\n', '        userOrders[_order.maker].length--;\n', '        userOrderIndex[_orderId] = 0;\n', '    }\n', '}']