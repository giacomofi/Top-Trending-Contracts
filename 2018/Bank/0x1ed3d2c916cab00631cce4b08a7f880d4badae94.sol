['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '  }\n', '\n', '  function square(uint256 a) internal pure returns (uint256) {\n', '    return mul(a, a);\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _owner) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  function allowance( address _owner, address _spender) public view returns (uint256);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHStock\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHStock is ERC20Interface {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /* EVENT */\n', '\n', '  event RedeemShares(\n', '    address indexed user,\n', '    uint256 shares,\n', '    uint256 dividends\n', '  );\n', '\n', '  /* STORAGE */\n', '\n', '  string public name = "ChickenHuntStock";\n', '  string public symbol = "CHS";\n', '  uint8 public decimals = 18;\n', '  uint256 public totalShares;\n', '  uint256 public dividendsPerShare;\n', '  uint256 public constant CORRECTION = 1 << 64;\n', '  mapping (address => uint256) public ethereumBalance;\n', '  mapping (address => uint256) internal shares;\n', '  mapping (address => uint256) internal refund;\n', '  mapping (address => uint256) internal deduction;\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /* FUNCTION */\n', '\n', '  function redeemShares() public {\n', '    uint256 _shares = shares[msg.sender];\n', '    uint256 _dividends = dividendsOf(msg.sender);\n', '\n', '    delete shares[msg.sender];\n', '    delete refund[msg.sender];\n', '    delete deduction[msg.sender];\n', '    totalShares = totalShares.sub(_shares);\n', '    ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends);\n', '\n', '    emit RedeemShares(msg.sender, _shares, _dividends);\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    _transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    allowed[_from][msg.sender] -= _value;\n', '    _transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function dividendsOf(address _shareholder) public view returns (uint256) {\n', '    return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalShares;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return shares[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _giveShares(address _user, uint256 _ethereum) internal {\n', '    if (_ethereum > 0) {\n', '      totalShares = totalShares.add(_ethereum);\n', '      deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum));\n', '      shares[_user] = shares[_user].add(_ethereum);\n', '      dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares);\n', '\n', '      emit Transfer(address(0), _user, _ethereum);\n', '    }\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _value) internal {\n', '    require(_to != address(0));\n', '    require(_value <= shares[_from]);\n', '    uint256 _rawProfit = dividendsPerShare.mul(_value);\n', '\n', '    uint256 _refund = refund[_from].add(_rawProfit);\n', '    uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from];\n', '    refund[_from] = _refund.sub(_min);\n', '    deduction[_from] = deduction[_from].sub(_min);\n', '    deduction[_to] = deduction[_to].add(_rawProfit);\n', '\n', '    shares[_from] = shares[_from].sub(_value);\n', '    shares[_to] = shares[_to].add(_value);\n', '\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHGameBase\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHGameBase is CHStock {\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct House {\n', '    Hunter hunter;\n', '    uint256 huntingPower;\n', '    uint256 offensePower;\n', '    uint256 defensePower;\n', '    uint256 huntingMultiplier;\n', '    uint256 offenseMultiplier;\n', '    uint256 defenseMultiplier;\n', '    uint256 depots;\n', '    uint256[] pets;\n', '  }\n', '\n', '  struct Hunter {\n', '    uint256 strength;\n', '    uint256 dexterity;\n', '    uint256 constitution;\n', '    uint256 resistance;\n', '  }\n', '\n', '  struct Store {\n', '    address owner;\n', '    uint256 cut;\n', '    uint256 cost;\n', '    uint256 balance;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  Store public store;\n', '  uint256 public devCut;\n', '  uint256 public devFee;\n', '  uint256 public altarCut;\n', '  uint256 public altarFund;\n', '  uint256 public dividendRate;\n', '  uint256 public totalChicken;\n', '  address public chickenTokenDelegator;\n', '  mapping (address => uint256) public lastSaveTime;\n', '  mapping (address => uint256) public savedChickenOf;\n', '  mapping (address => House) internal houses;\n', '\n', '  /* FUNCTION */\n', '\n', '  function saveChickenOf(address _user) public returns (uint256) {\n', '    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n', '    totalChicken = totalChicken.add(_unclaimedChicken);\n', '    uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken);\n', '    savedChickenOf[_user] = _chicken;\n', '    lastSaveTime[_user] = block.timestamp;\n', '    return _chicken;\n', '  }\n', '\n', '  function transferChickenFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(msg.sender == chickenTokenDelegator);\n', '    require(saveChickenOf(_from) >= _value);\n', '    savedChickenOf[_from] = savedChickenOf[_from] - _value;\n', '    savedChickenOf[_to] = savedChickenOf[_to].add(_value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function chickenOf(address _user) public view returns (uint256) {\n', '    return savedChickenOf[_user].add(_unclaimedChickenOf(_user));\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _payChicken(address _user, uint256 _chicken) internal {\n', '    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n', '    uint256 _extraChicken;\n', '\n', '    if (_chicken > _unclaimedChicken) {\n', '      _extraChicken = _chicken - _unclaimedChicken;\n', '      require(savedChickenOf[_user] >= _extraChicken);\n', '      savedChickenOf[_user] -= _extraChicken;\n', '      totalChicken -= _extraChicken;\n', '    } else {\n', '      _extraChicken = _unclaimedChicken - _chicken;\n', '      totalChicken = totalChicken.add(_extraChicken);\n', '      savedChickenOf[_user] += _extraChicken;\n', '    }\n', '\n', '    lastSaveTime[_user] = block.timestamp;\n', '  }\n', '\n', '  function _payEthereumAndDistribute(uint256 _cost) internal {\n', '    require(_cost * 100 / 100 == _cost);\n', '    _payEthereum(_cost);\n', '\n', '    uint256 _toShareholders = _cost * dividendRate / 100;\n', '    uint256 _toAltar = _cost * altarCut / 100;\n', '    uint256 _toStore = _cost * store.cut / 100;\n', '    devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore);\n', '\n', '    _giveShares(msg.sender, _toShareholders);\n', '    altarFund = altarFund.add(_toAltar);\n', '    store.balance = store.balance.add(_toStore);\n', '  }\n', '\n', '  function _payEthereum(uint256 _cost) internal {\n', '    uint256 _extra;\n', '    if (_cost > msg.value) {\n', '      _extra = _cost - msg.value;\n', '      require(ethereumBalance[msg.sender] >= _extra);\n', '      ethereumBalance[msg.sender] -= _extra;\n', '    } else {\n', '      _extra = msg.value - _cost;\n', '      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra);\n', '    }\n', '  }\n', '\n', '  function _unclaimedChickenOf(address _user) internal view returns (uint256) {\n', '    uint256 _timestamp = lastSaveTime[_user];\n', '    if (_timestamp > 0 && _timestamp < block.timestamp) {\n', '      return houses[_user].huntingPower.mul(\n', '        houses[_user].huntingMultiplier\n', '      ).mul(block.timestamp - _timestamp) / 100;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function _houseOf(address _user)\n', '    internal\n', '    view\n', '    returns (House storage _house)\n', '  {\n', '    _house = houses[_user];\n', '    require(_house.depots > 0);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHHunter\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHHunter is CHGameBase {\n', '\n', '  /* EVENT */\n', '\n', '  event UpgradeHunter(\n', '    address indexed user,\n', '    string attribute,\n', '    uint256 to\n', '  );\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Config {\n', '    uint256 chicken;\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  Config public typeA;\n', '  Config public typeB;\n', '\n', '  /* FUNCTION */\n', '\n', '  function upgradeStrength(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.strength;\n', '    require(typeA.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeA);\n', '\n', '    uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2);\n', '    _house.hunter.strength = _to;\n', '    _house.huntingPower = _house.huntingPower.add(_increment);\n', '    _house.offensePower = _house.offensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "strength", _to);\n', '  }\n', '\n', '  function upgradeDexterity(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.dexterity;\n', '    require(typeB.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeB);\n', '\n', '    uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2));\n', '    _house.hunter.dexterity = _to;\n', '    _house.huntingPower = _house.huntingPower.add(_increment);\n', '    _house.offensePower = _house.offensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "dexterity", _to);\n', '  }\n', '\n', '  function upgradeConstitution(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.constitution;\n', '    require(typeA.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeA);\n', '\n', '    uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2);\n', '    _house.hunter.constitution = _to;\n', '    _house.defensePower = _house.defensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "constitution", _to);\n', '  }\n', '\n', '  function upgradeResistance(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.resistance;\n', '    require(typeB.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeB);\n', '\n', '    uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2));\n', '    _house.hunter.resistance = _to;\n', '    _house.defensePower = _house.defensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "resistance", _to);\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal {\n', '    uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to));\n', '    _payChicken(msg.sender, _chickenCost);\n', '    uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to));\n', '    _payEthereumAndDistribute(_ethereumCost);\n', '  }\n', '\n', '  function _gapOfSquareSum(uint256 _before, uint256 _after)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // max value is capped to uint32\n', '    return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6;\n', '  }\n', '\n', '  function _gapOfCubeSum(uint256 _before, uint256 _after)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // max value is capped to uint32\n', '    return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHHouse\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHHouse is CHHunter {\n', '\n', '  /* EVENT */\n', '\n', '  event UpgradePet(\n', '    address indexed user,\n', '    uint256 id,\n', '    uint256 to\n', '  );\n', '\n', '  event UpgradeDepot(\n', '    address indexed user,\n', '    uint256 to\n', '  );\n', '\n', '  event BuyItem(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed id,\n', '    uint256 cost\n', '  );\n', '\n', '  event BuyStore(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 cost\n', '  );\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Pet {\n', '    uint256 huntingPower;\n', '    uint256 offensePower;\n', '    uint256 defensePower;\n', '    uint256 chicken;\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  struct Item {\n', '    address owner;\n', '    uint256 huntingMultiplier;\n', '    uint256 offenseMultiplier;\n', '    uint256 defenseMultiplier;\n', '    uint256 cost;\n', '  }\n', '\n', '  struct Depot {\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  uint256 public constant INCREMENT_RATE = 12; // 120% for Item and Store\n', '  Depot public depot;\n', '  Pet[] public pets;\n', '  Item[] public items;\n', '\n', '  /* FUNCTION */\n', '\n', '  function buyDepots(uint256 _amount) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    _house.depots = _house.depots.add(_amount);\n', '    require(_house.depots <= depot.max);\n', '    _payEthereumAndDistribute(_amount.mul(depot.ethereum));\n', '\n', '    emit UpgradeDepot(msg.sender, _house.depots);\n', '  }\n', '\n', '  function buyPets(uint256 _id, uint256 _amount) external payable {\n', '    require(_id < pets.length);\n', '    Pet memory _pet = pets[_id];\n', '    uint256 _chickenCost = _amount * _pet.chicken;\n', '    _payChicken(msg.sender, _chickenCost);\n', '    uint256 _ethereumCost = _amount * _pet.ethereum;\n', '    _payEthereumAndDistribute(_ethereumCost);\n', '\n', '    House storage _house = _houseOf(msg.sender);\n', '    if (_house.pets.length < _id + 1) {\n', '      _house.pets.length = _id + 1;\n', '    }\n', '    _house.pets[_id] = _house.pets[_id].add(_amount);\n', '    require(_house.pets[_id] <= _pet.max);\n', '\n', '    _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount);\n', '    _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount);\n', '    _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount);\n', '\n', '    emit UpgradePet(msg.sender, _id, _house.pets[_id]);\n', '  }\n', '\n', '  // This is independent of Stock and Altar.\n', '  function buyItem(uint256 _id) external payable {\n', '    Item storage _item = items[_id];\n', '    address _from = _item.owner;\n', '    uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10;\n', '    _payEthereum(_price);\n', '\n', '    saveChickenOf(_from);\n', '    House storage _fromHouse = _houseOf(_from);\n', '    _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier);\n', '    _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier);\n', '    _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier);\n', '\n', '    saveChickenOf(msg.sender);\n', '    House storage _toHouse = _houseOf(msg.sender);\n', '    _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier);\n', '    _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier);\n', '    _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier);\n', '\n', '    uint256 _halfMargin = _price.sub(_item.cost) / 2;\n', '    devFee = devFee.add(_halfMargin);\n', '    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin);\n', '\n', '    items[_id].cost = _price;\n', '    items[_id].owner = msg.sender;\n', '\n', '    emit BuyItem(_from, msg.sender, _id, _price);\n', '  }\n', '\n', '  // This is independent of Stock and Altar.\n', '  function buyStore() external payable {\n', '    address _from = store.owner;\n', '    uint256 _price = store.cost.mul(INCREMENT_RATE) / 10;\n', '    _payEthereum(_price);\n', '\n', '    uint256 _halfMargin = (_price - store.cost) / 2;\n', '    devFee = devFee.add(_halfMargin);\n', '    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance);\n', '\n', '    store.cost = _price;\n', '    store.owner = msg.sender;\n', '    delete store.balance;\n', '\n', '    emit BuyStore(_from, msg.sender, _price);\n', '  }\n', '\n', '  function withdrawStoreBalance() public {\n', '    ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance);\n', '    delete store.balance;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHArena\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHArena is CHHouse {\n', '\n', '  /* EVENT */\n', '\n', '  event Attack(\n', '    address indexed attacker,\n', '    address indexed defender,\n', '    uint256 booty\n', '  );\n', '\n', '  /* STORAGE */\n', '\n', '  mapping(address => uint256) public attackCooldown;\n', '  uint256 public cooldownTime;\n', '\n', '  /* FUNCTION */\n', '\n', '  function attack(address _target) external {\n', '    require(attackCooldown[msg.sender] < block.timestamp);\n', '    House storage _attacker = houses[msg.sender];\n', '    House storage _defender = houses[_target];\n', '    if (_attacker.offensePower.mul(_attacker.offenseMultiplier)\n', '        > _defender.defensePower.mul(_defender.defenseMultiplier)) {\n', '      uint256 _chicken = saveChickenOf(_target);\n', '      _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken;\n', '      savedChickenOf[_target] = savedChickenOf[_target] - _chicken;\n', '      savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken);\n', '      attackCooldown[msg.sender] = block.timestamp + cooldownTime;\n', '\n', '      emit Attack(msg.sender, _target, _chicken);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHAltar\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHAltar is CHArena {\n', '\n', '  /* EVENT */\n', '\n', '  event NewAltarRecord(uint256 id, uint256 ethereum);\n', '  event ChickenToAltar(address indexed user, uint256 id, uint256 chicken);\n', '  event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum);\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct AltarRecord {\n', '    uint256 ethereum;\n', '    uint256 chicken;\n', '  }\n', '\n', '  struct TradeBook {\n', '    uint256 altarRecordId;\n', '    uint256 chicken;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  uint256 public genesis;\n', '  mapping (uint256 => AltarRecord) public altarRecords;\n', '  mapping (address => TradeBook) public tradeBooks;\n', '\n', '  /* FUNCTION */\n', '\n', '  function chickenToAltar(uint256 _chicken) external {\n', '    require(_chicken > 0);\n', '\n', '    _payChicken(msg.sender, _chicken);\n', '    uint256 _id = _getCurrentAltarRecordId();\n', '    AltarRecord storage _altarRecord = _getAltarRecord(_id);\n', '    require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum);\n', '    TradeBook storage _tradeBook = tradeBooks[msg.sender];\n', '    if (_tradeBook.altarRecordId < _id) {\n', '      _resolveTradeBook(_tradeBook);\n', '      _tradeBook.altarRecordId = _id;\n', '    }\n', '    _altarRecord.chicken = _altarRecord.chicken.add(_chicken);\n', '    _tradeBook.chicken += _chicken;\n', '\n', '    emit ChickenToAltar(msg.sender, _id, _chicken);\n', '  }\n', '\n', '  function ethereumFromAltar() external {\n', '    uint256 _id = _getCurrentAltarRecordId();\n', '    TradeBook storage _tradeBook = tradeBooks[msg.sender];\n', '    require(_tradeBook.altarRecordId < _id);\n', '    _resolveTradeBook(_tradeBook);\n', '  }\n', '\n', '  function tradeBookOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256 _id,\n', '      uint256 _ethereum,\n', '      uint256 _totalChicken,\n', '      uint256 _chicken,\n', '      uint256 _income\n', '    )\n', '  {\n', '    TradeBook memory _tradeBook = tradeBooks[_user];\n', '    _id = _tradeBook.altarRecordId;\n', '    _chicken = _tradeBook.chicken;\n', '    AltarRecord memory _altarRecord = altarRecords[_id];\n', '    _totalChicken = _altarRecord.chicken;\n', '    _ethereum = _altarRecord.ethereum;\n', '    _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0;\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _resolveTradeBook(TradeBook storage _tradeBook) internal {\n', '    if (_tradeBook.chicken > 0) {\n', '      AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId];\n', '      uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken;\n', '      delete _tradeBook.chicken;\n', '      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum);\n', '\n', '      emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum);\n', '    }\n', '  }\n', '\n', '  function _getCurrentAltarRecordId() internal view returns (uint256) {\n', '    return (block.timestamp - genesis) / 86400;\n', '  }\n', '\n', '  function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) {\n', '    _altarRecord = altarRecords[_id];\n', '    if (_altarRecord.ethereum == 0) {\n', '      uint256 _ethereum = altarFund / 10;\n', '      _altarRecord.ethereum = _ethereum;\n', '      altarFund -= _ethereum;\n', '\n', '      emit NewAltarRecord(_id, _ethereum);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHCommittee\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHCommittee is CHAltar {\n', '\n', '  /* EVENT */\n', '\n', '  event NewPet(\n', '    uint256 id,\n', '    uint256 huntingPower,\n', '    uint256 offensePower,\n', '    uint256 defense,\n', '    uint256 chicken,\n', '    uint256 ethereum,\n', '    uint256 max\n', '  );\n', '\n', '  event ChangePet(\n', '    uint256 id,\n', '    uint256 chicken,\n', '    uint256 ethereum,\n', '    uint256 max\n', '  );\n', '\n', '  event NewItem(\n', '    uint256 id,\n', '    uint256 huntingMultiplier,\n', '    uint256 offenseMultiplier,\n', '    uint256 defenseMultiplier,\n', '    uint256 ethereum\n', '  );\n', '\n', '  event SetDepot(uint256 ethereum, uint256 max);\n', '\n', '  event SetConfiguration(\n', '    uint256 chickenA,\n', '    uint256 ethereumA,\n', '    uint256 maxA,\n', '    uint256 chickenB,\n', '    uint256 ethereumB,\n', '    uint256 maxB\n', '  );\n', '\n', '  event SetDistribution(\n', '    uint256 dividendRate,\n', '    uint256 altarCut,\n', '    uint256 storeCut,\n', '    uint256 devCut\n', '  );\n', '\n', '  event SetCooldownTime(uint256 cooldownTime);\n', '  event SetNameAndSymbol(string name, string symbol);\n', '  event SetDeveloper(address developer);\n', '  event SetCommittee(address committee);\n', '\n', '  /* STORAGE */\n', '\n', '  address public committee;\n', '  address public developer;\n', '\n', '  /* FUNCTION */\n', '\n', '  function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n', '    external\n', '    payable\n', '    onlyCommittee\n', '    returns (bool)\n', '  {\n', '    return _to.call.value(_value).gas(_gas)(_code);\n', '  }\n', '\n', '  function addPet(\n', '    uint256 _huntingPower,\n', '    uint256 _offensePower,\n', '    uint256 _defense,\n', '    uint256 _chicken,\n', '    uint256 _ethereum,\n', '    uint256 _max\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_max > 0);\n', '    require(_max == uint256(uint32(_max)));\n', '    uint256 _newLength = pets.push(\n', '      Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max)\n', '    );\n', '\n', '    emit NewPet(\n', '      _newLength - 1,\n', '      _huntingPower,\n', '      _offensePower,\n', '      _defense,\n', '      _chicken,\n', '      _ethereum,\n', '      _max\n', '    );\n', '  }\n', '\n', '  function changePet(\n', '    uint256 _id,\n', '    uint256 _chicken,\n', '    uint256 _ethereum,\n', '    uint256 _max\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_id < pets.length);\n', '    Pet storage _pet = pets[_id];\n', '    require(_max >= _pet.max && _max == uint256(uint32(_max)));\n', '\n', '    _pet.chicken = _chicken;\n', '    _pet.ethereum = _ethereum;\n', '    _pet.max = _max;\n', '\n', '    emit ChangePet(_id, _chicken, _ethereum, _max);\n', '  }\n', '\n', '  function addItem(\n', '    uint256 _huntingMultiplier,\n', '    uint256 _offenseMultiplier,\n', '    uint256 _defenseMultiplier,\n', '    uint256 _price\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    uint256 _cap = 1 << 16;\n', '    require(\n', '      _huntingMultiplier < _cap &&\n', '      _offenseMultiplier < _cap &&\n', '      _defenseMultiplier < _cap\n', '    );\n', '    saveChickenOf(committee);\n', '    House storage _house = _houseOf(committee);\n', '    _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier);\n', '    _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier);\n', '    _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier);\n', '\n', '    uint256 _newLength = items.push(\n', '      Item(\n', '        committee,\n', '        _huntingMultiplier,\n', '        _offenseMultiplier,\n', '        _defenseMultiplier,\n', '        _price\n', '      )\n', '    );\n', '\n', '    emit NewItem(\n', '      _newLength - 1,\n', '      _huntingMultiplier,\n', '      _offenseMultiplier,\n', '      _defenseMultiplier,\n', '      _price\n', '    );\n', '  }\n', '\n', '  function setDepot(uint256 _price, uint256 _max) public onlyCommittee {\n', '    require(_max >= depot.max);\n', '\n', '    depot.ethereum = _price;\n', '    depot.max = _max;\n', '\n', '    emit SetDepot(_price, _max);\n', '  }\n', '\n', '  function setConfiguration(\n', '    uint256 _chickenA,\n', '    uint256 _ethereumA,\n', '    uint256 _maxA,\n', '    uint256 _chickenB,\n', '    uint256 _ethereumB,\n', '    uint256 _maxB\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA))));\n', '    require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB))));\n', '\n', '    typeA.chicken = _chickenA;\n', '    typeA.ethereum = _ethereumA;\n', '    typeA.max = _maxA;\n', '\n', '    typeB.chicken = _chickenB;\n', '    typeB.ethereum = _ethereumB;\n', '    typeB.max = _maxB;\n', '\n', '    emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB);\n', '  }\n', '\n', '  function setDistribution(\n', '    uint256 _dividendRate,\n', '    uint256 _altarCut,\n', '    uint256 _storeCut,\n', '    uint256 _devCut\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_storeCut > 0);\n', '    require(\n', '      _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100\n', '    );\n', '\n', '    dividendRate = _dividendRate;\n', '    altarCut = _altarCut;\n', '    store.cut = _storeCut;\n', '    devCut = _devCut;\n', '\n', '    emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut);\n', '  }\n', '\n', '  function setCooldownTime(uint256 _cooldownTime) public onlyCommittee {\n', '    cooldownTime = _cooldownTime;\n', '\n', '    emit SetCooldownTime(_cooldownTime);\n', '  }\n', '\n', '  function setNameAndSymbol(string _name, string _symbol)\n', '    public\n', '    onlyCommittee\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    emit SetNameAndSymbol(_name, _symbol);\n', '  }\n', '\n', '  function setDeveloper(address _developer) public onlyCommittee {\n', '    require(_developer != address(0));\n', '    withdrawDevFee();\n', '    developer = _developer;\n', '\n', '    emit SetDeveloper(_developer);\n', '  }\n', '\n', '  function setCommittee(address _committee) public onlyCommittee {\n', '    require(_committee != address(0));\n', '    committee = _committee;\n', '\n', '    emit SetCommittee(_committee);\n', '  }\n', '\n', '  function withdrawDevFee() public {\n', '    ethereumBalance[developer] = ethereumBalance[developer].add(devFee);\n', '    delete devFee;\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyCommittee {\n', '    require(msg.sender == committee);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ChickenHunt\n', ' * @author M.H. Kang\n', ' */\n', 'contract ChickenHunt is CHCommittee {\n', '\n', '  /* EVENT */\n', '\n', '  event Join(address user);\n', '\n', '  /* CONSTRUCTOR */\n', '\n', '  constructor() public {\n', '    committee = msg.sender;\n', '    developer = msg.sender;\n', '  }\n', '\n', '  /* FUNCTION */\n', '\n', '  function init(address _chickenTokenDelegator) external onlyCommittee {\n', '    require(chickenTokenDelegator == address(0));\n', '    chickenTokenDelegator = _chickenTokenDelegator;\n', '    genesis = 1525791600;\n', '    join();\n', '    store.owner = msg.sender;\n', '    store.cost = 0.1 ether;\n', '    setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9);\n', '    setDistribution(20, 75, 1, 4);\n', '    setCooldownTime(600);\n', '    setDepot(0.05 ether, 9);\n', '    addItem(5, 5, 0, 0.01 ether);\n', '    addItem(0, 0, 5, 0.01 ether);\n', '    addPet(1000, 0, 0, 100000, 0.01 ether, 9);\n', '    addPet(0, 1000, 0, 100000, 0.01 ether, 9);\n', '    addPet(0, 0, 1000, 202500, 0.01 ether, 9);\n', '  }\n', '\n', '  function withdraw() external {\n', '    uint256 _ethereum = ethereumBalance[msg.sender];\n', '    delete ethereumBalance[msg.sender];\n', '    msg.sender.transfer(_ethereum);\n', '  }\n', '\n', '  function join() public {\n', '    House storage _house = houses[msg.sender];\n', '    require(_house.depots == 0);\n', '    _house.hunter = Hunter(1, 1, 1, 1);\n', '    _house.depots = 1;\n', '    _house.huntingPower = 10;\n', '    _house.offensePower = 10;\n', '    _house.defensePower = 110;\n', '    _house.huntingMultiplier = 10;\n', '    _house.offenseMultiplier = 10;\n', '    _house.defenseMultiplier = 10;\n', '    lastSaveTime[msg.sender] = block.timestamp;\n', '\n', '    emit Join(msg.sender);\n', '  }\n', '\n', '  function hunterOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256 _strength,\n', '      uint256 _dexterity,\n', '      uint256 _constitution,\n', '      uint256 _resistance\n', '    )\n', '  {\n', '    Hunter memory _hunter = houses[_user].hunter;\n', '    return (\n', '      _hunter.strength,\n', '      _hunter.dexterity,\n', '      _hunter.constitution,\n', '      _hunter.resistance\n', '    );\n', '  }\n', '\n', '  function detailsOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256[2] _hunting,\n', '      uint256[2] _offense,\n', '      uint256[2] _defense,\n', '      uint256[4] _hunter,\n', '      uint256[] _pets,\n', '      uint256 _depots,\n', '      uint256 _savedChicken,\n', '      uint256 _lastSaveTime,\n', '      uint256 _cooldown\n', '    )\n', '  {\n', '    House memory _house = houses[_user];\n', '\n', '    _hunting = [_house.huntingPower, _house.huntingMultiplier];\n', '    _offense = [_house.offensePower, _house.offenseMultiplier];\n', '    _defense = [_house.defensePower, _house.defenseMultiplier];\n', '    _hunter = [\n', '      _house.hunter.strength,\n', '      _house.hunter.dexterity,\n', '      _house.hunter.constitution,\n', '      _house.hunter.resistance\n', '    ];\n', '    _pets = _house.pets;\n', '    _depots = _house.depots;\n', '    _savedChicken = savedChickenOf[_user];\n', '    _lastSaveTime = lastSaveTime[_user];\n', '    _cooldown = attackCooldown[_user];\n', '  }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '  }\n', '\n', '  function square(uint256 a) internal pure returns (uint256) {\n', '    return mul(a, a);\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _owner) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  function allowance( address _owner, address _spender) public view returns (uint256);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHStock\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHStock is ERC20Interface {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /* EVENT */\n', '\n', '  event RedeemShares(\n', '    address indexed user,\n', '    uint256 shares,\n', '    uint256 dividends\n', '  );\n', '\n', '  /* STORAGE */\n', '\n', '  string public name = "ChickenHuntStock";\n', '  string public symbol = "CHS";\n', '  uint8 public decimals = 18;\n', '  uint256 public totalShares;\n', '  uint256 public dividendsPerShare;\n', '  uint256 public constant CORRECTION = 1 << 64;\n', '  mapping (address => uint256) public ethereumBalance;\n', '  mapping (address => uint256) internal shares;\n', '  mapping (address => uint256) internal refund;\n', '  mapping (address => uint256) internal deduction;\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /* FUNCTION */\n', '\n', '  function redeemShares() public {\n', '    uint256 _shares = shares[msg.sender];\n', '    uint256 _dividends = dividendsOf(msg.sender);\n', '\n', '    delete shares[msg.sender];\n', '    delete refund[msg.sender];\n', '    delete deduction[msg.sender];\n', '    totalShares = totalShares.sub(_shares);\n', '    ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends);\n', '\n', '    emit RedeemShares(msg.sender, _shares, _dividends);\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    _transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    allowed[_from][msg.sender] -= _value;\n', '    _transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function dividendsOf(address _shareholder) public view returns (uint256) {\n', '    return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalShares;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return shares[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _giveShares(address _user, uint256 _ethereum) internal {\n', '    if (_ethereum > 0) {\n', '      totalShares = totalShares.add(_ethereum);\n', '      deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum));\n', '      shares[_user] = shares[_user].add(_ethereum);\n', '      dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares);\n', '\n', '      emit Transfer(address(0), _user, _ethereum);\n', '    }\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _value) internal {\n', '    require(_to != address(0));\n', '    require(_value <= shares[_from]);\n', '    uint256 _rawProfit = dividendsPerShare.mul(_value);\n', '\n', '    uint256 _refund = refund[_from].add(_rawProfit);\n', '    uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from];\n', '    refund[_from] = _refund.sub(_min);\n', '    deduction[_from] = deduction[_from].sub(_min);\n', '    deduction[_to] = deduction[_to].add(_rawProfit);\n', '\n', '    shares[_from] = shares[_from].sub(_value);\n', '    shares[_to] = shares[_to].add(_value);\n', '\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHGameBase\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHGameBase is CHStock {\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct House {\n', '    Hunter hunter;\n', '    uint256 huntingPower;\n', '    uint256 offensePower;\n', '    uint256 defensePower;\n', '    uint256 huntingMultiplier;\n', '    uint256 offenseMultiplier;\n', '    uint256 defenseMultiplier;\n', '    uint256 depots;\n', '    uint256[] pets;\n', '  }\n', '\n', '  struct Hunter {\n', '    uint256 strength;\n', '    uint256 dexterity;\n', '    uint256 constitution;\n', '    uint256 resistance;\n', '  }\n', '\n', '  struct Store {\n', '    address owner;\n', '    uint256 cut;\n', '    uint256 cost;\n', '    uint256 balance;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  Store public store;\n', '  uint256 public devCut;\n', '  uint256 public devFee;\n', '  uint256 public altarCut;\n', '  uint256 public altarFund;\n', '  uint256 public dividendRate;\n', '  uint256 public totalChicken;\n', '  address public chickenTokenDelegator;\n', '  mapping (address => uint256) public lastSaveTime;\n', '  mapping (address => uint256) public savedChickenOf;\n', '  mapping (address => House) internal houses;\n', '\n', '  /* FUNCTION */\n', '\n', '  function saveChickenOf(address _user) public returns (uint256) {\n', '    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n', '    totalChicken = totalChicken.add(_unclaimedChicken);\n', '    uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken);\n', '    savedChickenOf[_user] = _chicken;\n', '    lastSaveTime[_user] = block.timestamp;\n', '    return _chicken;\n', '  }\n', '\n', '  function transferChickenFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(msg.sender == chickenTokenDelegator);\n', '    require(saveChickenOf(_from) >= _value);\n', '    savedChickenOf[_from] = savedChickenOf[_from] - _value;\n', '    savedChickenOf[_to] = savedChickenOf[_to].add(_value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function chickenOf(address _user) public view returns (uint256) {\n', '    return savedChickenOf[_user].add(_unclaimedChickenOf(_user));\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _payChicken(address _user, uint256 _chicken) internal {\n', '    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n', '    uint256 _extraChicken;\n', '\n', '    if (_chicken > _unclaimedChicken) {\n', '      _extraChicken = _chicken - _unclaimedChicken;\n', '      require(savedChickenOf[_user] >= _extraChicken);\n', '      savedChickenOf[_user] -= _extraChicken;\n', '      totalChicken -= _extraChicken;\n', '    } else {\n', '      _extraChicken = _unclaimedChicken - _chicken;\n', '      totalChicken = totalChicken.add(_extraChicken);\n', '      savedChickenOf[_user] += _extraChicken;\n', '    }\n', '\n', '    lastSaveTime[_user] = block.timestamp;\n', '  }\n', '\n', '  function _payEthereumAndDistribute(uint256 _cost) internal {\n', '    require(_cost * 100 / 100 == _cost);\n', '    _payEthereum(_cost);\n', '\n', '    uint256 _toShareholders = _cost * dividendRate / 100;\n', '    uint256 _toAltar = _cost * altarCut / 100;\n', '    uint256 _toStore = _cost * store.cut / 100;\n', '    devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore);\n', '\n', '    _giveShares(msg.sender, _toShareholders);\n', '    altarFund = altarFund.add(_toAltar);\n', '    store.balance = store.balance.add(_toStore);\n', '  }\n', '\n', '  function _payEthereum(uint256 _cost) internal {\n', '    uint256 _extra;\n', '    if (_cost > msg.value) {\n', '      _extra = _cost - msg.value;\n', '      require(ethereumBalance[msg.sender] >= _extra);\n', '      ethereumBalance[msg.sender] -= _extra;\n', '    } else {\n', '      _extra = msg.value - _cost;\n', '      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra);\n', '    }\n', '  }\n', '\n', '  function _unclaimedChickenOf(address _user) internal view returns (uint256) {\n', '    uint256 _timestamp = lastSaveTime[_user];\n', '    if (_timestamp > 0 && _timestamp < block.timestamp) {\n', '      return houses[_user].huntingPower.mul(\n', '        houses[_user].huntingMultiplier\n', '      ).mul(block.timestamp - _timestamp) / 100;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function _houseOf(address _user)\n', '    internal\n', '    view\n', '    returns (House storage _house)\n', '  {\n', '    _house = houses[_user];\n', '    require(_house.depots > 0);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHHunter\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHHunter is CHGameBase {\n', '\n', '  /* EVENT */\n', '\n', '  event UpgradeHunter(\n', '    address indexed user,\n', '    string attribute,\n', '    uint256 to\n', '  );\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Config {\n', '    uint256 chicken;\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  Config public typeA;\n', '  Config public typeB;\n', '\n', '  /* FUNCTION */\n', '\n', '  function upgradeStrength(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.strength;\n', '    require(typeA.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeA);\n', '\n', '    uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2);\n', '    _house.hunter.strength = _to;\n', '    _house.huntingPower = _house.huntingPower.add(_increment);\n', '    _house.offensePower = _house.offensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "strength", _to);\n', '  }\n', '\n', '  function upgradeDexterity(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.dexterity;\n', '    require(typeB.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeB);\n', '\n', '    uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2));\n', '    _house.hunter.dexterity = _to;\n', '    _house.huntingPower = _house.huntingPower.add(_increment);\n', '    _house.offensePower = _house.offensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "dexterity", _to);\n', '  }\n', '\n', '  function upgradeConstitution(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.constitution;\n', '    require(typeA.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeA);\n', '\n', '    uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2);\n', '    _house.hunter.constitution = _to;\n', '    _house.defensePower = _house.defensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "constitution", _to);\n', '  }\n', '\n', '  function upgradeResistance(uint256 _to) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    uint256 _from = _house.hunter.resistance;\n', '    require(typeB.max >= _to && _to > _from);\n', '    _payForUpgrade(_from, _to, typeB);\n', '\n', '    uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2));\n', '    _house.hunter.resistance = _to;\n', '    _house.defensePower = _house.defensePower.add(_increment);\n', '\n', '    emit UpgradeHunter(msg.sender, "resistance", _to);\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal {\n', '    uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to));\n', '    _payChicken(msg.sender, _chickenCost);\n', '    uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to));\n', '    _payEthereumAndDistribute(_ethereumCost);\n', '  }\n', '\n', '  function _gapOfSquareSum(uint256 _before, uint256 _after)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // max value is capped to uint32\n', '    return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6;\n', '  }\n', '\n', '  function _gapOfCubeSum(uint256 _before, uint256 _after)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // max value is capped to uint32\n', '    return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHHouse\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHHouse is CHHunter {\n', '\n', '  /* EVENT */\n', '\n', '  event UpgradePet(\n', '    address indexed user,\n', '    uint256 id,\n', '    uint256 to\n', '  );\n', '\n', '  event UpgradeDepot(\n', '    address indexed user,\n', '    uint256 to\n', '  );\n', '\n', '  event BuyItem(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed id,\n', '    uint256 cost\n', '  );\n', '\n', '  event BuyStore(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 cost\n', '  );\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Pet {\n', '    uint256 huntingPower;\n', '    uint256 offensePower;\n', '    uint256 defensePower;\n', '    uint256 chicken;\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  struct Item {\n', '    address owner;\n', '    uint256 huntingMultiplier;\n', '    uint256 offenseMultiplier;\n', '    uint256 defenseMultiplier;\n', '    uint256 cost;\n', '  }\n', '\n', '  struct Depot {\n', '    uint256 ethereum;\n', '    uint256 max;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  uint256 public constant INCREMENT_RATE = 12; // 120% for Item and Store\n', '  Depot public depot;\n', '  Pet[] public pets;\n', '  Item[] public items;\n', '\n', '  /* FUNCTION */\n', '\n', '  function buyDepots(uint256 _amount) external payable {\n', '    House storage _house = _houseOf(msg.sender);\n', '    _house.depots = _house.depots.add(_amount);\n', '    require(_house.depots <= depot.max);\n', '    _payEthereumAndDistribute(_amount.mul(depot.ethereum));\n', '\n', '    emit UpgradeDepot(msg.sender, _house.depots);\n', '  }\n', '\n', '  function buyPets(uint256 _id, uint256 _amount) external payable {\n', '    require(_id < pets.length);\n', '    Pet memory _pet = pets[_id];\n', '    uint256 _chickenCost = _amount * _pet.chicken;\n', '    _payChicken(msg.sender, _chickenCost);\n', '    uint256 _ethereumCost = _amount * _pet.ethereum;\n', '    _payEthereumAndDistribute(_ethereumCost);\n', '\n', '    House storage _house = _houseOf(msg.sender);\n', '    if (_house.pets.length < _id + 1) {\n', '      _house.pets.length = _id + 1;\n', '    }\n', '    _house.pets[_id] = _house.pets[_id].add(_amount);\n', '    require(_house.pets[_id] <= _pet.max);\n', '\n', '    _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount);\n', '    _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount);\n', '    _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount);\n', '\n', '    emit UpgradePet(msg.sender, _id, _house.pets[_id]);\n', '  }\n', '\n', '  // This is independent of Stock and Altar.\n', '  function buyItem(uint256 _id) external payable {\n', '    Item storage _item = items[_id];\n', '    address _from = _item.owner;\n', '    uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10;\n', '    _payEthereum(_price);\n', '\n', '    saveChickenOf(_from);\n', '    House storage _fromHouse = _houseOf(_from);\n', '    _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier);\n', '    _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier);\n', '    _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier);\n', '\n', '    saveChickenOf(msg.sender);\n', '    House storage _toHouse = _houseOf(msg.sender);\n', '    _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier);\n', '    _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier);\n', '    _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier);\n', '\n', '    uint256 _halfMargin = _price.sub(_item.cost) / 2;\n', '    devFee = devFee.add(_halfMargin);\n', '    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin);\n', '\n', '    items[_id].cost = _price;\n', '    items[_id].owner = msg.sender;\n', '\n', '    emit BuyItem(_from, msg.sender, _id, _price);\n', '  }\n', '\n', '  // This is independent of Stock and Altar.\n', '  function buyStore() external payable {\n', '    address _from = store.owner;\n', '    uint256 _price = store.cost.mul(INCREMENT_RATE) / 10;\n', '    _payEthereum(_price);\n', '\n', '    uint256 _halfMargin = (_price - store.cost) / 2;\n', '    devFee = devFee.add(_halfMargin);\n', '    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance);\n', '\n', '    store.cost = _price;\n', '    store.owner = msg.sender;\n', '    delete store.balance;\n', '\n', '    emit BuyStore(_from, msg.sender, _price);\n', '  }\n', '\n', '  function withdrawStoreBalance() public {\n', '    ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance);\n', '    delete store.balance;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHArena\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHArena is CHHouse {\n', '\n', '  /* EVENT */\n', '\n', '  event Attack(\n', '    address indexed attacker,\n', '    address indexed defender,\n', '    uint256 booty\n', '  );\n', '\n', '  /* STORAGE */\n', '\n', '  mapping(address => uint256) public attackCooldown;\n', '  uint256 public cooldownTime;\n', '\n', '  /* FUNCTION */\n', '\n', '  function attack(address _target) external {\n', '    require(attackCooldown[msg.sender] < block.timestamp);\n', '    House storage _attacker = houses[msg.sender];\n', '    House storage _defender = houses[_target];\n', '    if (_attacker.offensePower.mul(_attacker.offenseMultiplier)\n', '        > _defender.defensePower.mul(_defender.defenseMultiplier)) {\n', '      uint256 _chicken = saveChickenOf(_target);\n', '      _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken;\n', '      savedChickenOf[_target] = savedChickenOf[_target] - _chicken;\n', '      savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken);\n', '      attackCooldown[msg.sender] = block.timestamp + cooldownTime;\n', '\n', '      emit Attack(msg.sender, _target, _chicken);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHAltar\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHAltar is CHArena {\n', '\n', '  /* EVENT */\n', '\n', '  event NewAltarRecord(uint256 id, uint256 ethereum);\n', '  event ChickenToAltar(address indexed user, uint256 id, uint256 chicken);\n', '  event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum);\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct AltarRecord {\n', '    uint256 ethereum;\n', '    uint256 chicken;\n', '  }\n', '\n', '  struct TradeBook {\n', '    uint256 altarRecordId;\n', '    uint256 chicken;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  uint256 public genesis;\n', '  mapping (uint256 => AltarRecord) public altarRecords;\n', '  mapping (address => TradeBook) public tradeBooks;\n', '\n', '  /* FUNCTION */\n', '\n', '  function chickenToAltar(uint256 _chicken) external {\n', '    require(_chicken > 0);\n', '\n', '    _payChicken(msg.sender, _chicken);\n', '    uint256 _id = _getCurrentAltarRecordId();\n', '    AltarRecord storage _altarRecord = _getAltarRecord(_id);\n', '    require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum);\n', '    TradeBook storage _tradeBook = tradeBooks[msg.sender];\n', '    if (_tradeBook.altarRecordId < _id) {\n', '      _resolveTradeBook(_tradeBook);\n', '      _tradeBook.altarRecordId = _id;\n', '    }\n', '    _altarRecord.chicken = _altarRecord.chicken.add(_chicken);\n', '    _tradeBook.chicken += _chicken;\n', '\n', '    emit ChickenToAltar(msg.sender, _id, _chicken);\n', '  }\n', '\n', '  function ethereumFromAltar() external {\n', '    uint256 _id = _getCurrentAltarRecordId();\n', '    TradeBook storage _tradeBook = tradeBooks[msg.sender];\n', '    require(_tradeBook.altarRecordId < _id);\n', '    _resolveTradeBook(_tradeBook);\n', '  }\n', '\n', '  function tradeBookOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256 _id,\n', '      uint256 _ethereum,\n', '      uint256 _totalChicken,\n', '      uint256 _chicken,\n', '      uint256 _income\n', '    )\n', '  {\n', '    TradeBook memory _tradeBook = tradeBooks[_user];\n', '    _id = _tradeBook.altarRecordId;\n', '    _chicken = _tradeBook.chicken;\n', '    AltarRecord memory _altarRecord = altarRecords[_id];\n', '    _totalChicken = _altarRecord.chicken;\n', '    _ethereum = _altarRecord.ethereum;\n', '    _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0;\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _resolveTradeBook(TradeBook storage _tradeBook) internal {\n', '    if (_tradeBook.chicken > 0) {\n', '      AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId];\n', '      uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken;\n', '      delete _tradeBook.chicken;\n', '      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum);\n', '\n', '      emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum);\n', '    }\n', '  }\n', '\n', '  function _getCurrentAltarRecordId() internal view returns (uint256) {\n', '    return (block.timestamp - genesis) / 86400;\n', '  }\n', '\n', '  function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) {\n', '    _altarRecord = altarRecords[_id];\n', '    if (_altarRecord.ethereum == 0) {\n', '      uint256 _ethereum = altarFund / 10;\n', '      _altarRecord.ethereum = _ethereum;\n', '      altarFund -= _ethereum;\n', '\n', '      emit NewAltarRecord(_id, _ethereum);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CHCommittee\n', ' * @author M.H. Kang\n', ' */\n', 'contract CHCommittee is CHAltar {\n', '\n', '  /* EVENT */\n', '\n', '  event NewPet(\n', '    uint256 id,\n', '    uint256 huntingPower,\n', '    uint256 offensePower,\n', '    uint256 defense,\n', '    uint256 chicken,\n', '    uint256 ethereum,\n', '    uint256 max\n', '  );\n', '\n', '  event ChangePet(\n', '    uint256 id,\n', '    uint256 chicken,\n', '    uint256 ethereum,\n', '    uint256 max\n', '  );\n', '\n', '  event NewItem(\n', '    uint256 id,\n', '    uint256 huntingMultiplier,\n', '    uint256 offenseMultiplier,\n', '    uint256 defenseMultiplier,\n', '    uint256 ethereum\n', '  );\n', '\n', '  event SetDepot(uint256 ethereum, uint256 max);\n', '\n', '  event SetConfiguration(\n', '    uint256 chickenA,\n', '    uint256 ethereumA,\n', '    uint256 maxA,\n', '    uint256 chickenB,\n', '    uint256 ethereumB,\n', '    uint256 maxB\n', '  );\n', '\n', '  event SetDistribution(\n', '    uint256 dividendRate,\n', '    uint256 altarCut,\n', '    uint256 storeCut,\n', '    uint256 devCut\n', '  );\n', '\n', '  event SetCooldownTime(uint256 cooldownTime);\n', '  event SetNameAndSymbol(string name, string symbol);\n', '  event SetDeveloper(address developer);\n', '  event SetCommittee(address committee);\n', '\n', '  /* STORAGE */\n', '\n', '  address public committee;\n', '  address public developer;\n', '\n', '  /* FUNCTION */\n', '\n', '  function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n', '    external\n', '    payable\n', '    onlyCommittee\n', '    returns (bool)\n', '  {\n', '    return _to.call.value(_value).gas(_gas)(_code);\n', '  }\n', '\n', '  function addPet(\n', '    uint256 _huntingPower,\n', '    uint256 _offensePower,\n', '    uint256 _defense,\n', '    uint256 _chicken,\n', '    uint256 _ethereum,\n', '    uint256 _max\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_max > 0);\n', '    require(_max == uint256(uint32(_max)));\n', '    uint256 _newLength = pets.push(\n', '      Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max)\n', '    );\n', '\n', '    emit NewPet(\n', '      _newLength - 1,\n', '      _huntingPower,\n', '      _offensePower,\n', '      _defense,\n', '      _chicken,\n', '      _ethereum,\n', '      _max\n', '    );\n', '  }\n', '\n', '  function changePet(\n', '    uint256 _id,\n', '    uint256 _chicken,\n', '    uint256 _ethereum,\n', '    uint256 _max\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_id < pets.length);\n', '    Pet storage _pet = pets[_id];\n', '    require(_max >= _pet.max && _max == uint256(uint32(_max)));\n', '\n', '    _pet.chicken = _chicken;\n', '    _pet.ethereum = _ethereum;\n', '    _pet.max = _max;\n', '\n', '    emit ChangePet(_id, _chicken, _ethereum, _max);\n', '  }\n', '\n', '  function addItem(\n', '    uint256 _huntingMultiplier,\n', '    uint256 _offenseMultiplier,\n', '    uint256 _defenseMultiplier,\n', '    uint256 _price\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    uint256 _cap = 1 << 16;\n', '    require(\n', '      _huntingMultiplier < _cap &&\n', '      _offenseMultiplier < _cap &&\n', '      _defenseMultiplier < _cap\n', '    );\n', '    saveChickenOf(committee);\n', '    House storage _house = _houseOf(committee);\n', '    _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier);\n', '    _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier);\n', '    _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier);\n', '\n', '    uint256 _newLength = items.push(\n', '      Item(\n', '        committee,\n', '        _huntingMultiplier,\n', '        _offenseMultiplier,\n', '        _defenseMultiplier,\n', '        _price\n', '      )\n', '    );\n', '\n', '    emit NewItem(\n', '      _newLength - 1,\n', '      _huntingMultiplier,\n', '      _offenseMultiplier,\n', '      _defenseMultiplier,\n', '      _price\n', '    );\n', '  }\n', '\n', '  function setDepot(uint256 _price, uint256 _max) public onlyCommittee {\n', '    require(_max >= depot.max);\n', '\n', '    depot.ethereum = _price;\n', '    depot.max = _max;\n', '\n', '    emit SetDepot(_price, _max);\n', '  }\n', '\n', '  function setConfiguration(\n', '    uint256 _chickenA,\n', '    uint256 _ethereumA,\n', '    uint256 _maxA,\n', '    uint256 _chickenB,\n', '    uint256 _ethereumB,\n', '    uint256 _maxB\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA))));\n', '    require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB))));\n', '\n', '    typeA.chicken = _chickenA;\n', '    typeA.ethereum = _ethereumA;\n', '    typeA.max = _maxA;\n', '\n', '    typeB.chicken = _chickenB;\n', '    typeB.ethereum = _ethereumB;\n', '    typeB.max = _maxB;\n', '\n', '    emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB);\n', '  }\n', '\n', '  function setDistribution(\n', '    uint256 _dividendRate,\n', '    uint256 _altarCut,\n', '    uint256 _storeCut,\n', '    uint256 _devCut\n', '  )\n', '    public\n', '    onlyCommittee\n', '  {\n', '    require(_storeCut > 0);\n', '    require(\n', '      _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100\n', '    );\n', '\n', '    dividendRate = _dividendRate;\n', '    altarCut = _altarCut;\n', '    store.cut = _storeCut;\n', '    devCut = _devCut;\n', '\n', '    emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut);\n', '  }\n', '\n', '  function setCooldownTime(uint256 _cooldownTime) public onlyCommittee {\n', '    cooldownTime = _cooldownTime;\n', '\n', '    emit SetCooldownTime(_cooldownTime);\n', '  }\n', '\n', '  function setNameAndSymbol(string _name, string _symbol)\n', '    public\n', '    onlyCommittee\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    emit SetNameAndSymbol(_name, _symbol);\n', '  }\n', '\n', '  function setDeveloper(address _developer) public onlyCommittee {\n', '    require(_developer != address(0));\n', '    withdrawDevFee();\n', '    developer = _developer;\n', '\n', '    emit SetDeveloper(_developer);\n', '  }\n', '\n', '  function setCommittee(address _committee) public onlyCommittee {\n', '    require(_committee != address(0));\n', '    committee = _committee;\n', '\n', '    emit SetCommittee(_committee);\n', '  }\n', '\n', '  function withdrawDevFee() public {\n', '    ethereumBalance[developer] = ethereumBalance[developer].add(devFee);\n', '    delete devFee;\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyCommittee {\n', '    require(msg.sender == committee);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ChickenHunt\n', ' * @author M.H. Kang\n', ' */\n', 'contract ChickenHunt is CHCommittee {\n', '\n', '  /* EVENT */\n', '\n', '  event Join(address user);\n', '\n', '  /* CONSTRUCTOR */\n', '\n', '  constructor() public {\n', '    committee = msg.sender;\n', '    developer = msg.sender;\n', '  }\n', '\n', '  /* FUNCTION */\n', '\n', '  function init(address _chickenTokenDelegator) external onlyCommittee {\n', '    require(chickenTokenDelegator == address(0));\n', '    chickenTokenDelegator = _chickenTokenDelegator;\n', '    genesis = 1525791600;\n', '    join();\n', '    store.owner = msg.sender;\n', '    store.cost = 0.1 ether;\n', '    setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9);\n', '    setDistribution(20, 75, 1, 4);\n', '    setCooldownTime(600);\n', '    setDepot(0.05 ether, 9);\n', '    addItem(5, 5, 0, 0.01 ether);\n', '    addItem(0, 0, 5, 0.01 ether);\n', '    addPet(1000, 0, 0, 100000, 0.01 ether, 9);\n', '    addPet(0, 1000, 0, 100000, 0.01 ether, 9);\n', '    addPet(0, 0, 1000, 202500, 0.01 ether, 9);\n', '  }\n', '\n', '  function withdraw() external {\n', '    uint256 _ethereum = ethereumBalance[msg.sender];\n', '    delete ethereumBalance[msg.sender];\n', '    msg.sender.transfer(_ethereum);\n', '  }\n', '\n', '  function join() public {\n', '    House storage _house = houses[msg.sender];\n', '    require(_house.depots == 0);\n', '    _house.hunter = Hunter(1, 1, 1, 1);\n', '    _house.depots = 1;\n', '    _house.huntingPower = 10;\n', '    _house.offensePower = 10;\n', '    _house.defensePower = 110;\n', '    _house.huntingMultiplier = 10;\n', '    _house.offenseMultiplier = 10;\n', '    _house.defenseMultiplier = 10;\n', '    lastSaveTime[msg.sender] = block.timestamp;\n', '\n', '    emit Join(msg.sender);\n', '  }\n', '\n', '  function hunterOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256 _strength,\n', '      uint256 _dexterity,\n', '      uint256 _constitution,\n', '      uint256 _resistance\n', '    )\n', '  {\n', '    Hunter memory _hunter = houses[_user].hunter;\n', '    return (\n', '      _hunter.strength,\n', '      _hunter.dexterity,\n', '      _hunter.constitution,\n', '      _hunter.resistance\n', '    );\n', '  }\n', '\n', '  function detailsOf(address _user)\n', '    public\n', '    view\n', '    returns (\n', '      uint256[2] _hunting,\n', '      uint256[2] _offense,\n', '      uint256[2] _defense,\n', '      uint256[4] _hunter,\n', '      uint256[] _pets,\n', '      uint256 _depots,\n', '      uint256 _savedChicken,\n', '      uint256 _lastSaveTime,\n', '      uint256 _cooldown\n', '    )\n', '  {\n', '    House memory _house = houses[_user];\n', '\n', '    _hunting = [_house.huntingPower, _house.huntingMultiplier];\n', '    _offense = [_house.offensePower, _house.offenseMultiplier];\n', '    _defense = [_house.defensePower, _house.defenseMultiplier];\n', '    _hunter = [\n', '      _house.hunter.strength,\n', '      _house.hunter.dexterity,\n', '      _house.hunter.constitution,\n', '      _house.hunter.resistance\n', '    ];\n', '    _pets = _house.pets;\n', '    _depots = _house.depots;\n', '    _savedChicken = savedChickenOf[_user];\n', '    _lastSaveTime = lastSaveTime[_user];\n', '    _cooldown = attackCooldown[_user];\n', '  }\n', '\n', '}']
