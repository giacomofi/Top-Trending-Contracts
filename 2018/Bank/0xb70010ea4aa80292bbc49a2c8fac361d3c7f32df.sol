['// hevm: flattened sources of src/LightPoolWrapper.sol\n', 'pragma solidity ^0.4.21;\n', '\n', '////// lib/ds-roles/lib/ds-auth/src/auth.sol\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/ERC20.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function decimals() public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/PriceSanityInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract PriceSanityInterface {\n', '    function checkPrice(address base, address quote, bool buy, uint256 baseAmount, uint256 quoteAmount) external view returns (bool result);\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/WETHInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./ERC20.sol"; */\n', '\n', 'contract WETHInterface is ERC20 {\n', '  function() external payable;\n', '  function deposit() external payable;\n', '  function withdraw(uint wad) external;\n', '}\n', '\n', '////// lib/lightpool-contracts/src/LightPool.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./interfaces/WETHInterface.sol"; */\n', '/* import "./interfaces/PriceSanityInterface.sol"; */\n', '/* import "./interfaces/ERC20.sol"; */\n', '\n', 'contract LightPool {\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    struct TokenData {\n', '        address walletAddress;\n', '        PriceSanityInterface priceSanityContract;\n', '    }\n', '\n', '    // key = keccak256(token, base, walletAddress)\n', '    mapping(bytes32 => TokenData)       public markets;\n', '    mapping(address => bool)            public traders;\n', '    address                             public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWalletAddress(address base, address quote) {\n', '        bytes32 key = keccak256(base, quote, msg.sender);\n', '        require(markets[key].walletAddress == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTrader() {\n', '        require(traders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function LightPool() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setTrader(address trader, bool enabled) onlyOwner external {\n', '        traders[trader] = enabled;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner external {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '\n', '    event AddMarket(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function addMarket(ERC20 base, ERC20 quote, PriceSanityInterface priceSanityContract) external {\n', '        require(base != address(0));\n', '        require(quote != address(0));\n', '\n', '        // Make sure there&#39;s no such configured token\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        require(markets[tokenHash].walletAddress == address(0));\n', '\n', '        // Initialize token pool data\n', '        markets[tokenHash] = TokenData(msg.sender, priceSanityContract);\n', '        emit AddMarket(base, quote, msg.sender, priceSanityContract);\n', '    }\n', '\n', '    event RemoveMarket(address indexed base, address indexed quote, address indexed walletAddress);\n', '    function removeMarket(ERC20 base, ERC20 quote) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '\n', '        emit RemoveMarket(base, quote, tokenData.walletAddress);\n', '        delete markets[tokenHash];\n', '    }\n', '\n', '    event ChangePriceSanityContract(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function changePriceSanityContract(ERC20 base, ERC20 quote, PriceSanityInterface _priceSanityContract) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        tokenData.priceSanityContract = _priceSanityContract;\n', '        emit ChangePriceSanityContract(base, quote, msg.sender, _priceSanityContract);\n', '    }\n', '\n', '    event Trade(address indexed trader, address indexed baseToken, address indexed quoteToken, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount);\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) onlyTrader external {\n', '        bytes32 tokenHash = keccak256(base, quote, walletAddress);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        require(tokenData.walletAddress != address(0));\n', '        if (tokenData.priceSanityContract != address(0)) {\n', '            require(tokenData.priceSanityContract.checkPrice.gas(EXTERNAL_QUERY_GAS_LIMIT)(base, quote, buy, baseAmount, quoteAmount)); // Limit gas to prevent reentrancy\n', '        }\n', '        ERC20 takenToken;\n', '        ERC20 givenToken;\n', '        uint256 takenTokenAmount;\n', '        uint256 givenTokenAmount;\n', '        if (buy) {\n', '            takenToken = quote;\n', '            givenToken = base;\n', '            takenTokenAmount = quoteAmount;\n', '            givenTokenAmount = baseAmount;\n', '        } else {\n', '            takenToken = base;\n', '            givenToken = quote;\n', '            takenTokenAmount = baseAmount;\n', '            givenTokenAmount = quoteAmount;\n', '        }\n', '        require(takenTokenAmount != 0 && givenTokenAmount != 0);\n', '\n', '        // Swap!\n', '        require(takenToken.transferFrom(msg.sender, tokenData.walletAddress, takenTokenAmount));\n', '        require(givenToken.transferFrom(tokenData.walletAddress, msg.sender, givenTokenAmount));\n', '        emit Trade(msg.sender, base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-token/lib/ds-math/src/math.sol\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\n', '/// note.sol -- the `note&#39; modifier, for logging calls as events\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-value/lib/ds-thing/src/thing.sol\n', '// thing.sol - `auth` with handy mixins. your things should be DSThings\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', '/* import &#39;ds-auth/auth.sol&#39;; */\n', '/* import &#39;ds-note/note.sol&#39;; */\n', '/* import &#39;ds-math/math.sol&#39;; */\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '\n', '    function S(string s) internal pure returns (bytes4) {\n', '        return bytes4(keccak256(s));\n', '    }\n', '\n', '}\n', '\n', '////// src/LightPoolWrapper.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "ds-thing/thing.sol"; */\n', '/* import "lightpool-contracts/LightPool.sol"; */\n', '\n', 'contract WETH is WETHInterface { }\n', '\n', 'contract LightPoolWrapper is DSThing {\n', '    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    address public reserve;\n', '    LightPool public lightpool;\n', '    mapping(address => bool) public whitelistedWallets;\n', '\n', '    function LightPoolWrapper(address reserve_, LightPool lightpool_) public {\n', '        assert(address(reserve_) != 0);\n', '        assert(address(lightpool_) != 0);\n', '\n', '        reserve = reserve_;\n', '        lightpool = lightpool_;\n', '    }\n', '\n', '    function switchLightPool(LightPool lightpool_) public note auth {\n', '        assert(address(lightpool_) != 0);\n', '        lightpool = lightpool_;\n', '    }\n', '\n', '    function switchReserve(address reserve_) public note auth {\n', '        assert(address(reserve_) != 0);\n', '        reserve = reserve_;\n', '    }\n', '\n', '    function approveToken(ERC20 token, address spender, uint amount) public note auth {\n', '        require(token.approve(spender, amount));\n', '    }\n', '\n', '    function setWhitelistedWallet(address walletAddress_, bool whitelisted) public note auth {\n', '        whitelistedWallets[walletAddress_] = whitelisted;\n', '    }\n', '\n', '    event Trade(\n', '        address indexed origin,\n', '        address indexed srcToken,\n', '        uint srcAmount,\n', '        address indexed destToken,\n', '        uint destAmount,\n', '        address destAddress\n', '    );\n', '\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) public auth {\n', '        require(whitelistedWallets[walletAddress]);\n', '\n', '        ERC20 takenToken;\n', '        uint takenAmount;\n', '        ERC20 givenToken;\n', '        uint givenAmount;\n', '\n', '        if (buy) {\n', '            takenToken = base;\n', '            takenAmount = baseAmount;\n', '            givenToken = quote;\n', '            givenAmount = quoteAmount;\n', '        } else {\n', '            takenToken = quote;\n', '            takenAmount = quoteAmount;\n', '            givenToken = base;\n', '            givenAmount = baseAmount;\n', '        }\n', '\n', '        require(givenToken.transferFrom(reserve, this, givenAmount));\n', '        lightpool.trade(base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '        require(takenToken.transfer(reserve, takenAmount));\n', '\n', '        emit Trade(reserve, givenToken, givenAmount, takenToken, takenAmount, walletAddress);\n', '    }\n', '\n', '    function withdraw(ERC20 token, uint amount, address destination) public note auth {\n', '        if (token == ETH_TOKEN_ADDRESS) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(token.transfer(destination, amount));\n', '        }\n', '    }\n', '}']
['// hevm: flattened sources of src/LightPoolWrapper.sol\n', 'pragma solidity ^0.4.21;\n', '\n', '////// lib/ds-roles/lib/ds-auth/src/auth.sol\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/ERC20.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function decimals() public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/PriceSanityInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract PriceSanityInterface {\n', '    function checkPrice(address base, address quote, bool buy, uint256 baseAmount, uint256 quoteAmount) external view returns (bool result);\n', '}\n', '\n', '////// lib/lightpool-contracts/src/interfaces/WETHInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./ERC20.sol"; */\n', '\n', 'contract WETHInterface is ERC20 {\n', '  function() external payable;\n', '  function deposit() external payable;\n', '  function withdraw(uint wad) external;\n', '}\n', '\n', '////// lib/lightpool-contracts/src/LightPool.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./interfaces/WETHInterface.sol"; */\n', '/* import "./interfaces/PriceSanityInterface.sol"; */\n', '/* import "./interfaces/ERC20.sol"; */\n', '\n', 'contract LightPool {\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    struct TokenData {\n', '        address walletAddress;\n', '        PriceSanityInterface priceSanityContract;\n', '    }\n', '\n', '    // key = keccak256(token, base, walletAddress)\n', '    mapping(bytes32 => TokenData)       public markets;\n', '    mapping(address => bool)            public traders;\n', '    address                             public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWalletAddress(address base, address quote) {\n', '        bytes32 key = keccak256(base, quote, msg.sender);\n', '        require(markets[key].walletAddress == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTrader() {\n', '        require(traders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function LightPool() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setTrader(address trader, bool enabled) onlyOwner external {\n', '        traders[trader] = enabled;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner external {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '\n', '    event AddMarket(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function addMarket(ERC20 base, ERC20 quote, PriceSanityInterface priceSanityContract) external {\n', '        require(base != address(0));\n', '        require(quote != address(0));\n', '\n', "        // Make sure there's no such configured token\n", '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        require(markets[tokenHash].walletAddress == address(0));\n', '\n', '        // Initialize token pool data\n', '        markets[tokenHash] = TokenData(msg.sender, priceSanityContract);\n', '        emit AddMarket(base, quote, msg.sender, priceSanityContract);\n', '    }\n', '\n', '    event RemoveMarket(address indexed base, address indexed quote, address indexed walletAddress);\n', '    function removeMarket(ERC20 base, ERC20 quote) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '\n', '        emit RemoveMarket(base, quote, tokenData.walletAddress);\n', '        delete markets[tokenHash];\n', '    }\n', '\n', '    event ChangePriceSanityContract(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function changePriceSanityContract(ERC20 base, ERC20 quote, PriceSanityInterface _priceSanityContract) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        tokenData.priceSanityContract = _priceSanityContract;\n', '        emit ChangePriceSanityContract(base, quote, msg.sender, _priceSanityContract);\n', '    }\n', '\n', '    event Trade(address indexed trader, address indexed baseToken, address indexed quoteToken, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount);\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) onlyTrader external {\n', '        bytes32 tokenHash = keccak256(base, quote, walletAddress);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        require(tokenData.walletAddress != address(0));\n', '        if (tokenData.priceSanityContract != address(0)) {\n', '            require(tokenData.priceSanityContract.checkPrice.gas(EXTERNAL_QUERY_GAS_LIMIT)(base, quote, buy, baseAmount, quoteAmount)); // Limit gas to prevent reentrancy\n', '        }\n', '        ERC20 takenToken;\n', '        ERC20 givenToken;\n', '        uint256 takenTokenAmount;\n', '        uint256 givenTokenAmount;\n', '        if (buy) {\n', '            takenToken = quote;\n', '            givenToken = base;\n', '            takenTokenAmount = quoteAmount;\n', '            givenTokenAmount = baseAmount;\n', '        } else {\n', '            takenToken = base;\n', '            givenToken = quote;\n', '            takenTokenAmount = baseAmount;\n', '            givenTokenAmount = quoteAmount;\n', '        }\n', '        require(takenTokenAmount != 0 && givenTokenAmount != 0);\n', '\n', '        // Swap!\n', '        require(takenToken.transferFrom(msg.sender, tokenData.walletAddress, takenTokenAmount));\n', '        require(givenToken.transferFrom(tokenData.walletAddress, msg.sender, givenTokenAmount));\n', '        emit Trade(msg.sender, base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-token/lib/ds-math/src/math.sol\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\n', "/// note.sol -- the `note' modifier, for logging calls as events\n", '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '////// lib/lpc/lib/ds-value/lib/ds-thing/src/thing.sol\n', '// thing.sol - `auth` with handy mixins. your things should be DSThings\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity ^0.4.13; */\n', '\n', "/* import 'ds-auth/auth.sol'; */\n", "/* import 'ds-note/note.sol'; */\n", "/* import 'ds-math/math.sol'; */\n", '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '\n', '    function S(string s) internal pure returns (bytes4) {\n', '        return bytes4(keccak256(s));\n', '    }\n', '\n', '}\n', '\n', '////// src/LightPoolWrapper.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "ds-thing/thing.sol"; */\n', '/* import "lightpool-contracts/LightPool.sol"; */\n', '\n', 'contract WETH is WETHInterface { }\n', '\n', 'contract LightPoolWrapper is DSThing {\n', '    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    address public reserve;\n', '    LightPool public lightpool;\n', '    mapping(address => bool) public whitelistedWallets;\n', '\n', '    function LightPoolWrapper(address reserve_, LightPool lightpool_) public {\n', '        assert(address(reserve_) != 0);\n', '        assert(address(lightpool_) != 0);\n', '\n', '        reserve = reserve_;\n', '        lightpool = lightpool_;\n', '    }\n', '\n', '    function switchLightPool(LightPool lightpool_) public note auth {\n', '        assert(address(lightpool_) != 0);\n', '        lightpool = lightpool_;\n', '    }\n', '\n', '    function switchReserve(address reserve_) public note auth {\n', '        assert(address(reserve_) != 0);\n', '        reserve = reserve_;\n', '    }\n', '\n', '    function approveToken(ERC20 token, address spender, uint amount) public note auth {\n', '        require(token.approve(spender, amount));\n', '    }\n', '\n', '    function setWhitelistedWallet(address walletAddress_, bool whitelisted) public note auth {\n', '        whitelistedWallets[walletAddress_] = whitelisted;\n', '    }\n', '\n', '    event Trade(\n', '        address indexed origin,\n', '        address indexed srcToken,\n', '        uint srcAmount,\n', '        address indexed destToken,\n', '        uint destAmount,\n', '        address destAddress\n', '    );\n', '\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) public auth {\n', '        require(whitelistedWallets[walletAddress]);\n', '\n', '        ERC20 takenToken;\n', '        uint takenAmount;\n', '        ERC20 givenToken;\n', '        uint givenAmount;\n', '\n', '        if (buy) {\n', '            takenToken = base;\n', '            takenAmount = baseAmount;\n', '            givenToken = quote;\n', '            givenAmount = quoteAmount;\n', '        } else {\n', '            takenToken = quote;\n', '            takenAmount = quoteAmount;\n', '            givenToken = base;\n', '            givenAmount = baseAmount;\n', '        }\n', '\n', '        require(givenToken.transferFrom(reserve, this, givenAmount));\n', '        lightpool.trade(base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '        require(takenToken.transfer(reserve, takenAmount));\n', '\n', '        emit Trade(reserve, givenToken, givenAmount, takenToken, takenAmount, walletAddress);\n', '    }\n', '\n', '    function withdraw(ERC20 token, uint amount, address destination) public note auth {\n', '        if (token == ETH_TOKEN_ADDRESS) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(token.transfer(destination, amount));\n', '        }\n', '    }\n', '}']
