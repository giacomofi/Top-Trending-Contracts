['pragma solidity ^0.4.24;\n', '\n', 'contract I4D_Contract{\n', '    using SafeMath for uint256;\n', '    \n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    // Attributes set.\n', '    string public name = "I4D";\n', '    uint256 public tokenPrice = 0.01 ether;\n', '    uint256 public mintax = 0.003 ether; // about 1 USD\n', '    uint16[3] public Gate = [10, 100, 1000];\n', '    uint8[4] public commissionRate = [1, 2, 3, 4];\n', '    uint256 public newPlayerFee=0.1 ether;\n', '    bytes32 internal SuperAdmin_id = 0x0eac2ad3c8c41367ba898b18b9f85aab3adac98f5dfc76fafe967280f62987b4;\n', '    \n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    // Data stored.\n', '    uint256 internal administratorETH;\n', '    uint256 public totalTokenSupply;\n', '    uint256 internal DivsSeriesSum;\n', '    mapping(bytes32 => bool) public administrators;  // type of byte32, keccak256 of address\n', '    mapping(address=>uint256) public tokenBalance;\n', '    mapping(address=>address) public highlevel;\n', '    mapping(address=>address) public rightbrother;\n', '    mapping(address=>address) public leftchild;\n', '    mapping(address=>uint256) public deltaDivsSum;\n', '    mapping(address=>uint256) public commission;\n', '    mapping(address=>uint256) public withdrawETH;\n', '    \n', '\n', '    constructor() public{\n', '        administrators[SuperAdmin_id] = true;\n', '        \n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    // modifier and Events\n', '    modifier onlyAdmin(){\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[keccak256(_customerAddress)]);\n', '        _;\n', '    }\n', '    modifier onlyTokenholders() {\n', '        require(tokenBalance[msg.sender] > 0);\n', '        _;\n', '    }\n', '    \n', '    event onEthSell(\n', '        address indexed customerAddress,\n', '        uint256 ethereumEarned\n', '    );\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    event testOutput(\n', '        uint256 ret\n', '    );\n', '    event taxOutput(\n', '        uint256 tax,\n', '        uint256 sumoftax\n', '    );\n', '    \n', '    \n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    //Administrator api\n', '    function withdrawAdministratorETH(uint256 amount)\n', '        public\n', '        onlyAdmin()\n', '    {\n', '        address administrator = msg.sender;\n', '        require(amount<=administratorETH,"Too much");\n', '        administratorETH = administratorETH.sub(amount);\n', '        administrator.transfer(amount);\n', '    }\n', '    \n', '    function getAdministratorETH()\n', '        public\n', '        onlyAdmin()\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return administratorETH;\n', '    }\n', '    \n', '    /** add Adimin here\n', '     * you can not change status of  super administrator.\n', '     */\n', '    function setAdministrator(bytes32 _identifier, bool _status)\n', '        onlyAdmin()\n', '        public\n', '    {\n', '        require(_identifier!=SuperAdmin_id);\n', '        administrators[_identifier] = _status;\n', '    }\n', '    \n', '    \n', '    function setName(string _name)\n', '        onlyAdmin()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '    /////////////////////////////////////////////////////////////////////////////\n', '    function setTokenValue(uint256 _value)\n', '        onlyAdmin()\n', '        public\n', '    {\n', '        // we may increase our token price.\n', '        require(_value > tokenPrice);\n', '        tokenPrice = _value;\n', '    }\n', '    \n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    // Player api.\n', '    \n', '    /** \n', '     * api of buy tokens.\n', '     */\n', '    function buy(address _referredBy)\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        PurchaseTokens(msg.value, _referredBy);\n', '    }\n', '    \n', '    /**\n', '     * reinvest your profits to puchase more tokens.\n', '     */\n', '    function reinvest(uint256 reinvestAmount)\n', '    onlyTokenholders()\n', '    public\n', '    {\n', '        require(reinvestAmount>=1,"At least 1 Token!");\n', '        address _customerAddress = msg.sender;\n', '        require(getReinvestableTokenAmount(_customerAddress)>=reinvestAmount,"You DO NOT have enough ETH!");\n', '        withdrawETH[_customerAddress] = withdrawETH[_customerAddress].add(reinvestAmount*tokenPrice);\n', '        uint256 tokens = PurchaseTokens(reinvestAmount.mul(tokenPrice), highlevel[_customerAddress]);\n', '        \n', '        ///////////////////\n', '        emit onReinvestment(_customerAddress,tokens*tokenPrice,tokens);\n', '    }\n', '    \n', '    /**\n', '     * withdraw the profits(include commissions and divs).\n', '     */\n', '    function withdraw(uint256 _amountOfEths)\n', '    public\n', '    onlyTokenholders()\n', '    {\n', '        address _customerAddress=msg.sender;\n', '        uint256 eth_all = getWithdrawableETH(_customerAddress);\n', '        require(eth_all >= _amountOfEths);\n', '        withdrawETH[_customerAddress] = withdrawETH[_customerAddress].add(_amountOfEths);\n', '        _customerAddress.transfer(_amountOfEths);\n', '        emit onEthSell(_customerAddress,_amountOfEths);\n', '        \n', '        //sell logic here\n', '    }\n', '    \n', '    // some view functions to get your information.\n', '    function getMaxLevel(address _customerAddress, uint16 cur_level)\n', '    public\n', '    view\n', '    returns(uint32)\n', '    {\n', '        address children = leftchild[_customerAddress];\n', '        uint32 maxlvl = cur_level;\n', '        while(children!=0x0000000000000000000000000000000000000000){\n', '            uint32 child_lvl = getMaxLevel(children, cur_level+1);\n', '            if(maxlvl < child_lvl){\n', '                maxlvl = child_lvl;\n', '            }\n', '            children = rightbrother[children];\n', '        }\n', '        return maxlvl;\n', '    }\n', '    \n', '    function getTotalNodeCount(address _customerAddress)\n', '    public\n', '    view\n', '    returns(uint32)\n', '    {\n', '        uint32 ctr=1;\n', '        address children = leftchild[_customerAddress];\n', '        while(children!=0x0000000000000000000000000000000000000000){\n', '            ctr += getTotalNodeCount(children);\n', '            children = rightbrother[children];\n', '        }\n', '        return ctr;\n', '    }\n', '    \n', '    function getMaxProfitAndtoken(address[] playerList)\n', '    public\n', '    view\n', '    returns(uint256[],uint256[],address[])\n', '    {\n', '        uint256 len=playerList.length;\n', '        uint256 i;\n', '        uint256 Profit;\n', '        uint256 token;\n', '        address hl;\n', '        uint[] memory ProfitList=new uint[](len);\n', '        uint[] memory tokenList=new uint[](len);\n', '        address[] memory highlevelList=new address[](len);\n', '        for(i=0;i<len;i++)\n', '        {\n', '            Profit=getTotalProfit(playerList[i]);\n', '            token=tokenBalance[playerList[i]];\n', '            hl=highlevel[playerList[i]];\n', '            ProfitList[i]=Profit;\n', '            tokenList[i]=token;\n', '            highlevelList[i]=hl;\n', '        }\n', '        return (ProfitList,tokenList,highlevelList);\n', '    }\n', '    function getReinvestableTokenAmount(address _customerAddress)\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return getWithdrawableETH(_customerAddress).div(tokenPrice);\n', '    }\n', '    \n', '    /**\n', '     * Total profit = your withdrawable ETH + ETHs you have withdrew.\n', '     */\n', '    function getTotalProfit(address _customerAddress)\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return commission[_customerAddress].add(DivsSeriesSum.sub(deltaDivsSum[_customerAddress]).mul(tokenBalance[_customerAddress])/10*3);\n', '    }\n', '    \n', '    function getWithdrawableETH(address _customerAddress)\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        uint256 divs = DivsSeriesSum.sub(deltaDivsSum[_customerAddress]).mul(tokenBalance[_customerAddress])/10*3;\n', '        return commission[_customerAddress].add(divs).sub(withdrawETH[_customerAddress]);\n', '    }\n', '    \n', '    function getTokenBalance()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '    address _address = msg.sender;\n', '    return tokenBalance[_address];\n', '    }\n', '    \n', '    function getContractBalance()public view returns (uint) {\n', '        return address(this).balance;\n', '    }  \n', '    \n', '    /**\n', '     * get your commission rate by your token held.\n', '     */\n', '    function getCommissionRate(address _customerAddress)\n', '    public\n', '    view\n', '    returns(uint8)\n', '    {\n', '        if(tokenBalance[_customerAddress]<1){\n', '            return 0;\n', '        }\n', '        uint8 i;\n', '        for(i=0; i<Gate.length; i++){\n', '            if(tokenBalance[_customerAddress]<Gate[i]){\n', '                break;\n', '            }\n', '        }\n', '        return commissionRate[i];\n', '    }\n', '    \n', '    \n', '    ///////////////////////////////////////////////////////////////////////////////\n', '    // functions to calculate commissions and divs when someone purchase some tokens.\n', '    \n', '    /**\n', '     * api for buying tokens.\n', '     */\n', '    function PurchaseTokens(uint256 _incomingEthereum, address _referredBy)\n', '        internal\n', '        returns(uint256)\n', '    {   \n', '        /////////////////////////////////\n', '        address _customerAddress=msg.sender;\n', '        uint256 numOfToken;\n', '        require(_referredBy==0x0000000000000000000000000000000000000000 || tokenBalance[_referredBy] > 0);\n', '        if(tokenBalance[_customerAddress] > 0)\n', '        {\n', '            require(_incomingEthereum >= tokenPrice,"ETH is NOT enough");\n', '            require(_incomingEthereum % tokenPrice ==0);\n', '            require(highlevel[_customerAddress] == _referredBy);\n', '            numOfToken = ETH2Tokens(_incomingEthereum);\n', '        }\n', '        else\n', '        {\n', '            //New player without a inviter will be taxed for newPlayerFee, and this value can be changed by administrator\n', '            if(_referredBy==0x0000000000000000000000000000000000000000 || _referredBy==_customerAddress)\n', '            {\n', '                require(_incomingEthereum >= newPlayerFee+tokenPrice,"ETH is NOT enough");\n', '                require((_incomingEthereum-newPlayerFee) % tokenPrice ==0);\n', '                _incomingEthereum -= newPlayerFee;\n', '                numOfToken = ETH2Tokens(_incomingEthereum);\n', '                highlevel[_customerAddress] = 0x0000000000000000000000000000000000000000;\n', '                administratorETH = administratorETH.add(newPlayerFee);\n', '            }\n', '            else\n', '            {\n', '                // new player with invite address.\n', '                require(_incomingEthereum >= tokenPrice,"ETH is NOT enough");\n', '                require(_incomingEthereum % tokenPrice ==0);\n', '                numOfToken = ETH2Tokens(_incomingEthereum);\n', '                highlevel[_customerAddress] = _referredBy;\n', '                addMember(_referredBy,_customerAddress);\n', '            }\n', '            commission[_customerAddress] = 0;\n', '        }\n', '        calDivs(_customerAddress,numOfToken);\n', '        calCommission(_incomingEthereum,_customerAddress);\n', '        emit onTokenPurchase(_customerAddress,_incomingEthereum,numOfToken,_referredBy); \n', '        return numOfToken;\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Calculate the dividends of the members hold tokens.\n', '     * There are two methods to calculate the dividends.\n', '     * We chose the second method for you that you can get more divs.\n', '     */\n', '    function calDivs(address customer,uint256 num)\n', '    internal\n', '    {\n', '        // Approach 1.\n', '        // Use harmonic series to cal player divs. This is a precise algorithm.\n', '        // Approach 2.\n', '        // Simplify the "for loop" of approach 1.\n', '        // You can get more divs than approach 1 when you buy more than 1 token at one time.\n', '        // cal average to avoid overflow.\n', '        uint256 average_before = deltaDivsSum[customer].mul(tokenBalance[customer]) / tokenBalance[customer].add(num);\n', '        uint256 average_delta = DivsSeriesSum.mul(num) / (num + tokenBalance[customer]);\n', '        deltaDivsSum[customer] = average_before.add(average_delta);\n', '        DivsSeriesSum = DivsSeriesSum.add(tokenPrice.mul(num) / totalTokenSupply.add(num));\n', '        totalTokenSupply += num;\n', '        tokenBalance[customer] = num.add(tokenBalance[customer]);\n', '    }\n', '    \n', '    /**\n', '     * Calculate the commissions of your inviters.\n', '     */\n', '    function calCommission(uint256 _incomingEthereum,address _customerAddress)\n', '        internal \n', '        returns(uint256)\n', '    {\n', '        address _highlevel=highlevel[_customerAddress];\n', '        uint256 tax;\n', '        uint256 sumOftax=0;\n', '        uint8 i=0;\n', '        uint256 tax_chain=_incomingEthereum;\n', '        uint256 globalfee = _incomingEthereum.mul(3).div(10);\n', '        // The maximum deepth of tree you can get commission is 14. You can never get any eth from your children of more than 15 lvl.\n', '        for(i=1; i<=14; i++)\n', '        {\n', '            if(_highlevel==0x0000000000000000000000000000000000000000 || tokenBalance[_highlevel]==0){\n', '                break;\n', '            }\n', '            uint8 com_rate = getCommissionRate(_highlevel);\n', '            tax_chain = tax_chain.mul(com_rate).div(10);\n', '            if(tokenBalance[_highlevel]>=Gate[2]){\n', '                tax=mul_float_power(_incomingEthereum, i, com_rate, 10);\n', '            }\n', '            else{\n', '                tax=tax_chain;\n', '            }\n', '\n', '            // The minimum deepth of tree you can get commission is 2.\n', '            // If the deepth is higher than 2 and the tax is lower than mintax, you can never get any commission.\n', '            if(i>2 && tax <= mintax){\n', '                break;\n', '            }\n', '            commission[_highlevel] = commission[_highlevel].add(tax);\n', '            sumOftax = sumOftax.add(tax);\n', '            _highlevel = highlevel[_highlevel];\n', '            emit taxOutput(tax,sumOftax);\n', '        }\n', '        \n', '        if(sumOftax.add(globalfee) < _incomingEthereum)\n', '        {\n', '            administratorETH = _incomingEthereum.sub(sumOftax).sub(globalfee).add(administratorETH);\n', '        }\n', '        \n', '    }\n', '    \n', '    /**\n', '     * New player with inviter should add member to the group tree.\n', '     */\n', '    function addMember(address _referredBy,address _customer)\n', '    internal\n', '    {\n', '        require(tokenBalance[_referredBy] > 0);\n', '        if(leftchild[_referredBy]!=0x0000000000000000000000000000000000000000)\n', '        {\n', '            rightbrother[_customer] = leftchild[_referredBy];\n', '        }\n', '        leftchild[_referredBy] = _customer;\n', '    }\n', '    \n', '    function ETH2Tokens(uint256 _ethereum)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return _ethereum.div(tokenPrice);\n', '    }\n', '    \n', '    function Tokens2ETH(uint256 _tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return _tokens.mul(tokenPrice);\n', '    }\n', '    \n', '    /**\n', '     * Calculate x  *  (numerator / denominator) ** n\n', '     * Use "For Loop" to avoid overflow.\n', '     */\n', '    function mul_float_power(uint256 x, uint8 n, uint8 numerator, uint8 denominator)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 ret = x;\n', '        if(x==0 || numerator==0){\n', '            return 0;\n', '        }\n', '        for(uint8 i=0; i<n; i++){\n', '            ret = ret.mul(numerator).div(denominator);\n', '        }\n', '        return ret;\n', '\n', '    }\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']