['pragma solidity ^0.4.24;\n', '\n', '/*   \n', ' *    Exodus adaptation of OasisDirectProxy by MakerDAO.\n', ' */\n', '\n', 'contract OtcInterface {\n', '    function sellAllAmount(address, uint, address, uint) public returns (uint);\n', '    function buyAllAmount(address, uint, address, uint) public returns (uint);\n', '    function getPayAmount(address, address, uint) public constant returns (uint);\n', '}\n', '\n', 'contract TokenInterface {\n', '    function balanceOf(address) public returns (uint);\n', '    function allowance(address, address) public returns (uint);\n', '    function approve(address, uint) public;\n', '    function transfer(address,uint) public returns (bool);\n', '    function transferFrom(address, address, uint) public returns (bool);\n', '    function deposit() public payable;\n', '    function withdraw(uint) public;\n', '}\n', '\n', 'contract FeeInterface {\n', '    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Mortal is DSAuth {\n', '    function kill() public auth {\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function withdrawTo(address _to) public auth {\n', '    /* rescue all ETH */\n', '        require(_to.call.value(address(this).balance)());\n', '    }\n', '    \n', '    function withdrawTokenTo(TokenInterface token, address _to) public auth {\n', '    /* rescue all of a token */\n', '        require(token.transfer(_to, token.balanceOf(this)));\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract OasisMonetizedProxy is Mortal, DSMath {\n', '    FeeInterface fees;\n', '    \n', '    constructor(FeeInterface _fees) public {\n', '        fees = _fees;\n', '    }\n', '    \n', '    function setFeeAuthority(FeeInterface _fees) public auth {\n', '      fees = _fees;\n', '    }\n', '    \n', '    function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal {\n', '        wethToken.withdraw(wethAmt);\n', '        require(_to.call.value(wethAmt)()); \n', '  /* perform a call when sending ETH, in case the _to is a contract */\n', '    }\n', '\n', '    /*** Public functions start here ***/\n', '\n', '    function sellAllAmount(\n', '        OtcInterface otc,\n', '        TokenInterface payToken, \n', '        uint payAmt, \n', '        TokenInterface buyToken, \n', '        uint minBuyAmt\n', '    ) public returns (uint) {\n', '        require(payToken.transferFrom(msg.sender, this, payAmt));\n', '        if (payToken.allowance(this, otc) < payAmt) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        uint buyAmt = otc.sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder));\n', '        return buyAmtRemainder;\n', '    }\n', '\n', '    function sellAllAmountPayEth(\n', '        OtcInterface otc,\n', '        TokenInterface wethToken,\n', '        TokenInterface buyToken,\n', '        uint minBuyAmt\n', '    ) public payable returns (uint) {\n', '        wethToken.deposit.value(msg.value)();\n', '        if (wethToken.allowance(this, otc) < msg.value) {\n', '            wethToken.approve(otc, uint(-1));\n', '        }\n', '        uint buyAmt = otc.sellAllAmount(wethToken, msg.value, buyToken, minBuyAmt); \n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder));\n', '        return buyAmtRemainder;\n', '    }\n', '\n', '    function sellAllAmountBuyEth(\n', '        OtcInterface otc,\n', '        TokenInterface payToken, \n', '        uint payAmt, \n', '        TokenInterface wethToken, \n', '        uint minBuyAmt\n', '    ) public returns (uint) {\n', '        require(payToken.transferFrom(msg.sender, this, payAmt));\n', '        if (payToken.allowance(this, otc) < payAmt) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);\n', '        (uint feeAmt, uint wethAmtRemainder) = fees.takeFee(wethAmt, wethToken);\n', '        unwrapAndSend(wethToken, owner, feeAmt); /* fee is taken in ETH */ \n', '        unwrapAndSend(wethToken, msg.sender, wethAmtRemainder);\n', '        return wethAmtRemainder;\n', '    }\n', '\n', '    function buyAllAmount(\n', '        OtcInterface otc, \n', '        TokenInterface buyToken, \n', '        uint buyAmt, \n', '        TokenInterface payToken, \n', '        uint maxPayAmt\n', '    ) public returns (uint payAmt) {\n', '        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);\n', '        require(payAmtNow <= maxPayAmt);\n', '        require(payToken.transferFrom(msg.sender, this, payAmtNow));\n', '        if (payToken.allowance(this, otc) < payAmtNow) {\n', '            payToken.approve(otc, uint(-1));\n', '        } \n', '        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\n', '        buyAmt = min(buyAmt, buyToken.balanceOf(this));\n', '        /* To avoid rounding issues we check the minimum value */\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder)); \n', '    }\n', '\n', '    function buyAllAmountPayEth(\n', '        OtcInterface otc, \n', '        TokenInterface buyToken, \n', '        uint buyAmt, \n', '        TokenInterface wethToken\n', '    ) public payable returns (uint wethAmt) {\n', '        /* In this case client needs to send more ETH than a estimated \n', '           value, then contract will send back the rest */\n', '        wethToken.deposit.value(msg.value)();\n', '        if (wethToken.allowance(this, otc) < msg.value) {\n', '            wethToken.approve(otc, uint(-1));\n', '        }\n', '        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\n', '        buyAmt = min(buyAmt, buyToken.balanceOf(this));\n', '        /* To avoid rounding issues we check the minimum value */\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); \n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder)); \n', '        unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); /* return leftover eth */\n', '    }\n', '\n', '    function buyAllAmountBuyEth(\n', '        OtcInterface otc, \n', '        TokenInterface wethToken, \n', '        uint wethAmt, \n', '        TokenInterface payToken, \n', '        uint maxPayAmt\n', '    ) public returns (uint payAmt) {\n', '        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\n', '        require(payAmtNow <= maxPayAmt);\n', '        require(payToken.transferFrom(msg.sender, this, payAmtNow));\n', '        if (payToken.allowance(this, otc) < payAmtNow) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\n', '        (uint feeAmt, uint wethAmtRemainder) = fees.takeFee(wethAmt, wethToken);\n', '        unwrapAndSend(wethToken, owner, feeAmt);\n', '        unwrapAndSend(wethToken, msg.sender, wethAmtRemainder);\n', '    }\n', '\n', '    function() public payable {\n', '    /* fallback function. Revert ensures no ETH is sent to the contract by accident */\n', '         revert(); \n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*   \n', ' *    Exodus adaptation of OasisDirectProxy by MakerDAO.\n', ' */\n', '\n', 'contract OtcInterface {\n', '    function sellAllAmount(address, uint, address, uint) public returns (uint);\n', '    function buyAllAmount(address, uint, address, uint) public returns (uint);\n', '    function getPayAmount(address, address, uint) public constant returns (uint);\n', '}\n', '\n', 'contract TokenInterface {\n', '    function balanceOf(address) public returns (uint);\n', '    function allowance(address, address) public returns (uint);\n', '    function approve(address, uint) public;\n', '    function transfer(address,uint) public returns (bool);\n', '    function transferFrom(address, address, uint) public returns (bool);\n', '    function deposit() public payable;\n', '    function withdraw(uint) public;\n', '}\n', '\n', 'contract FeeInterface {\n', '    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Mortal is DSAuth {\n', '    function kill() public auth {\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function withdrawTo(address _to) public auth {\n', '    /* rescue all ETH */\n', '        require(_to.call.value(address(this).balance)());\n', '    }\n', '    \n', '    function withdrawTokenTo(TokenInterface token, address _to) public auth {\n', '    /* rescue all of a token */\n', '        require(token.transfer(_to, token.balanceOf(this)));\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract OasisMonetizedProxy is Mortal, DSMath {\n', '    FeeInterface fees;\n', '    \n', '    constructor(FeeInterface _fees) public {\n', '        fees = _fees;\n', '    }\n', '    \n', '    function setFeeAuthority(FeeInterface _fees) public auth {\n', '      fees = _fees;\n', '    }\n', '    \n', '    function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal {\n', '        wethToken.withdraw(wethAmt);\n', '        require(_to.call.value(wethAmt)()); \n', '  /* perform a call when sending ETH, in case the _to is a contract */\n', '    }\n', '\n', '    /*** Public functions start here ***/\n', '\n', '    function sellAllAmount(\n', '        OtcInterface otc,\n', '        TokenInterface payToken, \n', '        uint payAmt, \n', '        TokenInterface buyToken, \n', '        uint minBuyAmt\n', '    ) public returns (uint) {\n', '        require(payToken.transferFrom(msg.sender, this, payAmt));\n', '        if (payToken.allowance(this, otc) < payAmt) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        uint buyAmt = otc.sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder));\n', '        return buyAmtRemainder;\n', '    }\n', '\n', '    function sellAllAmountPayEth(\n', '        OtcInterface otc,\n', '        TokenInterface wethToken,\n', '        TokenInterface buyToken,\n', '        uint minBuyAmt\n', '    ) public payable returns (uint) {\n', '        wethToken.deposit.value(msg.value)();\n', '        if (wethToken.allowance(this, otc) < msg.value) {\n', '            wethToken.approve(otc, uint(-1));\n', '        }\n', '        uint buyAmt = otc.sellAllAmount(wethToken, msg.value, buyToken, minBuyAmt); \n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder));\n', '        return buyAmtRemainder;\n', '    }\n', '\n', '    function sellAllAmountBuyEth(\n', '        OtcInterface otc,\n', '        TokenInterface payToken, \n', '        uint payAmt, \n', '        TokenInterface wethToken, \n', '        uint minBuyAmt\n', '    ) public returns (uint) {\n', '        require(payToken.transferFrom(msg.sender, this, payAmt));\n', '        if (payToken.allowance(this, otc) < payAmt) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);\n', '        (uint feeAmt, uint wethAmtRemainder) = fees.takeFee(wethAmt, wethToken);\n', '        unwrapAndSend(wethToken, owner, feeAmt); /* fee is taken in ETH */ \n', '        unwrapAndSend(wethToken, msg.sender, wethAmtRemainder);\n', '        return wethAmtRemainder;\n', '    }\n', '\n', '    function buyAllAmount(\n', '        OtcInterface otc, \n', '        TokenInterface buyToken, \n', '        uint buyAmt, \n', '        TokenInterface payToken, \n', '        uint maxPayAmt\n', '    ) public returns (uint payAmt) {\n', '        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);\n', '        require(payAmtNow <= maxPayAmt);\n', '        require(payToken.transferFrom(msg.sender, this, payAmtNow));\n', '        if (payToken.allowance(this, otc) < payAmtNow) {\n', '            payToken.approve(otc, uint(-1));\n', '        } \n', '        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\n', '        buyAmt = min(buyAmt, buyToken.balanceOf(this));\n', '        /* To avoid rounding issues we check the minimum value */\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);\n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder)); \n', '    }\n', '\n', '    function buyAllAmountPayEth(\n', '        OtcInterface otc, \n', '        TokenInterface buyToken, \n', '        uint buyAmt, \n', '        TokenInterface wethToken\n', '    ) public payable returns (uint wethAmt) {\n', '        /* In this case client needs to send more ETH than a estimated \n', '           value, then contract will send back the rest */\n', '        wethToken.deposit.value(msg.value)();\n', '        if (wethToken.allowance(this, otc) < msg.value) {\n', '            wethToken.approve(otc, uint(-1));\n', '        }\n', '        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\n', '        buyAmt = min(buyAmt, buyToken.balanceOf(this));\n', '        /* To avoid rounding issues we check the minimum value */\n', '        (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); \n', '        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\n', '        require(buyToken.transfer(msg.sender, buyAmtRemainder)); \n', '        unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); /* return leftover eth */\n', '    }\n', '\n', '    function buyAllAmountBuyEth(\n', '        OtcInterface otc, \n', '        TokenInterface wethToken, \n', '        uint wethAmt, \n', '        TokenInterface payToken, \n', '        uint maxPayAmt\n', '    ) public returns (uint payAmt) {\n', '        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\n', '        require(payAmtNow <= maxPayAmt);\n', '        require(payToken.transferFrom(msg.sender, this, payAmtNow));\n', '        if (payToken.allowance(this, otc) < payAmtNow) {\n', '            payToken.approve(otc, uint(-1));\n', '        }\n', '        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\n', '        (uint feeAmt, uint wethAmtRemainder) = fees.takeFee(wethAmt, wethToken);\n', '        unwrapAndSend(wethToken, owner, feeAmt);\n', '        unwrapAndSend(wethToken, msg.sender, wethAmtRemainder);\n', '    }\n', '\n', '    function() public payable {\n', '    /* fallback function. Revert ensures no ETH is sent to the contract by accident */\n', '         revert(); \n', '    }\n', '}']
