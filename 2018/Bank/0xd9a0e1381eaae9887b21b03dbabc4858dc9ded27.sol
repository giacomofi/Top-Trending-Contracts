['pragma solidity 0.4.23;\n', '\n', '/*\n', '*DivvyUp for Goo\n', '*\n', '* ====================================================================*\n', '*&#39;||&#39;&#39;|.    ||                                    &#39;||&#39;  &#39;|&#39;         \n', '* ||   ||  ...  .... ... .... ... .... ...      ,  ||    |  ... ... \n', '* ||    ||  ||   &#39;|.  |   &#39;|.  |   &#39;|.  |  <>  /   ||    |   ||&#39;  ||\n', '* ||    ||  ||    &#39;|.|     &#39;|.|     &#39;|.|      /    ||    |   ||    |\n', '*.||...|&#39;  .||.    &#39;|       &#39;|       &#39;|      /      &#39;|..&#39;    ||...&#39; \n', '*                                 .. |      /                ||     \n', '*                                  &#39;&#39;      /  <>            &#39;&#39;&#39;&#39;    \n', '* =====================================================================*\n', '*\n', '* A wealth redistribution smart contract cleverly disguised as a ERC20 token.\n', '* Complete with a factory for making new verticals, and a fair launch contract\n', '* to ensure a fair launch.\n', '*\n', '*/\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public ownerCandidate;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        ownerCandidate = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == ownerCandidate);  \n', '        owner = ownerCandidate;\n', '    }\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract DivvyUpFactoryInterface {\n', '    function create(\n', '        bytes32 name, // Name of the DivvyUp\n', '        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\n', '        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\n', '        uint8 decimals, // Number of decimals the token has. Example: 18\n', '        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\n', '        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\n', '        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\n', '        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\n', '     )\n', '        public \n', '        returns(address);\n', '}\n', '\n', '\n', 'contract DivvyUpFactory is Owned {\n', '\n', '    event Create(\n', '        bytes32 name,\n', '        bytes32 symbol,\n', '        uint8 dividendDivisor,\n', '        uint8 decimals,\n', '        uint256 initialPrice,\n', '        uint256 incrementPrice,\n', '        uint256 magnitude,\n', '        address creator\n', '    );\n', '\n', '  \n', '    DivvyUp[] public registry;\n', '\n', '    function create(\n', '        bytes32 name, // Name of the DivvyUp\n', '        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\n', '        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\n', '        uint8 decimals, // Number of decimals the token has. Example: 18\n', '        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\n', '        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\n', '        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\n', '        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\n', '     )\n', '        public \n', '        returns(address)\n', '    {\n', '        DivvyUp divvyUp = new DivvyUp(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, counter);\n', '        divvyUp.changeOwner(msg.sender);\n', '        registry.push(divvyUp);\n', '        emit Create(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, msg.sender);\n', '        return divvyUp;\n', '    }\n', '\n', '    function die() onlyOwner public {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * Owner can transfer out any accidentally sent ERC20 tokens\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', 'contract DivvyUpInterface{\n', '    function purchaseTokens()\n', '        public\n', '        payable\n', '        returns(uint256);\n', '\n', '    function purchaseTokensERC20(uint256 amount)\n', '        public\n', '        returns(uint256);\n', '}\n', '\n', 'contract DivvyUp is ERC20Interface, Owned, DivvyUpInterface {\n', '    using SafeMath for uint256;\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyTokenHolders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with profits\n', '    modifier onlyDividendHolders() {\n', '        require(dividendDivisor > 0 && myDividends() > 0);\n', '        _;\n', '    }\n', '\n', '    modifier erc20Destination(){\n', '        require(counter != 0x0);\n', '        _;\n', '    }\n', '    \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event Purchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingCounter,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event Sell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 counterEarned\n', '    );\n', '    \n', '    event Reinvestment(\n', '        address indexed customerAddress,\n', '        uint256 counterReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event Withdraw(\n', '        address indexed customerAddress,\n', '        uint256 counterWithdrawn\n', '    ); \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint8  public dividendDivisor;\n', '    uint8 public decimals;// = 18;\n', '    uint256 public tokenPriceInitial;// = 0.0000001 ether;\n', '    uint256 public tokenPriceIncremental;// = 0.00000001 ether;\n', '    uint256 public magnitude;// = 2**64;\n', '    address counter;\n', '\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of tokens for each address\n', '    mapping(address => uint256) internal tokenBalanceLedger;\n', '    // amount of eth withdrawn\n', '    mapping(address => int256) internal payoutsTo;\n', '    // amount of tokens allowed to someone else \n', '    mapping(address => mapping(address => uint)) allowed;\n', '    // the actual amount of tokens\n', '    uint256 internal tokenSupply = 0;\n', '    // the amount of dividends per token\n', '    uint256 internal profitPerShare;\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /**\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    function DivvyUp(bytes32 aName, bytes32 aSymbol, uint8 aDividendDivisor, uint8 aDecimals, uint256 aTokenPriceInitial, uint256 aTokenPriceIncremental, uint256 aMagnitude, address aCounter) \n', '    public {\n', '        require(aDividendDivisor < 100);\n', '        name = aName;\n', '        symbol = aSymbol;\n', '        dividendDivisor = aDividendDivisor;\n', '        decimals = aDecimals;\n', '        tokenPriceInitial = aTokenPriceInitial;\n', '        tokenPriceIncremental = aTokenPriceIncremental;\n', '        magnitude = aMagnitude;\n', '        counter = aCounter;    \n', '    }\n', '    \n', '    /**\n', '     * Allows the owner to change the name of the contract\n', '     */\n', '    function changeName(bytes32 newName) onlyOwner() public {\n', '        name = newName;\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Allows the owner to change the symbol of the contract\n', '     */\n', '    function changeSymbol(bytes32 newSymbol) onlyOwner() public {\n', '        symbol = newSymbol;\n', '    }\n', '    \n', '    /**\n', '     * Converts all incoming counter to tokens for the caller\n', '     */\n', '    function purchaseTokens()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        if(msg.value > 0){\n', '            require(counter == 0x0);\n', '        }\n', '        return purchaseTokens(msg.value);\n', '    }\n', '    \n', '\n', '    /**\n', '     * Converts all incoming counter to tokens for the caller\n', '     */\n', '    function purchaseTokensERC20(uint256 amount)\n', '        public\n', '        erc20Destination\n', '        returns(uint256)\n', '    {\n', '        require(ERC20Interface(counter).transferFrom(msg.sender, this, amount));\n', '        return purchaseTokens(amount);\n', '    }\n', '\n', '\n', '        /**\n', '     * Fallback function to handle counter that was send straight to the contract.\n', '     * Causes tokens to be purchased.\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        if(msg.value > 0){\n', '            require(counter == 0x0);\n', '        }\n', '        purchaseTokens(msg.value);\n', '    }\n', '    \n', '     \n', '    /**\n', '     * Converts all of caller&#39;s dividends to tokens.\n', '     */\n', '    function reinvestDividends()\n', '        onlyDividendHolders()\n', '        public\n', '        returns (uint256)\n', '    {\n', '        // fetch dividends\n', '        uint256 dividends = myDividends(); \n', '       \n', '        // pay out the dividends virtually\n', '        address customerAddress = msg.sender;\n', '        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends" if we have dividends\n', '        uint256 tokens = purchaseTokens(dividends);\n', '        \n', '        // fire event\n', '        emit Reinvestment(customerAddress, dividends, tokens);\n', '        \n', '        return tokens;\n', '    }\n', '    \n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit()\n', '        public\n', '    {\n', '        // get token count for caller & sell them all\n', '        address customerAddress = msg.sender;\n', '        uint256 tokens = tokenBalanceLedger[customerAddress];\n', '        if(tokens > 0) {\n', '            sell(tokens);\n', '        }\n', '        // lambo delivery service\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        onlyDividendHolders()\n', '        public\n', '    {\n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        uint256 dividends = myDividends(); \n', '\n', '        // update dividend tracker\n', '        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\n', '                \n', '        // fire event\n', '        emit Withdraw(customerAddress, dividends);\n', '    }\n', '    \n', '    /**\n', '     * Liquifies tokens to counter.\n', '     */\n', '    function sell(uint256 amountOfTokens)\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require(amountOfTokens > 0);\n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        // russian hackers BTFO\n', '        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\n', '        uint256 tokens = amountOfTokens;\n', '        uint256 counterAmount = tokensToCounter(tokens);\n', '        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(counterAmount, dividendDivisor) : 0;\n', '        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '        \n', '        // burn the sold tokens\n', '        tokenSupply = SafeMath.sub(tokenSupply, tokens);\n', '        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], tokens);\n', '        \n', '        // update dividends tracker\n', '        int256 updatedPayouts = (int256) (profitPerShare * tokens + (taxedCounter * magnitude));\n', '        payoutsTo[customerAddress] -= updatedPayouts;       \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply > 0 && dividendDivisor > 0) {\n', '            // update the amount of dividends per token\n', '            profitPerShare = SafeMath.add(profitPerShare, (dividends * magnitude) / tokenSupply);\n', '        }\n', '        \n', '        // fire event\n', '        emit Sell(customerAddress, tokens, taxedCounter);\n', '    }\n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     * Transfering ownership of tokens requires settling outstanding dividends\n', '     * and transfering them back. You can therefore send 0 tokens to this contract to\n', '     * trigger your withdraw.\n', '     */\n', '    function transfer(address toAddress, uint256 amountOfTokens)\n', '        onlyTokenHolders\n', '        public\n', '        returns(bool)\n', '    {\n', '\n', '       // Sell on transfer in instad of transfering to\n', '        if(toAddress == address(this)){\n', '            // If we sent in tokens, destroy them and credit their account with ETH\n', '            if(amountOfTokens > 0){\n', '                sell(amountOfTokens);\n', '            }\n', '            // Send them their ETH\n', '            withdraw();\n', '            // fire event\n', '            emit Transfer(0x0, msg.sender, amountOfTokens);\n', '\n', '            return true;\n', '        }\n', '       \n', '        // Deal with outstanding dividends first\n', '        if(myDividends() > 0) {\n', '            withdraw();\n', '        }\n', '        \n', '        return _transfer(toAddress, amountOfTokens);\n', '    }\n', '\n', '    function transferWithDividends(address toAddress, uint256 amountOfTokens) public onlyTokenHolders returns (bool) {\n', '        return _transfer(toAddress, amountOfTokens);\n', '    }\n', '\n', '    function _transfer(address toAddress, uint256 amountOfTokens)\n', '        internal\n', '        onlyTokenHolders\n', '        returns(bool)\n', '    {\n', '        // setup\n', '        address customerAddress = msg.sender;\n', '        \n', '        // make sure we have the requested tokens\n', '        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\n', '       \n', '        // exchange tokens\n', '        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], amountOfTokens);\n', '        tokenBalanceLedger[toAddress] = SafeMath.add(tokenBalanceLedger[toAddress], amountOfTokens);\n', '        \n', '        // fire event\n', '        emit Transfer(customerAddress, toAddress, amountOfTokens);\n', '\n', '\n', '        return true;\n', '       \n', '    }\n', '\n', '    // ERC20 \n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * Transfer `tokens` from the `from` account to the `to` account\n', '    * \n', '    * The calling account must already have sufficient tokens approve(...)-d\n', '    * for spending from the `from` account and\n', '    * - From account must have sufficient balance to transfer\n', '    * - Spender must have sufficient allowance to transfer\n', '    * - 0 value transfers are allowed\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        tokenBalanceLedger[from] = tokenBalanceLedger[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        tokenBalanceLedger[to] = tokenBalanceLedger[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Returns the amount of tokens approved by the owner that can be\n', '    * transferred to the spender&#39;s account\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '    * Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    * from the token owner&#39;s account. The `spender` contract function\n', '    * `receiveApproval(...)` is then executed\n', '    * \n', '    */\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Counter stored in the contract\n', '     * Example: totalDestinationBalance()\n', '     */\n', '    function totalDestinationBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if(counter == 0x0){\n', '            return address(this).balance;\n', '        } else {\n', '            return ERC20Interface(counter).balanceOf(this);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the name of the token.\n', '     */\n', '    function name() \n', '        public \n', '        view \n', '        returns(bytes32)\n', '    {\n', '        return name;\n', '    }\n', '     \n', '\n', '    /**\n', '     * Retrieve the symbol of the token.\n', '     */\n', '    function symbol() \n', '        public\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return symbol;\n', '    }\n', '     \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address customerAddress = msg.sender;\n', '        return balanceOf(customerAddress);\n', '    }\n', '    \n', '    /**\n', '    * Retrieve the dividends owned by the caller.\n', '    */\n', '\n', '    function myDividends() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        address customerAddress = msg.sender;\n', '\n', '        return (uint256) ((int256)(profitPerShare * tokenBalanceLedger[customerAddress]) - payoutsTo[customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger[customerAddress];\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Return the buy price of 1 individual token.\n', '     */\n', '    function sellPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply == 0){\n', '            return tokenPriceInitial - tokenPriceIncremental;\n', '        } else {\n', '            uint256 counterAmount = tokensToCounter(1e18);\n', '            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '            uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '            return taxedCounter;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Return the sell price of 1 individual token.\n', '     */\n', '    function buyPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply == 0){\n', '            return tokenPriceInitial + tokenPriceIncremental;\n', '        } else {\n', '            uint256 counterAmount = tokensToCounter(1e18);\n', '            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '            uint256 taxedCounter = SafeMath.add(counterAmount, dividends);\n', '            return taxedCounter;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 counterToSpend) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 dividends = SafeMath.div(counterToSpend, dividendDivisor);\n', '        uint256 taxedCounter = SafeMath.sub(counterToSpend, dividends);\n', '        uint256 amountOfTokens = counterToTokens(taxedCounter);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '     */\n', '    function calculateCounterReceived(uint256 tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(tokensToSell <= tokenSupply);\n', '        uint256 counterAmount = tokensToCounter(tokensToSell);\n', '        uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '        return taxedCounter;\n', '    }\n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 incomingCounter)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        if(incomingCounter == 0){\n', '            return reinvestDividends();\n', '        }\n', '\n', '\n', '        \n', '        // book keeping\n', '        address customerAddress = msg.sender;\n', '//     uint256 undividedDividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\n', '//this was ref bonus \n', '        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\n', '        uint256 taxedCounter = SafeMath.sub(incomingCounter, dividends);\n', '        uint256 amountOfTokens = counterToTokens(taxedCounter);\n', '        uint256 fee = dividends * magnitude;\n', ' \n', '        // prevents overflow\n', '        assert(amountOfTokens > 0 && (SafeMath.add(amountOfTokens,tokenSupply) > tokenSupply));\n', '               \n', '        // Start making sure we can do the math. No token holders means no dividends, yet.\n', '        if(tokenSupply > 0){\n', '            \n', '            // add tokens to the pool\n', '            tokenSupply = SafeMath.add(tokenSupply, amountOfTokens);\n', ' \n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare += (dividends * magnitude / (tokenSupply));\n', '            \n', '            // calculate the amount of tokens the customer receives \n', '            fee = dividendDivisor > 0 ? fee - (fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)))) : 0x0;\n', '        \n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply = amountOfTokens;\n', '        }\n', '        \n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger[customerAddress] = SafeMath.add(tokenBalanceLedger[customerAddress], amountOfTokens);\n', '        \n', '        // Tells the contract that the buyer doesn&#39;t deserve dividends for the tokens before they owned them\n', '        int256 updatedPayouts = (int256) ((profitPerShare * amountOfTokens) - fee);\n', '        payoutsTo[customerAddress] += updatedPayouts;\n', '        \n', '        // fire events\n', '        emit Purchase(customerAddress, incomingCounter, amountOfTokens);\n', '        emit Transfer(0x0, customerAddress, amountOfTokens);\n', '        return amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming counter\n', '     */\n', '    function counterToTokens(uint256 counterAmount)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 tokenPrice = tokenPriceInitial * 1e18;\n', '        uint256 tokensReceived = ((SafeMath.sub((sqrt((tokenPrice**2)+(2*(tokenPriceIncremental * 1e18)*(counterAmount * 1e18))+(((tokenPriceIncremental)**2)*(tokenSupply**2))+(2*(tokenPriceIncremental)*tokenPrice*tokenSupply))), tokenPrice))/(tokenPriceIncremental))-(tokenSupply);  \n', '        return tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * Calculate token sell value.\n', '     */\n', '    function tokensToCounter(uint256 tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 theTokens = (tokens + 1e18);\n', '        uint256 theTokenSupply = (tokenSupply + 1e18);\n', '        // underflow attempts BTFO\n', '        uint256 etherReceived = (SafeMath.sub((((tokenPriceInitial + (tokenPriceIncremental * (theTokenSupply/1e18)))-tokenPriceIncremental)*(theTokens - 1e18)),(tokenPriceIncremental*((theTokens**2-theTokens)/1e18))/2)/1e18);\n', '        return etherReceived;\n', '    }\n', '    \n', '    //This is where all your gas goes, sorry\n', '    //Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Owner can transfer out any accidentally sent ERC20 tokens\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        require(tokenAddress != counter);\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '/*\n', '*DivvyUp for Goo\n', '*\n', '* ====================================================================*\n', "*'||''|.    ||                                    '||'  '|'         \n", '* ||   ||  ...  .... ... .... ... .... ...      ,  ||    |  ... ... \n', "* ||    ||  ||   '|.  |   '|.  |   '|.  |  <>  /   ||    |   ||'  ||\n", "* ||    ||  ||    '|.|     '|.|     '|.|      /    ||    |   ||    |\n", "*.||...|'  .||.    '|       '|       '|      /      '|..'    ||...' \n", '*                                 .. |      /                ||     \n', "*                                  ''      /  <>            ''''    \n", '* =====================================================================*\n', '*\n', '* A wealth redistribution smart contract cleverly disguised as a ERC20 token.\n', '* Complete with a factory for making new verticals, and a fair launch contract\n', '* to ensure a fair launch.\n', '*\n', '*/\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public ownerCandidate;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        ownerCandidate = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == ownerCandidate);  \n', '        owner = ownerCandidate;\n', '    }\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract DivvyUpFactoryInterface {\n', '    function create(\n', '        bytes32 name, // Name of the DivvyUp\n', '        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\n', '        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\n', '        uint8 decimals, // Number of decimals the token has. Example: 18\n', '        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\n', '        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\n', '        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\n', '        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\n', '     )\n', '        public \n', '        returns(address);\n', '}\n', '\n', '\n', 'contract DivvyUpFactory is Owned {\n', '\n', '    event Create(\n', '        bytes32 name,\n', '        bytes32 symbol,\n', '        uint8 dividendDivisor,\n', '        uint8 decimals,\n', '        uint256 initialPrice,\n', '        uint256 incrementPrice,\n', '        uint256 magnitude,\n', '        address creator\n', '    );\n', '\n', '  \n', '    DivvyUp[] public registry;\n', '\n', '    function create(\n', '        bytes32 name, // Name of the DivvyUp\n', '        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\n', '        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\n', '        uint8 decimals, // Number of decimals the token has. Example: 18\n', '        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\n', '        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\n', '        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\n', '        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\n', '     )\n', '        public \n', '        returns(address)\n', '    {\n', '        DivvyUp divvyUp = new DivvyUp(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, counter);\n', '        divvyUp.changeOwner(msg.sender);\n', '        registry.push(divvyUp);\n', '        emit Create(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, msg.sender);\n', '        return divvyUp;\n', '    }\n', '\n', '    function die() onlyOwner public {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * Owner can transfer out any accidentally sent ERC20 tokens\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', 'contract DivvyUpInterface{\n', '    function purchaseTokens()\n', '        public\n', '        payable\n', '        returns(uint256);\n', '\n', '    function purchaseTokensERC20(uint256 amount)\n', '        public\n', '        returns(uint256);\n', '}\n', '\n', 'contract DivvyUp is ERC20Interface, Owned, DivvyUpInterface {\n', '    using SafeMath for uint256;\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyTokenHolders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with profits\n', '    modifier onlyDividendHolders() {\n', '        require(dividendDivisor > 0 && myDividends() > 0);\n', '        _;\n', '    }\n', '\n', '    modifier erc20Destination(){\n', '        require(counter != 0x0);\n', '        _;\n', '    }\n', '    \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event Purchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingCounter,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event Sell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 counterEarned\n', '    );\n', '    \n', '    event Reinvestment(\n', '        address indexed customerAddress,\n', '        uint256 counterReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event Withdraw(\n', '        address indexed customerAddress,\n', '        uint256 counterWithdrawn\n', '    ); \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint8  public dividendDivisor;\n', '    uint8 public decimals;// = 18;\n', '    uint256 public tokenPriceInitial;// = 0.0000001 ether;\n', '    uint256 public tokenPriceIncremental;// = 0.00000001 ether;\n', '    uint256 public magnitude;// = 2**64;\n', '    address counter;\n', '\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of tokens for each address\n', '    mapping(address => uint256) internal tokenBalanceLedger;\n', '    // amount of eth withdrawn\n', '    mapping(address => int256) internal payoutsTo;\n', '    // amount of tokens allowed to someone else \n', '    mapping(address => mapping(address => uint)) allowed;\n', '    // the actual amount of tokens\n', '    uint256 internal tokenSupply = 0;\n', '    // the amount of dividends per token\n', '    uint256 internal profitPerShare;\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /**\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    function DivvyUp(bytes32 aName, bytes32 aSymbol, uint8 aDividendDivisor, uint8 aDecimals, uint256 aTokenPriceInitial, uint256 aTokenPriceIncremental, uint256 aMagnitude, address aCounter) \n', '    public {\n', '        require(aDividendDivisor < 100);\n', '        name = aName;\n', '        symbol = aSymbol;\n', '        dividendDivisor = aDividendDivisor;\n', '        decimals = aDecimals;\n', '        tokenPriceInitial = aTokenPriceInitial;\n', '        tokenPriceIncremental = aTokenPriceIncremental;\n', '        magnitude = aMagnitude;\n', '        counter = aCounter;    \n', '    }\n', '    \n', '    /**\n', '     * Allows the owner to change the name of the contract\n', '     */\n', '    function changeName(bytes32 newName) onlyOwner() public {\n', '        name = newName;\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Allows the owner to change the symbol of the contract\n', '     */\n', '    function changeSymbol(bytes32 newSymbol) onlyOwner() public {\n', '        symbol = newSymbol;\n', '    }\n', '    \n', '    /**\n', '     * Converts all incoming counter to tokens for the caller\n', '     */\n', '    function purchaseTokens()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        if(msg.value > 0){\n', '            require(counter == 0x0);\n', '        }\n', '        return purchaseTokens(msg.value);\n', '    }\n', '    \n', '\n', '    /**\n', '     * Converts all incoming counter to tokens for the caller\n', '     */\n', '    function purchaseTokensERC20(uint256 amount)\n', '        public\n', '        erc20Destination\n', '        returns(uint256)\n', '    {\n', '        require(ERC20Interface(counter).transferFrom(msg.sender, this, amount));\n', '        return purchaseTokens(amount);\n', '    }\n', '\n', '\n', '        /**\n', '     * Fallback function to handle counter that was send straight to the contract.\n', '     * Causes tokens to be purchased.\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        if(msg.value > 0){\n', '            require(counter == 0x0);\n', '        }\n', '        purchaseTokens(msg.value);\n', '    }\n', '    \n', '     \n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    function reinvestDividends()\n', '        onlyDividendHolders()\n', '        public\n', '        returns (uint256)\n', '    {\n', '        // fetch dividends\n', '        uint256 dividends = myDividends(); \n', '       \n', '        // pay out the dividends virtually\n', '        address customerAddress = msg.sender;\n', '        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends" if we have dividends\n', '        uint256 tokens = purchaseTokens(dividends);\n', '        \n', '        // fire event\n', '        emit Reinvestment(customerAddress, dividends, tokens);\n', '        \n', '        return tokens;\n', '    }\n', '    \n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit()\n', '        public\n', '    {\n', '        // get token count for caller & sell them all\n', '        address customerAddress = msg.sender;\n', '        uint256 tokens = tokenBalanceLedger[customerAddress];\n', '        if(tokens > 0) {\n', '            sell(tokens);\n', '        }\n', '        // lambo delivery service\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        onlyDividendHolders()\n', '        public\n', '    {\n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        uint256 dividends = myDividends(); \n', '\n', '        // update dividend tracker\n', '        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\n', '                \n', '        // fire event\n', '        emit Withdraw(customerAddress, dividends);\n', '    }\n', '    \n', '    /**\n', '     * Liquifies tokens to counter.\n', '     */\n', '    function sell(uint256 amountOfTokens)\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require(amountOfTokens > 0);\n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        // russian hackers BTFO\n', '        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\n', '        uint256 tokens = amountOfTokens;\n', '        uint256 counterAmount = tokensToCounter(tokens);\n', '        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(counterAmount, dividendDivisor) : 0;\n', '        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '        \n', '        // burn the sold tokens\n', '        tokenSupply = SafeMath.sub(tokenSupply, tokens);\n', '        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], tokens);\n', '        \n', '        // update dividends tracker\n', '        int256 updatedPayouts = (int256) (profitPerShare * tokens + (taxedCounter * magnitude));\n', '        payoutsTo[customerAddress] -= updatedPayouts;       \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply > 0 && dividendDivisor > 0) {\n', '            // update the amount of dividends per token\n', '            profitPerShare = SafeMath.add(profitPerShare, (dividends * magnitude) / tokenSupply);\n', '        }\n', '        \n', '        // fire event\n', '        emit Sell(customerAddress, tokens, taxedCounter);\n', '    }\n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     * Transfering ownership of tokens requires settling outstanding dividends\n', '     * and transfering them back. You can therefore send 0 tokens to this contract to\n', '     * trigger your withdraw.\n', '     */\n', '    function transfer(address toAddress, uint256 amountOfTokens)\n', '        onlyTokenHolders\n', '        public\n', '        returns(bool)\n', '    {\n', '\n', '       // Sell on transfer in instad of transfering to\n', '        if(toAddress == address(this)){\n', '            // If we sent in tokens, destroy them and credit their account with ETH\n', '            if(amountOfTokens > 0){\n', '                sell(amountOfTokens);\n', '            }\n', '            // Send them their ETH\n', '            withdraw();\n', '            // fire event\n', '            emit Transfer(0x0, msg.sender, amountOfTokens);\n', '\n', '            return true;\n', '        }\n', '       \n', '        // Deal with outstanding dividends first\n', '        if(myDividends() > 0) {\n', '            withdraw();\n', '        }\n', '        \n', '        return _transfer(toAddress, amountOfTokens);\n', '    }\n', '\n', '    function transferWithDividends(address toAddress, uint256 amountOfTokens) public onlyTokenHolders returns (bool) {\n', '        return _transfer(toAddress, amountOfTokens);\n', '    }\n', '\n', '    function _transfer(address toAddress, uint256 amountOfTokens)\n', '        internal\n', '        onlyTokenHolders\n', '        returns(bool)\n', '    {\n', '        // setup\n', '        address customerAddress = msg.sender;\n', '        \n', '        // make sure we have the requested tokens\n', '        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\n', '       \n', '        // exchange tokens\n', '        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], amountOfTokens);\n', '        tokenBalanceLedger[toAddress] = SafeMath.add(tokenBalanceLedger[toAddress], amountOfTokens);\n', '        \n', '        // fire event\n', '        emit Transfer(customerAddress, toAddress, amountOfTokens);\n', '\n', '\n', '        return true;\n', '       \n', '    }\n', '\n', '    // ERC20 \n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * Transfer `tokens` from the `from` account to the `to` account\n', '    * \n', '    * The calling account must already have sufficient tokens approve(...)-d\n', '    * for spending from the `from` account and\n', '    * - From account must have sufficient balance to transfer\n', '    * - Spender must have sufficient allowance to transfer\n', '    * - 0 value transfers are allowed\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        tokenBalanceLedger[from] = tokenBalanceLedger[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        tokenBalanceLedger[to] = tokenBalanceLedger[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Returns the amount of tokens approved by the owner that can be\n', "    * transferred to the spender's account\n", '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '    * Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    * from the token owner's account. The `spender` contract function\n", '    * `receiveApproval(...)` is then executed\n', '    * \n', '    */\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Counter stored in the contract\n', '     * Example: totalDestinationBalance()\n', '     */\n', '    function totalDestinationBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if(counter == 0x0){\n', '            return address(this).balance;\n', '        } else {\n', '            return ERC20Interface(counter).balanceOf(this);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the name of the token.\n', '     */\n', '    function name() \n', '        public \n', '        view \n', '        returns(bytes32)\n', '    {\n', '        return name;\n', '    }\n', '     \n', '\n', '    /**\n', '     * Retrieve the symbol of the token.\n', '     */\n', '    function symbol() \n', '        public\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return symbol;\n', '    }\n', '     \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address customerAddress = msg.sender;\n', '        return balanceOf(customerAddress);\n', '    }\n', '    \n', '    /**\n', '    * Retrieve the dividends owned by the caller.\n', '    */\n', '\n', '    function myDividends() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        address customerAddress = msg.sender;\n', '\n', '        return (uint256) ((int256)(profitPerShare * tokenBalanceLedger[customerAddress]) - payoutsTo[customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger[customerAddress];\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Return the buy price of 1 individual token.\n', '     */\n', '    function sellPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply == 0){\n', '            return tokenPriceInitial - tokenPriceIncremental;\n', '        } else {\n', '            uint256 counterAmount = tokensToCounter(1e18);\n', '            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '            uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '            return taxedCounter;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Return the sell price of 1 individual token.\n', '     */\n', '    function buyPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply == 0){\n', '            return tokenPriceInitial + tokenPriceIncremental;\n', '        } else {\n', '            uint256 counterAmount = tokensToCounter(1e18);\n', '            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '            uint256 taxedCounter = SafeMath.add(counterAmount, dividends);\n', '            return taxedCounter;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 counterToSpend) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 dividends = SafeMath.div(counterToSpend, dividendDivisor);\n', '        uint256 taxedCounter = SafeMath.sub(counterToSpend, dividends);\n', '        uint256 amountOfTokens = counterToTokens(taxedCounter);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '     */\n', '    function calculateCounterReceived(uint256 tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(tokensToSell <= tokenSupply);\n', '        uint256 counterAmount = tokensToCounter(tokensToSell);\n', '        uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\n', '        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\n', '        return taxedCounter;\n', '    }\n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 incomingCounter)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        if(incomingCounter == 0){\n', '            return reinvestDividends();\n', '        }\n', '\n', '\n', '        \n', '        // book keeping\n', '        address customerAddress = msg.sender;\n', '//     uint256 undividedDividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\n', '//this was ref bonus \n', '        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\n', '        uint256 taxedCounter = SafeMath.sub(incomingCounter, dividends);\n', '        uint256 amountOfTokens = counterToTokens(taxedCounter);\n', '        uint256 fee = dividends * magnitude;\n', ' \n', '        // prevents overflow\n', '        assert(amountOfTokens > 0 && (SafeMath.add(amountOfTokens,tokenSupply) > tokenSupply));\n', '               \n', '        // Start making sure we can do the math. No token holders means no dividends, yet.\n', '        if(tokenSupply > 0){\n', '            \n', '            // add tokens to the pool\n', '            tokenSupply = SafeMath.add(tokenSupply, amountOfTokens);\n', ' \n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare += (dividends * magnitude / (tokenSupply));\n', '            \n', '            // calculate the amount of tokens the customer receives \n', '            fee = dividendDivisor > 0 ? fee - (fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)))) : 0x0;\n', '        \n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply = amountOfTokens;\n', '        }\n', '        \n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger[customerAddress] = SafeMath.add(tokenBalanceLedger[customerAddress], amountOfTokens);\n', '        \n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them\n", '        int256 updatedPayouts = (int256) ((profitPerShare * amountOfTokens) - fee);\n', '        payoutsTo[customerAddress] += updatedPayouts;\n', '        \n', '        // fire events\n', '        emit Purchase(customerAddress, incomingCounter, amountOfTokens);\n', '        emit Transfer(0x0, customerAddress, amountOfTokens);\n', '        return amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming counter\n', '     */\n', '    function counterToTokens(uint256 counterAmount)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 tokenPrice = tokenPriceInitial * 1e18;\n', '        uint256 tokensReceived = ((SafeMath.sub((sqrt((tokenPrice**2)+(2*(tokenPriceIncremental * 1e18)*(counterAmount * 1e18))+(((tokenPriceIncremental)**2)*(tokenSupply**2))+(2*(tokenPriceIncremental)*tokenPrice*tokenSupply))), tokenPrice))/(tokenPriceIncremental))-(tokenSupply);  \n', '        return tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * Calculate token sell value.\n', '     */\n', '    function tokensToCounter(uint256 tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 theTokens = (tokens + 1e18);\n', '        uint256 theTokenSupply = (tokenSupply + 1e18);\n', '        // underflow attempts BTFO\n', '        uint256 etherReceived = (SafeMath.sub((((tokenPriceInitial + (tokenPriceIncremental * (theTokenSupply/1e18)))-tokenPriceIncremental)*(theTokens - 1e18)),(tokenPriceIncremental*((theTokens**2-theTokens)/1e18))/2)/1e18);\n', '        return etherReceived;\n', '    }\n', '    \n', '    //This is where all your gas goes, sorry\n', '    //Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Owner can transfer out any accidentally sent ERC20 tokens\n', '    * \n', '    * Implementation taken from ERC20 reference\n', '    * \n', '    */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        require(tokenAddress != counter);\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
