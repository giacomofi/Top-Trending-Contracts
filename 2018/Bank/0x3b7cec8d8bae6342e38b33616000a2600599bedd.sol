['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    uint8 public decimals;\n', '    string public name;\n', '}\n', '\n', '\n', 'contract StandardToken is Token {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract ReserveToken is StandardToken, SafeMath {\n', '\n', '    address public minter;\n', '\n', '    constructor() public {\n', '        minter = msg.sender;\n', '    }\n', '\n', '    function create(address account, uint amount) public {\n', '        if (msg.sender != minter) revert();\n', '        balances[account] = safeAdd(balances[account], amount);\n', '        totalSupply = safeAdd(totalSupply, amount);\n', '    }\n', '\n', '    function destroy(address account, uint amount) public {\n', '        if (msg.sender != minter) revert();\n', '        if (balances[account] < amount) revert();\n', '        balances[account] = safeSub(balances[account], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '    }\n', '}\n', '\n', '\n', 'contract AccountLevels {\n', '    //given a user, returns an account level\n', '    //0 = regular user (pays take fee and make fee)\n', '    //1 = market maker silver (pays take fee, no make fee, gets rebate)\n', '    //2 = market maker gold (pays take fee, no make fee, gets entire counterparty&#39;s take fee as rebate)\n', '    function accountLevel(address user) public constant returns(uint);\n', '}\n', '\n', '\n', 'contract AccountLevelsTest is AccountLevels {\n', '\n', '    mapping (address => uint) public accountLevels;\n', '\n', '    function setAccountLevel(address user, uint level) public {\n', '        accountLevels[user] = level;\n', '    }\n', '\n', '    function accountLevel(address user) public constant returns(uint) {\n', '        return accountLevels[user];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GenevExch is SafeMath {\n', '\n', '    address public admin; //the admin address\n', '    address public feeAccount; //the account that will receive fees\n', '    address public accountLevelsAddr; //the address of the AccountLevels contract\n', '    uint public feeMake; //percentage times (1 ether)\n', '    uint public feeTake; //percentage times (1 ether)\n', '    uint public feeRebate; //percentage times (1 ether)\n', '    mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '    mapping (address => bool) public whiteListERC20;\n', '    mapping (address => bool) public whiteListERC223;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    \n', '    modifier onlyAdmin() {\n', '        require(msg.sender==admin);\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '\n', '    constructor(\n', '        address admin_, \n', '        address feeAccount_, \n', '        address accountLevelsAddr_, \n', '        uint feeMake_, \n', '        uint feeTake_, \n', '        uint feeRebate_) public {\n', '\n', '        admin = admin_;\n', '        feeAccount = feeAccount_;\n', '        accountLevelsAddr = accountLevelsAddr_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '        feeRebate = feeRebate_;\n', '    }\n', '\n', '    function() public {\n', '        revert();\n', '    }\n', '\n', '    // Admin functions\n', '\n', '    function changeAdmin(address admin_) public onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeAccountLevelsAddr(address accountLevelsAddr_) public onlyAdmin {\n', '        accountLevelsAddr = accountLevelsAddr_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) public onlyAdmin {\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) public onlyAdmin {\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) public onlyAdmin {\n', '        if (feeTake_ < feeRebate) revert();\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function changeFeeRebate(uint feeRebate_) public onlyAdmin {\n', '        if (feeRebate_ > feeTake) revert();\n', '        feeRebate = feeRebate_;\n', '    }\n', '\n', '    // Whitelists for ERC20 or ERC223 tokens\n', '\n', '    function setBlackListERC20(address _token) public onlyAdmin {\n', '        whiteListERC20[_token] = false;\n', '    }\n', '    function setWhiteListERC20(address _token) public onlyAdmin {\n', '        whiteListERC20[_token] = true;\n', '    }\n', '    function setBlackListERC223(address _token) public onlyAdmin {\n', '        whiteListERC223[_token] = false;\n', '    }\n', '    function setWhiteListERC223(address _token) public onlyAdmin {\n', '        whiteListERC223[_token] = true;\n', '    }\n', '\n', '    // Public functions\n', '\n', '    function deposit() public payable { // Deposit Ethers\n', '        tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function tokenFallback(address _from, uint _value, bytes _data) public { // Deposit ERC223 tokens\n', '        if (_value==0) revert();\n', '        require(whiteListERC223[msg.sender]);\n', '        tokens[msg.sender][_from] = safeAdd(tokens[msg.sender][_from], _value);\n', '        emit Deposit(msg.sender, _from, _value, tokens[msg.sender][_from]);\n', '     }\n', '\n', '    function depositToken(address token, uint amount) public { // Deposit ERC20 tokens\n', '        if (amount==0) revert();\n', '        require(whiteListERC20[token]);\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) revert();\n', '        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) public { // Withdraw ethers\n', '        if (tokens[0][msg.sender] < amount) revert();\n', '        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '        msg.sender.transfer(amount);\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) public { // Withdraw tokens\n', '        require(whiteListERC20[token] || whiteListERC223[token]);\n', '        if (tokens[token][msg.sender] < amount) revert();\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        require (Token(token).transfer(msg.sender, amount));\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) public constant returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    // Exchange specific functions\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        orders[msg.sender][hash] = true;\n', '        emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '        //amount is in amountGet terms\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '            block.number <= expires &&\n', '            safeAdd(orderFills[user][hash], amount) <= amountGet\n', '        )) revert();\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n', '        emit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n', '        uint feeRebateXfer = 0;\n', '\n', '        if (accountLevelsAddr != 0x0) {\n', '            uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n', '            if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n', '            if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n', '        }\n', '\n', '        tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n', '        tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n', '        if (!(\n', '            tokens[tokenGet][sender] >= amount &&\n', '            availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '        )) return false;\n', '        return true;\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '            block.number <= expires\n', '        )) return 0;\n', '        uint available1 = safeSub(amountGet, orderFills[user][hash]);\n', '        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1 < available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) public constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(orders[msg.sender][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == msg.sender)) revert();\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    uint8 public decimals;\n', '    string public name;\n', '}\n', '\n', '\n', 'contract StandardToken is Token {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract ReserveToken is StandardToken, SafeMath {\n', '\n', '    address public minter;\n', '\n', '    constructor() public {\n', '        minter = msg.sender;\n', '    }\n', '\n', '    function create(address account, uint amount) public {\n', '        if (msg.sender != minter) revert();\n', '        balances[account] = safeAdd(balances[account], amount);\n', '        totalSupply = safeAdd(totalSupply, amount);\n', '    }\n', '\n', '    function destroy(address account, uint amount) public {\n', '        if (msg.sender != minter) revert();\n', '        if (balances[account] < amount) revert();\n', '        balances[account] = safeSub(balances[account], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '    }\n', '}\n', '\n', '\n', 'contract AccountLevels {\n', '    //given a user, returns an account level\n', '    //0 = regular user (pays take fee and make fee)\n', '    //1 = market maker silver (pays take fee, no make fee, gets rebate)\n', "    //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\n", '    function accountLevel(address user) public constant returns(uint);\n', '}\n', '\n', '\n', 'contract AccountLevelsTest is AccountLevels {\n', '\n', '    mapping (address => uint) public accountLevels;\n', '\n', '    function setAccountLevel(address user, uint level) public {\n', '        accountLevels[user] = level;\n', '    }\n', '\n', '    function accountLevel(address user) public constant returns(uint) {\n', '        return accountLevels[user];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GenevExch is SafeMath {\n', '\n', '    address public admin; //the admin address\n', '    address public feeAccount; //the account that will receive fees\n', '    address public accountLevelsAddr; //the address of the AccountLevels contract\n', '    uint public feeMake; //percentage times (1 ether)\n', '    uint public feeTake; //percentage times (1 ether)\n', '    uint public feeRebate; //percentage times (1 ether)\n', '    mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '    mapping (address => bool) public whiteListERC20;\n', '    mapping (address => bool) public whiteListERC223;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    \n', '    modifier onlyAdmin() {\n', '        require(msg.sender==admin);\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '\n', '    constructor(\n', '        address admin_, \n', '        address feeAccount_, \n', '        address accountLevelsAddr_, \n', '        uint feeMake_, \n', '        uint feeTake_, \n', '        uint feeRebate_) public {\n', '\n', '        admin = admin_;\n', '        feeAccount = feeAccount_;\n', '        accountLevelsAddr = accountLevelsAddr_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '        feeRebate = feeRebate_;\n', '    }\n', '\n', '    function() public {\n', '        revert();\n', '    }\n', '\n', '    // Admin functions\n', '\n', '    function changeAdmin(address admin_) public onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeAccountLevelsAddr(address accountLevelsAddr_) public onlyAdmin {\n', '        accountLevelsAddr = accountLevelsAddr_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) public onlyAdmin {\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) public onlyAdmin {\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) public onlyAdmin {\n', '        if (feeTake_ < feeRebate) revert();\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function changeFeeRebate(uint feeRebate_) public onlyAdmin {\n', '        if (feeRebate_ > feeTake) revert();\n', '        feeRebate = feeRebate_;\n', '    }\n', '\n', '    // Whitelists for ERC20 or ERC223 tokens\n', '\n', '    function setBlackListERC20(address _token) public onlyAdmin {\n', '        whiteListERC20[_token] = false;\n', '    }\n', '    function setWhiteListERC20(address _token) public onlyAdmin {\n', '        whiteListERC20[_token] = true;\n', '    }\n', '    function setBlackListERC223(address _token) public onlyAdmin {\n', '        whiteListERC223[_token] = false;\n', '    }\n', '    function setWhiteListERC223(address _token) public onlyAdmin {\n', '        whiteListERC223[_token] = true;\n', '    }\n', '\n', '    // Public functions\n', '\n', '    function deposit() public payable { // Deposit Ethers\n', '        tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function tokenFallback(address _from, uint _value, bytes _data) public { // Deposit ERC223 tokens\n', '        if (_value==0) revert();\n', '        require(whiteListERC223[msg.sender]);\n', '        tokens[msg.sender][_from] = safeAdd(tokens[msg.sender][_from], _value);\n', '        emit Deposit(msg.sender, _from, _value, tokens[msg.sender][_from]);\n', '     }\n', '\n', '    function depositToken(address token, uint amount) public { // Deposit ERC20 tokens\n', '        if (amount==0) revert();\n', '        require(whiteListERC20[token]);\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) revert();\n', '        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) public { // Withdraw ethers\n', '        if (tokens[0][msg.sender] < amount) revert();\n', '        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '        msg.sender.transfer(amount);\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) public { // Withdraw tokens\n', '        require(whiteListERC20[token] || whiteListERC223[token]);\n', '        if (tokens[token][msg.sender] < amount) revert();\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        require (Token(token).transfer(msg.sender, amount));\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) public constant returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    // Exchange specific functions\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        orders[msg.sender][hash] = true;\n', '        emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '        //amount is in amountGet terms\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '            block.number <= expires &&\n', '            safeAdd(orderFills[user][hash], amount) <= amountGet\n', '        )) revert();\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n', '        emit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n', '        uint feeRebateXfer = 0;\n', '\n', '        if (accountLevelsAddr != 0x0) {\n', '            uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n', '            if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n', '            if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n', '        }\n', '\n', '        tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n', '        tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n', '        if (!(\n', '            tokens[tokenGet][sender] >= amount &&\n', '            availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '        )) return false;\n', '        return true;\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '            block.number <= expires\n', '        )) return 0;\n', '        uint available1 = safeSub(amountGet, orderFills[user][hash]);\n', '        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1 < available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) public constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(orders[msg.sender][hash] || ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == msg.sender)) revert();\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '    \n', '}']
