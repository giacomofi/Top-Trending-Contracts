['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/libs/ERC20.sol\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external  view returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external  returns (bool success);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/libs/utils.sol\n', '\n', 'library Utils {\n', '\n', '    uint  constant PRECISION = (10**18);\n', '    uint  constant MAX_DECIMALS = 18;\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n', '        if( dstDecimals >= srcDecimals ) {\n', '            require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals-srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals-dstDecimals)));\n', '        }\n', '    }\n', '\n', '    // function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n', '    //     if( srcDecimals >= dstDecimals ) {\n', '    //         require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\n', '    //         return (PRECISION * dstQty * (10**(srcDecimals - dstDecimals))) / rate;\n', '    //     } else {\n', '    //         require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\n', '    //         return (PRECISION * dstQty) / (rate * (10**(dstDecimals - srcDecimals)));\n', '    //     }\n', '    // }\n', '}\n', '\n', '// File: contracts/libs/Manageable.sol\n', '\n', 'contract Manageable {\n', '    event ProviderUpdated (uint8 name, address hash);\n', '\n', '    // This is used to hold the addresses of the providers\n', '    mapping (uint8 => address) public subContracts;\n', '    modifier onlyOwner() {\n', '        // Make sure that this function can&#39;t be used without being overridden\n', '        require(true == false);\n', '        _;\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        require(_providerAddress != address(0));\n', '        subContracts[_id] = _providerAddress;\n', '        emit ProviderUpdated(_id, _providerAddress);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/Provider.sol\n', '\n', 'library TypeDefinitions {\n', '\n', '    enum ProviderType {\n', '        Strategy,\n', '        Price,\n', '        Exchange,\n', '        Storage,\n', '        ExtendedStorage,\n', '        Whitelist\n', '    }\n', '\n', '    struct ProviderStatistic {\n', '        uint counter;\n', '        uint amountInEther;\n', '        uint reputation;\n', '    }\n', '\n', '    struct ERC20Token {\n', '        string symbol;\n', '        address tokenAddress;\n', '        uint decimal;\n', '    }\n', '}\n', '\n', 'contract Provider is Manageable {\n', '    string public name;\n', '    TypeDefinitions.ProviderType public providerType;\n', '    string public description;\n', '    mapping(string => bool) internal properties;\n', '    TypeDefinitions.ProviderStatistic public statistics;\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/rbac/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' *      Supports unlimited numbers of roles and addresses.\n', ' *      See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', ' * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n', ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBAC()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '// File: contracts/permission/PermissionProviderInterface.sol\n', '\n', 'contract PermissionProviderInterface is Provider, RBAC {\n', '    string public constant ROLE_ADMIN = "admin";\n', '    string public constant ROLE_CORE = "core";\n', '    string public constant ROLE_STORAGE = "storage";\n', '    string public constant ROLE_CORE_OWNER = "CoreOwner";\n', '    string public constant ROLE_STRATEGY_OWNER = "StrategyOwner";\n', '    string public constant ROLE_PRICE_OWNER = "PriceOwner";\n', '    string public constant ROLE_EXCHANGE_OWNER = "ExchangeOwner";\n', '    string public constant ROLE_EXCHANGE_ADAPTER_OWNER = "ExchangeAdapterOwner";\n', '    string public constant ROLE_STORAGE_OWNER = "StorageOwner";\n', '    string public constant ROLE_WHITELIST_OWNER = "WhitelistOwner";\n', '\n', '    modifier onlyAdmin()\n', '    {\n', '        checkRole(msg.sender, ROLE_ADMIN);\n', '        _;\n', '    }\n', '\n', '    function changeAdmin(address _newAdmin) onlyAdmin public returns (bool success);\n', '    function adminAdd(address _addr, string _roleName) onlyAdmin public;\n', '    function adminRemove(address _addr, string _roleName) onlyAdmin public;\n', '\n', '    function has(address _addr, string _roleName) public view returns(bool success);\n', '}\n', '\n', '// File: contracts/exchange/ExchangeAdapterBase.sol\n', '\n', 'contract ExchangeAdapterBase {\n', '\n', '    address internal adapterManager;\n', '    address internal exchangeExchange;\n', '\n', '    enum Status {\n', '        ENABLED, \n', '        DISABLED\n', '    }\n', '\n', '    enum OrderStatus {\n', '        Pending,\n', '        Approved,\n', '        PartiallyCompleted,\n', '        Completed,\n', '        Cancelled,\n', '        Errored\n', '    }\n', '\n', '    function ExchangeAdapterBase(address _manager,address _exchange) public {\n', '        adapterManager = _manager;\n', '        exchangeExchange = _exchange;\n', '    }\n', '\n', '    function getExpectAmount(uint eth, uint destDecimals, uint rate) internal pure returns(uint){\n', '        return Utils.calcDstQty(eth, 18, destDecimals, rate);\n', '    }\n', '\n', '    modifier onlyAdaptersManager(){\n', '        require(msg.sender == adapterManager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyExchangeProvider(){\n', '        require(msg.sender == exchangeExchange);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/exchange/ExchangeProviderInterface.sol\n', '\n', 'contract ExchangeProviderInterface {\n', '    function startPlaceOrder(uint orderId, address deposit) external returns(bool);\n', '    function addPlaceOrderItem(uint orderId, ERC20 token, uint amount, uint rate) external returns(bool);\n', '    function endPlaceOrder(uint orderId) external payable returns(bool);\n', '    function getSubOrderStatus(uint orderId, ERC20 token) external view returns (ExchangeAdapterBase.OrderStatus);\n', '    function cancelOrder(uint orderId) external returns (bool success);\n', '    function checkTokenSupported(ERC20 token) external view returns (bool);\n', '}\n', '\n', '// File: contracts/libs/Converter.sol\n', '\n', 'library Converter {\n', '    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function bytes32ToString(bytes32 x) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '// File: contracts/libs/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/price/PriceProviderInterface.sol\n', '\n', 'contract PriceProviderInterface {\n', '\n', '    function updatePrice(address _tokenAddress,bytes32[] _exchanges,uint[] _prices,uint _nonce) public returns(bool success);\n', '    function getNewDefaultPrice(address _tokenAddress) public view returns(uint);\n', '    function getNewCustomPrice(address _provider,address _tokenAddress) public view returns(uint);\n', '\n', '    function getNonce(address providerAddress,address tokenAddress) public view returns(uint);\n', '\n', '    function checkTokenSupported(address tokenAddress)  public view returns(bool success);\n', '    function checkExchangeSupported(bytes32 Exchanges)  public view returns(bool success);\n', '    function checkProviderSupported(address providerAddress,address tokenAddress)  public view returns(bool success);\n', '\n', '    function getRates(address dest, uint srcQty)  public view returns (uint expectedRate, uint slippageRate);\n', '}\n', '\n', '// File: contracts/storage/OlympusStorageExtendedInterface.sol\n', '\n', '/*\n', ' * @dev This contract, for now, can be used to store simple bytes32 key pairs.\n', ' * These key pairs which are identifiable by their objectId and dataKind\n', ' * Such as strategy, order, price, etc.\n', ' * The purpose of this interface is that we can store custom data into this contract\n', ' * for any changes in the requirements in the future. Each part of the Olympus core\n', ' * should have options to add custom data to their respective dataType, by using\n', ' * this contract.\n', ' * The functions will always be the same, the implementation of the functions might change\n', ' * So the implementing contracts should be able to modify the configured address of this contract\n', ' * after deployment.\n', ' */\n', 'contract OlympusStorageExtendedInterface {\n', '    /*\n', '     * @dev Use this function to set custom extra data for your contract in a key value format\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @param key The key which is used to save your data in the key value mapping\n', '     * @param value The value which will be set on the location of the key\n', '     * @return A boolean which returns true if the function executed succesfully\n', '     */\n', '    function setCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key, bytes32 value) external returns(bool success);\n', '    /*\n', '     * @dev Use this function to get custom extra data for your contract by key\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @param key The key which is used to lookup your data in the key value mapping\n', '     * @return The result from the key lookup in string format\n', '     */\n', '    function getCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key) external view returns(bytes32 result);\n', '    /*\n', '     * @dev This function is used internally to get the accessor for the kind of data\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param id The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @return A concatenation of the dataKind string and id as string, which can be used as lookup\n', '     */\n', '    function getAccessor(bytes32 dataKind, uint id) private pure returns(string accessor);\n', '}\n', '\n', '// File: contracts/storage/StorageDefinitions.sol\n', '\n', 'library StorageTypeDefinitions {\n', '    enum OrderStatus {\n', '        New,\n', '        Placed,\n', '        PartiallyCompleted,\n', '        Completed,\n', '        Cancelled,\n', '        Errored\n', '    }\n', '}\n', '\n', '// File: contracts/storage/OlympusStorageInterface.sol\n', '\n', 'contract OlympusStorageInterface {\n', '\n', '    function addTokenDetails(\n', '        uint indexOrderId,\n', '        address[] tokens,\n', '        uint[] weights,\n', '        uint[] totalTokenAmounts,\n', '        uint[] estimatedPrices) external;\n', '\n', '    function addOrderBasicFields(\n', '        uint strategyId,\n', '        address buyer,\n', '        uint amountInWei,\n', '        uint feeInWei,\n', '        bytes32 exchangeId) external returns (uint indexOrderId);\n', '\n', '    function getOrderTokenCompletedAmount(\n', '        uint _orderId,\n', '        address _tokenAddress) external view returns (uint, uint);\n', '\n', '    function getIndexOrder1(uint _orderId) external view returns(\n', '        uint strategyId,\n', '        address buyer,\n', '        StorageTypeDefinitions.OrderStatus status,\n', '        uint dateCreated\n', '        );\n', '\n', '    function getIndexOrder2(uint _orderId) external view returns(\n', '        uint dateCompleted,\n', '        uint amountInWei,\n', '        uint tokensLength,\n', '        bytes32 exchangeId\n', '        );\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        uint _tokenIndex,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity,\n', '        ExchangeAdapterBase.OrderStatus status) external;\n', '\n', '    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token);\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external returns (bool success);\n', '\n', '    function resetOrderIdTo(uint _orderId) external returns(uint);\n', '\n', '    function addCustomField(\n', '        uint _orderId,\n', '        bytes32 key,\n', '        bytes32 value\n', '        ) external returns (bool success);\n', '\n', '    function getCustomField(\n', '        uint _orderId,\n', '        bytes32 key\n', '        ) external view returns (bytes32 result);\n', '}\n', '\n', '// File: contracts/storage/OlympusStorage.sol\n', '\n', 'contract OlympusStorage is Manageable, OlympusStorageInterface {\n', '    using SafeMath for uint256;\n', '\n', '    event IndexOrderUpdated (uint orderId);\n', '    event Log(string message);\n', '\n', '    struct IndexOrder {\n', '        address buyer;\n', '        uint strategyId;\n', '        uint amountInWei;\n', '        uint feeInWei;\n', '        uint dateCreated;\n', '        uint dateCompleted;\n', '        address[] tokens;\n', '        uint[] weights;\n', '        uint[] estimatedPrices;\n', '        uint[] dealtPrices;\n', '        uint[] totalTokenAmounts;\n', '        uint[] completedTokenAmounts;\n', '        ExchangeAdapterBase.OrderStatus[] subStatuses;\n', '        StorageTypeDefinitions.OrderStatus status;\n', '        bytes32 exchangeId;\n', '    }\n', '    mapping(uint => IndexOrder) public orders;\n', '    mapping(uint => mapping(address => uint)) public orderTokenAmounts;\n', '    uint public orderId = 1000000;\n', '    bytes32 constant private dataKind = "Order";\n', '    OlympusStorageExtendedInterface internal olympusStorageExtended = OlympusStorageExtendedInterface(address(0xcEb51bD598ABb0caa8d2Da30D4D760f08936547B));\n', '\n', '    modifier onlyOwner() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_STORAGE_OWNER()));\n', '        _;\n', '    }\n', '    modifier onlyCore() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE()));\n', '        _;\n', '    }\n', '    PermissionProviderInterface internal permissionProvider;\n', '    constructor(address _permissionProvider) public {\n', '        permissionProvider = PermissionProviderInterface(_permissionProvider);\n', '    }\n', '\n', '    function addTokenDetails(\n', '        uint indexOrderId,\n', '        address[] tokens,\n', '        uint[] weights,\n', '        uint[] totalTokenAmounts,\n', '        uint[] estimatedPrices\n', '    ) external onlyCore {\n', '        orders[indexOrderId].tokens = tokens;\n', '        orders[indexOrderId].weights = weights;\n', '        orders[indexOrderId].estimatedPrices = estimatedPrices;\n', '        orders[indexOrderId].totalTokenAmounts = totalTokenAmounts;\n', '        uint i;\n', '\n', '        for (i = 0; i < tokens.length; i++ ) {\n', '            orders[indexOrderId].subStatuses.push(ExchangeAdapterBase.OrderStatus.Pending);\n', '            orders[indexOrderId].dealtPrices.push(0);\n', '            orders[indexOrderId].completedTokenAmounts.push(0);\n', '\n', '            orderTokenAmounts[indexOrderId][tokens[i]] = weights[i];\n', '        }\n', '    }\n', '\n', '    function addOrderBasicFields(\n', '        uint strategyId,\n', '        address buyer,\n', '        uint amountInWei,\n', '        uint feeInWei,\n', '        bytes32 exchangeId\n', '        ) external onlyCore returns (uint indexOrderId) {\n', '        indexOrderId = getOrderId();\n', '\n', '        IndexOrder memory order = IndexOrder({\n', '            buyer: buyer,\n', '            strategyId: strategyId,\n', '            amountInWei: amountInWei,\n', '            feeInWei: feeInWei,\n', '            dateCreated: now,\n', '            dateCompleted: 0,\n', '            tokens: new address[](0),\n', '            weights: new uint[](0),\n', '            estimatedPrices: new uint[](0),\n', '            dealtPrices: new uint[](0),\n', '            totalTokenAmounts: new uint[](0),\n', '            completedTokenAmounts: new uint[](0),\n', '            subStatuses: new ExchangeAdapterBase.OrderStatus[](0),\n', '            status: StorageTypeDefinitions.OrderStatus.New,\n', '            exchangeId: exchangeId\n', '        });\n', '\n', '        orders[indexOrderId] = order;\n', '        return indexOrderId;\n', '    }\n', '\n', '    function getIndexOrder1(uint _orderId) external view returns(\n', '        uint strategyId,\n', '        address buyer,\n', '        StorageTypeDefinitions.OrderStatus status,\n', '        uint dateCreated\n', '        ) {\n', '        IndexOrder memory order = orders[_orderId];\n', '        return (\n', '            order.strategyId,\n', '            order.buyer,\n', '            order.status,\n', '            order.dateCreated\n', '        );\n', '    }\n', '    function getIndexOrder2(uint _orderId) external view returns(\n', '        uint dateCompleted,\n', '        uint amountInWei,\n', '        uint tokensLength,\n', '        bytes32 exchangeId\n', '        ) {\n', '        IndexOrder memory order = orders[_orderId];\n', '        return (\n', '            order.dateCompleted,\n', '            order.amountInWei,\n', '            order.tokens.length,\n', '            order.exchangeId\n', '        );\n', '    }\n', '\n', '    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token){\n', '        return orders[_orderId].tokens[tokenPosition];\n', '    }\n', '\n', '    function getOrderTokenCompletedAmount(uint _orderId, address _tokenAddress) external view returns (uint, uint){\n', '        IndexOrder memory order = orders[_orderId];\n', '\n', '        int index = -1;\n', '        for(uint i = 0 ; i < order.tokens.length; i++){\n', '            if(order.tokens[i] == _tokenAddress) {\n', '                index = int(i);\n', '                break;\n', '            }\n', '        }\n', '\n', '        if(index == -1) {\n', '            // token not found.\n', '            revert();\n', '        }\n', '\n', '        return (order.completedTokenAmounts[uint(index)], uint(index));\n', '\n', '    }\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        uint _tokenIndex,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity,\n', '        ExchangeAdapterBase.OrderStatus _status) external onlyCore {\n', '\n', '        orders[_orderId].totalTokenAmounts[_tokenIndex] = _totalTokenAmount;\n', '        orders[_orderId].dealtPrices[_tokenIndex] = _actualPrice;\n', '        orders[_orderId].completedTokenAmounts[_tokenIndex] = _completedQuantity;\n', '        orders[_orderId].subStatuses[_tokenIndex] = _status;\n', '    }\n', '\n', '    function addCustomField(\n', '        uint _orderId,\n', '        bytes32 key,\n', '        bytes32 value\n', '    ) external onlyCore returns (bool success){\n', '        return olympusStorageExtended.setCustomExtraData(dataKind,_orderId,key,value);\n', '    }\n', '\n', '    function getCustomField(\n', '        uint _orderId,\n', '        bytes32 key\n', '    ) external view returns (bytes32 result){\n', '        return olympusStorageExtended.getCustomExtraData(dataKind,_orderId,key);\n', '    }\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external onlyCore returns (bool success){\n', '\n', '        orders[_orderId].status = _status;\n', '        return true;\n', '    }\n', '\n', '    function getOrderId() private returns (uint) {\n', '        return orderId++;\n', '    }\n', '\n', '    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\n', '        orderId = _start;\n', '        return orderId;\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        bool result = super.setProvider(_id, _providerAddress);\n', '        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\n', '\n', '        if(_type == TypeDefinitions.ProviderType.ExtendedStorage) {\n', '            emit Log("ExtendedStorage");\n', '            olympusStorageExtended = OlympusStorageExtendedInterface(_providerAddress);\n', '        } else {\n', '            emit Log("Unknown provider type supplied.");\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/strategy/StrategyProviderInterface.sol\n', '\n', 'contract StrategyProviderInterface is Provider {\n', '\n', '    struct Combo {\n', '        uint id;\n', '        string name;\n', '        string description;\n', '        string category;\n', '        address[] tokenAddresses;\n', '        uint[] weights;      //total is 100\n', '        uint follower;\n', '        uint amount;\n', '        bytes32 exchangeId;\n', '    }\n', '\n', '    Combo[] public comboHub;\n', '    modifier _checkIndex(uint _index) {\n', '        require(_index < comboHub.length);\n', '        _;\n', '    }\n', '\n', '   // To core smart contract\n', '    function getStrategyCount() public view returns (uint length);\n', '\n', '    function getStrategyTokenCount(uint strategyId) public view returns (uint length);\n', '    function getStrategyTokenByIndex(uint strategyId, uint tokenIndex) public view returns (address token, uint weight);\n', '\n', '    function getStrategy(uint _index) public _checkIndex(_index) view returns (\n', '        uint id,\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] memory tokenAddresses,\n', '        uint[] memory weights,\n', '        uint followers,\n', '        uint amount,\n', '        bytes32 exchangeId);\n', '\n', '    function createStrategy(\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] tokenAddresses,\n', '        uint[] weights,\n', '        bytes32 exchangeId)\n', '        public returns (uint strategyId);\n', '\n', '    function updateStrategy(\n', '        uint strategyId,\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] tokenAddresses,\n', '        uint[] weights,\n', '        bytes32 exchangeId)\n', '        public returns (bool success);\n', '\n', '    // increment statistics\n', '    function incrementStatistics(uint id, uint amountInEther) external returns (bool success);\n', '    function updateFollower(uint id, bool follow) external returns (bool success);\n', '}\n', '\n', '// File: contracts/whitelist/WhitelistProviderInterface.sol\n', '\n', 'contract WhitelistProviderInterface is Provider {\n', '    function isAllowed(address account) external view returns(bool);\n', '}\n', '\n', '// File: contracts/OlympusLabsCore.sol\n', '\n', 'contract OlympusLabsCore is Manageable {\n', '    using SafeMath for uint256;\n', '\n', '    event IndexOrderUpdated (uint orderId);\n', '    event Log(string message);\n', '    event LogNumber(uint number);\n', '    event LogAddress(address message);\n', '    event LogAddresses(address[] message);\n', '    event LogNumbers(uint[] numbers);\n', '    event LOGDEBUG(address);\n', '\n', '    ExchangeProviderInterface internal exchangeProvider =  ExchangeProviderInterface(address(0x0));\n', '    StrategyProviderInterface internal strategyProvider = StrategyProviderInterface(address(0x0));\n', '    PriceProviderInterface internal priceProvider = PriceProviderInterface(address(0x0));\n', '    OlympusStorageInterface internal olympusStorage = OlympusStorageInterface(address(0x0));\n', '    WhitelistProviderInterface internal whitelistProvider;\n', '    ERC20 private constant MOT = ERC20(address(0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD));\n', '    // TODO, update for mainnet: 0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD\n', '\n', '    uint public feePercentage = 100;\n', '    uint public MOTDiscount = 25;\n', '    uint public constant DENOMINATOR = 10000;\n', '\n', '    uint public minimumInWei = 0;\n', '    uint public maximumInWei;\n', '\n', '    modifier allowProviderOnly(TypeDefinitions.ProviderType _type) {\n', '        require(msg.sender == subContracts[uint8(_type)]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE_OWNER()));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed(){\n', '        require(address(whitelistProvider) == 0x0 || whitelistProvider.isAllowed(msg.sender));\n', '        _;\n', '    }\n', '\n', '    PermissionProviderInterface internal permissionProvider;\n', '\n', '    function OlympusLabsCore(address _permissionProvider) public {\n', '        permissionProvider = PermissionProviderInterface(_permissionProvider);\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    function getStrategyCount() public view returns (uint length)\n', '    {\n', '        return strategyProvider.getStrategyCount();\n', '    }\n', '\n', '    function getStrategy(uint strategyId) public view returns (\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] memory tokens,\n', '        uint[] memory weights,\n', '        uint followers,\n', '        uint amount,\n', '        string exchangeName)\n', '    {\n', '        bytes32 _exchangeName;\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        tokens = new address[](tokenLength);\n', '        weights = new uint[](tokenLength);\n', '\n', '        (,name,description,category,,,followers,amount,_exchangeName) = strategyProvider.getStrategy(strategyId);\n', '        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\n', '        exchangeName = Converter.bytes32ToString(_exchangeName);\n', '    }\n', '\n', '    function getStrategyTokenAndWeightByIndex(uint strategyId, uint index) public view returns (\n', '        address token,\n', '        uint weight\n', '        )\n', '    {\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        require(index < tokenLength);\n', '\n', '        (token, weight) = strategyProvider.getStrategyTokenByIndex(strategyId, index);\n', '    }\n', '\n', '    // Forward to Price smart contract.\n', '    function getPrice(address tokenAddress, uint srcQty) public view returns (uint price){\n', '        require(tokenAddress != address(0));\n', '        (, price) = priceProvider.getRates(tokenAddress, srcQty);\n', '        return price;\n', '    }\n', '\n', '    function getStrategyTokenPrice(uint strategyId, uint tokenIndex) public view returns (uint price) {\n', '        uint totalLength;\n', '\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        require(tokenIndex <= totalLength);\n', '        address[] memory tokens;\n', '        uint[] memory weights;\n', '        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\n', '\n', '        //Default get the price for one Ether\n', '\n', '        return getPrice(tokens[tokenIndex], 10**18);\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        bool result = super.setProvider(_id, _providerAddress);\n', '        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\n', '\n', '        if(_type == TypeDefinitions.ProviderType.Strategy) {\n', '            emit Log("StrategyProvider");\n', '            strategyProvider = StrategyProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Exchange) {\n', '            emit Log("ExchangeProvider");\n', '            exchangeProvider = ExchangeProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Price) {\n', '            emit Log("PriceProvider");\n', '            priceProvider = PriceProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Storage) {\n', '            emit Log("StorageProvider");\n', '            olympusStorage = OlympusStorageInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Whitelist) {\n', '            emit Log("WhitelistProvider");\n', '            whitelistProvider = WhitelistProviderInterface(_providerAddress);\n', '        } else {\n', '            emit Log("Unknown provider type supplied.");\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function buyIndex(uint strategyId, address depositAddress, bool feeIsMOT)\n', '    public onlyAllowed payable returns (uint indexOrderId)\n', '    {\n', '        require(msg.value > minimumInWei);\n', '        if(maximumInWei > 0){\n', '            require(msg.value <= maximumInWei);\n', '        }\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        // can&#39;t buy an index without tokens.\n', '        require(tokenLength > 0);\n', '        address[] memory tokens = new address[](tokenLength);\n', '        uint[] memory weights = new uint[](tokenLength);\n', '        bytes32 exchangeId;\n', '\n', '        (,,,,tokens,weights,,,exchangeId) = strategyProvider.getStrategy(strategyId);\n', '\n', '        uint[3] memory amounts;\n', '        amounts[0] = msg.value; //uint totalAmount\n', '        amounts[1] = getFeeAmount(amounts[0], feeIsMOT); // fee\n', '        amounts[2] = payFee(amounts[0], amounts[1], msg.sender, feeIsMOT);\n', '\n', '        // create order.\n', '        indexOrderId = olympusStorage.addOrderBasicFields(\n', '          strategyId,\n', '          msg.sender,\n', '          amounts[0],\n', '          amounts[1],\n', '          exchangeId\n', '        );\n', '\n', '        uint[][4] memory subOrderTemp;\n', '        // 0: token amounts\n', '        // 1: estimatedPrices\n', '        subOrderTemp[0] = initializeArray(tokenLength);\n', '        subOrderTemp[1] = initializeArray(tokenLength);\n', '\n', '        emit LogNumber(indexOrderId);\n', '\n', '\n', '        require(exchangeProvider.startPlaceOrder(indexOrderId, depositAddress));\n', '\n', '        for (uint i = 0; i < tokenLength; i ++ ) {\n', '\n', '            // ignore those tokens with zero weight.\n', '            if(weights[i] <= 0) {\n', '                continue;\n', '            }\n', '            // token has to be supported by exchange provider.\n', '            if(!exchangeProvider.checkTokenSupported(ERC20(tokens[i]))){\n', '                emit Log("Exchange provider doesn&#39;t support");\n', '                revert();\n', '            }\n', '\n', '            // check if price provider supports it.\n', '            if(!priceProvider.checkTokenSupported(tokens[i])){\n', '                emit Log("Price provider doesn&#39;t support");\n', '                revert();\n', '            }\n', '\n', '            subOrderTemp[0][i] = amounts[2] * weights[i] / 100;\n', '            subOrderTemp[1][i] = getPrice(tokens[i], subOrderTemp[0][i]);\n', '\n', '            emit LogAddress(tokens[i]);\n', '            emit LogNumber(subOrderTemp[0][i]);\n', '            emit LogNumber(subOrderTemp[1][i]);\n', '            require(exchangeProvider.addPlaceOrderItem(indexOrderId, ERC20(tokens[i]), subOrderTemp[0][i], subOrderTemp[1][i]));\n', '        }\n', '\n', '        olympusStorage.addTokenDetails(\n', '            indexOrderId,\n', '            tokens, weights, subOrderTemp[0], subOrderTemp[1]\n', '        );\n', '\n', '\n', '        emit LogNumber(amounts[2]);\n', '        require((exchangeProvider.endPlaceOrder.value(amounts[2])(indexOrderId)));\n', '\n', '\n', '        strategyProvider.updateFollower(strategyId, true);\n', '\n', '        strategyProvider.incrementStatistics(strategyId, msg.value);\n', '\n', '        return indexOrderId;\n', '    }\n', '\n', '    function initializeArray(uint length) private pure returns (uint[]){\n', '        return new uint[](length);\n', '    }\n', '\n', '    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\n', '        return olympusStorage.resetOrderIdTo(_start);\n', '    }\n', '\n', '    // For app/3rd-party clients to check details / status.\n', '    function getIndexOrder(uint _orderId) public view returns\n', '    (uint[])\n', '    {\n', '        // 0 strategyId\n', '        // 1 dateCreated\n', '        // 2 dateCompleted\n', '        // 3 amountInWei\n', '        // 4 tokenLength\n', '        uint[] memory orderPartial = new uint[](5);\n', '        address[] memory buyer = new address[](1);\n', '        bytes32[] memory exchangeId = new bytes32[](1);\n', '        StorageTypeDefinitions.OrderStatus[] memory status = new StorageTypeDefinitions.OrderStatus[](1);\n', '\n', '\n', '        (orderPartial[0], buyer[0], status[0], orderPartial[1]) = olympusStorage.getIndexOrder1(_orderId);\n', '        (orderPartial[2], orderPartial[3], orderPartial[4], exchangeId[0]) = olympusStorage.getIndexOrder2(_orderId);\n', '        address[] memory tokens = new address[](orderPartial[4]);\n', '\n', '        for(uint i = 0; i < orderPartial[4]; i++){\n', '            tokens[i] = olympusStorage.getIndexToken(_orderId, i);\n', '        }\n', '        return (\n', '          orderPartial\n', '        );\n', '    }\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        address _tokenAddress,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity\n', '    ) external allowProviderOnly(TypeDefinitions.ProviderType.Exchange) returns (bool success)\n', '    {\n', '        uint completedTokenAmount;\n', '        uint tokenIndex;\n', '        (completedTokenAmount, tokenIndex) = olympusStorage.getOrderTokenCompletedAmount(_orderId,_tokenAddress);\n', '\n', '        ExchangeAdapterBase.OrderStatus status;\n', '\n', '        if(completedTokenAmount == 0 && _completedQuantity < completedTokenAmount){\n', '            status = ExchangeAdapterBase.OrderStatus.PartiallyCompleted;\n', '        }\n', '\n', '        if(_completedQuantity >= completedTokenAmount){\n', '            status = ExchangeAdapterBase.OrderStatus.Completed;\n', '        }\n', '        olympusStorage.updateIndexOrderToken(_orderId, tokenIndex, _totalTokenAmount, _actualPrice, _completedQuantity, status);\n', '\n', '        return true;\n', '    }\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external allowProviderOnly(TypeDefinitions.ProviderType.Exchange)\n', '        returns (bool success)\n', '    {\n', '        olympusStorage.updateOrderStatus(_orderId, _status);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getSubOrderStatus(uint _orderId, address _tokenAddress)\n', '        external view returns (ExchangeAdapterBase.OrderStatus)\n', '    {\n', '        return exchangeProvider.getSubOrderStatus(_orderId, ERC20(_tokenAddress));\n', '    }\n', '\n', '    function adjustFee(uint _newFeePercentage) public onlyOwner returns (bool success) {\n', '        require(_newFeePercentage < DENOMINATOR);\n', '        feePercentage = _newFeePercentage;\n', '        return true;\n', '    }\n', '\n', '    function adjustMOTFeeDiscount(uint _newDiscountPercentage) public onlyOwner returns(bool success) {\n', '        require(_newDiscountPercentage <= 100);\n', '        MOTDiscount = _newDiscountPercentage;\n', '        return true;\n', '    }\n', '\n', '    function adjustTradeRange(uint _minInWei, uint _maxInWei) public onlyOwner returns (bool success) {\n', '        require(_minInWei > 0);\n', '        require(_maxInWei > _minInWei);\n', '        minimumInWei = _minInWei;\n', '        maximumInWei = _maxInWei;\n', '\n', '        return true;\n', '    }\n', '\n', '    function getFeeAmount(uint amountInWei, bool feeIsMOT) private view returns (uint){\n', '        if(feeIsMOT){\n', '            return ((amountInWei * feePercentage / DENOMINATOR) * (100 - MOTDiscount)) / 100;\n', '        } else {\n', '            return amountInWei * feePercentage / DENOMINATOR;\n', '        }\n', '    }\n', '\n', '    function payFee(uint totalValue, uint feeValueInETH, address sender, bool feeIsMOT) private returns (uint){\n', '        if(feeIsMOT){\n', '            // Transfer MOT\n', '            uint MOTPrice;\n', '            uint allowance = MOT.allowance(sender,address(this));\n', '            (MOTPrice,) = priceProvider.getRates(address(MOT), feeValueInETH);\n', '            uint amount = (feeValueInETH * MOTPrice) / 10**18;\n', '            require(allowance >= amount);\n', '            require(MOT.transferFrom(sender,address(this),amount));\n', '            return totalValue; // Use all sent ETH to buy, because fee is paid in MOT\n', '        } else { // We use ETH as fee, so deduct that from the amount of ETH sent\n', '            return totalValue - feeValueInETH;\n', '        }\n', '    }\n', '\n', '    function withdrawERC20(address receiveAddress,address _tokenAddress) public onlyOwner returns(bool success)\n', '    {\n', '        uint _balance = ERC20(_tokenAddress).balanceOf(address(this));\n', '        require(_tokenAddress != 0x0 && receiveAddress != 0x0 && _balance != 0);\n', '        require(ERC20(_tokenAddress).transfer(receiveAddress,_balance));\n', '        return true;\n', '    }\n', '    function withdrawETH(address receiveAddress) public onlyOwner returns(bool success)\n', '    {\n', '        require(receiveAddress != 0x0);\n', '        receiveAddress.transfer(this.balance);\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/libs/ERC20.sol\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external  view returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external  returns (bool success);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/libs/utils.sol\n', '\n', 'library Utils {\n', '\n', '    uint  constant PRECISION = (10**18);\n', '    uint  constant MAX_DECIMALS = 18;\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n', '        if( dstDecimals >= srcDecimals ) {\n', '            require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals-srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals-dstDecimals)));\n', '        }\n', '    }\n', '\n', '    // function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n', '    //     if( srcDecimals >= dstDecimals ) {\n', '    //         require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\n', '    //         return (PRECISION * dstQty * (10**(srcDecimals - dstDecimals))) / rate;\n', '    //     } else {\n', '    //         require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\n', '    //         return (PRECISION * dstQty) / (rate * (10**(dstDecimals - srcDecimals)));\n', '    //     }\n', '    // }\n', '}\n', '\n', '// File: contracts/libs/Manageable.sol\n', '\n', 'contract Manageable {\n', '    event ProviderUpdated (uint8 name, address hash);\n', '\n', '    // This is used to hold the addresses of the providers\n', '    mapping (uint8 => address) public subContracts;\n', '    modifier onlyOwner() {\n', "        // Make sure that this function can't be used without being overridden\n", '        require(true == false);\n', '        _;\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        require(_providerAddress != address(0));\n', '        subContracts[_id] = _providerAddress;\n', '        emit ProviderUpdated(_id, _providerAddress);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/Provider.sol\n', '\n', 'library TypeDefinitions {\n', '\n', '    enum ProviderType {\n', '        Strategy,\n', '        Price,\n', '        Exchange,\n', '        Storage,\n', '        ExtendedStorage,\n', '        Whitelist\n', '    }\n', '\n', '    struct ProviderStatistic {\n', '        uint counter;\n', '        uint amountInEther;\n', '        uint reputation;\n', '    }\n', '\n', '    struct ERC20Token {\n', '        string symbol;\n', '        address tokenAddress;\n', '        uint decimal;\n', '    }\n', '}\n', '\n', 'contract Provider is Manageable {\n', '    string public name;\n', '    TypeDefinitions.ProviderType public providerType;\n', '    string public description;\n', '    mapping(string => bool) internal properties;\n', '    TypeDefinitions.ProviderStatistic public statistics;\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/rbac/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' *      Supports unlimited numbers of roles and addresses.\n', ' *      See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBAC()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '// File: contracts/permission/PermissionProviderInterface.sol\n', '\n', 'contract PermissionProviderInterface is Provider, RBAC {\n', '    string public constant ROLE_ADMIN = "admin";\n', '    string public constant ROLE_CORE = "core";\n', '    string public constant ROLE_STORAGE = "storage";\n', '    string public constant ROLE_CORE_OWNER = "CoreOwner";\n', '    string public constant ROLE_STRATEGY_OWNER = "StrategyOwner";\n', '    string public constant ROLE_PRICE_OWNER = "PriceOwner";\n', '    string public constant ROLE_EXCHANGE_OWNER = "ExchangeOwner";\n', '    string public constant ROLE_EXCHANGE_ADAPTER_OWNER = "ExchangeAdapterOwner";\n', '    string public constant ROLE_STORAGE_OWNER = "StorageOwner";\n', '    string public constant ROLE_WHITELIST_OWNER = "WhitelistOwner";\n', '\n', '    modifier onlyAdmin()\n', '    {\n', '        checkRole(msg.sender, ROLE_ADMIN);\n', '        _;\n', '    }\n', '\n', '    function changeAdmin(address _newAdmin) onlyAdmin public returns (bool success);\n', '    function adminAdd(address _addr, string _roleName) onlyAdmin public;\n', '    function adminRemove(address _addr, string _roleName) onlyAdmin public;\n', '\n', '    function has(address _addr, string _roleName) public view returns(bool success);\n', '}\n', '\n', '// File: contracts/exchange/ExchangeAdapterBase.sol\n', '\n', 'contract ExchangeAdapterBase {\n', '\n', '    address internal adapterManager;\n', '    address internal exchangeExchange;\n', '\n', '    enum Status {\n', '        ENABLED, \n', '        DISABLED\n', '    }\n', '\n', '    enum OrderStatus {\n', '        Pending,\n', '        Approved,\n', '        PartiallyCompleted,\n', '        Completed,\n', '        Cancelled,\n', '        Errored\n', '    }\n', '\n', '    function ExchangeAdapterBase(address _manager,address _exchange) public {\n', '        adapterManager = _manager;\n', '        exchangeExchange = _exchange;\n', '    }\n', '\n', '    function getExpectAmount(uint eth, uint destDecimals, uint rate) internal pure returns(uint){\n', '        return Utils.calcDstQty(eth, 18, destDecimals, rate);\n', '    }\n', '\n', '    modifier onlyAdaptersManager(){\n', '        require(msg.sender == adapterManager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyExchangeProvider(){\n', '        require(msg.sender == exchangeExchange);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/exchange/ExchangeProviderInterface.sol\n', '\n', 'contract ExchangeProviderInterface {\n', '    function startPlaceOrder(uint orderId, address deposit) external returns(bool);\n', '    function addPlaceOrderItem(uint orderId, ERC20 token, uint amount, uint rate) external returns(bool);\n', '    function endPlaceOrder(uint orderId) external payable returns(bool);\n', '    function getSubOrderStatus(uint orderId, ERC20 token) external view returns (ExchangeAdapterBase.OrderStatus);\n', '    function cancelOrder(uint orderId) external returns (bool success);\n', '    function checkTokenSupported(ERC20 token) external view returns (bool);\n', '}\n', '\n', '// File: contracts/libs/Converter.sol\n', '\n', 'library Converter {\n', '    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function bytes32ToString(bytes32 x) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '// File: contracts/libs/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/price/PriceProviderInterface.sol\n', '\n', 'contract PriceProviderInterface {\n', '\n', '    function updatePrice(address _tokenAddress,bytes32[] _exchanges,uint[] _prices,uint _nonce) public returns(bool success);\n', '    function getNewDefaultPrice(address _tokenAddress) public view returns(uint);\n', '    function getNewCustomPrice(address _provider,address _tokenAddress) public view returns(uint);\n', '\n', '    function getNonce(address providerAddress,address tokenAddress) public view returns(uint);\n', '\n', '    function checkTokenSupported(address tokenAddress)  public view returns(bool success);\n', '    function checkExchangeSupported(bytes32 Exchanges)  public view returns(bool success);\n', '    function checkProviderSupported(address providerAddress,address tokenAddress)  public view returns(bool success);\n', '\n', '    function getRates(address dest, uint srcQty)  public view returns (uint expectedRate, uint slippageRate);\n', '}\n', '\n', '// File: contracts/storage/OlympusStorageExtendedInterface.sol\n', '\n', '/*\n', ' * @dev This contract, for now, can be used to store simple bytes32 key pairs.\n', ' * These key pairs which are identifiable by their objectId and dataKind\n', ' * Such as strategy, order, price, etc.\n', ' * The purpose of this interface is that we can store custom data into this contract\n', ' * for any changes in the requirements in the future. Each part of the Olympus core\n', ' * should have options to add custom data to their respective dataType, by using\n', ' * this contract.\n', ' * The functions will always be the same, the implementation of the functions might change\n', ' * So the implementing contracts should be able to modify the configured address of this contract\n', ' * after deployment.\n', ' */\n', 'contract OlympusStorageExtendedInterface {\n', '    /*\n', '     * @dev Use this function to set custom extra data for your contract in a key value format\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @param key The key which is used to save your data in the key value mapping\n', '     * @param value The value which will be set on the location of the key\n', '     * @return A boolean which returns true if the function executed succesfully\n', '     */\n', '    function setCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key, bytes32 value) external returns(bool success);\n', '    /*\n', '     * @dev Use this function to get custom extra data for your contract by key\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @param key The key which is used to lookup your data in the key value mapping\n', '     * @return The result from the key lookup in string format\n', '     */\n', '    function getCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key) external view returns(bytes32 result);\n', '    /*\n', '     * @dev This function is used internally to get the accessor for the kind of data\n', '     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\n', '     * @param id The id for your kind of data, e.g. the strategyId, the orderId\n', '     * @return A concatenation of the dataKind string and id as string, which can be used as lookup\n', '     */\n', '    function getAccessor(bytes32 dataKind, uint id) private pure returns(string accessor);\n', '}\n', '\n', '// File: contracts/storage/StorageDefinitions.sol\n', '\n', 'library StorageTypeDefinitions {\n', '    enum OrderStatus {\n', '        New,\n', '        Placed,\n', '        PartiallyCompleted,\n', '        Completed,\n', '        Cancelled,\n', '        Errored\n', '    }\n', '}\n', '\n', '// File: contracts/storage/OlympusStorageInterface.sol\n', '\n', 'contract OlympusStorageInterface {\n', '\n', '    function addTokenDetails(\n', '        uint indexOrderId,\n', '        address[] tokens,\n', '        uint[] weights,\n', '        uint[] totalTokenAmounts,\n', '        uint[] estimatedPrices) external;\n', '\n', '    function addOrderBasicFields(\n', '        uint strategyId,\n', '        address buyer,\n', '        uint amountInWei,\n', '        uint feeInWei,\n', '        bytes32 exchangeId) external returns (uint indexOrderId);\n', '\n', '    function getOrderTokenCompletedAmount(\n', '        uint _orderId,\n', '        address _tokenAddress) external view returns (uint, uint);\n', '\n', '    function getIndexOrder1(uint _orderId) external view returns(\n', '        uint strategyId,\n', '        address buyer,\n', '        StorageTypeDefinitions.OrderStatus status,\n', '        uint dateCreated\n', '        );\n', '\n', '    function getIndexOrder2(uint _orderId) external view returns(\n', '        uint dateCompleted,\n', '        uint amountInWei,\n', '        uint tokensLength,\n', '        bytes32 exchangeId\n', '        );\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        uint _tokenIndex,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity,\n', '        ExchangeAdapterBase.OrderStatus status) external;\n', '\n', '    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token);\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external returns (bool success);\n', '\n', '    function resetOrderIdTo(uint _orderId) external returns(uint);\n', '\n', '    function addCustomField(\n', '        uint _orderId,\n', '        bytes32 key,\n', '        bytes32 value\n', '        ) external returns (bool success);\n', '\n', '    function getCustomField(\n', '        uint _orderId,\n', '        bytes32 key\n', '        ) external view returns (bytes32 result);\n', '}\n', '\n', '// File: contracts/storage/OlympusStorage.sol\n', '\n', 'contract OlympusStorage is Manageable, OlympusStorageInterface {\n', '    using SafeMath for uint256;\n', '\n', '    event IndexOrderUpdated (uint orderId);\n', '    event Log(string message);\n', '\n', '    struct IndexOrder {\n', '        address buyer;\n', '        uint strategyId;\n', '        uint amountInWei;\n', '        uint feeInWei;\n', '        uint dateCreated;\n', '        uint dateCompleted;\n', '        address[] tokens;\n', '        uint[] weights;\n', '        uint[] estimatedPrices;\n', '        uint[] dealtPrices;\n', '        uint[] totalTokenAmounts;\n', '        uint[] completedTokenAmounts;\n', '        ExchangeAdapterBase.OrderStatus[] subStatuses;\n', '        StorageTypeDefinitions.OrderStatus status;\n', '        bytes32 exchangeId;\n', '    }\n', '    mapping(uint => IndexOrder) public orders;\n', '    mapping(uint => mapping(address => uint)) public orderTokenAmounts;\n', '    uint public orderId = 1000000;\n', '    bytes32 constant private dataKind = "Order";\n', '    OlympusStorageExtendedInterface internal olympusStorageExtended = OlympusStorageExtendedInterface(address(0xcEb51bD598ABb0caa8d2Da30D4D760f08936547B));\n', '\n', '    modifier onlyOwner() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_STORAGE_OWNER()));\n', '        _;\n', '    }\n', '    modifier onlyCore() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE()));\n', '        _;\n', '    }\n', '    PermissionProviderInterface internal permissionProvider;\n', '    constructor(address _permissionProvider) public {\n', '        permissionProvider = PermissionProviderInterface(_permissionProvider);\n', '    }\n', '\n', '    function addTokenDetails(\n', '        uint indexOrderId,\n', '        address[] tokens,\n', '        uint[] weights,\n', '        uint[] totalTokenAmounts,\n', '        uint[] estimatedPrices\n', '    ) external onlyCore {\n', '        orders[indexOrderId].tokens = tokens;\n', '        orders[indexOrderId].weights = weights;\n', '        orders[indexOrderId].estimatedPrices = estimatedPrices;\n', '        orders[indexOrderId].totalTokenAmounts = totalTokenAmounts;\n', '        uint i;\n', '\n', '        for (i = 0; i < tokens.length; i++ ) {\n', '            orders[indexOrderId].subStatuses.push(ExchangeAdapterBase.OrderStatus.Pending);\n', '            orders[indexOrderId].dealtPrices.push(0);\n', '            orders[indexOrderId].completedTokenAmounts.push(0);\n', '\n', '            orderTokenAmounts[indexOrderId][tokens[i]] = weights[i];\n', '        }\n', '    }\n', '\n', '    function addOrderBasicFields(\n', '        uint strategyId,\n', '        address buyer,\n', '        uint amountInWei,\n', '        uint feeInWei,\n', '        bytes32 exchangeId\n', '        ) external onlyCore returns (uint indexOrderId) {\n', '        indexOrderId = getOrderId();\n', '\n', '        IndexOrder memory order = IndexOrder({\n', '            buyer: buyer,\n', '            strategyId: strategyId,\n', '            amountInWei: amountInWei,\n', '            feeInWei: feeInWei,\n', '            dateCreated: now,\n', '            dateCompleted: 0,\n', '            tokens: new address[](0),\n', '            weights: new uint[](0),\n', '            estimatedPrices: new uint[](0),\n', '            dealtPrices: new uint[](0),\n', '            totalTokenAmounts: new uint[](0),\n', '            completedTokenAmounts: new uint[](0),\n', '            subStatuses: new ExchangeAdapterBase.OrderStatus[](0),\n', '            status: StorageTypeDefinitions.OrderStatus.New,\n', '            exchangeId: exchangeId\n', '        });\n', '\n', '        orders[indexOrderId] = order;\n', '        return indexOrderId;\n', '    }\n', '\n', '    function getIndexOrder1(uint _orderId) external view returns(\n', '        uint strategyId,\n', '        address buyer,\n', '        StorageTypeDefinitions.OrderStatus status,\n', '        uint dateCreated\n', '        ) {\n', '        IndexOrder memory order = orders[_orderId];\n', '        return (\n', '            order.strategyId,\n', '            order.buyer,\n', '            order.status,\n', '            order.dateCreated\n', '        );\n', '    }\n', '    function getIndexOrder2(uint _orderId) external view returns(\n', '        uint dateCompleted,\n', '        uint amountInWei,\n', '        uint tokensLength,\n', '        bytes32 exchangeId\n', '        ) {\n', '        IndexOrder memory order = orders[_orderId];\n', '        return (\n', '            order.dateCompleted,\n', '            order.amountInWei,\n', '            order.tokens.length,\n', '            order.exchangeId\n', '        );\n', '    }\n', '\n', '    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token){\n', '        return orders[_orderId].tokens[tokenPosition];\n', '    }\n', '\n', '    function getOrderTokenCompletedAmount(uint _orderId, address _tokenAddress) external view returns (uint, uint){\n', '        IndexOrder memory order = orders[_orderId];\n', '\n', '        int index = -1;\n', '        for(uint i = 0 ; i < order.tokens.length; i++){\n', '            if(order.tokens[i] == _tokenAddress) {\n', '                index = int(i);\n', '                break;\n', '            }\n', '        }\n', '\n', '        if(index == -1) {\n', '            // token not found.\n', '            revert();\n', '        }\n', '\n', '        return (order.completedTokenAmounts[uint(index)], uint(index));\n', '\n', '    }\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        uint _tokenIndex,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity,\n', '        ExchangeAdapterBase.OrderStatus _status) external onlyCore {\n', '\n', '        orders[_orderId].totalTokenAmounts[_tokenIndex] = _totalTokenAmount;\n', '        orders[_orderId].dealtPrices[_tokenIndex] = _actualPrice;\n', '        orders[_orderId].completedTokenAmounts[_tokenIndex] = _completedQuantity;\n', '        orders[_orderId].subStatuses[_tokenIndex] = _status;\n', '    }\n', '\n', '    function addCustomField(\n', '        uint _orderId,\n', '        bytes32 key,\n', '        bytes32 value\n', '    ) external onlyCore returns (bool success){\n', '        return olympusStorageExtended.setCustomExtraData(dataKind,_orderId,key,value);\n', '    }\n', '\n', '    function getCustomField(\n', '        uint _orderId,\n', '        bytes32 key\n', '    ) external view returns (bytes32 result){\n', '        return olympusStorageExtended.getCustomExtraData(dataKind,_orderId,key);\n', '    }\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external onlyCore returns (bool success){\n', '\n', '        orders[_orderId].status = _status;\n', '        return true;\n', '    }\n', '\n', '    function getOrderId() private returns (uint) {\n', '        return orderId++;\n', '    }\n', '\n', '    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\n', '        orderId = _start;\n', '        return orderId;\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        bool result = super.setProvider(_id, _providerAddress);\n', '        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\n', '\n', '        if(_type == TypeDefinitions.ProviderType.ExtendedStorage) {\n', '            emit Log("ExtendedStorage");\n', '            olympusStorageExtended = OlympusStorageExtendedInterface(_providerAddress);\n', '        } else {\n', '            emit Log("Unknown provider type supplied.");\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/strategy/StrategyProviderInterface.sol\n', '\n', 'contract StrategyProviderInterface is Provider {\n', '\n', '    struct Combo {\n', '        uint id;\n', '        string name;\n', '        string description;\n', '        string category;\n', '        address[] tokenAddresses;\n', '        uint[] weights;      //total is 100\n', '        uint follower;\n', '        uint amount;\n', '        bytes32 exchangeId;\n', '    }\n', '\n', '    Combo[] public comboHub;\n', '    modifier _checkIndex(uint _index) {\n', '        require(_index < comboHub.length);\n', '        _;\n', '    }\n', '\n', '   // To core smart contract\n', '    function getStrategyCount() public view returns (uint length);\n', '\n', '    function getStrategyTokenCount(uint strategyId) public view returns (uint length);\n', '    function getStrategyTokenByIndex(uint strategyId, uint tokenIndex) public view returns (address token, uint weight);\n', '\n', '    function getStrategy(uint _index) public _checkIndex(_index) view returns (\n', '        uint id,\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] memory tokenAddresses,\n', '        uint[] memory weights,\n', '        uint followers,\n', '        uint amount,\n', '        bytes32 exchangeId);\n', '\n', '    function createStrategy(\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] tokenAddresses,\n', '        uint[] weights,\n', '        bytes32 exchangeId)\n', '        public returns (uint strategyId);\n', '\n', '    function updateStrategy(\n', '        uint strategyId,\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] tokenAddresses,\n', '        uint[] weights,\n', '        bytes32 exchangeId)\n', '        public returns (bool success);\n', '\n', '    // increment statistics\n', '    function incrementStatistics(uint id, uint amountInEther) external returns (bool success);\n', '    function updateFollower(uint id, bool follow) external returns (bool success);\n', '}\n', '\n', '// File: contracts/whitelist/WhitelistProviderInterface.sol\n', '\n', 'contract WhitelistProviderInterface is Provider {\n', '    function isAllowed(address account) external view returns(bool);\n', '}\n', '\n', '// File: contracts/OlympusLabsCore.sol\n', '\n', 'contract OlympusLabsCore is Manageable {\n', '    using SafeMath for uint256;\n', '\n', '    event IndexOrderUpdated (uint orderId);\n', '    event Log(string message);\n', '    event LogNumber(uint number);\n', '    event LogAddress(address message);\n', '    event LogAddresses(address[] message);\n', '    event LogNumbers(uint[] numbers);\n', '    event LOGDEBUG(address);\n', '\n', '    ExchangeProviderInterface internal exchangeProvider =  ExchangeProviderInterface(address(0x0));\n', '    StrategyProviderInterface internal strategyProvider = StrategyProviderInterface(address(0x0));\n', '    PriceProviderInterface internal priceProvider = PriceProviderInterface(address(0x0));\n', '    OlympusStorageInterface internal olympusStorage = OlympusStorageInterface(address(0x0));\n', '    WhitelistProviderInterface internal whitelistProvider;\n', '    ERC20 private constant MOT = ERC20(address(0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD));\n', '    // TODO, update for mainnet: 0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD\n', '\n', '    uint public feePercentage = 100;\n', '    uint public MOTDiscount = 25;\n', '    uint public constant DENOMINATOR = 10000;\n', '\n', '    uint public minimumInWei = 0;\n', '    uint public maximumInWei;\n', '\n', '    modifier allowProviderOnly(TypeDefinitions.ProviderType _type) {\n', '        require(msg.sender == subContracts[uint8(_type)]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE_OWNER()));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed(){\n', '        require(address(whitelistProvider) == 0x0 || whitelistProvider.isAllowed(msg.sender));\n', '        _;\n', '    }\n', '\n', '    PermissionProviderInterface internal permissionProvider;\n', '\n', '    function OlympusLabsCore(address _permissionProvider) public {\n', '        permissionProvider = PermissionProviderInterface(_permissionProvider);\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    function getStrategyCount() public view returns (uint length)\n', '    {\n', '        return strategyProvider.getStrategyCount();\n', '    }\n', '\n', '    function getStrategy(uint strategyId) public view returns (\n', '        string name,\n', '        string description,\n', '        string category,\n', '        address[] memory tokens,\n', '        uint[] memory weights,\n', '        uint followers,\n', '        uint amount,\n', '        string exchangeName)\n', '    {\n', '        bytes32 _exchangeName;\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        tokens = new address[](tokenLength);\n', '        weights = new uint[](tokenLength);\n', '\n', '        (,name,description,category,,,followers,amount,_exchangeName) = strategyProvider.getStrategy(strategyId);\n', '        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\n', '        exchangeName = Converter.bytes32ToString(_exchangeName);\n', '    }\n', '\n', '    function getStrategyTokenAndWeightByIndex(uint strategyId, uint index) public view returns (\n', '        address token,\n', '        uint weight\n', '        )\n', '    {\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        require(index < tokenLength);\n', '\n', '        (token, weight) = strategyProvider.getStrategyTokenByIndex(strategyId, index);\n', '    }\n', '\n', '    // Forward to Price smart contract.\n', '    function getPrice(address tokenAddress, uint srcQty) public view returns (uint price){\n', '        require(tokenAddress != address(0));\n', '        (, price) = priceProvider.getRates(tokenAddress, srcQty);\n', '        return price;\n', '    }\n', '\n', '    function getStrategyTokenPrice(uint strategyId, uint tokenIndex) public view returns (uint price) {\n', '        uint totalLength;\n', '\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', '        require(tokenIndex <= totalLength);\n', '        address[] memory tokens;\n', '        uint[] memory weights;\n', '        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\n', '\n', '        //Default get the price for one Ether\n', '\n', '        return getPrice(tokens[tokenIndex], 10**18);\n', '    }\n', '\n', '    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\n', '        bool result = super.setProvider(_id, _providerAddress);\n', '        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\n', '\n', '        if(_type == TypeDefinitions.ProviderType.Strategy) {\n', '            emit Log("StrategyProvider");\n', '            strategyProvider = StrategyProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Exchange) {\n', '            emit Log("ExchangeProvider");\n', '            exchangeProvider = ExchangeProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Price) {\n', '            emit Log("PriceProvider");\n', '            priceProvider = PriceProviderInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Storage) {\n', '            emit Log("StorageProvider");\n', '            olympusStorage = OlympusStorageInterface(_providerAddress);\n', '        } else if(_type == TypeDefinitions.ProviderType.Whitelist) {\n', '            emit Log("WhitelistProvider");\n', '            whitelistProvider = WhitelistProviderInterface(_providerAddress);\n', '        } else {\n', '            emit Log("Unknown provider type supplied.");\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function buyIndex(uint strategyId, address depositAddress, bool feeIsMOT)\n', '    public onlyAllowed payable returns (uint indexOrderId)\n', '    {\n', '        require(msg.value > minimumInWei);\n', '        if(maximumInWei > 0){\n', '            require(msg.value <= maximumInWei);\n', '        }\n', '        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\n', "        // can't buy an index without tokens.\n", '        require(tokenLength > 0);\n', '        address[] memory tokens = new address[](tokenLength);\n', '        uint[] memory weights = new uint[](tokenLength);\n', '        bytes32 exchangeId;\n', '\n', '        (,,,,tokens,weights,,,exchangeId) = strategyProvider.getStrategy(strategyId);\n', '\n', '        uint[3] memory amounts;\n', '        amounts[0] = msg.value; //uint totalAmount\n', '        amounts[1] = getFeeAmount(amounts[0], feeIsMOT); // fee\n', '        amounts[2] = payFee(amounts[0], amounts[1], msg.sender, feeIsMOT);\n', '\n', '        // create order.\n', '        indexOrderId = olympusStorage.addOrderBasicFields(\n', '          strategyId,\n', '          msg.sender,\n', '          amounts[0],\n', '          amounts[1],\n', '          exchangeId\n', '        );\n', '\n', '        uint[][4] memory subOrderTemp;\n', '        // 0: token amounts\n', '        // 1: estimatedPrices\n', '        subOrderTemp[0] = initializeArray(tokenLength);\n', '        subOrderTemp[1] = initializeArray(tokenLength);\n', '\n', '        emit LogNumber(indexOrderId);\n', '\n', '\n', '        require(exchangeProvider.startPlaceOrder(indexOrderId, depositAddress));\n', '\n', '        for (uint i = 0; i < tokenLength; i ++ ) {\n', '\n', '            // ignore those tokens with zero weight.\n', '            if(weights[i] <= 0) {\n', '                continue;\n', '            }\n', '            // token has to be supported by exchange provider.\n', '            if(!exchangeProvider.checkTokenSupported(ERC20(tokens[i]))){\n', '                emit Log("Exchange provider doesn\'t support");\n', '                revert();\n', '            }\n', '\n', '            // check if price provider supports it.\n', '            if(!priceProvider.checkTokenSupported(tokens[i])){\n', '                emit Log("Price provider doesn\'t support");\n', '                revert();\n', '            }\n', '\n', '            subOrderTemp[0][i] = amounts[2] * weights[i] / 100;\n', '            subOrderTemp[1][i] = getPrice(tokens[i], subOrderTemp[0][i]);\n', '\n', '            emit LogAddress(tokens[i]);\n', '            emit LogNumber(subOrderTemp[0][i]);\n', '            emit LogNumber(subOrderTemp[1][i]);\n', '            require(exchangeProvider.addPlaceOrderItem(indexOrderId, ERC20(tokens[i]), subOrderTemp[0][i], subOrderTemp[1][i]));\n', '        }\n', '\n', '        olympusStorage.addTokenDetails(\n', '            indexOrderId,\n', '            tokens, weights, subOrderTemp[0], subOrderTemp[1]\n', '        );\n', '\n', '\n', '        emit LogNumber(amounts[2]);\n', '        require((exchangeProvider.endPlaceOrder.value(amounts[2])(indexOrderId)));\n', '\n', '\n', '        strategyProvider.updateFollower(strategyId, true);\n', '\n', '        strategyProvider.incrementStatistics(strategyId, msg.value);\n', '\n', '        return indexOrderId;\n', '    }\n', '\n', '    function initializeArray(uint length) private pure returns (uint[]){\n', '        return new uint[](length);\n', '    }\n', '\n', '    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\n', '        return olympusStorage.resetOrderIdTo(_start);\n', '    }\n', '\n', '    // For app/3rd-party clients to check details / status.\n', '    function getIndexOrder(uint _orderId) public view returns\n', '    (uint[])\n', '    {\n', '        // 0 strategyId\n', '        // 1 dateCreated\n', '        // 2 dateCompleted\n', '        // 3 amountInWei\n', '        // 4 tokenLength\n', '        uint[] memory orderPartial = new uint[](5);\n', '        address[] memory buyer = new address[](1);\n', '        bytes32[] memory exchangeId = new bytes32[](1);\n', '        StorageTypeDefinitions.OrderStatus[] memory status = new StorageTypeDefinitions.OrderStatus[](1);\n', '\n', '\n', '        (orderPartial[0], buyer[0], status[0], orderPartial[1]) = olympusStorage.getIndexOrder1(_orderId);\n', '        (orderPartial[2], orderPartial[3], orderPartial[4], exchangeId[0]) = olympusStorage.getIndexOrder2(_orderId);\n', '        address[] memory tokens = new address[](orderPartial[4]);\n', '\n', '        for(uint i = 0; i < orderPartial[4]; i++){\n', '            tokens[i] = olympusStorage.getIndexToken(_orderId, i);\n', '        }\n', '        return (\n', '          orderPartial\n', '        );\n', '    }\n', '\n', '    function updateIndexOrderToken(\n', '        uint _orderId,\n', '        address _tokenAddress,\n', '        uint _actualPrice,\n', '        uint _totalTokenAmount,\n', '        uint _completedQuantity\n', '    ) external allowProviderOnly(TypeDefinitions.ProviderType.Exchange) returns (bool success)\n', '    {\n', '        uint completedTokenAmount;\n', '        uint tokenIndex;\n', '        (completedTokenAmount, tokenIndex) = olympusStorage.getOrderTokenCompletedAmount(_orderId,_tokenAddress);\n', '\n', '        ExchangeAdapterBase.OrderStatus status;\n', '\n', '        if(completedTokenAmount == 0 && _completedQuantity < completedTokenAmount){\n', '            status = ExchangeAdapterBase.OrderStatus.PartiallyCompleted;\n', '        }\n', '\n', '        if(_completedQuantity >= completedTokenAmount){\n', '            status = ExchangeAdapterBase.OrderStatus.Completed;\n', '        }\n', '        olympusStorage.updateIndexOrderToken(_orderId, tokenIndex, _totalTokenAmount, _actualPrice, _completedQuantity, status);\n', '\n', '        return true;\n', '    }\n', '\n', '    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\n', '        external allowProviderOnly(TypeDefinitions.ProviderType.Exchange)\n', '        returns (bool success)\n', '    {\n', '        olympusStorage.updateOrderStatus(_orderId, _status);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getSubOrderStatus(uint _orderId, address _tokenAddress)\n', '        external view returns (ExchangeAdapterBase.OrderStatus)\n', '    {\n', '        return exchangeProvider.getSubOrderStatus(_orderId, ERC20(_tokenAddress));\n', '    }\n', '\n', '    function adjustFee(uint _newFeePercentage) public onlyOwner returns (bool success) {\n', '        require(_newFeePercentage < DENOMINATOR);\n', '        feePercentage = _newFeePercentage;\n', '        return true;\n', '    }\n', '\n', '    function adjustMOTFeeDiscount(uint _newDiscountPercentage) public onlyOwner returns(bool success) {\n', '        require(_newDiscountPercentage <= 100);\n', '        MOTDiscount = _newDiscountPercentage;\n', '        return true;\n', '    }\n', '\n', '    function adjustTradeRange(uint _minInWei, uint _maxInWei) public onlyOwner returns (bool success) {\n', '        require(_minInWei > 0);\n', '        require(_maxInWei > _minInWei);\n', '        minimumInWei = _minInWei;\n', '        maximumInWei = _maxInWei;\n', '\n', '        return true;\n', '    }\n', '\n', '    function getFeeAmount(uint amountInWei, bool feeIsMOT) private view returns (uint){\n', '        if(feeIsMOT){\n', '            return ((amountInWei * feePercentage / DENOMINATOR) * (100 - MOTDiscount)) / 100;\n', '        } else {\n', '            return amountInWei * feePercentage / DENOMINATOR;\n', '        }\n', '    }\n', '\n', '    function payFee(uint totalValue, uint feeValueInETH, address sender, bool feeIsMOT) private returns (uint){\n', '        if(feeIsMOT){\n', '            // Transfer MOT\n', '            uint MOTPrice;\n', '            uint allowance = MOT.allowance(sender,address(this));\n', '            (MOTPrice,) = priceProvider.getRates(address(MOT), feeValueInETH);\n', '            uint amount = (feeValueInETH * MOTPrice) / 10**18;\n', '            require(allowance >= amount);\n', '            require(MOT.transferFrom(sender,address(this),amount));\n', '            return totalValue; // Use all sent ETH to buy, because fee is paid in MOT\n', '        } else { // We use ETH as fee, so deduct that from the amount of ETH sent\n', '            return totalValue - feeValueInETH;\n', '        }\n', '    }\n', '\n', '    function withdrawERC20(address receiveAddress,address _tokenAddress) public onlyOwner returns(bool success)\n', '    {\n', '        uint _balance = ERC20(_tokenAddress).balanceOf(address(this));\n', '        require(_tokenAddress != 0x0 && receiveAddress != 0x0 && _balance != 0);\n', '        require(ERC20(_tokenAddress).transfer(receiveAddress,_balance));\n', '        return true;\n', '    }\n', '    function withdrawETH(address receiveAddress) public onlyOwner returns(bool success)\n', '    {\n', '        require(receiveAddress != 0x0);\n', '        receiveAddress.transfer(this.balance);\n', '        return true;\n', '    }\n', '}']
