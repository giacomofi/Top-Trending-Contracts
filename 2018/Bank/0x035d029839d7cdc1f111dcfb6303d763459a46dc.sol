['pragma solidity ^0.4.18;\n', '\n', '/// @title manages special access privileges.\n', '/// @author Axiom Zen (https://www.axiomzen.co)\n', '/// @dev See KittyAccessControl\n', '\n', 'contract AccessControl {\n', '      /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) external onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract EggFactory is AccessControl{\n', '    \n', '    event EggOpened(address eggOwner, uint256 eggId, uint256 amount);\n', '    event EggBought(address eggOwner, uint256 eggId, uint256 amount);\n', '    \n', '    // @dev Sanity check that allows us to ensure that we are pointing to the\n', '    //  right auction in our setEggFactoryAddress() call.\n', '    bool public isEggFactory = true;\n', '\n', '    address public vaultAddress;\n', '\n', '    // @dev Scheme of egg\n', '    struct EggScheme{\n', '        uint256 id;\n', '        uint256 stock; // max available eggs. zero for unlimited\n', '        uint256 purchased; // purchased eggs\n', '        uint256 customGene; // custom gene for future beast\n', '        uint256 maxAllowedToBuy; // max amount allowed to buy on single transaction. zero for unnlimited\n', '        \n', '        uint256 increase; // price increase. zero for no increase\n', '        uint256 price; // base price of the egg\n', '        \n', '        bool active; // is the egg active to be bought\n', '        bool open; // is the egg active to be opened \n', '        bool isEggScheme;\n', '    }\n', '\n', '    // Mapping of existing eggs \n', '    // @dev: uint256 is the ID of the egg scheme\n', '    mapping (uint256 => EggScheme) public eggs;\n', '    uint256[] public eggsIndexes;\n', '    \n', '    uint256[] public activeEggs;\n', '    mapping (uint256 => uint256) indexesActiveEggs;\n', '\n', '    // Mapping of eggs owned by an address\n', '    // @dev: owner => ( eggId => eggsAmount )\n', '    mapping ( address => mapping ( uint256 => uint256 ) ) public eggsOwned;\n', '    \n', '\n', '    // Extend constructor\n', '    function EggFactory(address _vaultAddress) public {\n', '        vaultAddress = _vaultAddress;\n', '        ceoAddress = msg.sender;\n', '    }\n', '\n', '    // Verify existence of id to avoid collision\n', '    function eggExists( uint _eggId) internal view returns(bool) {\n', '        return eggs[_eggId].isEggScheme;\n', '    }\n', '\n', '    function listEggsIds() external view returns(uint256[]){\n', '        return eggsIndexes;\n', '    }\n', '    \n', '    function listActiveEggs() external view returns(uint256[]){\n', '        return activeEggs;\n', '    }\n', '\n', '    // Get the amount of purchased eggs of a struct\n', '    function getPurchased(uint256 _eggId) external view returns(uint256){\n', '        return eggs[_eggId].purchased;\n', '    }\n', '\n', '    // Set a new address for vault contract\n', '    function setVaultAddress(address _vaultAddress) public onlyCEO returns (bool) {\n', '        require( _vaultAddress != address(0x0) );\n', '        vaultAddress = _vaultAddress;\n', '    }\n', '    \n', '    function setActiveStatusEgg( uint256 _eggId, bool state ) public onlyCEO returns (bool){\n', '        require(eggExists(_eggId));\n', '        eggs[_eggId].active = state;\n', '\n', '        if(state) {\n', '            uint newIndex = activeEggs.push(_eggId);\n', '            indexesActiveEggs[_eggId] = uint256(newIndex-1);\n', '        }\n', '        else {\n', '            indexesActiveEggs[activeEggs[activeEggs.length-1]] = indexesActiveEggs[_eggId];\n', '            activeEggs[indexesActiveEggs[_eggId]] = activeEggs[activeEggs.length-1]; \n', '            delete activeEggs[activeEggs.length-1];\n', '            activeEggs.length--;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function setOpenStatusEgg( uint256 _eggId, bool state ) public onlyCEO returns (bool){\n', '        require(eggExists(_eggId));\n', '        eggs[_eggId].open = state;\n', '        return true;\n', '    }\n', '\n', '    // Add modifier of onlyCOO\n', '    function createEggScheme( uint256 _eggId, uint256 _stock, uint256 _maxAllowedToBuy, uint256 _customGene, uint256 _price, uint256 _increase, bool _active, bool _open ) public onlyCEO returns (bool){\n', '        require(!eggExists(_eggId));\n', '        \n', '        eggs[_eggId].isEggScheme = true;\n', '        \n', '        eggs[_eggId].id = _eggId;\n', '        eggs[_eggId].stock = _stock;\n', '        eggs[_eggId].maxAllowedToBuy = _maxAllowedToBuy;\n', '        eggs[_eggId].purchased = 0;\n', '        eggs[_eggId].customGene = _customGene;\n', '        eggs[_eggId].price = _price;\n', '        eggs[_eggId].increase = _increase;\n', '        \n', '        setActiveStatusEgg(_eggId,_active);\n', '        setOpenStatusEgg(_eggId,_open);\n', '        \n', '        eggsIndexes.push(_eggId);\n', '        return true;\n', '    }\n', '\n', '    function buyEgg(uint256 _eggId, uint256 _amount) public payable returns(bool){\n', '        require(eggs[_eggId].active == true);\n', '        require((currentEggPrice(_eggId)*_amount) == msg.value);\n', '        require(eggs[_eggId].maxAllowedToBuy == 0 || _amount<=eggs[_eggId].maxAllowedToBuy);\n', '        require(eggs[_eggId].stock == 0 || eggs[_eggId].purchased+_amount<=eggs[_eggId].stock); // until max\n', '        \n', '        vaultAddress.transfer(msg.value); // transfer the amount to vault\n', '        \n', '        eggs[_eggId].purchased += _amount;\n', '        eggsOwned[msg.sender][_eggId] += _amount;\n', '\n', '        emit EggBought(msg.sender, _eggId, _amount);\n', '    } \n', '    \n', '    function currentEggPrice( uint256 _eggId ) public view returns (uint256) {\n', '        return eggs[_eggId].price + (eggs[_eggId].purchased * eggs[_eggId].increase);\n', '    }\n', '    \n', '    function openEgg(uint256 _eggId, uint256 _amount) external {\n', '        require(eggs[_eggId].open == true);\n', '        require(eggsOwned[msg.sender][_eggId] >= _amount);\n', '        \n', '        eggsOwned[msg.sender][_eggId] -= _amount;\n', '        emit EggOpened(msg.sender, _eggId, _amount);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/// @title manages special access privileges.\n', '/// @author Axiom Zen (https://www.axiomzen.co)\n', '/// @dev See KittyAccessControl\n', '\n', 'contract AccessControl {\n', '      /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) external onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract EggFactory is AccessControl{\n', '    \n', '    event EggOpened(address eggOwner, uint256 eggId, uint256 amount);\n', '    event EggBought(address eggOwner, uint256 eggId, uint256 amount);\n', '    \n', '    // @dev Sanity check that allows us to ensure that we are pointing to the\n', '    //  right auction in our setEggFactoryAddress() call.\n', '    bool public isEggFactory = true;\n', '\n', '    address public vaultAddress;\n', '\n', '    // @dev Scheme of egg\n', '    struct EggScheme{\n', '        uint256 id;\n', '        uint256 stock; // max available eggs. zero for unlimited\n', '        uint256 purchased; // purchased eggs\n', '        uint256 customGene; // custom gene for future beast\n', '        uint256 maxAllowedToBuy; // max amount allowed to buy on single transaction. zero for unnlimited\n', '        \n', '        uint256 increase; // price increase. zero for no increase\n', '        uint256 price; // base price of the egg\n', '        \n', '        bool active; // is the egg active to be bought\n', '        bool open; // is the egg active to be opened \n', '        bool isEggScheme;\n', '    }\n', '\n', '    // Mapping of existing eggs \n', '    // @dev: uint256 is the ID of the egg scheme\n', '    mapping (uint256 => EggScheme) public eggs;\n', '    uint256[] public eggsIndexes;\n', '    \n', '    uint256[] public activeEggs;\n', '    mapping (uint256 => uint256) indexesActiveEggs;\n', '\n', '    // Mapping of eggs owned by an address\n', '    // @dev: owner => ( eggId => eggsAmount )\n', '    mapping ( address => mapping ( uint256 => uint256 ) ) public eggsOwned;\n', '    \n', '\n', '    // Extend constructor\n', '    function EggFactory(address _vaultAddress) public {\n', '        vaultAddress = _vaultAddress;\n', '        ceoAddress = msg.sender;\n', '    }\n', '\n', '    // Verify existence of id to avoid collision\n', '    function eggExists( uint _eggId) internal view returns(bool) {\n', '        return eggs[_eggId].isEggScheme;\n', '    }\n', '\n', '    function listEggsIds() external view returns(uint256[]){\n', '        return eggsIndexes;\n', '    }\n', '    \n', '    function listActiveEggs() external view returns(uint256[]){\n', '        return activeEggs;\n', '    }\n', '\n', '    // Get the amount of purchased eggs of a struct\n', '    function getPurchased(uint256 _eggId) external view returns(uint256){\n', '        return eggs[_eggId].purchased;\n', '    }\n', '\n', '    // Set a new address for vault contract\n', '    function setVaultAddress(address _vaultAddress) public onlyCEO returns (bool) {\n', '        require( _vaultAddress != address(0x0) );\n', '        vaultAddress = _vaultAddress;\n', '    }\n', '    \n', '    function setActiveStatusEgg( uint256 _eggId, bool state ) public onlyCEO returns (bool){\n', '        require(eggExists(_eggId));\n', '        eggs[_eggId].active = state;\n', '\n', '        if(state) {\n', '            uint newIndex = activeEggs.push(_eggId);\n', '            indexesActiveEggs[_eggId] = uint256(newIndex-1);\n', '        }\n', '        else {\n', '            indexesActiveEggs[activeEggs[activeEggs.length-1]] = indexesActiveEggs[_eggId];\n', '            activeEggs[indexesActiveEggs[_eggId]] = activeEggs[activeEggs.length-1]; \n', '            delete activeEggs[activeEggs.length-1];\n', '            activeEggs.length--;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function setOpenStatusEgg( uint256 _eggId, bool state ) public onlyCEO returns (bool){\n', '        require(eggExists(_eggId));\n', '        eggs[_eggId].open = state;\n', '        return true;\n', '    }\n', '\n', '    // Add modifier of onlyCOO\n', '    function createEggScheme( uint256 _eggId, uint256 _stock, uint256 _maxAllowedToBuy, uint256 _customGene, uint256 _price, uint256 _increase, bool _active, bool _open ) public onlyCEO returns (bool){\n', '        require(!eggExists(_eggId));\n', '        \n', '        eggs[_eggId].isEggScheme = true;\n', '        \n', '        eggs[_eggId].id = _eggId;\n', '        eggs[_eggId].stock = _stock;\n', '        eggs[_eggId].maxAllowedToBuy = _maxAllowedToBuy;\n', '        eggs[_eggId].purchased = 0;\n', '        eggs[_eggId].customGene = _customGene;\n', '        eggs[_eggId].price = _price;\n', '        eggs[_eggId].increase = _increase;\n', '        \n', '        setActiveStatusEgg(_eggId,_active);\n', '        setOpenStatusEgg(_eggId,_open);\n', '        \n', '        eggsIndexes.push(_eggId);\n', '        return true;\n', '    }\n', '\n', '    function buyEgg(uint256 _eggId, uint256 _amount) public payable returns(bool){\n', '        require(eggs[_eggId].active == true);\n', '        require((currentEggPrice(_eggId)*_amount) == msg.value);\n', '        require(eggs[_eggId].maxAllowedToBuy == 0 || _amount<=eggs[_eggId].maxAllowedToBuy);\n', '        require(eggs[_eggId].stock == 0 || eggs[_eggId].purchased+_amount<=eggs[_eggId].stock); // until max\n', '        \n', '        vaultAddress.transfer(msg.value); // transfer the amount to vault\n', '        \n', '        eggs[_eggId].purchased += _amount;\n', '        eggsOwned[msg.sender][_eggId] += _amount;\n', '\n', '        emit EggBought(msg.sender, _eggId, _amount);\n', '    } \n', '    \n', '    function currentEggPrice( uint256 _eggId ) public view returns (uint256) {\n', '        return eggs[_eggId].price + (eggs[_eggId].purchased * eggs[_eggId].increase);\n', '    }\n', '    \n', '    function openEgg(uint256 _eggId, uint256 _amount) external {\n', '        require(eggs[_eggId].open == true);\n', '        require(eggsOwned[msg.sender][_eggId] >= _amount);\n', '        \n', '        eggsOwned[msg.sender][_eggId] -= _amount;\n', '        emit EggOpened(msg.sender, _eggId, _amount);\n', '    }\n', '}']
