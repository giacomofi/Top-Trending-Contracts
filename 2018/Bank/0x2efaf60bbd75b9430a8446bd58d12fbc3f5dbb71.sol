['pragma solidity ^0.4.18;\n', '\n', '///EtherMinerals\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c181908193c1d04151311061912521f13">[email&#160;protected]</a>> (https://github.com/dete)\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '}\n', '\n', 'contract EtherMinerals is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '  event Birth(uint256 tokenId, bytes32 name, address owner);\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** STRUCTS ***/\n', '  struct Mineral {\n', '    bytes32 name;\n', '    address owner;\n', '    uint256 price;\n', '    uint256 last_price;\n', '    address approve_transfer_to;\n', '  }\n', '\n', '  /*** CONSTANTS ***/\n', '  string public constant NAME = "EtherMinerals";\n', '  string public constant SYMBOL = "MINERAL";\n', '  \n', '  uint256 private startingPrice = 0.01 ether;\n', '  uint256 private firstStepLimit =  0.15 ether;\n', '  uint256 private secondStepLimit = 0.564957 ether;\n', '  \n', '  bool public gameOpen = false;\n', '\n', '  /*** STORAGE ***/\n', '  mapping (address => uint256) private ownerCount;\n', '  mapping (uint256 => address) public lastBuyer;\n', '\n', '  address public ceoAddress;\n', '  mapping (uint256 => address) public extra;\n', '  \n', '  uint256 mineral_count;\n', ' \n', '  mapping (uint256 => Mineral) private minerals;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  modifier onlyCEO() { require(msg.sender == ceoAddress); _; }\n', '\n', '  /*** ACCESS MODIFIES ***/\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setLast(uint256 _id, address _newExtra) public onlyCEO {\n', '    require(_newExtra != address(0));\n', '    lastBuyer[_id] = _newExtra;\n', '  }\n', '\n', '  /*** DEFAULT METHODS ***/\n', '  function symbol() public pure returns (string) { return SYMBOL; }\n', '  function name() public pure returns (string) { return NAME; }\n', '  function implementsERC721() public pure returns (bool) { return true; }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function EtherMinerals() public {\n', '    ceoAddress = msg.sender;\n', '    lastBuyer[1] = msg.sender;\n', '    lastBuyer[2] = msg.sender;\n', '    lastBuyer[3] = msg.sender;\n', '    lastBuyer[4] = msg.sender;\n', '    lastBuyer[5] = msg.sender;\n', '    lastBuyer[6] = msg.sender;\n', '    lastBuyer[7] = msg.sender;\n', '    lastBuyer[8] = msg.sender;\n', '    lastBuyer[9] = msg.sender;\n', '  }\n', '\n', '  /*** INTERFACE METHODS ***/\n', '\n', '  function createMineral(bytes32 _name, uint256 _price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    _create_mineral(_name, address(this), _price, 0);\n', '  }\n', '\n', '  function createPromoMineral(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    require(_owner != address(0));\n', '    _create_mineral(_name, _owner, _price, _last_price);\n', '  }\n', '\n', '  function openGame() public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    gameOpen = true;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return mineral_count;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownerCount[_owner];\n', '  }\n', '  function priceOf(uint256 _mineral_id) public view returns (uint256 price) {\n', '    return minerals[_mineral_id].price;\n', '  }\n', '\n', '  function getMineral(uint256 _mineral_id) public view returns (\n', '    uint256 id,\n', '    bytes32 mineral_name,\n', '    address owner,\n', '    uint256 price,\n', '    uint256 last_price\n', '  ) {\n', '    id = _mineral_id;\n', '    mineral_name = minerals[_mineral_id].name;\n', '    owner = minerals[_mineral_id].owner;\n', '    price = minerals[_mineral_id].price;\n', '    last_price = minerals[_mineral_id].last_price;\n', '  }\n', '  \n', '  function getMinerals() public view returns (uint256[], bytes32[], address[], uint256[]) {\n', '    uint256[] memory ids = new uint256[](mineral_count);\n', '    bytes32[] memory names = new bytes32[](mineral_count);\n', '    address[] memory owners = new address[](mineral_count);\n', '    uint256[] memory prices = new uint256[](mineral_count);\n', '    for(uint256 _id = 0; _id < mineral_count; _id++){\n', '      ids[_id] = _id;\n', '      names[_id] = minerals[_id].name;\n', '      owners[_id] = minerals[_id].owner;\n', '      prices[_id] = minerals[_id].price;\n', '    }\n', '    return (ids, names, owners, prices);\n', '  }\n', '  \n', '  function getBalance() public onlyCEO view returns(uint){\n', '      return address(this).balance;\n', '  }\n', '  \n', '\n', '  \n', '  function purchase(uint256 _mineral_id) public payable {\n', '    require(gameOpen == true);\n', '    Mineral storage mineral = minerals[_mineral_id];\n', '\n', '    require(mineral.owner != msg.sender);\n', '    require(msg.sender != address(0));  \n', '    require(msg.value >= mineral.price);\n', '\n', '    uint256 excess = SafeMath.sub(msg.value, mineral.price);\n', '    uint256 reward = uint256(SafeMath.div(SafeMath.mul(mineral.price, 90), 100));\n', '  \n', '\n', '    if(mineral.owner != address(this)){\n', '      mineral.owner.transfer(reward);\n', '    }\n', '    \n', '    \n', '    mineral.last_price = mineral.price;\n', '    address _old_owner = mineral.owner;\n', '    \n', '    if (mineral.price < firstStepLimit) {\n', '      // first stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 200), 90);\n', '    } else if (mineral.price < secondStepLimit) {\n', '      // second stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 118), 90);\n', '    } else {\n', '      // third stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 113), 90);\n', '    }\n', '    mineral.owner = msg.sender;\n', '\n', '    emit Transfer(_old_owner, mineral.owner, _mineral_id);\n', '    emit TokenSold(_mineral_id, mineral.last_price, mineral.price, _old_owner, mineral.owner, mineral.name);\n', '\n', '    msg.sender.transfer(excess);\n', '  }\n', '\n', '  function payout() public onlyCEO {\n', '    ceoAddress.transfer(address(this).balance);\n', '  }\n', '\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 resultIndex = 0;\n', '      for (uint256 mineralId = 0; mineralId <= totalSupply(); mineralId++) {\n', '        if (minerals[mineralId].owner == _owner) {\n', '          result[resultIndex] = mineralId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /*** ERC-721 compliance. ***/\n', '\n', '  function approve(address _to, uint256 _mineral_id) public {\n', '    require(msg.sender == minerals[_mineral_id].owner);\n', '    minerals[_mineral_id].approve_transfer_to = _to;\n', '    emit Approval(msg.sender, _to, _mineral_id);\n', '  }\n', '  function ownerOf(uint256 _mineral_id) public view returns (address owner){\n', '    owner = minerals[_mineral_id].owner;\n', '    require(owner != address(0));\n', '  }\n', '  function takeOwnership(uint256 _mineral_id) public {\n', '    address oldOwner = minerals[_mineral_id].owner;\n', '    require(msg.sender != address(0));\n', '    require(minerals[_mineral_id].approve_transfer_to == msg.sender);\n', '    _transfer(oldOwner, msg.sender, _mineral_id);\n', '  }\n', '  function transfer(address _to, uint256 _mineral_id) public {\n', '    require(msg.sender != address(0));\n', '    require(msg.sender == minerals[_mineral_id].owner);\n', '    _transfer(msg.sender, _to, _mineral_id);\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 _mineral_id) public {\n', '    require(_from == minerals[_mineral_id].owner);\n', '    require(minerals[_mineral_id].approve_transfer_to == _to);\n', '    require(_to != address(0));\n', '    _transfer(_from, _to, _mineral_id);\n', '  }\n', ' \n', '  function createAllTokens() public onlyCEO{\n', '    createMineral("Emerald", 10000000000000000);\n', '    createMineral("Opal", 10000000000000000);\n', '    createMineral("Diamond", 10000000000000000);\n', '    createMineral("Bismuth", 10000000000000000);\n', '    createMineral("Amethyst", 10000000000000000);\n', '    createMineral("Gold", 10000000000000000);\n', '    createMineral("Fluorite", 10000000000000000);\n', '    createMineral("Ruby", 10000000000000000);\n', '    createMineral("Sapphire", 10000000000000000);\n', '    createMineral("Pascoite", 10000000000000000);\n', '    createMineral("Karpatite", 10000000000000000);\n', '    createMineral("Uvarovite", 10000000000000000);\n', '    createMineral("Kryptonite", 10000000000000000);\n', '    createMineral("Good ol&#39; Rock", 10000000000000000);\n', '    createMineral("Malachite", 10000000000000000);\n', '    createMineral("Silver", 10000000000000000);\n', '    createMineral("Burmese Tourmaline" ,10000000000000000);\n', '    }\n', '\n', '  /*** PRIVATE METHODS ***/\n', '\n', '  function _create_mineral(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) private {\n', '    // Params: name, owner, price, is_for_sale, is_public, share_price, increase, fee, share_count,\n', '    minerals[mineral_count] = Mineral({\n', '      name: _name,\n', '      owner: _owner,\n', '      price: _price,\n', '      last_price: _last_price,\n', '      approve_transfer_to: address(0)\n', '    });\n', '    \n', '\n', '    \n', '    \n', '    emit Birth(mineral_count, _name, _owner);\n', '    emit Transfer(address(this), _owner, mineral_count);\n', '    mineral_count++;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _mineral_id) private {\n', '    minerals[_mineral_id].owner = _to;\n', '    minerals[_mineral_id].approve_transfer_to = address(0);\n', '    ownerCount[_from] -= 1;\n', '    ownerCount[_to] += 1;\n', '    emit Transfer(_from, _to, _mineral_id);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '///EtherMinerals\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '}\n', '\n', 'contract EtherMinerals is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '  event Birth(uint256 tokenId, bytes32 name, address owner);\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** STRUCTS ***/\n', '  struct Mineral {\n', '    bytes32 name;\n', '    address owner;\n', '    uint256 price;\n', '    uint256 last_price;\n', '    address approve_transfer_to;\n', '  }\n', '\n', '  /*** CONSTANTS ***/\n', '  string public constant NAME = "EtherMinerals";\n', '  string public constant SYMBOL = "MINERAL";\n', '  \n', '  uint256 private startingPrice = 0.01 ether;\n', '  uint256 private firstStepLimit =  0.15 ether;\n', '  uint256 private secondStepLimit = 0.564957 ether;\n', '  \n', '  bool public gameOpen = false;\n', '\n', '  /*** STORAGE ***/\n', '  mapping (address => uint256) private ownerCount;\n', '  mapping (uint256 => address) public lastBuyer;\n', '\n', '  address public ceoAddress;\n', '  mapping (uint256 => address) public extra;\n', '  \n', '  uint256 mineral_count;\n', ' \n', '  mapping (uint256 => Mineral) private minerals;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  modifier onlyCEO() { require(msg.sender == ceoAddress); _; }\n', '\n', '  /*** ACCESS MODIFIES ***/\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setLast(uint256 _id, address _newExtra) public onlyCEO {\n', '    require(_newExtra != address(0));\n', '    lastBuyer[_id] = _newExtra;\n', '  }\n', '\n', '  /*** DEFAULT METHODS ***/\n', '  function symbol() public pure returns (string) { return SYMBOL; }\n', '  function name() public pure returns (string) { return NAME; }\n', '  function implementsERC721() public pure returns (bool) { return true; }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function EtherMinerals() public {\n', '    ceoAddress = msg.sender;\n', '    lastBuyer[1] = msg.sender;\n', '    lastBuyer[2] = msg.sender;\n', '    lastBuyer[3] = msg.sender;\n', '    lastBuyer[4] = msg.sender;\n', '    lastBuyer[5] = msg.sender;\n', '    lastBuyer[6] = msg.sender;\n', '    lastBuyer[7] = msg.sender;\n', '    lastBuyer[8] = msg.sender;\n', '    lastBuyer[9] = msg.sender;\n', '  }\n', '\n', '  /*** INTERFACE METHODS ***/\n', '\n', '  function createMineral(bytes32 _name, uint256 _price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    _create_mineral(_name, address(this), _price, 0);\n', '  }\n', '\n', '  function createPromoMineral(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    require(_owner != address(0));\n', '    _create_mineral(_name, _owner, _price, _last_price);\n', '  }\n', '\n', '  function openGame() public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    gameOpen = true;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return mineral_count;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownerCount[_owner];\n', '  }\n', '  function priceOf(uint256 _mineral_id) public view returns (uint256 price) {\n', '    return minerals[_mineral_id].price;\n', '  }\n', '\n', '  function getMineral(uint256 _mineral_id) public view returns (\n', '    uint256 id,\n', '    bytes32 mineral_name,\n', '    address owner,\n', '    uint256 price,\n', '    uint256 last_price\n', '  ) {\n', '    id = _mineral_id;\n', '    mineral_name = minerals[_mineral_id].name;\n', '    owner = minerals[_mineral_id].owner;\n', '    price = minerals[_mineral_id].price;\n', '    last_price = minerals[_mineral_id].last_price;\n', '  }\n', '  \n', '  function getMinerals() public view returns (uint256[], bytes32[], address[], uint256[]) {\n', '    uint256[] memory ids = new uint256[](mineral_count);\n', '    bytes32[] memory names = new bytes32[](mineral_count);\n', '    address[] memory owners = new address[](mineral_count);\n', '    uint256[] memory prices = new uint256[](mineral_count);\n', '    for(uint256 _id = 0; _id < mineral_count; _id++){\n', '      ids[_id] = _id;\n', '      names[_id] = minerals[_id].name;\n', '      owners[_id] = minerals[_id].owner;\n', '      prices[_id] = minerals[_id].price;\n', '    }\n', '    return (ids, names, owners, prices);\n', '  }\n', '  \n', '  function getBalance() public onlyCEO view returns(uint){\n', '      return address(this).balance;\n', '  }\n', '  \n', '\n', '  \n', '  function purchase(uint256 _mineral_id) public payable {\n', '    require(gameOpen == true);\n', '    Mineral storage mineral = minerals[_mineral_id];\n', '\n', '    require(mineral.owner != msg.sender);\n', '    require(msg.sender != address(0));  \n', '    require(msg.value >= mineral.price);\n', '\n', '    uint256 excess = SafeMath.sub(msg.value, mineral.price);\n', '    uint256 reward = uint256(SafeMath.div(SafeMath.mul(mineral.price, 90), 100));\n', '  \n', '\n', '    if(mineral.owner != address(this)){\n', '      mineral.owner.transfer(reward);\n', '    }\n', '    \n', '    \n', '    mineral.last_price = mineral.price;\n', '    address _old_owner = mineral.owner;\n', '    \n', '    if (mineral.price < firstStepLimit) {\n', '      // first stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 200), 90);\n', '    } else if (mineral.price < secondStepLimit) {\n', '      // second stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 118), 90);\n', '    } else {\n', '      // third stage\n', '      mineral.price = SafeMath.div(SafeMath.mul(mineral.price, 113), 90);\n', '    }\n', '    mineral.owner = msg.sender;\n', '\n', '    emit Transfer(_old_owner, mineral.owner, _mineral_id);\n', '    emit TokenSold(_mineral_id, mineral.last_price, mineral.price, _old_owner, mineral.owner, mineral.name);\n', '\n', '    msg.sender.transfer(excess);\n', '  }\n', '\n', '  function payout() public onlyCEO {\n', '    ceoAddress.transfer(address(this).balance);\n', '  }\n', '\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 resultIndex = 0;\n', '      for (uint256 mineralId = 0; mineralId <= totalSupply(); mineralId++) {\n', '        if (minerals[mineralId].owner == _owner) {\n', '          result[resultIndex] = mineralId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /*** ERC-721 compliance. ***/\n', '\n', '  function approve(address _to, uint256 _mineral_id) public {\n', '    require(msg.sender == minerals[_mineral_id].owner);\n', '    minerals[_mineral_id].approve_transfer_to = _to;\n', '    emit Approval(msg.sender, _to, _mineral_id);\n', '  }\n', '  function ownerOf(uint256 _mineral_id) public view returns (address owner){\n', '    owner = minerals[_mineral_id].owner;\n', '    require(owner != address(0));\n', '  }\n', '  function takeOwnership(uint256 _mineral_id) public {\n', '    address oldOwner = minerals[_mineral_id].owner;\n', '    require(msg.sender != address(0));\n', '    require(minerals[_mineral_id].approve_transfer_to == msg.sender);\n', '    _transfer(oldOwner, msg.sender, _mineral_id);\n', '  }\n', '  function transfer(address _to, uint256 _mineral_id) public {\n', '    require(msg.sender != address(0));\n', '    require(msg.sender == minerals[_mineral_id].owner);\n', '    _transfer(msg.sender, _to, _mineral_id);\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 _mineral_id) public {\n', '    require(_from == minerals[_mineral_id].owner);\n', '    require(minerals[_mineral_id].approve_transfer_to == _to);\n', '    require(_to != address(0));\n', '    _transfer(_from, _to, _mineral_id);\n', '  }\n', ' \n', '  function createAllTokens() public onlyCEO{\n', '    createMineral("Emerald", 10000000000000000);\n', '    createMineral("Opal", 10000000000000000);\n', '    createMineral("Diamond", 10000000000000000);\n', '    createMineral("Bismuth", 10000000000000000);\n', '    createMineral("Amethyst", 10000000000000000);\n', '    createMineral("Gold", 10000000000000000);\n', '    createMineral("Fluorite", 10000000000000000);\n', '    createMineral("Ruby", 10000000000000000);\n', '    createMineral("Sapphire", 10000000000000000);\n', '    createMineral("Pascoite", 10000000000000000);\n', '    createMineral("Karpatite", 10000000000000000);\n', '    createMineral("Uvarovite", 10000000000000000);\n', '    createMineral("Kryptonite", 10000000000000000);\n', '    createMineral("Good ol\' Rock", 10000000000000000);\n', '    createMineral("Malachite", 10000000000000000);\n', '    createMineral("Silver", 10000000000000000);\n', '    createMineral("Burmese Tourmaline" ,10000000000000000);\n', '    }\n', '\n', '  /*** PRIVATE METHODS ***/\n', '\n', '  function _create_mineral(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) private {\n', '    // Params: name, owner, price, is_for_sale, is_public, share_price, increase, fee, share_count,\n', '    minerals[mineral_count] = Mineral({\n', '      name: _name,\n', '      owner: _owner,\n', '      price: _price,\n', '      last_price: _last_price,\n', '      approve_transfer_to: address(0)\n', '    });\n', '    \n', '\n', '    \n', '    \n', '    emit Birth(mineral_count, _name, _owner);\n', '    emit Transfer(address(this), _owner, mineral_count);\n', '    mineral_count++;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _mineral_id) private {\n', '    minerals[_mineral_id].owner = _to;\n', '    minerals[_mineral_id].approve_transfer_to = address(0);\n', '    ownerCount[_from] -= 1;\n', '    ownerCount[_to] += 1;\n', '    emit Transfer(_from, _to, _mineral_id);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
