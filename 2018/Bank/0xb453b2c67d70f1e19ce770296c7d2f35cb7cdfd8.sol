['pragma solidity ^0.4.23;\n', '\n', 'contract Events {\n', '    event onActive();\n', '\n', '    event onOuterDividend\n', '    (\n', '        uint256 _dividends\n', '    );\n', '\n', '    event onBuyKey\n', '    (\n', '        address _address,\n', '        uint256 _pID,\n', '        uint256 _rID,\n', '        uint256 _eth,\n', '        uint256 _key,\n', '        bool _timeExtended\n', '    );\n', '\n', '    event onReload\n', '    (\n', '        address _address,\n', '        uint256 _pID,\n', '        uint256 _rID,\n', '        uint256 _eth,\n', '        uint256 _dividend,\n', '        uint256 _luckBonus,\n', '        uint256 _key,\n', '        bool _timeExtended\n', '    );\n', '\n', '    event onWithdraw\n', '    (\n', '        address _address,\n', '        uint256 _pID,\n', '        uint256 _rID,\n', '        uint256 _eth,\n', '        uint256 _dividend,\n', '        uint256 _luckBonus\n', '    );\n', '\n', '    event onSell\n', '    (\n', '        address _address,\n', '        uint256 _pID,\n', '        uint256 _rID,\n', '        uint256 _key,\n', '        uint256 _eth\n', '    );\n', '\n', '    event onWinLuckyPrize\n', '    (\n', '        uint256 _rID\n', '    );\n', '}\n', '\n', 'contract PT7D is Events {\n', '    using SafeMath for *;\n', '\n', '    ReferralInterface private Referralcontract_;\n', '//==============================================================================\n', '//   config\n', '//==============================================================================\n', '    string public name = "PT7D";\n', '    string public symbol = "PT";\n', '    uint256 constant internal magnitude = 1e18;\n', '//==============================================================================\n', '//   variable config\n', '//==============================================================================\n', '    uint16 public sellFee_ = 1500;\n', '    uint8 public luckyBonus_ = 5;\n', '    uint8 public attenuationFee_ = 1;\n', '    uint8 public luckyEdge_ = 70;\n', '    uint8 public extensionThreshold_ = 2;\n', '\n', '    uint256 public extensionMin_ = 0.1 ether;\n', '    uint256 public extensionMax_ = 10 ether;\n', '    uint256 public rndInit_ = 24 hours;\n', '    uint256 public rndInc_ = 1 hours;\n', '//==============================================================================\n', '//   datasets\n', '//============================================================================== \n', '    uint256 public pID_ = 0;\n', '    uint256 public rID_ = 0;\n', '    uint256 public keySupply_ = 0;\n', '    uint256 public totalInvestment_ = 0;\n', '    uint256 public pot_ = 0;\n', '    uint256 internal profitPerShare_ = 0;\n', '    uint256 public luckyRounds_ = 0;\n', '\n', '    mapping (address => uint256) public pIDxAddr_;\n', '    mapping (uint256 => Datasets.Player) public plyr_;\n', '    mapping (uint256 => Datasets.Round) public round_;\n', '    mapping (uint256 => mapping (uint256 => uint256)) public plyrRnds_;\n', '    mapping (bytes32 => bool) public administrators;\n', '\n', '    uint256 internal administratorBalance_ = 0;\n', '//==============================================================================\n', '//   modifier\n', '//==============================================================================\n', '    modifier isActivated() {\n', '        require(activated_ == true, "its not ready yet."); \n', '        _;\n', '    }\n', '\n', '    modifier onlyAdministrator(){\n', '        address _customerAddress = msg.sender; \n', '        require(administrators[keccak256(_customerAddress)]);\n', '        _;\n', '    }\n', '//==============================================================================\n', '//   public functions\n', '//==============================================================================\n', '    constructor()\n', '        public\n', '    {\n', '        administrators[0x14c319c3c982350b442e4074ec4736b3ac376ebdca548bdda0097040223e7bd6] = true;\n', '    }\n', '    \n', '    function()\n', '        public\n', '        payable\n', '        isActivated()\n', '    {\n', '        uint256 _curBalance = totalEthereumBalance();\n', '        if (_curBalance > 10 ether && _curBalance < 500 ether)\n', '            require(msg.value >= 10 ether);\n', '\n', '        uint256 _pID = getPlayerID();\n', '        endRoundAndGetEarnings(_pID);\n', '\n', '        uint256 _amountOfkeys;\n', '        bool _timeExtended;\n', '        (_amountOfkeys,_timeExtended) = purchaseKeys(_pID, msg.value);\n', '        \n', '        emit onBuyKey(msg.sender, _pID, rID_, msg.value, _amountOfkeys, _timeExtended);\n', '    }\n', '    \n', '    function outerDividend()\n', '        external\n', '        payable\n', '        isActivated()\n', '    {\n', '        uint256 _dividends = msg.value;\n', '        profitPerShare_ = profitPerShare_.add(_dividends.mul(magnitude).div(keySupply_));\n', '\n', '        emit onOuterDividend(_dividends);\n', '    }\n', '\n', '    function reLoad()\n', '        public\n', '        isActivated()\n', '    {\n', '        uint256 _pID = getPlayerID();\n', '        endRoundAndGetEarnings(_pID);\n', '\n', '        uint256 _dividends;\n', '        uint256 _luckBonus;\n', '        (_dividends,_luckBonus) = withdrawEarnings(_pID);\n', '        uint256 _earnings = _dividends.add(_luckBonus);\n', '\n', '        uint256 _curBalance = totalEthereumBalance();\n', '        if (_curBalance > 10 ether && _curBalance < 500 ether)\n', '            require(_earnings >= 10 ether);\n', '\n', '        uint256 _amountOfkeys;\n', '        bool _timeExtended;\n', '        (_amountOfkeys,_timeExtended) = purchaseKeys(_pID, _earnings);\n', '\n', '        emit onReload(msg.sender, _pID, rID_, _earnings, _dividends, _luckBonus, _amountOfkeys, _timeExtended);\n', '    }\n', '\n', '    function withdraw()\n', '        public\n', '        isActivated()\n', '    {\n', '        uint256 _pID = getPlayerID();\n', '        endRoundAndGetEarnings(_pID);\n', '\n', '        uint256 _dividends;\n', '        uint256 _luckBonus;\n', '        (_dividends,_luckBonus) = withdrawEarnings(_pID);\n', '        uint256 _earnings = _dividends.add(_luckBonus);\n', '        if (_earnings > 0)\n', '            plyr_[_pID].addr.transfer(_earnings);\n', '\n', '        emit onWithdraw(msg.sender, _pID, rID_, _earnings, _dividends, _luckBonus);\n', '    }\n', '    \n', '    function sell(uint256 _amountOfkeys)\n', '        public\n', '        isActivated()\n', '    {\n', '        uint256 _pID = getPlayerID();\n', '        endRoundAndGetEarnings(_pID);\n', '\n', '        Datasets.Player _plyr = plyr_[_pID];\n', '        Datasets.Round _round = round_[rID_];\n', '\n', '        require(_amountOfkeys <= _plyr.keys);\n', '\n', '        uint256 _eth = keysToEthereum(_amountOfkeys);\n', '        uint256 _sellFee = calcSellFee(_pID);\n', '        uint256 _dividends = _eth.mul(_sellFee).div(10000);\n', '        uint256 _taxedEthereum = _eth.sub(_dividends);\n', '        \n', '        keySupply_ = keySupply_.sub(_amountOfkeys);\n', '\n', '        _plyr.keys = _plyr.keys.sub(_amountOfkeys);\n', '        _plyr.mask = _plyr.mask - (int256)(_taxedEthereum.add(profitPerShare_.mul(_amountOfkeys).div(magnitude)));\n', '        \n', '        if (keySupply_ > 0) {\n', '            profitPerShare_ = profitPerShare_.add((_dividends.mul(magnitude)).div(keySupply_));\n', '        }\n', '        \n', '        emit onSell(msg.sender, _pID, rID_, _amountOfkeys, _eth);\n', '    }\n', '//==============================================================================\n', '//   private functions\n', '//==============================================================================\n', '    function getPlayerID()\n', '        private\n', '        returns (uint256)\n', '    {\n', '        uint256 _pID = pIDxAddr_[msg.sender];\n', '        if (_pID == 0)\n', '        {\n', '            pID_++;\n', '            _pID = pID_;\n', '            pIDxAddr_[msg.sender] = _pID;\n', '            plyr_[_pID].addr = msg.sender;\n', '        } \n', '        return (_pID);\n', '    }\n', '\n', '    function getExtensionValue()\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Datasets.Round _round = round_[rID_];\n', '        uint256 _extensionEth = _round.investment.mul(extensionThreshold_).div(1000);\n', '        _extensionEth = _extensionEth >= extensionMin_ ? _extensionEth : extensionMin_;\n', '        _extensionEth = _extensionEth >= extensionMax_ ? _extensionEth : extensionMax_;\n', '        return _extensionEth;\n', '    }\n', '\n', '    function getReferBonus()\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _investment = round_[rID_].investment;\n', '        uint256 _referBonus = 10;\n', '        if (_investment >= 25000 ether && _investment < 50000 ether)\n', '            _referBonus = 20;\n', '        else if (_investment >= 50000 ether && _investment < 75000 ether)\n', '            _referBonus = 30;\n', '        else if (_investment >= 75000 ether && _investment < 100000 ether)\n', '            _referBonus = 40;\n', '        else if (_investment >= 100000 ether)\n', '            _referBonus = 50;\n', '        return _referBonus;\n', '    }\n', '\n', '    function endRoundAndGetEarnings(uint256 _pID)\n', '        private\n', '    {\n', '        Datasets.Round _round = round_[rID_];\n', '        if (_round.investment > pot_.mul(luckyEdge_).div(100) || now > _round.end)\n', '            endRound();\n', '\n', '        Datasets.Player _plyr = plyr_[_pID];\n', '        if (_plyr.lrnd == 0)\n', '            _plyr.lrnd = rID_;\n', '        uint256 _lrnd = _plyr.lrnd;\n', '        if (rID_ > 1 && _lrnd != rID_)\n', '        {\n', '            uint256 _plyrRoundKeys = plyrRnds_[_pID][_lrnd];\n', '            if (_plyrRoundKeys > 0 && round_[_lrnd].ppk > 0)\n', '                _plyr.luck = _plyr.luck.add(_plyrRoundKeys.mul(round_[_lrnd].ppk).div(magnitude));\n', '\n', '            _plyr.lrnd = rID_;\n', '        }\n', '    }\n', '\n', '    function endRound()\n', '        private\n', '    {\n', '        Datasets.Round _round = round_[rID_];\n', '\n', '        if (_round.keys > 0 && _round.investment <= pot_.mul(luckyEdge_).div(100) && now > _round.end)\n', '        {\n', '            uint256 _referBonus = getReferBonus();\n', '            uint256 _ref = pot_.mul(_referBonus).div(100);\n', '            uint256 _luck = pot_.sub(_ref);\n', '            _round.ppk = _luck.mul(magnitude).div(_round.keys);\n', '            pot_ = 0;\n', '            luckyRounds_++;\n', '\n', '            Referralcontract_.outerDividend.value(_ref)();\n', '\n', '            emit onWinLuckyPrize(rID_);\n', '        }\n', '\n', '        rID_++;\n', '        round_[rID_].strt = now;\n', '        round_[rID_].end = now.add(rndInit_);\n', '    }\n', '\n', '    function purchaseKeys(uint256 _pID, uint256 _eth)\n', '        private\n', '        returns(uint256,bool)\n', '    {\n', '        Datasets.Player _plyr = plyr_[_pID];\n', '        Datasets.Round _round = round_[rID_];\n', '\n', '        if (_eth > 1000000000)\n', '        {\n', '            uint256 _luck = _eth.mul(luckyBonus_).div(100);\n', '            uint256 _amountOfkeys = ethereumTokeys(_eth.sub(_luck));\n', '            \n', '            bool _timeExtended = false;\n', '            if (_eth >= getExtensionValue())\n', '            {\n', '                _round.end = _round.end.add(rndInc_);\n', '                if (_round.end > now.add(rndInit_))\n', '                    _round.end = now.add(rndInit_);\n', '                _timeExtended = true;\n', '            }\n', '\n', '            uint256 _totalKeys = _plyr.keys.add(_amountOfkeys);\n', '            if (_plyr.keys == 0)\n', '                _plyr.keytime = now;\n', '            else\n', '                _plyr.keytime = now.sub(now.sub(_plyr.keytime).mul(_plyr.keys).div(_totalKeys));\n', '            _plyr.keys = _totalKeys;\n', '            _plyr.mask = _plyr.mask + (int256)(profitPerShare_.mul(_amountOfkeys).div(magnitude));\n', '\n', '            _round.keys = _round.keys.add(_amountOfkeys);\n', '            _round.investment = _round.investment.add(_eth);\n', '\n', '            plyrRnds_[_pID][rID_] = plyrRnds_[_pID][rID_].add(_amountOfkeys);\n', '\n', '            keySupply_ = keySupply_.add(_amountOfkeys);\n', '            totalInvestment_ = totalInvestment_.add(_eth);\n', '            pot_ = pot_.add(_luck);\n', '            \n', '            return (_amountOfkeys,_timeExtended);\n', '        }\n', '        return (0,false);\n', '    }\n', '\n', '    function withdrawEarnings(uint256 _pID)\n', '        private\n', '        returns(uint256,uint256)\n', '    {\n', '        uint256 _dividends = getPlayerDividends(_pID);\n', '        uint256 _luckBonus = getPlayerLuckyBonus(_pID);\n', '\n', '        if (_dividends > 0)\n', '            plyr_[_pID].mask = (int256)(plyr_[_pID].keys.mul(profitPerShare_).div(magnitude));\n', '        if (_luckBonus > 0)\n', '            plyr_[_pID].luck = 0;\n', '\n', '        return (_dividends,_luckBonus);\n', '    }\n', '//==============================================================================\n', '//   view only functions\n', '//==============================================================================\n', '    function getReferralContract()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return address(Referralcontract_);\n', '    }\n', '\n', '    function getBuyPrice(uint256 _keysToBuy)\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 _amountOfkeys = ethereumTokeys(1e18);\n', '        return _keysToBuy.mul(magnitude).div(_amountOfkeys);\n', '    }\n', '\n', '    function getSellPrice(uint256 _keysToSell)\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(_keysToSell <= keySupply_, "exceeded the maximum");\n', '        uint256 _ethereum = keysToEthereum(_keysToSell);\n', '        uint256 _dividends = _ethereum.mul(sellFee_).div(10000);\n', '        uint256 _taxedEthereum = _ethereum.sub(_dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return this.balance;\n', '    }\n', '\n', '    function calcLuckEdge()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pot_.mul(luckyEdge_).div(100);\n', '    }\n', '\n', '    function calcSellFee(uint256 _pID)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _attenuation = now.sub(plyr_[_pID].keytime).div(86400).mul(attenuationFee_);\n', '        if (_attenuation > 100)\n', '            _attenuation = 100;\n', '        uint256 _sellFee = sellFee_.sub(sellFee_.mul(_attenuation).div(100));\n', '        return _sellFee;\n', '    }\n', '\n', '    function getPlayerDividends(uint256 _pID)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        Datasets.Player _plyr = plyr_[_pID];\n', '        return (uint256)((int256)(_plyr.keys.mul(profitPerShare_).div(magnitude)) - _plyr.mask);\n', '    }\n', '\n', '    function getPlayerLuckyBonus(uint256 _pID)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        Datasets.Player _plyr = plyr_[_pID];\n', '        uint256 _lrnd = _plyr.lrnd;\n', '        Datasets.Round _round = round_[_lrnd];\n', '        uint256 _plyrRoundKeys = plyrRnds_[_pID][_lrnd];\n', '        uint256 _luckBonus = _plyr.luck;\n', '\n', '        if (_lrnd != rID_ && _lrnd > 0 && _plyrRoundKeys > 0 && _round.ppk > 0)\n', '            _luckBonus = _luckBonus.add(_plyrRoundKeys.mul(_round.ppk).div(magnitude));\n', '\n', '        return _luckBonus;\n', '    }\n', '\n', '    function calcRoundEarnings(uint256 _pID, uint256 _rID)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return plyrRnds_[_pID][_rID].mul(round_[_rID].ppk).div(magnitude);\n', '    }\n', '\n', '//==============================================================================\n', '//   key calculate\n', '//==============================================================================\n', '    uint256 constant internal keyPriceInitial_ = 0.0000001 ether;\n', '    uint256 constant internal keyPriceIncremental_ = 0.00000001 ether;\n', '\n', '    function ethereumTokeys(uint256 _ethereum)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _keyPriceInitial = keyPriceInitial_ * 1e18;\n', '        uint256 _keysReceived = \n', '         (\n', '            (\n', '                SafeMath.sub(\n', '                    (SafeMath.sqrt\n', '                        (\n', '                            (_keyPriceInitial**2)\n', '                            +\n', '                            (2*(keyPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n', '                            +\n', '                            (((keyPriceIncremental_)**2)*(keySupply_**2))\n', '                            +\n', '                            (2*(keyPriceIncremental_)*_keyPriceInitial*keySupply_)\n', '                        )\n', '                    ), _keyPriceInitial\n', '                )\n', '            )/(keyPriceIncremental_)\n', '        )-(keySupply_)\n', '        ;\n', '  \n', '        return _keysReceived;\n', '    }\n', '    \n', '    function keysToEthereum(uint256 _keys)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 keys_ = (_keys + 1e18);\n', '        uint256 _keySupply = (keySupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            keyPriceInitial_ +(keyPriceIncremental_ * (_keySupply/1e18))\n', '                        )-keyPriceIncremental_\n', '                    )*(keys_ - 1e18)\n', '                ),(keyPriceIncremental_*((keys_**2-keys_)/1e18))/2\n', '            )\n', '        /1e18);\n', '        return _etherReceived;\n', '    }\n', '//==============================================================================\n', '//   administrator only functions\n', '//============================================================================== \n', '    function setAdministrator(bytes32 _identifier, bool _status)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '    \n', '    function setReferralContract(address _referral)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        require(address(Referralcontract_) == address(0), "silly dev, you already did that");\n', '        Referralcontract_ = ReferralInterface(_referral);\n', '    }\n', '\n', '    bool public activated_ = false;\n', '    function activate()\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        require(address(Referralcontract_) != address(0), "must link to Referral Contract");\n', '        require(activated_ == false, "already activated");\n', '        \n', '        activated_ = true;\n', '        rID_ = 1;\n', '        round_[rID_].strt = now;\n', '        round_[rID_].end = now.add(rndInit_);\n', '\n', '        emit onActive();\n', '    }\n', '\n', '    function updateConfigs(\n', '        uint16 _sellFee,uint8 _luckyBonus,uint8 _attenuationFee,uint8 _luckyEdge,uint8 _extensionThreshold,\n', '        uint256 _extensionMin,uint256 _extensionMax,uint256 _rndInit,uint256 _rndInc)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        require(_sellFee >= 0 && _sellFee <= 10000, "out of range.");\n', '        require(_luckyBonus >= 0 && _luckyBonus <= 100, "out of range.");\n', '        require(_attenuationFee >= 0 && _attenuationFee <= 100, "out of range.");\n', '        require(_luckyEdge >= 0 && _luckyEdge <= 100, "out of range.");\n', '        require(_extensionThreshold >= 0 && _extensionThreshold <= 1000, "out of range.");\n', '\n', '        sellFee_ = _sellFee == 0 ? sellFee_ : _sellFee;\n', '        luckyBonus_ = _luckyBonus == 0 ? luckyBonus_ : _luckyBonus;\n', '        attenuationFee_ = _attenuationFee == 0 ? attenuationFee_ : _attenuationFee;\n', '        luckyEdge_ = _luckyEdge == 0 ? luckyEdge_ : _luckyEdge;\n', '        extensionThreshold_ = _extensionThreshold == 0 ? extensionThreshold_ : _extensionThreshold;\n', '        \n', '        extensionMin_ = _extensionMin == 0 ? extensionMin_ : _extensionMin;\n', '        extensionMax_ = _extensionMax == 0 ? extensionMax_ : _extensionMax;\n', '        rndInit_ = _rndInit == 0 ? rndInit_ : _rndInit;\n', '        rndInc_ = _rndInc == 0 ? rndInc_ : _rndInc;\n', '    }\n', '\n', '    function administratorInvest()\n', '        public\n', '        payable\n', '        onlyAdministrator()\n', '    {\n', '        administratorBalance_ = administratorBalance_.add(msg.value);\n', '    }\n', '\n', '    function administratorWithdraw(uint256 _eth)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        require(_eth <= administratorBalance_);\n', '        administratorBalance_ = administratorBalance_.sub(_eth);\n', '        msg.sender.transfer(_eth);\n', '    }\n', '}\n', '\n', 'interface ReferralInterface {\n', '    function outerDividend() external payable;\n', '}\n', '\n', 'library Datasets {\n', '    struct Player {\n', '        address addr;\n', '        uint256 keys;\n', '        int256 mask;\n', '        uint256 luck;\n', '        uint256 lrnd;\n', '        uint256 keytime;\n', '    }\n', '\n', '    struct Round {\n', '        uint256 strt;\n', '        uint256 end;\n', '        uint256 keys;\n', '        uint256 ppk;\n', '        uint256 investment;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}']