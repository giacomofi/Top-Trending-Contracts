['pragma solidity ^0.4.18;\n', '\n', 'contract FortuneToken {\n', '    address public admin;\n', '\n', '    uint ethereumTokenInitValue = 5 ether;\n', '\n', '    uint fortuneInitValue = 1 ether;\n', '\n', '    struct EtherFortuneToken {\n', '        address owner;\n', '        uint price;\n', '    }\n', '\n', '    struct Fortune {\n', '        address owner;\n', '        address buyer1;\n', '        address buyer2;\n', '        uint price;\n', '        uint buyers;\n', '    }\n', '\n', '    EtherFortuneToken private EthereumToken;\n', '\n', '    Fortune[] private fortunes;\n', '\n', '    modifier onlyDev() {\n', '    require(msg.sender == admin);\n', '    _;\n', '    }\n', '\n', '    function FortuneToken() public {\n', '      admin = msg.sender;\n', '\n', '      Fortune memory _fortune = Fortune({\n', '          owner: address(this),\n', '          buyer1: address(0),\n', '          buyer2: address(0),\n', '          price: fortuneInitValue,\n', '          buyers: 0\n', '      });\n', '\n', '      fortunes.push(_fortune);\n', '\n', '      EtherFortuneToken memory _fortuneEthereumToken = EtherFortuneToken({\n', '          owner: address(this),\n', '          price: ethereumTokenInitValue\n', '      });\n', '\n', '      EthereumToken = _fortuneEthereumToken;\n', '    }\n', '\n', '    function getFortune(uint id) public view returns (address owner, address buyer1, address buyer2, uint price, uint buyers) {\n', '        Fortune storage _fortune = fortunes[id];\n', '        owner = _fortune.owner;\n', '        buyer1 = _fortune.buyer1;\n', '        buyer2 = _fortune.buyer2;\n', '        price = _fortune.price;\n', '        buyers = _fortune.buyers;\n', '    }\n', '\n', '    function payFortune(uint id) public payable{\n', '        Fortune storage _fortune = fortunes[id];\n', '        require(_fortune.buyer1 == address(0) || _fortune.buyer2 == address(0));\n', '        require(msg.value == _fortune.price);\n', '        if (_fortune.buyer1 == address(0)) {\n', '            _fortune.buyer1 = msg.sender;\n', '            _fortune.buyers++;\n', '        } else {\n', '            _fortune.buyer2 = msg.sender;\n', '            Fortune memory newFortune1 = Fortune({\n', '                owner: _fortune.buyer1,\n', '                buyer1: address(0),\n', '                buyer2: address(0),\n', '                price: SafeMath.div(SafeMath.mul(_fortune.price, 100), 90),\n', '                buyers: 0\n', '            });\n', '            Fortune memory newFortune2 = Fortune({\n', '                owner: _fortune.buyer2,\n', '                buyer1: address(0),\n', '                buyer2: address(0),\n', '                price: SafeMath.div(SafeMath.mul(_fortune.price, 100), 90),\n', '                buyers: 0\n', '            });\n', '            fortunes.push(newFortune1);\n', '            fortunes.push(newFortune2);\n', '            _fortune.buyers++;\n', '        }\n', '        if (_fortune.owner != address(this)) {\n', '            uint256 payment = SafeMath.div(SafeMath.mul(_fortune.price, 90), 100);\n', '            _fortune.owner.transfer(payment);\n', '        }\n', '        if (EthereumToken.owner != address(this)) {\n', '            uint256 paymentEthereumTokenFortune = SafeMath.div(SafeMath.mul(_fortune.price, 5), 100);\n', '            EthereumToken.owner.transfer(paymentEthereumTokenFortune);\n', '        }\n', '\n', '\n', '\n', '    }\n', '\n', '    function buyEthereumToken() public payable {\n', '        require(EthereumToken.price == msg.value);\n', '        require(EthereumToken.owner != msg.sender);\n', '        address newOwner = msg.sender;\n', '        if (EthereumToken.owner != address(this)) {\n', '            uint256 payment = SafeMath.div(SafeMath.mul(EthereumToken.price, 90), 100);\n', '            EthereumToken.owner.transfer(payment);\n', '        }\n', '        EthereumToken.owner = newOwner;\n', '        EthereumToken.price = SafeMath.div(SafeMath.mul(EthereumToken.price, 120), 90);\n', '\n', '    }\n', '\n', '    function getEthereumToken() public view returns (address owner, uint price) {\n', '        EtherFortuneToken storage _fortuneEthereumToken = EthereumToken;\n', '        owner = _fortuneEthereumToken.owner;\n', '        price = _fortuneEthereumToken.price;\n', '    }\n', '\n', '    function totalFortunes() public view returns (uint) {\n', '        return fortunes.length;\n', '    }\n', '\n', '    function getBalance() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function withdraw(address _to) public onlyDev{\n', '        if (_to != address(0)) {\n', '            _to.transfer(this.balance);\n', '        } else {\n', '            admin.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']