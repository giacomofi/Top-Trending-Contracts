['pragma solidity ^0.4.18;\n', '\n', '///EtherDrugs\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3b7b6a7b693b2abbabcbea9b6bdfdb0bc">[email&#160;protected]</a>> (https://github.com/dete)\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '}\n', '\n', 'contract EtherDrugs is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '  event Birth(uint256 tokenId, bytes32 name, address owner);\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** STRUCTS ***/\n', '  struct Drug {\n', '    bytes32 name;\n', '    address owner;\n', '    uint256 price;\n', '    uint256 last_price;\n', '    address approve_transfer_to;\n', '  }\n', '\n', '  /*** CONSTANTS ***/\n', '  string public constant NAME = "EtherDrugs";\n', '  string public constant SYMBOL = "DRUG";\n', '  \n', '  bool public gameOpen = false;\n', '\n', '  /*** STORAGE ***/\n', '  mapping (address => uint256) private ownerCount;\n', '  mapping (uint256 => address) public lastBuyer;\n', '\n', '  address public ceoAddress;\n', '  mapping (uint256 => address) public extra;\n', '  \n', '  uint256 drug_count;\n', ' \n', '  mapping (uint256 => Drug) private drugs;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  modifier onlyCEO() { require(msg.sender == ceoAddress); _; }\n', '\n', '  /*** ACCESS MODIFIES ***/\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setLast(uint256 _id, address _newExtra) public onlyCEO {\n', '    require(_newExtra != address(0));\n', '    lastBuyer[_id] = _newExtra;\n', '  }\n', '\n', '  /*** DEFAULT METHODS ***/\n', '  function symbol() public pure returns (string) { return SYMBOL; }\n', '  function name() public pure returns (string) { return NAME; }\n', '  function implementsERC721() public pure returns (bool) { return true; }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function EtherDrugs() public {\n', '    ceoAddress = msg.sender;\n', '    lastBuyer[1] = msg.sender;\n', '    lastBuyer[2] = msg.sender;\n', '    lastBuyer[3] = msg.sender;\n', '    lastBuyer[4] = msg.sender;\n', '    lastBuyer[5] = msg.sender;\n', '    lastBuyer[6] = msg.sender;\n', '    lastBuyer[7] = msg.sender;\n', '    lastBuyer[8] = msg.sender;\n', '    lastBuyer[9] = msg.sender;\n', '  }\n', '\n', '  /*** INTERFACE METHODS ***/\n', '\n', '  function createDrug(bytes32 _name, uint256 _price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    _create_drug(_name, address(this), _price, 0);\n', '  }\n', '\n', '  function createPromoDrug(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    require(_owner != address(0));\n', '    _create_drug(_name, _owner, _price, _last_price);\n', '  }\n', '\n', '  function openGame() public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    gameOpen = true;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return drug_count;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownerCount[_owner];\n', '  }\n', '  function priceOf(uint256 _drug_id) public view returns (uint256 price) {\n', '    return drugs[_drug_id].price;\n', '  }\n', '\n', '  function getDrug(uint256 _drug_id) public view returns (\n', '    uint256 id,\n', '    bytes32 drug_name,\n', '    address owner,\n', '    uint256 price,\n', '    uint256 last_price\n', '  ) {\n', '    id = _drug_id;\n', '    drug_name = drugs[_drug_id].name;\n', '    owner = drugs[_drug_id].owner;\n', '    price = drugs[_drug_id].price;\n', '    last_price = drugs[_drug_id].last_price;\n', '  }\n', '  \n', '  function getDrugs() public view returns (uint256[], bytes32[], address[], uint256[]) {\n', '    uint256[] memory ids = new uint256[](drug_count);\n', '    bytes32[] memory names = new bytes32[](drug_count);\n', '    address[] memory owners = new address[](drug_count);\n', '    uint256[] memory prices = new uint256[](drug_count);\n', '    for(uint256 _id = 0; _id < drug_count; _id++){\n', '      ids[_id] = _id;\n', '      names[_id] = drugs[_id].name;\n', '      owners[_id] = drugs[_id].owner;\n', '      prices[_id] = drugs[_id].price;\n', '    }\n', '    return (ids, names, owners, prices);\n', '  }\n', '  \n', '  function purchase(uint256 _drug_id) public payable {\n', '    require(gameOpen == true);\n', '    Drug storage drug = drugs[_drug_id];\n', '\n', '    require(drug.owner != msg.sender);\n', '    require(msg.sender != address(0));  \n', '    require(msg.value >= drug.price);\n', '\n', '    uint256 excess = SafeMath.sub(msg.value, drug.price);\n', '    uint256 half_diff = SafeMath.div(SafeMath.sub(drug.price, drug.last_price), 2);\n', '    uint256 reward = SafeMath.add(half_diff, drug.last_price);\n', '  \n', '    lastBuyer[1].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 69))); //69% goes to last buyer\n', '    lastBuyer[6].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 2)));  //2% goes to 6th last buyer, else ceo\n', '    lastBuyer[9].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 2)));  //2% goes to 9th last buyer, else ceo\n', '\n', '    if(drug.owner == address(this)){\n', '      ceoAddress.send(reward);\n', '    } else {\n', '      drug.owner.send(reward);\n', '    }\n', '    \n', '    \n', '    drug.last_price = drug.price;\n', '    address _old_owner = drug.owner;\n', '    \n', '    if(drug.price < 1690000000000000000){ // 1.69 eth\n', '        drug.price = SafeMath.mul(SafeMath.div(drug.price, 100), 169); // 1.69x\n', '    } else {\n', '        drug.price = SafeMath.mul(SafeMath.div(drug.price, 100), 125); // 1.2x\n', '    }\n', '    drug.owner = msg.sender;\n', '\n', '    lastBuyer[9] = lastBuyer[8];\n', '    lastBuyer[8] = lastBuyer[7];\n', '    lastBuyer[7] = lastBuyer[6];\n', '    lastBuyer[6] = lastBuyer[5];\n', '    lastBuyer[5] = lastBuyer[4];\n', '    lastBuyer[4] = lastBuyer[3];\n', '    lastBuyer[3] = lastBuyer[2];\n', '    lastBuyer[2] = lastBuyer[1];\n', '    lastBuyer[1] = msg.sender;\n', '\n', '    Transfer(_old_owner, drug.owner, _drug_id);\n', '    TokenSold(_drug_id, drug.last_price, drug.price, _old_owner, drug.owner, drug.name);\n', '\n', '    msg.sender.send(excess);\n', '  }\n', '\n', '  function payout() public onlyCEO {\n', '    ceoAddress.send(this.balance);\n', '  }\n', '\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 resultIndex = 0;\n', '      for (uint256 drugId = 0; drugId <= totalSupply(); drugId++) {\n', '        if (drugs[drugId].owner == _owner) {\n', '          result[resultIndex] = drugId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /*** ERC-721 compliance. ***/\n', '\n', '  function approve(address _to, uint256 _drug_id) public {\n', '    require(msg.sender == drugs[_drug_id].owner);\n', '    drugs[_drug_id].approve_transfer_to = _to;\n', '    Approval(msg.sender, _to, _drug_id);\n', '  }\n', '  function ownerOf(uint256 _drug_id) public view returns (address owner){\n', '    owner = drugs[_drug_id].owner;\n', '    require(owner != address(0));\n', '  }\n', '  function takeOwnership(uint256 _drug_id) public {\n', '    address oldOwner = drugs[_drug_id].owner;\n', '    require(msg.sender != address(0));\n', '    require(drugs[_drug_id].approve_transfer_to == msg.sender);\n', '    _transfer(oldOwner, msg.sender, _drug_id);\n', '  }\n', '  function transfer(address _to, uint256 _drug_id) public {\n', '    require(msg.sender != address(0));\n', '    require(msg.sender == drugs[_drug_id].owner);\n', '    _transfer(msg.sender, _to, _drug_id);\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 _drug_id) public {\n', '    require(_from == drugs[_drug_id].owner);\n', '    require(drugs[_drug_id].approve_transfer_to == _to);\n', '    require(_to != address(0));\n', '    _transfer(_from, _to, _drug_id);\n', '  }\n', '\n', '  /*** PRIVATE METHODS ***/\n', '\n', '  function _create_drug(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) private {\n', '    // Params: name, owner, price, is_for_sale, is_public, share_price, increase, fee, share_count,\n', '    drugs[drug_count] = Drug({\n', '      name: _name,\n', '      owner: _owner,\n', '      price: _price,\n', '      last_price: _last_price,\n', '      approve_transfer_to: address(0)\n', '    });\n', '    \n', '    Drug storage drug = drugs[drug_count];\n', '    \n', '    Birth(drug_count, _name, _owner);\n', '    Transfer(address(this), _owner, drug_count);\n', '    drug_count++;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _drug_id) private {\n', '    drugs[_drug_id].owner = _to;\n', '    drugs[_drug_id].approve_transfer_to = address(0);\n', '    ownerCount[_from] -= 1;\n', '    ownerCount[_to] += 1;\n', '    Transfer(_from, _to, _drug_id);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '///EtherDrugs\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '}\n', '\n', 'contract EtherDrugs is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '  event Birth(uint256 tokenId, bytes32 name, address owner);\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** STRUCTS ***/\n', '  struct Drug {\n', '    bytes32 name;\n', '    address owner;\n', '    uint256 price;\n', '    uint256 last_price;\n', '    address approve_transfer_to;\n', '  }\n', '\n', '  /*** CONSTANTS ***/\n', '  string public constant NAME = "EtherDrugs";\n', '  string public constant SYMBOL = "DRUG";\n', '  \n', '  bool public gameOpen = false;\n', '\n', '  /*** STORAGE ***/\n', '  mapping (address => uint256) private ownerCount;\n', '  mapping (uint256 => address) public lastBuyer;\n', '\n', '  address public ceoAddress;\n', '  mapping (uint256 => address) public extra;\n', '  \n', '  uint256 drug_count;\n', ' \n', '  mapping (uint256 => Drug) private drugs;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  modifier onlyCEO() { require(msg.sender == ceoAddress); _; }\n', '\n', '  /*** ACCESS MODIFIES ***/\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setLast(uint256 _id, address _newExtra) public onlyCEO {\n', '    require(_newExtra != address(0));\n', '    lastBuyer[_id] = _newExtra;\n', '  }\n', '\n', '  /*** DEFAULT METHODS ***/\n', '  function symbol() public pure returns (string) { return SYMBOL; }\n', '  function name() public pure returns (string) { return NAME; }\n', '  function implementsERC721() public pure returns (bool) { return true; }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function EtherDrugs() public {\n', '    ceoAddress = msg.sender;\n', '    lastBuyer[1] = msg.sender;\n', '    lastBuyer[2] = msg.sender;\n', '    lastBuyer[3] = msg.sender;\n', '    lastBuyer[4] = msg.sender;\n', '    lastBuyer[5] = msg.sender;\n', '    lastBuyer[6] = msg.sender;\n', '    lastBuyer[7] = msg.sender;\n', '    lastBuyer[8] = msg.sender;\n', '    lastBuyer[9] = msg.sender;\n', '  }\n', '\n', '  /*** INTERFACE METHODS ***/\n', '\n', '  function createDrug(bytes32 _name, uint256 _price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    _create_drug(_name, address(this), _price, 0);\n', '  }\n', '\n', '  function createPromoDrug(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    require(_owner != address(0));\n', '    _create_drug(_name, _owner, _price, _last_price);\n', '  }\n', '\n', '  function openGame() public onlyCEO {\n', '    require(msg.sender != address(0));\n', '    gameOpen = true;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return drug_count;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownerCount[_owner];\n', '  }\n', '  function priceOf(uint256 _drug_id) public view returns (uint256 price) {\n', '    return drugs[_drug_id].price;\n', '  }\n', '\n', '  function getDrug(uint256 _drug_id) public view returns (\n', '    uint256 id,\n', '    bytes32 drug_name,\n', '    address owner,\n', '    uint256 price,\n', '    uint256 last_price\n', '  ) {\n', '    id = _drug_id;\n', '    drug_name = drugs[_drug_id].name;\n', '    owner = drugs[_drug_id].owner;\n', '    price = drugs[_drug_id].price;\n', '    last_price = drugs[_drug_id].last_price;\n', '  }\n', '  \n', '  function getDrugs() public view returns (uint256[], bytes32[], address[], uint256[]) {\n', '    uint256[] memory ids = new uint256[](drug_count);\n', '    bytes32[] memory names = new bytes32[](drug_count);\n', '    address[] memory owners = new address[](drug_count);\n', '    uint256[] memory prices = new uint256[](drug_count);\n', '    for(uint256 _id = 0; _id < drug_count; _id++){\n', '      ids[_id] = _id;\n', '      names[_id] = drugs[_id].name;\n', '      owners[_id] = drugs[_id].owner;\n', '      prices[_id] = drugs[_id].price;\n', '    }\n', '    return (ids, names, owners, prices);\n', '  }\n', '  \n', '  function purchase(uint256 _drug_id) public payable {\n', '    require(gameOpen == true);\n', '    Drug storage drug = drugs[_drug_id];\n', '\n', '    require(drug.owner != msg.sender);\n', '    require(msg.sender != address(0));  \n', '    require(msg.value >= drug.price);\n', '\n', '    uint256 excess = SafeMath.sub(msg.value, drug.price);\n', '    uint256 half_diff = SafeMath.div(SafeMath.sub(drug.price, drug.last_price), 2);\n', '    uint256 reward = SafeMath.add(half_diff, drug.last_price);\n', '  \n', '    lastBuyer[1].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 69))); //69% goes to last buyer\n', '    lastBuyer[6].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 2)));  //2% goes to 6th last buyer, else ceo\n', '    lastBuyer[9].send(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 2)));  //2% goes to 9th last buyer, else ceo\n', '\n', '    if(drug.owner == address(this)){\n', '      ceoAddress.send(reward);\n', '    } else {\n', '      drug.owner.send(reward);\n', '    }\n', '    \n', '    \n', '    drug.last_price = drug.price;\n', '    address _old_owner = drug.owner;\n', '    \n', '    if(drug.price < 1690000000000000000){ // 1.69 eth\n', '        drug.price = SafeMath.mul(SafeMath.div(drug.price, 100), 169); // 1.69x\n', '    } else {\n', '        drug.price = SafeMath.mul(SafeMath.div(drug.price, 100), 125); // 1.2x\n', '    }\n', '    drug.owner = msg.sender;\n', '\n', '    lastBuyer[9] = lastBuyer[8];\n', '    lastBuyer[8] = lastBuyer[7];\n', '    lastBuyer[7] = lastBuyer[6];\n', '    lastBuyer[6] = lastBuyer[5];\n', '    lastBuyer[5] = lastBuyer[4];\n', '    lastBuyer[4] = lastBuyer[3];\n', '    lastBuyer[3] = lastBuyer[2];\n', '    lastBuyer[2] = lastBuyer[1];\n', '    lastBuyer[1] = msg.sender;\n', '\n', '    Transfer(_old_owner, drug.owner, _drug_id);\n', '    TokenSold(_drug_id, drug.last_price, drug.price, _old_owner, drug.owner, drug.name);\n', '\n', '    msg.sender.send(excess);\n', '  }\n', '\n', '  function payout() public onlyCEO {\n', '    ceoAddress.send(this.balance);\n', '  }\n', '\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 resultIndex = 0;\n', '      for (uint256 drugId = 0; drugId <= totalSupply(); drugId++) {\n', '        if (drugs[drugId].owner == _owner) {\n', '          result[resultIndex] = drugId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /*** ERC-721 compliance. ***/\n', '\n', '  function approve(address _to, uint256 _drug_id) public {\n', '    require(msg.sender == drugs[_drug_id].owner);\n', '    drugs[_drug_id].approve_transfer_to = _to;\n', '    Approval(msg.sender, _to, _drug_id);\n', '  }\n', '  function ownerOf(uint256 _drug_id) public view returns (address owner){\n', '    owner = drugs[_drug_id].owner;\n', '    require(owner != address(0));\n', '  }\n', '  function takeOwnership(uint256 _drug_id) public {\n', '    address oldOwner = drugs[_drug_id].owner;\n', '    require(msg.sender != address(0));\n', '    require(drugs[_drug_id].approve_transfer_to == msg.sender);\n', '    _transfer(oldOwner, msg.sender, _drug_id);\n', '  }\n', '  function transfer(address _to, uint256 _drug_id) public {\n', '    require(msg.sender != address(0));\n', '    require(msg.sender == drugs[_drug_id].owner);\n', '    _transfer(msg.sender, _to, _drug_id);\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 _drug_id) public {\n', '    require(_from == drugs[_drug_id].owner);\n', '    require(drugs[_drug_id].approve_transfer_to == _to);\n', '    require(_to != address(0));\n', '    _transfer(_from, _to, _drug_id);\n', '  }\n', '\n', '  /*** PRIVATE METHODS ***/\n', '\n', '  function _create_drug(bytes32 _name, address _owner, uint256 _price, uint256 _last_price) private {\n', '    // Params: name, owner, price, is_for_sale, is_public, share_price, increase, fee, share_count,\n', '    drugs[drug_count] = Drug({\n', '      name: _name,\n', '      owner: _owner,\n', '      price: _price,\n', '      last_price: _last_price,\n', '      approve_transfer_to: address(0)\n', '    });\n', '    \n', '    Drug storage drug = drugs[drug_count];\n', '    \n', '    Birth(drug_count, _name, _owner);\n', '    Transfer(address(this), _owner, drug_count);\n', '    drug_count++;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _drug_id) private {\n', '    drugs[_drug_id].owner = _to;\n', '    drugs[_drug_id].approve_transfer_to = address(0);\n', '    ownerCount[_from] -= 1;\n', '    ownerCount[_to] += 1;\n', '    Transfer(_from, _to, _drug_id);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
