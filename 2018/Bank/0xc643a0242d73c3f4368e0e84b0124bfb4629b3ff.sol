['pragma solidity 0.4.25;\n', '\n', '\n', 'library SafeMath8 {\n', '\n', '    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint8 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        uint8 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint8 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library SafeMath256 {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint256 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function _validateAddress(address _addr) internal pure {\n', '        require(_addr != address(0), "invalid address");\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "not a contract owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _validateAddress(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    mapping(address => bool) controllers;\n', '\n', '    modifier onlyController {\n', '        require(_isController(msg.sender), "no controller rights");\n', '        _;\n', '    }\n', '\n', '    function _isController(address _controller) internal view returns (bool) {\n', '        return controllers[_controller];\n', '    }\n', '\n', '    function _setControllers(address[] _controllers) internal {\n', '        for (uint256 i = 0; i < _controllers.length; i++) {\n', '            _validateAddress(_controllers[i]);\n', '            controllers[_controllers[i]] = true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Upgradable is Controllable {\n', '    address[] internalDependencies;\n', '    address[] externalDependencies;\n', '\n', '    function getInternalDependencies() public view returns(address[]) {\n', '        return internalDependencies;\n', '    }\n', '\n', '    function getExternalDependencies() public view returns(address[]) {\n', '        return externalDependencies;\n', '    }\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        for (uint256 i = 0; i < _newDependencies.length; i++) {\n', '            _validateAddress(_newDependencies[i]);\n', '        }\n', '        internalDependencies = _newDependencies;\n', '    }\n', '\n', '    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        externalDependencies = _newDependencies;\n', '        _setControllers(_newDependencies);\n', '    }\n', '}\n', '\n', 'contract Random {\n', '    function random(uint256) external view returns (uint256) {}\n', '    function randomOfBlock(uint256, uint256) external view returns (uint256) {}\n', '}\n', '\n', '\n', '\n', '\n', '//////////////CONTRACT//////////////\n', '\n', '\n', '\n', '\n', 'contract Nest is Upgradable {\n', '    using SafeMath8 for uint8;\n', '    using SafeMath256 for uint256;\n', '\n', '    Random random;\n', '\n', '    uint256[2] eggs;\n', '    uint256 lastBlockNumber;\n', '\n', '    bool isFull;\n', '\n', '    mapping (uint256 => bool) public inNest;\n', '\n', '    function add(\n', '        uint256 _id\n', '    ) external onlyController returns (\n', '        bool isHatched,\n', '        uint256 hatchedId,\n', '        uint256 randomForEggOpening\n', '    ) {\n', '        require(!inNest[_id], "egg is already in nest");\n', '        require(block.number > lastBlockNumber, "only 1 egg in a block");\n', '\n', '        lastBlockNumber = block.number;\n', '        inNest[_id] = true;\n', '\n', '        // if amount of egg = 3, then hatch one\n', '        if (isFull) {\n', '            isHatched = true;\n', '            hatchedId = eggs[0];\n', '            randomForEggOpening = random.random(2**256 - 1);\n', '            eggs[0] = eggs[1];\n', '            eggs[1] = _id;\n', '            delete inNest[hatchedId];\n', '        } else {\n', '            uint8 _index = eggs[0] == 0 ? 0 : 1;\n', '            eggs[_index] = _id;\n', '            if (_index == 1) {\n', '                isFull = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    // GETTERS\n', '\n', '    function getEggs() external view returns (uint256[2]) {\n', '        return eggs;\n', '    }\n', '\n', '    // UPDATE CONTRACT\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        super.setInternalDependencies(_newDependencies);\n', '\n', '        random = Random(_newDependencies[0]);\n', '    }\n', '}']