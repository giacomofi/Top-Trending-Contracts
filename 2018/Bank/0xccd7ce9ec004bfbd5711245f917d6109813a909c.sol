['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner()\n', '    {\n', '        require(\n', '            msg.sender == owner,\n', '            "Only the owner of that contract can execute this method"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newOwner != address(0x0),\n', '            "Invalid address"\n', '        );\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '// Inspired by https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n', '// The old ERC20 token standard defines transfer and transferFrom without return value.\n', '// So the current ERC20 token standard is incompatible with this one.\n', 'interface IOldERC20 {\n', '\tfunction transfer(address to, uint256 value)\n', '        external;\n', '\n', '\tfunction transferFrom(address from, address to, uint256 value)\n', '        external;\n', '\n', '\tfunction approve(address spender, uint256 value)\n', '        external;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library SafeOldERC20 {\n', '\t// definitely not a pure fn but the compiler complains otherwise\n', '    function checkSuccess()\n', '        private\n', '        pure\n', '\t\treturns (bool)\n', '\t{\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '\t\t\t// check number of bytes returned from last function call\n', '\t\t\tswitch returndatasize\n', '\n', '\t\t\t// no bytes returned: assume success\n', '\t\t\tcase 0x0 {\n', '\t\t\t\treturnValue := 1\n', '\t\t\t}\n', '\n', '\t\t\t// 32 bytes returned: check if non-zero\n', '\t\t\tcase 0x20 {\n', '\t\t\t\t// copy 32 bytes into scratch space\n', '\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n', '\n', '\t\t\t\t// load those bytes into returnValue\n', '\t\t\t\treturnValue := mload(0x0)\n', '\t\t\t}\n', '\n', '\t\t\t// not sure what was returned: don&#39;t mark as success\n', '\t\t\tdefault { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '\n', '    function transfer(address token, address to, uint256 amount) internal {\n', '        IOldERC20(token).transfer(to, amount);\n', '        require(checkSuccess(), "Transfer failed");\n', '    }\n', '\n', '    function transferFrom(address token, address from, address to, uint256 amount) internal {\n', '        IOldERC20(token).transferFrom(from, to, amount);\n', '        require(checkSuccess(), "Transfer From failed");\n', '    }\n', '}\n', '\n', 'library CrowdsaleLib {\n', '\n', '    struct Crowdsale {\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        uint256 capacity;\n', '        uint256 leftAmount;\n', '        uint256 tokenRatio;\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 weiRaised;\n', '        address wallet;\n', '    }\n', '\n', '    function isValid(Crowdsale storage _self)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            (_self.startTime >= now) &&\n', '            (_self.endTime >= _self.startTime) &&\n', '            (_self.tokenRatio > 0) &&\n', '            (_self.wallet != address(0))\n', '        );\n', '    }\n', '\n', '    function isOpened(Crowdsale storage _self)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (now >= _self.startTime && now <= _self.endTime);\n', '    }\n', '\n', '    function createCrowdsale(\n', '        address _wallet,\n', '        uint256[8] _values\n', '    )\n', '        internal\n', '        pure\n', '        returns (Crowdsale memory)\n', '    {\n', '        return Crowdsale({\n', '            startTime: _values[0],\n', '            endTime: _values[1],\n', '            capacity: _values[2],\n', '            leftAmount: _values[3],\n', '            tokenRatio: _values[4],\n', '            minContribution: _values[5],\n', '            maxContribution: _values[6],\n', '            weiRaised: _values[7],\n', '            wallet: _wallet\n', '        });\n', '    }\n', '}\n', '\n', 'contract IUpgradableExchange {\n', '\n', '    uint8 public VERSION;\n', '\n', '    event FundsMigrated(address indexed user, address indexed exchangeAddress);\n', '\n', '    function allowOrRestrictMigrations() external;\n', '\n', '    function migrateFunds(address[] _tokens) external;\n', '\n', '    function migrateEthers() private;\n', '\n', '    function migrateTokens(address[] _tokens) private;\n', '\n', '    function importEthers(address _user) external payable;\n', '\n', '    function importTokens(address _tokenAddress, uint256 _tokenAmount, address _user) external;\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external view returns (uint256);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value)\n', '        external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        external returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library OrderLib {\n', '\n', '    struct Order {\n', '        uint256 makerSellAmount;\n', '        uint256 makerBuyAmount;\n', '        uint256 nonce;\n', '        address maker;\n', '        address makerSellToken;\n', '        address makerBuyToken;\n', '    }\n', '\n', '    /**\n', '    * @dev Hashes the order.\n', '    * @param order Order to be hashed.\n', '    * @return hash result\n', '    */\n', '    function createHash(Order memory order)\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                order.maker,\n', '                order.makerSellToken,\n', '                order.makerSellAmount,\n', '                order.makerBuyToken,\n', '                order.makerBuyAmount,\n', '                order.nonce,\n', '                this\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Creates order struct from value arrays.\n', '    * @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    * @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    * @return Order struct\n', '    */\n', '    function createOrder(\n', '        address[3] addresses,\n', '        uint256[3] values\n', '    )\n', '        internal\n', '        pure\n', '        returns (Order memory)\n', '    {\n', '        return Order({\n', '            maker: addresses[0],\n', '            makerSellToken: addresses[1],\n', '            makerSellAmount: values[0],\n', '            makerBuyToken: addresses[2],\n', '            makerBuyAmount: values[1],\n', '            nonce: values[2]\n', '        });\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library Math {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256 c)\n', '    {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the ration between two assets. For example ETH/WDX\n', '    * @param _numerator uint256 base currency\n', '    * @param _denominator uint256 quote currency\n', '    */\n', '    function calculateRate(\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return div(mul(_numerator, 1e18), _denominator);\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the fee in WDX\n', '    * @param _fee uint256 full fee\n', '    * @param _referralFeeRate uint256 referral fee rate\n', '    */\n', '    function calculateReferralFee(uint256 _fee, uint256 _referralFeeRate) internal pure returns (uint256) {\n', '        return div(_fee, _referralFeeRate);\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the fee in WDX\n', '    * @param _etherAmount uint256 amount in Ethers\n', '    * @param _tokenRatio uint256 the rate between ETH/WDX\n', '    * @param _feeRate uint256 the fee rate\n', '    */\n', '    function calculateWdxFee(uint256 _etherAmount, uint256 _tokenRatio, uint256 _feeRate) internal pure returns (uint256) {\n', '        return div(div(mul(_etherAmount, 1e18), _tokenRatio), mul(_feeRate, 2));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Token contract\n', ' * @dev extending ERC20 to support ExchangeOffering functionality.\n', ' */\n', 'contract Token is IERC20 {\n', '    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)\n', '        public view returns (uint256);\n', '\n', '    function isUserWhitelisted(address _user)\n', '        public view returns (bool);\n', '}\n', '\n', 'contract Exchange is Ownable {\n', '\n', '    using Math for uint256;\n', '\n', '    using OrderLib for OrderLib.Order;\n', '\n', '    uint256 public feeRate;\n', '\n', '    mapping(address => mapping(address => uint256)) public balances;\n', '\n', '    mapping(bytes32 => uint256) public filledAmounts;\n', '\n', '    address constant public ETH = address(0x0);\n', '\n', '    address public feeAccount;\n', '\n', '    constructor(\n', '        address _feeAccount,\n', '        uint256 _feeRate\n', '    )\n', '        public\n', '    {\n', '        feeAccount = _feeAccount;\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    enum ErrorCode {\n', '        INSUFFICIENT_MAKER_BALANCE,\n', '        INSUFFICIENT_TAKER_BALANCE,\n', '        INSUFFICIENT_ORDER_AMOUNT\n', '    }\n', '\n', '    event Deposit(\n', '        address indexed tokenAddress,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    event Withdraw(\n', '        address indexed tokenAddress,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    event CancelOrder(\n', '        address indexed makerBuyToken,\n', '        address indexed makerSellToken,\n', '        address indexed maker,\n', '        bytes32 orderHash,\n', '        uint256 nonce\n', '    );\n', '\n', '    event TakeOrder(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed makerBuyToken,\n', '        address indexed makerSellToken,\n', '        uint256 takerGivenAmount,\n', '        uint256 takerReceivedAmount,\n', '        bytes32 orderHash,\n', '        uint256 nonce\n', '    );\n', '\n', '    event Error(\n', '        uint8 eventId,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    /**\n', '    * @dev Owner can set the exchange fee\n', '    * @param _feeRate uint256 new fee rate\n', '    */\n', '    function setFee(uint256 _feeRate)\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can set the new fee account\n', '    * @param _feeAccount address\n', '    */\n', '    function setFeeAccount(address _feeAccount)\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeAccount = _feeAccount;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Ethers in the exchange contract.\n', '    * Only the respected user can withdraw these Ethers.\n', '    */\n', '    function depositEthers() external payable\n', '    {\n', '        address user = msg.sender;\n', '        _depositEthers(user);\n', '        emit Deposit(ETH, user, msg.value, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Ethers for beneficiary in the exchange contract.\n', '    * @param _beneficiary address\n', '    * Only the beneficiary can withdraw these Ethers.\n', '    */\n', '    function depositEthersFor(\n', '        address\n', '        _beneficiary\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        _depositEthers(_beneficiary);\n', '        emit Deposit(ETH, _beneficiary, msg.value, balances[ETH][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Tokens in the exchange contract.\n', '    * Only the respected user can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    */\n', '    function depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '        _depositTokens(_tokenAddress, _amount, user);\n', '        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '        /**\n', '    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\n', '    * Only the beneficiary can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    * @param _beneficiary address representing the token amount to be deposited.\n', '    */\n', '    function depositTokensFor(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        external\n', '    {\n', '        _depositTokens(_tokenAddress, _amount, _beneficiary);\n', '        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Ethers.\n', '    */\n', '    function _depositEthers(\n', '        address\n', '        _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[ETH][_beneficiary] = balances[ETH][_beneficiary].add(msg.value);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Tokens.\n', '    */\n', '    function _depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\n', '\n', '        require(\n', '            Token(_tokenAddress).transferFrom(msg.sender, this, _amount),\n', '            "Token transfer is not successfull (maybe you haven&#39;t used approve first?)"\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw Ethers from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawEthers(uint256 _amount) external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[ETH][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[ETH][user] = balances[ETH][user].sub(_amount);\n', '\n', '        user.transfer(_amount);\n', '\n', '        emit Withdraw(ETH, user, _amount, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw specific Token from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        require(\n', '            Token(_tokenAddress).transfer(user, _amount),\n', '            "Token transfer is not successfull."\n', '        );\n', '\n', '        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to transfer specific Token inside the exchange.\n', '    * @param _tokenAddress address representing the token address.\n', '    * @param _to address representing the beneficier.\n', '    * @param _amount uint256 representing the amount to be transferred.\n', '    */\n', '    function transfer(\n', '        address _tokenAddress,\n', '        address _to,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to transfer."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        balances[_tokenAddress][_to] = balances[_tokenAddress][_to].add(_amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Common take order implementation\n', '    * @param _order OrderLib.Order memory - order info\n', '    * @param _takerSellAmount uint256 - amount being given by the taker\n', '    * @param _v uint8 part of the signature\n', '    * @param _r bytes32 part of the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 part of the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeOrder(\n', '        OrderLib.Order memory _order,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        bytes32 orderHash = _order.createHash();\n', '\n', '        require(\n', '            ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)), _v, _r, _s) == _order.maker,\n', '            "Order maker is invalid."\n', '        );\n', '\n', '        if(balances[_order.makerBuyToken][msg.sender] < _takerSellAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_TAKER_BALANCE), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint256 receivedAmount = (_order.makerSellAmount.mul(_takerSellAmount)).div(_order.makerBuyAmount);\n', '\n', '        if(balances[_order.makerSellToken][_order.maker] < receivedAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_MAKER_BALANCE), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if(filledAmounts[orderHash].add(_takerSellAmount) > _order.makerBuyAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_ORDER_AMOUNT), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        filledAmounts[orderHash] = filledAmounts[orderHash].add(_takerSellAmount);\n', '\n', '        balances[_order.makerBuyToken][msg.sender] = balances[_order.makerBuyToken][msg.sender].sub(_takerSellAmount);\n', '        balances[_order.makerBuyToken][_order.maker] = balances[_order.makerBuyToken][_order.maker].add(_takerSellAmount);\n', '\n', '        balances[_order.makerSellToken][msg.sender] = balances[_order.makerSellToken][msg.sender].add(receivedAmount);\n', '        balances[_order.makerSellToken][_order.maker] = balances[_order.makerSellToken][_order.maker].sub(receivedAmount);\n', '\n', '        emit TakeOrder(\n', '            _order.maker,\n', '            msg.sender,\n', '            _order.makerBuyToken,\n', '            _order.makerSellToken,\n', '            _takerSellAmount,\n', '            receivedAmount,\n', '            orderHash,\n', '            _order.nonce\n', '        );\n', '\n', '        return receivedAmount;\n', '    }\n', '\n', '    /**\n', '    * @dev Order maker can call this function in order to cancel it.\n', '    * What actually happens is that the order become\n', '    * fulfilled in the "filledAmounts" mapping. Thus we avoid someone calling\n', '    * "takeOrder" directly from the contract if the order hash is available to him.\n', '    * @param _orderAddresses address[3]\n', '    * @param _orderValues uint256[3]\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function cancelOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '    {\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '        bytes32 orderHash = order.createHash();\n', '\n', '        require(\n', '            ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)), _v, _r, _s) == msg.sender,\n', '            "Only order maker can cancel it."\n', '        );\n', '\n', '        filledAmounts[orderHash] = filledAmounts[orderHash].add(order.makerBuyAmount);\n', '\n', '        emit CancelOrder(\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            msg.sender,\n', '            orderHash,\n', '            order.nonce\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Cancel multiple orders in a single transaction.\n', '    * @param _orderAddresses address[3][]\n', '    * @param _orderValues uint256[3][]\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function cancelMultipleOrders(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s\n', '    )\n', '        external\n', '    {\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            cancelOrder(\n', '                _orderAddresses[index],\n', '                _orderValues[index],\n', '                _v[index],\n', '                _r[index],\n', '                _s[index]\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', 'contract DailyVolumeUpdater is Ownable {\n', '\n', '    using Math for uint256;\n', '\n', '    uint256 public dailyVolume;\n', '\n', '    uint256 public dailyVolumeCap;\n', '\n', '    uint256 private lastDay;\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        dailyVolume = 0;\n', '        dailyVolumeCap = 1000 ether;\n', '        lastDay = today();\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the owner to change the daily volume capacity.\n', '    * @param _dailyVolumeCap uint256 representing the daily volume capacity\n', '    */\n', '    function setDailyVolumeCap(uint256 _dailyVolumeCap)\n', '        public\n', '        onlyOwner\n', '    {\n', '        dailyVolumeCap = _dailyVolumeCap;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function that increments the daily volume.\n', '    * @param _volume uint256 representing the amount of volume increasement.\n', '    */\n', '    function updateVolume(uint256 _volume)\n', '        internal\n', '    {\n', '        if(today() > lastDay) {\n', '            dailyVolume = _volume;\n', '            lastDay = today();\n', '        } else {\n', '            dailyVolume = dailyVolume.add(_volume);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to check if the volume capacity is reached.\n', '    * @return Whether the volume is reached or not.\n', '    */\n', '    function isVolumeReached()\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        return dailyVolume >= dailyVolumeCap;\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to determine today&#39;s index\n', '    * @return uint256 of today&#39;s index.\n', '    */\n', '    function today()\n', '        private\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return block.timestamp.div(1 days);\n', '    }\n', '}\n', '\n', 'contract DiscountTokenExchange is Exchange, DailyVolumeUpdater {\n', '\n', '    uint256 internal discountTokenRatio;\n', '\n', '    uint256 private minimumTokenAmountForUpdate;\n', '\n', '    address public discountTokenAddress;\n', '\n', '    bool internal initialized = false;\n', '\n', '    constructor(\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio\n', '    )\n', '        public\n', '    {\n', '        discountTokenAddress = _discountTokenAddress;\n', '        discountTokenRatio = _discountTokenRatio;\n', '    }\n', '\n', '    modifier onlyOnce() {\n', '        require(\n', '            initialized == false,\n', '            "Exchange is already initialized"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Update the token discount contract.\n', '    * @param _discountTokenAddress address of the token used for fee discount\n', '    * @param _discountTokenRatio uint256 initial rate of the token discount contract\n', '    */\n', '    function setDiscountToken(\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio,\n', '        uint256 _minimumTokenAmountForUpdate\n', '    )\n', '        public\n', '        onlyOwner\n', '        onlyOnce\n', '    {\n', '        discountTokenAddress = _discountTokenAddress;\n', '        discountTokenRatio = _discountTokenRatio;\n', '        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\n', '        initialized = true;\n', '    }\n', '\n', '    /**\n', '    * @dev Update the token ratio.\n', '    * Add a minimum requirement for the amount of tokens being traded\n', '    * to avoid possible intentional manipulation\n', '    * @param _etherAmount uint256 amount in Ethers (wei)\n', '    * @param _tokenAmount uint256 amount in Tokens\n', '    */\n', '    function updateTokenRatio(\n', '        uint256 _etherAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        if(_tokenAmount >= minimumTokenAmountForUpdate) {\n', '            discountTokenRatio = _etherAmount.calculateRate(_tokenAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Set the minimum requirement for updating the price.\n', '    * This should be called whenever the rate of the token\n', '    * has changed massively.\n', '    * In order to avoid token price manipulation (that will reduce the fee)\n', '    * The minimum amount requirement take place.\n', '    * For example: Someone buys or sells 0.0000000001 Tokens with\n', '    * high rate against ETH and after that execute a trade,\n', '    * reducing his fees to approximately zero.\n', '    * Having the mimimum amount requirement for updating\n', '    * the price will protect us from such cases because\n', '    * it will not be worth to do it.\n', '    * @param _minimumTokenAmountForUpdate - the new mimimum amount of\n', '    * tokens for updating the ratio (price)\n', '    */\n', '    function setMinimumTokenAmountForUpdate(\n', '        uint256 _minimumTokenAmountForUpdate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\n', '    }\n', '\n', '    /**\n', '    * @dev Execute WeiDexToken Sale Order based on the order input parameters\n', '    * and the signature from the maker&#39;s signing.\n', '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of WeiDexToken\n', '    * [2] address of Ether (0x0)\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in WDX\n', '    * [1] amount in Ethers (wei)\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeSellTokenOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[1] == discountTokenAddress,\n', '            "Should sell WeiDex Tokens"\n', '        );\n', '\n', '        require(\n', '            0 < takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s),\n', '            "Trade failure"\n', '        );\n', '        updateVolume(_takerSellAmount);\n', '        updateTokenRatio(_orderValues[1], _orderValues[0]);\n', '    }\n', '\n', '    /**\n', '    * @dev Execute WeiDexToken Buy Order based on the order input parameters\n', '    * and the signature from the maker&#39;s signing.\n', '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of Ether (0x0)\n', '    * [2] address of WeiDexToken\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in Ethers\n', '    * [1] amount in WDX\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeBuyTokenOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[2] == discountTokenAddress,\n', '            "Should buy WeiDex Tokens"\n', '        );\n', '\n', '        uint256 receivedAmount = takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s);\n', '        require(0 < receivedAmount, "Trade failure");\n', '        updateVolume(receivedAmount);\n', '        updateTokenRatio(_orderValues[0], _orderValues[1]);\n', '    }\n', '}\n', '\n', 'contract ReferralExchange is Exchange {\n', '\n', '    uint256 public referralFeeRate;\n', '\n', '    mapping(address => address) public referrals;\n', '\n', '    constructor(\n', '        uint256 _referralFeeRate\n', '    )\n', '        public\n', '    {\n', '        referralFeeRate = _referralFeeRate;\n', '    }\n', '\n', '    event ReferralBalanceUpdated(\n', '        address refererAddress,\n', '        address referralAddress,\n', '        address tokenAddress,\n', '        uint256 feeAmount,\n', '        uint256 referralFeeAmount\n', '    );\n', '\n', '    event ReferralDeposit(\n', '        address token,\n', '        address indexed user,\n', '        address indexed referrer,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '    * @dev Deposit Ethers with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositEthers(address _referrer)\n', '        external\n', '        payable\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        super._depositEthers(user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(ETH, user, _referrer, msg.value, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Deposit Tokens with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _referrer\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        super._depositTokens(_tokenAddress, _amount, user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Update the referral fee rate,\n', '    * i.e. the rate of the fee that will be accounted to the referrer\n', '    * @param _referralFeeRate uint256 amount of fee going to the referrer\n', '    */\n', '    function setReferralFee(uint256 _referralFeeRate)\n', '        external\n', '        onlyOwner\n', '    {\n', '        referralFeeRate = _referralFeeRate;\n', '    }\n', '\n', '    /**\n', '    * @dev Return the feeAccount address if user doesn&#39;t have referrer\n', '    * @param _user address user whom referrer is being checked.\n', '    * @return address of user&#39;s referrer.\n', '    */\n', '    function getReferrer(address _user)\n', '        internal\n', '        view\n', '        returns(address referrer)\n', '    {\n', '        return referrals[_user] != address(0x0) ? referrals[_user] : feeAccount;\n', '    }\n', '}\n', '\n', 'contract UpgradableExchange is Exchange {\n', '\n', '    uint8 constant public VERSION = 0;\n', '\n', '    address public newExchangeAddress;\n', '\n', '    bool public isMigrationAllowed;\n', '\n', '    event FundsMigrated(address indexed user, address indexed exchangeAddress);\n', '\n', '    /**\n', '    * @dev Owner can set the address of the new version of the exchange contract.\n', '    * @param _newExchangeAddress address representing the new exchange contract address\n', '    */\n', '    function setNewExchangeAddress(address _newExchangeAddress)\n', '        external\n', '        onlyOwner\n', '    {\n', '        newExchangeAddress = _newExchangeAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Enables/Disables the migrations. Can be called only by the owner.\n', '    */\n', '    function allowOrRestrictMigrations()\n', '        external\n', '        onlyOwner\n', '    {\n', '        isMigrationAllowed = !isMigrationAllowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Set the address of the new version of the exchange contract. Should be called by the user.\n', '    * @param _tokens address[] representing the token addresses which are going to be migrated.\n', '    */\n', '    function migrateFunds(address[] _tokens) external {\n', '\n', '        require(\n', '            false != isMigrationAllowed,\n', '            "Fund migration is not allowed"\n', '        );\n', '\n', '        require(\n', '            IUpgradableExchange(newExchangeAddress).VERSION() > VERSION,\n', '            "New exchange version should be greater than the current version."\n', '        );\n', '\n', '        migrateEthers();\n', '\n', '        migrateTokens(_tokens);\n', '\n', '        emit FundsMigrated(msg.sender, newExchangeAddress);\n', '    }\n', '\n', '    /**\n', '    * @dev Helper function to migrate user&#39;s Ethers. Should be called in migrateFunds() function.\n', '    */\n', '    function migrateEthers() private {\n', '\n', '        uint256 etherAmount = balances[ETH][msg.sender];\n', '        if (etherAmount > 0) {\n', '            balances[ETH][msg.sender] = 0;\n', '\n', '            IUpgradableExchange(newExchangeAddress).importEthers.value(etherAmount)(msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Helper function to migrate user&#39;s tokens. Should be called in migrateFunds() function.\n', '    * @param _tokens address[] representing the token addresses which are going to be migrated.\n', '    */\n', '    function migrateTokens(address[] _tokens) private {\n', '\n', '        for (uint256 index = 0; index < _tokens.length; index++) {\n', '\n', '            address tokenAddress = _tokens[index];\n', '\n', '            uint256 tokenAmount = balances[tokenAddress][msg.sender];\n', '\n', '            if (0 == tokenAmount) {\n', '                continue;\n', '            }\n', '\n', '            require(\n', '                Token(tokenAddress).approve(newExchangeAddress, tokenAmount),\n', '                "Approve failed"\n', '            );\n', '\n', '            balances[tokenAddress][msg.sender] = 0;\n', '\n', '            IUpgradableExchange(newExchangeAddress).importTokens(tokenAddress, tokenAmount, msg.sender);\n', '        }\n', '    }\n', '}\n', '\n', 'contract ExchangeOffering is Exchange {\n', '\n', '    using CrowdsaleLib for CrowdsaleLib.Crowdsale;\n', '\n', '    mapping(address => CrowdsaleLib.Crowdsale) public crowdsales;\n', '\n', '    mapping(address => mapping(address => uint256)) public userContributionForProject;\n', '\n', '    event TokenPurchase(\n', '        address indexed project,\n', '        address indexed contributor,\n', '        uint256 tokens,\n', '        uint256 weiAmount\n', '    );\n', '\n', '    function registerCrowdsale(\n', '        address _project,\n', '        address _projectWallet,\n', '        uint256[8] _values\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        crowdsales[_project] = CrowdsaleLib.createCrowdsale(_projectWallet, _values);\n', '\n', '        require(\n', '            crowdsales[_project].isValid(),\n', '            "Crowdsale is not active."\n', '        );\n', '\n', '        // project contract validation\n', '        require(\n', '            getBonusFactor(_project, crowdsales[_project].minContribution) >= 0,\n', '            "The project should have *getBonusFactor* function implemented. The function should return the bonus percentage depending on the start/end date and contribution amount. Should return 0 if there is no bonus."\n', '        );\n', '\n', '        // project contract validation\n', '        require(\n', '            isUserWhitelisted(_project, this),\n', '            "The project should have *isUserWhitelisted* function implemented. This contract address should be whitelisted"\n', '        );\n', '    }\n', '\n', '    function buyTokens(address _project)\n', '       public\n', '       payable\n', '    {\n', '        uint256 weiAmount = msg.value;\n', '\n', '        address contributor = msg.sender;\n', '\n', '        address crowdsaleWallet = crowdsales[_project].wallet;\n', '\n', '        require(\n', '            isUserWhitelisted(_project, contributor), "User is not whitelisted"\n', '        );\n', '\n', '        require(\n', '            validContribution(_project, contributor, weiAmount),\n', '            "Contribution is not valid: Check minimum/maximum contribution amount or if crowdsale cap is reached"\n', '        );\n', '\n', '        uint256 tokens = weiAmount.mul(crowdsales[_project].tokenRatio);\n', '\n', '        uint256 bonus = getBonusFactor(_project, weiAmount);\n', '\n', '        uint256 bonusAmount = tokens.mul(bonus).div(100);\n', '\n', '        uint256 totalPurchasedTokens = tokens.add(bonusAmount);\n', '\n', '        crowdsales[_project].leftAmount = crowdsales[_project].leftAmount.sub(totalPurchasedTokens);\n', '\n', '        require(Token(_project).transfer(contributor, totalPurchasedTokens), "Transfer failed");\n', '\n', '        crowdsales[_project].weiRaised = crowdsales[_project].weiRaised.add(weiAmount);\n', '\n', '        userContributionForProject[_project][contributor] = userContributionForProject[_project][contributor].add(weiAmount);\n', '\n', '        balances[ETH][crowdsaleWallet] = balances[ETH][crowdsaleWallet].add(weiAmount);\n', '\n', '        emit TokenPurchase(_project, contributor, totalPurchasedTokens, weiAmount);\n', '    }\n', '\n', '    function withdrawWhenFinished(address _project) public {\n', '\n', '        address crowdsaleWallet = crowdsales[_project].wallet;\n', '\n', '        require(\n', '            msg.sender == crowdsaleWallet,\n', '            "Only crowdsale owner can withdraw funds that are left."\n', '        );\n', '\n', '        require(\n', '            !crowdsales[_project].isOpened(),\n', '            "You can&#39;t withdraw funds yet. Crowdsale should end first."\n', '        );\n', '\n', '        uint256 leftAmount = crowdsales[_project].leftAmount;\n', '\n', '        crowdsales[_project].leftAmount = 0;\n', '\n', '        require(Token(_project).transfer(crowdsaleWallet, leftAmount), "Transfer failed");\n', '    }\n', '\n', '    function saleOpen(address _project)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return crowdsales[_project].isOpened();\n', '    }\n', '\n', '    function getBonusFactor(address _project, uint256 _weiAmount)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Token(_project).getBonusFactor(crowdsales[_project].startTime, crowdsales[_project].endTime, _weiAmount);\n', '    }\n', '\n', '    function isUserWhitelisted(address _project, address _user)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return Token(_project).isUserWhitelisted(_user);\n', '    }\n', '\n', '    function validContribution(\n', '        address _project,\n', '        address _user,\n', '        uint256 _weiAmount\n', '    )\n', '        private\n', '        view\n', '        returns(bool)\n', '    {\n', '        if (saleOpen(_project)) {\n', '            // minimum contribution check\n', '            if (_weiAmount < crowdsales[_project].minContribution) {\n', '                return false;\n', '            }\n', '\n', '            // maximum contribution check\n', '            if (userContributionForProject[_project][_user].add(_weiAmount) > crowdsales[_project].maxContribution) {\n', '                return false;\n', '            }\n', '\n', '            // token sale capacity check\n', '            if (crowdsales[_project].capacity < crowdsales[_project].weiRaised.add(_weiAmount)) {\n', '                return false;\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '\n', '        return msg.value != 0; // check for non zero contribution\n', '    }\n', '}\n', '\n', 'contract OldERC20ExchangeSupport is Exchange, ReferralExchange {\n', '\n', '    /**\n', '    * @dev Allows user to deposit Tokens in the exchange contract.\n', '    * Only the respected user can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    */\n', '    function depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '        _depositOldTokens(_tokenAddress, _amount, user);\n', '        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Deposit Tokens with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _referrer\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        _depositOldTokens(_tokenAddress, _amount, user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '        /**\n', '    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\n', '    * Only the beneficiary can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    * @param _beneficiary address representing the token amount to be deposited.\n', '    */\n', '    function depositOldTokensFor(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        external\n', '    {\n', '        _depositOldTokens(_tokenAddress, _amount, _beneficiary);\n', '        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw specific Token from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        SafeOldERC20.transfer(_tokenAddress, user, _amount);\n', '\n', '        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Tokens.\n', '    */\n', '    function _depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\n', '\n', '        SafeOldERC20.transferFrom(_tokenAddress, msg.sender, this, _amount);\n', '    }\n', '}\n', '\n', 'contract WeiDex is DiscountTokenExchange, ReferralExchange, UpgradableExchange, ExchangeOffering, OldERC20ExchangeSupport  {\n', '\n', '    mapping(bytes4 => bool) private allowedMethods;\n', '\n', '    function () public payable {\n', '        revert("Cannot send Ethers to the contract, use depositEthers");\n', '    }\n', '\n', '    constructor(\n', '        address _feeAccount,\n', '        uint256 _feeRate,\n', '        uint256 _referralFeeRate,\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio\n', '    )\n', '        public\n', '        Exchange(_feeAccount, _feeRate)\n', '        ReferralExchange(_referralFeeRate)\n', '        DiscountTokenExchange(_discountTokenAddress, _discountTokenRatio)\n', '    {\n', '        // empty constructor\n', '    }\n', '\n', '    /**\n', '    * @dev Allows or restricts methods from being executed in takeAllPossible and takeAllOrRevert\n', '    * @param _methodId bytes4 method id that will be allowed/forbidded from execution\n', '    * @param _allowed bool\n', '    */\n', '    function allowOrRestrictMethod(\n', '        bytes4 _methodId,\n', '        bool _allowed\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        allowedMethods[_methodId] = _allowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Execute multiple order by given method id\n', '    * @param _orderAddresses address[3][] representing\n', '    * @param _orderValues uint256[4][] representing\n', '    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeAllOrRevert(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint256[] _takerSellAmount,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        bytes4 _methodId\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            allowedMethods[_methodId],\n', '            "Can&#39;t call this method"\n', '        );\n', '\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            require(\n', '                address(this).delegatecall(\n', '                _methodId,\n', '                _orderAddresses[index],\n', '                _orderValues[index],\n', '                _takerSellAmount[index],\n', '                _v[index],\n', '                _r[index],\n', '                _s[index]\n', '                ),\n', '                "Method call failed"\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute multiple order by given method id\n', '    * @param _orderAddresses address[3][]\n', '    * @param _orderValues uint256[4][]\n', '    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeAllPossible(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint256[] _takerSellAmount,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        bytes4 _methodId\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            allowedMethods[_methodId],\n', '            "Can&#39;t call this method"\n', '        );\n', '\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            address(this).delegatecall(\n', '            _methodId,\n', '            _orderAddresses[index],\n', '            _orderValues[index],\n', '            _takerSellAmount[index],\n', '            _v[index],\n', '            _r[index],\n', '            _s[index]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute buy order based on the order input parameters\n', '    * and the signature from the maker&#39;s signing\n', '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of ether (0x0)\n', '    * [2] address of token being bought\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in Ethers (wei)\n', '    * [1] amount in tokens\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in tokens\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeBuyOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[1] == ETH,\n', '            "Base currency must be ether&#39;s (0x0)"\n', '        );\n', '\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\n', '\n', '        require(0 < receivedAmount, "Trade failure");\n', '\n', '        updateVolume(receivedAmount);\n', '\n', '        if (!isVolumeReached()) {\n', '            takeFee(order.maker, msg.sender, order.makerBuyToken, _takerSellAmount, receivedAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute sell order based on the order input parameters\n', '    * and the signature from the maker&#39;s signing\n', '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of token being sold\n', '    * [2] address of ether (0x0)\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in tokens\n', '    * [1] amount in Ethers (wei)\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeSellOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            _orderAddresses[2] == ETH,\n', '            "Base currency must be ether&#39;s (0x0)"\n', '        );\n', '\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '\n', '        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\n', '\n', '        require(0 < receivedAmount, "Trade failure");\n', '\n', '        updateVolume(_takerSellAmount);\n', '\n', '        if (!isVolumeReached()) {\n', '            takeFee(order.maker, msg.sender, order.makerSellToken, receivedAmount, _takerSellAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee for making/taking the order\n', '    * @param _maker address\n', '    * @param _taker address\n', '    * @param _tokenAddress address\n', '    * @param _tokenFulfilledAmount uint256 fulfilled amount in tokens\n', '    * @param _etherFulfilledAmount uint256 fulfilled amount in ethers\n', '    */\n', '    function takeFee(\n', '        address _maker,\n', '        address _taker,\n', '        address _tokenAddress,\n', '        uint256 _tokenFulfilledAmount,\n', '        uint256 _etherFulfilledAmount\n', '    )\n', '        private\n', '    {\n', '        uint256 _feeRate = feeRate; // gas optimization\n', '        uint256 feeInWdx = _etherFulfilledAmount.calculateWdxFee(discountTokenRatio, feeRate);\n', '\n', '        takeFee(_maker, ETH, _etherFulfilledAmount.div(_feeRate), feeInWdx);\n', '        takeFee(_taker, _tokenAddress, _tokenFulfilledAmount.div(_feeRate), feeInWdx);\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee in WDX or the given token address\n', '    * @param _user address taker or maker\n', '    * @param _tokenAddress address of the token\n', '    * @param _tokenFeeAmount uint256 amount in given token address\n', '    * @param _wdxFeeAmount uint256 amount in WDX tokens\n', '    */\n', '    function takeFee(\n', '        address _user,\n', '        address _tokenAddress,\n', '        uint256 _tokenFeeAmount,\n', '        uint256 _wdxFeeAmount\n', '        )\n', '        private\n', '    {\n', '        if(balances[discountTokenAddress][_user] >= _wdxFeeAmount) {\n', '            takeFee(_user, discountTokenAddress, _wdxFeeAmount);\n', '        } else {\n', '            takeFee(_user, _tokenAddress, _tokenFeeAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee in WDX or the given token address\n', '    * @param _user address taker or maker\n', '    * @param _tokenAddress address\n', '    * @param _fullFee uint256 fee taken from a given token address\n', '    */\n', '    function takeFee(\n', '        address _user,\n', '        address _tokenAddress,\n', '        uint256 _fullFee\n', '        )\n', '        private\n', '    {\n', '        address _feeAccount = feeAccount; // gas optimization\n', '        address referrer = getReferrer(_user);\n', '        uint256 referralFee = _fullFee.calculateReferralFee(referralFeeRate);\n', '\n', '        balances[_tokenAddress][_user] = balances[_tokenAddress][_user].sub(_fullFee);\n', '\n', '        if(referrer == _feeAccount) {\n', '            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee);\n', '        } else {\n', '            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee.sub(referralFee));\n', '            balances[_tokenAddress][referrer] = balances[_tokenAddress][referrer].add(referralFee);\n', '        }\n', '        emit ReferralBalanceUpdated(referrer, _user, _tokenAddress, _fullFee, referralFee);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner()\n', '    {\n', '        require(\n', '            msg.sender == owner,\n', '            "Only the owner of that contract can execute this method"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newOwner != address(0x0),\n', '            "Invalid address"\n', '        );\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '// Inspired by https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n', '// The old ERC20 token standard defines transfer and transferFrom without return value.\n', '// So the current ERC20 token standard is incompatible with this one.\n', 'interface IOldERC20 {\n', '\tfunction transfer(address to, uint256 value)\n', '        external;\n', '\n', '\tfunction transferFrom(address from, address to, uint256 value)\n', '        external;\n', '\n', '\tfunction approve(address spender, uint256 value)\n', '        external;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library SafeOldERC20 {\n', '\t// definitely not a pure fn but the compiler complains otherwise\n', '    function checkSuccess()\n', '        private\n', '        pure\n', '\t\treturns (bool)\n', '\t{\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '\t\t\t// check number of bytes returned from last function call\n', '\t\t\tswitch returndatasize\n', '\n', '\t\t\t// no bytes returned: assume success\n', '\t\t\tcase 0x0 {\n', '\t\t\t\treturnValue := 1\n', '\t\t\t}\n', '\n', '\t\t\t// 32 bytes returned: check if non-zero\n', '\t\t\tcase 0x20 {\n', '\t\t\t\t// copy 32 bytes into scratch space\n', '\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n', '\n', '\t\t\t\t// load those bytes into returnValue\n', '\t\t\t\treturnValue := mload(0x0)\n', '\t\t\t}\n', '\n', "\t\t\t// not sure what was returned: don't mark as success\n", '\t\t\tdefault { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '\n', '    function transfer(address token, address to, uint256 amount) internal {\n', '        IOldERC20(token).transfer(to, amount);\n', '        require(checkSuccess(), "Transfer failed");\n', '    }\n', '\n', '    function transferFrom(address token, address from, address to, uint256 amount) internal {\n', '        IOldERC20(token).transferFrom(from, to, amount);\n', '        require(checkSuccess(), "Transfer From failed");\n', '    }\n', '}\n', '\n', 'library CrowdsaleLib {\n', '\n', '    struct Crowdsale {\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        uint256 capacity;\n', '        uint256 leftAmount;\n', '        uint256 tokenRatio;\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 weiRaised;\n', '        address wallet;\n', '    }\n', '\n', '    function isValid(Crowdsale storage _self)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            (_self.startTime >= now) &&\n', '            (_self.endTime >= _self.startTime) &&\n', '            (_self.tokenRatio > 0) &&\n', '            (_self.wallet != address(0))\n', '        );\n', '    }\n', '\n', '    function isOpened(Crowdsale storage _self)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (now >= _self.startTime && now <= _self.endTime);\n', '    }\n', '\n', '    function createCrowdsale(\n', '        address _wallet,\n', '        uint256[8] _values\n', '    )\n', '        internal\n', '        pure\n', '        returns (Crowdsale memory)\n', '    {\n', '        return Crowdsale({\n', '            startTime: _values[0],\n', '            endTime: _values[1],\n', '            capacity: _values[2],\n', '            leftAmount: _values[3],\n', '            tokenRatio: _values[4],\n', '            minContribution: _values[5],\n', '            maxContribution: _values[6],\n', '            weiRaised: _values[7],\n', '            wallet: _wallet\n', '        });\n', '    }\n', '}\n', '\n', 'contract IUpgradableExchange {\n', '\n', '    uint8 public VERSION;\n', '\n', '    event FundsMigrated(address indexed user, address indexed exchangeAddress);\n', '\n', '    function allowOrRestrictMigrations() external;\n', '\n', '    function migrateFunds(address[] _tokens) external;\n', '\n', '    function migrateEthers() private;\n', '\n', '    function migrateTokens(address[] _tokens) private;\n', '\n', '    function importEthers(address _user) external payable;\n', '\n', '    function importTokens(address _tokenAddress, uint256 _tokenAmount, address _user) external;\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external view returns (uint256);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value)\n', '        external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        external returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library OrderLib {\n', '\n', '    struct Order {\n', '        uint256 makerSellAmount;\n', '        uint256 makerBuyAmount;\n', '        uint256 nonce;\n', '        address maker;\n', '        address makerSellToken;\n', '        address makerBuyToken;\n', '    }\n', '\n', '    /**\n', '    * @dev Hashes the order.\n', '    * @param order Order to be hashed.\n', '    * @return hash result\n', '    */\n', '    function createHash(Order memory order)\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                order.maker,\n', '                order.makerSellToken,\n', '                order.makerSellAmount,\n', '                order.makerBuyToken,\n', '                order.makerBuyAmount,\n', '                order.nonce,\n', '                this\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Creates order struct from value arrays.\n', "    * @param addresses Array of trade's maker, makerToken and takerToken.\n", "    * @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    * @return Order struct\n', '    */\n', '    function createOrder(\n', '        address[3] addresses,\n', '        uint256[3] values\n', '    )\n', '        internal\n', '        pure\n', '        returns (Order memory)\n', '    {\n', '        return Order({\n', '            maker: addresses[0],\n', '            makerSellToken: addresses[1],\n', '            makerSellAmount: values[0],\n', '            makerBuyToken: addresses[2],\n', '            makerBuyAmount: values[1],\n', '            nonce: values[2]\n', '        });\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library Math {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256 c)\n', '    {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the ration between two assets. For example ETH/WDX\n', '    * @param _numerator uint256 base currency\n', '    * @param _denominator uint256 quote currency\n', '    */\n', '    function calculateRate(\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return div(mul(_numerator, 1e18), _denominator);\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the fee in WDX\n', '    * @param _fee uint256 full fee\n', '    * @param _referralFeeRate uint256 referral fee rate\n', '    */\n', '    function calculateReferralFee(uint256 _fee, uint256 _referralFeeRate) internal pure returns (uint256) {\n', '        return div(_fee, _referralFeeRate);\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the fee in WDX\n', '    * @param _etherAmount uint256 amount in Ethers\n', '    * @param _tokenRatio uint256 the rate between ETH/WDX\n', '    * @param _feeRate uint256 the fee rate\n', '    */\n', '    function calculateWdxFee(uint256 _etherAmount, uint256 _tokenRatio, uint256 _feeRate) internal pure returns (uint256) {\n', '        return div(div(mul(_etherAmount, 1e18), _tokenRatio), mul(_feeRate, 2));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Token contract\n', ' * @dev extending ERC20 to support ExchangeOffering functionality.\n', ' */\n', 'contract Token is IERC20 {\n', '    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)\n', '        public view returns (uint256);\n', '\n', '    function isUserWhitelisted(address _user)\n', '        public view returns (bool);\n', '}\n', '\n', 'contract Exchange is Ownable {\n', '\n', '    using Math for uint256;\n', '\n', '    using OrderLib for OrderLib.Order;\n', '\n', '    uint256 public feeRate;\n', '\n', '    mapping(address => mapping(address => uint256)) public balances;\n', '\n', '    mapping(bytes32 => uint256) public filledAmounts;\n', '\n', '    address constant public ETH = address(0x0);\n', '\n', '    address public feeAccount;\n', '\n', '    constructor(\n', '        address _feeAccount,\n', '        uint256 _feeRate\n', '    )\n', '        public\n', '    {\n', '        feeAccount = _feeAccount;\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    enum ErrorCode {\n', '        INSUFFICIENT_MAKER_BALANCE,\n', '        INSUFFICIENT_TAKER_BALANCE,\n', '        INSUFFICIENT_ORDER_AMOUNT\n', '    }\n', '\n', '    event Deposit(\n', '        address indexed tokenAddress,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    event Withdraw(\n', '        address indexed tokenAddress,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    event CancelOrder(\n', '        address indexed makerBuyToken,\n', '        address indexed makerSellToken,\n', '        address indexed maker,\n', '        bytes32 orderHash,\n', '        uint256 nonce\n', '    );\n', '\n', '    event TakeOrder(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed makerBuyToken,\n', '        address indexed makerSellToken,\n', '        uint256 takerGivenAmount,\n', '        uint256 takerReceivedAmount,\n', '        bytes32 orderHash,\n', '        uint256 nonce\n', '    );\n', '\n', '    event Error(\n', '        uint8 eventId,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    /**\n', '    * @dev Owner can set the exchange fee\n', '    * @param _feeRate uint256 new fee rate\n', '    */\n', '    function setFee(uint256 _feeRate)\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can set the new fee account\n', '    * @param _feeAccount address\n', '    */\n', '    function setFeeAccount(address _feeAccount)\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeAccount = _feeAccount;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Ethers in the exchange contract.\n', '    * Only the respected user can withdraw these Ethers.\n', '    */\n', '    function depositEthers() external payable\n', '    {\n', '        address user = msg.sender;\n', '        _depositEthers(user);\n', '        emit Deposit(ETH, user, msg.value, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Ethers for beneficiary in the exchange contract.\n', '    * @param _beneficiary address\n', '    * Only the beneficiary can withdraw these Ethers.\n', '    */\n', '    function depositEthersFor(\n', '        address\n', '        _beneficiary\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        _depositEthers(_beneficiary);\n', '        emit Deposit(ETH, _beneficiary, msg.value, balances[ETH][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to deposit Tokens in the exchange contract.\n', '    * Only the respected user can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    */\n', '    function depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '        _depositTokens(_tokenAddress, _amount, user);\n', '        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '        /**\n', '    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\n', '    * Only the beneficiary can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    * @param _beneficiary address representing the token amount to be deposited.\n', '    */\n', '    function depositTokensFor(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        external\n', '    {\n', '        _depositTokens(_tokenAddress, _amount, _beneficiary);\n', '        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Ethers.\n', '    */\n', '    function _depositEthers(\n', '        address\n', '        _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[ETH][_beneficiary] = balances[ETH][_beneficiary].add(msg.value);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Tokens.\n', '    */\n', '    function _depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\n', '\n', '        require(\n', '            Token(_tokenAddress).transferFrom(msg.sender, this, _amount),\n', '            "Token transfer is not successfull (maybe you haven\'t used approve first?)"\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw Ethers from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawEthers(uint256 _amount) external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[ETH][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[ETH][user] = balances[ETH][user].sub(_amount);\n', '\n', '        user.transfer(_amount);\n', '\n', '        emit Withdraw(ETH, user, _amount, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw specific Token from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        require(\n', '            Token(_tokenAddress).transfer(user, _amount),\n', '            "Token transfer is not successfull."\n', '        );\n', '\n', '        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to transfer specific Token inside the exchange.\n', '    * @param _tokenAddress address representing the token address.\n', '    * @param _to address representing the beneficier.\n', '    * @param _amount uint256 representing the amount to be transferred.\n', '    */\n', '    function transfer(\n', '        address _tokenAddress,\n', '        address _to,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to transfer."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        balances[_tokenAddress][_to] = balances[_tokenAddress][_to].add(_amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Common take order implementation\n', '    * @param _order OrderLib.Order memory - order info\n', '    * @param _takerSellAmount uint256 - amount being given by the taker\n', '    * @param _v uint8 part of the signature\n', '    * @param _r bytes32 part of the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 part of the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeOrder(\n', '        OrderLib.Order memory _order,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        bytes32 orderHash = _order.createHash();\n', '\n', '        require(\n', '            ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)), _v, _r, _s) == _order.maker,\n', '            "Order maker is invalid."\n', '        );\n', '\n', '        if(balances[_order.makerBuyToken][msg.sender] < _takerSellAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_TAKER_BALANCE), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint256 receivedAmount = (_order.makerSellAmount.mul(_takerSellAmount)).div(_order.makerBuyAmount);\n', '\n', '        if(balances[_order.makerSellToken][_order.maker] < receivedAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_MAKER_BALANCE), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if(filledAmounts[orderHash].add(_takerSellAmount) > _order.makerBuyAmount) {\n', '            emit Error(uint8(ErrorCode.INSUFFICIENT_ORDER_AMOUNT), orderHash);\n', '            return 0;\n', '        }\n', '\n', '        filledAmounts[orderHash] = filledAmounts[orderHash].add(_takerSellAmount);\n', '\n', '        balances[_order.makerBuyToken][msg.sender] = balances[_order.makerBuyToken][msg.sender].sub(_takerSellAmount);\n', '        balances[_order.makerBuyToken][_order.maker] = balances[_order.makerBuyToken][_order.maker].add(_takerSellAmount);\n', '\n', '        balances[_order.makerSellToken][msg.sender] = balances[_order.makerSellToken][msg.sender].add(receivedAmount);\n', '        balances[_order.makerSellToken][_order.maker] = balances[_order.makerSellToken][_order.maker].sub(receivedAmount);\n', '\n', '        emit TakeOrder(\n', '            _order.maker,\n', '            msg.sender,\n', '            _order.makerBuyToken,\n', '            _order.makerSellToken,\n', '            _takerSellAmount,\n', '            receivedAmount,\n', '            orderHash,\n', '            _order.nonce\n', '        );\n', '\n', '        return receivedAmount;\n', '    }\n', '\n', '    /**\n', '    * @dev Order maker can call this function in order to cancel it.\n', '    * What actually happens is that the order become\n', '    * fulfilled in the "filledAmounts" mapping. Thus we avoid someone calling\n', '    * "takeOrder" directly from the contract if the order hash is available to him.\n', '    * @param _orderAddresses address[3]\n', '    * @param _orderValues uint256[3]\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function cancelOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '    {\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '        bytes32 orderHash = order.createHash();\n', '\n', '        require(\n', '            ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)), _v, _r, _s) == msg.sender,\n', '            "Only order maker can cancel it."\n', '        );\n', '\n', '        filledAmounts[orderHash] = filledAmounts[orderHash].add(order.makerBuyAmount);\n', '\n', '        emit CancelOrder(\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            msg.sender,\n', '            orderHash,\n', '            order.nonce\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Cancel multiple orders in a single transaction.\n', '    * @param _orderAddresses address[3][]\n', '    * @param _orderValues uint256[3][]\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function cancelMultipleOrders(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s\n', '    )\n', '        external\n', '    {\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            cancelOrder(\n', '                _orderAddresses[index],\n', '                _orderValues[index],\n', '                _v[index],\n', '                _r[index],\n', '                _s[index]\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', 'contract DailyVolumeUpdater is Ownable {\n', '\n', '    using Math for uint256;\n', '\n', '    uint256 public dailyVolume;\n', '\n', '    uint256 public dailyVolumeCap;\n', '\n', '    uint256 private lastDay;\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        dailyVolume = 0;\n', '        dailyVolumeCap = 1000 ether;\n', '        lastDay = today();\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the owner to change the daily volume capacity.\n', '    * @param _dailyVolumeCap uint256 representing the daily volume capacity\n', '    */\n', '    function setDailyVolumeCap(uint256 _dailyVolumeCap)\n', '        public\n', '        onlyOwner\n', '    {\n', '        dailyVolumeCap = _dailyVolumeCap;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function that increments the daily volume.\n', '    * @param _volume uint256 representing the amount of volume increasement.\n', '    */\n', '    function updateVolume(uint256 _volume)\n', '        internal\n', '    {\n', '        if(today() > lastDay) {\n', '            dailyVolume = _volume;\n', '            lastDay = today();\n', '        } else {\n', '            dailyVolume = dailyVolume.add(_volume);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to check if the volume capacity is reached.\n', '    * @return Whether the volume is reached or not.\n', '    */\n', '    function isVolumeReached()\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        return dailyVolume >= dailyVolumeCap;\n', '    }\n', '\n', '    /**\n', "    * @dev Private function to determine today's index\n", "    * @return uint256 of today's index.\n", '    */\n', '    function today()\n', '        private\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return block.timestamp.div(1 days);\n', '    }\n', '}\n', '\n', 'contract DiscountTokenExchange is Exchange, DailyVolumeUpdater {\n', '\n', '    uint256 internal discountTokenRatio;\n', '\n', '    uint256 private minimumTokenAmountForUpdate;\n', '\n', '    address public discountTokenAddress;\n', '\n', '    bool internal initialized = false;\n', '\n', '    constructor(\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio\n', '    )\n', '        public\n', '    {\n', '        discountTokenAddress = _discountTokenAddress;\n', '        discountTokenRatio = _discountTokenRatio;\n', '    }\n', '\n', '    modifier onlyOnce() {\n', '        require(\n', '            initialized == false,\n', '            "Exchange is already initialized"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Update the token discount contract.\n', '    * @param _discountTokenAddress address of the token used for fee discount\n', '    * @param _discountTokenRatio uint256 initial rate of the token discount contract\n', '    */\n', '    function setDiscountToken(\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio,\n', '        uint256 _minimumTokenAmountForUpdate\n', '    )\n', '        public\n', '        onlyOwner\n', '        onlyOnce\n', '    {\n', '        discountTokenAddress = _discountTokenAddress;\n', '        discountTokenRatio = _discountTokenRatio;\n', '        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\n', '        initialized = true;\n', '    }\n', '\n', '    /**\n', '    * @dev Update the token ratio.\n', '    * Add a minimum requirement for the amount of tokens being traded\n', '    * to avoid possible intentional manipulation\n', '    * @param _etherAmount uint256 amount in Ethers (wei)\n', '    * @param _tokenAmount uint256 amount in Tokens\n', '    */\n', '    function updateTokenRatio(\n', '        uint256 _etherAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        if(_tokenAmount >= minimumTokenAmountForUpdate) {\n', '            discountTokenRatio = _etherAmount.calculateRate(_tokenAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Set the minimum requirement for updating the price.\n', '    * This should be called whenever the rate of the token\n', '    * has changed massively.\n', '    * In order to avoid token price manipulation (that will reduce the fee)\n', '    * The minimum amount requirement take place.\n', '    * For example: Someone buys or sells 0.0000000001 Tokens with\n', '    * high rate against ETH and after that execute a trade,\n', '    * reducing his fees to approximately zero.\n', '    * Having the mimimum amount requirement for updating\n', '    * the price will protect us from such cases because\n', '    * it will not be worth to do it.\n', '    * @param _minimumTokenAmountForUpdate - the new mimimum amount of\n', '    * tokens for updating the ratio (price)\n', '    */\n', '    function setMinimumTokenAmountForUpdate(\n', '        uint256 _minimumTokenAmountForUpdate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\n', '    }\n', '\n', '    /**\n', '    * @dev Execute WeiDexToken Sale Order based on the order input parameters\n', "    * and the signature from the maker's signing.\n", '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of WeiDexToken\n', '    * [2] address of Ether (0x0)\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in WDX\n', '    * [1] amount in Ethers (wei)\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeSellTokenOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[1] == discountTokenAddress,\n', '            "Should sell WeiDex Tokens"\n', '        );\n', '\n', '        require(\n', '            0 < takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s),\n', '            "Trade failure"\n', '        );\n', '        updateVolume(_takerSellAmount);\n', '        updateTokenRatio(_orderValues[1], _orderValues[0]);\n', '    }\n', '\n', '    /**\n', '    * @dev Execute WeiDexToken Buy Order based on the order input parameters\n', "    * and the signature from the maker's signing.\n", '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of Ether (0x0)\n', '    * [2] address of WeiDexToken\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in Ethers\n', '    * [1] amount in WDX\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeBuyTokenOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[2] == discountTokenAddress,\n', '            "Should buy WeiDex Tokens"\n', '        );\n', '\n', '        uint256 receivedAmount = takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s);\n', '        require(0 < receivedAmount, "Trade failure");\n', '        updateVolume(receivedAmount);\n', '        updateTokenRatio(_orderValues[0], _orderValues[1]);\n', '    }\n', '}\n', '\n', 'contract ReferralExchange is Exchange {\n', '\n', '    uint256 public referralFeeRate;\n', '\n', '    mapping(address => address) public referrals;\n', '\n', '    constructor(\n', '        uint256 _referralFeeRate\n', '    )\n', '        public\n', '    {\n', '        referralFeeRate = _referralFeeRate;\n', '    }\n', '\n', '    event ReferralBalanceUpdated(\n', '        address refererAddress,\n', '        address referralAddress,\n', '        address tokenAddress,\n', '        uint256 feeAmount,\n', '        uint256 referralFeeAmount\n', '    );\n', '\n', '    event ReferralDeposit(\n', '        address token,\n', '        address indexed user,\n', '        address indexed referrer,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '    * @dev Deposit Ethers with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositEthers(address _referrer)\n', '        external\n', '        payable\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        super._depositEthers(user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(ETH, user, _referrer, msg.value, balances[ETH][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Deposit Tokens with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _referrer\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        super._depositTokens(_tokenAddress, _amount, user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Update the referral fee rate,\n', '    * i.e. the rate of the fee that will be accounted to the referrer\n', '    * @param _referralFeeRate uint256 amount of fee going to the referrer\n', '    */\n', '    function setReferralFee(uint256 _referralFeeRate)\n', '        external\n', '        onlyOwner\n', '    {\n', '        referralFeeRate = _referralFeeRate;\n', '    }\n', '\n', '    /**\n', "    * @dev Return the feeAccount address if user doesn't have referrer\n", '    * @param _user address user whom referrer is being checked.\n', "    * @return address of user's referrer.\n", '    */\n', '    function getReferrer(address _user)\n', '        internal\n', '        view\n', '        returns(address referrer)\n', '    {\n', '        return referrals[_user] != address(0x0) ? referrals[_user] : feeAccount;\n', '    }\n', '}\n', '\n', 'contract UpgradableExchange is Exchange {\n', '\n', '    uint8 constant public VERSION = 0;\n', '\n', '    address public newExchangeAddress;\n', '\n', '    bool public isMigrationAllowed;\n', '\n', '    event FundsMigrated(address indexed user, address indexed exchangeAddress);\n', '\n', '    /**\n', '    * @dev Owner can set the address of the new version of the exchange contract.\n', '    * @param _newExchangeAddress address representing the new exchange contract address\n', '    */\n', '    function setNewExchangeAddress(address _newExchangeAddress)\n', '        external\n', '        onlyOwner\n', '    {\n', '        newExchangeAddress = _newExchangeAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Enables/Disables the migrations. Can be called only by the owner.\n', '    */\n', '    function allowOrRestrictMigrations()\n', '        external\n', '        onlyOwner\n', '    {\n', '        isMigrationAllowed = !isMigrationAllowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Set the address of the new version of the exchange contract. Should be called by the user.\n', '    * @param _tokens address[] representing the token addresses which are going to be migrated.\n', '    */\n', '    function migrateFunds(address[] _tokens) external {\n', '\n', '        require(\n', '            false != isMigrationAllowed,\n', '            "Fund migration is not allowed"\n', '        );\n', '\n', '        require(\n', '            IUpgradableExchange(newExchangeAddress).VERSION() > VERSION,\n', '            "New exchange version should be greater than the current version."\n', '        );\n', '\n', '        migrateEthers();\n', '\n', '        migrateTokens(_tokens);\n', '\n', '        emit FundsMigrated(msg.sender, newExchangeAddress);\n', '    }\n', '\n', '    /**\n', "    * @dev Helper function to migrate user's Ethers. Should be called in migrateFunds() function.\n", '    */\n', '    function migrateEthers() private {\n', '\n', '        uint256 etherAmount = balances[ETH][msg.sender];\n', '        if (etherAmount > 0) {\n', '            balances[ETH][msg.sender] = 0;\n', '\n', '            IUpgradableExchange(newExchangeAddress).importEthers.value(etherAmount)(msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @dev Helper function to migrate user's tokens. Should be called in migrateFunds() function.\n", '    * @param _tokens address[] representing the token addresses which are going to be migrated.\n', '    */\n', '    function migrateTokens(address[] _tokens) private {\n', '\n', '        for (uint256 index = 0; index < _tokens.length; index++) {\n', '\n', '            address tokenAddress = _tokens[index];\n', '\n', '            uint256 tokenAmount = balances[tokenAddress][msg.sender];\n', '\n', '            if (0 == tokenAmount) {\n', '                continue;\n', '            }\n', '\n', '            require(\n', '                Token(tokenAddress).approve(newExchangeAddress, tokenAmount),\n', '                "Approve failed"\n', '            );\n', '\n', '            balances[tokenAddress][msg.sender] = 0;\n', '\n', '            IUpgradableExchange(newExchangeAddress).importTokens(tokenAddress, tokenAmount, msg.sender);\n', '        }\n', '    }\n', '}\n', '\n', 'contract ExchangeOffering is Exchange {\n', '\n', '    using CrowdsaleLib for CrowdsaleLib.Crowdsale;\n', '\n', '    mapping(address => CrowdsaleLib.Crowdsale) public crowdsales;\n', '\n', '    mapping(address => mapping(address => uint256)) public userContributionForProject;\n', '\n', '    event TokenPurchase(\n', '        address indexed project,\n', '        address indexed contributor,\n', '        uint256 tokens,\n', '        uint256 weiAmount\n', '    );\n', '\n', '    function registerCrowdsale(\n', '        address _project,\n', '        address _projectWallet,\n', '        uint256[8] _values\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        crowdsales[_project] = CrowdsaleLib.createCrowdsale(_projectWallet, _values);\n', '\n', '        require(\n', '            crowdsales[_project].isValid(),\n', '            "Crowdsale is not active."\n', '        );\n', '\n', '        // project contract validation\n', '        require(\n', '            getBonusFactor(_project, crowdsales[_project].minContribution) >= 0,\n', '            "The project should have *getBonusFactor* function implemented. The function should return the bonus percentage depending on the start/end date and contribution amount. Should return 0 if there is no bonus."\n', '        );\n', '\n', '        // project contract validation\n', '        require(\n', '            isUserWhitelisted(_project, this),\n', '            "The project should have *isUserWhitelisted* function implemented. This contract address should be whitelisted"\n', '        );\n', '    }\n', '\n', '    function buyTokens(address _project)\n', '       public\n', '       payable\n', '    {\n', '        uint256 weiAmount = msg.value;\n', '\n', '        address contributor = msg.sender;\n', '\n', '        address crowdsaleWallet = crowdsales[_project].wallet;\n', '\n', '        require(\n', '            isUserWhitelisted(_project, contributor), "User is not whitelisted"\n', '        );\n', '\n', '        require(\n', '            validContribution(_project, contributor, weiAmount),\n', '            "Contribution is not valid: Check minimum/maximum contribution amount or if crowdsale cap is reached"\n', '        );\n', '\n', '        uint256 tokens = weiAmount.mul(crowdsales[_project].tokenRatio);\n', '\n', '        uint256 bonus = getBonusFactor(_project, weiAmount);\n', '\n', '        uint256 bonusAmount = tokens.mul(bonus).div(100);\n', '\n', '        uint256 totalPurchasedTokens = tokens.add(bonusAmount);\n', '\n', '        crowdsales[_project].leftAmount = crowdsales[_project].leftAmount.sub(totalPurchasedTokens);\n', '\n', '        require(Token(_project).transfer(contributor, totalPurchasedTokens), "Transfer failed");\n', '\n', '        crowdsales[_project].weiRaised = crowdsales[_project].weiRaised.add(weiAmount);\n', '\n', '        userContributionForProject[_project][contributor] = userContributionForProject[_project][contributor].add(weiAmount);\n', '\n', '        balances[ETH][crowdsaleWallet] = balances[ETH][crowdsaleWallet].add(weiAmount);\n', '\n', '        emit TokenPurchase(_project, contributor, totalPurchasedTokens, weiAmount);\n', '    }\n', '\n', '    function withdrawWhenFinished(address _project) public {\n', '\n', '        address crowdsaleWallet = crowdsales[_project].wallet;\n', '\n', '        require(\n', '            msg.sender == crowdsaleWallet,\n', '            "Only crowdsale owner can withdraw funds that are left."\n', '        );\n', '\n', '        require(\n', '            !crowdsales[_project].isOpened(),\n', '            "You can\'t withdraw funds yet. Crowdsale should end first."\n', '        );\n', '\n', '        uint256 leftAmount = crowdsales[_project].leftAmount;\n', '\n', '        crowdsales[_project].leftAmount = 0;\n', '\n', '        require(Token(_project).transfer(crowdsaleWallet, leftAmount), "Transfer failed");\n', '    }\n', '\n', '    function saleOpen(address _project)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return crowdsales[_project].isOpened();\n', '    }\n', '\n', '    function getBonusFactor(address _project, uint256 _weiAmount)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Token(_project).getBonusFactor(crowdsales[_project].startTime, crowdsales[_project].endTime, _weiAmount);\n', '    }\n', '\n', '    function isUserWhitelisted(address _project, address _user)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return Token(_project).isUserWhitelisted(_user);\n', '    }\n', '\n', '    function validContribution(\n', '        address _project,\n', '        address _user,\n', '        uint256 _weiAmount\n', '    )\n', '        private\n', '        view\n', '        returns(bool)\n', '    {\n', '        if (saleOpen(_project)) {\n', '            // minimum contribution check\n', '            if (_weiAmount < crowdsales[_project].minContribution) {\n', '                return false;\n', '            }\n', '\n', '            // maximum contribution check\n', '            if (userContributionForProject[_project][_user].add(_weiAmount) > crowdsales[_project].maxContribution) {\n', '                return false;\n', '            }\n', '\n', '            // token sale capacity check\n', '            if (crowdsales[_project].capacity < crowdsales[_project].weiRaised.add(_weiAmount)) {\n', '                return false;\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '\n', '        return msg.value != 0; // check for non zero contribution\n', '    }\n', '}\n', '\n', 'contract OldERC20ExchangeSupport is Exchange, ReferralExchange {\n', '\n', '    /**\n', '    * @dev Allows user to deposit Tokens in the exchange contract.\n', '    * Only the respected user can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    */\n', '    function depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '        _depositOldTokens(_tokenAddress, _amount, user);\n', '        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Deposit Tokens with a given referrer address\n', '    * @param _referrer address of the referrer\n', '    */\n', '    function depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _referrer\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            0x0 == referrals[user],\n', '            "This user already have a referrer."\n', '        );\n', '\n', '        _depositOldTokens(_tokenAddress, _amount, user);\n', '        referrals[user] = _referrer;\n', '        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '        /**\n', '    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\n', '    * Only the beneficiary can withdraw these tokens.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the token amount to be deposited.\n', '    * @param _beneficiary address representing the token amount to be deposited.\n', '    */\n', '    function depositOldTokensFor(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        external\n', '    {\n', '        _depositOldTokens(_tokenAddress, _amount, _beneficiary);\n', '        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows user to withdraw specific Token from the exchange contract.\n', '    * Throws if the user balance is lower than the requested amount.\n', '    * @param _tokenAddress address representing the token contract address.\n', '    * @param _amount uint256 representing the amount to be withdrawn.\n', '    */\n', '    function withdrawOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[_tokenAddress][user] >= _amount,\n', '            "Not enough funds to withdraw."\n', '        );\n', '\n', '        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\n', '\n', '        SafeOldERC20.transfer(_tokenAddress, user, _amount);\n', '\n', '        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal version of deposit Tokens.\n', '    */\n', '    function _depositOldTokens(\n', '        address _tokenAddress,\n', '        uint256 _amount,\n', '        address _beneficiary\n', '    )\n', '        internal\n', '    {\n', '        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\n', '\n', '        SafeOldERC20.transferFrom(_tokenAddress, msg.sender, this, _amount);\n', '    }\n', '}\n', '\n', 'contract WeiDex is DiscountTokenExchange, ReferralExchange, UpgradableExchange, ExchangeOffering, OldERC20ExchangeSupport  {\n', '\n', '    mapping(bytes4 => bool) private allowedMethods;\n', '\n', '    function () public payable {\n', '        revert("Cannot send Ethers to the contract, use depositEthers");\n', '    }\n', '\n', '    constructor(\n', '        address _feeAccount,\n', '        uint256 _feeRate,\n', '        uint256 _referralFeeRate,\n', '        address _discountTokenAddress,\n', '        uint256 _discountTokenRatio\n', '    )\n', '        public\n', '        Exchange(_feeAccount, _feeRate)\n', '        ReferralExchange(_referralFeeRate)\n', '        DiscountTokenExchange(_discountTokenAddress, _discountTokenRatio)\n', '    {\n', '        // empty constructor\n', '    }\n', '\n', '    /**\n', '    * @dev Allows or restricts methods from being executed in takeAllPossible and takeAllOrRevert\n', '    * @param _methodId bytes4 method id that will be allowed/forbidded from execution\n', '    * @param _allowed bool\n', '    */\n', '    function allowOrRestrictMethod(\n', '        bytes4 _methodId,\n', '        bool _allowed\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        allowedMethods[_methodId] = _allowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Execute multiple order by given method id\n', '    * @param _orderAddresses address[3][] representing\n', '    * @param _orderValues uint256[4][] representing\n', '    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeAllOrRevert(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint256[] _takerSellAmount,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        bytes4 _methodId\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            allowedMethods[_methodId],\n', '            "Can\'t call this method"\n', '        );\n', '\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            require(\n', '                address(this).delegatecall(\n', '                _methodId,\n', '                _orderAddresses[index],\n', '                _orderValues[index],\n', '                _takerSellAmount[index],\n', '                _v[index],\n', '                _r[index],\n', '                _s[index]\n', '                ),\n', '                "Method call failed"\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute multiple order by given method id\n', '    * @param _orderAddresses address[3][]\n', '    * @param _orderValues uint256[4][]\n', '    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\n', '    * @param _v uint8[] parameter parsed from the signature recovery\n', '    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeAllPossible(\n', '        address[3][] _orderAddresses,\n', '        uint256[3][] _orderValues,\n', '        uint256[] _takerSellAmount,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        bytes4 _methodId\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            allowedMethods[_methodId],\n', '            "Can\'t call this method"\n', '        );\n', '\n', '        for (uint256 index = 0; index < _orderAddresses.length; index++) {\n', '            address(this).delegatecall(\n', '            _methodId,\n', '            _orderAddresses[index],\n', '            _orderValues[index],\n', '            _takerSellAmount[index],\n', '            _v[index],\n', '            _r[index],\n', '            _s[index]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute buy order based on the order input parameters\n', "    * and the signature from the maker's signing\n", '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of ether (0x0)\n', '    * [2] address of token being bought\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in Ethers (wei)\n', '    * [1] amount in tokens\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in tokens\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeBuyOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _orderAddresses[1] == ETH,\n', '            "Base currency must be ether\'s (0x0)"\n', '        );\n', '\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\n', '\n', '        require(0 < receivedAmount, "Trade failure");\n', '\n', '        updateVolume(receivedAmount);\n', '\n', '        if (!isVolumeReached()) {\n', '            takeFee(order.maker, msg.sender, order.makerBuyToken, _takerSellAmount, receivedAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Execute sell order based on the order input parameters\n', "    * and the signature from the maker's signing\n", '    * @param _orderAddresses address[3] representing\n', '    * [0] address of the order maker\n', '    * [1] address of token being sold\n', '    * [2] address of ether (0x0)\n', '    * @param _orderValues uint256[4] representing\n', '    * [0] amount in tokens\n', '    * [1] amount in Ethers (wei)\n', '    * [2] order nonce used for hash uniqueness\n', '    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\n', '    * @param _v uint8 parameter parsed from the signature recovery\n', '    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\n', '    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\n', '    */\n', '    function takeSellOrder(\n', '        address[3] _orderAddresses,\n', '        uint256[3] _orderValues,\n', '        uint256 _takerSellAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            _orderAddresses[2] == ETH,\n', '            "Base currency must be ether\'s (0x0)"\n', '        );\n', '\n', '        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\n', '\n', '        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\n', '\n', '        require(0 < receivedAmount, "Trade failure");\n', '\n', '        updateVolume(_takerSellAmount);\n', '\n', '        if (!isVolumeReached()) {\n', '            takeFee(order.maker, msg.sender, order.makerSellToken, receivedAmount, _takerSellAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee for making/taking the order\n', '    * @param _maker address\n', '    * @param _taker address\n', '    * @param _tokenAddress address\n', '    * @param _tokenFulfilledAmount uint256 fulfilled amount in tokens\n', '    * @param _etherFulfilledAmount uint256 fulfilled amount in ethers\n', '    */\n', '    function takeFee(\n', '        address _maker,\n', '        address _taker,\n', '        address _tokenAddress,\n', '        uint256 _tokenFulfilledAmount,\n', '        uint256 _etherFulfilledAmount\n', '    )\n', '        private\n', '    {\n', '        uint256 _feeRate = feeRate; // gas optimization\n', '        uint256 feeInWdx = _etherFulfilledAmount.calculateWdxFee(discountTokenRatio, feeRate);\n', '\n', '        takeFee(_maker, ETH, _etherFulfilledAmount.div(_feeRate), feeInWdx);\n', '        takeFee(_taker, _tokenAddress, _tokenFulfilledAmount.div(_feeRate), feeInWdx);\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee in WDX or the given token address\n', '    * @param _user address taker or maker\n', '    * @param _tokenAddress address of the token\n', '    * @param _tokenFeeAmount uint256 amount in given token address\n', '    * @param _wdxFeeAmount uint256 amount in WDX tokens\n', '    */\n', '    function takeFee(\n', '        address _user,\n', '        address _tokenAddress,\n', '        uint256 _tokenFeeAmount,\n', '        uint256 _wdxFeeAmount\n', '        )\n', '        private\n', '    {\n', '        if(balances[discountTokenAddress][_user] >= _wdxFeeAmount) {\n', '            takeFee(_user, discountTokenAddress, _wdxFeeAmount);\n', '        } else {\n', '            takeFee(_user, _tokenAddress, _tokenFeeAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Takes fee in WDX or the given token address\n', '    * @param _user address taker or maker\n', '    * @param _tokenAddress address\n', '    * @param _fullFee uint256 fee taken from a given token address\n', '    */\n', '    function takeFee(\n', '        address _user,\n', '        address _tokenAddress,\n', '        uint256 _fullFee\n', '        )\n', '        private\n', '    {\n', '        address _feeAccount = feeAccount; // gas optimization\n', '        address referrer = getReferrer(_user);\n', '        uint256 referralFee = _fullFee.calculateReferralFee(referralFeeRate);\n', '\n', '        balances[_tokenAddress][_user] = balances[_tokenAddress][_user].sub(_fullFee);\n', '\n', '        if(referrer == _feeAccount) {\n', '            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee);\n', '        } else {\n', '            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee.sub(referralFee));\n', '            balances[_tokenAddress][referrer] = balances[_tokenAddress][referrer].add(referralFee);\n', '        }\n', '        emit ReferralBalanceUpdated(referrer, _user, _tokenAddress, _fullFee, referralFee);\n', '    }\n', '}']
