['pragma solidity ^0.4.18;\n', '\n', '/**\n', '* Ponzi Trust Token Seller Smart Contract\n', '* Code is published on https://github.com/PonziTrust/TokenSeller\n', '* Ponzi Trust https://ponzitrust.com/\n', '*/\n', '\n', '// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// Ponzi Token Minimal Interface\n', 'contract PonziTokenMinInterface {\n', '  function balanceOf(address owner) public view returns(uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract PonziSeller {\n', '  using SafeMath for uint256;\n', '  enum AccessRank {\n', '    None,\n', '    SetPrice,\n', '    Withdraw,\n', '    Full\n', '  }\n', '\n', '  address private constant PONZI_ADDRESS = 0xc2807533832807Bf15898778D8A108405e9edfb1;\n', '  PonziTokenMinInterface private m_ponzi;\n', '  uint256 private m_ponziPriceInWei;\n', '  uint256 private m_rewardNum;\n', '  uint256 private m_rewardDen;\n', '  uint256 private m_discountNum;\n', '  uint256 private m_discountDen;\n', '  mapping(address => AccessRank) private m_admins;\n', '\n', '  event PriceChanged(address indexed who, uint256 newPrice);\n', '  event RewardRef(address indexed refAddr, uint256 ponziAmount);\n', '  event WithdrawalETH(address indexed to, uint256 amountInWei);\n', '  event WithdrawalPonzi(address indexed to, uint256 amount);\n', '  event ProvidingAccess(address indexed addr, AccessRank rank);\n', '  event PonziSold(\n', '    address indexed purchasedBy, \n', '    uint256 indexed priceInWei, \n', '    uint256 ponziAmount, \n', '    uint256 weiAmount, \n', '    address indexed refAddr \n', '  );\n', '  event NotEnoughPonzi(\n', '    address indexed addr, \n', '    uint256 weiAmount, \n', '    uint256 ponziPriceInWei, \n', '    uint256 ponziBalance\n', '  );\n', '\n', '  modifier onlyAdmin(AccessRank  r) {\n', '    require(m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full);\n', '    _;\n', '  }\n', '\n', '  function PonziSeller() public {\n', '    m_ponzi = PonziTokenMinInterface(PONZI_ADDRESS);\n', '    m_admins[msg.sender] = AccessRank.Full;\n', '    m_rewardNum = 1;\n', '    m_rewardDen = 10;\n', '    m_discountNum = 5;\n', '    m_discountDen = 100;\n', '  }\n', '\n', '  function() public payable {\n', '    byPonzi(address(0));\n', '  }\n', '\n', '  function setPonziAddress(address ponziAddr) public onlyAdmin(AccessRank.Full) {\n', '    m_ponzi = PonziTokenMinInterface(ponziAddr);\n', '  }\n', '\n', '  function ponziAddress() public view returns (address ponziAddr) {\n', '    return address(m_ponzi);\n', '  }\n', '\n', '  function ponziPriceInWei() public view returns (uint256) { \n', '    return m_ponziPriceInWei;\n', '  }\n', '\n', '  function setPonziPriceInWei(uint256 newPonziPriceInWei) public onlyAdmin(AccessRank.SetPrice) { \n', '    m_ponziPriceInWei = newPonziPriceInWei;\n', '    emit PriceChanged(msg.sender, m_ponziPriceInWei);\n', '  }\n', '\n', '  function rewardPercent() public view returns (uint256 numerator, uint256 denominator) {\n', '    numerator = m_rewardNum;\n', '    denominator = m_rewardDen;\n', '  }\n', '\n', '  function discountPercent() public view returns (uint256 numerator, uint256 denominator) {\n', '    numerator = m_discountNum;\n', '    denominator = m_discountDen;\n', '  }\n', '\n', '  function provideAccess(address adminAddr, uint8 rank) public onlyAdmin(AccessRank.Full) {\n', '    require(rank <= uint8(AccessRank.Full));\n', '    require(m_admins[adminAddr] != AccessRank.Full);\n', '    m_admins[adminAddr] = AccessRank(rank);\n', '  }\n', '\n', '  function setRewardPercent(uint256 newNumerator, uint256 newDenominator) public onlyAdmin(AccessRank.Full) {\n', '    require(newDenominator != 0);\n', '    m_rewardNum = newNumerator;\n', '    m_rewardDen = newDenominator;\n', '  }\n', '\n', '  function setDiscountPercent(uint256 newNumerator, uint256 newDenominator) public onlyAdmin(AccessRank.Full) {\n', '    require(newDenominator != 0);\n', '    m_discountNum = newNumerator;\n', '    m_discountDen = newDenominator;\n', '  }\n', '\n', '  function byPonzi(address refAddr) public payable {\n', '    require(m_ponziPriceInWei > 0 && msg.value > m_ponziPriceInWei);\n', '\n', '    uint256 refAmount = 0;\n', '    uint256 senderAmount = weiToPonzi(msg.value, m_ponziPriceInWei);\n', '\n', '    // check if ref addres is valid and calc reward and discount\n', '    if (refAddr != msg.sender && refAddr != address(0) && refAddr != address(this)) {\n', '      // ref reward\n', '      refAmount = senderAmount.mul(m_rewardNum).div(m_rewardDen);\n', '      // sender discount\n', '      // uint256 d = m_discountDen/(m_discountDen-m_discountNum)\n', '      senderAmount = senderAmount.mul(m_discountDen).div(m_discountDen-m_discountNum);\n', '      // senderAmount = senderAmount.add(senderAmount.mul(m_discountNum).div(m_discountDen));\n', '    }\n', '    // check if we have enough ponzi on balance\n', '    if (availablePonzi() < senderAmount.add(refAmount)) {\n', '      emit NotEnoughPonzi(msg.sender, msg.value, m_ponziPriceInWei, availablePonzi());\n', '      revert();\n', '    }\n', '  \n', '    // transfer ponzi to sender\n', '    require(m_ponzi.transfer(msg.sender, senderAmount));\n', '    // transfer ponzi to ref if needed\n', '    if (refAmount > 0) {\n', '      require(m_ponzi.transfer(refAddr, refAmount));\n', '      emit RewardRef(refAddr, refAmount);\n', '    }\n', '    emit PonziSold(msg.sender, m_ponziPriceInWei, senderAmount, msg.value, refAddr);\n', '  }\n', '\n', '  function availablePonzi() public view returns (uint256) {\n', '    return m_ponzi.balanceOf(address(this));\n', '  }\n', '\n', '  function withdrawETH() public onlyAdmin(AccessRank.Withdraw) {\n', '    uint256 amountWei = address(this).balance;\n', '    require(amountWei > 0);\n', '    msg.sender.transfer(amountWei);\n', '    assert(address(this).balance < amountWei);\n', '    emit WithdrawalETH(msg.sender, amountWei);\n', '  }\n', '\n', '  function withdrawPonzi(uint256 amount) public onlyAdmin(AccessRank.Withdraw) {\n', '    uint256 pt = availablePonzi();\n', '    require(pt > 0 && amount > 0 && pt >= amount);\n', '    require(m_ponzi.transfer(msg.sender, amount));\n', '    assert(availablePonzi() < pt);\n', '    emit WithdrawalPonzi(msg.sender, pt);\n', '  }\n', '\n', '  function weiToPonzi(uint256 weiAmount, uint256 tokenPrice) \n', '    internal \n', '    pure \n', '    returns(uint256 tokensAmount) \n', '  {\n', '    tokensAmount = weiAmount.div(tokenPrice);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', '* Ponzi Trust Token Seller Smart Contract\n', '* Code is published on https://github.com/PonziTrust/TokenSeller\n', '* Ponzi Trust https://ponzitrust.com/\n', '*/\n', '\n', '// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// Ponzi Token Minimal Interface\n', 'contract PonziTokenMinInterface {\n', '  function balanceOf(address owner) public view returns(uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract PonziSeller {\n', '  using SafeMath for uint256;\n', '  enum AccessRank {\n', '    None,\n', '    SetPrice,\n', '    Withdraw,\n', '    Full\n', '  }\n', '\n', '  address private constant PONZI_ADDRESS = 0xc2807533832807Bf15898778D8A108405e9edfb1;\n', '  PonziTokenMinInterface private m_ponzi;\n', '  uint256 private m_ponziPriceInWei;\n', '  uint256 private m_rewardNum;\n', '  uint256 private m_rewardDen;\n', '  uint256 private m_discountNum;\n', '  uint256 private m_discountDen;\n', '  mapping(address => AccessRank) private m_admins;\n', '\n', '  event PriceChanged(address indexed who, uint256 newPrice);\n', '  event RewardRef(address indexed refAddr, uint256 ponziAmount);\n', '  event WithdrawalETH(address indexed to, uint256 amountInWei);\n', '  event WithdrawalPonzi(address indexed to, uint256 amount);\n', '  event ProvidingAccess(address indexed addr, AccessRank rank);\n', '  event PonziSold(\n', '    address indexed purchasedBy, \n', '    uint256 indexed priceInWei, \n', '    uint256 ponziAmount, \n', '    uint256 weiAmount, \n', '    address indexed refAddr \n', '  );\n', '  event NotEnoughPonzi(\n', '    address indexed addr, \n', '    uint256 weiAmount, \n', '    uint256 ponziPriceInWei, \n', '    uint256 ponziBalance\n', '  );\n', '\n', '  modifier onlyAdmin(AccessRank  r) {\n', '    require(m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full);\n', '    _;\n', '  }\n', '\n', '  function PonziSeller() public {\n', '    m_ponzi = PonziTokenMinInterface(PONZI_ADDRESS);\n', '    m_admins[msg.sender] = AccessRank.Full;\n', '    m_rewardNum = 1;\n', '    m_rewardDen = 10;\n', '    m_discountNum = 5;\n', '    m_discountDen = 100;\n', '  }\n', '\n', '  function() public payable {\n', '    byPonzi(address(0));\n', '  }\n', '\n', '  function setPonziAddress(address ponziAddr) public onlyAdmin(AccessRank.Full) {\n', '    m_ponzi = PonziTokenMinInterface(ponziAddr);\n', '  }\n', '\n', '  function ponziAddress() public view returns (address ponziAddr) {\n', '    return address(m_ponzi);\n', '  }\n', '\n', '  function ponziPriceInWei() public view returns (uint256) { \n', '    return m_ponziPriceInWei;\n', '  }\n', '\n', '  function setPonziPriceInWei(uint256 newPonziPriceInWei) public onlyAdmin(AccessRank.SetPrice) { \n', '    m_ponziPriceInWei = newPonziPriceInWei;\n', '    emit PriceChanged(msg.sender, m_ponziPriceInWei);\n', '  }\n', '\n', '  function rewardPercent() public view returns (uint256 numerator, uint256 denominator) {\n', '    numerator = m_rewardNum;\n', '    denominator = m_rewardDen;\n', '  }\n', '\n', '  function discountPercent() public view returns (uint256 numerator, uint256 denominator) {\n', '    numerator = m_discountNum;\n', '    denominator = m_discountDen;\n', '  }\n', '\n', '  function provideAccess(address adminAddr, uint8 rank) public onlyAdmin(AccessRank.Full) {\n', '    require(rank <= uint8(AccessRank.Full));\n', '    require(m_admins[adminAddr] != AccessRank.Full);\n', '    m_admins[adminAddr] = AccessRank(rank);\n', '  }\n', '\n', '  function setRewardPercent(uint256 newNumerator, uint256 newDenominator) public onlyAdmin(AccessRank.Full) {\n', '    require(newDenominator != 0);\n', '    m_rewardNum = newNumerator;\n', '    m_rewardDen = newDenominator;\n', '  }\n', '\n', '  function setDiscountPercent(uint256 newNumerator, uint256 newDenominator) public onlyAdmin(AccessRank.Full) {\n', '    require(newDenominator != 0);\n', '    m_discountNum = newNumerator;\n', '    m_discountDen = newDenominator;\n', '  }\n', '\n', '  function byPonzi(address refAddr) public payable {\n', '    require(m_ponziPriceInWei > 0 && msg.value > m_ponziPriceInWei);\n', '\n', '    uint256 refAmount = 0;\n', '    uint256 senderAmount = weiToPonzi(msg.value, m_ponziPriceInWei);\n', '\n', '    // check if ref addres is valid and calc reward and discount\n', '    if (refAddr != msg.sender && refAddr != address(0) && refAddr != address(this)) {\n', '      // ref reward\n', '      refAmount = senderAmount.mul(m_rewardNum).div(m_rewardDen);\n', '      // sender discount\n', '      // uint256 d = m_discountDen/(m_discountDen-m_discountNum)\n', '      senderAmount = senderAmount.mul(m_discountDen).div(m_discountDen-m_discountNum);\n', '      // senderAmount = senderAmount.add(senderAmount.mul(m_discountNum).div(m_discountDen));\n', '    }\n', '    // check if we have enough ponzi on balance\n', '    if (availablePonzi() < senderAmount.add(refAmount)) {\n', '      emit NotEnoughPonzi(msg.sender, msg.value, m_ponziPriceInWei, availablePonzi());\n', '      revert();\n', '    }\n', '  \n', '    // transfer ponzi to sender\n', '    require(m_ponzi.transfer(msg.sender, senderAmount));\n', '    // transfer ponzi to ref if needed\n', '    if (refAmount > 0) {\n', '      require(m_ponzi.transfer(refAddr, refAmount));\n', '      emit RewardRef(refAddr, refAmount);\n', '    }\n', '    emit PonziSold(msg.sender, m_ponziPriceInWei, senderAmount, msg.value, refAddr);\n', '  }\n', '\n', '  function availablePonzi() public view returns (uint256) {\n', '    return m_ponzi.balanceOf(address(this));\n', '  }\n', '\n', '  function withdrawETH() public onlyAdmin(AccessRank.Withdraw) {\n', '    uint256 amountWei = address(this).balance;\n', '    require(amountWei > 0);\n', '    msg.sender.transfer(amountWei);\n', '    assert(address(this).balance < amountWei);\n', '    emit WithdrawalETH(msg.sender, amountWei);\n', '  }\n', '\n', '  function withdrawPonzi(uint256 amount) public onlyAdmin(AccessRank.Withdraw) {\n', '    uint256 pt = availablePonzi();\n', '    require(pt > 0 && amount > 0 && pt >= amount);\n', '    require(m_ponzi.transfer(msg.sender, amount));\n', '    assert(availablePonzi() < pt);\n', '    emit WithdrawalPonzi(msg.sender, pt);\n', '  }\n', '\n', '  function weiToPonzi(uint256 weiAmount, uint256 tokenPrice) \n', '    internal \n', '    pure \n', '    returns(uint256 tokensAmount) \n', '  {\n', '    tokensAmount = weiAmount.div(tokenPrice);\n', '  }\n', '}']
