['pragma solidity ^0.4.22;\n', '\n', 'contract EthMashChain {\n', '\n', '    address public owner;\n', '    mapping (address => uint) public withdrawals;\n', '\n', '    uint round;\n', '    mapping (uint => address[3]) participants;\n', '    \n', '    event Log(address indexed user, uint action, uint price);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        round = 1;\n', '        participants[1][0] = owner;\n', '    }\n', '\n', '    modifier whenOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function ownerWithdraw(uint amount) external whenOwner {\n', '        owner.transfer(amount);\n', '    }\n', '\n', '    function ownerDestroy() external whenOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function publicGetRound() view public returns (uint) {\n', '        return round;\n', '    }\n', '\n', '    function publicGetParticipants(uint index) view public returns (address[3]) {\n', '        return participants[index];\n', '    }\n', '\n', '    function publicGetBalance(address player) view public returns (uint) {\n', '        return withdrawals[player];\n', '    }\n', '\n', '    function userWithdraw() public {\n', '        require(withdrawals[msg.sender] > 0);\n', '        uint amount = withdrawals[msg.sender];\n', '        withdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '        emit Log(msg.sender, 0, amount);\n', '    }\n', '\n', '    function userRegister() public payable {\n', '        require(msg.value == 105 finney);\n', '        emit Log(msg.sender, 1, msg.value);\n', '        participants[round][1] = msg.sender;\n', '\n', '        uint reward = 100 finney;\n', '        uint random = (uint(blockhash(block.number - 1)) + uint(participants[round][0]) + uint(participants[round][1]));\n', '\n', '        if (random % 2 == 0) {\n', '            participants[round][2] = participants[round][0];\n', '            withdrawals[participants[round][0]] += reward;\n', '            emit Log(participants[round][0], 2, reward);\n', '        } else {\n', '            participants[round][2] = participants[round][1];\n', '            withdrawals[participants[round][1]] += reward;\n', '            emit Log(participants[round][1], 2, reward);\n', '        }\n', '        \n', '        round++;\n', '        participants[round][0] = msg.sender;\n', '    }\n', '}']