['pragma solidity ^0.4.24;\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        emit LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        emit LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return Token(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'interface ExchangeHandler {\n', '\n', '    /// @dev Get the available amount left to fill for an order\n', '    /// @param orderAddresses Array of address values needed for this DEX order\n', '    /// @param orderValues Array of uint values needed for this DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Available amount left to fill for this order\n', '    function getAvailableAmount(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '\n', '    /// @dev Perform a buy order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable returns (uint256);\n', '\n', '    /// @dev Perform a sell order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '/// @title The primary contract for Totle Inc\n', 'contract TotlePrimary is Ownable {\n', '    // Constants\n', '    string public constant CONTRACT_VERSION = "0";\n', '    uint256 public constant MAX_EXCHANGE_FEE_PERCENTAGE = 0.01 * 10**18; // 1%\n', '    bool constant BUY = false;\n', '    bool constant SELL = true;\n', '\n', '    // State variables\n', '    mapping(address => bool) public handlerWhitelist;\n', '    address tokenTransferProxy;\n', '\n', '    // Structs\n', '    struct Tokens {\n', '        address[] tokenAddresses;\n', '        bool[]    buyOrSell;\n', '        uint256[] amountToObtain;\n', '        uint256[] amountToGive;\n', '    }\n', '\n', '    struct DEXOrders {\n', '        address[] tokenForOrder;\n', '        address[] exchanges;\n', '        address[8][] orderAddresses;\n', '        uint256[6][] orderValues;\n', '        uint256[] exchangeFees;\n', '        uint8[] v;\n', '        bytes32[] r;\n', '        bytes32[] s;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    /// @param proxy Address of the TokenTransferProxy\n', '    constructor(address proxy) public {\n', '        tokenTransferProxy = proxy;\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    /// @dev Set an exchange handler address to true/false\n', '    /// @notice - onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param handler Address of the exchange handler which permission needs changing\n', '    /// @param allowed Boolean value to set whether an exchange handler is allowed/denied\n', '    function setHandler(address handler, bool allowed) public onlyOwner {\n', '        handlerWhitelist[handler] = allowed;\n', '    }\n', '\n', '    /// @dev Synchronously executes an array of orders\n', '    /// @notice The first four parameters relate to Token orders, the last eight relate to DEX orders\n', '    /// @param tokenAddresses Array of addresses of ERC20 Token contracts for each Token order\n', '    /// @param buyOrSell Array indicating whether each Token order is a buy or sell\n', '    /// @param amountToObtain Array indicating the amount (in ether or tokens) to obtain in the order\n', '    /// @param amountToGive Array indicating the amount (in ether or tokens) to give in the order\n', '    /// @param tokenForOrder Array of addresses of ERC20 Token contracts for each DEX order\n', '    /// @param exchanges Array of addresses of exchange handler contracts\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFees Array indicating the fee for each DEX order (percentage of fill amount as decimal * 10**18)\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    function executeOrders(\n', '        // Tokens\n', '        address[] tokenAddresses,\n', '        bool[]    buyOrSell,\n', '        uint256[] amountToObtain,\n', '        uint256[] amountToGive,\n', '        // DEX Orders\n', '        address[] tokenForOrder,\n', '        address[] exchanges,\n', '        address[8][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256[] exchangeFees,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s\n', '    ) public payable {\n', '\n', '        require(\n', '            tokenAddresses.length == buyOrSell.length &&\n', '            buyOrSell.length      == amountToObtain.length &&\n', '            amountToObtain.length == amountToGive.length\n', '        );\n', '\n', '        require(\n', '            tokenForOrder.length  == exchanges.length &&\n', '            exchanges.length      == orderAddresses.length &&\n', '            orderAddresses.length == orderValues.length &&\n', '            orderValues.length    == exchangeFees.length &&\n', '            exchangeFees.length   == v.length &&\n', '            v.length              == r.length &&\n', '            r.length              == s.length\n', '        );\n', '\n', '        // Wrapping order in structs to reduce local variable count\n', '        internalOrderExecution(\n', '            Tokens(\n', '                tokenAddresses,\n', '                buyOrSell,\n', '                amountToObtain,\n', '                amountToGive\n', '            ),\n', '            DEXOrders(\n', '                tokenForOrder,\n', '                exchanges,\n', '                orderAddresses,\n', '                orderValues,\n', '                exchangeFees,\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        );\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '    /// @dev Synchronously executes an array of orders\n', '    /// @notice The orders in this function have been wrapped in structs to reduce the local variable count\n', '    /// @param tokens Struct containing the arrays of token orders\n', '    /// @param orders Struct containing the arrays of DEX orders\n', '    function internalOrderExecution(Tokens tokens, DEXOrders orders) internal {\n', '        transferTokens(tokens);\n', '\n', '        uint256 tokensLength = tokens.tokenAddresses.length;\n', '        uint256 ordersLength = orders.tokenForOrder.length;\n', '        uint256 etherBalance = msg.value;\n', '        uint256 orderIndex = 0;\n', '\n', '        for(uint256 tokenIndex = 0; tokenIndex < tokensLength; tokenIndex++) {\n', '            // NOTE - check for repetitions in the token list?\n', '\n', '            uint256 amountRemaining = tokens.amountToGive[tokenIndex];\n', '            uint256 amountObtained = 0;\n', '\n', '            while(orderIndex < ordersLength) {\n', '                require(tokens.tokenAddresses[tokenIndex] == orders.tokenForOrder[orderIndex]);\n', '                require(handlerWhitelist[orders.exchanges[orderIndex]]);\n', '\n', '                if(amountRemaining > 0) {\n', '                    if(tokens.buyOrSell[tokenIndex] == BUY) {\n', '                        require(etherBalance >= amountRemaining);\n', '                    }\n', '                    (amountRemaining, amountObtained) = performTrade(\n', '                        tokens.buyOrSell[tokenIndex],\n', '                        amountRemaining,\n', '                        amountObtained,\n', '                        orders, // NOTE - unable to send pointer to order values individually, as run out of stack space!\n', '                        orderIndex\n', '                        );\n', '                }\n', '\n', '                orderIndex = SafeMath.add(orderIndex, 1);\n', '                // If this is the last order for this token\n', '                if(orderIndex == ordersLength || orders.tokenForOrder[SafeMath.sub(orderIndex, 1)] != orders.tokenForOrder[orderIndex]) {\n', '                    break;\n', '                }\n', '            }\n', '\n', '            uint256 amountGiven = SafeMath.sub(tokens.amountToGive[tokenIndex], amountRemaining);\n', '\n', '            require(orderWasValid(amountObtained, amountGiven, tokens.amountToObtain[tokenIndex], tokens.amountToGive[tokenIndex]));\n', '\n', '            if(tokens.buyOrSell[tokenIndex] == BUY) {\n', '                // Take away spent ether from refund balance\n', '                etherBalance = SafeMath.sub(etherBalance, amountGiven);\n', '                // Transfer back tokens acquired\n', '                if(amountObtained > 0) {\n', '                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountObtained));\n', '                }\n', '            } else {\n', '                // Add ether to refund balance\n', '                etherBalance = SafeMath.add(etherBalance, amountObtained);\n', '                // Transfer back un-sold tokens\n', '                if(amountRemaining > 0) {\n', '                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountRemaining));\n', '                }\n', '            }\n', '        }\n', '\n', '        // Send back acquired/unspent ether - throw on failure\n', '        if(etherBalance > 0) {\n', '            msg.sender.transfer(etherBalance);\n', '        }\n', '    }\n', '\n', '    /// @dev Iterates through a list of token orders, transfer the SELL orders to this contract & calculates if we have the ether needed\n', '    /// @param tokens Struct containing the arrays of token orders\n', '    function transferTokens(Tokens tokens) internal {\n', '        uint256 expectedEtherAvailable = msg.value;\n', '        uint256 totalEtherNeeded = 0;\n', '\n', '        for(uint256 i = 0; i < tokens.tokenAddresses.length; i++) {\n', '            if(tokens.buyOrSell[i] == BUY) {\n', '                totalEtherNeeded = SafeMath.add(totalEtherNeeded, tokens.amountToGive[i]);\n', '            } else {\n', '                expectedEtherAvailable = SafeMath.add(expectedEtherAvailable, tokens.amountToObtain[i]);\n', '                require(TokenTransferProxy(tokenTransferProxy).transferFrom(\n', '                    tokens.tokenAddresses[i],\n', '                    msg.sender,\n', '                    this,\n', '                    tokens.amountToGive[i]\n', '                ));\n', '            }\n', '        }\n', '\n', '        // Make sure we have will have enough ETH after SELLs to cover our BUYs\n', '        require(expectedEtherAvailable >= totalEtherNeeded);\n', '    }\n', '\n', '    /// @dev Performs a single trade via the requested exchange handler\n', '    /// @param buyOrSell Boolean value stating whether this is a buy or sell order\n', '    /// @param initialRemaining The remaining value we have left to trade\n', '    /// @param totalObtained The total amount we have obtained so far\n', '    /// @param orders Struct containing all DEX orders\n', '    /// @param index Value indicating the index of the specific DEX order we wish to execute\n', '    /// @return Remaining value left after trade\n', '    /// @return Total value obtained after trade\n', '    function performTrade(bool buyOrSell, uint256 initialRemaining, uint256 totalObtained, DEXOrders orders, uint256 index)\n', '        internal returns (uint256, uint256) {\n', '        uint256 obtained = 0;\n', '        uint256 remaining = initialRemaining;\n', '\n', '        require(orders.exchangeFees[index] < MAX_EXCHANGE_FEE_PERCENTAGE);\n', '\n', '        uint256 amountToFill = getAmountToFill(remaining, orders, index);\n', '\n', '        if(amountToFill > 0) {\n', '            remaining = SafeMath.sub(remaining, amountToFill);\n', '\n', '            if(buyOrSell == BUY) {\n', '                obtained = ExchangeHandler(orders.exchanges[index]).performBuy.value(amountToFill)(\n', '                    orders.orderAddresses[index],\n', '                    orders.orderValues[index],\n', '                    orders.exchangeFees[index],\n', '                    amountToFill,\n', '                    orders.v[index],\n', '                    orders.r[index],\n', '                    orders.s[index]\n', '                );\n', '            } else {\n', '                require(Token(orders.tokenForOrder[index]).transfer(\n', '                    orders.exchanges[index],\n', '                    amountToFill\n', '                ));\n', '                obtained = ExchangeHandler(orders.exchanges[index]).performSell(\n', '                    orders.orderAddresses[index],\n', '                    orders.orderValues[index],\n', '                    orders.exchangeFees[index],\n', '                    amountToFill,\n', '                    orders.v[index],\n', '                    orders.r[index],\n', '                    orders.s[index]\n', '                );\n', '            }\n', '        }\n', '\n', '        return (obtained == 0 ? initialRemaining: remaining, SafeMath.add(totalObtained, obtained));\n', '    }\n', '\n', '    /// @dev Get the amount of this order we are able to fill\n', '    /// @param remaining Amount we have left to spend\n', '    /// @param orders Struct containing all DEX orders\n', '    /// @param index Value indicating the index of the specific DEX order we wish to execute\n', '    /// @return Minimum of the amount we have left to spend and the available amount at the exchange\n', '    function getAmountToFill(uint256 remaining, DEXOrders orders, uint256 index) internal returns (uint256) {\n', '\n', '        uint256 availableAmount = ExchangeHandler(orders.exchanges[index]).getAvailableAmount(\n', '            orders.orderAddresses[index],\n', '            orders.orderValues[index],\n', '            orders.exchangeFees[index],\n', '            orders.v[index],\n', '            orders.r[index],\n', '            orders.s[index]\n', '        );\n', '\n', '        return Math.min256(remaining, availableAmount);\n', '    }\n', '\n', '    /// @dev Checks whether a given order was valid\n', '    /// @param amountObtained Amount of the order which was obtained\n', '    /// @param amountGiven Amount given in return for amountObtained\n', '    /// @param amountToObtain Amount we intended to obtain\n', '    /// @param amountToGive Amount we intended to give in return for amountToObtain\n', '    /// @return Boolean value indicating whether this order was valid\n', '    function orderWasValid(uint256 amountObtained, uint256 amountGiven, uint256 amountToObtain, uint256 amountToGive) internal pure returns (bool) {\n', '\n', '        if(amountObtained > 0 && amountGiven > 0) {\n', '            // NOTE - Check the edge cases here\n', '            if(amountObtained > amountGiven) {\n', '                return SafeMath.div(amountToObtain, amountToGive) <= SafeMath.div(amountObtained, amountGiven);\n', '            } else {\n', '                return SafeMath.div(amountToGive, amountToObtain) >= SafeMath.div(amountGiven, amountObtained);\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function() public payable {\n', '        // Check in here that the sender is a contract! (to stop accidents)\n', '        uint256 size;\n', '        address sender = msg.sender;\n', '        assembly {\n', '            size := extcodesize(sender)\n', '        }\n', '        require(size > 0);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        emit LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        emit LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return Token(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'interface ExchangeHandler {\n', '\n', '    /// @dev Get the available amount left to fill for an order\n', '    /// @param orderAddresses Array of address values needed for this DEX order\n', '    /// @param orderValues Array of uint values needed for this DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Available amount left to fill for this order\n', '    function getAvailableAmount(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '\n', '    /// @dev Perform a buy order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable returns (uint256);\n', '\n', '    /// @dev Perform a sell order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '/// @title The primary contract for Totle Inc\n', 'contract TotlePrimary is Ownable {\n', '    // Constants\n', '    string public constant CONTRACT_VERSION = "0";\n', '    uint256 public constant MAX_EXCHANGE_FEE_PERCENTAGE = 0.01 * 10**18; // 1%\n', '    bool constant BUY = false;\n', '    bool constant SELL = true;\n', '\n', '    // State variables\n', '    mapping(address => bool) public handlerWhitelist;\n', '    address tokenTransferProxy;\n', '\n', '    // Structs\n', '    struct Tokens {\n', '        address[] tokenAddresses;\n', '        bool[]    buyOrSell;\n', '        uint256[] amountToObtain;\n', '        uint256[] amountToGive;\n', '    }\n', '\n', '    struct DEXOrders {\n', '        address[] tokenForOrder;\n', '        address[] exchanges;\n', '        address[8][] orderAddresses;\n', '        uint256[6][] orderValues;\n', '        uint256[] exchangeFees;\n', '        uint8[] v;\n', '        bytes32[] r;\n', '        bytes32[] s;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    /// @param proxy Address of the TokenTransferProxy\n', '    constructor(address proxy) public {\n', '        tokenTransferProxy = proxy;\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    /// @dev Set an exchange handler address to true/false\n', '    /// @notice - onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param handler Address of the exchange handler which permission needs changing\n', '    /// @param allowed Boolean value to set whether an exchange handler is allowed/denied\n', '    function setHandler(address handler, bool allowed) public onlyOwner {\n', '        handlerWhitelist[handler] = allowed;\n', '    }\n', '\n', '    /// @dev Synchronously executes an array of orders\n', '    /// @notice The first four parameters relate to Token orders, the last eight relate to DEX orders\n', '    /// @param tokenAddresses Array of addresses of ERC20 Token contracts for each Token order\n', '    /// @param buyOrSell Array indicating whether each Token order is a buy or sell\n', '    /// @param amountToObtain Array indicating the amount (in ether or tokens) to obtain in the order\n', '    /// @param amountToGive Array indicating the amount (in ether or tokens) to give in the order\n', '    /// @param tokenForOrder Array of addresses of ERC20 Token contracts for each DEX order\n', '    /// @param exchanges Array of addresses of exchange handler contracts\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFees Array indicating the fee for each DEX order (percentage of fill amount as decimal * 10**18)\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    function executeOrders(\n', '        // Tokens\n', '        address[] tokenAddresses,\n', '        bool[]    buyOrSell,\n', '        uint256[] amountToObtain,\n', '        uint256[] amountToGive,\n', '        // DEX Orders\n', '        address[] tokenForOrder,\n', '        address[] exchanges,\n', '        address[8][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256[] exchangeFees,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s\n', '    ) public payable {\n', '\n', '        require(\n', '            tokenAddresses.length == buyOrSell.length &&\n', '            buyOrSell.length      == amountToObtain.length &&\n', '            amountToObtain.length == amountToGive.length\n', '        );\n', '\n', '        require(\n', '            tokenForOrder.length  == exchanges.length &&\n', '            exchanges.length      == orderAddresses.length &&\n', '            orderAddresses.length == orderValues.length &&\n', '            orderValues.length    == exchangeFees.length &&\n', '            exchangeFees.length   == v.length &&\n', '            v.length              == r.length &&\n', '            r.length              == s.length\n', '        );\n', '\n', '        // Wrapping order in structs to reduce local variable count\n', '        internalOrderExecution(\n', '            Tokens(\n', '                tokenAddresses,\n', '                buyOrSell,\n', '                amountToObtain,\n', '                amountToGive\n', '            ),\n', '            DEXOrders(\n', '                tokenForOrder,\n', '                exchanges,\n', '                orderAddresses,\n', '                orderValues,\n', '                exchangeFees,\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        );\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '    /// @dev Synchronously executes an array of orders\n', '    /// @notice The orders in this function have been wrapped in structs to reduce the local variable count\n', '    /// @param tokens Struct containing the arrays of token orders\n', '    /// @param orders Struct containing the arrays of DEX orders\n', '    function internalOrderExecution(Tokens tokens, DEXOrders orders) internal {\n', '        transferTokens(tokens);\n', '\n', '        uint256 tokensLength = tokens.tokenAddresses.length;\n', '        uint256 ordersLength = orders.tokenForOrder.length;\n', '        uint256 etherBalance = msg.value;\n', '        uint256 orderIndex = 0;\n', '\n', '        for(uint256 tokenIndex = 0; tokenIndex < tokensLength; tokenIndex++) {\n', '            // NOTE - check for repetitions in the token list?\n', '\n', '            uint256 amountRemaining = tokens.amountToGive[tokenIndex];\n', '            uint256 amountObtained = 0;\n', '\n', '            while(orderIndex < ordersLength) {\n', '                require(tokens.tokenAddresses[tokenIndex] == orders.tokenForOrder[orderIndex]);\n', '                require(handlerWhitelist[orders.exchanges[orderIndex]]);\n', '\n', '                if(amountRemaining > 0) {\n', '                    if(tokens.buyOrSell[tokenIndex] == BUY) {\n', '                        require(etherBalance >= amountRemaining);\n', '                    }\n', '                    (amountRemaining, amountObtained) = performTrade(\n', '                        tokens.buyOrSell[tokenIndex],\n', '                        amountRemaining,\n', '                        amountObtained,\n', '                        orders, // NOTE - unable to send pointer to order values individually, as run out of stack space!\n', '                        orderIndex\n', '                        );\n', '                }\n', '\n', '                orderIndex = SafeMath.add(orderIndex, 1);\n', '                // If this is the last order for this token\n', '                if(orderIndex == ordersLength || orders.tokenForOrder[SafeMath.sub(orderIndex, 1)] != orders.tokenForOrder[orderIndex]) {\n', '                    break;\n', '                }\n', '            }\n', '\n', '            uint256 amountGiven = SafeMath.sub(tokens.amountToGive[tokenIndex], amountRemaining);\n', '\n', '            require(orderWasValid(amountObtained, amountGiven, tokens.amountToObtain[tokenIndex], tokens.amountToGive[tokenIndex]));\n', '\n', '            if(tokens.buyOrSell[tokenIndex] == BUY) {\n', '                // Take away spent ether from refund balance\n', '                etherBalance = SafeMath.sub(etherBalance, amountGiven);\n', '                // Transfer back tokens acquired\n', '                if(amountObtained > 0) {\n', '                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountObtained));\n', '                }\n', '            } else {\n', '                // Add ether to refund balance\n', '                etherBalance = SafeMath.add(etherBalance, amountObtained);\n', '                // Transfer back un-sold tokens\n', '                if(amountRemaining > 0) {\n', '                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountRemaining));\n', '                }\n', '            }\n', '        }\n', '\n', '        // Send back acquired/unspent ether - throw on failure\n', '        if(etherBalance > 0) {\n', '            msg.sender.transfer(etherBalance);\n', '        }\n', '    }\n', '\n', '    /// @dev Iterates through a list of token orders, transfer the SELL orders to this contract & calculates if we have the ether needed\n', '    /// @param tokens Struct containing the arrays of token orders\n', '    function transferTokens(Tokens tokens) internal {\n', '        uint256 expectedEtherAvailable = msg.value;\n', '        uint256 totalEtherNeeded = 0;\n', '\n', '        for(uint256 i = 0; i < tokens.tokenAddresses.length; i++) {\n', '            if(tokens.buyOrSell[i] == BUY) {\n', '                totalEtherNeeded = SafeMath.add(totalEtherNeeded, tokens.amountToGive[i]);\n', '            } else {\n', '                expectedEtherAvailable = SafeMath.add(expectedEtherAvailable, tokens.amountToObtain[i]);\n', '                require(TokenTransferProxy(tokenTransferProxy).transferFrom(\n', '                    tokens.tokenAddresses[i],\n', '                    msg.sender,\n', '                    this,\n', '                    tokens.amountToGive[i]\n', '                ));\n', '            }\n', '        }\n', '\n', '        // Make sure we have will have enough ETH after SELLs to cover our BUYs\n', '        require(expectedEtherAvailable >= totalEtherNeeded);\n', '    }\n', '\n', '    /// @dev Performs a single trade via the requested exchange handler\n', '    /// @param buyOrSell Boolean value stating whether this is a buy or sell order\n', '    /// @param initialRemaining The remaining value we have left to trade\n', '    /// @param totalObtained The total amount we have obtained so far\n', '    /// @param orders Struct containing all DEX orders\n', '    /// @param index Value indicating the index of the specific DEX order we wish to execute\n', '    /// @return Remaining value left after trade\n', '    /// @return Total value obtained after trade\n', '    function performTrade(bool buyOrSell, uint256 initialRemaining, uint256 totalObtained, DEXOrders orders, uint256 index)\n', '        internal returns (uint256, uint256) {\n', '        uint256 obtained = 0;\n', '        uint256 remaining = initialRemaining;\n', '\n', '        require(orders.exchangeFees[index] < MAX_EXCHANGE_FEE_PERCENTAGE);\n', '\n', '        uint256 amountToFill = getAmountToFill(remaining, orders, index);\n', '\n', '        if(amountToFill > 0) {\n', '            remaining = SafeMath.sub(remaining, amountToFill);\n', '\n', '            if(buyOrSell == BUY) {\n', '                obtained = ExchangeHandler(orders.exchanges[index]).performBuy.value(amountToFill)(\n', '                    orders.orderAddresses[index],\n', '                    orders.orderValues[index],\n', '                    orders.exchangeFees[index],\n', '                    amountToFill,\n', '                    orders.v[index],\n', '                    orders.r[index],\n', '                    orders.s[index]\n', '                );\n', '            } else {\n', '                require(Token(orders.tokenForOrder[index]).transfer(\n', '                    orders.exchanges[index],\n', '                    amountToFill\n', '                ));\n', '                obtained = ExchangeHandler(orders.exchanges[index]).performSell(\n', '                    orders.orderAddresses[index],\n', '                    orders.orderValues[index],\n', '                    orders.exchangeFees[index],\n', '                    amountToFill,\n', '                    orders.v[index],\n', '                    orders.r[index],\n', '                    orders.s[index]\n', '                );\n', '            }\n', '        }\n', '\n', '        return (obtained == 0 ? initialRemaining: remaining, SafeMath.add(totalObtained, obtained));\n', '    }\n', '\n', '    /// @dev Get the amount of this order we are able to fill\n', '    /// @param remaining Amount we have left to spend\n', '    /// @param orders Struct containing all DEX orders\n', '    /// @param index Value indicating the index of the specific DEX order we wish to execute\n', '    /// @return Minimum of the amount we have left to spend and the available amount at the exchange\n', '    function getAmountToFill(uint256 remaining, DEXOrders orders, uint256 index) internal returns (uint256) {\n', '\n', '        uint256 availableAmount = ExchangeHandler(orders.exchanges[index]).getAvailableAmount(\n', '            orders.orderAddresses[index],\n', '            orders.orderValues[index],\n', '            orders.exchangeFees[index],\n', '            orders.v[index],\n', '            orders.r[index],\n', '            orders.s[index]\n', '        );\n', '\n', '        return Math.min256(remaining, availableAmount);\n', '    }\n', '\n', '    /// @dev Checks whether a given order was valid\n', '    /// @param amountObtained Amount of the order which was obtained\n', '    /// @param amountGiven Amount given in return for amountObtained\n', '    /// @param amountToObtain Amount we intended to obtain\n', '    /// @param amountToGive Amount we intended to give in return for amountToObtain\n', '    /// @return Boolean value indicating whether this order was valid\n', '    function orderWasValid(uint256 amountObtained, uint256 amountGiven, uint256 amountToObtain, uint256 amountToGive) internal pure returns (bool) {\n', '\n', '        if(amountObtained > 0 && amountGiven > 0) {\n', '            // NOTE - Check the edge cases here\n', '            if(amountObtained > amountGiven) {\n', '                return SafeMath.div(amountToObtain, amountToGive) <= SafeMath.div(amountObtained, amountGiven);\n', '            } else {\n', '                return SafeMath.div(amountToGive, amountToObtain) >= SafeMath.div(amountGiven, amountObtained);\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function() public payable {\n', '        // Check in here that the sender is a contract! (to stop accidents)\n', '        uint256 size;\n', '        address sender = msg.sender;\n', '        assembly {\n', '            size := extcodesize(sender)\n', '        }\n', '        require(size > 0);\n', '    }\n', '}']
