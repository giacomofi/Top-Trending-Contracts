['pragma solidity ^0.4.18;\n', '\n', 'contract usingOwnership {\n', '  address public contract_owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == contract_owner);\n', '    _;\n', '  }\n', '\n', '  function usingOwnership() internal {\n', '    contract_owner = msg.sender;\n', '  }\n', '\n', '  function Withdraw(uint _amount) onlyOwner public {\n', '    if (_amount > this.balance)\n', '      _amount = this.balance;\n', '    contract_owner.transfer(_amount);\n', '  }\n', '\n', '  function TransferOwnership(address _new_owner) onlyOwner public {\n', '    require(_new_owner != address(0));\n', '    contract_owner = _new_owner;\n', '  }\n', '}\n', '\n', 'contract usingCanvasBoundaries {\n', '  uint private g_block;\n', '  uint private max_max_index;\n', '  uint private max_block_number;\n', '  uint[] private halving;\n', '   \n', '  function usingCanvasBoundaries() internal {\n', '    g_block = block.number;\n', '    max_max_index = 4198401;\n', '    max_block_number = g_block + 3330049;\n', '    halving = [g_block + 16384, g_block + 81920, g_block + 770048];\n', '  }\n', '\n', '  function max_index() internal view returns(uint m_index) {\n', '    if (block.number > max_block_number)\n', '      return max_max_index;\n', '    uint delta = block.number - g_block;\n', '    return delta +\n', '    ((block.number <= halving[0]) ? delta : halving[0] - g_block) +\n', '    ((block.number <= halving[1]) ? delta : halving[1] - g_block) +\n', '    ((block.number <= halving[2]) ? delta : halving[2] - g_block);\n', '  }\n', '\n', '  function HalvingInfo() public view returns(uint genesis_block, uint[] halving_array) {\n', '    return (g_block, halving);\n', '  }\n', '}\n', '\n', 'contract Etherpixels is usingOwnership, usingCanvasBoundaries {\n', '  uint private starting_price = 5000000000000; /* 5000 gwei */\n', '\n', '  /* packed to 32 bytes */\n', '  struct Pixel {\n', '    uint96 price;\n', '    address owner;\n', '  }\n', '  \n', '  mapping(uint => Pixel) private pixels;\n', '\n', '  event PixelPainted(uint i, address new_owner, address old_owner, uint price, bytes3 new_color);\n', '  event PixelUnavailable(uint i, address new_owner, uint price, bytes3 new_color);\n', '  \n', '  function Paint(uint _index, bytes3 _color) public payable {\n', '    require(_index <= max_index());\n', '    paint_pixel(_index, _color, msg.value);\n', '  }\n', '\n', '  function BatchPaint(uint8 _batch_size, uint[] _index, bytes3[] _color, uint[] _paid) public payable {\n', '    uint remaining = msg.value;\n', '    uint m_i = max_index();\n', '    for(uint8 i = 0; i < _batch_size; i++) {\n', '      require(remaining >= _paid[i] && _index[i] <= m_i);\n', '      paint_pixel(_index[i], _color[i], _paid[i]);\n', '      remaining -= _paid[i];\n', '    }\n', '  }\n', '\n', '  function StartingPrice() public view returns(uint price) {\n', '    return starting_price;\n', '  }\n', '\n', '  function LowerStartingPrice(uint _new_starting_price) onlyOwner public {\n', '    require(_new_starting_price < starting_price);\n', '    starting_price = _new_starting_price;\n', '  }\n', '  \n', '  function paint_pixel(uint _index, bytes3 _color, uint _paid) private {\n', '    Pixel storage p = pixels[_index];\n', '    if (msg.sender == p.owner) {\n', '      PixelPainted(_index, msg.sender, msg.sender, p.price, _color);\n', '    }\n', '    else {\n', '      uint current_price = p.price == 0 ? starting_price : uint(p.price);\n', '      if (_paid < current_price * 11 / 10)\n', '        PixelUnavailable(_index, msg.sender, current_price, _color);\n', '      else {\n', '        if (_paid > current_price * 2)\n', '          _paid = current_price * 2;\n', '        p.price = uint96(_paid);\n', '        require(p.price == _paid); /* casting guard */ \n', '        address old_owner = p.owner;\n', '        p.owner = msg.sender;\n', '        PixelPainted(_index, msg.sender, old_owner, p.price, _color);\n', '        if (old_owner != address(0))\n', '          old_owner.send(_paid * 98 / 100); /* not using transfer to avoid old_owner locking pixel by buying it from a contract that reverts when receiving funds */\n', '      }\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract usingOwnership {\n', '  address public contract_owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == contract_owner);\n', '    _;\n', '  }\n', '\n', '  function usingOwnership() internal {\n', '    contract_owner = msg.sender;\n', '  }\n', '\n', '  function Withdraw(uint _amount) onlyOwner public {\n', '    if (_amount > this.balance)\n', '      _amount = this.balance;\n', '    contract_owner.transfer(_amount);\n', '  }\n', '\n', '  function TransferOwnership(address _new_owner) onlyOwner public {\n', '    require(_new_owner != address(0));\n', '    contract_owner = _new_owner;\n', '  }\n', '}\n', '\n', 'contract usingCanvasBoundaries {\n', '  uint private g_block;\n', '  uint private max_max_index;\n', '  uint private max_block_number;\n', '  uint[] private halving;\n', '   \n', '  function usingCanvasBoundaries() internal {\n', '    g_block = block.number;\n', '    max_max_index = 4198401;\n', '    max_block_number = g_block + 3330049;\n', '    halving = [g_block + 16384, g_block + 81920, g_block + 770048];\n', '  }\n', '\n', '  function max_index() internal view returns(uint m_index) {\n', '    if (block.number > max_block_number)\n', '      return max_max_index;\n', '    uint delta = block.number - g_block;\n', '    return delta +\n', '    ((block.number <= halving[0]) ? delta : halving[0] - g_block) +\n', '    ((block.number <= halving[1]) ? delta : halving[1] - g_block) +\n', '    ((block.number <= halving[2]) ? delta : halving[2] - g_block);\n', '  }\n', '\n', '  function HalvingInfo() public view returns(uint genesis_block, uint[] halving_array) {\n', '    return (g_block, halving);\n', '  }\n', '}\n', '\n', 'contract Etherpixels is usingOwnership, usingCanvasBoundaries {\n', '  uint private starting_price = 5000000000000; /* 5000 gwei */\n', '\n', '  /* packed to 32 bytes */\n', '  struct Pixel {\n', '    uint96 price;\n', '    address owner;\n', '  }\n', '  \n', '  mapping(uint => Pixel) private pixels;\n', '\n', '  event PixelPainted(uint i, address new_owner, address old_owner, uint price, bytes3 new_color);\n', '  event PixelUnavailable(uint i, address new_owner, uint price, bytes3 new_color);\n', '  \n', '  function Paint(uint _index, bytes3 _color) public payable {\n', '    require(_index <= max_index());\n', '    paint_pixel(_index, _color, msg.value);\n', '  }\n', '\n', '  function BatchPaint(uint8 _batch_size, uint[] _index, bytes3[] _color, uint[] _paid) public payable {\n', '    uint remaining = msg.value;\n', '    uint m_i = max_index();\n', '    for(uint8 i = 0; i < _batch_size; i++) {\n', '      require(remaining >= _paid[i] && _index[i] <= m_i);\n', '      paint_pixel(_index[i], _color[i], _paid[i]);\n', '      remaining -= _paid[i];\n', '    }\n', '  }\n', '\n', '  function StartingPrice() public view returns(uint price) {\n', '    return starting_price;\n', '  }\n', '\n', '  function LowerStartingPrice(uint _new_starting_price) onlyOwner public {\n', '    require(_new_starting_price < starting_price);\n', '    starting_price = _new_starting_price;\n', '  }\n', '  \n', '  function paint_pixel(uint _index, bytes3 _color, uint _paid) private {\n', '    Pixel storage p = pixels[_index];\n', '    if (msg.sender == p.owner) {\n', '      PixelPainted(_index, msg.sender, msg.sender, p.price, _color);\n', '    }\n', '    else {\n', '      uint current_price = p.price == 0 ? starting_price : uint(p.price);\n', '      if (_paid < current_price * 11 / 10)\n', '        PixelUnavailable(_index, msg.sender, current_price, _color);\n', '      else {\n', '        if (_paid > current_price * 2)\n', '          _paid = current_price * 2;\n', '        p.price = uint96(_paid);\n', '        require(p.price == _paid); /* casting guard */ \n', '        address old_owner = p.owner;\n', '        p.owner = msg.sender;\n', '        PixelPainted(_index, msg.sender, old_owner, p.price, _color);\n', '        if (old_owner != address(0))\n', '          old_owner.send(_paid * 98 / 100); /* not using transfer to avoid old_owner locking pixel by buying it from a contract that reverts when receiving funds */\n', '      }\n', '    }\n', '  }\n', '}']
