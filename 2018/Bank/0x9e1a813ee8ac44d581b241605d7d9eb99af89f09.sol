['pragma solidity ^0.4.19;\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() public constant returns (uint256 totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract GBT is ERC20Interface {\n', '    uint256 public expirationBlock;\n', '    function isActive(address _owner) public returns (bool activated);\n', '}\n', '\n', '\n', 'contract GBIT is SafeMath {\n', '    address public admin = 0xb772725c0e453aF4c93fcD00A4cF005C73889126; //the admin address\n', '    address public feeAccount = 0xe04F320bCc0e8796e2e6092B3796C722a1220Bf5; //the account that will receive fees\n', '    address public gbtAddress = 0xe04F320bCc0e8796e2e6092B3796C722a1220Bf5;\n', '\n', '    uint256 public makeFee = 0; //percentage times (1 ether)\n', '    uint256 public takeFee = 1; //percentage times (1 ether)\n', '    uint256 public lastFreeBlock = 500000000;\n', '\n', '    mapping (bytes32 => uint256) public sellOrderBalances; //a hash of available order balances holds a number of tokens\n', '    mapping (bytes32 => uint256) public buyOrderBalances; //a hash of available order balances. holds a number of eth\n', '\n', '    event MakeBuyOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, address indexed buyer);\n', '\n', '    event MakeSellOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, address indexed seller);\n', '\n', '    event CancelBuyOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, address indexed buyer);\n', '\n', '    event CancelSellOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, address indexed seller);\n', '\n', '    event TakeBuyOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, uint256 totalTransactionTokens, address indexed buyer, address indexed seller);\n', '\n', '    event TakeSellOrder(bytes32 orderHash, address indexed token, uint256 tokenAmount, uint256 weiAmount, uint256 totalTransactionWei, address indexed buyer, address indexed seller);\n', '\n', '    function() public {\n', '        revert();\n', '    }\n', '\n', '    function changeAdmin(address admin_) public {\n', '        require(msg.sender == admin);\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeGBTAddress(address gbtAddress_) public {\n', '        require(msg.sender == admin);\n', '        require(block.number > GBT(gbtAddress).expirationBlock());\n', '        gbtAddress = gbtAddress_;\n', '    }\n', '\n', '    function changeLastFreeBlock(uint256 _lastFreeBlock) public {\n', '        require(msg.sender == admin);\n', '        require(_lastFreeBlock > block.number + 100); //announce at least 100 blocks ahead\n', '        lastFreeBlock = _lastFreeBlock;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) public {\n', '        require(msg.sender == admin);\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeMakeFee(uint256 makeFee_) public {\n', '        require(msg.sender == admin);\n', '        require(makeFee_ < makeFee);\n', '        makeFee = makeFee_;\n', '    }\n', '\n', '    function changeTakeFee(uint256 takeFee_) public {\n', '        require(msg.sender == admin);\n', '        require(takeFee_ < takeFee);\n', '        takeFee = takeFee_;\n', '    }\n', '\n', '    function feeFromTotalCostForAccount(uint256 totalCost, uint256 feeAmount, address account) public constant returns (uint256) {\n', '        return feeFromTotalCost(totalCost, feeAmount);\n', '    }\n', '\n', '    function feeFromTotalCost(uint256 totalCost, uint256 feeAmount) public constant returns (uint256) {\n', '\n', '        uint256 cost = safeMul(totalCost, (1 ether)) / safeAdd((1 ether), feeAmount);\n', '\n', '        // Calculate ceil(cost).\n', '        uint256 remainder = safeMul(totalCost, (1 ether)) % safeAdd((1 ether), feeAmount);\n', '        if (remainder != 0) {\n', '            cost = safeAdd(cost, 1);\n', '        }\n', '\n', '        uint256 fee = safeSub(totalCost, cost);\n', '        return fee;\n', '    }\n', '\n', '    function calculateFeeForAccount(uint256 cost, uint256 feeAmount, address account) public constant returns (uint256) {\n', '        return calculateFee(cost, feeAmount);\n', '    }\n', '\n', '    function calculateFee(uint256 cost, uint256 feeAmount) public constant returns (uint256) {\n', '        uint256 fee = safeMul(cost, feeAmount) / (1 ether);\n', '        return fee;\n', '    }\n', '\n', '    // Makes an offer to trade tokenAmount of ERC20 token, token, for weiAmount of wei.\n', '    function makeSellOrder(address token, uint256 tokenAmount, uint256 weiAmount) public {\n', '        require(tokenAmount != 0);\n', '        require(weiAmount != 0);\n', '\n', '        bytes32 h = sha256(token, tokenAmount, weiAmount, msg.sender);\n', '\n', '\n', '        // Update balance.\n', '        sellOrderBalances[h] = safeAdd(sellOrderBalances[h], tokenAmount);\n', '\n', '        // Check allowance.  -- Done after updating balance bc it makes a call to an untrusted contract.\n', '        require(tokenAmount <= ERC20Interface(token).allowance(msg.sender, this));\n', '\n', '        // Grab the token.\n', '        if (!ERC20Interface(token).transferFrom(msg.sender, this, tokenAmount)) {\n', '            revert();\n', '        }\n', '\n', '\n', '        MakeSellOrder(h, token, tokenAmount, weiAmount, msg.sender);\n', '    }\n', '\n', '    // Makes an offer to trade msg.value wei for tokenAmount of token (an ERC20 token).\n', '    function makeBuyOrder(address token, uint256 tokenAmount) public payable {\n', '        require(tokenAmount != 0);\n', '        require(msg.value != 0);\n', '\n', '        uint256 fee = feeFromTotalCost(msg.value, makeFee);\n', '        uint256 valueNoFee = safeSub(msg.value, fee);\n', '        bytes32 h = sha256(token, tokenAmount, valueNoFee, msg.sender);\n', '\n', '        //put ether in the buyOrderBalances map\n', '        buyOrderBalances[h] = safeAdd(buyOrderBalances[h], msg.value);\n', '\n', '        // Notify all clients.\n', '        MakeBuyOrder(h, token, tokenAmount, valueNoFee, msg.sender);\n', '    }\n', '\n', '\n', '    // Cancels all previous offers by msg.sender to trade tokenAmount of tokens for weiAmount of wei.\n', '    function cancelAllSellOrders(address token, uint256 tokenAmount, uint256 weiAmount) public {\n', '        bytes32 h = sha256(token, tokenAmount, weiAmount, msg.sender);\n', '        uint256 remain = sellOrderBalances[h];\n', '        delete sellOrderBalances[h];\n', '\n', '        ERC20Interface(token).transfer(msg.sender, remain);\n', '\n', '        CancelSellOrder(h, token, tokenAmount, weiAmount, msg.sender);\n', '    }\n', '\n', '    // Cancels any previous offers to trade weiAmount of wei for tokenAmount of tokens. Refunds the wei to sender.\n', '    function cancelAllBuyOrders(address token, uint256 tokenAmount, uint256 weiAmount) public {\n', '        bytes32 h = sha256(token, tokenAmount, weiAmount, msg.sender);\n', '        uint256 remain = buyOrderBalances[h];\n', '        delete buyOrderBalances[h];\n', '\n', '        if (!msg.sender.send(remain)) {\n', '            revert();\n', '        }\n', '\n', '        CancelBuyOrder(h, token, tokenAmount, weiAmount, msg.sender);\n', '    }\n', '\n', '    // Take some (or all) of the ether (minus fees) in the buyOrderBalances hash in exchange for totalTokens tokens.\n', '    function takeBuyOrder(address token, uint256 tokenAmount, uint256 weiAmount, uint256 totalTokens, address buyer) public {\n', '        require(tokenAmount != 0);\n', '        require(weiAmount != 0);\n', '        require(totalTokens != 0);\n', '\n', '        bytes32 h = sha256(token, tokenAmount, weiAmount, buyer);\n', '\n', '        // How many wei for the amount of tokens being sold?\n', '        uint256 transactionWeiAmountNoFee = safeMul(totalTokens, weiAmount) / tokenAmount;\n', '\n', '        // Does the buyer (maker) have enough money in the contract?\n', '        uint256 unvestedMakeFee = calculateFee(transactionWeiAmountNoFee, makeFee);\n', '        uint256 totalTransactionWeiAmount = safeAdd(transactionWeiAmountNoFee, unvestedMakeFee);\n', '        require(buyOrderBalances[h] >= totalTransactionWeiAmount);\n', '\n', '\n', '        // Calculate the actual vested fees.\n', '        uint256 currentTakeFee = calculateFeeForAccount(transactionWeiAmountNoFee, takeFee, msg.sender);\n', '        uint256 currentMakeFee = calculateFeeForAccount(transactionWeiAmountNoFee, makeFee, buyer);\n', '\n', '        // Proceed with transferring balances.\n', '\n', '        // Update our internal accounting.\n', '        buyOrderBalances[h] = safeSub(buyOrderBalances[h], totalTransactionWeiAmount);\n', '\n', '\n', '        // Did the seller send enough tokens?  -- This check is here bc it calls to an untrusted contract.\n', '        require(ERC20Interface(token).allowance(msg.sender, this) >= totalTokens);\n', '\n', '        // Send buyer their tokens and any fee refund.\n', '        if (currentMakeFee < unvestedMakeFee) {// the buyer got a fee discount. Send the refund.\n', '            uint256 refundAmount = safeSub(unvestedMakeFee, currentMakeFee);\n', '            if (!buyer.send(refundAmount)) {\n', '                revert();\n', '            }\n', '        }\n', '        if (!ERC20Interface(token).transferFrom(msg.sender, buyer, totalTokens)) {\n', '            revert();\n', '        }\n', '\n', '        // Grab our fee.\n', '        if (safeAdd(currentTakeFee, currentMakeFee) > 0) {\n', '            if (!feeAccount.send(safeAdd(currentTakeFee, currentMakeFee))) {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        // Send seller the proceeds.\n', '        if (!msg.sender.send(safeSub(transactionWeiAmountNoFee, currentTakeFee))) {\n', '            revert();\n', '        }\n', '\n', '        TakeBuyOrder(h, token, tokenAmount, weiAmount, totalTokens, buyer, msg.sender);\n', '    }\n', '\n', '\n', '    function takeSellOrder(address token, uint256 tokenAmount, uint256 weiAmount, address seller) public payable {\n', '\n', '        require(tokenAmount != 0);\n', '        require(weiAmount != 0);\n', '\n', '        bytes32 h = sha256(token, tokenAmount, weiAmount, seller);\n', '\n', '        // Check that the contract has enough token to satisfy this order.\n', '        uint256 currentTakeFee = feeFromTotalCostForAccount(msg.value, takeFee, msg.sender);\n', '        uint256 transactionWeiAmountNoFee = safeSub(msg.value, currentTakeFee);\n', '        uint256 totalTokens = safeMul(transactionWeiAmountNoFee, tokenAmount) / weiAmount;\n', '        require(sellOrderBalances[h] >= totalTokens);\n', '\n', '        // Calculate total vested fee.\n', '        uint256 currentMakeFee = calculateFeeForAccount(transactionWeiAmountNoFee, makeFee, seller);\n', '        uint256 totalFee = safeAdd(currentMakeFee, currentTakeFee);\n', '\n', '        uint256 makerProceedsAfterFee = safeSub(transactionWeiAmountNoFee, currentMakeFee);\n', '\n', '        // Transfer.\n', '\n', '        // Update internal accounting.\n', '        sellOrderBalances[h] = safeSub(sellOrderBalances[h], totalTokens);\n', '\n', '        // Send buyer the tokens.\n', '        if (!ERC20Interface(token).transfer(msg.sender, totalTokens)) {\n', '            revert();\n', '        }\n', '\n', '        // Take our fee.\n', '        if (totalFee > 0) {\n', '            if (!feeAccount.send(totalFee)) {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        // Send seller the proceeds.\n', '        if (!seller.send(makerProceedsAfterFee)) {\n', '            revert();\n', '        }\n', '\n', '        TakeSellOrder(h, token, tokenAmount, weiAmount, transactionWeiAmountNoFee, msg.sender, seller);\n', '    }\n', '}']