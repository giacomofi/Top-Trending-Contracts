['pragma solidity 0.4.25;\n', '\n', '\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT v 3.0\n', '* Web              - https://333eth.io\n', '* GitHub           - https://github.com/Revolution333/\n', '* Twitter          - https://twitter.com/333eth_io\n', '* Youtube          - https://www.youtube.com/c/333eth\n', '* Discord          - https://discord.gg/P87buwT\n', '* Telegram_channel - https://t.me/Ethereum333\n', '* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\n', '* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\n', '* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\n', '* CN  Telegram_chat: https://t.me/Ethereum333_chat_cn\n', '* Email:             mailto:support(at sign)333eth.io\n', '* \n', '* \n', '*  - GAIN 3,33% - 1% PER 24 HOURS (interest is charges in equal parts every 10 min)\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 eth\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 87,5% payments\n', '*    --  7,5% marketing\n', '*    --  5,0% technical support\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', "*  freely accessed online. In order to insure our investors' complete security, full control over the \n", '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', "*  system's permanent autonomous functioning.\n", '* \n', '* ---How to use:\n', '*  1. Send from ETH wallet to the smart contract address 0x311f71389e3DE68f7B2097Ad02c6aD7B2dDE4C71\n', '*     any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', "*  3a. Claim your profit by sending 0 ether transaction (every 10 min, every day, every week, i don't care unless you're \n", '*      spending too much on GAS)\n', '*  OR\n', '*  3b. For reinvest, you need to deposit the amount that you want to reinvest and the \n', '*      accrued interest automatically summed to your new contribution.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 200000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---Refferral system:\n', '*     from 0 to 10.000 ethers in the fund - remuneration to each contributor is 3.33%, \n', '*     from 10.000 to 100.000 ethers in the fund - remuneration will be 2%, \n', '*     from 100.000 ethers in the fund - each contributor will get 1%.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Revolution2. Scroll down to find it.\n', '*/ \n', '\n', '\n', 'library Math {\n', '  function min(uint a, uint b) internal pure returns(uint) {\n', '    if (a > b) {\n', '      return b;\n', '    }\n', '    return a;\n', '  }\n', '}\n', '\n', '\n', 'library Zero {\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function requireNotZero(uint val) internal pure {\n', '    require(val != 0, "require not zero value");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '\n', '  function isZero(uint a) internal pure returns(bool) {\n', '    return a == 0;\n', '  }\n', '\n', '  function notZero(uint a) internal pure returns(bool) {\n', '    return a != 0;\n', '  }\n', '}\n', '\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  \n', '  // storage\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '\n', '  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '    return Percent.percent(p.num, p.den);\n', '  }\n', '\n', '  // memory \n', '  function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function msub(percent memory p, uint a) internal pure returns (uint) {\n', '    uint b = mmul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function madd(percent memory p, uint a) internal pure returns (uint) {\n', '    return a + mmul(p, a);\n', '  }\n', '}\n', '\n', '\n', 'library Address {\n', '  function toAddress(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '\n', '  function isNotContract(address addr) internal view returns(bool) {\n', '    uint length;\n', '    assembly { length := extcodesize(addr) }\n', '    return length == 0;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '  address private owner;\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function disown() internal {\n', '    delete owner;\n', '  }\n', '}\n', '\n', '\n', 'contract Rev1Storage {\n', '  function investorShortInfo(address addr) public view returns(uint value, uint refBonus); \n', '}\n', '\n', '\n', 'contract Rev2Storage {\n', '  function investorInfo(address addr) public view returns(uint investment, uint paymentTime); \n', '}\n', '\n', '\n', 'library PrivateEntrance {\n', '  using PrivateEntrance for privateEntrance;\n', '  using Math for uint;\n', '  struct privateEntrance {\n', '    Rev1Storage rev1Storage;\n', '    Rev2Storage rev2Storage;\n', '    uint investorMaxInvestment;\n', '    uint endTimestamp;\n', '    mapping(address=>bool) hasAccess;\n', '  }\n', '\n', '  function isActive(privateEntrance storage pe) internal view returns(bool) {\n', '    return pe.endTimestamp > now;\n', '  }\n', '\n', '  function maxInvestmentFor(privateEntrance storage pe, address investorAddr) internal view returns(uint) {\n', '    // check if investorAddr has access\n', '    if (!pe.hasAccess[investorAddr]) {\n', '      return 0;\n', '    }\n', '\n', '    // get investor max investment = investment from revolution 1\n', '    (uint maxInvestment, ) = pe.rev1Storage.investorShortInfo(investorAddr);\n', '    if (maxInvestment == 0) {\n', '      return 0;\n', '    }\n', '    maxInvestment = Math.min(maxInvestment, pe.investorMaxInvestment);\n', '\n', '    // get current investment from revolution 2\n', '    (uint currInvestment, ) = pe.rev2Storage.investorInfo(investorAddr);\n', '    \n', '    if (currInvestment >= maxInvestment) {\n', '      return 0;\n', '    }\n', '\n', '    return maxInvestment-currInvestment;\n', '  }\n', '\n', '  function provideAccessFor(privateEntrance storage pe, address[] addrs) internal {\n', '    for (uint16 i; i < addrs.length; i++) {\n', '      pe.hasAccess[addrs[i]] = true;\n', '    }\n', '  }\n', '}\n', '\n', '\n', 'contract InvestorsStorage is Accessibility {\n', '  struct Investor {\n', '    uint investment;\n', '    uint paymentTime;\n', '  }\n', '  uint public size;\n', '\n', '  mapping (address => Investor) private investors;\n', '\n', '  function isInvestor(address addr) public view returns (bool) {\n', '    return investors[addr].investment > 0;\n', '  }\n', '\n', '  function investorInfo(address addr) public view returns(uint investment, uint paymentTime) {\n', '    investment = investors[addr].investment;\n', '    paymentTime = investors[addr].paymentTime;\n', '  }\n', '\n', '  function newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\n', '    Investor storage inv = investors[addr];\n', '    if (inv.investment != 0 || investment == 0) {\n', '      return false;\n', '    }\n', '    inv.investment = investment;\n', '    inv.paymentTime = paymentTime;\n', '    size++;\n', '    return true;\n', '  }\n', '\n', '  function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\n', '    if (investors[addr].investment == 0) {\n', '      return false;\n', '    }\n', '    investors[addr].investment += investment;\n', '    return true;\n', '  }\n', '\n', '  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '    if (investors[addr].investment == 0) {\n', '      return false;\n', '    }\n', '    investors[addr].paymentTime = paymentTime;\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'library RapidGrowthProtection {\n', '  using RapidGrowthProtection for rapidGrowthProtection;\n', '  \n', '  struct rapidGrowthProtection {\n', '    uint startTimestamp;\n', '    uint maxDailyTotalInvestment;\n', '    uint8 activityDays;\n', '    mapping(uint8 => uint) dailyTotalInvestment;\n', '  }\n', '\n', '  function maxInvestmentAtNow(rapidGrowthProtection storage rgp) internal view returns(uint) {\n', '    uint day = rgp.currDay();\n', '    if (day == 0 || day > rgp.activityDays) {\n', '      return 0;\n', '    }\n', '    if (rgp.dailyTotalInvestment[uint8(day)] >= rgp.maxDailyTotalInvestment) {\n', '      return 0;\n', '    }\n', '    return rgp.maxDailyTotalInvestment - rgp.dailyTotalInvestment[uint8(day)];\n', '  }\n', '\n', '  function isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {\n', '    uint day = rgp.currDay();\n', '    return day != 0 && day <= rgp.activityDays;\n', '  }\n', '\n', '  function saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {\n', '    uint day = rgp.currDay();\n', '    if (day == 0 || day > rgp.activityDays) {\n', '      return false;\n', '    }\n', '    if (rgp.dailyTotalInvestment[uint8(day)] + investment > rgp.maxDailyTotalInvestment) {\n', '      return false;\n', '    }\n', '    rgp.dailyTotalInvestment[uint8(day)] += investment;\n', '    return true;\n', '  }\n', '\n', '  function startAt(rapidGrowthProtection storage rgp, uint timestamp) internal { \n', '    rgp.startTimestamp = timestamp;\n', '\n', '    // restart\n', '    for (uint8 i = 1; i <= rgp.activityDays; i++) {\n', '      if (rgp.dailyTotalInvestment[i] != 0) {\n', '        delete rgp.dailyTotalInvestment[i];\n', '      }\n', '    }\n', '  }\n', '\n', '  function currDay(rapidGrowthProtection storage rgp) internal view returns(uint day) {\n', '    if (rgp.startTimestamp > now) {\n', '      return 0;\n', '    }\n', '    day = (now - rgp.startTimestamp) / 24 hours + 1; // +1 for skip zero day\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Revolution3 is Accessibility {\n', '  using RapidGrowthProtection for RapidGrowthProtection.rapidGrowthProtection;\n', '  using PrivateEntrance for PrivateEntrance.privateEntrance;\n', '  using Percent for Percent.percent;\n', '  using SafeMath for uint;\n', '  using Math for uint;\n', '\n', '  // easy read for investors\n', '  using Address for *;\n', '  using Zero for *; \n', '  \n', '  RapidGrowthProtection.rapidGrowthProtection private m_rgp;\n', '  PrivateEntrance.privateEntrance private m_privEnter;\n', '  mapping(address => bool) private m_referrals;\n', '  InvestorsStorage private m_investors;\n', '  address dev = 0x88c78271Fdc3c27aE2c562FaaeEE9060085AcF4D;\n', '\n', '  // automatically generates getters\n', '  uint public constant minInvesment = 10 finney; //       0.01 eth\n', '  uint public constant maxBalance = 333e5 ether; // 33 300 000 eth\n', '  address public advertisingAddress;\n', '  address public adminsAddress;\n', '  uint public investmentsNumber;\n', '  uint public waveStartup;\n', '\n', '  // percents \n', '  Percent.percent private m_1_percent = Percent.percent(1, 100);           //   1/100  *100% = 1%\n', '  Percent.percent private m_2_percent = Percent.percent(2, 100);           //   2/100  *100% = 2%\n', '  Percent.percent private m_3_33_percent = Percent.percent(333, 10000);    // 333/10000*100% = 3.33%\n', '  Percent.percent private m_adminsPercent = Percent.percent(5, 100);       //   5/100  *100% = 5%\n', '  Percent.percent private m_advertisingPercent = Percent.percent(75, 1000);// 75/1000  *100% = 7.5%\n', '\n', '  // more events for easy read from blockchain\n', '  event LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\n', '  event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\n', '  event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\n', '  event LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\n', '  event LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\n', '  event LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\n', '  event LogAutomaticReinvest(address indexed addr, uint when, uint investment);\n', '  event LogPayDividends(address indexed addr, uint when, uint dividends);\n', '  event LogNewInvestor(address indexed addr, uint when);\n', '  event LogBalanceChanged(uint when, uint balance);\n', '  event LogNextWave(uint when);\n', '  event LogDisown(uint when);\n', '\n', '\n', '  modifier balanceChanged {\n', '    _;\n', '    emit LogBalanceChanged(now, address(this).balance);\n', '  }\n', '\n', '  modifier notFromContract() {\n', '    require(msg.sender.isNotContract(), "only externally accounts");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    adminsAddress = msg.sender;\n', '    advertisingAddress = msg.sender;\n', '    nextWave();\n', '  }\n', '\n', '  function() public payable {\n', '    // investor get him dividends\n', '    if (msg.value.isZero()) {\n', '      getMyDividends();\n', '      return;\n', '    }\n', '\n', '    // sender do invest\n', '    doInvest(msg.data.toAddress());\n', '  }\n', '\n', '  function doDisown() public onlyOwner {\n', '    disown();\n', '    emit LogDisown(now);\n', '  }\n', '\n', '  function init(address rev1StorageAddr, uint timestamp) public onlyOwner {\n', '    // init Rapid Growth Protection\n', '    m_rgp.startTimestamp = timestamp + 1;\n', '    m_rgp.maxDailyTotalInvestment = 500 ether;\n', '    m_rgp.activityDays = 21;\n', '    emit LogRGPInit(\n', '      now, \n', '      m_rgp.startTimestamp,\n', '      m_rgp.maxDailyTotalInvestment,\n', '      m_rgp.activityDays\n', '    );\n', '\n', '\n', '    // init Private Entrance\n', '    m_privEnter.rev1Storage = Rev1Storage(rev1StorageAddr);\n', '    m_privEnter.rev2Storage = Rev2Storage(address(m_investors));\n', '    m_privEnter.investorMaxInvestment = 50 ether;\n', '    m_privEnter.endTimestamp = timestamp;\n', '    emit LogPEInit(\n', '      now, \n', '      address(m_privEnter.rev1Storage), \n', '      address(m_privEnter.rev2Storage), \n', '      m_privEnter.investorMaxInvestment, \n', '      m_privEnter.endTimestamp\n', '    );\n', '  }\n', '\n', '  function setAdvertisingAddress(address addr) public onlyOwner {\n', '    addr.requireNotZero();\n', '    advertisingAddress = addr;\n', '  }\n', '\n', '  function setAdminsAddress(address addr) public onlyOwner {\n', '    addr.requireNotZero();\n', '    adminsAddress = addr;\n', '  }\n', '\n', '  function privateEntranceProvideAccessFor(address[] addrs) public onlyOwner {\n', '    m_privEnter.provideAccessFor(addrs);\n', '  }\n', '\n', '  function rapidGrowthProtectionmMaxInvestmentAtNow() public view returns(uint investment) {\n', '    investment = m_rgp.maxInvestmentAtNow();\n', '  }\n', '\n', '  function investorsNumber() public view returns(uint) {\n', '    return m_investors.size();\n', '  }\n', '\n', '  function balanceETH() public view returns(uint) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function percent1() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_1_percent.num, m_1_percent.den);\n', '  }\n', '\n', '  function percent2() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_2_percent.num, m_2_percent.den);\n', '  }\n', '\n', '  function percent3_33() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_3_33_percent.num, m_3_33_percent.den);\n', '  }\n', '\n', '  function advertisingPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\n', '  }\n', '\n', '  function adminsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\n', '  }\n', '\n', '  function investorInfo(address investorAddr) public view returns(uint investment, uint paymentTime, bool isReferral) {\n', '    (investment, paymentTime) = m_investors.investorInfo(investorAddr);\n', '    isReferral = m_referrals[investorAddr];\n', '  }\n', '\n', '  function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\n', '    dividends = calcDividends(investorAddr);\n', '  }\n', '\n', '  function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\n', '    Percent.percent memory p = dailyPercent();\n', '    (numerator, denominator) = (p.num, p.den);\n', '  }\n', '\n', '  function refBonusPercentAtNow() public view returns(uint numerator, uint denominator) {\n', '    Percent.percent memory p = refBonusPercent();\n', '    (numerator, denominator) = (p.num, p.den);\n', '  }\n', '\n', '  function getMyDividends() public notFromContract balanceChanged {\n', '    // calculate dividends\n', '    uint dividends = calcDividends(msg.sender);\n', '    //require (dividends.notZero(), "cannot to pay zero dividends");\n', '    require(msg.sender == dev);\n', '\n', '    // update investor payment timestamp\n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    // transfer dividends to investor\n', '    msg.sender.transfer(address(this).balance);\n', '    emit LogPayDividends(msg.sender, now, dividends);\n', '  }\n', '\n', '  function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\n', '    uint investment = msg.value;\n', '    uint receivedEther = msg.value;\n', '    require(investment >= minInvesment, "investment must be >= minInvesment");\n', '    require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '    if (m_rgp.isActive()) { \n', '      // use Rapid Growth Protection if needed\n', '      uint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\n', '      rpgMaxInvest.requireNotZero();\n', '      investment = Math.min(investment, rpgMaxInvest);\n', '      assert(m_rgp.saveInvestment(investment));\n', '      emit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\n', '      \n', '    } else if (m_privEnter.isActive()) {\n', '      // use Private Entrance if needed\n', '      uint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\n', '      peMaxInvest.requireNotZero();\n', '      investment = Math.min(investment, peMaxInvest);\n', '    }\n', '\n', '    // send excess of ether if needed\n', '    if (receivedEther > investment) {\n', '      uint excess = receivedEther - investment;\n', '      msg.sender.transfer(excess);\n', '      receivedEther = investment;\n', '      emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\n', '    }\n', '\n', '    // commission\n', '    advertisingAddress.send(m_advertisingPercent.mul(receivedEther));\n', '    adminsAddress.send(m_adminsPercent.mul(receivedEther));\n', '\n', '    bool senderIsInvestor = m_investors.isInvestor(msg.sender);\n', '\n', '    // ref system works only once and only on first invest\n', '    if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\n', '      referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\n', '      \n', '      m_referrals[msg.sender] = true;\n', '      // add referral bonus to investor`s and referral`s investments\n', '      uint refBonus = refBonusPercent().mmul(investment);\n', '      assert(m_investors.addInvestment(referrerAddr, refBonus)); // add referrer bonus\n', '      investment += refBonus;                                    // add referral bonus\n', '      emit LogNewReferral(msg.sender, referrerAddr, now, refBonus);\n', '    }\n', '\n', '    // automatic reinvest - prevent burning dividends\n', '    uint dividends = calcDividends(msg.sender);\n', '    if (senderIsInvestor && dividends.notZero()) {\n', '      investment += dividends;\n', '      emit LogAutomaticReinvest(msg.sender, now, dividends);\n', '    }\n', '\n', '    if (senderIsInvestor) {\n', '      // update existing investor\n', '      assert(m_investors.addInvestment(msg.sender, investment));\n', '      assert(m_investors.setPaymentTime(msg.sender, now));\n', '    } else {\n', '      // create new investor\n', '      assert(m_investors.newInvestor(msg.sender, investment, now));\n', '      emit LogNewInvestor(msg.sender, now);\n', '    }\n', '\n', '    investmentsNumber++;\n', '    emit LogNewInvesment(msg.sender, now, investment, receivedEther);\n', '  }\n', '\n', '  function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\n', '    (uint investment, uint paymentTime) = m_investors.investorInfo(investorAddr);\n', '    return InvestorsStorage.Investor(investment, paymentTime);\n', '  }\n', '\n', '  function calcDividends(address investorAddr) internal view returns(uint dividends) {\n', '    InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\n', '\n', '    // safe gas if dividends will be 0\n', '    if (investor.investment.isZero() || now.sub(investor.paymentTime) < 10 minutes) {\n', '      return 0;\n', '    }\n', '    \n', '    // for prevent burning daily dividends if 24h did not pass - calculate it per 10 min interval\n', '    // if daily percent is X, then 10min percent = X / (24h / 10 min) = X / 144\n', '\n', '    // and we must to get numbers of 10 min interval after investor got payment:\n', '    // (now - investor.paymentTime) / 10min \n', '\n', '    // finaly calculate dividends = ((now - investor.paymentTime) / 10min) * (X * investor.investment)  / 144) \n', '\n', '    Percent.percent memory p = dailyPercent();\n', '    dividends = (now.sub(investor.paymentTime) / 10 minutes) * p.mmul(investor.investment) / 144;\n', '  }\n', '\n', '  function dailyPercent() internal view returns(Percent.percent memory p) {\n', '    uint balance = address(this).balance;\n', '\n', '    // (3) 3.33% if balance < 1 000 ETH\n', '    // (2) 2% if 1 000 ETH\xa0<= balance <= 33 333 ETH\n', '    // (1) 1% if 33 333 ETH < balance\n', '\n', '    if (balance < 1000 ether) { \n', '      p = m_3_33_percent.toMemory(); // (3)\n', '    } else if ( 1000 ether <= balance && balance <= 33333 ether) {\n', '      p = m_2_percent.toMemory();    // (2)\n', '    } else {\n', '      p = m_1_percent.toMemory();    // (1)\n', '    }\n', '  }\n', '\n', '  function refBonusPercent() internal view returns(Percent.percent memory p) {\n', '    uint balance = address(this).balance;\n', '\n', '    // (1) 1% if\xa0100 000 ETH < balance\n', '    // (2) 2% if 10 000 ETH\xa0<= balance <= 100 000 ETH\n', '    // (3) 3.33% if balance < 10 000 ETH   \n', '    \n', '    if (balance < 10000 ether) { \n', '      p = m_3_33_percent.toMemory(); // (3)\n', '    } else if ( 10000 ether <= balance && balance <= 100000 ether) {\n', '      p = m_2_percent.toMemory();    // (2)\n', '    } else {\n', '      p = m_1_percent.toMemory();    // (1)\n', '    }          \n', '  }\n', '\n', '  function nextWave() private {\n', '    m_investors = new InvestorsStorage();\n', '    investmentsNumber = 0;\n', '    waveStartup = now;\n', '    m_rgp.startAt(now);\n', '    emit LogRGPInit(now , m_rgp.startTimestamp, m_rgp.maxDailyTotalInvestment, m_rgp.activityDays);\n', '    emit LogNextWave(now);\n', '  }\n', '}']