['pragma solidity ^0.4.19;\n', '\n', '//ERC20 Token\n', 'contract Token {\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address _owner) public constant returns (uint);\n', '  function transfer(address _to, uint _value) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '  function approve(address _spender, uint _value) public returns (bool);\n', '  function allowance(address _owner, address _spender) public constant returns (uint);\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BitEyeExchange is SafeMath {\n', '  mapping (address => mapping (address => uint256)) public balances;\n', '  mapping (bytes32 => bool) public traded;\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  address public owner;\n', '  address public feeAccount;\n', '  mapping (address => bool) public signers;\n', '  mapping (address => uint256) public cancels;\n', '  mapping (bytes32 => bool) public withdraws;\n', '\n', '  uint256 public teamLocked = 300000000 * 1e18;\n', '  uint256 public teamClaimed = 0;\n', '  uint256 public totalForMining = 600000000 * 1e18;\n', '  uint256 public unmined = 600000000 * 1e18;\n', '  mapping (address => uint256) public mined;\n', '  address public BEY;\n', '  mapping (address => uint256) public miningRate;\n', '  bool public paused = false;\n', '  \n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '  event Trade(address baseToken, address quoteToken, uint256 volume, uint256 fund, uint256 nonce, address buyer, address seller);\n', '  event Cancel(address user, bytes32 orderHash, uint256 nonce);\n', '  event Claim(address user, uint256 amount);\n', '\n', '  function BitEyeExchange(address _feeAccount) public {\n', '    owner = msg.sender;\n', '    feeAccount = _feeAccount;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    if (_newOwner != address(0)) {\n', '      owner = _newOwner;\n', '    }\n', '  }\n', '\n', '  function setFeeAccount(address _newFeeAccount) public onlyOwner {\n', '    feeAccount = _newFeeAccount;\n', '  }\n', '\n', '  function addSigner(address _signer) public onlyOwner {\n', '    signers[_signer] = true;\n', '  }\n', '\n', '  function removeSigner(address _signer) public onlyOwner {\n', '    signers[_signer] = false;\n', '  }\n', '\n', '  function setBEY(address _addr) public onlyOwner {\n', '    BEY = _addr;\n', '  }\n', '\n', '  function setMiningRate(address _quoteToken, uint256 _rate) public onlyOwner {\n', '    miningRate[_quoteToken] = _rate;\n', '  }\n', '\n', '  function setPaused(bool _paused) public onlyOwner {\n', '    paused = _paused;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlySigner() {\n', '    require(signers[msg.sender]);\n', '    _; \n', '  }\n', '\n', '  modifier onlyNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  function() external {\n', '    revert();\n', '  }\n', '\n', '  function depositToken(address token, uint amount) public {\n', '    balances[token][msg.sender] = safeAdd(balances[token][msg.sender], amount);\n', '    require(Token(token).transferFrom(msg.sender, this, amount));\n', '    Deposit(token, msg.sender, amount, balances[token][msg.sender]);\n', '  }\n', '\n', '  function deposit() public payable {\n', '    balances[address(0)][msg.sender] = safeAdd(balances[address(0)][msg.sender], msg.value);\n', '    Deposit(address(0), msg.sender, msg.value, balances[address(0)][msg.sender]);\n', '  }\n', '\n', '  function withdraw(address token, uint amount, uint nonce, address _signer, uint8 v, bytes32 r, bytes32 s) public {\n', '    require(balances[token][msg.sender] >= amount);\n', '    require(signers[_signer]);\n', '    bytes32 hash = keccak256(this, msg.sender, token, amount, nonce);\n', '    require(isValidSignature(_signer, hash, v, r, s));\n', '    require(!withdraws[hash]);\n', '    withdraws[hash] = true;\n', '\n', '    balances[token][msg.sender] = safeSub(balances[token][msg.sender], amount);\n', '    if (token == address(0)) {\n', '      require(msg.sender.send(amount));\n', '    } else {\n', '      require(Token(token).transfer(msg.sender, amount));\n', '    }\n', '    Withdraw(token, msg.sender, amount, balances[token][msg.sender]);\n', '  }\n', '\n', '  function balanceOf(address token, address user) public view returns(uint) {\n', '    return balances[token][user];\n', '  }\n', '\n', '  function updateCancels(address user, uint256 nonce) public onlySigner {\n', '    require(nonce > cancels[user]);\n', '    cancels[user] = nonce;\n', '  }\n', '\n', '  function getMiningRate(address _quoteToken) public view returns(uint256) {\n', '    uint256 initialRate = miningRate[_quoteToken];\n', '    if (unmined > 500000000e18){\n', '      return initialRate;\n', '    } else if (unmined > 400000000e18 && unmined <= 500000000e18){\n', '      return initialRate * 9e17 / 1e18;\n', '    } else if (unmined > 300000000e18 && unmined <= 400000000e18){\n', '      return initialRate * 8e17 / 1e18;\n', '    } else if (unmined > 200000000e18 && unmined <= 300000000e18){\n', '      return initialRate * 7e17 / 1e18;\n', '    } else if (unmined > 100000000e18 && unmined <= 200000000e18){\n', '      return initialRate * 6e17 / 1e18;\n', '    } else if(unmined <= 100000000e18) {\n', '      return initialRate * 5e17 / 1e18;\n', '    }\n', '  }\n', '\n', '  function trade(\n', '      address[5] addrs,\n', '      uint[11] vals,\n', '      uint8[3] v,\n', '      bytes32[6] rs\n', '    ) public onlyNotPaused\n', '    returns (bool)\n', '\n', '    // addrs:\n', '    // addrs[0] baseToken\n', '    // addrs[1] quoteToken\n', '    // addrs[2] buyer\n', '    // addrs[3] seller\n', '    // addrs[4] signer\n', '\n', '    // vals:\n', '    // vals[0] buyVolume\n', '    // vals[1] buyFund\n', '    // vals[2] buyNonce\n', '\n', '    // vals[3] sellVolume\n', '    // vals[4] sellFund\n', '    // vals[5] sellNonce\n', '\n', '    // vals[6] tradeVolume\n', '    // vals[7] tradeFund\n', '    // vals[8] tradeNonce\n', '\n', '    // vals[9] buyerFee\n', '    // vals[10] sellerFee\n', '\n', '    // v:\n', '    // v[0] buyV\n', '    // v[1] sellV\n', '    // v[2] tradeV\n', '\n', '    // rs:\n', '    // rs[0] buyR\n', '    // rs[1] buyS\n', '    // rs[2] sellR\n', '    // rs[3] sellS\n', '    // rs[4] tradeR\n', '    // rs[5] tradeS\n', '  {\n', '    require(signers[addrs[4]]);\n', '    require(cancels[addrs[2]] < vals[2]);\n', '    require(cancels[addrs[3]] < vals[5]);\n', '\n', '    require(vals[6] > 0 && vals[7] > 0 && vals[8] > 0);\n', '    require(vals[1] >= vals[7] && vals[4] >= vals[7]);\n', '    require(msg.sender == addrs[2] || msg.sender == addrs[3] || msg.sender == addrs[4]);\n', '\n', '    bytes32 buyHash = keccak256(address(this), addrs[0], addrs[1], addrs[2], vals[0], vals[1], vals[2]);\n', '    bytes32 sellHash = keccak256(address(this), addrs[0], addrs[1], addrs[3], vals[3], vals[4], vals[5]);\n', '\n', '    require(isValidSignature(addrs[2], buyHash, v[0], rs[0], rs[1]));\n', '    require(isValidSignature(addrs[3], sellHash, v[1], rs[2], rs[3]));\n', '\n', '    bytes32 tradeHash = keccak256(this, buyHash, sellHash, addrs[4], vals[6], vals[7], vals[8], vals[9], vals[10]);\n', '    require(isValidSignature(addrs[4], tradeHash, v[2], rs[4], rs[5]));\n', '    \n', '    require(!traded[tradeHash]);\n', '    traded[tradeHash] = true;\n', '    \n', '    require(safeAdd(orderFills[buyHash], vals[6]) <= vals[0]);\n', '    require(safeAdd(orderFills[sellHash], vals[6]) <= vals[3]);\n', '\n', '    // balances[quoteToken][buyer] > tradeFund\n', '    require(balances[addrs[1]][addrs[2]] >= vals[7]);\n', '\n', '    // balances[quoteToken][buyer] -= tradeFund\n', '    balances[addrs[1]][addrs[2]] = safeSub(balances[addrs[1]][addrs[2]], vals[7]);\n', '\n', '    // balances[baseToken][seller] > tradeVolume\n', '    require(balances[addrs[0]][addrs[3]] >= vals[6]);\n', '\n', '    // balances[baseToken][seller] -= tradeVolume\n', '    balances[addrs[0]][addrs[3]] = safeSub(balances[addrs[0]][addrs[3]], vals[6]);\n', '\n', '    // balances[baseToken][buyer] += tradeVolume - tradeVolume * buyFee\n', '    balances[addrs[0]][addrs[2]] = safeAdd(balances[addrs[0]][addrs[2]], safeSub(vals[6], (safeMul(vals[6], vals[9]) / 1 ether)));\n', '\n', '    // balances[quoteToken][seller] += tradeFund - tradeFund * sellFee\n', '    balances[addrs[1]][addrs[3]] = safeAdd(balances[addrs[1]][addrs[3]], safeSub(vals[7], (safeMul(vals[7], vals[10]) / 1 ether)));\n', '    \n', '    balances[addrs[0]][feeAccount] = safeAdd(balances[addrs[0]][feeAccount], safeMul(vals[6], vals[9]) / 1 ether);\n', '    balances[addrs[1]][feeAccount] = safeAdd(balances[addrs[1]][feeAccount], safeMul(vals[7], vals[10]) / 1 ether);\n', '\n', '    orderFills[buyHash] = safeAdd(orderFills[buyHash], vals[6]);\n', '    orderFills[sellHash] = safeAdd(orderFills[sellHash], vals[6]);\n', '\n', '    Trade(addrs[0], addrs[1], vals[6], vals[7], vals[8], addrs[2], addrs[3]);\n', '\n', '    // Reward BEYs to buyer and seller\n', '    if(unmined > 0) {\n', '      if(miningRate[addrs[1]] > 0){\n', '        uint256 minedBEY = safeMul(safeMul(vals[7], getMiningRate(addrs[1])), 2) / (1 ether);\n', '        if(unmined > minedBEY) {\n', '          mined[addrs[2]] = safeAdd(mined[addrs[2]], safeSub(minedBEY, minedBEY / 2));\n', '          mined[addrs[3]] = safeAdd(mined[addrs[3]], minedBEY / 2);\n', '          unmined = safeSub(unmined, minedBEY);\n', '        } else {\n', '          mined[addrs[2]] = safeAdd(mined[addrs[2]], safeSub(unmined, unmined / 2));\n', '          mined[addrs[3]] = safeAdd(mined[addrs[3]], unmined / 2);\n', '          unmined = 0;\n', '        }\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function claim() public returns(bool) {\n', '    require(mined[msg.sender] > 0);\n', '    require(BEY != address(0));\n', '    uint256 amount = mined[msg.sender];\n', '    mined[msg.sender] = 0;\n', '    require(Token(BEY).transfer(msg.sender, amount));\n', '    Claim(msg.sender, amount);\n', '    return true;\n', '  }\n', '\n', '  function claimByTeam() public onlyOwner returns(bool) {\n', '    uint256 totalMined = safeSub(totalForMining, unmined);\n', '    require(totalMined > 0);\n', '    uint256 released = safeMul(teamLocked, totalMined) / totalForMining;\n', '    uint256 amount = safeSub(released, teamClaimed);\n', '    require(amount > 0);\n', '    teamClaimed = released;\n', '    require(Token(BEY).transfer(msg.sender, amount));\n', '    Claim(msg.sender, amount);\n', '    return true;\n', '  }\n', '\n', '  function cancel(\n', '    address baseToken, \n', '    address quoteToken, \n', '    address user,\n', '    uint volume,\n', '    uint fund,\n', '    uint nonce,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s) public onlySigner returns(bool)\n', '  {\n', '\n', '    bytes32 hash = keccak256(this, baseToken, quoteToken, user, volume, fund, nonce);\n', '    require(isValidSignature(user, hash, v, r, s));\n', '    orderFills[hash] = volume;\n', '    Cancel(user, hash, nonce);\n', '    return true;\n', '  }\n', '  \n', '  function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        pure\n', '        returns (bool)\n', '  {\n', '    return signer == ecrecover(\n', '      keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '      v,\n', '      r,\n', '      s\n', '    );\n', '  }\n', '}']