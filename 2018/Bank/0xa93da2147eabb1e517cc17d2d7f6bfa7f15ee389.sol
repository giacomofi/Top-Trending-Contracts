['pragma solidity ^0.4.24;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract braggerContract {\n', '\n', '/*********************************/\n', '/*********** MAPPINGS ************/\n', '/*********************************/\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) private isUser;\n', '    mapping (address => bool) private hasPicture;\n', '    mapping (address => string) private userWalletToUserName;\n', '    mapping (string => address) private userNameToUserWallet;\n', '    mapping (string => string) private userNameToPicture;\n', '    mapping (address => string) private userWalletToPicture;\n', '    mapping (address => uint256) private fineLevel;\n', '\n', '/*********************************/\n', '/************* EVENTS ************/\n', '/*********************************/\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '/*********************************/\n', '/******** FREE VARIABLES *********/\n', '/*********************************/\n', '\n', '    address public ownerAddress = 0x000;\n', '    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n', '\n', '    string private initialQuote = "Teach your people with your wisdom.";\n', '    /******SET PICTURE*/\n', '    string private initialPicture = "https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png";\n', '\n', '    uint256 basicFine = 25000000000000000;\n', '\n', '    uint256 totalBraggedValue = 0;\n', '\n', '    uint256 winningpot = 0;\n', '\n', '    uint256 totalbrags = 0;\n', '\n', '    bool payoutReady;\n', '    bool payoutRequested;\n', '    uint256 payoutBlock;\n', '\n', '/*********************************/\n', '/*********** DATA TYPES **********/\n', '/*********************************/\n', '\n', '    struct Bragger{\n', '        address braggerAddress;\n', '        uint256 braggedAmount;\n', '        string braggerQuote;\n', '    }\n', '\n', '    Bragger[] private braggers;\n', '\n', '    struct User{\n', '        address userAddress;\n', '        string userName;\n', '    }\n', '\n', '    User[] private users;\n', '\n', '/*********************************/\n', '/*********** MODIFIER ************/\n', '/*********************************/\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCreator() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '\n', '/*********************************/\n', '/********** CONSTRUCTOR **********/\n', '/*********************************/\n', '\n', '    constructor() public {\n', '        payoutRequested = false;\n', '        payoutReady = false;\n', '        ownerAddress = msg.sender;\n', '    }\n', '\n', '/*********************************/\n', '/******* PAYOUT FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function requestPayout() public {\n', '        //require(isUser[msg.sender]);\n', '        if(!getPayoutRequestedState()) {\n', '            payoutRequested = true;\n', '            payoutBlock = SafeMath.add(block.number, 17280);\n', '        }\n', '    }\n', '\n', '    function delayPayout() public payable {\n', '        require(getPayoutRequestedState());\n', '        //require(isUser[msg.sender]);\n', '        require(msg.value>=2500000000000000);\n', '        payoutBlock = SafeMath.add(payoutBlock, 240);\n', '        bragAddress.transfer(msg.value);\n', '    }\n', '\n', '    function triggerPayout() public {\n', '        //require(isUser[msg.sender]);\n', '        require(checkPayoutReadyState());\n', '        address _winner = braggers[braggers.length-1].braggerAddress;\n', '        _winner.transfer(getWinnerPot());\n', '        payoutBlock = 0;\n', '        payoutRequested = false;\n', '    }\n', '\n', '     function checkPayoutReadyState() public returns(bool){\n', '        if(block.number >= payoutBlock && payoutBlock != 0){\n', '            payoutReady = true;\n', '            return true;\n', '        }\n', '\n', '        if(block.number < payoutBlock){\n', '            payoutReady = false;\n', '            return false;\n', '        }\n', '    }\n', '\n', '/*********************************/\n', '/************ GETTERS ************/\n', '/*********************************/\n', '\n', '    function getPayoutRequestedState() public view returns(bool){\n', '        return payoutRequested;\n', '    }\n', '\n', '    function getPayoutReadyState() public view returns(bool){\n', '         if(block.number>=payoutBlock && payoutBlock != 0){\n', '            return true;\n', '        }\n', '\n', '        if(block.number < payoutBlock){\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function getCurrentPayoutBlock() public view returns(uint){\n', '        return payoutBlock;\n', '    }\n', '\n', '    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n', '        return SafeMath.sub(payoutBlock, block.number);\n', '    }\n', '\n', '    function getTotalBraggedVolume() public view returns (uint256 _amount){\n', '        return totalBraggedValue;\n', '    }\n', '\n', '    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n', '        _bragger = braggers[braggers.length-1].braggerAddress;\n', '        _amount = braggers[braggers.length-1].braggedAmount;\n', '        _quote = braggers[braggers.length-1].braggerQuote;\n', '        if(isAlreadyUser(_bragger)){\n', '            _username = getUserNameByWallet(_bragger);\n', '        } else {\n', '            _username = "";\n', '        }\n', '\n', '        if(hasPicture[_bragger]){\n', '            _picture = userWalletToPicture[_bragger];\n', '        } else {\n', '            _picture = initialPicture;\n', '        }\n', '\n', '        return (_bragger, _amount, _quote, _username, _picture);\n', '    }\n', '\n', '    function arrayLength()public view returns(uint256 length){\n', '        length = braggers.length;\n', '        return length;\n', '    }\n', '\n', '    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n', '        _bragger = braggers[_index].braggerAddress;\n', '        _brag = braggers[_index].braggedAmount;\n', '\n', '        if(isAlreadyUser(_bragger)){\n', '            _username = getUserNameByWallet(_bragger);\n', '        } else {\n', '            _username = "";\n', '        }\n', '\n', '         if(hasPicture[_bragger]){\n', '            _picture = userWalletToPicture[_bragger];\n', '        } else {\n', '            _picture = initialPicture;\n', '        }\n', '\n', '        return (_bragger, _brag, _username, _picture);\n', '    }\n', '\n', '    function getUserNameByWallet(address _wallet) public view returns (string _username){\n', '        require(isAlreadyUser(_wallet));\n', '        _username = userWalletToUserName[_wallet];\n', '        return _username;\n', '    }\n', '\n', '     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n', '        require(isAlreadyUser(_wallet));\n', '        _url = userWalletToPicture[_wallet];\n', '        return _url;\n', '    }\n', '\n', '    function getUserWalletByUsername(string _username) public view returns(address _address){\n', '        address _user = userNameToUserWallet[_username];\n', '        return (_user);\n', '    }\n', '\n', '    function getUserPictureByUsername(string _username) public view returns(string _url){\n', '        _url = userNameToPicture[_username];\n', '        return (_url);\n', '    }\n', '\n', '    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n', '        _fineLevel = fineLevel[_user];\n', '        _fineAmount = _fineLevel * basicFine;\n', '        return (_fineLevel, _fineAmount);\n', '    }\n', '\n', '    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n', '        address _user = userNameToUserWallet[_username];\n', '        _fineLevel = fineLevel[_user];\n', '        _fineAmount = _fineLevel * basicFine;\n', '        return (_fineLevel, _fineAmount);\n', '    }\n', '\n', '    function getTotalBrags() public view returns(uint256){\n', '        return totalbrags;\n', '    }\n', '\n', '    function getWinnerPot() public view returns(uint256){\n', '        return winningpot;\n', '    }\n', '\n', '/*********************************/\n', '/****** BRAGING FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function getCurrentPot() public view returns (uint256 _amount){\n', '        return address(this).balance;\n', '    }\n', '\n', '\n', '    function brag() public payable{\n', '\n', '        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n', '\n', '        if(braggers.length != 0){\n', '         require(braggers[braggers.length-1].braggedAmount < msg.value);\n', '        }\n', '\n', '        Bragger memory _bragger = Bragger({\n', '            braggerAddress: msg.sender,\n', '            braggedAmount: msg.value,\n', '            braggerQuote: initialQuote\n', '        });\n', '\n', '        braggers.push(_bragger);\n', '\n', '        totalBraggedValue = totalBraggedValue + msg.value;\n', '\n', '        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n', '\n', '        bragAddress.transfer(shortage);\n', '\n', '        totalbrags += 1;\n', '    }\n', '\n', '/*********************************/\n', '/******* USER INTERACTION ********/\n', '/*********************************/\n', '\n', '    function setTheKingsQuote(string _message) public payable{\n', '        if(fineLevel[msg.sender] > 0){\n', '            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n', '        }\n', '        address currentKing = braggers[braggers.length-1].braggerAddress;\n', '        require(msg.sender == currentKing);\n', '        braggers[braggers.length-1].braggerQuote = _message;\n', '    }\n', '\n', '/*********************************/\n', '/********* USER CREATION *********/\n', '/*********************************/\n', '\n', '    function isAlreadyUser(address _address) public view returns (bool status){\n', '        if (isUser[_address]){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function hasProfilePicture(address _address) public view returns (bool status){\n', '        if (isUser[_address]){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function createNewUser(string _username, string _pictureUrl) public {\n', '\n', '        require(!isAlreadyUser(msg.sender));\n', '\n', '        User memory _user = User({\n', '            userAddress: msg.sender,\n', '            userName: _username\n', '        });\n', '\n', '        userWalletToUserName[msg.sender] = _username;\n', '        userNameToUserWallet[_username] = msg.sender;\n', '        userNameToPicture[_username] = _pictureUrl;\n', '        userWalletToPicture[msg.sender] = _pictureUrl;\n', '        fineLevel[msg.sender] = 0;\n', '\n', '        users.push(_user) - 1;\n', '        isUser[msg.sender] = true;\n', '        hasPicture[msg.sender] = true;\n', '    }\n', '\n', '/*********************************/\n', '/******** OWNER FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function resetQuote()public onlyCreator{\n', '        braggers[braggers.length-1].braggerQuote = initialQuote;\n', '        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n', '    }\n', '\n', '    function resetUsername(string _username)public onlyCreator{\n', '        address user = userNameToUserWallet[_username];\n', '        userWalletToUserName[user] = "Mick";\n', '        fineLevel[user] = fineLevel[user] + 1;\n', '    }\n', '\n', '    function resetUserPicture(string _username)public onlyCreator{\n', '        address user = userNameToUserWallet[_username];\n', '        userWalletToPicture[user] = initialPicture;\n', '        fineLevel[user] = fineLevel[user] + 1;\n', '    }\n', '\n', '    /********** ResetUserPicture */\n', '\n', '/*********************************/\n', '/******** LEGACY FUNCIONS ********/\n', '/*********************************/\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function reset()public onlyCreator {\n', '        selfdestruct(ownerAddress);\n', '    }\n', '\n', '}\n', '\n', '/*********************************/\n', '/*********** CALC LIB ************/\n', '/*********************************/\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract braggerContract {\n', '\n', '/*********************************/\n', '/*********** MAPPINGS ************/\n', '/*********************************/\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) private isUser;\n', '    mapping (address => bool) private hasPicture;\n', '    mapping (address => string) private userWalletToUserName;\n', '    mapping (string => address) private userNameToUserWallet;\n', '    mapping (string => string) private userNameToPicture;\n', '    mapping (address => string) private userWalletToPicture;\n', '    mapping (address => uint256) private fineLevel;\n', '\n', '/*********************************/\n', '/************* EVENTS ************/\n', '/*********************************/\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '/*********************************/\n', '/******** FREE VARIABLES *********/\n', '/*********************************/\n', '\n', '    address public ownerAddress = 0x000;\n', '    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n', '\n', '    string private initialQuote = "Teach your people with your wisdom.";\n', '    /******SET PICTURE*/\n', '    string private initialPicture = "https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png";\n', '\n', '    uint256 basicFine = 25000000000000000;\n', '\n', '    uint256 totalBraggedValue = 0;\n', '\n', '    uint256 winningpot = 0;\n', '\n', '    uint256 totalbrags = 0;\n', '\n', '    bool payoutReady;\n', '    bool payoutRequested;\n', '    uint256 payoutBlock;\n', '\n', '/*********************************/\n', '/*********** DATA TYPES **********/\n', '/*********************************/\n', '\n', '    struct Bragger{\n', '        address braggerAddress;\n', '        uint256 braggedAmount;\n', '        string braggerQuote;\n', '    }\n', '\n', '    Bragger[] private braggers;\n', '\n', '    struct User{\n', '        address userAddress;\n', '        string userName;\n', '    }\n', '\n', '    User[] private users;\n', '\n', '/*********************************/\n', '/*********** MODIFIER ************/\n', '/*********************************/\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCreator() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '\n', '/*********************************/\n', '/********** CONSTRUCTOR **********/\n', '/*********************************/\n', '\n', '    constructor() public {\n', '        payoutRequested = false;\n', '        payoutReady = false;\n', '        ownerAddress = msg.sender;\n', '    }\n', '\n', '/*********************************/\n', '/******* PAYOUT FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function requestPayout() public {\n', '        //require(isUser[msg.sender]);\n', '        if(!getPayoutRequestedState()) {\n', '            payoutRequested = true;\n', '            payoutBlock = SafeMath.add(block.number, 17280);\n', '        }\n', '    }\n', '\n', '    function delayPayout() public payable {\n', '        require(getPayoutRequestedState());\n', '        //require(isUser[msg.sender]);\n', '        require(msg.value>=2500000000000000);\n', '        payoutBlock = SafeMath.add(payoutBlock, 240);\n', '        bragAddress.transfer(msg.value);\n', '    }\n', '\n', '    function triggerPayout() public {\n', '        //require(isUser[msg.sender]);\n', '        require(checkPayoutReadyState());\n', '        address _winner = braggers[braggers.length-1].braggerAddress;\n', '        _winner.transfer(getWinnerPot());\n', '        payoutBlock = 0;\n', '        payoutRequested = false;\n', '    }\n', '\n', '     function checkPayoutReadyState() public returns(bool){\n', '        if(block.number >= payoutBlock && payoutBlock != 0){\n', '            payoutReady = true;\n', '            return true;\n', '        }\n', '\n', '        if(block.number < payoutBlock){\n', '            payoutReady = false;\n', '            return false;\n', '        }\n', '    }\n', '\n', '/*********************************/\n', '/************ GETTERS ************/\n', '/*********************************/\n', '\n', '    function getPayoutRequestedState() public view returns(bool){\n', '        return payoutRequested;\n', '    }\n', '\n', '    function getPayoutReadyState() public view returns(bool){\n', '         if(block.number>=payoutBlock && payoutBlock != 0){\n', '            return true;\n', '        }\n', '\n', '        if(block.number < payoutBlock){\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function getCurrentPayoutBlock() public view returns(uint){\n', '        return payoutBlock;\n', '    }\n', '\n', '    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n', '        return SafeMath.sub(payoutBlock, block.number);\n', '    }\n', '\n', '    function getTotalBraggedVolume() public view returns (uint256 _amount){\n', '        return totalBraggedValue;\n', '    }\n', '\n', '    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n', '        _bragger = braggers[braggers.length-1].braggerAddress;\n', '        _amount = braggers[braggers.length-1].braggedAmount;\n', '        _quote = braggers[braggers.length-1].braggerQuote;\n', '        if(isAlreadyUser(_bragger)){\n', '            _username = getUserNameByWallet(_bragger);\n', '        } else {\n', '            _username = "";\n', '        }\n', '\n', '        if(hasPicture[_bragger]){\n', '            _picture = userWalletToPicture[_bragger];\n', '        } else {\n', '            _picture = initialPicture;\n', '        }\n', '\n', '        return (_bragger, _amount, _quote, _username, _picture);\n', '    }\n', '\n', '    function arrayLength()public view returns(uint256 length){\n', '        length = braggers.length;\n', '        return length;\n', '    }\n', '\n', '    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n', '        _bragger = braggers[_index].braggerAddress;\n', '        _brag = braggers[_index].braggedAmount;\n', '\n', '        if(isAlreadyUser(_bragger)){\n', '            _username = getUserNameByWallet(_bragger);\n', '        } else {\n', '            _username = "";\n', '        }\n', '\n', '         if(hasPicture[_bragger]){\n', '            _picture = userWalletToPicture[_bragger];\n', '        } else {\n', '            _picture = initialPicture;\n', '        }\n', '\n', '        return (_bragger, _brag, _username, _picture);\n', '    }\n', '\n', '    function getUserNameByWallet(address _wallet) public view returns (string _username){\n', '        require(isAlreadyUser(_wallet));\n', '        _username = userWalletToUserName[_wallet];\n', '        return _username;\n', '    }\n', '\n', '     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n', '        require(isAlreadyUser(_wallet));\n', '        _url = userWalletToPicture[_wallet];\n', '        return _url;\n', '    }\n', '\n', '    function getUserWalletByUsername(string _username) public view returns(address _address){\n', '        address _user = userNameToUserWallet[_username];\n', '        return (_user);\n', '    }\n', '\n', '    function getUserPictureByUsername(string _username) public view returns(string _url){\n', '        _url = userNameToPicture[_username];\n', '        return (_url);\n', '    }\n', '\n', '    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n', '        _fineLevel = fineLevel[_user];\n', '        _fineAmount = _fineLevel * basicFine;\n', '        return (_fineLevel, _fineAmount);\n', '    }\n', '\n', '    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n', '        address _user = userNameToUserWallet[_username];\n', '        _fineLevel = fineLevel[_user];\n', '        _fineAmount = _fineLevel * basicFine;\n', '        return (_fineLevel, _fineAmount);\n', '    }\n', '\n', '    function getTotalBrags() public view returns(uint256){\n', '        return totalbrags;\n', '    }\n', '\n', '    function getWinnerPot() public view returns(uint256){\n', '        return winningpot;\n', '    }\n', '\n', '/*********************************/\n', '/****** BRAGING FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function getCurrentPot() public view returns (uint256 _amount){\n', '        return address(this).balance;\n', '    }\n', '\n', '\n', '    function brag() public payable{\n', '\n', '        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n', '\n', '        if(braggers.length != 0){\n', '         require(braggers[braggers.length-1].braggedAmount < msg.value);\n', '        }\n', '\n', '        Bragger memory _bragger = Bragger({\n', '            braggerAddress: msg.sender,\n', '            braggedAmount: msg.value,\n', '            braggerQuote: initialQuote\n', '        });\n', '\n', '        braggers.push(_bragger);\n', '\n', '        totalBraggedValue = totalBraggedValue + msg.value;\n', '\n', '        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n', '\n', '        bragAddress.transfer(shortage);\n', '\n', '        totalbrags += 1;\n', '    }\n', '\n', '/*********************************/\n', '/******* USER INTERACTION ********/\n', '/*********************************/\n', '\n', '    function setTheKingsQuote(string _message) public payable{\n', '        if(fineLevel[msg.sender] > 0){\n', '            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n', '        }\n', '        address currentKing = braggers[braggers.length-1].braggerAddress;\n', '        require(msg.sender == currentKing);\n', '        braggers[braggers.length-1].braggerQuote = _message;\n', '    }\n', '\n', '/*********************************/\n', '/********* USER CREATION *********/\n', '/*********************************/\n', '\n', '    function isAlreadyUser(address _address) public view returns (bool status){\n', '        if (isUser[_address]){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function hasProfilePicture(address _address) public view returns (bool status){\n', '        if (isUser[_address]){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function createNewUser(string _username, string _pictureUrl) public {\n', '\n', '        require(!isAlreadyUser(msg.sender));\n', '\n', '        User memory _user = User({\n', '            userAddress: msg.sender,\n', '            userName: _username\n', '        });\n', '\n', '        userWalletToUserName[msg.sender] = _username;\n', '        userNameToUserWallet[_username] = msg.sender;\n', '        userNameToPicture[_username] = _pictureUrl;\n', '        userWalletToPicture[msg.sender] = _pictureUrl;\n', '        fineLevel[msg.sender] = 0;\n', '\n', '        users.push(_user) - 1;\n', '        isUser[msg.sender] = true;\n', '        hasPicture[msg.sender] = true;\n', '    }\n', '\n', '/*********************************/\n', '/******** OWNER FUNCTIONS ********/\n', '/*********************************/\n', '\n', '    function resetQuote()public onlyCreator{\n', '        braggers[braggers.length-1].braggerQuote = initialQuote;\n', '        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n', '    }\n', '\n', '    function resetUsername(string _username)public onlyCreator{\n', '        address user = userNameToUserWallet[_username];\n', '        userWalletToUserName[user] = "Mick";\n', '        fineLevel[user] = fineLevel[user] + 1;\n', '    }\n', '\n', '    function resetUserPicture(string _username)public onlyCreator{\n', '        address user = userNameToUserWallet[_username];\n', '        userWalletToPicture[user] = initialPicture;\n', '        fineLevel[user] = fineLevel[user] + 1;\n', '    }\n', '\n', '    /********** ResetUserPicture */\n', '\n', '/*********************************/\n', '/******** LEGACY FUNCIONS ********/\n', '/*********************************/\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function reset()public onlyCreator {\n', '        selfdestruct(ownerAddress);\n', '    }\n', '\n', '}\n', '\n', '/*********************************/\n', '/*********** CALC LIB ************/\n', '/*********************************/\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
