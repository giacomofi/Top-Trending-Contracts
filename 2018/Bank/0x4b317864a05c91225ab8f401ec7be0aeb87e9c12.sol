['pragma solidity ^0.4.16;\n', '\n', 'contract TokenBBBasic {\n', '    string public name = "BingoCoin";      \n', '    string public symbol = "BOC";              \n', '    uint8 public decimals = 18;                \n', '    uint256 public totalSupply;                \n', '\n', '    uint256 public sellScale = 15000;            \n', '    uint256 public minBalanceForAccounts = 5000000000000000;\n', '\n', '    bool public lockAll = false;               \n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event FrozenFunds(address target, bool frozen);\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '    address public owner;\n', '    address internal newOwner = 0x0;\n', '    mapping (address => bool) public frozens;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    //---------init----------\n', '    function TokenBBBasic() public {\n', '        totalSupply = 2000000000 * 10 ** uint256(decimals);  \n', '        balanceOf[msg.sender] = totalSupply;                \n', '        owner = msg.sender;\n', '    }\n', '    //--------control--------\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address tOwner) onlyOwner public {\n', '        require(owner!=tOwner);\n', '        newOwner = tOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender==newOwner && newOwner != 0x0);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '        emit OwnerUpdate(owner, newOwner);\n', '    }\n', '    function contBuy(address addr,uint256 amount) onlyOwner public{\n', '        require(address(this).balance >= amount / sellScale); \n', '        require(addr.balance < minBalanceForAccounts);\n', '        _transfer(addr, address(this), amount);\n', '        addr.transfer(amount/sellScale);\n', '    }\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozens[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '    function setScale(uint256 newSellScale,uint256 newMinBalanceForAccounts) onlyOwner public {\n', '        sellScale = newSellScale;\n', '        minBalanceForAccounts = newMinBalanceForAccounts;\n', '    }\n', '    function freezeAll(bool lock) onlyOwner public {\n', '        lockAll = lock;\n', '    }\n', '    function contTransfer(address _to,uint256 weis) onlyOwner public{\n', '        _transfer(this, _to, weis);\n', '    }\n', '    //-------transfer-------\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(!lockAll);\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        require(!frozens[_from]); \n', '        //require(!frozenAccount[_to]);  \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        if (balanceOf[_to] >= totalSupply/10 && _to!=address(this)) {\n', '            frozens[_to] = true;\n', '            emit FrozenFunds(_to, true);\n', '        }\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transferWithEther(address _to, uint256 _value) public {\n', '        uint256 value = _value;\n', '        if(_to.balance < minBalanceForAccounts){ \n', '            uint256 sellAmount = (minBalanceForAccounts - _to.balance) * sellScale; \n', '            require(sellAmount < _value); \n', '            require(address(this).balance > sellAmount / sellScale);\n', '            value = _value - sellAmount;\n', '            _transfer(msg.sender, _to, value);\n', '            sellToAddress((minBalanceForAccounts - _to.balance) * sellScale,_to);\n', '        }else{\n', '            _transfer(msg.sender, _to, value);\n', '        }\n', '    }\n', '    function sellToAddress(uint256 amount, address to) internal {\n', '        _transfer(msg.sender, this, amount); \n', '        to.transfer(amount / sellScale); \n', '    }\n', '\n', '    function sell(uint256 amount) public {\n', '        require(address(this).balance >= amount / sellScale); \n', '        _transfer(msg.sender, this, amount); \n', '        msg.sender.transfer(amount / sellScale); \n', '    }\n', '    function() payable public{\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract TokenBBBasic {\n', '    string public name = "BingoCoin";      \n', '    string public symbol = "BOC";              \n', '    uint8 public decimals = 18;                \n', '    uint256 public totalSupply;                \n', '\n', '    uint256 public sellScale = 15000;            \n', '    uint256 public minBalanceForAccounts = 5000000000000000;\n', '\n', '    bool public lockAll = false;               \n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event FrozenFunds(address target, bool frozen);\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '    address public owner;\n', '    address internal newOwner = 0x0;\n', '    mapping (address => bool) public frozens;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    //---------init----------\n', '    function TokenBBBasic() public {\n', '        totalSupply = 2000000000 * 10 ** uint256(decimals);  \n', '        balanceOf[msg.sender] = totalSupply;                \n', '        owner = msg.sender;\n', '    }\n', '    //--------control--------\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address tOwner) onlyOwner public {\n', '        require(owner!=tOwner);\n', '        newOwner = tOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender==newOwner && newOwner != 0x0);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '        emit OwnerUpdate(owner, newOwner);\n', '    }\n', '    function contBuy(address addr,uint256 amount) onlyOwner public{\n', '        require(address(this).balance >= amount / sellScale); \n', '        require(addr.balance < minBalanceForAccounts);\n', '        _transfer(addr, address(this), amount);\n', '        addr.transfer(amount/sellScale);\n', '    }\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozens[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '    function setScale(uint256 newSellScale,uint256 newMinBalanceForAccounts) onlyOwner public {\n', '        sellScale = newSellScale;\n', '        minBalanceForAccounts = newMinBalanceForAccounts;\n', '    }\n', '    function freezeAll(bool lock) onlyOwner public {\n', '        lockAll = lock;\n', '    }\n', '    function contTransfer(address _to,uint256 weis) onlyOwner public{\n', '        _transfer(this, _to, weis);\n', '    }\n', '    //-------transfer-------\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(!lockAll);\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        require(!frozens[_from]); \n', '        //require(!frozenAccount[_to]);  \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        if (balanceOf[_to] >= totalSupply/10 && _to!=address(this)) {\n', '            frozens[_to] = true;\n', '            emit FrozenFunds(_to, true);\n', '        }\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transferWithEther(address _to, uint256 _value) public {\n', '        uint256 value = _value;\n', '        if(_to.balance < minBalanceForAccounts){ \n', '            uint256 sellAmount = (minBalanceForAccounts - _to.balance) * sellScale; \n', '            require(sellAmount < _value); \n', '            require(address(this).balance > sellAmount / sellScale);\n', '            value = _value - sellAmount;\n', '            _transfer(msg.sender, _to, value);\n', '            sellToAddress((minBalanceForAccounts - _to.balance) * sellScale,_to);\n', '        }else{\n', '            _transfer(msg.sender, _to, value);\n', '        }\n', '    }\n', '    function sellToAddress(uint256 amount, address to) internal {\n', '        _transfer(msg.sender, this, amount); \n', '        to.transfer(amount / sellScale); \n', '    }\n', '\n', '    function sell(uint256 amount) public {\n', '        require(address(this).balance >= amount / sellScale); \n', '        _transfer(msg.sender, this, amount); \n', '        msg.sender.transfer(amount / sellScale); \n', '    }\n', '    function() payable public{\n', '    }\n', '}']
