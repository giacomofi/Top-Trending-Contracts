['pragma solidity ^0.4.21;\n', '\n', '\n', '/*\n', '* https://proof-of-stable-clone.com/\n', '* Contract is **live** in one hour\n', '* Deposit to buy in.\n', '* Reinvest to reinvest.\n', '* Claim to withdraw dividends.\n', '* Withdraw to sell.\n', '*/\n', '\n', 'contract ProofOfStableClone {\n', '    using SafeMath for uint256;\n', '   \n', '    \n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    bool gameStarted = true;\n', '\n', '    uint constant depositTaxDivisor = 4;\n', '    uint constant withdrawalTaxDivisor = 11;\n', '\n', '    mapping(address => uint) public investment;\n', '   \n', '     address owner = msg.sender;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfStableClone() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner );\n', '        _;\n', '    }\n', '\n', '    function startGame() public onlyOwner {\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '        uint _tax = _amount.div(depositTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit() public payable {\n', '        require(gameStarted);\n', '        depositHelper(msg.value);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.div(withdrawalTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '        owner.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        owner.transfer(_dividends);\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '        emit Reinvest(owner, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '      \n', '    function closeGame() onlyOwner public {\n', '        uint256 etherBalance = this.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold                                                                                                                       \n', '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', '/*\n', '* https://proof-of-stable-clone.com/\n', '* Contract is **live** in one hour\n', '* Deposit to buy in.\n', '* Reinvest to reinvest.\n', '* Claim to withdraw dividends.\n', '* Withdraw to sell.\n', '*/\n', '\n', 'contract ProofOfStableClone {\n', '    using SafeMath for uint256;\n', '   \n', '    \n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event Claim(address user, uint dividends);\n', '    event Reinvest(address user, uint dividends);\n', '\n', '    bool gameStarted = true;\n', '\n', '    uint constant depositTaxDivisor = 4;\n', '    uint constant withdrawalTaxDivisor = 11;\n', '\n', '    mapping(address => uint) public investment;\n', '   \n', '     address owner = msg.sender;\n', '\n', '    mapping(address => uint) public stake;\n', '    uint public totalStake;\n', '    uint stakeValue;\n', '\n', '    mapping(address => uint) dividendCredit;\n', '    mapping(address => uint) dividendDebit;\n', '\n', '    function ProofOfStableClone() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner );\n', '        _;\n', '    }\n', '\n', '    function startGame() public onlyOwner {\n', '        gameStarted = true;\n', '    }\n', '\n', '    function depositHelper(uint _amount) private {\n', '        uint _tax = _amount.div(depositTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        uint _stakeIncrement = sqrt(totalStake.mul(totalStake).add(_amountAfterTax)).sub(totalStake);\n', '        investment[msg.sender] = investment[msg.sender].add(_amountAfterTax);\n', '        stake[msg.sender] = stake[msg.sender].add(_stakeIncrement);\n', '        totalStake = totalStake.add(_stakeIncrement);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].add(_stakeIncrement.mul(stakeValue));\n', '    }\n', '\n', '    function deposit() public payable {\n', '        require(gameStarted);\n', '        depositHelper(msg.value);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= investment[msg.sender]);\n', '        uint _tax = _amount.div(withdrawalTaxDivisor);\n', '        uint _amountAfterTax = _amount.sub(_tax);\n', '        uint _stakeDecrement = stake[msg.sender].mul(_amount).div(investment[msg.sender]);\n', '        uint _dividendCredit = _stakeDecrement.mul(stakeValue);\n', '        investment[msg.sender] = investment[msg.sender].sub(_amount);\n', '        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);\n', '        totalStake = totalStake.sub(_stakeDecrement);\n', '        if (totalStake > 0)\n', '            stakeValue = stakeValue.add(_tax.div(totalStake));\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].add(_dividendCredit);\n', '        uint _creditDebitCancellation = min(dividendCredit[msg.sender], dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = dividendCredit[msg.sender].sub(_creditDebitCancellation);\n', '        dividendDebit[msg.sender] = dividendDebit[msg.sender].sub(_creditDebitCancellation);\n', '        owner.transfer(_amountAfterTax);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function claimHelper() private returns(uint) {\n', '        uint _dividendsForStake = stake[msg.sender].mul(stakeValue);\n', '        uint _dividends = _dividendsForStake.add(dividendCredit[msg.sender]).sub(dividendDebit[msg.sender]);\n', '        dividendCredit[msg.sender] = 0;\n', '        dividendDebit[msg.sender] = _dividendsForStake;\n', '        return _dividends;\n', '    }\n', '\n', '    function claim() public {\n', '        uint _dividends = claimHelper();\n', '        owner.transfer(_dividends);\n', '        emit Claim(msg.sender, _dividends);\n', '    }\n', '\n', '    function reinvest() public {\n', '        uint _dividends = claimHelper();\n', '        depositHelper(_dividends);\n', '        emit Reinvest(owner, _dividends);\n', '    }\n', '\n', '    function dividendsForUser(address _user) public view returns (uint) {\n', '        return stake[_user].mul(stakeValue).add(dividendCredit[_user]).sub(dividendDebit[_user]);\n', '    }\n', '\n', '    function min(uint x, uint y) private pure returns (uint) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function sqrt(uint x) private pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '      \n', '    function closeGame() onlyOwner public {\n', '        uint256 etherBalance = this.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;                                                                                                                                                                                       \n', '        }\n', '        uint256 c = a * b;                                                                                                                                                                                  \n', '        assert(c / a == b);                                                                                                                                                                                 \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0                                                                                                                               \n', '        // uint256 c = a / b;                                                                                                                                                                               \n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold                                                                                                                       \n", '        return a / b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);                                                                                                                                                                                     \n', '        return a - b;                                                                                                                                                                                       \n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;                                                                                                                                                                                  \n', '        assert(c >= a);                                                                                                                                                                                     \n', '        return c;                                                                                                                                                                                           \n', '    }\n', '}']
