['pragma solidity ^0.4.21;\n', '\n', '/*\n', 'Project: XPA Exchange - https://xpa.exchange\n', 'Author : Luphia Chang - <span class="__cf_email__" data-cfemail="9bf7eeebf3f2fab5f8f3faf5fcdbf2e8eef5f8f7f4eeffb5f8f4f6">[email&#160;protected]</span>\n', ' */\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint256 z = x + y;\n', '      require((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      require(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint z = x * y;\n', '      require((x == 0) || (z / x == y));\n', '      return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '      bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '      return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => address) public agentBooks;\n', '    address public owner;\n', '    address public operator;\n', '    address public bank;\n', '    bool public powerStatus = true;\n', '\n', '    function Authorization()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        operator = msg.sender;\n', '        bank = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(msg.sender == operator || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyActive\n', '    {\n', '        assert(powerStatus);\n', '        _;\n', '    }\n', '\n', '    function powerSwitch(\n', '        bool onOff_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        powerStatus = onOff_;\n', '    }\n', '\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        operator = user_;\n', '        agentBooks[bank] = user_;\n', '    }\n', '    \n', '    function assignBank(address bank_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bank = bank_;\n', '    }\n', '\n', '    function assignAgent(\n', '        address agent_\n', '    )\n', '        public\n', '    {\n', '        agentBooks[msg.sender] = agent_;\n', '    }\n', '\n', '    function isRepresentor(\n', '        address representor_\n', '    )\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return agentBooks[representor_] == msg.sender;\n', '    }\n', '\n', '    function getUser(\n', '        address representor_\n', '    )\n', '        internal\n', '        view\n', '    returns(address) {\n', '        return isRepresentor(representor_) ? representor_ : msg.sender;\n', '    }\n', '}\n', '\n', '/*  Error Code\n', '    0: insufficient funds (user)\n', '    1: insufficient funds (contract)\n', '    2: invalid amount\n', '    3: invalid price\n', ' */\n', '\n', '/*\n', '    1. 檢驗是否指定代理用戶，若是且為合法代理人則將操作角色轉換為被代理人，否則操作角色不變\n', '    2. 檢驗此操作是否有存入 ETH，有則暫時紀錄存入額度 A，若掛單指定 fromToken 不是 ETH 則直接更新用戶 ETH 帳戶餘額\n', '    3. 檢驗此操作是否有存入 fromToken，有則暫時紀錄存入額度 A\n', '    4. 檢驗用戶 fromToken 帳戶餘額 + 存入額度 A 是否 >= Amount，若是送出 makeOrder 掛單事件，否則結束操作\n', '    5. 依照 fromToken、toToken 尋找可匹配的交易對 P\n', '    6. 找出 P 的最低價格單進行匹配，記錄匹配數量，送出 fillOrder 成交事件，並結算 maker 交易結果，若成交完還有掛單數量有剩且未達迴圈次數上限則重複此步驟\n', '    7. 統計步驟 6 總成交量、交易價差利潤、交易手續費\n', '    8. 若扣除總成交量後 Taker 掛單尚未撮合完，則將剩餘額度轉換為 Maker 單\n', '    9. 結算交易所手續費\n', '    10. 結算 Taker 交易結果\n', ' */\n', '\n', 'contract Baliv is SafeMath, Authorization {\n', '    /* struct for exchange data */\n', '    struct linkedBook {\n', '        uint256 amount;\n', '        address nextUser;\n', '    }\n', '\n', '    /* business options */\n', '    mapping(address => uint256) public minAmount;\n', '    uint256[3] public feerate = [0, 1 * (10 ** 15), 1 * (10 ** 15)];\n', '    uint256 public autoMatch = 10;\n', '    uint256 public maxAmount = 10 ** 27;\n', '    uint256 public maxPrice = 10 ** 36;\n', '    address public XPAToken = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '\n', '    /* exchange data */\n', '    mapping(address => mapping(address => mapping(uint256 => mapping(address => linkedBook)))) public orderBooks;\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public nextOrderPrice;\n', '    mapping(address => mapping(address => uint256)) public priceBooks;\n', '    \n', '    /* user data */\n', '    mapping(address => mapping(address => uint256)) public balances;\n', '    mapping(address => bool) internal manualWithdraw;\n', '\n', '    /* event */\n', '    event eDeposit(address user,address token, uint256 amount);\n', '    event eWithdraw(address user,address token, uint256 amount);\n', '    event eMakeOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '    event eFillOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '    event eCancelOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '\n', '    event Error(uint256 code);\n', '\n', '    /* constructor */\n', '    function Baliv() public {\n', '        minAmount[0] = 10 ** 16;\n', '    }\n', '\n', '    /* Operator Function\n', '        function setup(uint256 autoMatch, uint256 maxAmount, uint256 maxPrice) external;\n', '        function setMinAmount(address token, uint256 amount) external;\n', '        function setFeerate(uint256[3] [maker, taker, autoWithdraw]) external;\n', '    */\n', '\n', '    /* External Function\n', '        function () public payable;\n', '        function deposit(address token, address representor) external payable;\n', '        function withdraw(address token, uint256 amount, address representor) external returns(bool);\n', '        function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '        function userCancelOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external returns(bool);\n', '        function caculateFee(address user, uint256 amount, uint8 role) external returns(uint256 remaining, uint256 fee);\n', '        function trade(address fromToken, address toToken) external;\n', '        function setManualWithdraw(bool) external;\n', '        function getMinAmount(address) external returns(uint256);\n', '        function getPrice(address fromToken, address toToken) external returns(uint256);\n', '    */\n', '\n', '    /* Internal Function\n', '        function depositAndFreeze(address token, address user) internal payable returns(uint256 amount);\n', '        function checkBalance(address user, address token, uint256 amount, uint256 depositAmount) internal returns(bool);\n', '        function checkAmount(address token, uint256 amount) internal returns(bool);\n', '        function checkPriceAmount(uint256 price) internal returns(bool);\n', '        function makeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address user, uint256 depositAmount) internal returns(uint256 amount);\n', '        function findAndTrade(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256[2] totalMatchAmount[fromToken, toToken], uint256[2] profit[fromToken, toToken]);\n', '        function makeTrade(address fromToken, address toToken, uint256 price, uint256 bestPrice, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee]);\n', '        function makeTradeDetail(address fromToken, address toToken, uint256 price, uint256 bestPrice, address maker, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee], bool makerFullfill);\n', '        function caculateFill(uint256 provide, uint256 require, uint256 price, uint256 pairProvide) internal pure returns(uint256 fillAmount);\n', '        function checkPricePair(uint256 price, uint256 bestPrice) internal pure returns(bool matched);\n', '        function fillOrder(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256 fee);\n', '        function transferToken(address user, address token, uint256 amount) internal returns(bool);\n', '        function updateBalance(address user, address token, uint256 amount, bool addOrSub) internal returns(bool);\n', '        function connectOrderPrice(address fromToken, address toToken, uint256 price, uint256 prevPrice) internal;\n', '        function connectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n', '        function disconnectOrderPrice(address fromToken, address toToken, uint256 price) internal;\n', '        function disconnectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n', '        function getNextOrderPrice(address fromToken, address toToken, uint256 price) internal view returns(uint256 price);\n', '        function updateNextOrderPrice(address fromToken, address toToken, uint256 price, uint256 nextPrice) internal;\n', '        function getNexOrdertUser(address fromToken, address toToken, uint256 price, address user) internal view returns(address nextUser);\n', '        function getOrderAmount(address fromToken, address toToken, uint256 price, address user) internal view returns(uint256 amount);\n', '        function updateNextOrderUser(address fromToken, address toToken, uint256 price, address user, address nextUser) internal;\n', '        function updateOrderAmount(address fromToken, address toToken, uint256 price, address user, uint256 amount, bool addOrSub) internal;\n', '        function logPrice(address fromToken, address toToken, uint256 price) internal;\n', '    */\n', '\n', '    /* Operator function */\n', '    function setup(\n', '        uint256 autoMatch_,\n', '        uint256 maxAmount_,\n', '        uint256 maxPrice_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        autoMatch = autoMatch_;\n', '        maxAmount = maxAmount_;\n', '        maxPrice = maxPrice_;\n', '    }\n', '    \n', '    function setMinAmount(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        minAmount[token_] = amount_;\n', '    }\n', '    \n', '    function getMinAmount(\n', '        address token_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return minAmount[token_] > 0\n', '            ? minAmount[token_]\n', '            : minAmount[0];\n', '    }\n', '    \n', '    function setFeerate(\n', '        uint256[3] feerate_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        require(feerate_[0] < 0.05 ether && feerate_[1] < 0.05 ether && feerate_[2] < 0.05 ether);\n', '        feerate = feerate_;\n', '    }\n', '\n', '    /* External function */\n', '    // fallback\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        deposit(0, 0);\n', '    }\n', '\n', '    // deposit all allowance\n', '    function deposit(\n', '        address token_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '        onlyActive\n', '    {\n', '        address user = getUser(representor_);\n', '        uint256 amount = depositAndFreeze(token_, user);\n', '        if(amount > 0) {\n', '            updateBalance(msg.sender, token_, amount, true);\n', '        }\n', '    }\n', '\n', '    function withdraw(\n', '        address token_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '    returns(bool) {\n', '        address user = getUser(representor_);\n', '        if(updateBalance(user, token_, amount_, false)) {\n', '            require(transferToken(user, token_, amount_));\n', '            return true;\n', '        }\n', '    }\n', '/*\n', '    function userMakeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '    returns(bool) {\n', '        // depositToken => makeOrder => updateBalance\n', '        uint256 depositAmount = depositAndFreeze(fromToken_, representor_);\n', '        if(\n', '            checkAmount(fromToken_, amount_) &&\n', '            checkPriceAmount(price_)\n', '        ) {\n', '            address user = getUser(representor_);\n', '            uint256 costAmount = makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\n', '\n', '            // log event: MakeOrder\n', '            eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n', '\n', '            if(costAmount < depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(depositAmount, costAmount), true);\n', '            } else if(costAmount > depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(costAmount, depositAmount), false);\n', '            }\n', '            return true;\n', '        }\n', '    }\n', '*/\n', '    function userTakeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '        onlyActive\n', '    returns(bool) {\n', '        // checkBalance => findAndTrade => userMakeOrder => updateBalance\n', '        address user = getUser(representor_);\n', '        uint256 depositAmount = depositAndFreeze(fromToken_, user);\n', '        if(\n', '            checkAmount(fromToken_, amount_) &&\n', '            checkPriceAmount(price_) &&\n', '            checkBalance(user, fromToken_, amount_, depositAmount)\n', '        ) {\n', '            // log event: MakeOrder\n', '            emit eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n', '\n', '            uint256[2] memory fillAmount;\n', '            uint256[2] memory profit;\n', '            (fillAmount, profit) = findAndTrade(fromToken_, toToken_, price_, amount_);\n', '            uint256 fee;\n', '            uint256 toAmount;\n', '            uint256 orderAmount;\n', '\n', '            if(fillAmount[0] > 0) {\n', '                // log event: makeTrade\n', '                emit eFillOrder(fromToken_, toToken_, price_, user, fillAmount[0]);\n', '\n', '                toAmount = safeDiv(safeMul(fillAmount[0], price_), 1 ether);\n', '                if(amount_ > fillAmount[0]) {\n', '                    orderAmount = safeSub(amount_, fillAmount[0]);\n', '                    makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\n', '                }\n', '                if(toAmount > 0) {\n', '                    (toAmount, fee) = caculateFee(user, toAmount, 1);\n', '                    profit[1] = profit[1] + fee;\n', '\n', '                    // save profit\n', '                    updateBalance(bank, fromToken_, profit[0], true);\n', '                    updateBalance(bank, toToken_, profit[1], true);\n', '\n', '                    // transfer to Taker\n', '                    if(manualWithdraw[user]) {\n', '                        updateBalance(user, toToken_, toAmount, true);\n', '                    } else {\n', '                        transferToken(user, toToken_, toAmount);\n', '                    }\n', '                }\n', '            } else {\n', '                orderAmount = amount_;\n', '                makeOrder(fromToken_, toToken_, price_, orderAmount, user, depositAmount);\n', '            }\n', '\n', '            // update balance\n', '            if(amount_ > depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(amount_, depositAmount), false);\n', '            } else if(amount_ < depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(depositAmount, amount_), true);\n', '            }\n', '\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function userCancelOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '    returns(bool) {\n', '        // updateOrderAmount => disconnectOrderUser => withdraw\n', '        address user = getUser(representor_);\n', '        uint256 amount = getOrderAmount(fromToken_, toToken_, price_, user);\n', '        amount = amount > amount_ ? amount_ : amount;\n', '        if(amount > 0) {\n', '            // log event: CancelOrder\n', '            emit eCancelOrder(fromToken_, toToken_, price_, user, amount);\n', '\n', '            updateOrderAmount(fromToken_, toToken_, price_, user, amount, false);\n', '            if(getOrderAmount(fromToken_, toToken_, price_, user) == 0) {\n', '                disconnectOrderUser(fromToken_, toToken_, price_, user);\n', '            }\n', '            if(manualWithdraw[user]) {\n', '                updateBalance(user, fromToken_, amount, true);\n', '            } else {\n', '                transferToken(user, fromToken_, amount);\n', '            }\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* role - 0: maker 1: taker */\n', '    function caculateFee(\n', '        address user_,\n', '        uint256 amount_,\n', '        uint8 role_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256, uint256) {\n', '        uint256 myXPABalance = Token(XPAToken).balanceOf(user_);\n', '        uint256 myFeerate = manualWithdraw[user_]\n', '            ? feerate[role_]\n', '            : feerate[role_] + feerate[2];\n', '        myFeerate =\n', '            myXPABalance > 1000000 ether ? myFeerate * 0.5 ether / 1 ether :\n', '            myXPABalance > 100000 ether ? myFeerate * 0.6 ether / 1 ether :\n', '            myXPABalance > 10000 ether ? myFeerate * 0.8 ether / 1 ether :\n', '            myFeerate;\n', '        uint256 fee = safeDiv(safeMul(amount_, myFeerate), 1 ether);\n', '        uint256 toAmount = safeSub(amount_, fee);\n', '        return(toAmount, fee);\n', '    }\n', '\n', '    function trade(\n', '        address fromToken_,\n', '        address toToken_\n', '    )\n', '        public\n', '        onlyActive\n', '    {\n', '        // Don&#39;t worry, this takes maker feerate\n', '        uint256 takerPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n', '        address taker = getNextOrderUser(fromToken_, toToken_, takerPrice, 0);\n', '        uint256 takerAmount = getOrderAmount(fromToken_, toToken_, takerPrice, taker);\n', '        /*\n', '            fillAmount[0] = TakerFill\n', '            fillAmount[1] = MakerFill\n', '            profit[0] = fromTokenProfit\n', '            profit[1] = toTokenProfit\n', '         */\n', '        uint256[2] memory fillAmount;\n', '        uint256[2] memory profit;\n', '        (fillAmount, profit) = findAndTrade(fromToken_, toToken_, takerPrice, takerAmount);\n', '        if(fillAmount[0] > 0) {\n', '            profit[1] = profit[1] + fillOrder(fromToken_, toToken_, takerPrice, taker, fillAmount[0]);\n', '\n', '            // save profit to operator\n', '            updateBalance(msg.sender, fromToken_, profit[0], true);\n', '            updateBalance(msg.sender, toToken_, profit[1], true);\n', '        }\n', '    }\n', '\n', '    function setManualWithdraw(\n', '        bool manual_\n', '    )\n', '        public\n', '    {\n', '        manualWithdraw[msg.sender] = manual_;\n', '    }\n', '\n', '    function getPrice(\n', '        address fromToken_,\n', '        address toToken_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        if(uint256(fromToken_) >= uint256(toToken_)) {\n', '            return priceBooks[fromToken_][toToken_];            \n', '        } else {\n', '            return priceBooks[toToken_][fromToken_] > 0 ? safeDiv(10 ** 36, priceBooks[toToken_][fromToken_]) : 0;\n', '        }\n', '    }\n', '\n', '    /* Internal Function */\n', '    // deposit all allowance\n', '    function depositAndFreeze(\n', '        address token_,\n', '        address user\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        uint256 amount;\n', '        if(token_ == address(0)) {\n', '            // log event: Deposit\n', '            emit eDeposit(user, address(0), msg.value);\n', '\n', '            amount = msg.value;\n', '            return amount;\n', '        } else {\n', '            if(msg.value > 0) {\n', '                // log event: Deposit\n', '                emit eDeposit(user, address(0), msg.value);\n', '\n', '                updateBalance(user, address(0), msg.value, true);\n', '            }\n', '            amount = Token(token_).allowance(msg.sender, this);\n', '            if(\n', '                amount > 0 &&\n', '                Token(token_).transferFrom(msg.sender, this, amount)\n', '            ) {\n', '                // log event: Deposit\n', '                emit eDeposit(user, token_, amount);\n', '\n', '                return amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function checkBalance(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_,\n', '        uint256 depositAmount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(safeAdd(balances[user_][token_], depositAmount_) >= amount_) {\n', '            return true;\n', '        } else {\n', '            emit Error(0);\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function checkAmount(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        uint256 min = getMinAmount(token_);\n', '        if(amount_ > maxAmount || amount_ < min) {\n', '            emit Error(2);\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function checkPriceAmount(\n', '        uint256 price_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(price_ == 0 || price_ > maxPrice) {\n', '            emit Error(3);\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function makeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address user_,\n', '        uint256 depositAmount_\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        if(checkBalance(user_, fromToken_, amount_, depositAmount_)) {\n', '            updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, true);\n', '            connectOrderPrice(fromToken_, toToken_, price_, 0);\n', '            connectOrderUser(fromToken_, toToken_, price_, user_);\n', '            return amount_;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function findAndTrade(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(uint256[2], uint256[2]) {\n', '        /*\n', '            totalMatchAmount[0]: Taker total match amount\n', '            totalMatchAmount[1]: Maker total match amount\n', '            profit[0]: fromToken profit\n', '            profit[1]: toToken profit\n', '            matchAmount[0]: Taker match amount\n', '            matchAmount[1]: Maker match amount\n', '         */\n', '        uint256[2] memory totalMatchAmount;\n', '        uint256[2] memory profit;\n', '        uint256[3] memory matchAmount;\n', '        uint256 toAmount;\n', '        uint256 remaining = amount_;\n', '        uint256 matches = 0;\n', '        uint256 prevBestPrice = 0;\n', '        uint256 bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n', '        for(; matches < autoMatch && remaining > 0;) {\n', '            matchAmount = makeTrade(fromToken_, toToken_, price_, bestPrice, remaining);\n', '            if(matchAmount[0] > 0) {\n', '                remaining = safeSub(remaining, matchAmount[0]);\n', '                totalMatchAmount[0] = safeAdd(totalMatchAmount[0], matchAmount[0]);\n', '                totalMatchAmount[1] = safeAdd(totalMatchAmount[1], matchAmount[1]);\n', '                profit[0] = safeAdd(profit[0], matchAmount[2]);\n', '                \n', '                // for next loop\n', '                matches++;\n', '                prevBestPrice = bestPrice;\n', '                bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '\n', '        if(totalMatchAmount[0] > 0) {\n', '            // log price\n', '            logPrice(toToken_, fromToken_, prevBestPrice);\n', '\n', '            // calculating spread profit\n', '            toAmount = safeDiv(safeMul(totalMatchAmount[0], price_), 1 ether);\n', '            profit[1] = safeSub(totalMatchAmount[1], toAmount);\n', '            if(totalMatchAmount[1] >= safeDiv(safeMul(amount_, price_), 1 ether)) {\n', '                // fromProfit += amount_ - takerFill;\n', '                profit[0] = profit[0] + amount_ - totalMatchAmount[0];\n', '                // fullfill Taker order\n', '                totalMatchAmount[0] = amount_;\n', '            } else {\n', '                toAmount = totalMatchAmount[1];\n', '                // fromProfit += takerFill - (toAmount / price_ * 1 ether)\n', '                profit[0] = profit[0] + totalMatchAmount[0] - (toAmount * 1 ether /price_);\n', '                // (real) takerFill = toAmount / price_ * 1 ether\n', '                totalMatchAmount[0] = safeDiv(safeMul(toAmount, 1 ether), price_);\n', '            }\n', '        }\n', '\n', '        return (totalMatchAmount, profit);\n', '    }\n', '\n', '    function makeTrade(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 bestPrice_,\n', '        uint256 remaining_\n', '    )\n', '        internal\n', '    returns(uint256[3]) {\n', '        if(checkPricePair(price_, bestPrice_)) {\n', '            address prevMaker = address(0);\n', '            address maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, 0);\n', '            uint256 remaining = remaining_;\n', '\n', '            /*\n', '                totalFill[0]: Total Taker fillAmount\n', '                totalFill[1]: Total Maker fillAmount\n', '                totalFill[2]: Total Maker fee\n', '             */\n', '            uint256[3] memory totalFill;\n', '            for(uint256 i = 0; i < autoMatch && remaining > 0 && maker != address(0); i++) {\n', '                uint256[3] memory fill;\n', '                bool fullfill;\n', '                (fill, fullfill) = makeTradeDetail(fromToken_, toToken_, price_, bestPrice_, maker, remaining);\n', '                if(fill[0] > 0) {\n', '                    if(fullfill) {\n', '                        disconnectOrderUser(toToken_, fromToken_, bestPrice_, maker);\n', '                    }\n', '                    remaining = safeSub(remaining, fill[0]);\n', '                    totalFill[0] = safeAdd(totalFill[0], fill[0]);\n', '                    totalFill[1] = safeAdd(totalFill[1], fill[1]);\n', '                    totalFill[2] = safeAdd(totalFill[2], fill[2]);\n', '                    prevMaker = maker;\n', '                    maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, prevMaker);\n', '                    if(maker == address(0)) {\n', '                        break;\n', '                    }\n', '                } else {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return totalFill;\n', '    }\n', '\n', '    function makeTradeDetail(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 bestPrice_,\n', '        address maker_,\n', '        uint256 remaining_\n', '    )\n', '        internal\n', '    returns(uint256[3], bool) {\n', '        /*\n', '            fillAmount[0]: Taker fillAmount\n', '            fillAmount[1]: Maker fillAmount\n', '            fillAmount[2]: Maker fee\n', '         */\n', '        uint256[3] memory fillAmount;\n', '        uint256 takerProvide = remaining_;\n', '        uint256 takerRequire = safeDiv(safeMul(takerProvide, price_), 1 ether);\n', '        uint256 makerProvide = getOrderAmount(toToken_, fromToken_, bestPrice_, maker_);\n', '        uint256 makerRequire = safeDiv(safeMul(makerProvide, bestPrice_), 1 ether);\n', '        fillAmount[0] = caculateFill(takerProvide, takerRequire, price_, makerProvide);\n', '        fillAmount[1] = caculateFill(makerProvide, makerRequire, bestPrice_, takerProvide);\n', '        fillAmount[2] = fillOrder(toToken_, fromToken_, bestPrice_, maker_, fillAmount[1]);\n', '        return (fillAmount, (makerRequire <= takerProvide));\n', '    }\n', '\n', '    function caculateFill(\n', '        uint256 provide_,\n', '        uint256 require_,\n', '        uint256 price_,\n', '        uint256 pairProvide_\n', '    )\n', '        internal\n', '        pure\n', '    returns(uint256) {\n', '        return require_ > pairProvide_ ? safeDiv(safeMul(pairProvide_, 1 ether), price_) : provide_;\n', '    }\n', '\n', '    function checkPricePair(\n', '        uint256 price_,\n', '        uint256 bestPrice_\n', '    )\n', '        internal pure \n', '    returns(bool) {\n', '        if(bestPrice_ < price_) {\n', '            return checkPricePair(bestPrice_, price_);\n', '        } else if(bestPrice_ < 1 ether) {\n', '            return true;\n', '        } else if(price_ > 1 ether) {\n', '            return false;\n', '        } else {\n', '            return price_ * bestPrice_ <= 1 ether * 1 ether;\n', '        }\n', '    }\n', '\n', '    function fillOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        // log event: fillOrder\n', '        emit eFillOrder(fromToken_, toToken_, price_, user_, amount_);\n', '\n', '        uint256 toAmount = safeDiv(safeMul(amount_, price_), 1 ether);\n', '        uint256 fee;\n', '        updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, false);\n', '        (toAmount, fee) = caculateFee(user_, toAmount, 0);\n', '        if(manualWithdraw[user_]) {\n', '            updateBalance(user_, toToken_, toAmount, true);\n', '        } else {\n', '            transferToken(user_, toToken_, toAmount);\n', '        }\n', '        return fee;\n', '    }\n', '    function transferToken(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(token_ == address(0)) {\n', '            if(address(this).balance < amount_) {\n', '                emit Error(1);\n', '                return false;\n', '            } else {\n', '                // log event: Withdraw\n', '                emit eWithdraw(user_, token_, amount_);\n', '\n', '                user_.transfer(amount_);\n', '                return true;\n', '            }\n', '        } else if(Token(token_).transfer(user_, amount_)) {\n', '            // log event: Withdraw\n', '            emit eWithdraw(user_, token_, amount_);\n', '\n', '            return true;\n', '        } else {\n', '            emit Error(1);\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function updateBalance(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_,\n', '        bool addOrSub_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(addOrSub_) {\n', '            balances[user_][token_] = safeAdd(balances[user_][token_], amount_);\n', '        } else {\n', '            if(checkBalance(user_, token_, amount_, 0)){\n', '                balances[user_][token_] = safeSub(balances[user_][token_], amount_);\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        }\n', '    }\n', '\n', '    function connectOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 prev_\n', '    )\n', '        internal\n', '    {\n', '        if(checkPriceAmount(price_)) {\n', '            uint256 prevPrice = getNextOrderPrice(fromToken_, toToken_, prev_);\n', '            uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, prevPrice);\n', '            if(prev_ != price_ && prevPrice != price_ && nextPrice != price_) {\n', '                if(price_ < prevPrice) {\n', '                    updateNextOrderPrice(fromToken_, toToken_, prev_, price_);\n', '                    updateNextOrderPrice(fromToken_, toToken_, price_, prevPrice);\n', '                } else if(nextPrice == 0) {\n', '                    updateNextOrderPrice(fromToken_, toToken_, prevPrice, price_);\n', '                } else {\n', '                    connectOrderPrice(fromToken_, toToken_, price_, prevPrice);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function connectOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal \n', '    {\n', '        address firstUser = getNextOrderUser(fromToken_, toToken_, price_, 0);\n', '        if(user_ != address(0) && user_ != firstUser) {\n', '            updateNextOrderUser(fromToken_, toToken_, price_, 0, user_);\n', '            if(firstUser != address(0)) {\n', '                updateNextOrderUser(fromToken_, toToken_, price_, user_, firstUser);\n', '            }\n', '        }\n', '    }\n', '\n', '    function disconnectOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '    {\n', '        uint256 currPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n', '        uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, currPrice);\n', '        if(price_ == currPrice) {\n', '            updateNextOrderPrice(fromToken_, toToken_, 0, nextPrice);\n', '        }\n', '    }\n', '\n', '    function disconnectOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '    {\n', '        if(user_ == address(0)) {\n', '            return;\n', '        }\n', '        address currUser = getNextOrderUser(fromToken_, toToken_, price_, address(0));\n', '        address nextUser = getNextOrderUser(fromToken_, toToken_, price_, currUser);\n', '        if(currUser == user_) {\n', '            updateNextOrderUser(fromToken_, toToken_, price_, address(0), nextUser);\n', '            if(nextUser == address(0)) {\n', '                disconnectOrderPrice(fromToken_, toToken_, price_);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getNextOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '        view\n', '    returns(uint256) {\n', '        return nextOrderPrice[fromToken_][toToken_][price_];\n', '    }\n', '\n', '    function updateNextOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 nextPrice_\n', '    )\n', '        internal\n', '    {\n', '        nextOrderPrice[fromToken_][toToken_][price_] = nextPrice_;\n', '    }\n', '\n', '    function getNextOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '        view\n', '    returns(address) {\n', '        return orderBooks[fromToken_][toToken_][price_][user_].nextUser;\n', '    }\n', '\n', '    function getOrderAmount(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '        view\n', '    returns(uint256) {\n', '        return orderBooks[fromToken_][toToken_][price_][user_].amount;\n', '    }\n', '\n', '    function updateNextOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        address nextUser_\n', '    )\n', '        internal\n', '    {\n', '        orderBooks[fromToken_][toToken_][price_][user_].nextUser = nextUser_;\n', '    }\n', '\n', '    function updateOrderAmount(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        uint256 amount_,\n', '        bool addOrSub_\n', '    )\n', '        internal\n', '    {\n', '        if(addOrSub_) {\n', '            orderBooks[fromToken_][toToken_][price_][user_].amount = safeAdd(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n', '        } else {\n', '            orderBooks[fromToken_][toToken_][price_][user_].amount = safeSub(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n', '        }\n', '    }\n', '\n', '    function logPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '    {\n', '        if(price_ > 0) {\n', '            if(uint256(fromToken_) >= uint256(toToken_)) {\n', '                priceBooks[fromToken_][toToken_] = price_;\n', '            } else  {\n', '                priceBooks[toToken_][fromToken_] = safeDiv(10 ** 36, price_);\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/*\n', 'Project: XPA Exchange - https://xpa.exchange\n', 'Author : Luphia Chang - luphia.chang@isuncloud.com\n', ' */\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint256 z = x + y;\n', '      require((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      require(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint z = x * y;\n', '      require((x == 0) || (z / x == y));\n', '      return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '      bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '      return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => address) public agentBooks;\n', '    address public owner;\n', '    address public operator;\n', '    address public bank;\n', '    bool public powerStatus = true;\n', '\n', '    function Authorization()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        operator = msg.sender;\n', '        bank = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(msg.sender == operator || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyActive\n', '    {\n', '        assert(powerStatus);\n', '        _;\n', '    }\n', '\n', '    function powerSwitch(\n', '        bool onOff_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        powerStatus = onOff_;\n', '    }\n', '\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        operator = user_;\n', '        agentBooks[bank] = user_;\n', '    }\n', '    \n', '    function assignBank(address bank_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bank = bank_;\n', '    }\n', '\n', '    function assignAgent(\n', '        address agent_\n', '    )\n', '        public\n', '    {\n', '        agentBooks[msg.sender] = agent_;\n', '    }\n', '\n', '    function isRepresentor(\n', '        address representor_\n', '    )\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return agentBooks[representor_] == msg.sender;\n', '    }\n', '\n', '    function getUser(\n', '        address representor_\n', '    )\n', '        internal\n', '        view\n', '    returns(address) {\n', '        return isRepresentor(representor_) ? representor_ : msg.sender;\n', '    }\n', '}\n', '\n', '/*  Error Code\n', '    0: insufficient funds (user)\n', '    1: insufficient funds (contract)\n', '    2: invalid amount\n', '    3: invalid price\n', ' */\n', '\n', '/*\n', '    1. 檢驗是否指定代理用戶，若是且為合法代理人則將操作角色轉換為被代理人，否則操作角色不變\n', '    2. 檢驗此操作是否有存入 ETH，有則暫時紀錄存入額度 A，若掛單指定 fromToken 不是 ETH 則直接更新用戶 ETH 帳戶餘額\n', '    3. 檢驗此操作是否有存入 fromToken，有則暫時紀錄存入額度 A\n', '    4. 檢驗用戶 fromToken 帳戶餘額 + 存入額度 A 是否 >= Amount，若是送出 makeOrder 掛單事件，否則結束操作\n', '    5. 依照 fromToken、toToken 尋找可匹配的交易對 P\n', '    6. 找出 P 的最低價格單進行匹配，記錄匹配數量，送出 fillOrder 成交事件，並結算 maker 交易結果，若成交完還有掛單數量有剩且未達迴圈次數上限則重複此步驟\n', '    7. 統計步驟 6 總成交量、交易價差利潤、交易手續費\n', '    8. 若扣除總成交量後 Taker 掛單尚未撮合完，則將剩餘額度轉換為 Maker 單\n', '    9. 結算交易所手續費\n', '    10. 結算 Taker 交易結果\n', ' */\n', '\n', 'contract Baliv is SafeMath, Authorization {\n', '    /* struct for exchange data */\n', '    struct linkedBook {\n', '        uint256 amount;\n', '        address nextUser;\n', '    }\n', '\n', '    /* business options */\n', '    mapping(address => uint256) public minAmount;\n', '    uint256[3] public feerate = [0, 1 * (10 ** 15), 1 * (10 ** 15)];\n', '    uint256 public autoMatch = 10;\n', '    uint256 public maxAmount = 10 ** 27;\n', '    uint256 public maxPrice = 10 ** 36;\n', '    address public XPAToken = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '\n', '    /* exchange data */\n', '    mapping(address => mapping(address => mapping(uint256 => mapping(address => linkedBook)))) public orderBooks;\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public nextOrderPrice;\n', '    mapping(address => mapping(address => uint256)) public priceBooks;\n', '    \n', '    /* user data */\n', '    mapping(address => mapping(address => uint256)) public balances;\n', '    mapping(address => bool) internal manualWithdraw;\n', '\n', '    /* event */\n', '    event eDeposit(address user,address token, uint256 amount);\n', '    event eWithdraw(address user,address token, uint256 amount);\n', '    event eMakeOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '    event eFillOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '    event eCancelOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n', '\n', '    event Error(uint256 code);\n', '\n', '    /* constructor */\n', '    function Baliv() public {\n', '        minAmount[0] = 10 ** 16;\n', '    }\n', '\n', '    /* Operator Function\n', '        function setup(uint256 autoMatch, uint256 maxAmount, uint256 maxPrice) external;\n', '        function setMinAmount(address token, uint256 amount) external;\n', '        function setFeerate(uint256[3] [maker, taker, autoWithdraw]) external;\n', '    */\n', '\n', '    /* External Function\n', '        function () public payable;\n', '        function deposit(address token, address representor) external payable;\n', '        function withdraw(address token, uint256 amount, address representor) external returns(bool);\n', '        function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '        function userCancelOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external returns(bool);\n', '        function caculateFee(address user, uint256 amount, uint8 role) external returns(uint256 remaining, uint256 fee);\n', '        function trade(address fromToken, address toToken) external;\n', '        function setManualWithdraw(bool) external;\n', '        function getMinAmount(address) external returns(uint256);\n', '        function getPrice(address fromToken, address toToken) external returns(uint256);\n', '    */\n', '\n', '    /* Internal Function\n', '        function depositAndFreeze(address token, address user) internal payable returns(uint256 amount);\n', '        function checkBalance(address user, address token, uint256 amount, uint256 depositAmount) internal returns(bool);\n', '        function checkAmount(address token, uint256 amount) internal returns(bool);\n', '        function checkPriceAmount(uint256 price) internal returns(bool);\n', '        function makeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address user, uint256 depositAmount) internal returns(uint256 amount);\n', '        function findAndTrade(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256[2] totalMatchAmount[fromToken, toToken], uint256[2] profit[fromToken, toToken]);\n', '        function makeTrade(address fromToken, address toToken, uint256 price, uint256 bestPrice, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee]);\n', '        function makeTradeDetail(address fromToken, address toToken, uint256 price, uint256 bestPrice, address maker, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee], bool makerFullfill);\n', '        function caculateFill(uint256 provide, uint256 require, uint256 price, uint256 pairProvide) internal pure returns(uint256 fillAmount);\n', '        function checkPricePair(uint256 price, uint256 bestPrice) internal pure returns(bool matched);\n', '        function fillOrder(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256 fee);\n', '        function transferToken(address user, address token, uint256 amount) internal returns(bool);\n', '        function updateBalance(address user, address token, uint256 amount, bool addOrSub) internal returns(bool);\n', '        function connectOrderPrice(address fromToken, address toToken, uint256 price, uint256 prevPrice) internal;\n', '        function connectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n', '        function disconnectOrderPrice(address fromToken, address toToken, uint256 price) internal;\n', '        function disconnectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n', '        function getNextOrderPrice(address fromToken, address toToken, uint256 price) internal view returns(uint256 price);\n', '        function updateNextOrderPrice(address fromToken, address toToken, uint256 price, uint256 nextPrice) internal;\n', '        function getNexOrdertUser(address fromToken, address toToken, uint256 price, address user) internal view returns(address nextUser);\n', '        function getOrderAmount(address fromToken, address toToken, uint256 price, address user) internal view returns(uint256 amount);\n', '        function updateNextOrderUser(address fromToken, address toToken, uint256 price, address user, address nextUser) internal;\n', '        function updateOrderAmount(address fromToken, address toToken, uint256 price, address user, uint256 amount, bool addOrSub) internal;\n', '        function logPrice(address fromToken, address toToken, uint256 price) internal;\n', '    */\n', '\n', '    /* Operator function */\n', '    function setup(\n', '        uint256 autoMatch_,\n', '        uint256 maxAmount_,\n', '        uint256 maxPrice_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        autoMatch = autoMatch_;\n', '        maxAmount = maxAmount_;\n', '        maxPrice = maxPrice_;\n', '    }\n', '    \n', '    function setMinAmount(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        minAmount[token_] = amount_;\n', '    }\n', '    \n', '    function getMinAmount(\n', '        address token_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return minAmount[token_] > 0\n', '            ? minAmount[token_]\n', '            : minAmount[0];\n', '    }\n', '    \n', '    function setFeerate(\n', '        uint256[3] feerate_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        require(feerate_[0] < 0.05 ether && feerate_[1] < 0.05 ether && feerate_[2] < 0.05 ether);\n', '        feerate = feerate_;\n', '    }\n', '\n', '    /* External function */\n', '    // fallback\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        deposit(0, 0);\n', '    }\n', '\n', '    // deposit all allowance\n', '    function deposit(\n', '        address token_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '        onlyActive\n', '    {\n', '        address user = getUser(representor_);\n', '        uint256 amount = depositAndFreeze(token_, user);\n', '        if(amount > 0) {\n', '            updateBalance(msg.sender, token_, amount, true);\n', '        }\n', '    }\n', '\n', '    function withdraw(\n', '        address token_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '    returns(bool) {\n', '        address user = getUser(representor_);\n', '        if(updateBalance(user, token_, amount_, false)) {\n', '            require(transferToken(user, token_, amount_));\n', '            return true;\n', '        }\n', '    }\n', '/*\n', '    function userMakeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '    returns(bool) {\n', '        // depositToken => makeOrder => updateBalance\n', '        uint256 depositAmount = depositAndFreeze(fromToken_, representor_);\n', '        if(\n', '            checkAmount(fromToken_, amount_) &&\n', '            checkPriceAmount(price_)\n', '        ) {\n', '            address user = getUser(representor_);\n', '            uint256 costAmount = makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\n', '\n', '            // log event: MakeOrder\n', '            eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n', '\n', '            if(costAmount < depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(depositAmount, costAmount), true);\n', '            } else if(costAmount > depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(costAmount, depositAmount), false);\n', '            }\n', '            return true;\n', '        }\n', '    }\n', '*/\n', '    function userTakeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '        payable\n', '        onlyActive\n', '    returns(bool) {\n', '        // checkBalance => findAndTrade => userMakeOrder => updateBalance\n', '        address user = getUser(representor_);\n', '        uint256 depositAmount = depositAndFreeze(fromToken_, user);\n', '        if(\n', '            checkAmount(fromToken_, amount_) &&\n', '            checkPriceAmount(price_) &&\n', '            checkBalance(user, fromToken_, amount_, depositAmount)\n', '        ) {\n', '            // log event: MakeOrder\n', '            emit eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n', '\n', '            uint256[2] memory fillAmount;\n', '            uint256[2] memory profit;\n', '            (fillAmount, profit) = findAndTrade(fromToken_, toToken_, price_, amount_);\n', '            uint256 fee;\n', '            uint256 toAmount;\n', '            uint256 orderAmount;\n', '\n', '            if(fillAmount[0] > 0) {\n', '                // log event: makeTrade\n', '                emit eFillOrder(fromToken_, toToken_, price_, user, fillAmount[0]);\n', '\n', '                toAmount = safeDiv(safeMul(fillAmount[0], price_), 1 ether);\n', '                if(amount_ > fillAmount[0]) {\n', '                    orderAmount = safeSub(amount_, fillAmount[0]);\n', '                    makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\n', '                }\n', '                if(toAmount > 0) {\n', '                    (toAmount, fee) = caculateFee(user, toAmount, 1);\n', '                    profit[1] = profit[1] + fee;\n', '\n', '                    // save profit\n', '                    updateBalance(bank, fromToken_, profit[0], true);\n', '                    updateBalance(bank, toToken_, profit[1], true);\n', '\n', '                    // transfer to Taker\n', '                    if(manualWithdraw[user]) {\n', '                        updateBalance(user, toToken_, toAmount, true);\n', '                    } else {\n', '                        transferToken(user, toToken_, toAmount);\n', '                    }\n', '                }\n', '            } else {\n', '                orderAmount = amount_;\n', '                makeOrder(fromToken_, toToken_, price_, orderAmount, user, depositAmount);\n', '            }\n', '\n', '            // update balance\n', '            if(amount_ > depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(amount_, depositAmount), false);\n', '            } else if(amount_ < depositAmount) {\n', '                updateBalance(user, fromToken_, safeSub(depositAmount, amount_), true);\n', '            }\n', '\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function userCancelOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        public\n', '    returns(bool) {\n', '        // updateOrderAmount => disconnectOrderUser => withdraw\n', '        address user = getUser(representor_);\n', '        uint256 amount = getOrderAmount(fromToken_, toToken_, price_, user);\n', '        amount = amount > amount_ ? amount_ : amount;\n', '        if(amount > 0) {\n', '            // log event: CancelOrder\n', '            emit eCancelOrder(fromToken_, toToken_, price_, user, amount);\n', '\n', '            updateOrderAmount(fromToken_, toToken_, price_, user, amount, false);\n', '            if(getOrderAmount(fromToken_, toToken_, price_, user) == 0) {\n', '                disconnectOrderUser(fromToken_, toToken_, price_, user);\n', '            }\n', '            if(manualWithdraw[user]) {\n', '                updateBalance(user, fromToken_, amount, true);\n', '            } else {\n', '                transferToken(user, fromToken_, amount);\n', '            }\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* role - 0: maker 1: taker */\n', '    function caculateFee(\n', '        address user_,\n', '        uint256 amount_,\n', '        uint8 role_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256, uint256) {\n', '        uint256 myXPABalance = Token(XPAToken).balanceOf(user_);\n', '        uint256 myFeerate = manualWithdraw[user_]\n', '            ? feerate[role_]\n', '            : feerate[role_] + feerate[2];\n', '        myFeerate =\n', '            myXPABalance > 1000000 ether ? myFeerate * 0.5 ether / 1 ether :\n', '            myXPABalance > 100000 ether ? myFeerate * 0.6 ether / 1 ether :\n', '            myXPABalance > 10000 ether ? myFeerate * 0.8 ether / 1 ether :\n', '            myFeerate;\n', '        uint256 fee = safeDiv(safeMul(amount_, myFeerate), 1 ether);\n', '        uint256 toAmount = safeSub(amount_, fee);\n', '        return(toAmount, fee);\n', '    }\n', '\n', '    function trade(\n', '        address fromToken_,\n', '        address toToken_\n', '    )\n', '        public\n', '        onlyActive\n', '    {\n', "        // Don't worry, this takes maker feerate\n", '        uint256 takerPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n', '        address taker = getNextOrderUser(fromToken_, toToken_, takerPrice, 0);\n', '        uint256 takerAmount = getOrderAmount(fromToken_, toToken_, takerPrice, taker);\n', '        /*\n', '            fillAmount[0] = TakerFill\n', '            fillAmount[1] = MakerFill\n', '            profit[0] = fromTokenProfit\n', '            profit[1] = toTokenProfit\n', '         */\n', '        uint256[2] memory fillAmount;\n', '        uint256[2] memory profit;\n', '        (fillAmount, profit) = findAndTrade(fromToken_, toToken_, takerPrice, takerAmount);\n', '        if(fillAmount[0] > 0) {\n', '            profit[1] = profit[1] + fillOrder(fromToken_, toToken_, takerPrice, taker, fillAmount[0]);\n', '\n', '            // save profit to operator\n', '            updateBalance(msg.sender, fromToken_, profit[0], true);\n', '            updateBalance(msg.sender, toToken_, profit[1], true);\n', '        }\n', '    }\n', '\n', '    function setManualWithdraw(\n', '        bool manual_\n', '    )\n', '        public\n', '    {\n', '        manualWithdraw[msg.sender] = manual_;\n', '    }\n', '\n', '    function getPrice(\n', '        address fromToken_,\n', '        address toToken_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        if(uint256(fromToken_) >= uint256(toToken_)) {\n', '            return priceBooks[fromToken_][toToken_];            \n', '        } else {\n', '            return priceBooks[toToken_][fromToken_] > 0 ? safeDiv(10 ** 36, priceBooks[toToken_][fromToken_]) : 0;\n', '        }\n', '    }\n', '\n', '    /* Internal Function */\n', '    // deposit all allowance\n', '    function depositAndFreeze(\n', '        address token_,\n', '        address user\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        uint256 amount;\n', '        if(token_ == address(0)) {\n', '            // log event: Deposit\n', '            emit eDeposit(user, address(0), msg.value);\n', '\n', '            amount = msg.value;\n', '            return amount;\n', '        } else {\n', '            if(msg.value > 0) {\n', '                // log event: Deposit\n', '                emit eDeposit(user, address(0), msg.value);\n', '\n', '                updateBalance(user, address(0), msg.value, true);\n', '            }\n', '            amount = Token(token_).allowance(msg.sender, this);\n', '            if(\n', '                amount > 0 &&\n', '                Token(token_).transferFrom(msg.sender, this, amount)\n', '            ) {\n', '                // log event: Deposit\n', '                emit eDeposit(user, token_, amount);\n', '\n', '                return amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function checkBalance(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_,\n', '        uint256 depositAmount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(safeAdd(balances[user_][token_], depositAmount_) >= amount_) {\n', '            return true;\n', '        } else {\n', '            emit Error(0);\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function checkAmount(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        uint256 min = getMinAmount(token_);\n', '        if(amount_ > maxAmount || amount_ < min) {\n', '            emit Error(2);\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function checkPriceAmount(\n', '        uint256 price_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(price_ == 0 || price_ > maxPrice) {\n', '            emit Error(3);\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function makeOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_,\n', '        address user_,\n', '        uint256 depositAmount_\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        if(checkBalance(user_, fromToken_, amount_, depositAmount_)) {\n', '            updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, true);\n', '            connectOrderPrice(fromToken_, toToken_, price_, 0);\n', '            connectOrderUser(fromToken_, toToken_, price_, user_);\n', '            return amount_;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function findAndTrade(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(uint256[2], uint256[2]) {\n', '        /*\n', '            totalMatchAmount[0]: Taker total match amount\n', '            totalMatchAmount[1]: Maker total match amount\n', '            profit[0]: fromToken profit\n', '            profit[1]: toToken profit\n', '            matchAmount[0]: Taker match amount\n', '            matchAmount[1]: Maker match amount\n', '         */\n', '        uint256[2] memory totalMatchAmount;\n', '        uint256[2] memory profit;\n', '        uint256[3] memory matchAmount;\n', '        uint256 toAmount;\n', '        uint256 remaining = amount_;\n', '        uint256 matches = 0;\n', '        uint256 prevBestPrice = 0;\n', '        uint256 bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n', '        for(; matches < autoMatch && remaining > 0;) {\n', '            matchAmount = makeTrade(fromToken_, toToken_, price_, bestPrice, remaining);\n', '            if(matchAmount[0] > 0) {\n', '                remaining = safeSub(remaining, matchAmount[0]);\n', '                totalMatchAmount[0] = safeAdd(totalMatchAmount[0], matchAmount[0]);\n', '                totalMatchAmount[1] = safeAdd(totalMatchAmount[1], matchAmount[1]);\n', '                profit[0] = safeAdd(profit[0], matchAmount[2]);\n', '                \n', '                // for next loop\n', '                matches++;\n', '                prevBestPrice = bestPrice;\n', '                bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '\n', '        if(totalMatchAmount[0] > 0) {\n', '            // log price\n', '            logPrice(toToken_, fromToken_, prevBestPrice);\n', '\n', '            // calculating spread profit\n', '            toAmount = safeDiv(safeMul(totalMatchAmount[0], price_), 1 ether);\n', '            profit[1] = safeSub(totalMatchAmount[1], toAmount);\n', '            if(totalMatchAmount[1] >= safeDiv(safeMul(amount_, price_), 1 ether)) {\n', '                // fromProfit += amount_ - takerFill;\n', '                profit[0] = profit[0] + amount_ - totalMatchAmount[0];\n', '                // fullfill Taker order\n', '                totalMatchAmount[0] = amount_;\n', '            } else {\n', '                toAmount = totalMatchAmount[1];\n', '                // fromProfit += takerFill - (toAmount / price_ * 1 ether)\n', '                profit[0] = profit[0] + totalMatchAmount[0] - (toAmount * 1 ether /price_);\n', '                // (real) takerFill = toAmount / price_ * 1 ether\n', '                totalMatchAmount[0] = safeDiv(safeMul(toAmount, 1 ether), price_);\n', '            }\n', '        }\n', '\n', '        return (totalMatchAmount, profit);\n', '    }\n', '\n', '    function makeTrade(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 bestPrice_,\n', '        uint256 remaining_\n', '    )\n', '        internal\n', '    returns(uint256[3]) {\n', '        if(checkPricePair(price_, bestPrice_)) {\n', '            address prevMaker = address(0);\n', '            address maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, 0);\n', '            uint256 remaining = remaining_;\n', '\n', '            /*\n', '                totalFill[0]: Total Taker fillAmount\n', '                totalFill[1]: Total Maker fillAmount\n', '                totalFill[2]: Total Maker fee\n', '             */\n', '            uint256[3] memory totalFill;\n', '            for(uint256 i = 0; i < autoMatch && remaining > 0 && maker != address(0); i++) {\n', '                uint256[3] memory fill;\n', '                bool fullfill;\n', '                (fill, fullfill) = makeTradeDetail(fromToken_, toToken_, price_, bestPrice_, maker, remaining);\n', '                if(fill[0] > 0) {\n', '                    if(fullfill) {\n', '                        disconnectOrderUser(toToken_, fromToken_, bestPrice_, maker);\n', '                    }\n', '                    remaining = safeSub(remaining, fill[0]);\n', '                    totalFill[0] = safeAdd(totalFill[0], fill[0]);\n', '                    totalFill[1] = safeAdd(totalFill[1], fill[1]);\n', '                    totalFill[2] = safeAdd(totalFill[2], fill[2]);\n', '                    prevMaker = maker;\n', '                    maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, prevMaker);\n', '                    if(maker == address(0)) {\n', '                        break;\n', '                    }\n', '                } else {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return totalFill;\n', '    }\n', '\n', '    function makeTradeDetail(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 bestPrice_,\n', '        address maker_,\n', '        uint256 remaining_\n', '    )\n', '        internal\n', '    returns(uint256[3], bool) {\n', '        /*\n', '            fillAmount[0]: Taker fillAmount\n', '            fillAmount[1]: Maker fillAmount\n', '            fillAmount[2]: Maker fee\n', '         */\n', '        uint256[3] memory fillAmount;\n', '        uint256 takerProvide = remaining_;\n', '        uint256 takerRequire = safeDiv(safeMul(takerProvide, price_), 1 ether);\n', '        uint256 makerProvide = getOrderAmount(toToken_, fromToken_, bestPrice_, maker_);\n', '        uint256 makerRequire = safeDiv(safeMul(makerProvide, bestPrice_), 1 ether);\n', '        fillAmount[0] = caculateFill(takerProvide, takerRequire, price_, makerProvide);\n', '        fillAmount[1] = caculateFill(makerProvide, makerRequire, bestPrice_, takerProvide);\n', '        fillAmount[2] = fillOrder(toToken_, fromToken_, bestPrice_, maker_, fillAmount[1]);\n', '        return (fillAmount, (makerRequire <= takerProvide));\n', '    }\n', '\n', '    function caculateFill(\n', '        uint256 provide_,\n', '        uint256 require_,\n', '        uint256 price_,\n', '        uint256 pairProvide_\n', '    )\n', '        internal\n', '        pure\n', '    returns(uint256) {\n', '        return require_ > pairProvide_ ? safeDiv(safeMul(pairProvide_, 1 ether), price_) : provide_;\n', '    }\n', '\n', '    function checkPricePair(\n', '        uint256 price_,\n', '        uint256 bestPrice_\n', '    )\n', '        internal pure \n', '    returns(bool) {\n', '        if(bestPrice_ < price_) {\n', '            return checkPricePair(bestPrice_, price_);\n', '        } else if(bestPrice_ < 1 ether) {\n', '            return true;\n', '        } else if(price_ > 1 ether) {\n', '            return false;\n', '        } else {\n', '            return price_ * bestPrice_ <= 1 ether * 1 ether;\n', '        }\n', '    }\n', '\n', '    function fillOrder(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(uint256) {\n', '        // log event: fillOrder\n', '        emit eFillOrder(fromToken_, toToken_, price_, user_, amount_);\n', '\n', '        uint256 toAmount = safeDiv(safeMul(amount_, price_), 1 ether);\n', '        uint256 fee;\n', '        updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, false);\n', '        (toAmount, fee) = caculateFee(user_, toAmount, 0);\n', '        if(manualWithdraw[user_]) {\n', '            updateBalance(user_, toToken_, toAmount, true);\n', '        } else {\n', '            transferToken(user_, toToken_, toAmount);\n', '        }\n', '        return fee;\n', '    }\n', '    function transferToken(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(token_ == address(0)) {\n', '            if(address(this).balance < amount_) {\n', '                emit Error(1);\n', '                return false;\n', '            } else {\n', '                // log event: Withdraw\n', '                emit eWithdraw(user_, token_, amount_);\n', '\n', '                user_.transfer(amount_);\n', '                return true;\n', '            }\n', '        } else if(Token(token_).transfer(user_, amount_)) {\n', '            // log event: Withdraw\n', '            emit eWithdraw(user_, token_, amount_);\n', '\n', '            return true;\n', '        } else {\n', '            emit Error(1);\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function updateBalance(\n', '        address user_,\n', '        address token_,\n', '        uint256 amount_,\n', '        bool addOrSub_\n', '    )\n', '        internal\n', '    returns(bool) {\n', '        if(addOrSub_) {\n', '            balances[user_][token_] = safeAdd(balances[user_][token_], amount_);\n', '        } else {\n', '            if(checkBalance(user_, token_, amount_, 0)){\n', '                balances[user_][token_] = safeSub(balances[user_][token_], amount_);\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        }\n', '    }\n', '\n', '    function connectOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 prev_\n', '    )\n', '        internal\n', '    {\n', '        if(checkPriceAmount(price_)) {\n', '            uint256 prevPrice = getNextOrderPrice(fromToken_, toToken_, prev_);\n', '            uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, prevPrice);\n', '            if(prev_ != price_ && prevPrice != price_ && nextPrice != price_) {\n', '                if(price_ < prevPrice) {\n', '                    updateNextOrderPrice(fromToken_, toToken_, prev_, price_);\n', '                    updateNextOrderPrice(fromToken_, toToken_, price_, prevPrice);\n', '                } else if(nextPrice == 0) {\n', '                    updateNextOrderPrice(fromToken_, toToken_, prevPrice, price_);\n', '                } else {\n', '                    connectOrderPrice(fromToken_, toToken_, price_, prevPrice);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function connectOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal \n', '    {\n', '        address firstUser = getNextOrderUser(fromToken_, toToken_, price_, 0);\n', '        if(user_ != address(0) && user_ != firstUser) {\n', '            updateNextOrderUser(fromToken_, toToken_, price_, 0, user_);\n', '            if(firstUser != address(0)) {\n', '                updateNextOrderUser(fromToken_, toToken_, price_, user_, firstUser);\n', '            }\n', '        }\n', '    }\n', '\n', '    function disconnectOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '    {\n', '        uint256 currPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n', '        uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, currPrice);\n', '        if(price_ == currPrice) {\n', '            updateNextOrderPrice(fromToken_, toToken_, 0, nextPrice);\n', '        }\n', '    }\n', '\n', '    function disconnectOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '    {\n', '        if(user_ == address(0)) {\n', '            return;\n', '        }\n', '        address currUser = getNextOrderUser(fromToken_, toToken_, price_, address(0));\n', '        address nextUser = getNextOrderUser(fromToken_, toToken_, price_, currUser);\n', '        if(currUser == user_) {\n', '            updateNextOrderUser(fromToken_, toToken_, price_, address(0), nextUser);\n', '            if(nextUser == address(0)) {\n', '                disconnectOrderPrice(fromToken_, toToken_, price_);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getNextOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '        view\n', '    returns(uint256) {\n', '        return nextOrderPrice[fromToken_][toToken_][price_];\n', '    }\n', '\n', '    function updateNextOrderPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        uint256 nextPrice_\n', '    )\n', '        internal\n', '    {\n', '        nextOrderPrice[fromToken_][toToken_][price_] = nextPrice_;\n', '    }\n', '\n', '    function getNextOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '        view\n', '    returns(address) {\n', '        return orderBooks[fromToken_][toToken_][price_][user_].nextUser;\n', '    }\n', '\n', '    function getOrderAmount(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_\n', '    )\n', '        internal\n', '        view\n', '    returns(uint256) {\n', '        return orderBooks[fromToken_][toToken_][price_][user_].amount;\n', '    }\n', '\n', '    function updateNextOrderUser(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        address nextUser_\n', '    )\n', '        internal\n', '    {\n', '        orderBooks[fromToken_][toToken_][price_][user_].nextUser = nextUser_;\n', '    }\n', '\n', '    function updateOrderAmount(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_,\n', '        address user_,\n', '        uint256 amount_,\n', '        bool addOrSub_\n', '    )\n', '        internal\n', '    {\n', '        if(addOrSub_) {\n', '            orderBooks[fromToken_][toToken_][price_][user_].amount = safeAdd(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n', '        } else {\n', '            orderBooks[fromToken_][toToken_][price_][user_].amount = safeSub(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n', '        }\n', '    }\n', '\n', '    function logPrice(\n', '        address fromToken_,\n', '        address toToken_,\n', '        uint256 price_\n', '    )\n', '        internal\n', '    {\n', '        if(price_ > 0) {\n', '            if(uint256(fromToken_) >= uint256(toToken_)) {\n', '                priceBooks[fromToken_][toToken_] = price_;\n', '            } else  {\n', '                priceBooks[toToken_][fromToken_] = safeDiv(10 ** 36, price_);\n', '            }\n', '        }\n', '    }\n', '}']
