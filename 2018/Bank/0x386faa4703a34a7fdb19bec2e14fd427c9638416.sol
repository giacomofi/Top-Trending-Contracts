['pragma solidity ^0.4.18;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract TokenERC20 is owned {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    \n', '    uint256 public totalSupply;\n', '    uint public amountRaised;\n', '\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    bool public lockedSell;\n', '    \n', '    bytes32 public currentChallenge;\n', '    uint public timeOfLastProof;\n', '    uint public difficulty = 10**32;\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Freeze(address from, uint256 amount);\n', '    event UnFreeze(address to, uint256 amount);\n', '        \n', '    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol, uint256 newSellPrice, uint256 newBuyPrice) public {\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  \n', '        balanceOf[msg.sender] = totalSupply;                \n', '        name = tokenName;                                   \n', '        symbol = tokenSymbol;                               \n', '        owner = msg.sender;\n', '        timeOfLastProof = now;\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '        lockedSell = true;\n', '    }\n', '\n', '    function emission(uint256 amount) onlyOwner public {\n', '        totalSupply += amount;\n', '        balanceOf[msg.sender] += amount;\n', '    } \n', '    \n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '    }\n', '    \n', '    function buy() public payable returns (uint amount) {\n', '        amount = (msg.value * 10 ** uint256(decimals)) / buyPrice;\n', '        require(balanceOf[owner] >= amount);               \n', '        balanceOf[msg.sender] += amount;                  \n', '        balanceOf[owner] -= amount;                        \n', '        amountRaised += msg.value;\n', '        Transfer(owner, msg.sender, amount);               \n', '        return amount;                                    \n', '    }\n', '\n', '    function sell(uint amount) public returns (uint revenue) {\n', '        require(!lockedSell);\n', '        require(balanceOf[msg.sender] >= amount);         \n', '        balanceOf[owner] += amount;                        \n', '        balanceOf[msg.sender] -= amount;  \n', '        revenue = amount * sellPrice / 10 ** uint256(decimals);\n', '        amountRaised -= revenue;\n', '        require(msg.sender.send(revenue));                \n', '        Transfer(msg.sender, owner, amount);               \n', '        return revenue;                                   \n', '    }\n', '\n', '    function lockSell(bool value) onlyOwner public {\n', '        lockedSell = value;\n', '    }\n', '\n', '    function proofOfWork(uint nonce) public {\n', '        bytes8 n = bytes8(keccak256(nonce, currentChallenge));    \n', '        require(n >= bytes8(difficulty));                   \n', '\n', '        uint timeSinceLastProof = (now - timeOfLastProof);  \n', '        require(timeSinceLastProof >= 5 seconds);         \n', '        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  \n', '\n', '        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  \n', '\n', '        timeOfLastProof = now;                              \n', '        currentChallenge = keccak256(nonce, currentChallenge, block.blockhash(block.number - 1));  \n', '    }\n', '    \n', '    function _transfer(address from, address to, uint amount) internal {\n', '        require(to != 0x0);\n', '        require(balanceOf[from] >= amount);\n', '        require(balanceOf[to] + amount > balanceOf[to]);\n', '        uint previousBalances = balanceOf[from] + balanceOf[to];\n', '        balanceOf[from] -= amount;\n', '        balanceOf[to] += amount;\n', '        Transfer(from, to, amount);\n', '        assert(balanceOf[from] + balanceOf[to] == previousBalances);\n', '    }\n', '    \n', '    function transfer(address to, uint256 amount) public {\n', '        _transfer(msg.sender, to, amount);\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n', '        require(amount <= allowance[from][msg.sender]);\n', '        allowance[from][msg.sender] -= amount;\n', '        _transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool success) {\n', '        allowance[msg.sender][spender] = amount;\n', '        return true;\n', '    }\n', '    \n', '    function burn(uint256 amount) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= amount);   \n', '        balanceOf[msg.sender] -= amount;            \n', '        totalSupply -= amount;                      \n', '        Burn(msg.sender, amount);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address from, uint256 amount) public returns (bool success) {\n', '        require(balanceOf[from] >= amount);\n', '        require(amount <= allowance[from][msg.sender]);\n', '        balanceOf[from] -= amount;\n', '        allowance[from][msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        Burn(from, amount);\n', '        return true;\n', '    }\n', '\n', '    function withdrawRaised(uint amount) onlyOwner public {\n', '        require(amountRaised >= amount);\n', '        if (owner.send(amount))\n', '            amountRaised -= amount;\n', '    }\n', '\n', '    function freeze(address from, uint256 amount) onlyOwner public returns (bool success){\n', '        require(amount <= allowance[from][this]);\n', '        allowance[from][this] -= amount;\n', '        _transfer(from, this, amount);\n', '        Freeze(from, amount);\n', '        return true;\n', '    }\n', '\n', '    function unFreeze(address to, uint256 amount) onlyOwner public returns (bool success){\n', '        _transfer(this, to, amount);\n', '        UnFreeze(to, amount);\n', '        return true;\n', '    }\n', '}']