['pragma solidity ^0.4.23;\n', '/*\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // require(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev a to power of b, throws on overflow.\n', '  */\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a ** b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// Refactored and extended by Radek Ostrowski and Maciek Zielinski\n', '// http://startonchain.com\n', '// Additional extensions done by Alex George\n', '// https://dexbrokerage.com\n', '\n', 'contract DexBrokerage is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  address public feeAccount;\n', '  uint256 public makerFee;\n', '  uint256 public takerFee;\n', '  uint256 public inactivityReleasePeriod;\n', '  mapping (address => bool) public approvedCurrencyTokens;\n', '  mapping (address => uint256) public invalidOrder;\n', '  mapping (address => mapping (address => uint256)) public tokens;\n', '  mapping (address => bool) public admins;\n', '  mapping (address => uint256) public lastActiveTransaction;\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  mapping (bytes32 => bool) public withdrawn;\n', '\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '  event MakerFeeUpdated(uint256 oldFee, uint256 newFee);\n', '  event TakerFeeUpdated(uint256 oldFee, uint256 newFee);\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == owner || admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  constructor(uint256 _makerFee, uint256 _takerFee , address _feeAccount, uint256 _inactivityReleasePeriod) public {\n', '    owner = msg.sender;\n', '    makerFee = _makerFee;\n', '    takerFee = _takerFee;\n', '    feeAccount = _feeAccount;\n', '    inactivityReleasePeriod = _inactivityReleasePeriod;\n', '  }\n', '\n', '  function approveCurrencyTokenAddress(address currencyTokenAddress, bool isApproved) onlyAdmin public {\n', '    approvedCurrencyTokens[currencyTokenAddress] = isApproved;\n', '  }\n', '\n', '  function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin public {\n', '    require(nonce >= invalidOrder[user]);\n', '    invalidOrder[user] = nonce;\n', '  }\n', '\n', '  function setMakerFee(uint256 _makerFee) onlyAdmin public {\n', '    //market maker fee will never be more than 1%\n', '    uint256 oldFee = makerFee;\n', '    if (_makerFee > 10 finney) {\n', '      _makerFee = 10 finney;\n', '    }\n', '    require(makerFee != _makerFee);\n', '    makerFee = _makerFee;\n', '    emit MakerFeeUpdated(oldFee, makerFee);\n', '  }\n', '\n', '  function setTakerFee(uint256 _takerFee) onlyAdmin public {\n', '    //market taker fee will never be more than 2%\n', '    uint256 oldFee = takerFee;\n', '    if (_takerFee > 20 finney) {\n', '      _takerFee = 20 finney;\n', '    }\n', '    require(takerFee != _takerFee);\n', '    takerFee = _takerFee;\n', '    emit TakerFeeUpdated(oldFee, takerFee);\n', '  }\n', '\n', '  function setAdmin(address admin, bool isAdmin) onlyOwner public {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '  function depositToken(address token, uint256 amount) public {\n', '    receiveTokenDeposit(token, msg.sender, amount);\n', '  }\n', '\n', '  function receiveTokenDeposit(address token, address from, uint256 amount) public {\n', '    tokens[token][from] = tokens[token][from].add(amount);\n', '    lastActiveTransaction[from] = block.number;\n', '    require(ERC20(token).transferFrom(from, address(this), amount));\n', '    emit Deposit(token, from, amount, tokens[token][from]);\n', '  }\n', '\n', '  function deposit() payable public {\n', '    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', '  function withdraw(address token, uint256 amount) public returns (bool) {\n', '    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\n', '    require(tokens[token][msg.sender] >= amount);\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '    if (token == address(0)) {\n', '      msg.sender.transfer(amount);\n', '    } else {\n', '      require(ERC20(token).transfer(msg.sender, amount));\n', '    }\n', '    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    return true;\n', '  }\n', '\n', '  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 gasCost) onlyAdmin public returns (bool) {\n', '    //gasCost will never be more than 30 finney\n', '    if (gasCost > 30 finney) gasCost = 30 finney;\n', '\n', '    if(token == address(0)){\n', '      require(tokens[address(0)][user] >= gasCost.add(amount));\n', '    } else {\n', '      require(tokens[address(0)][user] >= gasCost);\n', '      require(tokens[token][user] >= amount);\n', '    }\n', '\n', '    bytes32 hash = keccak256(address(this), token, amount, user, nonce);\n', '    require(!withdrawn[hash]);\n', '    withdrawn[hash] = true;\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user);\n', '\n', '    if(token == address(0)){\n', '      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost.add(amount));\n', '      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\n', '      user.transfer(amount);\n', '    } else {\n', '      tokens[token][user] = tokens[token][user].sub(amount);\n', '      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost);\n', '      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\n', '      require(ERC20(token).transfer(user, amount));\n', '    }\n', '    lastActiveTransaction[user] = block.number;\n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address token, address user) view public returns (uint256) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '    /* tradeValues\n', '       [0] amountBuy\n', '       [1] amountSell\n', '       [2] makerNonce\n', '       [3] takerAmountBuy\n', '       [4] takerAmountSell\n', '       [5] takerExpires\n', '       [6] takerNonce\n', '       [7] makerAmountBuy\n', '       [8] makerAmountSell\n', '       [9] makerExpires\n', '       [10] gasCost\n', '     tradeAddressses\n', '       [0] tokenBuy\n', '       [1] tokenSell\n', '       [2] maker\n', '       [3] taker\n', '     */\n', '\n', '  function trade(uint256[11] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin public returns (bool) {\n', '    uint256 price = tradeValues[0].mul(1 ether) / tradeValues[1];\n', '    require(price >= tradeValues[7].mul(1 ether) / tradeValues[8]);\n', '    require(price <= tradeValues[4].mul(1 ether) / tradeValues[3]);\n', '    require(block.number < tradeValues[9]);\n', '    require(block.number < tradeValues[5]);\n', '    require(invalidOrder[tradeAddresses[2]] <= tradeValues[2]);\n', '    require(invalidOrder[tradeAddresses[3]] <= tradeValues[6]);\n', '    bytes32 orderHash = keccak256(address(this), tradeAddresses[0], tradeValues[7], tradeAddresses[1], tradeValues[8], tradeValues[9], tradeValues[2], tradeAddresses[2]);\n', '    bytes32 tradeHash = keccak256(address(this), tradeAddresses[1], tradeValues[3], tradeAddresses[0], tradeValues[4], tradeValues[5], tradeValues[6], tradeAddresses[3]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\n', '    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[0]);\n', '    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= tradeValues[1]);\n', '    if ((tradeAddresses[0] == address(0) || tradeAddresses[1] == address(0)) && tradeValues[10] > 30 finney) tradeValues[10] = 30 finney;\n', '    if ((approvedCurrencyTokens[tradeAddresses[0]] == true || approvedCurrencyTokens[tradeAddresses[1]] == true) && tradeValues[10] > 10 ether) tradeValues[10] = 10 ether;\n', '\n', '    if(tradeAddresses[0] == address(0) || approvedCurrencyTokens[tradeAddresses[0]] == true){\n', '\n', '      require(orderFills[orderHash].add(tradeValues[1]) <= tradeValues[8]);\n', '      require(orderFills[tradeHash].add(tradeValues[1]) <= tradeValues[3]);\n', '\n', '      //tradeAddresses[0] is ether\n', '      uint256 valueInTokens = tradeValues[1];\n', '\n', '      //move tokens\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInTokens);\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInTokens);\n', '\n', '      //from taker, take ether payment, fee and gasCost\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(takerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[10]);\n', '\n', '      //to maker add ether payment, take fee\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].sub(makerFee.mul(tradeValues[0]) / (1 ether));\n', '\n', '      // take maker fee, taker fee and gasCost\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(makerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(takerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(tradeValues[10]);\n', '\n', '      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[1]);\n', '      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[1]);\n', '\n', '    } else {\n', '\n', '      require(orderFills[orderHash].add(tradeValues[0]) <= tradeValues[7]);\n', '      require(orderFills[tradeHash].add(tradeValues[0]) <= tradeValues[4]);\n', '\n', '      //tradeAddresses[0] is token\n', '      uint256 valueInEth = tradeValues[1];\n', '\n', '      //move tokens //changed tradeValues to 0\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\n', '\n', '      //from maker, take ether payment and fee\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInEth);\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(makerFee.mul(valueInEth) / (1 ether));\n', '\n', '      //add ether payment to taker, take fee, take gasCost\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInEth);\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(takerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(tradeValues[10]);\n', '\n', '      //take maker fee, taker fee and gasCost\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(makerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(takerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(tradeValues[10]);\n', '\n', '      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[0]);\n', '      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[0]);\n', '    }\n', '\n', '    lastActiveTransaction[tradeAddresses[2]] = block.number;\n', '    lastActiveTransaction[tradeAddresses[3]] = block.number;\n', '\n', '    emit Trade(tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeAddresses[2], tradeAddresses[3]);\n', '    return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '/*\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // require(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev a to power of b, throws on overflow.\n', '  */\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a ** b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// Refactored and extended by Radek Ostrowski and Maciek Zielinski\n', '// http://startonchain.com\n', '// Additional extensions done by Alex George\n', '// https://dexbrokerage.com\n', '\n', 'contract DexBrokerage is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  address public feeAccount;\n', '  uint256 public makerFee;\n', '  uint256 public takerFee;\n', '  uint256 public inactivityReleasePeriod;\n', '  mapping (address => bool) public approvedCurrencyTokens;\n', '  mapping (address => uint256) public invalidOrder;\n', '  mapping (address => mapping (address => uint256)) public tokens;\n', '  mapping (address => bool) public admins;\n', '  mapping (address => uint256) public lastActiveTransaction;\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  mapping (bytes32 => bool) public withdrawn;\n', '\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '  event MakerFeeUpdated(uint256 oldFee, uint256 newFee);\n', '  event TakerFeeUpdated(uint256 oldFee, uint256 newFee);\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == owner || admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  constructor(uint256 _makerFee, uint256 _takerFee , address _feeAccount, uint256 _inactivityReleasePeriod) public {\n', '    owner = msg.sender;\n', '    makerFee = _makerFee;\n', '    takerFee = _takerFee;\n', '    feeAccount = _feeAccount;\n', '    inactivityReleasePeriod = _inactivityReleasePeriod;\n', '  }\n', '\n', '  function approveCurrencyTokenAddress(address currencyTokenAddress, bool isApproved) onlyAdmin public {\n', '    approvedCurrencyTokens[currencyTokenAddress] = isApproved;\n', '  }\n', '\n', '  function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin public {\n', '    require(nonce >= invalidOrder[user]);\n', '    invalidOrder[user] = nonce;\n', '  }\n', '\n', '  function setMakerFee(uint256 _makerFee) onlyAdmin public {\n', '    //market maker fee will never be more than 1%\n', '    uint256 oldFee = makerFee;\n', '    if (_makerFee > 10 finney) {\n', '      _makerFee = 10 finney;\n', '    }\n', '    require(makerFee != _makerFee);\n', '    makerFee = _makerFee;\n', '    emit MakerFeeUpdated(oldFee, makerFee);\n', '  }\n', '\n', '  function setTakerFee(uint256 _takerFee) onlyAdmin public {\n', '    //market taker fee will never be more than 2%\n', '    uint256 oldFee = takerFee;\n', '    if (_takerFee > 20 finney) {\n', '      _takerFee = 20 finney;\n', '    }\n', '    require(takerFee != _takerFee);\n', '    takerFee = _takerFee;\n', '    emit TakerFeeUpdated(oldFee, takerFee);\n', '  }\n', '\n', '  function setAdmin(address admin, bool isAdmin) onlyOwner public {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '  function depositToken(address token, uint256 amount) public {\n', '    receiveTokenDeposit(token, msg.sender, amount);\n', '  }\n', '\n', '  function receiveTokenDeposit(address token, address from, uint256 amount) public {\n', '    tokens[token][from] = tokens[token][from].add(amount);\n', '    lastActiveTransaction[from] = block.number;\n', '    require(ERC20(token).transferFrom(from, address(this), amount));\n', '    emit Deposit(token, from, amount, tokens[token][from]);\n', '  }\n', '\n', '  function deposit() payable public {\n', '    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\n', '    lastActiveTransaction[msg.sender] = block.number;\n', '    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', '  function withdraw(address token, uint256 amount) public returns (bool) {\n', '    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\n', '    require(tokens[token][msg.sender] >= amount);\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '    if (token == address(0)) {\n', '      msg.sender.transfer(amount);\n', '    } else {\n', '      require(ERC20(token).transfer(msg.sender, amount));\n', '    }\n', '    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    return true;\n', '  }\n', '\n', '  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 gasCost) onlyAdmin public returns (bool) {\n', '    //gasCost will never be more than 30 finney\n', '    if (gasCost > 30 finney) gasCost = 30 finney;\n', '\n', '    if(token == address(0)){\n', '      require(tokens[address(0)][user] >= gasCost.add(amount));\n', '    } else {\n', '      require(tokens[address(0)][user] >= gasCost);\n', '      require(tokens[token][user] >= amount);\n', '    }\n', '\n', '    bytes32 hash = keccak256(address(this), token, amount, user, nonce);\n', '    require(!withdrawn[hash]);\n', '    withdrawn[hash] = true;\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user);\n', '\n', '    if(token == address(0)){\n', '      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost.add(amount));\n', '      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\n', '      user.transfer(amount);\n', '    } else {\n', '      tokens[token][user] = tokens[token][user].sub(amount);\n', '      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost);\n', '      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\n', '      require(ERC20(token).transfer(user, amount));\n', '    }\n', '    lastActiveTransaction[user] = block.number;\n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address token, address user) view public returns (uint256) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '    /* tradeValues\n', '       [0] amountBuy\n', '       [1] amountSell\n', '       [2] makerNonce\n', '       [3] takerAmountBuy\n', '       [4] takerAmountSell\n', '       [5] takerExpires\n', '       [6] takerNonce\n', '       [7] makerAmountBuy\n', '       [8] makerAmountSell\n', '       [9] makerExpires\n', '       [10] gasCost\n', '     tradeAddressses\n', '       [0] tokenBuy\n', '       [1] tokenSell\n', '       [2] maker\n', '       [3] taker\n', '     */\n', '\n', '  function trade(uint256[11] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin public returns (bool) {\n', '    uint256 price = tradeValues[0].mul(1 ether) / tradeValues[1];\n', '    require(price >= tradeValues[7].mul(1 ether) / tradeValues[8]);\n', '    require(price <= tradeValues[4].mul(1 ether) / tradeValues[3]);\n', '    require(block.number < tradeValues[9]);\n', '    require(block.number < tradeValues[5]);\n', '    require(invalidOrder[tradeAddresses[2]] <= tradeValues[2]);\n', '    require(invalidOrder[tradeAddresses[3]] <= tradeValues[6]);\n', '    bytes32 orderHash = keccak256(address(this), tradeAddresses[0], tradeValues[7], tradeAddresses[1], tradeValues[8], tradeValues[9], tradeValues[2], tradeAddresses[2]);\n', '    bytes32 tradeHash = keccak256(address(this), tradeAddresses[1], tradeValues[3], tradeAddresses[0], tradeValues[4], tradeValues[5], tradeValues[6], tradeAddresses[3]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\n', '    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[0]);\n', '    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= tradeValues[1]);\n', '    if ((tradeAddresses[0] == address(0) || tradeAddresses[1] == address(0)) && tradeValues[10] > 30 finney) tradeValues[10] = 30 finney;\n', '    if ((approvedCurrencyTokens[tradeAddresses[0]] == true || approvedCurrencyTokens[tradeAddresses[1]] == true) && tradeValues[10] > 10 ether) tradeValues[10] = 10 ether;\n', '\n', '    if(tradeAddresses[0] == address(0) || approvedCurrencyTokens[tradeAddresses[0]] == true){\n', '\n', '      require(orderFills[orderHash].add(tradeValues[1]) <= tradeValues[8]);\n', '      require(orderFills[tradeHash].add(tradeValues[1]) <= tradeValues[3]);\n', '\n', '      //tradeAddresses[0] is ether\n', '      uint256 valueInTokens = tradeValues[1];\n', '\n', '      //move tokens\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInTokens);\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInTokens);\n', '\n', '      //from taker, take ether payment, fee and gasCost\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(takerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[10]);\n', '\n', '      //to maker add ether payment, take fee\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].sub(makerFee.mul(tradeValues[0]) / (1 ether));\n', '\n', '      // take maker fee, taker fee and gasCost\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(makerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(takerFee.mul(tradeValues[0]) / (1 ether));\n', '      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(tradeValues[10]);\n', '\n', '      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[1]);\n', '      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[1]);\n', '\n', '    } else {\n', '\n', '      require(orderFills[orderHash].add(tradeValues[0]) <= tradeValues[7]);\n', '      require(orderFills[tradeHash].add(tradeValues[0]) <= tradeValues[4]);\n', '\n', '      //tradeAddresses[0] is token\n', '      uint256 valueInEth = tradeValues[1];\n', '\n', '      //move tokens //changed tradeValues to 0\n', '      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\n', '      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\n', '\n', '      //from maker, take ether payment and fee\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInEth);\n', '      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(makerFee.mul(valueInEth) / (1 ether));\n', '\n', '      //add ether payment to taker, take fee, take gasCost\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInEth);\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(takerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(tradeValues[10]);\n', '\n', '      //take maker fee, taker fee and gasCost\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(makerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(takerFee.mul(valueInEth) / (1 ether));\n', '      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(tradeValues[10]);\n', '\n', '      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[0]);\n', '      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[0]);\n', '    }\n', '\n', '    lastActiveTransaction[tradeAddresses[2]] = block.number;\n', '    lastActiveTransaction[tradeAddresses[3]] = block.number;\n', '\n', '    emit Trade(tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeAddresses[2], tradeAddresses[3]);\n', '    return true;\n', '  }\n', '\n', '}']
