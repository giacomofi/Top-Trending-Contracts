['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    string public constant name = "";\n', '    string public constant symbol = "";\n', '    uint8 public constant decimals = 0;\n', '}\n', '\n', '// Ethen Decentralized Exchange Contract\n', '// https://ethen.io/\n', 'contract Ethen is Pausable {\n', '    // Trade & order types\n', '    uint public constant BUY = 1; // order type BID\n', '    uint public constant SELL = 0; // order type ASK\n', '\n', '    // Percent multiplier in makeFee & takeFee\n', '    uint public FEE_MUL = 1000000;\n', '\n', '    // x1000000, 0.5%\n', '    uint public constant MAX_FEE = 5000;\n', '\n', '    // Time after expiration, until order will still be valid to trade.\n', '    //\n', '    // All trades are signed by server so it should not be possible to trade\n', '    // expired orders. Let&#39;s say, signing happens at the last second.\n', '    // Some time needed for transaction to be mined. If we going to require\n', '    // here in contract that expiration time should always be less than\n', '    // a block.timestamp than such trades will not be successful.\n', '    // Instead we add some reasonable time, after which order still be valid\n', '    // to trade in contract.\n', '    uint public expireDelay = 300;\n', '\n', '    uint public constant MAX_EXPIRE_DELAY = 600;\n', '\n', '    // Value of keccak256(\n', '    //     "address Contract", "string Order", "address Token", "uint Nonce",\n', '    //     "uint Price", "uint Amount", "uint Expire"\n', '    // )\n', '    // See https://github.com/ethereum/EIPs/pull/712\n', '    bytes32 public constant ETH_SIGN_TYPED_DATA_ARGHASH =\n', '        0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74;\n', '\n', '    // All prices are per 1e18 tokens\n', '    uint public constant PRICE_MUL = 1e18;\n', '\n', '    //\n', '    // Public State Vars\n', '    //\n', '\n', '    // That address gets all the fees\n', '    address public feeCollector;\n', '\n', '    // x1000000\n', '    uint public makeFee = 0;\n', '\n', '    // x1000000, 2500 == 0.25%\n', '    uint public takeFee = 2500;\n', '\n', '    // user address to ether balances\n', '    mapping (address => uint) public balances;\n', '\n', '    // user address to token address to token balance\n', '    mapping (address => mapping (address => uint)) public tokens;\n', '\n', '    // user => order nonce => amount filled\n', '    mapping (address => mapping (uint => uint)) public filled;\n', '\n', '    // user => nonce => true\n', '    mapping (address => mapping (uint => bool)) public trades;\n', '\n', '    // Every trade should be signed by that address\n', '    address public signer;\n', '\n', '    // Keep track of custom fee coefficients per user\n', '    // 0 means user will pay no fees, 50 - only 50% of fees\n', '    struct Coeff {\n', '        uint8   coeff; // 0-99\n', '        uint128 expire;\n', '    }\n', '    mapping (address => Coeff) public coeffs;\n', '\n', '    // Users can pay to reduce fees\n', '    // (duration << 8) + coeff => price\n', '    mapping(uint => uint) public packs;\n', '\n', '    //\n', '    // Events\n', '    //\n', '\n', '    event NewMakeFee(uint makeFee);\n', '    event NewTakeFee(uint takeFee);\n', '\n', '    event NewFeeCoeff(address user, uint8 coeff, uint128 expire, uint price);\n', '\n', '    event DepositEther(address user, uint amount, uint total);\n', '    event WithdrawEther(address user, uint amount, uint total);\n', '    event DepositToken(address user, address token, uint amount, uint total);\n', '    event WithdrawToken(address user, address token, uint amount, uint total);\n', '\n', '    event Cancel(\n', '        uint8 order,\n', '        address owner,\n', '        uint nonce,\n', '        address token,\n', '        uint price,\n', '        uint amount\n', '    );\n', '\n', '    event Order(\n', '        address orderOwner,\n', '        uint orderNonce,\n', '        uint orderPrice,\n', '        uint tradeTokens,\n', '        uint orderFilled,\n', '        uint orderOwnerFinalTokens,\n', '        uint orderOwnerFinalEther,\n', '        uint fees\n', '    );\n', '\n', '    event Trade(\n', '        address trader,\n', '        uint nonce,\n', '        uint trade,\n', '        address token,\n', '        uint traderFinalTokens,\n', '        uint traderFinalEther\n', '    );\n', '\n', '    event NotEnoughTokens(\n', '        address owner, address token, uint shouldHaveAmount, uint actualAmount\n', '    );\n', '    event NotEnoughEther(\n', '        address owner, uint shouldHaveAmount, uint actualAmount\n', '    );\n', '\n', '    //\n', '    // Constructor\n', '    //\n', '\n', '    function Ethen(address _signer) public {\n', '        feeCollector = msg.sender;\n', '        signer       = _signer;\n', '    }\n', '\n', '    //\n', '    // Admin Methods\n', '    //\n', '\n', '    function setFeeCollector(address _addr) external onlyOwner {\n', '        feeCollector = _addr;\n', '    }\n', '\n', '    function setSigner(address _addr) external onlyOwner {\n', '        signer = _addr;\n', '    }\n', '\n', '    function setMakeFee(uint _makeFee) external onlyOwner {\n', '        require(_makeFee <= MAX_FEE);\n', '        makeFee = _makeFee;\n', '        NewMakeFee(makeFee);\n', '    }\n', '\n', '    function setTakeFee(uint _takeFee) external onlyOwner {\n', '        require(_takeFee <= MAX_FEE);\n', '        takeFee = _takeFee;\n', '        NewTakeFee(takeFee);\n', '    }\n', '\n', '    function addPack(\n', '        uint8 _coeff, uint128 _duration, uint _price\n', '    ) external onlyOwner {\n', '        require(_coeff < 100);\n', '        require(_duration > 0);\n', '        require(_price > 0);\n', '\n', '        uint key = packKey(_coeff, _duration);\n', '        packs[key] = _price;\n', '    }\n', '\n', '    function delPack(uint8 _coeff, uint128 _duration) external onlyOwner {\n', '        uint key = packKey(_coeff, _duration);\n', '        delete packs[key];\n', '    }\n', '\n', '    function setExpireDelay(uint _expireDelay) external onlyOwner {\n', '        require(_expireDelay <= MAX_EXPIRE_DELAY);\n', '        expireDelay = _expireDelay;\n', '    }\n', '\n', '    //\n', '    // User Custom Fees\n', '    //\n', '\n', '    function getPack(\n', '        uint8 _coeff, uint128 _duration\n', '    ) public view returns (uint) {\n', '        uint key = packKey(_coeff, _duration);\n', '        return packs[key];\n', '    }\n', '\n', '    // Buys new fee coefficient for given duration of time\n', '    function buyPack(\n', '        uint8 _coeff, uint128 _duration\n', '    ) external payable {\n', '        require(now >= coeffs[msg.sender].expire);\n', '\n', '        uint key = packKey(_coeff, _duration);\n', '        uint price = packs[key];\n', '\n', '        require(price > 0);\n', '        require(msg.value == price);\n', '\n', '        updateCoeff(msg.sender, _coeff, uint128(now) + _duration, price);\n', '\n', '        balances[feeCollector] = SafeMath.add(\n', '            balances[feeCollector], msg.value\n', '        );\n', '    }\n', '\n', '    // Sets new fee coefficient for user\n', '    function setCoeff(\n', '        uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s\n', '    ) external {\n', '        bytes32 hash = keccak256(this, msg.sender, _coeff, _expire);\n', '        require(ecrecover(hash, _v, _r, _s) == signer);\n', '\n', '        require(_coeff < 100);\n', '        require(uint(_expire) > now);\n', '        require(uint(_expire) <= now + 35 days);\n', '\n', '        updateCoeff(msg.sender, _coeff, _expire, 0);\n', '    }\n', '\n', '    //\n', '    // User Balance Related Methods\n', '    //\n', '\n', '    function () external payable {\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\n', '        DepositEther(msg.sender, msg.value, balances[msg.sender]);\n', '    }\n', '\n', '    function depositEther() external payable {\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\n', '        DepositEther(msg.sender, msg.value, balances[msg.sender]);\n', '    }\n', '\n', '    function withdrawEther(uint _amount) external {\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _amount);\n', '        msg.sender.transfer(_amount);\n', '        WithdrawEther(msg.sender, _amount, balances[msg.sender]);\n', '    }\n', '\n', '    function depositToken(address _token, uint _amount) external {\n', '        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\n', '        tokens[msg.sender][_token] = SafeMath.add(\n', '            tokens[msg.sender][_token], _amount\n', '        );\n', '        DepositToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\n', '    }\n', '\n', '    function withdrawToken(address _token, uint _amount) external {\n', '        tokens[msg.sender][_token] = SafeMath.sub(\n', '            tokens[msg.sender][_token], _amount\n', '        );\n', '        require(ERC20(_token).transfer(msg.sender, _amount));\n', '        WithdrawToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\n', '    }\n', '\n', '    //\n', '    // User Trade Methods\n', '    //\n', '\n', '    // Fills order so it cant be executed later\n', '    function cancel(\n', '        uint8   _order, // BUY for bid orders or SELL for ask orders\n', '        address _token,\n', '        uint    _nonce,\n', '        uint    _price, // Price per 1e18 (PRICE_MUL) tokens\n', '        uint    _amount,\n', '        uint    _expire,\n', '        uint    _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external {\n', '        require(_order == BUY || _order == SELL);\n', '\n', '        if (now > _expire + expireDelay) {\n', '            // already expired\n', '            return;\n', '        }\n', '\n', '        getVerifiedHash(\n', '            msg.sender,\n', '            _order, _token, _nonce, _price, _amount, _expire,\n', '            _v, _r, _s\n', '        );\n', '\n', '        filled[msg.sender][_nonce] = _amount;\n', '\n', '        Cancel(_order, msg.sender, _nonce, _token, _price, _amount);\n', '    }\n', '\n', '    // Does trade, places order\n', '    // Argument hell because of "Stack to deep" errors.\n', '    function trade(\n', '        // _nums[0] 1=BUY, 0=SELL\n', '        // _nums[1] trade.nonce\n', '        // _nums[2] trade.v\n', '        // _nums[3] trade.expire\n', '        // _nums[4] order[0].nonce              First order should have\n', '        // _nums[5] order[0].price              best available price\n', '        // _nums[6] order[0].amount\n', '        // _nums[7] order[0].expire\n', '        // _nums[8] order[0].v\n', '        // _nums[9] order[0].tradeAmount\n', '        // ...\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        // _nums[6N+2] order[N-1].v             N -> 6N+8\n', '        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '        uint[] _nums,\n', '        // _addrs[0] token\n', '        // _addrs[1] order[0].owner\n', '        // ...\n', '        // _addrs[N] order[N-1].owner           N -> N+1\n', '        address[] _addrs,\n', '        // _rss[0] trade.r\n', '        // _rss[1] trade.s\n', '        // _rss[2] order[0].r\n', '        // _rss[3] order[0].s\n', '        // ...\n', '        // _rss[2N]   order[N-1].r              N -> 2N+2\n', '        // _rss[2N+1] order[N-1].s              N -> 2N+3\n', '        bytes32[] _rss\n', '    ) public whenNotPaused {\n', '        // number of orders\n', '        uint N = _addrs.length - 1;\n', '\n', '        require(_nums.length == 6*N+4);\n', '        require(_rss.length == 2*N+2);\n', '\n', '        // Type of trade\n', '        // _nums[0] BUY or SELL\n', '        require(_nums[0] == BUY || _nums[0] == SELL);\n', '\n', '        // _nums[2] placeOrder.nonce\n', '        saveNonce(_nums[1]);\n', '\n', '        // _nums[3] trade.expire\n', '        require(now <= _nums[3]);\n', '\n', '        // Start building hash signed by server\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        // _nums[1] nonce\n', '        // _nums[3] trade.expire\n', '        bytes32 tradeHash = keccak256(\n', '            this, msg.sender, uint8(_nums[0]), _addrs[0], _nums[1], _nums[3]\n', '        );\n', '\n', '        // Hash of an order signed by its owner\n', '        bytes32 orderHash;\n', '\n', '        for (uint i = 0; i < N; i++) {\n', '            checkExpiration(i, _nums);\n', '\n', '            orderHash = verifyOrder(i, _nums, _addrs, _rss);\n', '\n', '            // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '            tradeHash = keccak256(tradeHash, orderHash, _nums[6*i+9]);\n', '\n', '            tradeOrder(i, _nums, _addrs);\n', '        }\n', '\n', '        checkTradeSignature(tradeHash, _nums, _rss);\n', '\n', '        sendTradeEvent(_nums, _addrs);\n', '    }\n', '\n', '    //\n', '    // Private\n', '    //\n', '\n', '    function saveNonce(uint _nonce) private {\n', '        require(trades[msg.sender][_nonce] == false);\n', '        trades[msg.sender][_nonce] = true;\n', '    }\n', '\n', '    // Throws error if order is expired\n', '    function checkExpiration(\n', '        uint _i, // order number\n', '        uint[] _nums\n', '    ) private view {\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        require(now <= _nums[6*_i+7] + expireDelay);\n', '    }\n', '\n', '    // Returns hash of order `_i`, signed by its owner\n', '    function verifyOrder(\n', '        uint _i, // order number\n', '        uint[] _nums,\n', '        address[] _addrs,\n', '        bytes32[] _rss\n', '    ) private view returns (bytes32 _orderHash) {\n', '        // _nums[0] BUY or SELL\n', '        // User is buying orders, that are selling, and vice versa\n', '        uint8 order = _nums[0] == BUY ? uint8(SELL) : uint8(BUY);\n', '\n', '        // _addrs[N] order[N-1].owner       N -> N+1\n', '        // _addrs[0] token\n', '        address owner = _addrs[_i+1];\n', '        address token = _addrs[0];\n', '\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        uint nonce = _nums[6*_i+4];\n', '        uint price = _nums[6*_i+5];\n', '        uint amount = _nums[6*_i+6];\n', '        uint expire = _nums[6*_i+7];\n', '\n', '        // _nums[6N+2] order[N-1].v             N -> 6N+8\n', '        // _rss[2N]   order[N-1].r              N -> 2N+2\n', '        // _rss[2N+1] order[N-1].s              N -> 2N+3\n', '        uint v = _nums[6*_i+8];\n', '        bytes32 r = _rss[2*_i+2];\n', '        bytes32 s = _rss[2*_i+3];\n', '\n', '        _orderHash = getVerifiedHash(\n', '            owner,\n', '            order, token, nonce, price, amount,\n', '            expire, v, r, s\n', '        );\n', '    }\n', '\n', '    // Returns number of traded tokens\n', '    function tradeOrder(\n', '        uint _i, // order number\n', '        uint[] _nums,\n', '        address[] _addrs\n', '    ) private {\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        // _addrs[N] order[N-1].owner           N -> N+1\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '        executeOrder(\n', '            _nums[0],\n', '            _addrs[0],\n', '            _addrs[_i+1],\n', '            _nums[6*_i+4],\n', '            _nums[6*_i+5],\n', '            _nums[6*_i+6],\n', '            _nums[6*_i+9]\n', '        );\n', '    }\n', '\n', '    function checkTradeSignature(\n', '        bytes32 _tradeHash,\n', '        uint[] _nums,\n', '        bytes32[] _rss\n', '    ) private view {\n', '        // _nums[2] trade.v\n', '        // _rss[0] trade.r\n', '        // _rss[1] trade.s\n', '        require(ecrecover(\n', '            _tradeHash, uint8(_nums[2]), _rss[0], _rss[1]\n', '        ) == signer);\n', '    }\n', '\n', '    function sendTradeEvent(\n', '        uint[] _nums, address[] _addrs\n', '    ) private {\n', '        // _nums[1] nonce\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        Trade(\n', '            msg.sender, _nums[1], _nums[0], _addrs[0],\n', '            tokens[msg.sender][_addrs[0]], balances[msg.sender]\n', '        );\n', '    }\n', '\n', '    // Executes no more than _tradeAmount tokens from order\n', '    function executeOrder(\n', '        uint    _trade,\n', '        address _token,\n', '        address _orderOwner,\n', '        uint    _orderNonce,\n', '        uint    _orderPrice,\n', '        uint    _orderAmount,\n', '        uint    _tradeAmount\n', '    ) private {\n', '        var (tradeTokens, tradeEther) = getTradeParameters(\n', '            _trade, _token, _orderOwner, _orderNonce, _orderPrice,\n', '            _orderAmount, _tradeAmount\n', '        );\n', '\n', '        filled[_orderOwner][_orderNonce] = SafeMath.add(\n', '            filled[_orderOwner][_orderNonce],\n', '            tradeTokens\n', '        );\n', '\n', '        // Sanity check: orders should never overfill\n', '        require(filled[_orderOwner][_orderNonce] <= _orderAmount);\n', '\n', '        uint makeFees = getFees(tradeEther, makeFee, _orderOwner);\n', '        uint takeFees = getFees(tradeEther, takeFee, msg.sender);\n', '\n', '        swap(\n', '            _trade, _token, _orderOwner, tradeTokens, tradeEther,\n', '            makeFees, takeFees\n', '        );\n', '\n', '        balances[feeCollector] = SafeMath.add(\n', '            balances[feeCollector],\n', '            SafeMath.add(takeFees, makeFees)\n', '        );\n', '\n', '        sendOrderEvent(\n', '            _orderOwner, _orderNonce, _orderPrice, tradeTokens,\n', '            _token, SafeMath.add(takeFees, makeFees)\n', '        );\n', '    }\n', '\n', '    function swap(\n', '        uint _trade,\n', '        address _token,\n', '        address _orderOwner,\n', '        uint _tradeTokens,\n', '        uint _tradeEther,\n', '        uint _makeFees,\n', '        uint _takeFees\n', '    ) private {\n', '        if (_trade == BUY) {\n', '            tokens[msg.sender][_token] = SafeMath.add(\n', '                tokens[msg.sender][_token], _tradeTokens\n', '            );\n', '            tokens[_orderOwner][_token] = SafeMath.sub(\n', '                tokens[_orderOwner][_token], _tradeTokens\n', '            );\n', '            balances[msg.sender] = SafeMath.sub(\n', '                balances[msg.sender], SafeMath.add(_tradeEther, _takeFees)\n', '            );\n', '            balances[_orderOwner] = SafeMath.add(\n', '                balances[_orderOwner], SafeMath.sub(_tradeEther, _makeFees)\n', '            );\n', '        } else {\n', '            tokens[msg.sender][_token] = SafeMath.sub(\n', '                tokens[msg.sender][_token], _tradeTokens\n', '            );\n', '            tokens[_orderOwner][_token] = SafeMath.add(\n', '                tokens[_orderOwner][_token], _tradeTokens\n', '            );\n', '            balances[msg.sender] = SafeMath.add(\n', '                balances[msg.sender], SafeMath.sub(_tradeEther, _takeFees)\n', '            );\n', '            balances[_orderOwner] = SafeMath.sub(\n', '                balances[_orderOwner], SafeMath.add(_tradeEther, _makeFees)\n', '            );\n', '        }\n', '    }\n', '\n', '    function sendOrderEvent(\n', '        address _orderOwner,\n', '        uint _orderNonce,\n', '        uint _orderPrice,\n', '        uint _tradeTokens,\n', '        address _token,\n', '        uint _fees\n', '    ) private {\n', '        Order(\n', '            _orderOwner,\n', '            _orderNonce,\n', '            _orderPrice,\n', '            _tradeTokens,\n', '            filled[_orderOwner][_orderNonce],\n', '            tokens[_orderOwner][_token],\n', '            balances[_orderOwner],\n', '            _fees\n', '        );\n', '    }\n', '\n', '    // Returns number of tokens that could be traded and its total price\n', '    function getTradeParameters(\n', '        uint _trade, address _token, address _orderOwner,\n', '        uint _orderNonce, uint _orderPrice, uint _orderAmount, uint _tradeAmount\n', '    ) private returns (uint _tokens, uint _totalPrice) {\n', '        // remains on order\n', '        _tokens = SafeMath.sub(\n', '            _orderAmount, filled[_orderOwner][_orderNonce]\n', '        );\n', '\n', '        // trade no more than needed\n', '        if (_tokens > _tradeAmount) {\n', '            _tokens = _tradeAmount;\n', '        }\n', '\n', '        if (_trade == BUY) {\n', '            // ask owner has less tokens than it is on ask\n', '            if (_tokens > tokens[_orderOwner][_token]) {\n', '                NotEnoughTokens(\n', '                    _orderOwner, _token, _tokens, tokens[_orderOwner][_token]\n', '                );\n', '                _tokens = tokens[_orderOwner][_token];\n', '            }\n', '        } else {\n', '            // not possible to sell more tokens than sender has\n', '            if (_tokens > tokens[msg.sender][_token]) {\n', '                NotEnoughTokens(\n', '                    msg.sender, _token, _tokens, tokens[msg.sender][_token]\n', '                );\n', '                _tokens = tokens[msg.sender][_token];\n', '            }\n', '        }\n', '\n', '        uint shouldHave = getPrice(_tokens, _orderPrice);\n', '\n', '        uint spendable;\n', '        if (_trade == BUY) {\n', '            // max ether sender can spent\n', '            spendable = reversePercent(\n', '                balances[msg.sender],\n', '                applyCoeff(takeFee, msg.sender)\n', '            );\n', '        } else {\n', '            // max ether bid owner can spent\n', '            spendable = reversePercent(\n', '                balances[_orderOwner],\n', '                applyCoeff(makeFee, _orderOwner)\n', '            );\n', '        }\n', '\n', '        if (shouldHave <= spendable) {\n', '            // everyone have needed amount of tokens & ether\n', '            _totalPrice = shouldHave;\n', '            return;\n', '        }\n', '\n', '        // less price -> less tokens\n', '        _tokens = SafeMath.div(\n', '            SafeMath.mul(spendable, PRICE_MUL), _orderPrice\n', '        );\n', '        _totalPrice = getPrice(_tokens, _orderPrice);\n', '\n', '        if (_trade == BUY) {\n', '            NotEnoughEther(\n', '                msg.sender,\n', '                addFees(shouldHave, applyCoeff(takeFee, msg.sender)),\n', '                _totalPrice\n', '            );\n', '        } else {\n', '            NotEnoughEther(\n', '                _orderOwner,\n', '                addFees(shouldHave, applyCoeff(makeFee, _orderOwner)),\n', '                _totalPrice\n', '            );\n', '        }\n', '    }\n', '\n', '    // Returns price of _tokens\n', '    // _orderPrice is price per 1e18 tokens\n', '    function getPrice(\n', '        uint _tokens, uint _orderPrice\n', '    ) private pure returns (uint) {\n', '        return SafeMath.div(\n', '            SafeMath.mul(_tokens, _orderPrice), PRICE_MUL\n', '        );\n', '    }\n', '\n', '    function getFees(\n', '        uint _eth, uint _fee, address _payer\n', '    ) private view returns (uint) {\n', '        // _eth * (_fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, applyCoeff(_fee, _payer)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    function applyCoeff(uint _fees, address _user) private view returns (uint) {\n', '        if (now >= coeffs[_user].expire) {\n', '            return _fees;\n', '        }\n', '        return SafeMath.div(\n', '            SafeMath.mul(_fees, coeffs[_user].coeff), 100\n', '        );\n', '    }\n', '\n', '    function addFees(uint _eth, uint _fee) private view returns (uint) {\n', '        // _eth * (1 + _fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, SafeMath.add(FEE_MUL, _fee)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    function subFees(uint _eth, uint _fee) private view returns (uint) {\n', '        // _eth * (1 - _fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, SafeMath.sub(FEE_MUL, _fee)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    // Returns maximum ether that can be spent if percent _fee will be added\n', '    function reversePercent(\n', '        uint _balance, uint _fee\n', '    ) private view returns (uint) {\n', '        // _trade + _fees = _balance\n', '        // _trade * (1 + _fee / FEE_MUL) = _balance\n', '        // _trade = _balance * FEE_MUL / (FEE_MUL + _fee)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_balance, FEE_MUL),\n', '            SafeMath.add(FEE_MUL, _fee)\n', '        );\n', '    }\n', '\n', '    // Gets hash of an order, like it is done in `eth_signTypedData`\n', '    // See https://github.com/ethereum/EIPs/pull/712\n', '    function hashOrderTyped(\n', '        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\n', '        uint _expire\n', '    ) private view returns (bytes32) {\n', '        require(_order == BUY || _order == SELL);\n', '        return keccak256(\n', '            ETH_SIGN_TYPED_DATA_ARGHASH,\n', '            keccak256(\n', '                this,\n', '                _order == BUY ? "BUY" : "SELL",\n', '                _token,\n', '                _nonce,\n', '                _price,\n', '                _amount,\n', '                _expire\n', '            )\n', '        );\n', '    }\n', '\n', '    // Gets hash of an order for `eth_sign`\n', '    function hashOrder(\n', '        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\n', '        uint _expire\n', '    ) private view returns (bytes32) {\n', '        return keccak256(\n', '            "\\x19Ethereum Signed Message:\\n32",\n', '            keccak256(this, _order, _token, _nonce, _price, _amount, _expire)\n', '        );\n', '    }\n', '\n', '    // Returns hash of an order\n', '    // Reverts if signature is incorrect\n', '    function getVerifiedHash(\n', '        address _signer,\n', '        uint8 _order, address _token,\n', '        uint _nonce, uint _price, uint _amount, uint _expire,\n', '        uint _v, bytes32 _r, bytes32 _s\n', '    ) private view returns (bytes32 _hash) {\n', '        if (_v < 1000) {\n', '            _hash = hashOrderTyped(\n', '                _order, _token, _nonce, _price, _amount, _expire\n', '            );\n', '            require(ecrecover(_hash, uint8(_v), _r, _s) == _signer);\n', '        } else {\n', '            _hash = hashOrder(\n', '                _order, _token, _nonce, _price, _amount, _expire\n', '            );\n', '            require(ecrecover(_hash, uint8(_v - 1000), _r, _s) == _signer);\n', '        }\n', '    }\n', '\n', '    function packKey(\n', '        uint8 _coeff, uint128 _duration\n', '    ) private pure returns (uint) {\n', '        return (uint(_duration) << 8) + uint(_coeff);\n', '    }\n', '\n', '    function updateCoeff(\n', '        address _user, uint8 _coeff, uint128 _expire, uint price\n', '    ) private {\n', '        coeffs[_user] = Coeff(_coeff, _expire);\n', '        NewFeeCoeff(_user, _coeff, _expire, price);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    string public constant name = "";\n', '    string public constant symbol = "";\n', '    uint8 public constant decimals = 0;\n', '}\n', '\n', '// Ethen Decentralized Exchange Contract\n', '// https://ethen.io/\n', 'contract Ethen is Pausable {\n', '    // Trade & order types\n', '    uint public constant BUY = 1; // order type BID\n', '    uint public constant SELL = 0; // order type ASK\n', '\n', '    // Percent multiplier in makeFee & takeFee\n', '    uint public FEE_MUL = 1000000;\n', '\n', '    // x1000000, 0.5%\n', '    uint public constant MAX_FEE = 5000;\n', '\n', '    // Time after expiration, until order will still be valid to trade.\n', '    //\n', '    // All trades are signed by server so it should not be possible to trade\n', "    // expired orders. Let's say, signing happens at the last second.\n", '    // Some time needed for transaction to be mined. If we going to require\n', '    // here in contract that expiration time should always be less than\n', '    // a block.timestamp than such trades will not be successful.\n', '    // Instead we add some reasonable time, after which order still be valid\n', '    // to trade in contract.\n', '    uint public expireDelay = 300;\n', '\n', '    uint public constant MAX_EXPIRE_DELAY = 600;\n', '\n', '    // Value of keccak256(\n', '    //     "address Contract", "string Order", "address Token", "uint Nonce",\n', '    //     "uint Price", "uint Amount", "uint Expire"\n', '    // )\n', '    // See https://github.com/ethereum/EIPs/pull/712\n', '    bytes32 public constant ETH_SIGN_TYPED_DATA_ARGHASH =\n', '        0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74;\n', '\n', '    // All prices are per 1e18 tokens\n', '    uint public constant PRICE_MUL = 1e18;\n', '\n', '    //\n', '    // Public State Vars\n', '    //\n', '\n', '    // That address gets all the fees\n', '    address public feeCollector;\n', '\n', '    // x1000000\n', '    uint public makeFee = 0;\n', '\n', '    // x1000000, 2500 == 0.25%\n', '    uint public takeFee = 2500;\n', '\n', '    // user address to ether balances\n', '    mapping (address => uint) public balances;\n', '\n', '    // user address to token address to token balance\n', '    mapping (address => mapping (address => uint)) public tokens;\n', '\n', '    // user => order nonce => amount filled\n', '    mapping (address => mapping (uint => uint)) public filled;\n', '\n', '    // user => nonce => true\n', '    mapping (address => mapping (uint => bool)) public trades;\n', '\n', '    // Every trade should be signed by that address\n', '    address public signer;\n', '\n', '    // Keep track of custom fee coefficients per user\n', '    // 0 means user will pay no fees, 50 - only 50% of fees\n', '    struct Coeff {\n', '        uint8   coeff; // 0-99\n', '        uint128 expire;\n', '    }\n', '    mapping (address => Coeff) public coeffs;\n', '\n', '    // Users can pay to reduce fees\n', '    // (duration << 8) + coeff => price\n', '    mapping(uint => uint) public packs;\n', '\n', '    //\n', '    // Events\n', '    //\n', '\n', '    event NewMakeFee(uint makeFee);\n', '    event NewTakeFee(uint takeFee);\n', '\n', '    event NewFeeCoeff(address user, uint8 coeff, uint128 expire, uint price);\n', '\n', '    event DepositEther(address user, uint amount, uint total);\n', '    event WithdrawEther(address user, uint amount, uint total);\n', '    event DepositToken(address user, address token, uint amount, uint total);\n', '    event WithdrawToken(address user, address token, uint amount, uint total);\n', '\n', '    event Cancel(\n', '        uint8 order,\n', '        address owner,\n', '        uint nonce,\n', '        address token,\n', '        uint price,\n', '        uint amount\n', '    );\n', '\n', '    event Order(\n', '        address orderOwner,\n', '        uint orderNonce,\n', '        uint orderPrice,\n', '        uint tradeTokens,\n', '        uint orderFilled,\n', '        uint orderOwnerFinalTokens,\n', '        uint orderOwnerFinalEther,\n', '        uint fees\n', '    );\n', '\n', '    event Trade(\n', '        address trader,\n', '        uint nonce,\n', '        uint trade,\n', '        address token,\n', '        uint traderFinalTokens,\n', '        uint traderFinalEther\n', '    );\n', '\n', '    event NotEnoughTokens(\n', '        address owner, address token, uint shouldHaveAmount, uint actualAmount\n', '    );\n', '    event NotEnoughEther(\n', '        address owner, uint shouldHaveAmount, uint actualAmount\n', '    );\n', '\n', '    //\n', '    // Constructor\n', '    //\n', '\n', '    function Ethen(address _signer) public {\n', '        feeCollector = msg.sender;\n', '        signer       = _signer;\n', '    }\n', '\n', '    //\n', '    // Admin Methods\n', '    //\n', '\n', '    function setFeeCollector(address _addr) external onlyOwner {\n', '        feeCollector = _addr;\n', '    }\n', '\n', '    function setSigner(address _addr) external onlyOwner {\n', '        signer = _addr;\n', '    }\n', '\n', '    function setMakeFee(uint _makeFee) external onlyOwner {\n', '        require(_makeFee <= MAX_FEE);\n', '        makeFee = _makeFee;\n', '        NewMakeFee(makeFee);\n', '    }\n', '\n', '    function setTakeFee(uint _takeFee) external onlyOwner {\n', '        require(_takeFee <= MAX_FEE);\n', '        takeFee = _takeFee;\n', '        NewTakeFee(takeFee);\n', '    }\n', '\n', '    function addPack(\n', '        uint8 _coeff, uint128 _duration, uint _price\n', '    ) external onlyOwner {\n', '        require(_coeff < 100);\n', '        require(_duration > 0);\n', '        require(_price > 0);\n', '\n', '        uint key = packKey(_coeff, _duration);\n', '        packs[key] = _price;\n', '    }\n', '\n', '    function delPack(uint8 _coeff, uint128 _duration) external onlyOwner {\n', '        uint key = packKey(_coeff, _duration);\n', '        delete packs[key];\n', '    }\n', '\n', '    function setExpireDelay(uint _expireDelay) external onlyOwner {\n', '        require(_expireDelay <= MAX_EXPIRE_DELAY);\n', '        expireDelay = _expireDelay;\n', '    }\n', '\n', '    //\n', '    // User Custom Fees\n', '    //\n', '\n', '    function getPack(\n', '        uint8 _coeff, uint128 _duration\n', '    ) public view returns (uint) {\n', '        uint key = packKey(_coeff, _duration);\n', '        return packs[key];\n', '    }\n', '\n', '    // Buys new fee coefficient for given duration of time\n', '    function buyPack(\n', '        uint8 _coeff, uint128 _duration\n', '    ) external payable {\n', '        require(now >= coeffs[msg.sender].expire);\n', '\n', '        uint key = packKey(_coeff, _duration);\n', '        uint price = packs[key];\n', '\n', '        require(price > 0);\n', '        require(msg.value == price);\n', '\n', '        updateCoeff(msg.sender, _coeff, uint128(now) + _duration, price);\n', '\n', '        balances[feeCollector] = SafeMath.add(\n', '            balances[feeCollector], msg.value\n', '        );\n', '    }\n', '\n', '    // Sets new fee coefficient for user\n', '    function setCoeff(\n', '        uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s\n', '    ) external {\n', '        bytes32 hash = keccak256(this, msg.sender, _coeff, _expire);\n', '        require(ecrecover(hash, _v, _r, _s) == signer);\n', '\n', '        require(_coeff < 100);\n', '        require(uint(_expire) > now);\n', '        require(uint(_expire) <= now + 35 days);\n', '\n', '        updateCoeff(msg.sender, _coeff, _expire, 0);\n', '    }\n', '\n', '    //\n', '    // User Balance Related Methods\n', '    //\n', '\n', '    function () external payable {\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\n', '        DepositEther(msg.sender, msg.value, balances[msg.sender]);\n', '    }\n', '\n', '    function depositEther() external payable {\n', '        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\n', '        DepositEther(msg.sender, msg.value, balances[msg.sender]);\n', '    }\n', '\n', '    function withdrawEther(uint _amount) external {\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _amount);\n', '        msg.sender.transfer(_amount);\n', '        WithdrawEther(msg.sender, _amount, balances[msg.sender]);\n', '    }\n', '\n', '    function depositToken(address _token, uint _amount) external {\n', '        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\n', '        tokens[msg.sender][_token] = SafeMath.add(\n', '            tokens[msg.sender][_token], _amount\n', '        );\n', '        DepositToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\n', '    }\n', '\n', '    function withdrawToken(address _token, uint _amount) external {\n', '        tokens[msg.sender][_token] = SafeMath.sub(\n', '            tokens[msg.sender][_token], _amount\n', '        );\n', '        require(ERC20(_token).transfer(msg.sender, _amount));\n', '        WithdrawToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\n', '    }\n', '\n', '    //\n', '    // User Trade Methods\n', '    //\n', '\n', '    // Fills order so it cant be executed later\n', '    function cancel(\n', '        uint8   _order, // BUY for bid orders or SELL for ask orders\n', '        address _token,\n', '        uint    _nonce,\n', '        uint    _price, // Price per 1e18 (PRICE_MUL) tokens\n', '        uint    _amount,\n', '        uint    _expire,\n', '        uint    _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external {\n', '        require(_order == BUY || _order == SELL);\n', '\n', '        if (now > _expire + expireDelay) {\n', '            // already expired\n', '            return;\n', '        }\n', '\n', '        getVerifiedHash(\n', '            msg.sender,\n', '            _order, _token, _nonce, _price, _amount, _expire,\n', '            _v, _r, _s\n', '        );\n', '\n', '        filled[msg.sender][_nonce] = _amount;\n', '\n', '        Cancel(_order, msg.sender, _nonce, _token, _price, _amount);\n', '    }\n', '\n', '    // Does trade, places order\n', '    // Argument hell because of "Stack to deep" errors.\n', '    function trade(\n', '        // _nums[0] 1=BUY, 0=SELL\n', '        // _nums[1] trade.nonce\n', '        // _nums[2] trade.v\n', '        // _nums[3] trade.expire\n', '        // _nums[4] order[0].nonce              First order should have\n', '        // _nums[5] order[0].price              best available price\n', '        // _nums[6] order[0].amount\n', '        // _nums[7] order[0].expire\n', '        // _nums[8] order[0].v\n', '        // _nums[9] order[0].tradeAmount\n', '        // ...\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        // _nums[6N+2] order[N-1].v             N -> 6N+8\n', '        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '        uint[] _nums,\n', '        // _addrs[0] token\n', '        // _addrs[1] order[0].owner\n', '        // ...\n', '        // _addrs[N] order[N-1].owner           N -> N+1\n', '        address[] _addrs,\n', '        // _rss[0] trade.r\n', '        // _rss[1] trade.s\n', '        // _rss[2] order[0].r\n', '        // _rss[3] order[0].s\n', '        // ...\n', '        // _rss[2N]   order[N-1].r              N -> 2N+2\n', '        // _rss[2N+1] order[N-1].s              N -> 2N+3\n', '        bytes32[] _rss\n', '    ) public whenNotPaused {\n', '        // number of orders\n', '        uint N = _addrs.length - 1;\n', '\n', '        require(_nums.length == 6*N+4);\n', '        require(_rss.length == 2*N+2);\n', '\n', '        // Type of trade\n', '        // _nums[0] BUY or SELL\n', '        require(_nums[0] == BUY || _nums[0] == SELL);\n', '\n', '        // _nums[2] placeOrder.nonce\n', '        saveNonce(_nums[1]);\n', '\n', '        // _nums[3] trade.expire\n', '        require(now <= _nums[3]);\n', '\n', '        // Start building hash signed by server\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        // _nums[1] nonce\n', '        // _nums[3] trade.expire\n', '        bytes32 tradeHash = keccak256(\n', '            this, msg.sender, uint8(_nums[0]), _addrs[0], _nums[1], _nums[3]\n', '        );\n', '\n', '        // Hash of an order signed by its owner\n', '        bytes32 orderHash;\n', '\n', '        for (uint i = 0; i < N; i++) {\n', '            checkExpiration(i, _nums);\n', '\n', '            orderHash = verifyOrder(i, _nums, _addrs, _rss);\n', '\n', '            // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '            tradeHash = keccak256(tradeHash, orderHash, _nums[6*i+9]);\n', '\n', '            tradeOrder(i, _nums, _addrs);\n', '        }\n', '\n', '        checkTradeSignature(tradeHash, _nums, _rss);\n', '\n', '        sendTradeEvent(_nums, _addrs);\n', '    }\n', '\n', '    //\n', '    // Private\n', '    //\n', '\n', '    function saveNonce(uint _nonce) private {\n', '        require(trades[msg.sender][_nonce] == false);\n', '        trades[msg.sender][_nonce] = true;\n', '    }\n', '\n', '    // Throws error if order is expired\n', '    function checkExpiration(\n', '        uint _i, // order number\n', '        uint[] _nums\n', '    ) private view {\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        require(now <= _nums[6*_i+7] + expireDelay);\n', '    }\n', '\n', '    // Returns hash of order `_i`, signed by its owner\n', '    function verifyOrder(\n', '        uint _i, // order number\n', '        uint[] _nums,\n', '        address[] _addrs,\n', '        bytes32[] _rss\n', '    ) private view returns (bytes32 _orderHash) {\n', '        // _nums[0] BUY or SELL\n', '        // User is buying orders, that are selling, and vice versa\n', '        uint8 order = _nums[0] == BUY ? uint8(SELL) : uint8(BUY);\n', '\n', '        // _addrs[N] order[N-1].owner       N -> N+1\n', '        // _addrs[0] token\n', '        address owner = _addrs[_i+1];\n', '        address token = _addrs[0];\n', '\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+1] order[N-1].expire        N -> 6N+7\n', '        uint nonce = _nums[6*_i+4];\n', '        uint price = _nums[6*_i+5];\n', '        uint amount = _nums[6*_i+6];\n', '        uint expire = _nums[6*_i+7];\n', '\n', '        // _nums[6N+2] order[N-1].v             N -> 6N+8\n', '        // _rss[2N]   order[N-1].r              N -> 2N+2\n', '        // _rss[2N+1] order[N-1].s              N -> 2N+3\n', '        uint v = _nums[6*_i+8];\n', '        bytes32 r = _rss[2*_i+2];\n', '        bytes32 s = _rss[2*_i+3];\n', '\n', '        _orderHash = getVerifiedHash(\n', '            owner,\n', '            order, token, nonce, price, amount,\n', '            expire, v, r, s\n', '        );\n', '    }\n', '\n', '    // Returns number of traded tokens\n', '    function tradeOrder(\n', '        uint _i, // order number\n', '        uint[] _nums,\n', '        address[] _addrs\n', '    ) private {\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        // _addrs[N] order[N-1].owner           N -> N+1\n', '        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\n', '        // _nums[6N-1] order[N-1].price         N -> 6N+5\n', '        // _nums[6N]   order[N-1].amount        N -> 6N+6\n', '        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\n', '        executeOrder(\n', '            _nums[0],\n', '            _addrs[0],\n', '            _addrs[_i+1],\n', '            _nums[6*_i+4],\n', '            _nums[6*_i+5],\n', '            _nums[6*_i+6],\n', '            _nums[6*_i+9]\n', '        );\n', '    }\n', '\n', '    function checkTradeSignature(\n', '        bytes32 _tradeHash,\n', '        uint[] _nums,\n', '        bytes32[] _rss\n', '    ) private view {\n', '        // _nums[2] trade.v\n', '        // _rss[0] trade.r\n', '        // _rss[1] trade.s\n', '        require(ecrecover(\n', '            _tradeHash, uint8(_nums[2]), _rss[0], _rss[1]\n', '        ) == signer);\n', '    }\n', '\n', '    function sendTradeEvent(\n', '        uint[] _nums, address[] _addrs\n', '    ) private {\n', '        // _nums[1] nonce\n', '        // _nums[0] BUY or SELL\n', '        // _addrs[0] token\n', '        Trade(\n', '            msg.sender, _nums[1], _nums[0], _addrs[0],\n', '            tokens[msg.sender][_addrs[0]], balances[msg.sender]\n', '        );\n', '    }\n', '\n', '    // Executes no more than _tradeAmount tokens from order\n', '    function executeOrder(\n', '        uint    _trade,\n', '        address _token,\n', '        address _orderOwner,\n', '        uint    _orderNonce,\n', '        uint    _orderPrice,\n', '        uint    _orderAmount,\n', '        uint    _tradeAmount\n', '    ) private {\n', '        var (tradeTokens, tradeEther) = getTradeParameters(\n', '            _trade, _token, _orderOwner, _orderNonce, _orderPrice,\n', '            _orderAmount, _tradeAmount\n', '        );\n', '\n', '        filled[_orderOwner][_orderNonce] = SafeMath.add(\n', '            filled[_orderOwner][_orderNonce],\n', '            tradeTokens\n', '        );\n', '\n', '        // Sanity check: orders should never overfill\n', '        require(filled[_orderOwner][_orderNonce] <= _orderAmount);\n', '\n', '        uint makeFees = getFees(tradeEther, makeFee, _orderOwner);\n', '        uint takeFees = getFees(tradeEther, takeFee, msg.sender);\n', '\n', '        swap(\n', '            _trade, _token, _orderOwner, tradeTokens, tradeEther,\n', '            makeFees, takeFees\n', '        );\n', '\n', '        balances[feeCollector] = SafeMath.add(\n', '            balances[feeCollector],\n', '            SafeMath.add(takeFees, makeFees)\n', '        );\n', '\n', '        sendOrderEvent(\n', '            _orderOwner, _orderNonce, _orderPrice, tradeTokens,\n', '            _token, SafeMath.add(takeFees, makeFees)\n', '        );\n', '    }\n', '\n', '    function swap(\n', '        uint _trade,\n', '        address _token,\n', '        address _orderOwner,\n', '        uint _tradeTokens,\n', '        uint _tradeEther,\n', '        uint _makeFees,\n', '        uint _takeFees\n', '    ) private {\n', '        if (_trade == BUY) {\n', '            tokens[msg.sender][_token] = SafeMath.add(\n', '                tokens[msg.sender][_token], _tradeTokens\n', '            );\n', '            tokens[_orderOwner][_token] = SafeMath.sub(\n', '                tokens[_orderOwner][_token], _tradeTokens\n', '            );\n', '            balances[msg.sender] = SafeMath.sub(\n', '                balances[msg.sender], SafeMath.add(_tradeEther, _takeFees)\n', '            );\n', '            balances[_orderOwner] = SafeMath.add(\n', '                balances[_orderOwner], SafeMath.sub(_tradeEther, _makeFees)\n', '            );\n', '        } else {\n', '            tokens[msg.sender][_token] = SafeMath.sub(\n', '                tokens[msg.sender][_token], _tradeTokens\n', '            );\n', '            tokens[_orderOwner][_token] = SafeMath.add(\n', '                tokens[_orderOwner][_token], _tradeTokens\n', '            );\n', '            balances[msg.sender] = SafeMath.add(\n', '                balances[msg.sender], SafeMath.sub(_tradeEther, _takeFees)\n', '            );\n', '            balances[_orderOwner] = SafeMath.sub(\n', '                balances[_orderOwner], SafeMath.add(_tradeEther, _makeFees)\n', '            );\n', '        }\n', '    }\n', '\n', '    function sendOrderEvent(\n', '        address _orderOwner,\n', '        uint _orderNonce,\n', '        uint _orderPrice,\n', '        uint _tradeTokens,\n', '        address _token,\n', '        uint _fees\n', '    ) private {\n', '        Order(\n', '            _orderOwner,\n', '            _orderNonce,\n', '            _orderPrice,\n', '            _tradeTokens,\n', '            filled[_orderOwner][_orderNonce],\n', '            tokens[_orderOwner][_token],\n', '            balances[_orderOwner],\n', '            _fees\n', '        );\n', '    }\n', '\n', '    // Returns number of tokens that could be traded and its total price\n', '    function getTradeParameters(\n', '        uint _trade, address _token, address _orderOwner,\n', '        uint _orderNonce, uint _orderPrice, uint _orderAmount, uint _tradeAmount\n', '    ) private returns (uint _tokens, uint _totalPrice) {\n', '        // remains on order\n', '        _tokens = SafeMath.sub(\n', '            _orderAmount, filled[_orderOwner][_orderNonce]\n', '        );\n', '\n', '        // trade no more than needed\n', '        if (_tokens > _tradeAmount) {\n', '            _tokens = _tradeAmount;\n', '        }\n', '\n', '        if (_trade == BUY) {\n', '            // ask owner has less tokens than it is on ask\n', '            if (_tokens > tokens[_orderOwner][_token]) {\n', '                NotEnoughTokens(\n', '                    _orderOwner, _token, _tokens, tokens[_orderOwner][_token]\n', '                );\n', '                _tokens = tokens[_orderOwner][_token];\n', '            }\n', '        } else {\n', '            // not possible to sell more tokens than sender has\n', '            if (_tokens > tokens[msg.sender][_token]) {\n', '                NotEnoughTokens(\n', '                    msg.sender, _token, _tokens, tokens[msg.sender][_token]\n', '                );\n', '                _tokens = tokens[msg.sender][_token];\n', '            }\n', '        }\n', '\n', '        uint shouldHave = getPrice(_tokens, _orderPrice);\n', '\n', '        uint spendable;\n', '        if (_trade == BUY) {\n', '            // max ether sender can spent\n', '            spendable = reversePercent(\n', '                balances[msg.sender],\n', '                applyCoeff(takeFee, msg.sender)\n', '            );\n', '        } else {\n', '            // max ether bid owner can spent\n', '            spendable = reversePercent(\n', '                balances[_orderOwner],\n', '                applyCoeff(makeFee, _orderOwner)\n', '            );\n', '        }\n', '\n', '        if (shouldHave <= spendable) {\n', '            // everyone have needed amount of tokens & ether\n', '            _totalPrice = shouldHave;\n', '            return;\n', '        }\n', '\n', '        // less price -> less tokens\n', '        _tokens = SafeMath.div(\n', '            SafeMath.mul(spendable, PRICE_MUL), _orderPrice\n', '        );\n', '        _totalPrice = getPrice(_tokens, _orderPrice);\n', '\n', '        if (_trade == BUY) {\n', '            NotEnoughEther(\n', '                msg.sender,\n', '                addFees(shouldHave, applyCoeff(takeFee, msg.sender)),\n', '                _totalPrice\n', '            );\n', '        } else {\n', '            NotEnoughEther(\n', '                _orderOwner,\n', '                addFees(shouldHave, applyCoeff(makeFee, _orderOwner)),\n', '                _totalPrice\n', '            );\n', '        }\n', '    }\n', '\n', '    // Returns price of _tokens\n', '    // _orderPrice is price per 1e18 tokens\n', '    function getPrice(\n', '        uint _tokens, uint _orderPrice\n', '    ) private pure returns (uint) {\n', '        return SafeMath.div(\n', '            SafeMath.mul(_tokens, _orderPrice), PRICE_MUL\n', '        );\n', '    }\n', '\n', '    function getFees(\n', '        uint _eth, uint _fee, address _payer\n', '    ) private view returns (uint) {\n', '        // _eth * (_fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, applyCoeff(_fee, _payer)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    function applyCoeff(uint _fees, address _user) private view returns (uint) {\n', '        if (now >= coeffs[_user].expire) {\n', '            return _fees;\n', '        }\n', '        return SafeMath.div(\n', '            SafeMath.mul(_fees, coeffs[_user].coeff), 100\n', '        );\n', '    }\n', '\n', '    function addFees(uint _eth, uint _fee) private view returns (uint) {\n', '        // _eth * (1 + _fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, SafeMath.add(FEE_MUL, _fee)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    function subFees(uint _eth, uint _fee) private view returns (uint) {\n', '        // _eth * (1 - _fee / FEE_MUL)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_eth, SafeMath.sub(FEE_MUL, _fee)),\n', '            FEE_MUL\n', '        );\n', '    }\n', '\n', '    // Returns maximum ether that can be spent if percent _fee will be added\n', '    function reversePercent(\n', '        uint _balance, uint _fee\n', '    ) private view returns (uint) {\n', '        // _trade + _fees = _balance\n', '        // _trade * (1 + _fee / FEE_MUL) = _balance\n', '        // _trade = _balance * FEE_MUL / (FEE_MUL + _fee)\n', '        return SafeMath.div(\n', '            SafeMath.mul(_balance, FEE_MUL),\n', '            SafeMath.add(FEE_MUL, _fee)\n', '        );\n', '    }\n', '\n', '    // Gets hash of an order, like it is done in `eth_signTypedData`\n', '    // See https://github.com/ethereum/EIPs/pull/712\n', '    function hashOrderTyped(\n', '        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\n', '        uint _expire\n', '    ) private view returns (bytes32) {\n', '        require(_order == BUY || _order == SELL);\n', '        return keccak256(\n', '            ETH_SIGN_TYPED_DATA_ARGHASH,\n', '            keccak256(\n', '                this,\n', '                _order == BUY ? "BUY" : "SELL",\n', '                _token,\n', '                _nonce,\n', '                _price,\n', '                _amount,\n', '                _expire\n', '            )\n', '        );\n', '    }\n', '\n', '    // Gets hash of an order for `eth_sign`\n', '    function hashOrder(\n', '        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\n', '        uint _expire\n', '    ) private view returns (bytes32) {\n', '        return keccak256(\n', '            "\\x19Ethereum Signed Message:\\n32",\n', '            keccak256(this, _order, _token, _nonce, _price, _amount, _expire)\n', '        );\n', '    }\n', '\n', '    // Returns hash of an order\n', '    // Reverts if signature is incorrect\n', '    function getVerifiedHash(\n', '        address _signer,\n', '        uint8 _order, address _token,\n', '        uint _nonce, uint _price, uint _amount, uint _expire,\n', '        uint _v, bytes32 _r, bytes32 _s\n', '    ) private view returns (bytes32 _hash) {\n', '        if (_v < 1000) {\n', '            _hash = hashOrderTyped(\n', '                _order, _token, _nonce, _price, _amount, _expire\n', '            );\n', '            require(ecrecover(_hash, uint8(_v), _r, _s) == _signer);\n', '        } else {\n', '            _hash = hashOrder(\n', '                _order, _token, _nonce, _price, _amount, _expire\n', '            );\n', '            require(ecrecover(_hash, uint8(_v - 1000), _r, _s) == _signer);\n', '        }\n', '    }\n', '\n', '    function packKey(\n', '        uint8 _coeff, uint128 _duration\n', '    ) private pure returns (uint) {\n', '        return (uint(_duration) << 8) + uint(_coeff);\n', '    }\n', '\n', '    function updateCoeff(\n', '        address _user, uint8 _coeff, uint128 _expire, uint price\n', '    ) private {\n', '        coeffs[_user] = Coeff(_coeff, _expire);\n', '        NewFeeCoeff(_user, _coeff, _expire, price);\n', '    }\n', '}']
