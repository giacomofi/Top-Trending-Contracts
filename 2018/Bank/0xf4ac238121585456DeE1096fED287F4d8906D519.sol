['contract StandardToken\n', '{\n', '    string public name;\n', '    string public symbol; \n', '    uint256 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        if( _value > balanceOf[msg.sender] || (balanceOf[_to]+_value) < balanceOf[_to]) return false;\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        if( _value > balanceOf[_from] || _value > allowance[_from][msg.sender] || (balanceOf[_to]+_value) < balanceOf[_to] ) return false;\n', '        balanceOf[_from] -=_value;\n', '        balanceOf[_to] += _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ExtendetdToken is StandardToken\n', '{\n', '    function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) { \n', '        uint256 cnt = _receivers.length;\n', '        uint256 amount = cnt * _value;\n', '        if(amount == 0) return false;\n', '        if(balanceOf[msg.sender] < amount) return false;\n', '        balanceOf[msg.sender] -= amount;\n', '        for (uint i = 0; i < cnt; i++) {\n', '            balanceOf[_receivers[i]] += _value;\n', '            Transfer(msg.sender, _receivers[i], _value);\n', '            }\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Traded is ExtendetdToken\n', '{\n', '    mapping (address=>bool) public managers;\n', '    \n', '    modifier onlyManager()\n', '    {\n', '        if(!managers[msg.sender])throw;\n', '        _;\n', '    }\n', '    \n', '    event deal(address indexed seller, address indexed buyer, uint256 amount, uint256 price, bytes32 indexed data);\n', '    \n', '    function Trade(uint256 _qty, uint256 _price, bytes32 _data, address _seller, address _buyer) payable onlyManager\n', '    {\n', '        if(balanceOf[_seller]<_qty)return;\n', '        if(balanceOf[_buyer]+_qty<balanceOf[_buyer])return;\n', '        uint256 total = _qty*_price;\n', '        _seller.transfer(total);\n', '        balanceOf[_seller]-=_qty;\n', '        balanceOf[_buyer]+=_qty;\n', '        Transfer(_seller,_buyer,_qty);\n', '        deal(_seller,_buyer,_qty,_price,_data);\n', '    }\n', '    \n', '}\n', '\n', 'contract Shark is Traded\n', '{\n', '    function Shark()\n', '    {\n', '        name = "SHARK TECH";\n', '        symbol = "SKT";\n', '        decimals = 18;\n', '        totalSupply = 100000000000000000000000;\n', '        balanceOf[msg.sender]=totalSupply;\n', '        managers[this]=true;\n', '    }\n', '    \n', '    address public owner = msg.sender;\n', '    \n', '    uint256 public price = 1;\n', '    \n', '    modifier onlyHuman()\n', '    {\n', '        if(msg.sender!=tx.origin)throw;\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwner()\n', '    {\n', '        if(msg.sender!=owner)throw;\n', '        _;\n', '    }\n', '    \n', '    function changePrice(uint256 _newPrice)\n', '    onlyOwner\n', '    {\n', '        if(_newPrice>price)\n', '        {\n', '            price = _newPrice;\n', '        }\n', '    }\n', '    \n', '    function Buy()\n', '    payable\n', '    onlyHuman\n', '    {\n', '        if(msg.value<price*1 ether)throw;\n', '        this.Trade(msg.value/price,price,"",owner,msg.sender); \n', '    }\n', '    \n', '    function Sell(uint256 _qty) \n', '    payable\n', '    onlyHuman\n', '    {\n', '        if(this.balance<_qty*price)throw;\n', '        this.Trade(_qty,price,"buyback",msg.sender,owner);\n', '    }\n', '    \n', '    function airDrop(address[] _adr,uint256 _val)\n', '    public\n', '    payable\n', '    {\n', '        if(msg.value >= _adr.length * _val)\n', '        {\n', '            Buy();\n', '            batchTransfer(_adr,_val);\n', '        }\n', '    }\n', '    \n', '    function cashOut(uint256 _am)\n', '    onlyOwner\n', '    payable\n', '    {\n', '        owner.transfer(_am);\n', '    }\n', '    \n', '    function() public payable{}\n', '    \n', '}']