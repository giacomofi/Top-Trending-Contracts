['pragma solidity ^0.4.24;\n', '\n', 'library CheckOverflows {\n', '    function add(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n', '        n3 = n1 + n2;\n', '        require(n3 >= n1);\n', '        return n3;\n', '    }\n', '\n', '    function sub(uint256 n1, uint256 n2) internal pure returns(uint256) {\n', '        require(n2 <= n1);\n', '        return n1 - n2;\n', '    }\n', '\n', '    function mul(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n', '        if (n1 == 0 || n2 == 0) {\n', '            return 0;\n', '        }\n', '\n', '        n3 = n1 * n2;\n', '        require(n3 / n1 == n2);\n', '        return n3;\n', '    }\n', '\n', '    function div(uint256 n1, uint256 n2) internal pure returns(uint256) {\n', '        return n1 / n2;\n', '    }\n', '}\n', '\n', '// PolynomialBonding curve\n', '// Each meme is independent on its own on the eth blockchain\n', 'contract Meme {\n', '    string public ipfsHash;\n', '    address public creator; // aka owner\n', '    uint256 exponent;\n', '    uint256 PRECISION;\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    uint256 public decimals;\n', '\n', '    // amount of wei the smart contract holds\n', '    uint256 public poolBalance;\n', '\n', '    using CheckOverflows for uint256;\n', '\n', '    constructor(string _ipfsHash, address _creator, string _name, uint256 _decimals, uint256 _exponent, uint256 _precision) public {\n', '        ipfsHash = _ipfsHash;\n', '        creator = _creator;\n', '        name = _name;\n', '        decimals = _decimals;        // 18\n', '        exponent = _exponent;        // 1\n', '        PRECISION = _precision;      // experimenting with: 10 billion > 10000000000\n', '\n', '        // to reward creators automatically give tokens 100 * 1000\n', '        totalSupply = 100000;\n', '        tokenBalances[msg.sender] = 100000;\n', '    }\n', '\n', '    // tokens owned by each address\n', '    mapping(address => uint256) public tokenBalances;\n', '\n', '    // Calculate the integral from 0 to t (number to integrate to)\n', '    // https://github.com/CryptoAgainstHumanity/crypto-against-humanity/blob/master/ethereum/contracts/WhiteCard.sol#L249\n', '    function curveIntegral(uint256 _t) internal returns(uint256) {\n', '        uint256 nexp = exponent.add(1);\n', '        // calculate integral t^exponent\n', '        return PRECISION.div(nexp).mul(_t ** nexp).div(PRECISION);\n', '    }\n', '\n', '    // minting new tokens > aka voting\n', '    function mint(uint256 _numTokens) public payable {\n', '        uint256 priceForTokens = getMintingPrice(_numTokens);\n', '        require(msg.value >= priceForTokens, "Not enough value for total price of tokens");\n', '\n', '        totalSupply = totalSupply.add(_numTokens);\n', '        tokenBalances[msg.sender] = tokenBalances[msg.sender].add(_numTokens);\n', '        poolBalance = poolBalance.add(priceForTokens);\n', '\n', '        // send back the change\n', '        if (msg.value > priceForTokens) {\n', '            msg.sender.transfer(msg.value.sub(priceForTokens));\n', '        }\n', '    }\n', '\n', '    function getMintingPrice(uint256 _numTokens) public view returns(uint256) {\n', '        return curveIntegral(totalSupply.add(_numTokens)).sub(poolBalance);\n', '    }\n', '\n', '    // burning tokens >> eth to return\n', '    function burn(uint256 _numTokens) public {\n', '        require(tokenBalances[msg.sender] >= _numTokens, "Not enough owned tokens to burn");\n', '\n', '        uint256 ethToReturn = getBurningReward(_numTokens);\n', '\n', '        totalSupply = totalSupply.sub(_numTokens);\n', '        poolBalance = poolBalance.sub(ethToReturn);\n', '\n', '        // 3% fee go to site creators, the rest to former tokens owner\n', '        uint256 fee = ethToReturn.div(100).mul(3);\n', '\n', '        address(0x45405DAa47EFf12Bc225ddcAC932Ce5ef965B39b).transfer(fee);\n', '        msg.sender.transfer(ethToReturn.sub(fee));\n', '    }\n', '\n', '    function getBurningReward(uint256 _numTokens) public view returns(uint256) {\n', '        return poolBalance.sub(curveIntegral(totalSupply.sub(_numTokens)));\n', '    }\n', '\n', '    function kill() public {\n', '        // I give myself the ability to kill any contracts, though will only do so with duplicates aka cheaters\n', '        require(msg.sender == address(0xE76197fAa1C8c4973087d9d79064d2bb6F940946));\n', '        selfdestruct(this);\n', '    }\n', '}\n', '\n', '// Factory contract: keeps track of meme for only leaderboard and view purposes\n', 'contract MemeRecorder {\n', '    address[] public memeContracts;\n', '\n', '    constructor() public {}\n', '\n', '    function addMeme(string _ipfsHash, string _name) public {\n', '        Meme newMeme;\n', '        newMeme = new Meme(_ipfsHash, msg.sender, _name, 18, 1, 10000000000);\n', '        memeContracts.push(newMeme);\n', '    }\n', '\n', '    function getMemes() public view returns(address[]) {\n', '        return memeContracts;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library CheckOverflows {\n', '    function add(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n', '        n3 = n1 + n2;\n', '        require(n3 >= n1);\n', '        return n3;\n', '    }\n', '\n', '    function sub(uint256 n1, uint256 n2) internal pure returns(uint256) {\n', '        require(n2 <= n1);\n', '        return n1 - n2;\n', '    }\n', '\n', '    function mul(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n', '        if (n1 == 0 || n2 == 0) {\n', '            return 0;\n', '        }\n', '\n', '        n3 = n1 * n2;\n', '        require(n3 / n1 == n2);\n', '        return n3;\n', '    }\n', '\n', '    function div(uint256 n1, uint256 n2) internal pure returns(uint256) {\n', '        return n1 / n2;\n', '    }\n', '}\n', '\n', '// PolynomialBonding curve\n', '// Each meme is independent on its own on the eth blockchain\n', 'contract Meme {\n', '    string public ipfsHash;\n', '    address public creator; // aka owner\n', '    uint256 exponent;\n', '    uint256 PRECISION;\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    uint256 public decimals;\n', '\n', '    // amount of wei the smart contract holds\n', '    uint256 public poolBalance;\n', '\n', '    using CheckOverflows for uint256;\n', '\n', '    constructor(string _ipfsHash, address _creator, string _name, uint256 _decimals, uint256 _exponent, uint256 _precision) public {\n', '        ipfsHash = _ipfsHash;\n', '        creator = _creator;\n', '        name = _name;\n', '        decimals = _decimals;        // 18\n', '        exponent = _exponent;        // 1\n', '        PRECISION = _precision;      // experimenting with: 10 billion > 10000000000\n', '\n', '        // to reward creators automatically give tokens 100 * 1000\n', '        totalSupply = 100000;\n', '        tokenBalances[msg.sender] = 100000;\n', '    }\n', '\n', '    // tokens owned by each address\n', '    mapping(address => uint256) public tokenBalances;\n', '\n', '    // Calculate the integral from 0 to t (number to integrate to)\n', '    // https://github.com/CryptoAgainstHumanity/crypto-against-humanity/blob/master/ethereum/contracts/WhiteCard.sol#L249\n', '    function curveIntegral(uint256 _t) internal returns(uint256) {\n', '        uint256 nexp = exponent.add(1);\n', '        // calculate integral t^exponent\n', '        return PRECISION.div(nexp).mul(_t ** nexp).div(PRECISION);\n', '    }\n', '\n', '    // minting new tokens > aka voting\n', '    function mint(uint256 _numTokens) public payable {\n', '        uint256 priceForTokens = getMintingPrice(_numTokens);\n', '        require(msg.value >= priceForTokens, "Not enough value for total price of tokens");\n', '\n', '        totalSupply = totalSupply.add(_numTokens);\n', '        tokenBalances[msg.sender] = tokenBalances[msg.sender].add(_numTokens);\n', '        poolBalance = poolBalance.add(priceForTokens);\n', '\n', '        // send back the change\n', '        if (msg.value > priceForTokens) {\n', '            msg.sender.transfer(msg.value.sub(priceForTokens));\n', '        }\n', '    }\n', '\n', '    function getMintingPrice(uint256 _numTokens) public view returns(uint256) {\n', '        return curveIntegral(totalSupply.add(_numTokens)).sub(poolBalance);\n', '    }\n', '\n', '    // burning tokens >> eth to return\n', '    function burn(uint256 _numTokens) public {\n', '        require(tokenBalances[msg.sender] >= _numTokens, "Not enough owned tokens to burn");\n', '\n', '        uint256 ethToReturn = getBurningReward(_numTokens);\n', '\n', '        totalSupply = totalSupply.sub(_numTokens);\n', '        poolBalance = poolBalance.sub(ethToReturn);\n', '\n', '        // 3% fee go to site creators, the rest to former tokens owner\n', '        uint256 fee = ethToReturn.div(100).mul(3);\n', '\n', '        address(0x45405DAa47EFf12Bc225ddcAC932Ce5ef965B39b).transfer(fee);\n', '        msg.sender.transfer(ethToReturn.sub(fee));\n', '    }\n', '\n', '    function getBurningReward(uint256 _numTokens) public view returns(uint256) {\n', '        return poolBalance.sub(curveIntegral(totalSupply.sub(_numTokens)));\n', '    }\n', '\n', '    function kill() public {\n', '        // I give myself the ability to kill any contracts, though will only do so with duplicates aka cheaters\n', '        require(msg.sender == address(0xE76197fAa1C8c4973087d9d79064d2bb6F940946));\n', '        selfdestruct(this);\n', '    }\n', '}\n', '\n', '// Factory contract: keeps track of meme for only leaderboard and view purposes\n', 'contract MemeRecorder {\n', '    address[] public memeContracts;\n', '\n', '    constructor() public {}\n', '\n', '    function addMeme(string _ipfsHash, string _name) public {\n', '        Meme newMeme;\n', '        newMeme = new Meme(_ipfsHash, msg.sender, _name, 18, 1, 10000000000);\n', '        memeContracts.push(newMeme);\n', '    }\n', '\n', '    function getMemes() public view returns(address[]) {\n', '        return memeContracts;\n', '    }\n', '}']
