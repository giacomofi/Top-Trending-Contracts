['pragma solidity ^0.4.22;\n', '\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src,\n', '        address dst,\n', '        bytes4 sig\n', '        ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Exchange is DSAuth {\n', '\n', '    ERC20 public daiToken;\n', '    mapping(address => uint) public dai;\n', '    mapping(address => uint) public eth;\n', '\n', '    mapping(address => uint) public totalEth;\n', '    mapping(address => uint) public totalDai;\n', '\n', '    mapping(bytes32 => mapping(address => uint)) public callsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public putsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public callsSold;\n', '    mapping(bytes32 => mapping(address => uint)) public putsSold;\n', '\n', '    mapping(bytes32 => uint) public callsAssigned;\n', '    mapping(bytes32 => uint) public putsAssigned;\n', '    mapping(bytes32 => uint) public callsExercised;\n', '    mapping(bytes32 => uint) public putsExercised;\n', '\n', '    mapping(address => mapping(bytes32 => bool)) public cancelled;\n', '    mapping(address => mapping(bytes32 => uint)) public filled;\n', '\n', '    // fee values are actually in DAI, ether is just a keyword\n', '    uint public flatFee       = 7 ether;\n', '    uint public contractFee   = 1 ether;\n', '    uint public exerciseFee   = 20 ether;\n', '    uint public settlementFee = 20 ether;\n', '    uint public feesCollected = 0;\n', '\n', '    string precisionError = "Precision";\n', '\n', '    constructor(address daiAddress) public {\n', '        require(daiAddress != 0x0);\n', '        daiToken = ERC20(daiAddress);\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    event Deposit(address indexed account, uint amount);\n', '    event Withdraw(address indexed account, uint amount, address to);\n', '    event DepositDai(address indexed account, uint amount);\n', '    event WithdrawDai(address indexed account, uint amount, address to);\n', '\n', '    function deposit() public payable {\n', '        _addEth(msg.value, msg.sender);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function depositDai(uint amount) public {\n', '        require(daiToken.transferFrom(msg.sender, this, amount));\n', '        _addDai(amount, msg.sender);\n', '        emit DepositDai(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint amount, address to) public {\n', '        require(to != 0x0);\n', '        _subEth(amount, msg.sender);\n', '        to.transfer(amount);\n', '        emit Withdraw(msg.sender, amount, to);\n', '    }\n', '\n', '    function withdrawDai(uint amount, address to) public {\n', '        require(\n', '            to != 0x0 &&\n', '            daiToken.transfer(to, amount)\n', '        );\n', '        _subDai(amount, msg.sender);\n', '        emit WithdrawDai(msg.sender, amount, to);\n', '    }\n', '\n', '    function depositDaiFor(uint amount, address account) public {\n', '        require(\n', '            account != 0x0 &&\n', '            daiToken.transferFrom(msg.sender, this, amount)\n', '        );\n', '        _addDai(amount, account);\n', '        emit DepositDai(account, amount);\n', '    }\n', '\n', '    function _addEth(uint amount, address account) private {\n', '        eth[account] += amount;\n', '        totalEth[account] += amount;\n', '    }\n', '\n', '    function _subEth(uint amount, address account) private {\n', '        require(eth[account] >= amount);\n', '        eth[account] -= amount;\n', '        totalEth[account] -= amount;\n', '    }\n', '\n', '    function _addDai(uint amount, address account) private {\n', '        dai[account] += amount;\n', '        totalDai[account] += amount;\n', '    }\n', '\n', '    function _subDai(uint amount, address account) private {\n', '        require(dai[account] >= amount);\n', '        dai[account] -= amount;\n', '        totalDai[account] -= amount;\n', '    }\n', '\n', '    // ===== Admin functions ===== //\n', '\n', '    function setFeeSchedule(\n', '        uint _flatFee,\n', '        uint _contractFee,\n', '        uint _exerciseFee,\n', '        uint _settlementFee\n', '    ) public auth {\n', '        flatFee = _flatFee;\n', '        contractFee = _contractFee;\n', '        exerciseFee = _exerciseFee;\n', '        settlementFee = _settlementFee;\n', '\n', '        require(\n', '            contractFee < 5 ether &&\n', '            flatFee < 6.95 ether &&\n', '            exerciseFee < 20 ether &&\n', '            settlementFee < 20 ether\n', '        );\n', '    }\n', '\n', '    function withdrawFees(address to) public auth {\n', '        require(to != 0x0);\n', '        uint amount = feesCollected;\n', '        feesCollected = 0;\n', '        daiToken.transfer(to, amount);\n', '    }\n', '\n', '    // ===== End Admin Functions ===== //\n', '\n', '    modifier hasFee(uint amount) {\n', '        _;\n', '        _collectFee(msg.sender, calculateFee(amount));\n', '    }\n', '\n', '    enum Action {\n', '        BuyCallToOpen,\n', '        BuyCallToClose,\n', '        SellCallToOpen,\n', '        SellCallToClose,\n', '        BuyPutToOpen,\n', '        BuyPutToClose,\n', '        SellPutToOpen,\n', '        SellPutToClose\n', '    }\n', '\n', '    event CancelOrder(address indexed account, bytes32 h);\n', '    function cancelOrder(bytes32 h) public {\n', '        cancelled[msg.sender][h] = true;\n', '        emit CancelOrder(msg.sender, h);\n', '    }\n', '\n', '    function callBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellCallToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bcto(amount, expiration, price, strike, msg.sender);\n', '        _scto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellCallToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bcto(amount, expiration, price, strike, msg.sender);\n', '        _sctc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellCallToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bctc(amount, expiration, price, strike, msg.sender);\n', '        _scto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellCallToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bctc(amount, expiration, price, strike, msg.sender);\n', '        _sctc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyCallToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _scto(amount, expiration, price, strike, msg.sender);\n', '        _bcto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyCallToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _scto(amount, expiration, price, strike, msg.sender);\n', '        _bctc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyCallToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _sctc(amount, expiration, price, strike, msg.sender);\n', '        _bcto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyCallToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _sctc(amount, expiration, price, strike, msg.sender);\n', '        _bctc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _bcto(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '        _subDai(premium, buyer);\n', '\n', '        require(callsOwned[series][buyer] + amount >= callsOwned[series][buyer]);\n', '        callsOwned[series][buyer] += amount;\n', '        emit BuyCallToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _bctc(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        _subDai(premium, buyer);\n', '        eth[buyer] += amount;\n', '        require(callsSold[series][buyer] >= amount);\n', '        callsSold[series][buyer] -= amount;\n', '        emit BuyCallToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _scto(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        _addDai(premium, seller);\n', '        require(\n', '            eth[seller] >= amount &&\n', '            callsSold[series][seller] + amount >= callsSold[series][seller]\n', '        );\n', '        eth[seller] -= amount;\n', '        callsSold[series][seller] += amount;\n', '        emit SellCallToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sctc(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        _addDai(premium, seller);\n', '        require(callsOwned[series][seller] >= amount);\n', '        callsOwned[series][seller] -= amount;\n', '        emit SellCallToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExerciseCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exerciseCall(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        uint cost = amount * strike / 1 ether;\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(\n', '            now < expiration &&\n', '            amount % 1 finney == 0 &&\n', '            callsOwned[series][msg.sender] >= amount &&\n', '            amount > 0\n', '        );\n', '\n', '        callsOwned[series][msg.sender] -= amount;\n', '        callsExercised[series] += amount;\n', '\n', '        _collectFee(msg.sender, exerciseFee);\n', '        _subDai(cost, msg.sender);\n', '        _addEth(amount, msg.sender);\n', '        emit ExerciseCall(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettleCall(address indexed account, uint expiration, uint strike);\n', '    function settleCall(uint expiration, uint strike, address writer) public {\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(\n', '            (msg.sender == writer || isAuthorized(msg.sender, msg.sig)) &&\n', '            now > expiration &&\n', '            callsSold[series][writer] > 0\n', '        );\n', '\n', '        if (callsAssigned[series] < callsExercised[series]) {\n', '            uint maximum = callsSold[series][writer];\n', '            uint needed = callsExercised[series] - callsAssigned[series];\n', '            uint assignment = needed > maximum ? maximum : needed;\n', '\n', '            totalEth[writer] -= assignment;\n', '            callsAssigned[series] += assignment;\n', '            callsSold[series][writer] -= assignment;\n', '\n', '            uint value = strike * assignment / 1 ether;\n', '            _addDai(value, writer);\n', '            emit AssignCall(msg.sender, assignment, expiration, strike);\n', '        }\n', '\n', '        _collectFee(writer, settlementFee);\n', '        eth[writer] += callsSold[series][writer];\n', '        callsSold[series][writer] = 0;\n', '        emit SettleCall(writer, expiration, strike);\n', '    }\n', '\n', '\n', '    // ========== PUT OPTIONS EXCHANGE ========== //\n', '\n', '    function putBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellPutToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bpto(amount, expiration, price, strike, msg.sender);\n', '        _spto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellPutToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bpto(amount, expiration, price, strike, msg.sender);\n', '        _sptc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellPutToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bptc(amount, expiration, price, strike, msg.sender);\n', '        _spto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.SellPutToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _bptc(amount, expiration, price, strike, msg.sender);\n', '        _sptc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyPutToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _spto(amount, expiration, price, strike, msg.sender);\n', '        _bpto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyPutToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _spto(amount, expiration, price, strike, msg.sender);\n', '        _bptc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyPutToOpen, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _sptc(amount, expiration, price, strike, msg.sender);\n', '        _bpto(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        address maker = _validate(Action.BuyPutToClose, amount, expiration, nonce, price, size, strike, validUntil, r, s, v);\n', '        _sptc(amount, expiration, price, strike, msg.sender);\n', '        _bptc(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _bpto(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        _subDai(premium, buyer);\n', '        require(putsOwned[series][buyer] + amount >= putsOwned[series][buyer]);\n', '        putsOwned[series][buyer] += amount;\n', '        emit BuyPutToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _bptc(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        dai[buyer] += strike * amount / 1 ether;\n', '        _subDai(premium, buyer);\n', '        require(putsSold[series][buyer] >= amount);\n', '        putsSold[series][buyer] -= amount;\n', '        emit BuyPutToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _spto(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '        uint escrow = strike * amount / 1 ether;\n', '\n', '        _addDai(premium, seller);\n', '        require(dai[seller] >= escrow);\n', '        dai[seller] -= escrow;\n', '        putsSold[series][seller] += amount;\n', '        emit SellPutToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sptc(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount * price / 1 ether;\n', '\n', '        _addDai(premium, seller);\n', '        require(putsOwned[series][seller] >= amount);\n', '        putsOwned[series][seller] -= amount;\n', '        emit SellPutToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExercisePut(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exercisePut(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        uint yield = amount * strike / 1 ether;\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(\n', '            now < expiration &&\n', '            amount % 1 finney == 0 &&\n', '            putsOwned[series][msg.sender] >= amount &&\n', '            amount > 0\n', '        );\n', '\n', '        putsOwned[series][msg.sender] -= amount;\n', '        putsExercised[series] += amount;\n', '\n', '        _subEth(amount, msg.sender);\n', '        _addDai(yield, msg.sender);\n', '        _collectFee(msg.sender, exerciseFee);\n', '        emit ExercisePut(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignPut(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettlePut(address indexed account, uint expiration, uint strike);\n', '    function settlePut(uint expiration, uint strike, address writer) public {\n', '\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(\n', '            (msg.sender == writer || isAuthorized(msg.sender, msg.sig)) &&\n', '            now > expiration &&\n', '            putsSold[series][writer] > 0\n', '        );\n', '\n', '        if (putsAssigned[series] < putsExercised[series]) {\n', '            uint maximum = putsSold[series][writer];\n', '            uint needed = putsExercised[series] - putsAssigned[series];\n', '            uint assignment = maximum > needed ? needed : maximum;\n', '\n', '            totalDai[writer] -= assignment * strike / 1 ether;\n', '            putsSold[series][writer] -= assignment;\n', '            putsAssigned[series] += assignment;\n', '\n', '            _addEth(assignment, writer);\n', '            emit AssignPut(writer, assignment, expiration, strike);\n', '        }\n', '\n', '        uint yield = putsSold[series][writer] * strike / 1 ether;\n', '        _collectFee(writer, settlementFee);\n', '        dai[writer] += yield;\n', '        putsSold[series][writer] = 0;\n', '        emit SettlePut(writer, expiration, strike);\n', '    }\n', '\n', '    function calculateFee(uint amount) public view returns (uint) {\n', '        return amount * contractFee / 1 ether + flatFee;\n', '    }\n', '\n', '    function _validate(\n', '        Action action,\n', '        uint amount,\n', '        uint expiration,\n', '        bytes32 nonce,\n', '        uint price,\n', '        uint size,\n', '        uint strike,\n', '        uint validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8 v\n', '    ) private returns (address) {\n', '        bytes32 h = keccak256(action, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", h), v, r, s);\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        return maker;\n', '    }\n', '\n', '    event TakeOrder(address indexed account, address maker, uint amount, bytes32 h);\n', '    function _validateOrder(uint amount, uint expiration, bytes32 h, address maker, uint price, uint validUntil, uint size, uint strike) internal {\n', '        require(\n', '            strike % 1 ether == 0 &&\n', '            amount % 1 finney == 0 &&\n', '            price % 1 finney == 0 &&\n', '            expiration % 86400 == 0 &&\n', '            cancelled[maker][h] == false &&\n', '            amount <= size - filled[maker][h] &&\n', '            now < validUntil &&\n', '            now < expiration &&\n', '            strike > 10 ether &&\n', '            price < 1200000 ether &&\n', '            size < 1200000 ether &&\n', '            strike < 1200000 ether &&\n', '            price >= 1 finney\n', '        );\n', '\n', '        filled[maker][h] += amount;\n', '        emit TakeOrder(msg.sender, maker, amount, h);\n', '    }\n', '\n', '    function _collectFee(address account, uint amount) private {\n', '        _subDai(amount, account);\n', '        feesCollected += amount;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}']