['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/TxRegistry.sol\n', '\n', '/**\n', '* @title Transaction Registry for Customer\n', '* @dev Registry of customer&#39;s payments for MCW and payments for KWh.\n', '*/\n', 'contract TxRegistry is Ownable {\n', '    address public customer;\n', '\n', '    // @dev Structure for TX data\n', '    struct TxData {\n', '        bytes32 txOrigMcwTransfer;\n', '        uint256 amountMCW;\n', '        uint256 amountKWh;\n', '        uint256 timestampPaymentMCW;\n', '        bytes32 txPaymentKWh;\n', '        uint256 timestampPaymentKWh;\n', '    }\n', '\n', '    // @dev Customer&#39;s Tx of payment for MCW registry    \n', '    mapping (bytes32 => TxData) private txRegistry;\n', '\n', '    // @dev Customer&#39;s list of Tx   \n', '    bytes32[] private txIndex;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    * @param _customer the address of a customer for whom the TxRegistry contract is creating\n', '    */    \n', '    constructor(address _customer) public {\n', '        customer = _customer;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can add a new Tx of payment for MCW to the customer&#39;s TxRegistry\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which will be added\n', '    * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for this Tx of payment for MCW\n', '    * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx\n', '    * @param _amountKWh the amount of KWh which will be recorded to the new Tx\n', '    * @param _timestamp the timestamp of payment for MCW which will be recorded to the new Tx\n', '    */\n', '    function addTxToRegistry(\n', '        bytes32 _txPaymentForMCW,\n', '        bytes32 _txOrigMcwTransfer,\n', '        uint256 _amountMCW,\n', '        uint256 _amountKWh,\n', '        uint256 _timestamp\n', '        ) public onlyOwner returns(bool)\n', '    {\n', '        require(\n', '            _txPaymentForMCW != 0 && _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0 && _timestamp != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentMCW == 0,\n', '            "Tx with such hash is already exist."\n', '        );\n', '\n', '        txRegistry[_txPaymentForMCW].txOrigMcwTransfer = _txOrigMcwTransfer;\n', '        txRegistry[_txPaymentForMCW].amountMCW = _amountMCW;\n', '        txRegistry[_txPaymentForMCW].amountKWh = _amountKWh;\n', '        txRegistry[_txPaymentForMCW].timestampPaymentMCW = _timestamp;\n', '        txIndex.push(_txPaymentForMCW);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can mark a customer&#39;s Tx of payment for MCW as spent\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent\n', '    * @param _txPaymentForKWh the additional Tx of payment for KWh which will be recorded to the original Tx as proof of spend\n', '    * @param _timestamp the timestamp of payment for KWh which will be recorded to the Tx\n', '    */\n', '    function setTxAsSpent(bytes32 _txPaymentForMCW, bytes32 _txPaymentForKWh, uint256 _timestamp) public onlyOwner returns(bool) {\n', '        require(\n', '            _txPaymentForMCW != 0 && _txPaymentForKWh != 0 && _timestamp != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0,\n', '            "Tx with such hash doesn&#39;t exist."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentKWh == 0,\n', '            "Tx with such hash is already spent."\n', '        );\n', '\n', '        txRegistry[_txPaymentForMCW].txPaymentKWh = _txPaymentForKWh;\n', '        txRegistry[_txPaymentForMCW].timestampPaymentKWh = _timestamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW amount\n', '    */   \n', '    function getTxCount() public view returns(uint256) {\n', '        return txIndex.length;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW from customer&#39;s Tx list by index\n', '    * @param _index the index of a customer&#39;s Tx of payment for MCW in the customer&#39;s Tx list\n', '    */  \n', '    function getTxAtIndex(uint256 _index) public view returns(bytes32) {\n', '        return txIndex[_index];\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxOrigMcwTransfer(bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        return txRegistry[_txPaymentForMCW].txOrigMcwTransfer;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxAmountMCW(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].amountMCW;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - amount of KWh which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxAmountKWh(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].amountKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxTimestampPaymentMCW(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].timestampPaymentMCW;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxPaymentKWh(bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        return txRegistry[_txPaymentForMCW].txPaymentKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxTimestampPaymentKWh(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].timestampPaymentKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Check the customer&#39;s Tx of payment for MCW\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */  \n', '    function isValidTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        bool isValid = false;\n', '        if (txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0) {\n', '            isValid = true;\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', '    * @dev Check if the customer&#39;s Tx of payment for MCW is spent\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */\n', '    function isSpentTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        bool isSpent = false;\n', '        if (txRegistry[_txPaymentForMCW].timestampPaymentKWh != 0) {\n', '            isSpent = true;\n', '        }\n', '        return isSpent;\n', '    }\n', '\n', '    /**\n', '    * @dev Check the customer&#39;s Tx of payment for KWh\n', '    * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked\n', '    */\n', '    function isValidTxPaymentForKWh(bytes32 _txPaymentForKWh) public view returns(bool) {\n', '        bool isValid = false;\n', '        for (uint256 i = 0; i < getTxCount(); i++) {\n', '            if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) {\n', '                isValid = true;\n', '                break;\n', '            }\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW by Tx payment for KWh \n', '    * @param _txPaymentForKWh the Tx of payment for KWh\n', '    */\n', '    function getTxPaymentMCW(bytes32 _txPaymentForKWh) public view returns(bytes32) {\n', '        bytes32 txMCW = 0;\n', '        for (uint256 i = 0; i < getTxCount(); i++) {\n', '            if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) {\n', '                txMCW = getTxAtIndex(i);\n', '                break;\n', '            }\n', '        }\n', '        return txMCW;\n', '    }\n', '}\n', '\n', '// File: contracts/McwCustomerRegistry.sol\n', '\n', '/**\n', '* @title Customers Registry\n', '* @dev Registry of all customers\n', '*/\n', 'contract McwCustomerRegistry is Ownable {\n', '    // @dev Key: address of customer wallet, Value: address of customer TxRegistry contract\n', '    mapping (address => address) private registry;\n', '\n', '    // @dev Customers list\n', '    address[] private customerIndex;\n', '\n', '    // @dev Events for dashboard\n', '    event NewCustomer(address indexed customer, address indexed txRegistry);\n', '    event NewCustomerTx(\n', '        address indexed customer,\n', '        bytes32 txPaymentForMCW,\n', '        bytes32 txOrigMcwTransfer,\n', '        uint256 amountMCW,\n', '        uint256 amountKWh,\n', '        uint256 timestamp\n', '    );\n', '    event SpendCustomerTx(address indexed customer, bytes32 txPaymentForMCW, bytes32 txPaymentForKWh, uint256 timestamp);\n', '\n', '    // @dev Constructor\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Owner can add a new customer to registry\n', '    * @dev Creates a related TxRegistry contract for the new customer\n', '    * @dev Related event will be generated\n', '    * @param _customer the address of a new customer to add\n', '    */\n', '    function addCustomerToRegistry(address _customer) public onlyOwner returns(bool) {\n', '        require(\n', '            _customer != address(0),\n', '            "Parameter must be not empty."\n', '        );\n', '        require(\n', '            registry[_customer] == address(0),\n', '            "Customer is already in the registry."\n', '        );\n', '\n', '        address txRegistry = new TxRegistry(_customer);\n', '        registry[_customer] = txRegistry;\n', '        customerIndex.push(_customer);\n', '        emit NewCustomer(_customer, txRegistry);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can add a new Tx of payment for MCW to the customer&#39;s TxRegistry\n', '    * @dev Generates the Tx of payment for MCW (hash as proof of payment) and writes the Tx data to the customer&#39;s TxRegistry\n', '    * @dev Related event will be generated\n', '    * @param _customer the address of a customer to whom to add a new Tx\n', '    * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for a new Tx of payment for MCW\n', '    * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx\n', '    * @param _amountKWh the amount of KWh which will be recorded to the new Tx\n', '    */\n', '    function addTxToCustomerRegistry(\n', '        address _customer,\n', '        bytes32 _txOrigMcwTransfer,\n', '        uint256 _amountMCW,\n', '        uint256 _amountKWh\n', '        ) public onlyOwner returns(bool)\n', '    {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '\n', '        uint256 timestamp = now;\n', '        bytes32 txPaymentForMCW = keccak256(\n', '            abi.encodePacked(\n', '                _customer,\n', '                _amountMCW,\n', '                _amountKWh,\n', '                timestamp)\n', '            );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        require(\n', '            txRegistry.getTxTimestampPaymentMCW(txPaymentForMCW) == 0,\n', '            "Tx with such hash is already exist."\n', '        );\n', '\n', '        if (!txRegistry.addTxToRegistry(\n', '            txPaymentForMCW,\n', '            _txOrigMcwTransfer,\n', '            _amountMCW,\n', '            _amountKWh,\n', '            timestamp))\n', '            revert ("Something went wrong.");\n', '        emit NewCustomerTx(\n', '            _customer,\n', '            txPaymentForMCW,\n', '            _txOrigMcwTransfer,\n', '            _amountMCW,\n', '            _amountKWh,\n', '            timestamp);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can mark a customer&#39;s Tx of payment for MCW as spent\n', '    * @dev Generates an additional Tx of paymant for KWh (hash as proof of spend), which connected to the original Tx.\n', '    * @dev Related event will be generated\n', '    * @param _customer the address of a customer to whom to spend a Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent\n', '    */\n', '    function setCustomerTxAsSpent(address _customer, bytes32 _txPaymentForMCW) public onlyOwner returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        require(\n', '            txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW) != 0,\n', '            "Tx with such hash doesn&#39;t exist."\n', '        );\n', '        require(\n', '            txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW) == 0,\n', '            "Tx with such hash is already spent."\n', '        );\n', '\n', '        uint256 timestamp = now;\n', '        bytes32 txPaymentForKWh = keccak256(\n', '            abi.encodePacked(\n', '                _txPaymentForMCW,\n', '                timestamp)\n', '            );\n', '\n', '        if (!txRegistry.setTxAsSpent(_txPaymentForMCW, txPaymentForKWh, timestamp))\n', '            revert ("Something went wrong.");\n', '        emit SpendCustomerTx(\n', '            _customer,\n', '            _txPaymentForMCW,\n', '            txPaymentForKWh,\n', '            timestamp);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the current amount of customers\n', '    */\n', '    function getCustomerCount() public view returns(uint256) {\n', '        return customerIndex.length;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s address from customers list by index\n', '    * @param _index the index of a customer in the customers list\n', '    */    \n', '    function getCustomerAtIndex(uint256 _index) public view returns(address) {\n', '        return customerIndex[_index];\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s TxRegistry contract\n', '    * @param _customer the address of a customer for whom to get TxRegistry contract \n', '    */   \n', '    function getCustomerTxRegistry(address _customer) public view returns(address) {\n', '        return registry[_customer];\n', '    }\n', '\n', '    /**\n', '    * @dev Check the customer&#39;s address\n', '    * @param _customer the address of a customer which need to be checked\n', '    */   \n', '    function isValidCustomer(address _customer) public view returns(bool) {\n', '        require(\n', '            _customer != address(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        bool isValid = false;\n', '        address txRegistry = registry[_customer];\n', '        if (txRegistry != address(0)) {\n', '            isValid = true;\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    // wrappers on TxRegistry contract\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW amount\n', '    * @param _customer the address of a customer for whom to get\n', '    */   \n', '    function getCustomerTxCount(address _customer) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 txCount = txRegistry.getTxCount();\n', '        return txCount;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW from customer&#39;s Tx list by index\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _index the index of a customer&#39;s Tx of payment for MCW in the customer&#39;s Tx list\n', '    */       \n', '    function getCustomerTxAtIndex(address _customer, uint256 _index) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txIndex = txRegistry.getTxAtIndex(_index);\n', '        return txIndex;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxOrigMcwTransfer(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txOrigMcwTransfer = txRegistry.getTxOrigMcwTransfer(_txPaymentForMCW);\n', '        return txOrigMcwTransfer;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxAmountMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 amountMCW = txRegistry.getTxAmountMCW(_txPaymentForMCW);\n', '        return amountMCW;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - amount of KWh which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxAmountKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 amountKWh = txRegistry.getTxAmountKWh(_txPaymentForMCW);\n', '        return amountKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxTimestampPaymentMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 timestampPaymentMCW = txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW);\n', '        return timestampPaymentMCW;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txPaymentKWh = txRegistry.getTxPaymentKWh(_txPaymentForMCW);\n', '        return txPaymentKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx\n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxTimestampPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 timestampPaymentKWh = txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW);\n', '        return timestampPaymentKWh;\n', '    }\n', '\n', '    /**\n', '    * @dev Check the customer&#39;s Tx of payment for MCW\n', '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */  \n', '    function isValidCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isValid = txRegistry.isValidTxPaymentForMCW(_txPaymentForMCW);\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', '    * @dev Check if the customer&#39;s Tx of payment for MCW is spent\n', '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */\n', '    function isSpentCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isSpent = txRegistry.isSpentTxPaymentForMCW(_txPaymentForMCW);\n', '        return isSpent;\n', '    }\n', '\n', '    /**\n', '    * @dev Check the customer&#39;s Tx of payment for KWh\n', '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked\n', '    */\n', '    function isValidCustomerTxPaymentForKWh(address _customer, bytes32 _txPaymentForKWh) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForKWh != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isValid = txRegistry.isValidTxPaymentForKWh(_txPaymentForKWh);\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the customer&#39;s Tx of payment for MCW by Tx payment for KWh \n', '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForKWh the Tx of payment for KWh\n', '    */\n', '    function getCustomerTxPaymentMCW(address _customer, bytes32 _txPaymentForKWh) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForKWh != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txMCW = txRegistry.getTxPaymentMCW(_txPaymentForKWh);\n', '        return txMCW;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/TxRegistry.sol\n', '\n', '/**\n', '* @title Transaction Registry for Customer\n', "* @dev Registry of customer's payments for MCW and payments for KWh.\n", '*/\n', 'contract TxRegistry is Ownable {\n', '    address public customer;\n', '\n', '    // @dev Structure for TX data\n', '    struct TxData {\n', '        bytes32 txOrigMcwTransfer;\n', '        uint256 amountMCW;\n', '        uint256 amountKWh;\n', '        uint256 timestampPaymentMCW;\n', '        bytes32 txPaymentKWh;\n', '        uint256 timestampPaymentKWh;\n', '    }\n', '\n', "    // @dev Customer's Tx of payment for MCW registry    \n", '    mapping (bytes32 => TxData) private txRegistry;\n', '\n', "    // @dev Customer's list of Tx   \n", '    bytes32[] private txIndex;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    * @param _customer the address of a customer for whom the TxRegistry contract is creating\n', '    */    \n', '    constructor(address _customer) public {\n', '        customer = _customer;\n', '    }\n', '\n', '    /**\n', "    * @dev Owner can add a new Tx of payment for MCW to the customer's TxRegistry\n", '    * @param _txPaymentForMCW the Tx of payment for MCW which will be added\n', '    * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for this Tx of payment for MCW\n', '    * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx\n', '    * @param _amountKWh the amount of KWh which will be recorded to the new Tx\n', '    * @param _timestamp the timestamp of payment for MCW which will be recorded to the new Tx\n', '    */\n', '    function addTxToRegistry(\n', '        bytes32 _txPaymentForMCW,\n', '        bytes32 _txOrigMcwTransfer,\n', '        uint256 _amountMCW,\n', '        uint256 _amountKWh,\n', '        uint256 _timestamp\n', '        ) public onlyOwner returns(bool)\n', '    {\n', '        require(\n', '            _txPaymentForMCW != 0 && _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0 && _timestamp != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentMCW == 0,\n', '            "Tx with such hash is already exist."\n', '        );\n', '\n', '        txRegistry[_txPaymentForMCW].txOrigMcwTransfer = _txOrigMcwTransfer;\n', '        txRegistry[_txPaymentForMCW].amountMCW = _amountMCW;\n', '        txRegistry[_txPaymentForMCW].amountKWh = _amountKWh;\n', '        txRegistry[_txPaymentForMCW].timestampPaymentMCW = _timestamp;\n', '        txIndex.push(_txPaymentForMCW);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "    * @dev Owner can mark a customer's Tx of payment for MCW as spent\n", '    * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent\n', '    * @param _txPaymentForKWh the additional Tx of payment for KWh which will be recorded to the original Tx as proof of spend\n', '    * @param _timestamp the timestamp of payment for KWh which will be recorded to the Tx\n', '    */\n', '    function setTxAsSpent(bytes32 _txPaymentForMCW, bytes32 _txPaymentForKWh, uint256 _timestamp) public onlyOwner returns(bool) {\n', '        require(\n', '            _txPaymentForMCW != 0 && _txPaymentForKWh != 0 && _timestamp != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0,\n', '            "Tx with such hash doesn\'t exist."\n', '        );\n', '        require(\n', '            txRegistry[_txPaymentForMCW].timestampPaymentKWh == 0,\n', '            "Tx with such hash is already spent."\n', '        );\n', '\n', '        txRegistry[_txPaymentForMCW].txPaymentKWh = _txPaymentForKWh;\n', '        txRegistry[_txPaymentForMCW].timestampPaymentKWh = _timestamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW amount\n", '    */   \n', '    function getTxCount() public view returns(uint256) {\n', '        return txIndex.length;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW from customer's Tx list by index\n", "    * @param _index the index of a customer's Tx of payment for MCW in the customer's Tx list\n", '    */  \n', '    function getTxAtIndex(uint256 _index) public view returns(bytes32) {\n', '        return txIndex[_index];\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxOrigMcwTransfer(bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        return txRegistry[_txPaymentForMCW].txOrigMcwTransfer;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxAmountMCW(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].amountMCW;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - amount of KWh which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxAmountKWh(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].amountKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxTimestampPaymentMCW(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].timestampPaymentMCW;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxPaymentKWh(bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        return txRegistry[_txPaymentForMCW].txPaymentKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx\n", '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getTxTimestampPaymentKWh(bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        return txRegistry[_txPaymentForMCW].timestampPaymentKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Check the customer's Tx of payment for MCW\n", '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */  \n', '    function isValidTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        bool isValid = false;\n', '        if (txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0) {\n', '            isValid = true;\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', "    * @dev Check if the customer's Tx of payment for MCW is spent\n", '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */\n', '    function isSpentTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        bool isSpent = false;\n', '        if (txRegistry[_txPaymentForMCW].timestampPaymentKWh != 0) {\n', '            isSpent = true;\n', '        }\n', '        return isSpent;\n', '    }\n', '\n', '    /**\n', "    * @dev Check the customer's Tx of payment for KWh\n", '    * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked\n', '    */\n', '    function isValidTxPaymentForKWh(bytes32 _txPaymentForKWh) public view returns(bool) {\n', '        bool isValid = false;\n', '        for (uint256 i = 0; i < getTxCount(); i++) {\n', '            if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) {\n', '                isValid = true;\n', '                break;\n', '            }\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW by Tx payment for KWh \n", '    * @param _txPaymentForKWh the Tx of payment for KWh\n', '    */\n', '    function getTxPaymentMCW(bytes32 _txPaymentForKWh) public view returns(bytes32) {\n', '        bytes32 txMCW = 0;\n', '        for (uint256 i = 0; i < getTxCount(); i++) {\n', '            if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) {\n', '                txMCW = getTxAtIndex(i);\n', '                break;\n', '            }\n', '        }\n', '        return txMCW;\n', '    }\n', '}\n', '\n', '// File: contracts/McwCustomerRegistry.sol\n', '\n', '/**\n', '* @title Customers Registry\n', '* @dev Registry of all customers\n', '*/\n', 'contract McwCustomerRegistry is Ownable {\n', '    // @dev Key: address of customer wallet, Value: address of customer TxRegistry contract\n', '    mapping (address => address) private registry;\n', '\n', '    // @dev Customers list\n', '    address[] private customerIndex;\n', '\n', '    // @dev Events for dashboard\n', '    event NewCustomer(address indexed customer, address indexed txRegistry);\n', '    event NewCustomerTx(\n', '        address indexed customer,\n', '        bytes32 txPaymentForMCW,\n', '        bytes32 txOrigMcwTransfer,\n', '        uint256 amountMCW,\n', '        uint256 amountKWh,\n', '        uint256 timestamp\n', '    );\n', '    event SpendCustomerTx(address indexed customer, bytes32 txPaymentForMCW, bytes32 txPaymentForKWh, uint256 timestamp);\n', '\n', '    // @dev Constructor\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Owner can add a new customer to registry\n', '    * @dev Creates a related TxRegistry contract for the new customer\n', '    * @dev Related event will be generated\n', '    * @param _customer the address of a new customer to add\n', '    */\n', '    function addCustomerToRegistry(address _customer) public onlyOwner returns(bool) {\n', '        require(\n', '            _customer != address(0),\n', '            "Parameter must be not empty."\n', '        );\n', '        require(\n', '            registry[_customer] == address(0),\n', '            "Customer is already in the registry."\n', '        );\n', '\n', '        address txRegistry = new TxRegistry(_customer);\n', '        registry[_customer] = txRegistry;\n', '        customerIndex.push(_customer);\n', '        emit NewCustomer(_customer, txRegistry);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "    * @dev Owner can add a new Tx of payment for MCW to the customer's TxRegistry\n", "    * @dev Generates the Tx of payment for MCW (hash as proof of payment) and writes the Tx data to the customer's TxRegistry\n", '    * @dev Related event will be generated\n', '    * @param _customer the address of a customer to whom to add a new Tx\n', '    * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for a new Tx of payment for MCW\n', '    * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx\n', '    * @param _amountKWh the amount of KWh which will be recorded to the new Tx\n', '    */\n', '    function addTxToCustomerRegistry(\n', '        address _customer,\n', '        bytes32 _txOrigMcwTransfer,\n', '        uint256 _amountMCW,\n', '        uint256 _amountKWh\n', '        ) public onlyOwner returns(bool)\n', '    {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0,\n', '            "All parameters must be not empty."\n', '        );\n', '\n', '        uint256 timestamp = now;\n', '        bytes32 txPaymentForMCW = keccak256(\n', '            abi.encodePacked(\n', '                _customer,\n', '                _amountMCW,\n', '                _amountKWh,\n', '                timestamp)\n', '            );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        require(\n', '            txRegistry.getTxTimestampPaymentMCW(txPaymentForMCW) == 0,\n', '            "Tx with such hash is already exist."\n', '        );\n', '\n', '        if (!txRegistry.addTxToRegistry(\n', '            txPaymentForMCW,\n', '            _txOrigMcwTransfer,\n', '            _amountMCW,\n', '            _amountKWh,\n', '            timestamp))\n', '            revert ("Something went wrong.");\n', '        emit NewCustomerTx(\n', '            _customer,\n', '            txPaymentForMCW,\n', '            _txOrigMcwTransfer,\n', '            _amountMCW,\n', '            _amountKWh,\n', '            timestamp);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "    * @dev Owner can mark a customer's Tx of payment for MCW as spent\n", '    * @dev Generates an additional Tx of paymant for KWh (hash as proof of spend), which connected to the original Tx.\n', '    * @dev Related event will be generated\n', '    * @param _customer the address of a customer to whom to spend a Tx\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent\n', '    */\n', '    function setCustomerTxAsSpent(address _customer, bytes32 _txPaymentForMCW) public onlyOwner returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        require(\n', '            txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW) != 0,\n', '            "Tx with such hash doesn\'t exist."\n', '        );\n', '        require(\n', '            txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW) == 0,\n', '            "Tx with such hash is already spent."\n', '        );\n', '\n', '        uint256 timestamp = now;\n', '        bytes32 txPaymentForKWh = keccak256(\n', '            abi.encodePacked(\n', '                _txPaymentForMCW,\n', '                timestamp)\n', '            );\n', '\n', '        if (!txRegistry.setTxAsSpent(_txPaymentForMCW, txPaymentForKWh, timestamp))\n', '            revert ("Something went wrong.");\n', '        emit SpendCustomerTx(\n', '            _customer,\n', '            _txPaymentForMCW,\n', '            txPaymentForKWh,\n', '            timestamp);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the current amount of customers\n', '    */\n', '    function getCustomerCount() public view returns(uint256) {\n', '        return customerIndex.length;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's address from customers list by index\n", '    * @param _index the index of a customer in the customers list\n', '    */    \n', '    function getCustomerAtIndex(uint256 _index) public view returns(address) {\n', '        return customerIndex[_index];\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's TxRegistry contract\n", '    * @param _customer the address of a customer for whom to get TxRegistry contract \n', '    */   \n', '    function getCustomerTxRegistry(address _customer) public view returns(address) {\n', '        return registry[_customer];\n', '    }\n', '\n', '    /**\n', "    * @dev Check the customer's address\n", '    * @param _customer the address of a customer which need to be checked\n', '    */   \n', '    function isValidCustomer(address _customer) public view returns(bool) {\n', '        require(\n', '            _customer != address(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        bool isValid = false;\n', '        address txRegistry = registry[_customer];\n', '        if (txRegistry != address(0)) {\n', '            isValid = true;\n', '        }\n', '        return isValid;\n', '    }\n', '\n', '    // wrappers on TxRegistry contract\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW amount\n", '    * @param _customer the address of a customer for whom to get\n', '    */   \n', '    function getCustomerTxCount(address _customer) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 txCount = txRegistry.getTxCount();\n', '        return txCount;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW from customer's Tx list by index\n", '    * @param _customer the address of a customer for whom to get\n', "    * @param _index the index of a customer's Tx of payment for MCW in the customer's Tx list\n", '    */       \n', '    function getCustomerTxAtIndex(address _customer, uint256 _index) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txIndex = txRegistry.getTxAtIndex(_index);\n', '        return txIndex;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxOrigMcwTransfer(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txOrigMcwTransfer = txRegistry.getTxOrigMcwTransfer(_txPaymentForMCW);\n', '        return txOrigMcwTransfer;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxAmountMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 amountMCW = txRegistry.getTxAmountMCW(_txPaymentForMCW);\n', '        return amountMCW;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - amount of KWh which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxAmountKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 amountKWh = txRegistry.getTxAmountKWh(_txPaymentForMCW);\n', '        return amountKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxTimestampPaymentMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 timestampPaymentMCW = txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW);\n', '        return timestampPaymentMCW;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txPaymentKWh = txRegistry.getTxPaymentKWh(_txPaymentForMCW);\n', '        return txPaymentKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx\n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForMCW the Tx of payment for MCW for which to get data\n', '    */  \n', '    function getCustomerTxTimestampPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        uint256 timestampPaymentKWh = txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW);\n', '        return timestampPaymentKWh;\n', '    }\n', '\n', '    /**\n', "    * @dev Check the customer's Tx of payment for MCW\n", '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */  \n', '    function isValidCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isValid = txRegistry.isValidTxPaymentForMCW(_txPaymentForMCW);\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', "    * @dev Check if the customer's Tx of payment for MCW is spent\n", '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked\n', '    */\n', '    function isSpentCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForMCW != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isSpent = txRegistry.isSpentTxPaymentForMCW(_txPaymentForMCW);\n', '        return isSpent;\n', '    }\n', '\n', '    /**\n', "    * @dev Check the customer's Tx of payment for KWh\n", '    * @param _customer the address of a customer for whom to check\n', '    * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked\n', '    */\n', '    function isValidCustomerTxPaymentForKWh(address _customer, bytes32 _txPaymentForKWh) public view returns(bool) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForKWh != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bool isValid = txRegistry.isValidTxPaymentForKWh(_txPaymentForKWh);\n', '        return isValid;\n', '    }\n', '\n', '    /**\n', "    * @dev Get the customer's Tx of payment for MCW by Tx payment for KWh \n", '    * @param _customer the address of a customer for whom to get\n', '    * @param _txPaymentForKWh the Tx of payment for KWh\n', '    */\n', '    function getCustomerTxPaymentMCW(address _customer, bytes32 _txPaymentForKWh) public view returns(bytes32) {\n', '        require(\n', '            isValidCustomer(_customer),\n', '            "Customer is not in the registry."\n', '        );\n', '        require(\n', '            _txPaymentForKWh != bytes32(0),\n', '            "Parameter must be not empty."\n', '        );\n', '\n', '        TxRegistry txRegistry = TxRegistry(registry[_customer]);\n', '        bytes32 txMCW = txRegistry.getTxPaymentMCW(_txPaymentForKWh);\n', '        return txMCW;\n', '    }\n', '}']
