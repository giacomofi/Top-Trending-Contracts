['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract Owned\n', '{\n', '    address public owner;\n', '\n', '    modifier onlyOwner\n', '\t{\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner()\n', '\t{\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract Agricoin is Owned\n', '{\n', '    // Dividends payout struct.\n', '    struct DividendPayout\n', '    {\n', '        uint amount;            // Value of dividend payout.\n', '        uint momentTotalSupply; // Total supply in payout moment,\n', '    }\n', '\n', '    // Redemption payout struct.\n', '    struct RedemptionPayout\n', '    {\n', '        uint amount;            // Value of redemption payout.\n', '        uint momentTotalSupply; // Total supply in payout moment.\n', '        uint price;             // Price of Agricoin in weis.\n', '    }\n', '\n', '    // Balance struct with dividends and redemptions record.\n', '    struct Balance\n', '    {\n', '        uint icoBalance;\n', '        uint balance;                       // Agricoin balance.\n', '        uint posibleDividends;              // Dividend number, which user can get.\n', '        uint lastDividensPayoutNumber;      // Last dividend payout index, which user has gotten.\n', '        uint posibleRedemption;             // Redemption value in weis, which user can use.\n', '        uint lastRedemptionPayoutNumber;    // Last redemption payout index, which user has used.\n', '    }\n', '\n', '    // Can act only one from payers.\n', '    modifier onlyPayer()\n', '    {\n', '        require(payers[msg.sender]);\n', '        _;\n', '    }\n', '    \n', '    // Can act only after token activation.\n', '    modifier onlyActivated()\n', '    {\n', '        require(isActive);\n', '        _;\n', '    }\n', '\n', '    // Transfer event.\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);    \n', '\n', '    // Approve event.\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // Activate event.\n', '    event Activate(bool icoSuccessful);\n', '\n', '    // DividendPayout dividends event.\n', '    event PayoutDividends(uint etherAmount, uint indexed id);\n', '\n', '    // DividendPayout redemption event.\n', '    event PayoutRedemption(uint etherAmount, uint indexed id, uint price);\n', '\n', '    // Get unpaid event.\n', '    event GetUnpaid(uint etherAmount);\n', '\n', '    // Get dividends.\n', '    event GetDividends(address indexed investor, uint etherAmount);\n', '\n', '    // Constructor.\n', '    function Agricoin(uint payout_period_start, uint payout_period_end, address _payer) public\n', '    {\n', '        owner = msg.sender;// Save the owner.\n', '\n', '        // Set payout period.\n', '        payoutPeriodStart = payout_period_start;\n', '        payoutPeriodEnd = payout_period_end;\n', '\n', '        payers[_payer] = true;\n', '    }\n', '\n', '    // Activate token.\n', '\tfunction activate(bool icoSuccessful) onlyOwner() external returns (bool)\n', '\t{\n', '\t\trequire(!isActive);// Check once activation.\n', '\n', '        startDate = now;// Save activation date.\n', '\t\tisActive = true;// Make token active.\n', '\t\towner = 0x00;// Set owner to null.\n', '\t\t\n', '        if (icoSuccessful)\n', '        {\n', '            isSuccessfulIco = true;\n', '            totalSupply += totalSupplyOnIco;\n', '            Activate(true);// Call activation event.\n', '        }\n', '        else\n', '        {\n', '            Activate(false);// Call activation event.\n', '        }\n', '\n', '        return true;\n', '\t}\n', '\n', '    // Add new payer by payer.\n', '    function addPayer(address payer) onlyPayer() external\n', '    {\n', '        payers[payer] = true;\n', '    }\n', '\n', '    // Get balance of address.\n', '\tfunction balanceOf(address owner) public view returns (uint)\n', '\t{\n', '\t\treturn balances[owner].balance;\n', '\t}\n', '\n', '    // Get posible dividends value.\n', '    function posibleDividendsOf(address owner) public view returns (uint)\n', '    {\n', '        return balances[owner].posibleDividends;\n', '    }\n', '\n', '    // Get posible redemption value.\n', '    function posibleRedemptionOf(address owner) public view returns (uint)\n', '    {\n', '        return balances[owner].posibleRedemption;\n', '    }\n', '\n', '    // Transfer _value etheres to _to.\n', '    function transfer(address _to, uint _value) onlyActivated() external returns (bool)\n', '    {\n', '        require(balanceOf(msg.sender) >= _value);\n', '\n', "        recalculate(msg.sender);// Recalculate user's struct.\n", '        \n', '        if (_to != 0x00)// For normal transfer.\n', '        {\n', "            recalculate(_to);// Recalculate recipient's struct.\n", '\n', '            // Change balances.\n', '            balances[msg.sender].balance -= _value;\n', '            balances[_to].balance += _value;\n', '\n', '            Transfer(msg.sender, _to, _value);// Call transfer event.\n', '        }\n', '        else// For redemption transfer.\n', '        {\n', '            require(payoutPeriodStart <= now && now >= payoutPeriodEnd);// Check redemption period.\n', '            \n', '            uint amount = _value * redemptionPayouts[amountOfRedemptionPayouts].price;// Calculate amount of weis in redemption.\n', '\n', '            require(amount <= balances[msg.sender].posibleRedemption);// Check redemption limits.\n', '\n', "            // Change user's struct.\n", '            balances[msg.sender].posibleRedemption -= amount;\n', '            balances[msg.sender].balance -= _value;\n', '\n', '            totalSupply -= _value;// Decrease total supply.\n', '\n', '            msg.sender.transfer(amount);// Transfer redemption to user.\n', '\n', '            Transfer(msg.sender, _to, _value);// Call transfer event.\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // Transfer from _from to _to _value tokens.\n', '    function transferFrom(address _from, address _to, uint _value) onlyActivated() external returns (bool)\n', '    {\n', '        // Check transfer posibility.\n', '        require(balances[_from].balance >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(_to != 0x00);\n', '\n', '        // Recalculate structs.\n', '        recalculate(_from);\n', '        recalculate(_to);\n', '\n', '        // Change balances.\n', '        balances[_from].balance -= _value;\n', '        balances[_to].balance += _value;\n', '        \n', '        Transfer(_from, _to, _value);// Call tranfer event.\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Approve for transfers.\n', '    function approve(address _spender, uint _value) onlyActivated() public returns (bool)\n', '    {\n', '        // Recalculate structs.\n', '        recalculate(msg.sender);\n', '        recalculate(_spender);\n', '\n', '        allowed[msg.sender][_spender] = _value;// Set allowed.\n', '        \n', '        Approval(msg.sender, _spender, _value);// Call approval event.\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Get allowance.\n', '    function allowance(address _owner, address _spender) onlyActivated() external view returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Mint _value tokens to _to address.\n', '    function mint(address _to, uint _value, bool icoMinting) onlyOwner() external returns (bool)\n', '    {\n', '        require(!isActive);// Check no activation.\n', '\n', '        if (icoMinting)\n', '        {\n', '            balances[_to].icoBalance += _value;\n', '            totalSupplyOnIco += _value;\n', '        }\n', '        else\n', '        {\n', "            balances[_to].balance += _value;// Increase user's balance.\n", '            totalSupply += _value;// Increase total supply.\n', '\n', '            Transfer(0x00, _to, _value);// Call transfer event.\n', '        }\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Pay dividends.\n', '    function payDividends() onlyPayer() onlyActivated() external payable returns (bool)\n', '    {\n', '        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\n', '\n', '        dividendPayouts[amountOfDividendsPayouts].amount = msg.value;// Set payout amount in weis.\n', '        dividendPayouts[amountOfDividendsPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\n', '        \n', '        PayoutDividends(msg.value, amountOfDividendsPayouts);// Call dividend payout event.\n', '\n', '        amountOfDividendsPayouts++;// Increment dividend payouts amount.\n', '\n', '        return true;\n', '    }\n', '\n', '    // Pay redemption.\n', '    function payRedemption(uint price) onlyPayer() onlyActivated() external payable returns (bool)\n', '    {\n', '        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\n', '\n', '        redemptionPayouts[amountOfRedemptionPayouts].amount = msg.value;// Set payout amount in weis.\n', '        redemptionPayouts[amountOfRedemptionPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\n', '        redemptionPayouts[amountOfRedemptionPayouts].price = price;// Set price of Agricoin in weis at this redemption moment.\n', '\n', '        PayoutRedemption(msg.value, amountOfRedemptionPayouts, price);// Call redemption payout event.\n', '\n', '        amountOfRedemptionPayouts++;// Increment redemption payouts amount.\n', '\n', '        return true;\n', '    }\n', '\n', '    // Get back unpaid dividends and redemption.\n', '    function getUnpaid() onlyPayer() onlyActivated() external returns (bool)\n', '    {\n', '        require(now >= payoutPeriodEnd);// Check end payout period.\n', '\n', '        GetUnpaid(this.balance);// Call getting unpaid ether event.\n', '\n', '        msg.sender.transfer(this.balance);// Transfer all ethers back to payer.\n', '\n', '        return true;\n', '    }\n', '\n', '    // Recalculates dividends and redumptions.\n', '    function recalculate(address user) onlyActivated() public returns (bool)\n', '    {\n', '        if (isSuccessfulIco)\n', '        {\n', '            if (balances[user].icoBalance != 0)\n', '            {\n', '                balances[user].balance += balances[user].icoBalance;\n', '                Transfer(0x00, user, balances[user].icoBalance);\n', '                balances[user].icoBalance = 0;\n', '            }\n', '        }\n', '\n', '        // Check for necessity of recalculation.\n', '        if (balances[user].lastDividensPayoutNumber == amountOfDividendsPayouts &&\n', '            balances[user].lastRedemptionPayoutNumber == amountOfRedemptionPayouts)\n', '        {\n', '            return true;\n', '        }\n', '\n', '        uint addedDividend = 0;\n', '\n', '        // For dividends.\n', '        for (uint i = balances[user].lastDividensPayoutNumber; i < amountOfDividendsPayouts; i++)\n', '        {\n', '            addedDividend += (balances[user].balance * dividendPayouts[i].amount) / dividendPayouts[i].momentTotalSupply;\n', '        }\n', '\n', '        balances[user].posibleDividends += addedDividend;\n', '        balances[user].lastDividensPayoutNumber = amountOfDividendsPayouts;\n', '\n', '        uint addedRedemption = 0;\n', '\n', '        // For redemption.\n', '        for (uint j = balances[user].lastRedemptionPayoutNumber; j < amountOfRedemptionPayouts; j++)\n', '        {\n', '            addedRedemption += (balances[user].balance * redemptionPayouts[j].amount) / redemptionPayouts[j].momentTotalSupply;\n', '        }\n', '\n', '        balances[user].posibleRedemption += addedRedemption;\n', '        balances[user].lastRedemptionPayoutNumber = amountOfRedemptionPayouts;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Get dividends.\n', '    function () external payable\n', '    {\n', '        if (payoutPeriodStart >= now && now <= payoutPeriodEnd)// Check payout period.\n', '        {\n', '            if (posibleDividendsOf(msg.sender) > 0)// Check posible dividends.\n', '            {\n', '                uint dividendsAmount = posibleDividendsOf(msg.sender);// Get posible dividends amount.\n', '\n', '                GetDividends(msg.sender, dividendsAmount);// Call getting dividends event.\n', '\n', '                balances[msg.sender].posibleDividends = 0;// Set balance to zero.\n', '\n', '                msg.sender.transfer(dividendsAmount);// Transfer dividends amount.\n', '            }\n', '        }\n', '    }\n', '\n', '    // Token name.\n', '    string public constant name = "Agricoin";\n', '    \n', '    // Token market symbol.\n', '    string public constant symbol = "AGR";\n', '    \n', '    // Amount of digits after comma.\n', '    uint public constant decimals = 2;\n', '\n', '    // Total supply.\n', '    uint public totalSupply;\n', '\n', '    // Total supply on ICO only;\n', '    uint public totalSupplyOnIco;\n', '       \n', '    // Activation date.\n', '    uint public startDate;\n', '    \n', '    // Payment period start date, setted by ICO contract before activation.\n', '    uint public payoutPeriodStart;\n', '    \n', '    // Payment period last date, setted by ICO contract before activation.\n', '    uint public payoutPeriodEnd;\n', '    \n', '    // Dividends DividendPayout counter.\n', '    uint public amountOfDividendsPayouts = 0;\n', '\n', '    // Redemption DividendPayout counter.\n', '    uint public amountOfRedemptionPayouts = 0;\n', '\n', '    // Dividend payouts.\n', '    mapping (uint => DividendPayout) public dividendPayouts;\n', '    \n', '    // Redemption payouts.\n', '    mapping (uint => RedemptionPayout) public redemptionPayouts;\n', '\n', '    // Dividend and redemption payers.\n', '    mapping (address => bool) public payers;\n', '\n', '    // Balance records.\n', '    mapping (address => Balance) public balances;\n', '\n', '    // Allowed balances.\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '\n', "    // Set true for activating token. If false then token isn't working.\n", '    bool public isActive = false;\n', '\n', '    // Set true for activate ico minted tokens.\n', '    bool public isSuccessfulIco = false;\n', '}']