['pragma solidity ^0.4.21;\n', '\n', 'interface ExchangeInterface {\n', '\n', '    event Subscribed(address indexed user);\n', '    event Unsubscribed(address indexed user);\n', '\n', '    event Cancelled(bytes32 indexed hash);\n', '\n', '    event Traded(\n', '        bytes32 indexed hash,\n', '        address makerToken,\n', '        uint makerTokenAmount,\n', '        address takerToken,\n', '        uint takerTokenAmount,\n', '        address maker,\n', '        address taker\n', '    );\n', '\n', '    event Ordered(\n', '        address maker,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint makerTokenAmount,\n', '        uint takerTokenAmount,\n', '        uint expires,\n', '        uint nonce\n', '    );\n', '\n', '    function subscribe() external;\n', '    function unsubscribe() external;\n', '\n', '    function trade(address[3] addresses, uint[4] values, bytes signature, uint maxFillAmount) external;\n', '    function cancel(address[3] addresses, uint[4] values) external;\n', '    function order(address[2] addresses, uint[4] values) external;\n', '\n', '    function canTrade(address[3] addresses, uint[4] values, bytes signature)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function isSubscribed(address subscriber) external view returns (bool);\n', '    function availableAmount(address[3] addresses, uint[4] values) external view returns (uint);\n', '    function filled(bytes32 hash) external view returns (uint);\n', '    function isOrdered(address user, bytes32 hash) public view returns (bool);\n', '    function vault() public view returns (VaultInterface);\n', '\n', '}\n', '\n', 'interface VaultInterface {\n', '\n', '    event Deposited(address indexed user, address token, uint amount);\n', '    event Withdrawn(address indexed user, address token, uint amount);\n', '\n', '    event Approved(address indexed user, address indexed spender);\n', '    event Unapproved(address indexed user, address indexed spender);\n', '\n', '    event AddedSpender(address indexed spender);\n', '    event RemovedSpender(address indexed spender);\n', '\n', '    function deposit(address token, uint amount) external payable;\n', '    function withdraw(address token, uint amount) external;\n', '    function transfer(address token, address from, address to, uint amount) external;\n', '    function approve(address spender) external;\n', '    function unapprove(address spender) external;\n', '    function isApproved(address user, address spender) external view returns (bool);\n', '    function addSpender(address spender) external;\n', '    function removeSpender(address spender) external;\n', '    function latestSpender() external view returns (address);\n', '    function isSpender(address spender) external view returns (bool);\n', '    function tokenFallback(address from, uint value, bytes data) public;\n', '    function balanceOf(address token, address user) public view returns (uint);\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'library SignatureValidator {\n', '\n', '    enum SignatureMode {\n', '        EIP712,\n', '        GETH,\n', '        TREZOR\n', '    }\n', '\n', '    /// @dev Validates that a hash was signed by a specified signer.\n', '    /// @param hash Hash which was signed.\n', '    /// @param signer Address of the signer.\n', '    /// @param signature ECDSA signature along with the mode (0 = EIP712, 1 = Geth, 2 = Trezor) {mode}{v}{r}{s}.\n', '    /// @return Returns whether signature is from a specified user.\n', '    function isValidSignature(bytes32 hash, address signer, bytes signature) internal pure returns (bool) {\n', '        require(signature.length == 66);\n', '        SignatureMode mode = SignatureMode(uint8(signature[0]));\n', '\n', '        uint8 v = uint8(signature[1]);\n', '        bytes32 r;\n', '        bytes32 s;\n', '        assembly {\n', '            r := mload(add(signature, 34))\n', '            s := mload(add(signature, 66))\n', '        }\n', '\n', '        if (mode == SignatureMode.GETH) {\n', '            hash = keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '        } else if (mode == SignatureMode.TREZOR) {\n', '            hash = keccak256("\\x19Ethereum Signed Message:\\n\\x20", hash);\n', '        }\n', '\n', '        return ecrecover(hash, v, r, s) == signer;\n', '    }\n', '}\n', '\n', 'library OrderLibrary {\n', '\n', '    bytes32 constant public HASH_SCHEME = keccak256(\n', '        "address Taker Token",\n', '        "uint Taker Token Amount",\n', '        "address Maker Token",\n', '        "uint Maker Token Amount",\n', '        "uint Expires",\n', '        "uint Nonce",\n', '        "address Maker",\n', '        "address Exchange"\n', '    );\n', '\n', '    struct Order {\n', '        address maker;\n', '        address makerToken;\n', '        address takerToken;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint expires;\n', '        uint nonce;\n', '    }\n', '\n', '    /// @dev Hashes the order.\n', '    /// @param order Order to be hashed.\n', '    /// @return hash result\n', '    function hash(Order memory order) internal view returns (bytes32) {\n', '        return keccak256(\n', '            HASH_SCHEME,\n', '            keccak256(\n', '                order.takerToken,\n', '                order.takerTokenAmount,\n', '                order.makerToken,\n', '                order.makerTokenAmount,\n', '                order.expires,\n', '                order.nonce,\n', '                order.maker,\n', '                this\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @dev Creates order struct from value arrays.\n', '    /// @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    /// @return Order struct\n', '    function createOrder(address[3] addresses, uint[4] values) internal pure returns (Order memory) {\n', '        return Order({\n', '            maker: addresses[0],\n', '            makerToken: addresses[1],\n', '            takerToken: addresses[2],\n', '            makerTokenAmount: values[0],\n', '            takerTokenAmount: values[1],\n', '            expires: values[2],\n', '            nonce: values[3]\n', '        });\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return owner == _address;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '\n', '}\n', '\n', 'interface HookSubscriber {\n', '\n', '    function tradeExecuted(address token, uint amount) external;\n', '\n', '}\n', '\n', 'contract Exchange is Ownable, ExchangeInterface {\n', '\n', '    using SafeMath for *;\n', '    using OrderLibrary for OrderLibrary.Order;\n', '\n', '    address constant public ETH = 0x0;\n', '\n', '    uint256 constant public MAX_FEE = 5000000000000000; // 0.5% ((0.5 / 100) * 10**18)\n', '    uint256 constant private MAX_ROUNDING_PERCENTAGE = 1000; // 0.1%\n', '    \n', '    uint256 constant private MAX_HOOK_GAS = 40000; // enough for a storage write and some accounting logic\n', '\n', '    VaultInterface public vault;\n', '\n', '    uint public takerFee = 0;\n', '    address public feeAccount;\n', '\n', '    mapping (address => mapping (bytes32 => bool)) private orders;\n', '    mapping (bytes32 => uint) private fills;\n', '    mapping (bytes32 => bool) private cancelled;\n', '    mapping (address => bool) private subscribed;\n', '\n', '    function Exchange(uint _takerFee, address _feeAccount, VaultInterface _vault) public {\n', '        require(address(_vault) != 0x0);\n', '        setFees(_takerFee);\n', '        setFeeAccount(_feeAccount);\n', '        vault = _vault;\n', '    }\n', '\n', '    /// @dev Withdraws tokens accidentally sent to this contract.\n', '    /// @param token Address of the token to withdraw.\n', '    /// @param amount Amount of tokens to withdraw.\n', '    function withdraw(address token, uint amount) external onlyOwner {\n', '        if (token == ETH) {\n', '            msg.sender.transfer(amount);\n', '            return;\n', '        }\n', '\n', '        ERC20(token).transfer(msg.sender, amount);\n', '    }\n', '\n', '    /// @dev Subscribes user to trade hooks.\n', '    function subscribe() external {\n', '        require(!subscribed[msg.sender]);\n', '        subscribed[msg.sender] = true;\n', '        emit Subscribed(msg.sender);\n', '    }\n', '\n', '    /// @dev Unsubscribes user from trade hooks.\n', '    function unsubscribe() external {\n', '        require(subscribed[msg.sender]);\n', '        subscribed[msg.sender] = false;\n', '        emit Unsubscribed(msg.sender);\n', '    }\n', '\n', '    /// @dev Takes an order.\n', '    /// @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @param maxFillAmount Maximum amount of the order to be filled.\n', '    function trade(address[3] addresses, uint[4] values, bytes signature, uint maxFillAmount) external {\n', '        trade(OrderLibrary.createOrder(addresses, values), msg.sender, signature, maxFillAmount);\n', '    }\n', '\n', '    /// @dev Cancels an order.\n', '    /// @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    function cancel(address[3] addresses, uint[4] values) external {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '\n', '        require(msg.sender == order.maker);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0);\n', '\n', '        bytes32 hash = order.hash();\n', '        require(fills[hash] < order.takerTokenAmount);\n', '        require(!cancelled[hash]);\n', '\n', '        cancelled[hash] = true;\n', '        emit Cancelled(hash);\n', '    }\n', '\n', '    /// @dev Creates an order which is then indexed in the orderbook.\n', '    /// @param addresses Array of trade&#39;s makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    function order(address[2] addresses, uint[4] values) external {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(\n', '            [msg.sender, addresses[0], addresses[1]],\n', '            values\n', '        );\n', '\n', '        require(vault.isApproved(order.maker, this));\n', '        require(vault.balanceOf(order.makerToken, order.maker) >= order.makerTokenAmount);\n', '        require(order.makerToken != order.takerToken);\n', '        require(order.makerTokenAmount > 0);\n', '        require(order.takerTokenAmount > 0);\n', '\n', '        bytes32 hash = order.hash();\n', '\n', '        require(!orders[msg.sender][hash]);\n', '        orders[msg.sender][hash] = true;\n', '\n', '        emit Ordered(\n', '            order.maker,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            order.makerTokenAmount,\n', '            order.takerTokenAmount,\n', '            order.expires,\n', '            order.nonce\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if a order can be traded.\n', '    /// @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @return Boolean if order can be traded\n', '    function canTrade(address[3] addresses, uint[4] values, bytes signature)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '\n', '        bytes32 hash = order.hash();\n', '\n', '        return canTrade(order, signature, hash);\n', '    }\n', '\n', '    /// @dev Returns if user has subscribed to trade hooks.\n', '    /// @param subscriber Address of the subscriber.\n', '    /// @return Boolean if user is subscribed.\n', '    function isSubscribed(address subscriber) external view returns (bool) {\n', '        return subscribed[subscriber];\n', '    }\n', '\n', '    /// @dev Checks how much of an order can be filled.\n', '    /// @param addresses Array of trade&#39;s maker, makerToken and takerToken.\n', '    /// @param values Array of trade&#39;s makerTokenAmount, takerTokenAmount, expires and nonce.\n', '    /// @return Amount of the order which can be filled.\n', '    function availableAmount(address[3] addresses, uint[4] values) external view returns (uint) {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '        return availableAmount(order, order.hash());\n', '    }\n', '\n', '    /// @dev Returns how much of an order was filled.\n', '    /// @param hash Hash of the order.\n', '    /// @return Amount which was filled.\n', '    function filled(bytes32 hash) external view returns (uint) {\n', '        return fills[hash];\n', '    }\n', '\n', '    /// @dev Sets the taker fee.\n', '    /// @param _takerFee New taker fee.\n', '    function setFees(uint _takerFee) public onlyOwner {\n', '        require(_takerFee <= MAX_FEE);\n', '        takerFee = _takerFee;\n', '    }\n', '\n', '    /// @dev Sets the account where fees will be transferred to.\n', '    /// @param _feeAccount Address for the account.\n', '    function setFeeAccount(address _feeAccount) public onlyOwner {\n', '        require(_feeAccount != 0x0);\n', '        feeAccount = _feeAccount;\n', '    }\n', '\n', '    function vault() public view returns (VaultInterface) {\n', '        return vault;\n', '    }\n', '\n', '    /// @dev Checks if an order was created on chain.\n', '    /// @param user User who created the order.\n', '    /// @param hash Hash of the order.\n', '    /// @return Boolean if the order was created on chain.\n', '    function isOrdered(address user, bytes32 hash) public view returns (bool) {\n', '        return orders[user][hash];\n', '    }\n', '\n', '    /// @dev Executes the actual trade by transferring balances.\n', '    /// @param order Order to be traded.\n', '    /// @param taker Address of the taker.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @param maxFillAmount Maximum amount of the order to be filled.\n', '    function trade(OrderLibrary.Order memory order, address taker, bytes signature, uint maxFillAmount) internal {\n', '        require(taker != order.maker);\n', '        bytes32 hash = order.hash();\n', '\n', '        require(order.makerToken != order.takerToken);\n', '        require(canTrade(order, signature, hash));\n', '\n', '        uint fillAmount = SafeMath.min256(maxFillAmount, availableAmount(order, hash));\n', '\n', '        require(roundingPercent(fillAmount, order.takerTokenAmount, order.makerTokenAmount) <= MAX_ROUNDING_PERCENTAGE);\n', '        require(vault.balanceOf(order.takerToken, taker) >= fillAmount);\n', '\n', '        uint makeAmount = order.makerTokenAmount.mul(fillAmount).div(order.takerTokenAmount);\n', '        uint tradeTakerFee = makeAmount.mul(takerFee).div(1 ether);\n', '\n', '        if (tradeTakerFee > 0) {\n', '            vault.transfer(order.makerToken, order.maker, feeAccount, tradeTakerFee);\n', '        }\n', '\n', '        vault.transfer(order.takerToken, taker, order.maker, fillAmount);\n', '        vault.transfer(order.makerToken, order.maker, taker, makeAmount.sub(tradeTakerFee));\n', '\n', '        fills[hash] = fills[hash].add(fillAmount);\n', '        assert(fills[hash] <= order.takerTokenAmount);\n', '\n', '        if (subscribed[order.maker]) {\n', '            order.maker.call.gas(MAX_HOOK_GAS)(HookSubscriber(order.maker).tradeExecuted.selector, order.takerToken, fillAmount);\n', '        }\n', '\n', '        emit Traded(\n', '            hash,\n', '            order.makerToken,\n', '            makeAmount,\n', '            order.takerToken,\n', '            fillAmount,\n', '            order.maker,\n', '            taker\n', '        );\n', '    }\n', '\n', '    /// @dev Indicates whether or not an certain amount of an order can be traded.\n', '    /// @param order Order to be traded.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @param hash Hash of the order.\n', '    /// @return Boolean if order can be traded\n', '    function canTrade(OrderLibrary.Order memory order, bytes signature, bytes32 hash)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // if the order has never been traded against, we need to check the sig.\n', '        if (fills[hash] == 0) {\n', '            // ensures order was either created on chain, or signature is valid\n', '            if (!isOrdered(order.maker, hash) && !SignatureValidator.isValidSignature(hash, order.maker, signature)) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        if (cancelled[hash]) {\n', '            return false;\n', '        }\n', '\n', '        if (!vault.isApproved(order.maker, this)) {\n', '            return false;\n', '        }\n', '\n', '        if (order.takerTokenAmount == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (order.makerTokenAmount == 0) {\n', '            return false;\n', '        }\n', '\n', '        // ensures that the order still has an available amount to be filled.\n', '        if (availableAmount(order, hash) == 0) {\n', '            return false;\n', '        }\n', '\n', '        return order.expires > now;\n', '    }\n', '\n', '    /// @dev Returns the maximum available amount that can be taken of an order.\n', '    /// @param order Order to check.\n', '    /// @param hash Hash of the order.\n', '    /// @return Amount of the order that can be filled.\n', '    function availableAmount(OrderLibrary.Order memory order, bytes32 hash) internal view returns (uint) {\n', '        return SafeMath.min256(\n', '            order.takerTokenAmount.sub(fills[hash]),\n', '            vault.balanceOf(order.makerToken, order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount)\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the percentage which was rounded when dividing.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with.\n', '    /// @return Percentage rounded.\n', '    function roundingPercent(uint numerator, uint denominator, uint target) internal pure returns (uint) {\n', '        // Inspired by https://github.com/0xProject/contracts/blob/1.0.0/contracts/Exchange.sol#L472-L490\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return remainder.mul(1000000).div(numerator.mul(target));\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface ExchangeInterface {\n', '\n', '    event Subscribed(address indexed user);\n', '    event Unsubscribed(address indexed user);\n', '\n', '    event Cancelled(bytes32 indexed hash);\n', '\n', '    event Traded(\n', '        bytes32 indexed hash,\n', '        address makerToken,\n', '        uint makerTokenAmount,\n', '        address takerToken,\n', '        uint takerTokenAmount,\n', '        address maker,\n', '        address taker\n', '    );\n', '\n', '    event Ordered(\n', '        address maker,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint makerTokenAmount,\n', '        uint takerTokenAmount,\n', '        uint expires,\n', '        uint nonce\n', '    );\n', '\n', '    function subscribe() external;\n', '    function unsubscribe() external;\n', '\n', '    function trade(address[3] addresses, uint[4] values, bytes signature, uint maxFillAmount) external;\n', '    function cancel(address[3] addresses, uint[4] values) external;\n', '    function order(address[2] addresses, uint[4] values) external;\n', '\n', '    function canTrade(address[3] addresses, uint[4] values, bytes signature)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function isSubscribed(address subscriber) external view returns (bool);\n', '    function availableAmount(address[3] addresses, uint[4] values) external view returns (uint);\n', '    function filled(bytes32 hash) external view returns (uint);\n', '    function isOrdered(address user, bytes32 hash) public view returns (bool);\n', '    function vault() public view returns (VaultInterface);\n', '\n', '}\n', '\n', 'interface VaultInterface {\n', '\n', '    event Deposited(address indexed user, address token, uint amount);\n', '    event Withdrawn(address indexed user, address token, uint amount);\n', '\n', '    event Approved(address indexed user, address indexed spender);\n', '    event Unapproved(address indexed user, address indexed spender);\n', '\n', '    event AddedSpender(address indexed spender);\n', '    event RemovedSpender(address indexed spender);\n', '\n', '    function deposit(address token, uint amount) external payable;\n', '    function withdraw(address token, uint amount) external;\n', '    function transfer(address token, address from, address to, uint amount) external;\n', '    function approve(address spender) external;\n', '    function unapprove(address spender) external;\n', '    function isApproved(address user, address spender) external view returns (bool);\n', '    function addSpender(address spender) external;\n', '    function removeSpender(address spender) external;\n', '    function latestSpender() external view returns (address);\n', '    function isSpender(address spender) external view returns (bool);\n', '    function tokenFallback(address from, uint value, bytes data) public;\n', '    function balanceOf(address token, address user) public view returns (uint);\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'library SignatureValidator {\n', '\n', '    enum SignatureMode {\n', '        EIP712,\n', '        GETH,\n', '        TREZOR\n', '    }\n', '\n', '    /// @dev Validates that a hash was signed by a specified signer.\n', '    /// @param hash Hash which was signed.\n', '    /// @param signer Address of the signer.\n', '    /// @param signature ECDSA signature along with the mode (0 = EIP712, 1 = Geth, 2 = Trezor) {mode}{v}{r}{s}.\n', '    /// @return Returns whether signature is from a specified user.\n', '    function isValidSignature(bytes32 hash, address signer, bytes signature) internal pure returns (bool) {\n', '        require(signature.length == 66);\n', '        SignatureMode mode = SignatureMode(uint8(signature[0]));\n', '\n', '        uint8 v = uint8(signature[1]);\n', '        bytes32 r;\n', '        bytes32 s;\n', '        assembly {\n', '            r := mload(add(signature, 34))\n', '            s := mload(add(signature, 66))\n', '        }\n', '\n', '        if (mode == SignatureMode.GETH) {\n', '            hash = keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '        } else if (mode == SignatureMode.TREZOR) {\n', '            hash = keccak256("\\x19Ethereum Signed Message:\\n\\x20", hash);\n', '        }\n', '\n', '        return ecrecover(hash, v, r, s) == signer;\n', '    }\n', '}\n', '\n', 'library OrderLibrary {\n', '\n', '    bytes32 constant public HASH_SCHEME = keccak256(\n', '        "address Taker Token",\n', '        "uint Taker Token Amount",\n', '        "address Maker Token",\n', '        "uint Maker Token Amount",\n', '        "uint Expires",\n', '        "uint Nonce",\n', '        "address Maker",\n', '        "address Exchange"\n', '    );\n', '\n', '    struct Order {\n', '        address maker;\n', '        address makerToken;\n', '        address takerToken;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint expires;\n', '        uint nonce;\n', '    }\n', '\n', '    /// @dev Hashes the order.\n', '    /// @param order Order to be hashed.\n', '    /// @return hash result\n', '    function hash(Order memory order) internal view returns (bytes32) {\n', '        return keccak256(\n', '            HASH_SCHEME,\n', '            keccak256(\n', '                order.takerToken,\n', '                order.takerTokenAmount,\n', '                order.makerToken,\n', '                order.makerTokenAmount,\n', '                order.expires,\n', '                order.nonce,\n', '                order.maker,\n', '                this\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @dev Creates order struct from value arrays.\n', "    /// @param addresses Array of trade's maker, makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    /// @return Order struct\n', '    function createOrder(address[3] addresses, uint[4] values) internal pure returns (Order memory) {\n', '        return Order({\n', '            maker: addresses[0],\n', '            makerToken: addresses[1],\n', '            takerToken: addresses[2],\n', '            makerTokenAmount: values[0],\n', '            takerTokenAmount: values[1],\n', '            expires: values[2],\n', '            nonce: values[3]\n', '        });\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return owner == _address;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '\n', '}\n', '\n', 'interface HookSubscriber {\n', '\n', '    function tradeExecuted(address token, uint amount) external;\n', '\n', '}\n', '\n', 'contract Exchange is Ownable, ExchangeInterface {\n', '\n', '    using SafeMath for *;\n', '    using OrderLibrary for OrderLibrary.Order;\n', '\n', '    address constant public ETH = 0x0;\n', '\n', '    uint256 constant public MAX_FEE = 5000000000000000; // 0.5% ((0.5 / 100) * 10**18)\n', '    uint256 constant private MAX_ROUNDING_PERCENTAGE = 1000; // 0.1%\n', '    \n', '    uint256 constant private MAX_HOOK_GAS = 40000; // enough for a storage write and some accounting logic\n', '\n', '    VaultInterface public vault;\n', '\n', '    uint public takerFee = 0;\n', '    address public feeAccount;\n', '\n', '    mapping (address => mapping (bytes32 => bool)) private orders;\n', '    mapping (bytes32 => uint) private fills;\n', '    mapping (bytes32 => bool) private cancelled;\n', '    mapping (address => bool) private subscribed;\n', '\n', '    function Exchange(uint _takerFee, address _feeAccount, VaultInterface _vault) public {\n', '        require(address(_vault) != 0x0);\n', '        setFees(_takerFee);\n', '        setFeeAccount(_feeAccount);\n', '        vault = _vault;\n', '    }\n', '\n', '    /// @dev Withdraws tokens accidentally sent to this contract.\n', '    /// @param token Address of the token to withdraw.\n', '    /// @param amount Amount of tokens to withdraw.\n', '    function withdraw(address token, uint amount) external onlyOwner {\n', '        if (token == ETH) {\n', '            msg.sender.transfer(amount);\n', '            return;\n', '        }\n', '\n', '        ERC20(token).transfer(msg.sender, amount);\n', '    }\n', '\n', '    /// @dev Subscribes user to trade hooks.\n', '    function subscribe() external {\n', '        require(!subscribed[msg.sender]);\n', '        subscribed[msg.sender] = true;\n', '        emit Subscribed(msg.sender);\n', '    }\n', '\n', '    /// @dev Unsubscribes user from trade hooks.\n', '    function unsubscribe() external {\n', '        require(subscribed[msg.sender]);\n', '        subscribed[msg.sender] = false;\n', '        emit Unsubscribed(msg.sender);\n', '    }\n', '\n', '    /// @dev Takes an order.\n', "    /// @param addresses Array of trade's maker, makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    /// @param signature Signed order along with signature mode.\n', '    /// @param maxFillAmount Maximum amount of the order to be filled.\n', '    function trade(address[3] addresses, uint[4] values, bytes signature, uint maxFillAmount) external {\n', '        trade(OrderLibrary.createOrder(addresses, values), msg.sender, signature, maxFillAmount);\n', '    }\n', '\n', '    /// @dev Cancels an order.\n', "    /// @param addresses Array of trade's maker, makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    function cancel(address[3] addresses, uint[4] values) external {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '\n', '        require(msg.sender == order.maker);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0);\n', '\n', '        bytes32 hash = order.hash();\n', '        require(fills[hash] < order.takerTokenAmount);\n', '        require(!cancelled[hash]);\n', '\n', '        cancelled[hash] = true;\n', '        emit Cancelled(hash);\n', '    }\n', '\n', '    /// @dev Creates an order which is then indexed in the orderbook.\n', "    /// @param addresses Array of trade's makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    function order(address[2] addresses, uint[4] values) external {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(\n', '            [msg.sender, addresses[0], addresses[1]],\n', '            values\n', '        );\n', '\n', '        require(vault.isApproved(order.maker, this));\n', '        require(vault.balanceOf(order.makerToken, order.maker) >= order.makerTokenAmount);\n', '        require(order.makerToken != order.takerToken);\n', '        require(order.makerTokenAmount > 0);\n', '        require(order.takerTokenAmount > 0);\n', '\n', '        bytes32 hash = order.hash();\n', '\n', '        require(!orders[msg.sender][hash]);\n', '        orders[msg.sender][hash] = true;\n', '\n', '        emit Ordered(\n', '            order.maker,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            order.makerTokenAmount,\n', '            order.takerTokenAmount,\n', '            order.expires,\n', '            order.nonce\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if a order can be traded.\n', "    /// @param addresses Array of trade's maker, makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    /// @param signature Signed order along with signature mode.\n', '    /// @return Boolean if order can be traded\n', '    function canTrade(address[3] addresses, uint[4] values, bytes signature)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '\n', '        bytes32 hash = order.hash();\n', '\n', '        return canTrade(order, signature, hash);\n', '    }\n', '\n', '    /// @dev Returns if user has subscribed to trade hooks.\n', '    /// @param subscriber Address of the subscriber.\n', '    /// @return Boolean if user is subscribed.\n', '    function isSubscribed(address subscriber) external view returns (bool) {\n', '        return subscribed[subscriber];\n', '    }\n', '\n', '    /// @dev Checks how much of an order can be filled.\n', "    /// @param addresses Array of trade's maker, makerToken and takerToken.\n", "    /// @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\n", '    /// @return Amount of the order which can be filled.\n', '    function availableAmount(address[3] addresses, uint[4] values) external view returns (uint) {\n', '        OrderLibrary.Order memory order = OrderLibrary.createOrder(addresses, values);\n', '        return availableAmount(order, order.hash());\n', '    }\n', '\n', '    /// @dev Returns how much of an order was filled.\n', '    /// @param hash Hash of the order.\n', '    /// @return Amount which was filled.\n', '    function filled(bytes32 hash) external view returns (uint) {\n', '        return fills[hash];\n', '    }\n', '\n', '    /// @dev Sets the taker fee.\n', '    /// @param _takerFee New taker fee.\n', '    function setFees(uint _takerFee) public onlyOwner {\n', '        require(_takerFee <= MAX_FEE);\n', '        takerFee = _takerFee;\n', '    }\n', '\n', '    /// @dev Sets the account where fees will be transferred to.\n', '    /// @param _feeAccount Address for the account.\n', '    function setFeeAccount(address _feeAccount) public onlyOwner {\n', '        require(_feeAccount != 0x0);\n', '        feeAccount = _feeAccount;\n', '    }\n', '\n', '    function vault() public view returns (VaultInterface) {\n', '        return vault;\n', '    }\n', '\n', '    /// @dev Checks if an order was created on chain.\n', '    /// @param user User who created the order.\n', '    /// @param hash Hash of the order.\n', '    /// @return Boolean if the order was created on chain.\n', '    function isOrdered(address user, bytes32 hash) public view returns (bool) {\n', '        return orders[user][hash];\n', '    }\n', '\n', '    /// @dev Executes the actual trade by transferring balances.\n', '    /// @param order Order to be traded.\n', '    /// @param taker Address of the taker.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @param maxFillAmount Maximum amount of the order to be filled.\n', '    function trade(OrderLibrary.Order memory order, address taker, bytes signature, uint maxFillAmount) internal {\n', '        require(taker != order.maker);\n', '        bytes32 hash = order.hash();\n', '\n', '        require(order.makerToken != order.takerToken);\n', '        require(canTrade(order, signature, hash));\n', '\n', '        uint fillAmount = SafeMath.min256(maxFillAmount, availableAmount(order, hash));\n', '\n', '        require(roundingPercent(fillAmount, order.takerTokenAmount, order.makerTokenAmount) <= MAX_ROUNDING_PERCENTAGE);\n', '        require(vault.balanceOf(order.takerToken, taker) >= fillAmount);\n', '\n', '        uint makeAmount = order.makerTokenAmount.mul(fillAmount).div(order.takerTokenAmount);\n', '        uint tradeTakerFee = makeAmount.mul(takerFee).div(1 ether);\n', '\n', '        if (tradeTakerFee > 0) {\n', '            vault.transfer(order.makerToken, order.maker, feeAccount, tradeTakerFee);\n', '        }\n', '\n', '        vault.transfer(order.takerToken, taker, order.maker, fillAmount);\n', '        vault.transfer(order.makerToken, order.maker, taker, makeAmount.sub(tradeTakerFee));\n', '\n', '        fills[hash] = fills[hash].add(fillAmount);\n', '        assert(fills[hash] <= order.takerTokenAmount);\n', '\n', '        if (subscribed[order.maker]) {\n', '            order.maker.call.gas(MAX_HOOK_GAS)(HookSubscriber(order.maker).tradeExecuted.selector, order.takerToken, fillAmount);\n', '        }\n', '\n', '        emit Traded(\n', '            hash,\n', '            order.makerToken,\n', '            makeAmount,\n', '            order.takerToken,\n', '            fillAmount,\n', '            order.maker,\n', '            taker\n', '        );\n', '    }\n', '\n', '    /// @dev Indicates whether or not an certain amount of an order can be traded.\n', '    /// @param order Order to be traded.\n', '    /// @param signature Signed order along with signature mode.\n', '    /// @param hash Hash of the order.\n', '    /// @return Boolean if order can be traded\n', '    function canTrade(OrderLibrary.Order memory order, bytes signature, bytes32 hash)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // if the order has never been traded against, we need to check the sig.\n', '        if (fills[hash] == 0) {\n', '            // ensures order was either created on chain, or signature is valid\n', '            if (!isOrdered(order.maker, hash) && !SignatureValidator.isValidSignature(hash, order.maker, signature)) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        if (cancelled[hash]) {\n', '            return false;\n', '        }\n', '\n', '        if (!vault.isApproved(order.maker, this)) {\n', '            return false;\n', '        }\n', '\n', '        if (order.takerTokenAmount == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (order.makerTokenAmount == 0) {\n', '            return false;\n', '        }\n', '\n', '        // ensures that the order still has an available amount to be filled.\n', '        if (availableAmount(order, hash) == 0) {\n', '            return false;\n', '        }\n', '\n', '        return order.expires > now;\n', '    }\n', '\n', '    /// @dev Returns the maximum available amount that can be taken of an order.\n', '    /// @param order Order to check.\n', '    /// @param hash Hash of the order.\n', '    /// @return Amount of the order that can be filled.\n', '    function availableAmount(OrderLibrary.Order memory order, bytes32 hash) internal view returns (uint) {\n', '        return SafeMath.min256(\n', '            order.takerTokenAmount.sub(fills[hash]),\n', '            vault.balanceOf(order.makerToken, order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount)\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the percentage which was rounded when dividing.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with.\n', '    /// @return Percentage rounded.\n', '    function roundingPercent(uint numerator, uint denominator, uint target) internal pure returns (uint) {\n', '        // Inspired by https://github.com/0xProject/contracts/blob/1.0.0/contracts/Exchange.sol#L472-L490\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return remainder.mul(1000000).div(numerator.mul(target));\n', '    }\n', '}']
