['pragma solidity 0.4.21;\n', '\n', '// File: contracts/ExchangeHandler.sol\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'interface ExchangeHandler {\n', '\n', '    /// @dev Get the available amount left to fill for an order\n', '    /// @param orderAddresses Array of address values needed for this DEX order\n', '    /// @param orderValues Array of uint values needed for this DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Available amount left to fill for this order\n', '    function getAvailableAmount(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '\n', '    /// @dev Perform a buy order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable returns (uint256);\n', '\n', '    /// @dev Perform a sell order at the exchange\n', '    /// @param orderAddresses Array of address values needed for each DEX order\n', '    /// @param orderValues Array of uint values needed for each DEX order\n', '    /// @param exchangeFee Value indicating the fee for this DEX order\n', '    /// @param amountToFill Amount to fill in this order\n', '    /// @param v ECDSA signature parameter v\n', '    /// @param r ECDSA signature parameter r\n', '    /// @param s ECDSA signature parameter s\n', '    /// @return Amount filled in this order\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '}\n', '\n', '// File: contracts/ZeroExMock.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract ZXOwnable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract ZXToken {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract ZeroExTokenTransferProxy is ZXOwnable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return ZXToken(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', 'contract ZXSafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/// @title Exchange - Facilitates exchange of ERC20 tokens.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract ZeroExExchange is ZXSafeMath {\n', '\n', '    // Error Codes\n', '    enum Errors {\n', '        ORDER_EXPIRED,                    // Order has already expired\n', '        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n', '        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n', '        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n', '    }\n', '\n', '    string constant public VERSION = "1.0.0";\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    address public ZRX_TOKEN_CONTRACT;\n', '    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n', '\n', '    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n', '    mapping (bytes32 => uint) public filled;\n', '    mapping (bytes32 => uint) public cancelled;\n', '\n', '    event LogFill(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint filledMakerTokenAmount,\n', '        uint filledTakerTokenAmount,\n', '        uint paidMakerFee,\n', '        uint paidTakerFee,\n', '        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogCancel(\n', '        address indexed maker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint cancelledMakerTokenAmount,\n', '        uint cancelledTakerTokenAmount,\n', '        bytes32 indexed tokens,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    function ZeroExExchange(address _zrxToken, address _tokenTransferProxy) {\n', '        ZRX_TOKEN_CONTRACT = _zrxToken;\n', '        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\n', '    }\n', '\n', '    /*\n', '    * Core exchange functions\n', '    */\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Total amount of takerToken filled in trade.\n', '    function fillOrder(\n', '          address[5] orderAddresses,\n', '          uint[6] orderValues,\n', '          uint fillTakerTokenAmount,\n', '          bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '          uint8 v,\n', '          bytes32 r,\n', '          bytes32 s)\n', '          public\n', '          returns (uint filledTakerTokenAmount)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(0) || order.taker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (filledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\n', '            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\n', '            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '        uint paidMakerFee;\n', '        uint paidTakerFee;\n', '        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\n', '        require(transferViaTokenTransferProxy(\n', '            order.makerToken,\n', '            order.maker,\n', '            msg.sender,\n', '            filledMakerTokenAmount\n', '        ));\n', '        require(transferViaTokenTransferProxy(\n', '            order.takerToken,\n', '            msg.sender,\n', '            order.maker,\n', '            filledTakerTokenAmount\n', '        ));\n', '        if (order.feeRecipient != address(0)) {\n', '            if (order.makerFee > 0) {\n', '                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    order.maker,\n', '                    order.feeRecipient,\n', '                    paidMakerFee\n', '                ));\n', '            }\n', '            if (order.takerFee > 0) {\n', '                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    msg.sender,\n', '                    order.feeRecipient,\n', '                    paidTakerFee\n', '                ));\n', '            }\n', '        }\n', '\n', '        LogFill(\n', '            order.maker,\n', '            msg.sender,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            filledMakerTokenAmount,\n', '            filledTakerTokenAmount,\n', '            paidMakerFee,\n', '            paidTakerFee,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Cancels the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n', '    /// @return Amount of takerToken cancelled.\n', '    function cancelOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint cancelTakerTokenAmount)\n', '        public\n', '        returns (uint)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.maker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (cancelledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\n', '\n', '        LogCancel(\n', '            order.maker,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\n', '            cancelledTakerTokenAmount,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return cancelledTakerTokenAmount;\n', '    }\n', '\n', '    /*\n', '    * Wrapper functions\n', '    */\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    function fillOrKillOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '    {\n', '        require(fillOrder(\n', '            orderAddresses,\n', '            orderValues,\n', '            fillTakerTokenAmount,\n', '            false,\n', '            v,\n', '            r,\n', '            s\n', '        ) == fillTakerTokenAmount);\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrKillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrKillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    /// @return Total amount of fillTakerTokenAmount filled in orders.\n', '    function fillOrdersUpTo(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '        returns (uint)\n', '    {\n', '        uint filledTakerTokenAmount = 0;\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\n', '            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            ));\n', '            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\n', '        }\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n', '    function batchCancelOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] cancelTakerTokenAmounts)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            cancelOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                cancelTakerTokenAmounts[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Constant public functions\n', '    */\n', '\n', '    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @return Keccak-256 hash of order.\n', '    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            orderAddresses[0], // maker\n', '            orderAddresses[1], // taker\n', '            orderAddresses[2], // makerToken\n', '            orderAddresses[3], // takerToken\n', '            orderAddresses[4], // feeRecipient\n', '            orderValues[0],    // makerTokenAmount\n', '            orderValues[1],    // takerTokenAmount\n', '            orderValues[2],    // makerFee\n', '            orderValues[3],    // takerFee\n', '            orderValues[4],    // expirationTimestampInSec\n', '            orderValues[5]     // salt\n', '        );\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param signer address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if rounding error > 0.1%.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingError(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) return false; // No rounding error.\n', '\n', '        uint errPercentageTimes1000000 = safeDiv(\n', '            safeMul(remainder, 1000000),\n', '            safeMul(numerator, target)\n', '        );\n', '        return errPercentageTimes1000000 > 1000;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeDiv(safeMul(numerator, target), denominator);\n', '    }\n', '\n', '    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n', '    /// @param orderHash The Keccak-256 hash of the given order.\n', '    /// @return Sum of values already filled and cancelled.\n', '    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeAdd(filled[orderHash], cancelled[orderHash]);\n', '    }\n', '\n', '\n', '    /*\n', '    * Internal functions\n', '    */\n', '\n', '    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\n', '    /// @param token Address of token to transferFrom.\n', '    /// @param from Address transfering token.\n', '    /// @param to Address receiving token.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of token transfer.\n', '    function transferViaTokenTransferProxy(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return ZeroExTokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\n', '    }\n', '\n', '    /// @dev Checks if any order transfers will fail.\n', '    /// @param order Order struct of params that will be checked.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @return Predicted result of transfers.\n', '    function isTransferable(Order order, uint fillTakerTokenAmount)\n', '        internal\n', '        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\n', '        returns (bool)\n', '    {\n', '        address taker = msg.sender;\n', '        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '\n', '        if (order.feeRecipient != address(0)) {\n', '            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\n', '            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\n', '            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\n', '            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\n', '\n', '            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '            ) return false;\n', '\n', '            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don&#39;t double check makerToken if ZRX\n', '                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\n', '            ) return false;\n', '            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don&#39;t double check takerToken if ZRX\n', '                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\n', '            ) return false;\n', '        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\n', '                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\n', '        ) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Get token balance of an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Token balance of owner.\n', '    function getBalance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\n', '    }\n', '\n', '    /// @dev Get allowance of token given to TokenTransferProxy by an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Allowance of token given to TokenTransferProxy by owner.\n', '    function getAllowance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract Token is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/ZeroExHandler.sol\n', '\n', 'interface DepositToken {\n', '    function deposit() external payable;\n', '    function withdraw(uint amount) external payable;\n', '    function balanceOf(address who) external returns(uint256);\n', '}\n', '\n', 'contract ZeroExHandler is ExchangeHandler, Ownable {\n', '    address wethAddress;\n', '    address public exchangeAddress;\n', '    uint constant MAX_UINT = 2**256 - 1;\n', '    mapping(address => bool) public tokenAllowanceSet;\n', '\n', '    event Order(\n', '        address[8] addrs,\n', '        uint256[6] values,\n', '        uint256 value,\n', '        address exc\n', '    );\n', '\n', '    function ZeroExHandler(address _exchangeAddr, address _wethAddr) public {\n', '        exchangeAddress = _exchangeAddr;\n', '        wethAddress = _wethAddr;\n', '    }\n', '\n', '    function() public payable { }\n', '\n', '    /*\n', '     * Returns the remaining amount of the taker token available from this\n', '     * order.\n', '     */\n', '    function getAvailableAmount(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256) {\n', '        if (!orderUsable(orderAddresses, orderValues)) {\n', '            return 0;\n', '        }\n', '        address[5] memory newAddresses = convertAddressFormat(orderAddresses);\n', '        bytes32 orderHash = ZeroExExchange(exchangeAddress).getOrderHash(newAddresses, orderValues);\n', '        return SafeMath.sub(orderValues[1], ZeroExExchange(exchangeAddress).getUnavailableTakerTokenAmount(orderHash));\n', '    }\n', '\n', '    /*\n', '     * Spend ETH to acquire tokens\n', '     */\n', '    function performBuy(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable returns (uint256) {\n', '        require(orderUsable(orderAddresses, orderValues));\n', '        require(orderAddresses[3] == wethAddress);\n', '        require(amountToFill == msg.value);\n', '        DepositToken(wethAddress).deposit.value(amountToFill)();\n', '        address[5] memory newAddresses = convertAddressFormat(orderAddresses);\n', '        bytes32 orderHash = ZeroExExchange(exchangeAddress).getOrderHash(newAddresses, orderValues);\n', '        setAllowance(wethAddress);\n', '        ZeroExExchange(exchangeAddress).fillOrder(newAddresses, orderValues, amountToFill, true, v, r, s);\n', '        uint receivedAmount = getPartialAmount(amountToFill, orderValues[1], orderValues[0]);\n', '        require(Token(newAddresses[2]).transfer(msg.sender, receivedAmount));\n', '        return receivedAmount;\n', '    }\n', '\n', '    /*\n', '     * Spend tokens to acquire ETH\n', '     */\n', '    function performSell(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 exchangeFee,\n', '        uint256 amountToFill,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256) {\n', '        require(orderUsable(orderAddresses, orderValues));\n', '        require(orderAddresses[2] == wethAddress);\n', '        address[5] memory newAddresses = convertAddressFormat(orderAddresses);\n', '        setAllowance(orderAddresses[3]);\n', '        ZeroExExchange(exchangeAddress).fillOrder(newAddresses, orderValues, amountToFill, false, v, r, s);\n', '        uint receivedAmount = getPartialAmount(amountToFill, orderValues[1], orderValues[0]);\n', '        DepositToken(wethAddress).withdraw(receivedAmount);\n', '        msg.sender.transfer(receivedAmount);\n', '        return receivedAmount;\n', '    }\n', '\n', '    function setAllowance(address token) internal {\n', '        if(!tokenAllowanceSet[token]) {\n', '            Token(token).approve(ZeroExExchange(exchangeAddress).TOKEN_TRANSFER_PROXY_CONTRACT(), MAX_UINT);\n', '            tokenAllowanceSet[token] = true;\n', '        }\n', '    }\n', '\n', '    function orderUsable(\n', '        address[8] orderAddresses,\n', '        uint256[6] orderValues\n', '    ) internal returns (bool) {\n', '        return (\n', '            (orderAddresses[1] == address(0) ||    // Order&#39;s taker is anybody\n', '            orderAddresses[1] == address(this)) && // Or the order&#39;s taker is this handler\n', '            orderValues[3] == 0 &&                 // takerFees are 0\n', '            orderValues[4] > block.timestamp       // Order is not expired\n', '        );\n', '    }\n', '\n', '    function getPartialAmount(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\n', '    }\n', '\n', '    function convertAddressFormat(address[8] oldFormat) internal pure returns (address[5] newFormat) {\n', '        for(uint256 i = 0; i < newFormat.length; i++) {\n', '            newFormat[i] = oldFormat[i];\n', '        }\n', '    }\n', '}']