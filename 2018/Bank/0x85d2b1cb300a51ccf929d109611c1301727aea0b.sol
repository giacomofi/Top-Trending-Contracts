['pragma solidity^0.4.24;\n', '\n', 'contract ERC20 {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '}\n', 'contract father {\n', '    function fallback(uint num,address sender,uint amount) public;\n', '}\n', '\n', 'contract fathercontract{\n', '    \n', '    address owner;\n', '    address public NEO = 0xc55a13e36d93371a5b036a21d913a31CD2804ba4;\n', '    \n', '    mapping(address => uint)value;\n', '    mapping(address => address) contr;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    function use(uint _value) public {\n', '        \n', '        value[msg.sender] = _value*1e8;\n', '        ERC20(NEO).transferFrom(msg.sender,this,value[msg.sender]);\n', '        \n', '        if (contr[msg.sender] == address(0)){\n', '            getsometoken(msg.sender,value[msg.sender]);\n', '        }else{\n', '            getsometokenn(msg.sender,value[msg.sender]);\n', '        }\n', '    }\n', '    function getsometokenn(address _sender,uint _value) internal{\n', '        ERC20(NEO).transfer(contr[_sender],_value);\n', '        contr[_sender].call.value(0)();\n', '    }\n', '    function getsometoken(address _sender,uint _value) internal {\n', '        contr[msg.sender] = new getfreetoken(this,_sender);\n', '        ERC20(NEO).transfer(contr[_sender],_value);\n', '        contr[_sender].call.value(0)();\n', '    }\n', '    function fallback(uint num,address sender,uint amount) public {\n', '        require(contr[sender] == msg.sender);\n', '        if (num == 10){\n', '            uint a = (amount+(amount/500)-value[sender])/100*5;\n', '            ERC20(NEO).transfer(sender,amount+(amount/500)-a);\n', '            ERC20(NEO).transfer(owner,a);\n', '            value[sender] = 0;\n', '        }else{\n', '            getsometokenn(sender,amount+(amount/500));\n', '        }\n', '    }\n', '}\n', '\n', 'contract getfreetoken {\n', '    \n', '    address sender;\n', '    address fatherr;\n', '    address NEO = 0xc55a13e36d93371a5b036a21d913a31CD2804ba4;\n', '    \n', '    uint num;\n', '    \n', '    constructor(address _father,address _sender) public {\n', '        fatherr = _father;\n', '        sender = _sender;\n', '    }\n', '    function() public {\n', '        trans();\n', '    }\n', '    function trans() internal {\n', '        \n', '        uint A = ERC20(NEO).balanceOf(this);\n', '        \n', '        ERC20(NEO).transfer(fatherr,ERC20(NEO).balanceOf(this));\n', '        num++;\n', '        father(fatherr).fallback(num,sender,A);\n', '        \n', '        if (num == 10){num = 0;}\n', '    }\n', '}']
['pragma solidity^0.4.24;\n', '\n', 'contract ERC20 {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '}\n', 'contract father {\n', '    function fallback(uint num,address sender,uint amount) public;\n', '}\n', '\n', 'contract fathercontract{\n', '    \n', '    address owner;\n', '    address public NEO = 0xc55a13e36d93371a5b036a21d913a31CD2804ba4;\n', '    \n', '    mapping(address => uint)value;\n', '    mapping(address => address) contr;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    function use(uint _value) public {\n', '        \n', '        value[msg.sender] = _value*1e8;\n', '        ERC20(NEO).transferFrom(msg.sender,this,value[msg.sender]);\n', '        \n', '        if (contr[msg.sender] == address(0)){\n', '            getsometoken(msg.sender,value[msg.sender]);\n', '        }else{\n', '            getsometokenn(msg.sender,value[msg.sender]);\n', '        }\n', '    }\n', '    function getsometokenn(address _sender,uint _value) internal{\n', '        ERC20(NEO).transfer(contr[_sender],_value);\n', '        contr[_sender].call.value(0)();\n', '    }\n', '    function getsometoken(address _sender,uint _value) internal {\n', '        contr[msg.sender] = new getfreetoken(this,_sender);\n', '        ERC20(NEO).transfer(contr[_sender],_value);\n', '        contr[_sender].call.value(0)();\n', '    }\n', '    function fallback(uint num,address sender,uint amount) public {\n', '        require(contr[sender] == msg.sender);\n', '        if (num == 10){\n', '            uint a = (amount+(amount/500)-value[sender])/100*5;\n', '            ERC20(NEO).transfer(sender,amount+(amount/500)-a);\n', '            ERC20(NEO).transfer(owner,a);\n', '            value[sender] = 0;\n', '        }else{\n', '            getsometokenn(sender,amount+(amount/500));\n', '        }\n', '    }\n', '}\n', '\n', 'contract getfreetoken {\n', '    \n', '    address sender;\n', '    address fatherr;\n', '    address NEO = 0xc55a13e36d93371a5b036a21d913a31CD2804ba4;\n', '    \n', '    uint num;\n', '    \n', '    constructor(address _father,address _sender) public {\n', '        fatherr = _father;\n', '        sender = _sender;\n', '    }\n', '    function() public {\n', '        trans();\n', '    }\n', '    function trans() internal {\n', '        \n', '        uint A = ERC20(NEO).balanceOf(this);\n', '        \n', '        ERC20(NEO).transfer(fatherr,ERC20(NEO).balanceOf(this));\n', '        num++;\n', '        father(fatherr).fallback(num,sender,A);\n', '        \n', '        if (num == 10){num = 0;}\n', '    }\n', '}']
