['pragma solidity ^0.4.21;\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '    function burn(uint256 amount) external returns (bool success);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint256 z = x + y;\n', '        require((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint z = x * y;\n', '        require((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '        bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '        return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'interface Baliv {\n', '    function agentMakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '    function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '    function getPrice(address fromToken_, address toToken_) external view returns(uint256);\n', '}\n', '\n', 'interface TokenFactory {\n', '    function getPrice(address token_) external view returns(uint256);\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => bool) internal authbook;\n', '    address[] public operators;\n', '    address owner;\n', '\n', '    function Authorization()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        assignOperator(msg.sender);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(checkOperator(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if(user_ != address(0) && !authbook[user_]) {\n', '            authbook[user_] = true;\n', '            operators.push(user_);\n', '        }\n', '    }\n', '    \n', '    function dismissOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        delete authbook[user_];\n', '        for(uint i = 0; i < operators.length; i++) {\n', '            if(operators[i] == user_) {\n', '                operators[i] = operators[operators.length - 1];\n', '                operators.length -= 1;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function checkOperator(address user_)\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return authbook[user_];\n', '    }\n', '}\n', '\n', 'contract FundAccount is Authorization, SafeMath {\n', '    string public version = "0.5.0";\n', '\n', '    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;\n', '    address public xpaExchange = 0x008ea74569c1b9bbb13780114b6b5e93396910070a;\n', '    address public XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '    \n', '    function FundAccount(\n', '        address XPAAddr, \n', '        address balivAddr, \n', '        address factoryAddr\n', '    ) public {\n', '        XPA = XPAAddr;\n', '        xpaExchange = balivAddr;\n', '        tokenFactory = factoryAddr;\n', '    }\n', '\n', '    /*\n', '        10% - 110% price\n', '        20% - 105% price\n', '        40% - 100% price\n', '        20% -  95% price\n', '        10% -  90% price\n', '     */\n', '    function burn(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        uint256 price = TokenFactory(tokenFactory).getPrice(token_);\n', '        uint256 xpaAmount = amount_ * 1 ether / price;\n', '        if(\n', '            Token(token_).burn(amount_) &&\n', '            xpaAmount > 0 &&\n', '            Token(XPA).balanceOf(this) >= xpaAmount\n', '        ) {\n', '            uint256 orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 110), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 5);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 105), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 2);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, price, orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 95), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 90), 100), orderAmount, this);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function withdraw(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        if(token_ == address(0)) {\n', '            msg.sender.transfer(amount_);\n', '            return true;\n', '        } else {\n', '            return Token(token_).transfer(msg.sender, amount_);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '    function burn(uint256 amount) external returns (bool success);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint256 z = x + y;\n', '        require((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint z = x * y;\n', '        require((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '        bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '        return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'interface Baliv {\n', '    function agentMakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '    function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n', '    function getPrice(address fromToken_, address toToken_) external view returns(uint256);\n', '}\n', '\n', 'interface TokenFactory {\n', '    function getPrice(address token_) external view returns(uint256);\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => bool) internal authbook;\n', '    address[] public operators;\n', '    address owner;\n', '\n', '    function Authorization()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        assignOperator(msg.sender);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(checkOperator(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if(user_ != address(0) && !authbook[user_]) {\n', '            authbook[user_] = true;\n', '            operators.push(user_);\n', '        }\n', '    }\n', '    \n', '    function dismissOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        delete authbook[user_];\n', '        for(uint i = 0; i < operators.length; i++) {\n', '            if(operators[i] == user_) {\n', '                operators[i] = operators[operators.length - 1];\n', '                operators.length -= 1;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function checkOperator(address user_)\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return authbook[user_];\n', '    }\n', '}\n', '\n', 'contract FundAccount is Authorization, SafeMath {\n', '    string public version = "0.5.0";\n', '\n', '    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;\n', '    address public xpaExchange = 0x008ea74569c1b9bbb13780114b6b5e93396910070a;\n', '    address public XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '    \n', '    function FundAccount(\n', '        address XPAAddr, \n', '        address balivAddr, \n', '        address factoryAddr\n', '    ) public {\n', '        XPA = XPAAddr;\n', '        xpaExchange = balivAddr;\n', '        tokenFactory = factoryAddr;\n', '    }\n', '\n', '    /*\n', '        10% - 110% price\n', '        20% - 105% price\n', '        40% - 100% price\n', '        20% -  95% price\n', '        10% -  90% price\n', '     */\n', '    function burn(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        uint256 price = TokenFactory(tokenFactory).getPrice(token_);\n', '        uint256 xpaAmount = amount_ * 1 ether / price;\n', '        if(\n', '            Token(token_).burn(amount_) &&\n', '            xpaAmount > 0 &&\n', '            Token(XPA).balanceOf(this) >= xpaAmount\n', '        ) {\n', '            uint256 orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 110), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 5);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 105), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 2);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, price, orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 95), 100), orderAmount, this);\n', '\n', '            orderAmount = safeDiv(xpaAmount, 10);\n', '            Token(XPA).approve(xpaExchange, orderAmount);\n', '            Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 90), 100), orderAmount, this);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function withdraw(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        if(token_ == address(0)) {\n', '            msg.sender.transfer(amount_);\n', '            return true;\n', '        } else {\n', '            return Token(token_).transfer(msg.sender, amount_);\n', '        }\n', '    }\n', '}']
