['pragma solidity ^0.4.21;\n', '\n', 'contract SEO{\n', '    uint price;\n', '    uint stop_time;\n', '    uint balance;\n', '    uint total_tickets;\n', '    uint time=1 days;\n', '    address winner;\n', '    address owner;\n', '    bool owner_flag=false;\n', '    mapping(address=>uint) own_tickets;\n', '    mapping(address=>bool) claim_status;\n', '    modifier game_over(){\n', '        require(now>stop_time);\n', '        _;\n', '    }\n', '    function SEO() public{\n', '        price=0.1 ether;\n', '        stop_time=now+time;\n', '        owner=msg.sender;\n', '    }\n', '    function buy() public payable{\n', '        require(msg.value>=price);\n', '        require(now<stop_time);\n', '        own_tickets[msg.sender]++;\n', '        balance+=msg.value;\n', '        winner=msg.sender;\n', '        stop_time=now+time;\n', '        price+=0.1 ether;\n', '        total_tickets++;\n', '    }\n', '    function claim() public payable game_over(){\n', '        require(!claim_status[msg.sender]==true);\n', '        uint tmp_value;\n', '        if(msg.sender==winner){\n', '            tmp_value=price-0.1 ether+(balance-price+0.1 ether)/20;\n', '        }\n', '        tmp_value+=(balance-(balance-price+0.1 ether)/10-price+0.1 ether)/total_tickets*own_tickets[msg.sender];\n', '        msg.sender.transfer(tmp_value);\n', '        claim_status[msg.sender]=true;\n', '    }\n', '    function force_stop() public{\n', '        require(msg.sender==owner);\n', '        stop_time=0;\n', '    }\n', '    function owner_withdraw() public payable game_over(){\n', '        require(owner_flag==false);\n', '        owner.transfer((balance-price+0.1 ether)/20);\n', '        owner_flag=true;\n', '    }\n', '    function get_price() public view returns (uint){\n', '        return price;\n', '    }\n', '    function get_time() public view returns (uint){\n', '        return stop_time;\n', '    }\n', '    function get_balance() public view returns(uint){\n', '        return balance;\n', '    }\n', '}']