['pragma solidity ^0.4.23;\n', '\n', '/******************************************************************\n', ' * AXNET Decentralized Exchange Smart Contract * \n', ' * ***************************************************************/\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint);\n', '    function allowance(address _owner, address _spender) public constant returns (uint);\n', '    \n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;  // 18 is the most common number of decimal places\n', '}\n', '\n', '\n', 'contract AXNETDEX is SafeMath, Owned {\n', '  address public feeAccount; //the account that will receive fees\n', '\n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '\n', '  mapping (address => bool) public admins;  //admins who is responsible for trading\n', '  \n', '  //mapping of order hash to mapping of uints (amount of order that has been filled)\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  \n', '  //to make sure withdraw and trade will be done only once\n', '  mapping (bytes32 => bool) public withdrawn;\n', '  mapping (bytes32 => bool) public traded;\n', '  \n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', ' constructor() public {\n', '    feeAccount = msg.sender;\n', '  }\n', '\n', '  function() public {\n', '    revert();\n', '  }\n', '  \n', '  function setAdmin(address admin, bool isAdmin) public onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '  \n', '  modifier onlyAdmin {\n', '    require(msg.sender == owner || admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function changeFeeAccount(address feeAccount_) public onlyOwner {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  function deposit() payable public {\n', '    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '    emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function depositToken(address token, uint amount) public {\n', '    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '    require(token!=0);\n', '    assert(Token(token).transferFrom(msg.sender, this, amount));\n', '    \n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function adminWithdraw(address token, uint amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s, uint feeWithdrawal) public onlyAdmin {\n', '    bytes32 hash = sha256(this, token, amount, user, nonce);\n', '    require(!withdrawn[hash]);\n', '    withdrawn[hash] = true;\n', '    \n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user);\n', '    \n', '    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n', '\n', '    require(tokens[token][user] >= amount);\n', '    tokens[token][user] = safeSub(tokens[token][user], amount);\n', '    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n', '    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n', '\n', '    if (token == address(0)) {\n', '      assert(user.send(amount));\n', '    } else {\n', '      assert(Token(token).transfer(user, amount));\n', '    }\n', '    \n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '  }\n', '\n', '  function balanceOf(address token, address user)  public view returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '  \n', '    /* uint values\n', '         0:amountGet, 1:amountGive, 2:expires, 3:nonce, 4:amount, 5:tradeNonce, 6:feeMake, 7:feeTake\n', '       addressses\n', '         0:tokenGet, 1:tokenGive, 2:maker, 3:taker\n', '     signature binary\n', '       v[0] rs[0] rs[1] : signature for order\n', '       v[1] rs[2] rs[3] : signature for trade\n', '     */\n', '  function trade(uint[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) public onlyAdmin {\n', '    bytes32 orderHash = sha256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\n', '    bytes32 tradeHash = sha256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\n', '    \n', '    require(!traded[tradeHash]);\n', '    traded[tradeHash] = true;\n', '    \n', '    require(safeAdd(orderFills[orderHash], tradeValues[4]) <= tradeValues[0]);\n', '    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[4]);\n', '    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]));\n', '    \n', '    tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]);\n', '    tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether));\n', '    tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether));\n', '    tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]);\n', '    tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\n', '    tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\n', '    orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]);\n', '  }\n', '\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s, address user) public onlyAdmin {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, user);\n', '    assert(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user);\n', '    orderFills[hash] = amountGet;\n', '    emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s);\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/******************************************************************\n', ' * AXNET Decentralized Exchange Smart Contract * \n', ' * ***************************************************************/\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint);\n', '    function allowance(address _owner, address _spender) public constant returns (uint);\n', '    \n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;  // 18 is the most common number of decimal places\n', '}\n', '\n', '\n', 'contract AXNETDEX is SafeMath, Owned {\n', '  address public feeAccount; //the account that will receive fees\n', '\n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '\n', '  mapping (address => bool) public admins;  //admins who is responsible for trading\n', '  \n', '  //mapping of order hash to mapping of uints (amount of order that has been filled)\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  \n', '  //to make sure withdraw and trade will be done only once\n', '  mapping (bytes32 => bool) public withdrawn;\n', '  mapping (bytes32 => bool) public traded;\n', '  \n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', ' constructor() public {\n', '    feeAccount = msg.sender;\n', '  }\n', '\n', '  function() public {\n', '    revert();\n', '  }\n', '  \n', '  function setAdmin(address admin, bool isAdmin) public onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '  \n', '  modifier onlyAdmin {\n', '    require(msg.sender == owner || admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function changeFeeAccount(address feeAccount_) public onlyOwner {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  function deposit() payable public {\n', '    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '    emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function depositToken(address token, uint amount) public {\n', '    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '    require(token!=0);\n', '    assert(Token(token).transferFrom(msg.sender, this, amount));\n', '    \n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function adminWithdraw(address token, uint amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s, uint feeWithdrawal) public onlyAdmin {\n', '    bytes32 hash = sha256(this, token, amount, user, nonce);\n', '    require(!withdrawn[hash]);\n', '    withdrawn[hash] = true;\n', '    \n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user);\n', '    \n', '    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n', '\n', '    require(tokens[token][user] >= amount);\n', '    tokens[token][user] = safeSub(tokens[token][user], amount);\n', '    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n', '    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n', '\n', '    if (token == address(0)) {\n', '      assert(user.send(amount));\n', '    } else {\n', '      assert(Token(token).transfer(user, amount));\n', '    }\n', '    \n', '    emit Withdraw(token, user, amount, tokens[token][user]);\n', '  }\n', '\n', '  function balanceOf(address token, address user)  public view returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '  \n', '    /* uint values\n', '         0:amountGet, 1:amountGive, 2:expires, 3:nonce, 4:amount, 5:tradeNonce, 6:feeMake, 7:feeTake\n', '       addressses\n', '         0:tokenGet, 1:tokenGive, 2:maker, 3:taker\n', '     signature binary\n', '       v[0] rs[0] rs[1] : signature for order\n', '       v[1] rs[2] rs[3] : signature for trade\n', '     */\n', '  function trade(uint[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) public onlyAdmin {\n', '    bytes32 orderHash = sha256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\n', '    bytes32 tradeHash = sha256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]);\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\n', '    \n', '    require(!traded[tradeHash]);\n', '    traded[tradeHash] = true;\n', '    \n', '    require(safeAdd(orderFills[orderHash], tradeValues[4]) <= tradeValues[0]);\n', '    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[4]);\n', '    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]));\n', '    \n', '    tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]);\n', '    tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether));\n', '    tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether));\n', '    tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]);\n', '    tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\n', '    tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\n', '    orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]);\n', '  }\n', '\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s, address user) public onlyAdmin {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, user);\n', '    assert(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user);\n', '    orderFills[hash] = amountGet;\n', '    emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s);\n', '  }\n', '}']
