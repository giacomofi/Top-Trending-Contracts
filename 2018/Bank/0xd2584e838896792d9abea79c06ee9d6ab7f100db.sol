['pragma solidity 0.4.25;\n', '\n', 'library SafeMath256 {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint256 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function _validateAddress(address _addr) internal pure {\n', '        require(_addr != address(0), "invalid address");\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "not a contract owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _validateAddress(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    mapping(address => bool) controllers;\n', '\n', '    modifier onlyController {\n', '        require(_isController(msg.sender), "no controller rights");\n', '        _;\n', '    }\n', '\n', '    function _isController(address _controller) internal view returns (bool) {\n', '        return controllers[_controller];\n', '    }\n', '\n', '    function _setControllers(address[] _controllers) internal {\n', '        for (uint256 i = 0; i < _controllers.length; i++) {\n', '            _validateAddress(_controllers[i]);\n', '            controllers[_controllers[i]] = true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Upgradable is Controllable {\n', '    address[] internalDependencies;\n', '    address[] externalDependencies;\n', '\n', '    function getInternalDependencies() public view returns(address[]) {\n', '        return internalDependencies;\n', '    }\n', '\n', '    function getExternalDependencies() public view returns(address[]) {\n', '        return externalDependencies;\n', '    }\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        for (uint256 i = 0; i < _newDependencies.length; i++) {\n', '            _validateAddress(_newDependencies[i]);\n', '        }\n', '        internalDependencies = _newDependencies;\n', '    }\n', '\n', '    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        externalDependencies = _newDependencies;\n', '        _setControllers(_newDependencies);\n', '    }\n', '}\n', '\n', 'contract Gold {\n', '    function remoteTransfer(address _to, uint256 _value) external;\n', '}\n', '\n', 'contract GoldMarketplaceStorage {\n', '    function () external payable;\n', '    function transferGold(address, uint256) external;\n', '    function transferEth(address, uint256) external;\n', '    function createSellOrder(address, uint256, uint256) external;\n', '    function cancelSellOrder(address) external;\n', '    function updateSellOrder(address, uint256, uint256) external;\n', '    function createBuyOrder(address, uint256, uint256) external;\n', '    function cancelBuyOrder(address) external;\n', '    function updateBuyOrder(address, uint256, uint256) external;\n', '    function orderOfSeller(address) external view returns (uint256, address, uint256, uint256);\n', '    function orderOfBuyer(address) external view returns (uint256, address, uint256, uint256);\n', '    function sellOrdersAmount() external view returns (uint256);\n', '    function buyOrdersAmount() external view returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '//////////////CONTRACT//////////////\n', '\n', '\n', '\n', '\n', 'contract GoldMarketplace is Upgradable {\n', '    using SafeMath256 for uint256;\n', '\n', '    GoldMarketplaceStorage _storage_;\n', '    Gold goldTokens;\n', '\n', '    uint256 constant GOLD_DECIMALS = uint256(10) ** 18;\n', '\n', '\n', '    function _calculateFullPrice(\n', '        uint256 _price,\n', '        uint256 _amount\n', '    ) internal pure returns (uint256) {\n', '        return _price.mul(_amount).div(GOLD_DECIMALS);\n', '    }\n', '\n', '    function _transferGold(address _to, uint256 _value) internal {\n', '        goldTokens.remoteTransfer(_to, _value);\n', '    }\n', '\n', '    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a <= _b ? _a : _b;\n', '    }\n', '\n', '    function _safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return b > a ? 0 : a.sub(b);\n', '    }\n', '\n', '    function _checkPrice(uint256 _value) internal pure {\n', '        require(_value > 0, "price must be greater than 0");\n', '    }\n', '\n', '    function _checkAmount(uint256 _value) internal pure {\n', '        require(_value > 0, "amount must be greater than 0");\n', '    }\n', '\n', '    function _checkActualPrice(uint256 _expected, uint256 _actual) internal pure {\n', '        require(_expected == _actual, "wrong actual price");\n', '    }\n', '\n', '    // SELL\n', '\n', '    function createSellOrder(\n', '        address _user,\n', '        uint256 _price,\n', '        uint256 _amount\n', '    ) external onlyController {\n', '        _checkPrice(_price);\n', '        _checkAmount(_amount);\n', '\n', '        _transferGold(address(_storage_), _amount);\n', '\n', '        _storage_.createSellOrder(_user, _price, _amount);\n', '    }\n', '\n', '    function cancelSellOrder(address _user) external onlyController {\n', '        ( , , , uint256 _amount) = _storage_.orderOfSeller(_user);\n', '        _storage_.transferGold(_user, _amount);\n', '        _storage_.cancelSellOrder(_user);\n', '    }\n', '\n', '    function fillSellOrder(\n', '        address _buyer,\n', '        uint256 _value,\n', '        address _seller,\n', '        uint256 _expectedPrice,\n', '        uint256 _amount\n', '    ) external onlyController returns (uint256 price) {\n', '        uint256 _available;\n', '        ( , , price, _available) = _storage_.orderOfSeller(_seller);\n', '\n', '        _checkAmount(_amount);\n', '        require(_amount <= _available, "seller has no enough gold");\n', '        _checkActualPrice(_expectedPrice, price);\n', '\n', '        uint256 _fullPrice = _calculateFullPrice(price, _amount);\n', '        require(_fullPrice > 0, "no free gold, sorry");\n', '        require(_fullPrice <= _value, "not enough ether");\n', '\n', '        _seller.transfer(_fullPrice);\n', '        if (_value > _fullPrice) {\n', '            _buyer.transfer(_value.sub(_fullPrice));\n', '        }\n', '        _storage_.transferGold(_buyer, _amount);\n', '\n', '        _available = _available.sub(_amount);\n', '\n', '        if (_available == 0) {\n', '            _storage_.cancelSellOrder(_seller);\n', '        } else {\n', '            _storage_.updateSellOrder(_seller, price, _available);\n', '        }\n', '    }\n', '\n', '    // BUY\n', '\n', '    function () external payable onlyController {}\n', '\n', '    function createBuyOrder(\n', '        address _user,\n', '        uint256 _value, // eth\n', '        uint256 _price,\n', '        uint256 _amount\n', '    ) external onlyController {\n', '        _checkPrice(_price);\n', '        _checkAmount(_amount);\n', '\n', '        uint256 _fullPrice = _calculateFullPrice(_price, _amount);\n', '        require(_fullPrice == _value, "wrong eth value");\n', '\n', '        address(_storage_).transfer(_value);\n', '\n', '        _storage_.createBuyOrder(_user, _price, _amount);\n', '    }\n', '\n', '    function cancelBuyOrder(address _user) external onlyController {\n', '        ( , address _buyer, uint256 _price, uint256 _amount) = _storage_.orderOfBuyer(_user);\n', '        require(_buyer == _user, "user addresses are not equal");\n', '\n', '        uint256 _fullPrice = _calculateFullPrice(_price, _amount);\n', '        _storage_.transferEth(_user, _fullPrice);\n', '\n', '        _storage_.cancelBuyOrder(_user);\n', '    }\n', '\n', '    function fillBuyOrder(\n', '        address _seller,\n', '        address _buyer,\n', '        uint256 _expectedPrice,\n', '        uint256 _amount\n', '    ) external onlyController returns (uint256 price) {\n', '        uint256 _needed;\n', '        ( , , price, _needed) = _storage_.orderOfBuyer(_buyer);\n', '\n', '        _checkAmount(_amount);\n', '        require(_amount <= _needed, "buyer do not need so much");\n', '        _checkActualPrice(_expectedPrice, price);\n', '\n', '        uint256 _fullPrice = _calculateFullPrice(price, _amount);\n', '\n', '        _transferGold(_buyer, _amount);\n', '        _storage_.transferEth(_seller, _fullPrice);\n', '\n', '        _needed = _needed.sub(_amount);\n', '\n', '        if (_needed == 0) {\n', '            _storage_.cancelBuyOrder(_buyer);\n', '        } else {\n', '            _storage_.updateBuyOrder(_buyer, price, _needed);\n', '        }\n', '    }\n', '\n', '    // UPDATE CONTRACT\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        super.setInternalDependencies(_newDependencies);\n', '\n', '        _storage_ = GoldMarketplaceStorage(_newDependencies[0]);\n', '        goldTokens = Gold(_newDependencies[1]);\n', '    }\n', '}']