['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function takeOwnership(uint256 _tokenId) public;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EtherIslands is Ownable, ERC721 {\n', '    using SafeMath for uint256;\n', '\n', '    /*** EVENTS ***/\n', '    event NewIsland(uint256 tokenId, bytes32 name, address owner);\n', '    event IslandSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event DividendsPaid(address to, uint256 amount, bytes32 divType);\n', '    event ShipsBought(uint256 tokenId, address owner);\n', '    event IslandAttacked(uint256 attackerId, uint256 targetId, uint256 treasuryStolen);\n', '    event TreasuryWithdrawn(uint256 tokenId);\n', '\n', '    /*** STRUCTS ***/\n', '    struct Island {\n', '        bytes32 name;\n', '        address owner;\n', '        uint256 price;\n', '        uint256 treasury;\n', '        uint256 treasury_next_withdrawal_block;\n', '        uint256 previous_price;\n', '        uint256 attack_ships_count;\n', '        uint256 defense_ships_count;\n', '        uint256 transactions_count;\n', '        address approve_transfer_to;\n', '        address[2] previous_owners;\n', '    }\n', '\n', '    struct IslandBattleStats {\n', '        uint256 attacks_won;\n', '        uint256 attacks_lost;\n', '        uint256 defenses_won;\n', '        uint256 defenses_lost;\n', '        uint256 treasury_stolen;\n', '        uint256 treasury_lost;\n', '        uint256 attack_cooldown;\n', '        uint256 defense_cooldown;\n', '    }\n', '\n', '    /*** CONSTANTS ***/\n', '    string public constant NAME = "EtherIslands";\n', '    string public constant SYMBOL = "EIS";\n', '\n', '    bool public maintenance = true;\n', '    uint256 islands_count;\n', '\n', '    uint256 shipPrice = 0.01 ether;\n', '    uint256 withdrawalBlocksCooldown = 720;\n', '    uint256 battle_cooldown = 40;\n', '    address m_address = 0x9BB3364Baa5dbfcaa61ee0A79a9cA17359Fc7bBf;\n', '\n', '    mapping(address => uint256) private ownerCount;\n', '    mapping(uint256 => Island) private islands;\n', '    mapping(uint256 => IslandBattleStats) private islandBattleStats;\n', '\n', '    /*** DEFAULT METHODS ***/\n', '    function symbol() public pure returns (string) {return SYMBOL;}\n', '\n', '    function name() public pure returns (string) {return NAME;}\n', '\n', '    function implementsERC721() public pure returns (bool) {return true;}\n', '\n', '    function EtherIslands() public {\n', '    }\n', '\n', '    /** PUBLIC METHODS **/\n', '    function createIsland(bytes32 _name, uint256 _price, address _owner, uint256 _attack_ships_count, uint256 _defense_ships_count) public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        _create_island(_name, _owner, _price, 0, _attack_ships_count, _defense_ships_count);\n', '    }\n', '\n', '    function importIsland(bytes32 _name, address[3] _owners, uint256[7] _island_data, uint256[8] _island_battle_stats) public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        _import_island(_name, _owners, _island_data, _island_battle_stats);\n', '    }\n', '\n', '    function attackIsland(uint256 _attacker_id, uint256 _target_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage attackerIsland = islands[_attacker_id];\n', '        IslandBattleStats storage attackerIslandBattleStats = islandBattleStats[_attacker_id];\n', '\n', '        Island storage defenderIsland = islands[_target_id];\n', '        IslandBattleStats storage defenderIslandBattleStats = islandBattleStats[_target_id];\n', '\n', '        require(attackerIsland.owner == msg.sender);\n', '        require(attackerIsland.owner != defenderIsland.owner);\n', '        require(msg.sender != address(0));\n', '        require(msg.value == 0);\n', '        require(block.number >= attackerIslandBattleStats.attack_cooldown);\n', '        require(block.number >= defenderIslandBattleStats.defense_cooldown);\n', '        require(attackerIsland.attack_ships_count > 0); // attacker must have at least 1 attack ship\n', '        require(attackerIsland.attack_ships_count > defenderIsland.defense_ships_count);\n', '\n', '        uint256 goods_stolen = SafeMath.mul(SafeMath.div(defenderIsland.treasury, 100), 25);\n', '\n', '        defenderIsland.treasury = SafeMath.sub(defenderIsland.treasury, goods_stolen);\n', '\n', '        attackerIslandBattleStats.attacks_won++;\n', '        attackerIslandBattleStats.treasury_stolen = SafeMath.add(attackerIslandBattleStats.treasury_stolen, goods_stolen);\n', '\n', '        defenderIslandBattleStats.defenses_lost++;\n', '        defenderIslandBattleStats.treasury_lost = SafeMath.add(defenderIslandBattleStats.treasury_lost, goods_stolen);\n', '\n', '        uint256 cooldown_block = block.number + battle_cooldown;\n', '        attackerIslandBattleStats.attack_cooldown = cooldown_block;\n', '        defenderIslandBattleStats.defense_cooldown = cooldown_block;\n', '\n', '        uint256 goods_to_treasury = SafeMath.mul(SafeMath.div(goods_stolen, 100), 75);\n', '\n', '        attackerIsland.treasury = SafeMath.add(attackerIsland.treasury, goods_to_treasury);\n', '\n', '        // 2% of attacker army and 10% of defender army is destroyed\n', '        attackerIsland.attack_ships_count = SafeMath.sub(attackerIsland.attack_ships_count, SafeMath.mul(SafeMath.div(attackerIsland.attack_ships_count, 100), 2));\n', '        defenderIsland.defense_ships_count = SafeMath.sub(defenderIsland.defense_ships_count, SafeMath.mul(SafeMath.div(defenderIsland.defense_ships_count, 100), 10));\n', '\n', '        // Dividends\n', '        uint256 goods_for_current_owner = SafeMath.mul(SafeMath.div(goods_stolen, 100), 15);\n', '        uint256 goods_for_previous_owner_1 = SafeMath.mul(SafeMath.div(goods_stolen, 100), 6);\n', '        uint256 goods_for_previous_owner_2 = SafeMath.mul(SafeMath.div(goods_stolen, 100), 3);\n', '        uint256 goods_for_dev = SafeMath.mul(SafeMath.div(goods_stolen, 100), 1);\n', '\n', '        attackerIsland.owner.transfer(goods_for_current_owner);\n', '        attackerIsland.previous_owners[0].transfer(goods_for_previous_owner_1);\n', '        attackerIsland.previous_owners[1].transfer(goods_for_previous_owner_2);\n', '\n', '        //Split dev fee\n', '        m_address.transfer(SafeMath.mul(SafeMath.div(goods_for_dev, 100), 20));\n', '        owner.transfer(SafeMath.mul(SafeMath.div(goods_for_dev, 100), 80));\n', '\n', '        IslandAttacked(_attacker_id, _target_id, goods_stolen);\n', '    }\n', '\n', '    function buyShips(uint256 _island_id, uint256 _ships_to_buy, bool _is_attack_ships) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        uint256 totalPrice = SafeMath.mul(_ships_to_buy, shipPrice);\n', '        require(island.owner == msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(msg.value >= totalPrice);\n', '\n', '        if (_is_attack_ships) {\n', '            island.attack_ships_count = SafeMath.add(island.attack_ships_count, _ships_to_buy);\n', '        } else {\n', '            island.defense_ships_count = SafeMath.add(island.defense_ships_count, _ships_to_buy);\n', '        }\n', '\n', '        // Dividends\n', '        uint256 treasury_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 80);\n', '        uint256 dev_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 17);\n', '        uint256 previous_owner_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 2);\n', '        uint256 previous_owner2_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 1);\n', '\n', '        island.previous_owners[0].transfer(previous_owner_div);\n', '        //divs for 1st previous owner\n', '        island.previous_owners[1].transfer(previous_owner2_div);\n', '        //divs for 2nd previous owner\n', '        island.treasury = SafeMath.add(treasury_div, island.treasury);\n', '        // divs for treasury\n', '\n', '        //Split dev fee\n', '        uint256 m_fee = SafeMath.mul(SafeMath.div(dev_div, 100), 20);\n', '        uint256 d_fee = SafeMath.mul(SafeMath.div(dev_div, 100), 80);\n', '        m_address.transfer(m_fee);\n', '        owner.transfer(d_fee);\n', '\n', '        DividendsPaid(island.previous_owners[0], previous_owner_div, "buyShipPreviousOwner");\n', '        DividendsPaid(island.previous_owners[1], previous_owner2_div, "buyShipPreviousOwner2");\n', '\n', '        ShipsBought(_island_id, island.owner);\n', '    }\n', '\n', '    function withdrawTreasury(uint256 _island_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        require(island.owner == msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(island.treasury > 0);\n', '        require(block.number >= island.treasury_next_withdrawal_block);\n', '\n', '        uint256 treasury_to_withdraw = SafeMath.mul(SafeMath.div(island.treasury, 100), 10);\n', '        uint256 treasury_for_previous_owner_1 = SafeMath.mul(SafeMath.div(treasury_to_withdraw, 100), 2);\n', '        uint256 treasury_for_previous_owner_2 = SafeMath.mul(SafeMath.div(treasury_to_withdraw, 100), 1);\n', '        uint256 treasury_for_previous_owners = SafeMath.add(treasury_for_previous_owner_2, treasury_for_previous_owner_1);\n', '        uint256 treasury_for_current_owner = SafeMath.sub(treasury_to_withdraw, treasury_for_previous_owners);\n', '\n', '        island.owner.transfer(treasury_for_current_owner);\n', '        island.previous_owners[0].transfer(treasury_for_previous_owner_1);\n', '        island.previous_owners[1].transfer(treasury_for_previous_owner_2);\n', '\n', '        island.treasury = SafeMath.sub(island.treasury, treasury_to_withdraw);\n', '        island.treasury_next_withdrawal_block = block.number + withdrawalBlocksCooldown;\n', '        //setting cooldown for next withdrawal\n', '\n', '        DividendsPaid(island.previous_owners[0], treasury_for_previous_owner_1, "withdrawalPreviousOwner");\n', '        DividendsPaid(island.previous_owners[1], treasury_for_previous_owner_2, "withdrawalPreviousOwner2");\n', '        DividendsPaid(island.owner, treasury_for_current_owner, "withdrawalOwner");\n', '\n', '        TreasuryWithdrawn(_island_id);\n', '    }\n', '\n', '    function purchase(uint256 _island_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        require(island.owner != msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(msg.value >= island.price);\n', '\n', '        uint256 excess = SafeMath.sub(msg.value, island.price);\n', '        if (island.previous_price > 0) {\n', '            uint256 owners_cut = SafeMath.mul(SafeMath.div(island.price, 160), 130);\n', '            uint256 treasury_cut = SafeMath.mul(SafeMath.div(island.price, 160), 18);\n', '            uint256 dev_fee = SafeMath.mul(SafeMath.div(island.price, 160), 7);\n', '            uint256 previous_owner_fee = SafeMath.mul(SafeMath.div(island.price, 160), 3);\n', '            uint256 previous_owner_fee2 = SafeMath.mul(SafeMath.div(island.price, 160), 2);\n', '\n', '            island.previous_owners[0].transfer(previous_owner_fee);\n', '            //divs for 1st previous owner\n', '            island.previous_owners[1].transfer(previous_owner_fee2);\n', '            //divs for 2nd previous owner\n', '            island.treasury = SafeMath.add(treasury_cut, island.treasury);\n', '            // divs for treasury\n', '\n', '            //Split dev fee\n', '            uint256 m_fee = SafeMath.mul(SafeMath.div(dev_fee, 100), 20);\n', '            uint256 d_fee = SafeMath.mul(SafeMath.div(dev_fee, 100), 80);\n', '            m_address.transfer(m_fee);\n', '            owner.transfer(d_fee);\n', '\n', '            DividendsPaid(island.previous_owners[0], previous_owner_fee, "previousOwner");\n', '            DividendsPaid(island.previous_owners[1], previous_owner_fee2, "previousOwner2");\n', '            DividendsPaid(island.owner, owners_cut, "owner");\n', '            DividendsPaid(owner, dev_fee, "dev");\n', '\n', '            if (island.owner != address(this)) {\n', '                island.owner.transfer(owners_cut);\n', '                //divs for current island owner\n', '            }\n', '        }\n', '\n', '        island.previous_price = island.price;\n', '        island.treasury_next_withdrawal_block = block.number + withdrawalBlocksCooldown;\n', '        address _old_owner = island.owner;\n', '\n', '        island.price = SafeMath.mul(SafeMath.div(island.price, 100), 160);\n', '\n', '        //Change owners\n', '        island.previous_owners[1] = island.previous_owners[0];\n', '        island.previous_owners[0] = island.owner;\n', '        island.owner = msg.sender;\n', '        island.transactions_count++;\n', '\n', '        ownerCount[_old_owner] -= 1;\n', '        ownerCount[island.owner] += 1;\n', '\n', '        islandBattleStats[_island_id].attack_cooldown = block.number + battle_cooldown; // immunity for 10 mins\n', '        islandBattleStats[_island_id].defense_cooldown = block.number + battle_cooldown; // immunity for 10 mins\n', '\n', '        Transfer(_old_owner, island.owner, _island_id);\n', '        IslandSold(_island_id, island.previous_price, island.price, _old_owner, island.owner, island.name);\n', '\n', '        msg.sender.transfer(excess);\n', '        //returning excess\n', '    }\n', '\n', '    function onMaintenance() public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        maintenance = true;\n', '    }\n', '\n', '    function offMaintenance() public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        maintenance = false;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        return islands_count;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownerCount[_owner];\n', '    }\n', '\n', '    function priceOf(uint256 _island_id) public view returns (uint256 price) {\n', '        return islands[_island_id].price;\n', '    }\n', '\n', '    function getIslandBattleStats(uint256 _island_id) public view returns (\n', '        uint256 id,\n', '        uint256 attacks_won,\n', '        uint256 attacks_lost,\n', '        uint256 defenses_won,\n', '        uint256 defenses_lost,\n', '        uint256 treasury_stolen,\n', '        uint256 treasury_lost,\n', '        uint256 attack_cooldown,\n', '        uint256 defense_cooldown\n', '    ) {\n', '        id = _island_id;\n', '        attacks_won = islandBattleStats[_island_id].attacks_won;\n', '        attacks_lost = islandBattleStats[_island_id].attacks_lost;\n', '        defenses_won = islandBattleStats[_island_id].defenses_won;\n', '        defenses_lost = islandBattleStats[_island_id].defenses_lost;\n', '        treasury_stolen = islandBattleStats[_island_id].treasury_stolen;\n', '        treasury_lost = islandBattleStats[_island_id].treasury_lost;\n', '        attack_cooldown = islandBattleStats[_island_id].attack_cooldown;\n', '        defense_cooldown = islandBattleStats[_island_id].defense_cooldown;\n', '    }\n', '\n', '    function getIsland(uint256 _island_id) public view returns (\n', '        uint256 id,\n', '        bytes32 island_name,\n', '        address owner,\n', '        uint256 price,\n', '        uint256 treasury,\n', '        uint256 treasury_next_withdrawal_block,\n', '        uint256 previous_price,\n', '        uint256 attack_ships_count,\n', '        uint256 defense_ships_count,\n', '        uint256 transactions_count\n', '    ) {\n', '        id = _island_id;\n', '        island_name = islands[_island_id].name;\n', '        owner = islands[_island_id].owner;\n', '        price = islands[_island_id].price;\n', '        treasury = islands[_island_id].treasury;\n', '        treasury_next_withdrawal_block = islands[_island_id].treasury_next_withdrawal_block;\n', '        previous_price = islands[_island_id].previous_price;\n', '        attack_ships_count = islands[_island_id].attack_ships_count;\n', '        defense_ships_count = islands[_island_id].defense_ships_count;\n', '        transactions_count = islands[_island_id].transactions_count;\n', '    }\n', '\n', '    function getIslandPreviousOwners(uint256 _island_id) public view returns (\n', '        address[2] previous_owners\n', '    ) {\n', '        previous_owners = islands[_island_id].previous_owners;\n', '    }\n', '\n', '    function getIslands() public view returns (uint256[], address[], uint256[], uint256[], uint256[], uint256[], uint256[]) {\n', '        uint256[] memory ids = new uint256[](islands_count);\n', '        address[] memory owners = new address[](islands_count);\n', '        uint256[] memory prices = new uint256[](islands_count);\n', '        uint256[] memory treasuries = new uint256[](islands_count);\n', '        uint256[] memory attack_ships_counts = new uint256[](islands_count);\n', '        uint256[] memory defense_ships_counts = new uint256[](islands_count);\n', '        uint256[] memory transactions_count = new uint256[](islands_count);\n', '        for (uint256 _id = 0; _id < islands_count; _id++) {\n', '            ids[_id] = _id;\n', '            owners[_id] = islands[_id].owner;\n', '            prices[_id] = islands[_id].price;\n', '            treasuries[_id] = islands[_id].treasury;\n', '            attack_ships_counts[_id] = islands[_id].attack_ships_count;\n', '            defense_ships_counts[_id] = islands[_id].defense_ships_count;\n', '            transactions_count[_id] = islands[_id].transactions_count;\n', '        }\n', '        return (ids, owners, prices, treasuries, attack_ships_counts, defense_ships_counts, transactions_count);\n', '    }\n', '\n', '    /** PRIVATE METHODS **/\n', '    function _create_island(bytes32 _name, address _owner, uint256 _price, uint256 _previous_price, uint256 _attack_ships_count, uint256 _defense_ships_count) private {\n', '        islands[islands_count] = Island({\n', '            name : _name,\n', '            owner : _owner,\n', '            price : _price,\n', '            treasury : 0,\n', '            treasury_next_withdrawal_block : 0,\n', '            previous_price : _previous_price,\n', '            attack_ships_count : _attack_ships_count,\n', '            defense_ships_count : _defense_ships_count,\n', '            transactions_count : 0,\n', '            approve_transfer_to : address(0),\n', '            previous_owners : [_owner, _owner]\n', '            });\n', '\n', '        islandBattleStats[islands_count] = IslandBattleStats({\n', '            attacks_won : 0,\n', '            attacks_lost : 0,\n', '            defenses_won : 0,\n', '            defenses_lost : 0,\n', '            treasury_stolen : 0,\n', '            treasury_lost : 0,\n', '            attack_cooldown : 0,\n', '            defense_cooldown : 0\n', '            });\n', '\n', '        NewIsland(islands_count, _name, _owner);\n', '        Transfer(address(this), _owner, islands_count);\n', '        islands_count++;\n', '    }\n', '\n', '    function _import_island(bytes32 _name, address[3] _owners, uint256[7] _island_data, uint256[8] _island_battle_stats) private {\n', '        islands[islands_count] = Island({\n', '            name : _name,\n', '            owner : _owners[0],\n', '            price : _island_data[0],\n', '            treasury : _island_data[1],\n', '            treasury_next_withdrawal_block : _island_data[2],\n', '            previous_price : _island_data[3],\n', '            attack_ships_count : _island_data[4],\n', '            defense_ships_count : _island_data[5],\n', '            transactions_count : _island_data[6],\n', '            approve_transfer_to : address(0),\n', '            previous_owners : [_owners[1], _owners[2]]\n', '            });\n', '\n', '        islandBattleStats[islands_count] = IslandBattleStats({\n', '            attacks_won : _island_battle_stats[0],\n', '            attacks_lost : _island_battle_stats[1],\n', '            defenses_won : _island_battle_stats[2],\n', '            defenses_lost : _island_battle_stats[3],\n', '            treasury_stolen : _island_battle_stats[4],\n', '            treasury_lost : _island_battle_stats[5],\n', '            attack_cooldown : _island_battle_stats[6],\n', '            defense_cooldown : _island_battle_stats[7]\n', '            });\n', '\n', '        NewIsland(islands_count, _name, _owners[0]);\n', '        Transfer(address(this), _owners[0], islands_count);\n', '        islands_count++;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _island_id) private {\n', '        islands[_island_id].owner = _to;\n', '        islands[_island_id].approve_transfer_to = address(0);\n', '        ownerCount[_from] -= 1;\n', '        ownerCount[_to] += 1;\n', '        Transfer(_from, _to, _island_id);\n', '    }\n', '\n', '    /*** ERC-721 compliance. ***/\n', '    function approve(address _to, uint256 _island_id) public {\n', '        require(msg.sender == islands[_island_id].owner);\n', '        islands[_island_id].approve_transfer_to = _to;\n', '        Approval(msg.sender, _to, _island_id);\n', '    }\n', '\n', '    function ownerOf(uint256 _island_id) public view returns (address owner){\n', '        owner = islands[_island_id].owner;\n', '        require(owner != address(0));\n', '    }\n', '\n', '    function takeOwnership(uint256 _island_id) public {\n', '        address oldOwner = islands[_island_id].owner;\n', '        require(msg.sender != address(0));\n', '        require(islands[_island_id].approve_transfer_to == msg.sender);\n', '        _transfer(oldOwner, msg.sender, _island_id);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _island_id) public {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender == islands[_island_id].owner);\n', '        _transfer(msg.sender, _to, _island_id);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _island_id) public {\n', '        require(_from == islands[_island_id].owner);\n', '        require(islands[_island_id].approve_transfer_to == _to);\n', '        require(_to != address(0));\n', '        _transfer(_from, _to, _island_id);\n', '    }\n', '\n', '    function upgradeContract(address _newContract) public onlyOwner {\n', '        _newContract.transfer(this.balance);\n', '    }\n', '\n', '    function AddEth () public payable {}\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function takeOwnership(uint256 _tokenId) public;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EtherIslands is Ownable, ERC721 {\n', '    using SafeMath for uint256;\n', '\n', '    /*** EVENTS ***/\n', '    event NewIsland(uint256 tokenId, bytes32 name, address owner);\n', '    event IslandSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event DividendsPaid(address to, uint256 amount, bytes32 divType);\n', '    event ShipsBought(uint256 tokenId, address owner);\n', '    event IslandAttacked(uint256 attackerId, uint256 targetId, uint256 treasuryStolen);\n', '    event TreasuryWithdrawn(uint256 tokenId);\n', '\n', '    /*** STRUCTS ***/\n', '    struct Island {\n', '        bytes32 name;\n', '        address owner;\n', '        uint256 price;\n', '        uint256 treasury;\n', '        uint256 treasury_next_withdrawal_block;\n', '        uint256 previous_price;\n', '        uint256 attack_ships_count;\n', '        uint256 defense_ships_count;\n', '        uint256 transactions_count;\n', '        address approve_transfer_to;\n', '        address[2] previous_owners;\n', '    }\n', '\n', '    struct IslandBattleStats {\n', '        uint256 attacks_won;\n', '        uint256 attacks_lost;\n', '        uint256 defenses_won;\n', '        uint256 defenses_lost;\n', '        uint256 treasury_stolen;\n', '        uint256 treasury_lost;\n', '        uint256 attack_cooldown;\n', '        uint256 defense_cooldown;\n', '    }\n', '\n', '    /*** CONSTANTS ***/\n', '    string public constant NAME = "EtherIslands";\n', '    string public constant SYMBOL = "EIS";\n', '\n', '    bool public maintenance = true;\n', '    uint256 islands_count;\n', '\n', '    uint256 shipPrice = 0.01 ether;\n', '    uint256 withdrawalBlocksCooldown = 720;\n', '    uint256 battle_cooldown = 40;\n', '    address m_address = 0x9BB3364Baa5dbfcaa61ee0A79a9cA17359Fc7bBf;\n', '\n', '    mapping(address => uint256) private ownerCount;\n', '    mapping(uint256 => Island) private islands;\n', '    mapping(uint256 => IslandBattleStats) private islandBattleStats;\n', '\n', '    /*** DEFAULT METHODS ***/\n', '    function symbol() public pure returns (string) {return SYMBOL;}\n', '\n', '    function name() public pure returns (string) {return NAME;}\n', '\n', '    function implementsERC721() public pure returns (bool) {return true;}\n', '\n', '    function EtherIslands() public {\n', '    }\n', '\n', '    /** PUBLIC METHODS **/\n', '    function createIsland(bytes32 _name, uint256 _price, address _owner, uint256 _attack_ships_count, uint256 _defense_ships_count) public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        _create_island(_name, _owner, _price, 0, _attack_ships_count, _defense_ships_count);\n', '    }\n', '\n', '    function importIsland(bytes32 _name, address[3] _owners, uint256[7] _island_data, uint256[8] _island_battle_stats) public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        _import_island(_name, _owners, _island_data, _island_battle_stats);\n', '    }\n', '\n', '    function attackIsland(uint256 _attacker_id, uint256 _target_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage attackerIsland = islands[_attacker_id];\n', '        IslandBattleStats storage attackerIslandBattleStats = islandBattleStats[_attacker_id];\n', '\n', '        Island storage defenderIsland = islands[_target_id];\n', '        IslandBattleStats storage defenderIslandBattleStats = islandBattleStats[_target_id];\n', '\n', '        require(attackerIsland.owner == msg.sender);\n', '        require(attackerIsland.owner != defenderIsland.owner);\n', '        require(msg.sender != address(0));\n', '        require(msg.value == 0);\n', '        require(block.number >= attackerIslandBattleStats.attack_cooldown);\n', '        require(block.number >= defenderIslandBattleStats.defense_cooldown);\n', '        require(attackerIsland.attack_ships_count > 0); // attacker must have at least 1 attack ship\n', '        require(attackerIsland.attack_ships_count > defenderIsland.defense_ships_count);\n', '\n', '        uint256 goods_stolen = SafeMath.mul(SafeMath.div(defenderIsland.treasury, 100), 25);\n', '\n', '        defenderIsland.treasury = SafeMath.sub(defenderIsland.treasury, goods_stolen);\n', '\n', '        attackerIslandBattleStats.attacks_won++;\n', '        attackerIslandBattleStats.treasury_stolen = SafeMath.add(attackerIslandBattleStats.treasury_stolen, goods_stolen);\n', '\n', '        defenderIslandBattleStats.defenses_lost++;\n', '        defenderIslandBattleStats.treasury_lost = SafeMath.add(defenderIslandBattleStats.treasury_lost, goods_stolen);\n', '\n', '        uint256 cooldown_block = block.number + battle_cooldown;\n', '        attackerIslandBattleStats.attack_cooldown = cooldown_block;\n', '        defenderIslandBattleStats.defense_cooldown = cooldown_block;\n', '\n', '        uint256 goods_to_treasury = SafeMath.mul(SafeMath.div(goods_stolen, 100), 75);\n', '\n', '        attackerIsland.treasury = SafeMath.add(attackerIsland.treasury, goods_to_treasury);\n', '\n', '        // 2% of attacker army and 10% of defender army is destroyed\n', '        attackerIsland.attack_ships_count = SafeMath.sub(attackerIsland.attack_ships_count, SafeMath.mul(SafeMath.div(attackerIsland.attack_ships_count, 100), 2));\n', '        defenderIsland.defense_ships_count = SafeMath.sub(defenderIsland.defense_ships_count, SafeMath.mul(SafeMath.div(defenderIsland.defense_ships_count, 100), 10));\n', '\n', '        // Dividends\n', '        uint256 goods_for_current_owner = SafeMath.mul(SafeMath.div(goods_stolen, 100), 15);\n', '        uint256 goods_for_previous_owner_1 = SafeMath.mul(SafeMath.div(goods_stolen, 100), 6);\n', '        uint256 goods_for_previous_owner_2 = SafeMath.mul(SafeMath.div(goods_stolen, 100), 3);\n', '        uint256 goods_for_dev = SafeMath.mul(SafeMath.div(goods_stolen, 100), 1);\n', '\n', '        attackerIsland.owner.transfer(goods_for_current_owner);\n', '        attackerIsland.previous_owners[0].transfer(goods_for_previous_owner_1);\n', '        attackerIsland.previous_owners[1].transfer(goods_for_previous_owner_2);\n', '\n', '        //Split dev fee\n', '        m_address.transfer(SafeMath.mul(SafeMath.div(goods_for_dev, 100), 20));\n', '        owner.transfer(SafeMath.mul(SafeMath.div(goods_for_dev, 100), 80));\n', '\n', '        IslandAttacked(_attacker_id, _target_id, goods_stolen);\n', '    }\n', '\n', '    function buyShips(uint256 _island_id, uint256 _ships_to_buy, bool _is_attack_ships) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        uint256 totalPrice = SafeMath.mul(_ships_to_buy, shipPrice);\n', '        require(island.owner == msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(msg.value >= totalPrice);\n', '\n', '        if (_is_attack_ships) {\n', '            island.attack_ships_count = SafeMath.add(island.attack_ships_count, _ships_to_buy);\n', '        } else {\n', '            island.defense_ships_count = SafeMath.add(island.defense_ships_count, _ships_to_buy);\n', '        }\n', '\n', '        // Dividends\n', '        uint256 treasury_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 80);\n', '        uint256 dev_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 17);\n', '        uint256 previous_owner_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 2);\n', '        uint256 previous_owner2_div = SafeMath.mul(SafeMath.div(totalPrice, 100), 1);\n', '\n', '        island.previous_owners[0].transfer(previous_owner_div);\n', '        //divs for 1st previous owner\n', '        island.previous_owners[1].transfer(previous_owner2_div);\n', '        //divs for 2nd previous owner\n', '        island.treasury = SafeMath.add(treasury_div, island.treasury);\n', '        // divs for treasury\n', '\n', '        //Split dev fee\n', '        uint256 m_fee = SafeMath.mul(SafeMath.div(dev_div, 100), 20);\n', '        uint256 d_fee = SafeMath.mul(SafeMath.div(dev_div, 100), 80);\n', '        m_address.transfer(m_fee);\n', '        owner.transfer(d_fee);\n', '\n', '        DividendsPaid(island.previous_owners[0], previous_owner_div, "buyShipPreviousOwner");\n', '        DividendsPaid(island.previous_owners[1], previous_owner2_div, "buyShipPreviousOwner2");\n', '\n', '        ShipsBought(_island_id, island.owner);\n', '    }\n', '\n', '    function withdrawTreasury(uint256 _island_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        require(island.owner == msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(island.treasury > 0);\n', '        require(block.number >= island.treasury_next_withdrawal_block);\n', '\n', '        uint256 treasury_to_withdraw = SafeMath.mul(SafeMath.div(island.treasury, 100), 10);\n', '        uint256 treasury_for_previous_owner_1 = SafeMath.mul(SafeMath.div(treasury_to_withdraw, 100), 2);\n', '        uint256 treasury_for_previous_owner_2 = SafeMath.mul(SafeMath.div(treasury_to_withdraw, 100), 1);\n', '        uint256 treasury_for_previous_owners = SafeMath.add(treasury_for_previous_owner_2, treasury_for_previous_owner_1);\n', '        uint256 treasury_for_current_owner = SafeMath.sub(treasury_to_withdraw, treasury_for_previous_owners);\n', '\n', '        island.owner.transfer(treasury_for_current_owner);\n', '        island.previous_owners[0].transfer(treasury_for_previous_owner_1);\n', '        island.previous_owners[1].transfer(treasury_for_previous_owner_2);\n', '\n', '        island.treasury = SafeMath.sub(island.treasury, treasury_to_withdraw);\n', '        island.treasury_next_withdrawal_block = block.number + withdrawalBlocksCooldown;\n', '        //setting cooldown for next withdrawal\n', '\n', '        DividendsPaid(island.previous_owners[0], treasury_for_previous_owner_1, "withdrawalPreviousOwner");\n', '        DividendsPaid(island.previous_owners[1], treasury_for_previous_owner_2, "withdrawalPreviousOwner2");\n', '        DividendsPaid(island.owner, treasury_for_current_owner, "withdrawalOwner");\n', '\n', '        TreasuryWithdrawn(_island_id);\n', '    }\n', '\n', '    function purchase(uint256 _island_id) public payable {\n', '        require(maintenance == false);\n', '        Island storage island = islands[_island_id];\n', '\n', '        require(island.owner != msg.sender);\n', '        require(msg.sender != address(0));\n', '        require(msg.value >= island.price);\n', '\n', '        uint256 excess = SafeMath.sub(msg.value, island.price);\n', '        if (island.previous_price > 0) {\n', '            uint256 owners_cut = SafeMath.mul(SafeMath.div(island.price, 160), 130);\n', '            uint256 treasury_cut = SafeMath.mul(SafeMath.div(island.price, 160), 18);\n', '            uint256 dev_fee = SafeMath.mul(SafeMath.div(island.price, 160), 7);\n', '            uint256 previous_owner_fee = SafeMath.mul(SafeMath.div(island.price, 160), 3);\n', '            uint256 previous_owner_fee2 = SafeMath.mul(SafeMath.div(island.price, 160), 2);\n', '\n', '            island.previous_owners[0].transfer(previous_owner_fee);\n', '            //divs for 1st previous owner\n', '            island.previous_owners[1].transfer(previous_owner_fee2);\n', '            //divs for 2nd previous owner\n', '            island.treasury = SafeMath.add(treasury_cut, island.treasury);\n', '            // divs for treasury\n', '\n', '            //Split dev fee\n', '            uint256 m_fee = SafeMath.mul(SafeMath.div(dev_fee, 100), 20);\n', '            uint256 d_fee = SafeMath.mul(SafeMath.div(dev_fee, 100), 80);\n', '            m_address.transfer(m_fee);\n', '            owner.transfer(d_fee);\n', '\n', '            DividendsPaid(island.previous_owners[0], previous_owner_fee, "previousOwner");\n', '            DividendsPaid(island.previous_owners[1], previous_owner_fee2, "previousOwner2");\n', '            DividendsPaid(island.owner, owners_cut, "owner");\n', '            DividendsPaid(owner, dev_fee, "dev");\n', '\n', '            if (island.owner != address(this)) {\n', '                island.owner.transfer(owners_cut);\n', '                //divs for current island owner\n', '            }\n', '        }\n', '\n', '        island.previous_price = island.price;\n', '        island.treasury_next_withdrawal_block = block.number + withdrawalBlocksCooldown;\n', '        address _old_owner = island.owner;\n', '\n', '        island.price = SafeMath.mul(SafeMath.div(island.price, 100), 160);\n', '\n', '        //Change owners\n', '        island.previous_owners[1] = island.previous_owners[0];\n', '        island.previous_owners[0] = island.owner;\n', '        island.owner = msg.sender;\n', '        island.transactions_count++;\n', '\n', '        ownerCount[_old_owner] -= 1;\n', '        ownerCount[island.owner] += 1;\n', '\n', '        islandBattleStats[_island_id].attack_cooldown = block.number + battle_cooldown; // immunity for 10 mins\n', '        islandBattleStats[_island_id].defense_cooldown = block.number + battle_cooldown; // immunity for 10 mins\n', '\n', '        Transfer(_old_owner, island.owner, _island_id);\n', '        IslandSold(_island_id, island.previous_price, island.price, _old_owner, island.owner, island.name);\n', '\n', '        msg.sender.transfer(excess);\n', '        //returning excess\n', '    }\n', '\n', '    function onMaintenance() public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        maintenance = true;\n', '    }\n', '\n', '    function offMaintenance() public onlyOwner {\n', '        require(msg.sender != address(0));\n', '        maintenance = false;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total) {\n', '        return islands_count;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownerCount[_owner];\n', '    }\n', '\n', '    function priceOf(uint256 _island_id) public view returns (uint256 price) {\n', '        return islands[_island_id].price;\n', '    }\n', '\n', '    function getIslandBattleStats(uint256 _island_id) public view returns (\n', '        uint256 id,\n', '        uint256 attacks_won,\n', '        uint256 attacks_lost,\n', '        uint256 defenses_won,\n', '        uint256 defenses_lost,\n', '        uint256 treasury_stolen,\n', '        uint256 treasury_lost,\n', '        uint256 attack_cooldown,\n', '        uint256 defense_cooldown\n', '    ) {\n', '        id = _island_id;\n', '        attacks_won = islandBattleStats[_island_id].attacks_won;\n', '        attacks_lost = islandBattleStats[_island_id].attacks_lost;\n', '        defenses_won = islandBattleStats[_island_id].defenses_won;\n', '        defenses_lost = islandBattleStats[_island_id].defenses_lost;\n', '        treasury_stolen = islandBattleStats[_island_id].treasury_stolen;\n', '        treasury_lost = islandBattleStats[_island_id].treasury_lost;\n', '        attack_cooldown = islandBattleStats[_island_id].attack_cooldown;\n', '        defense_cooldown = islandBattleStats[_island_id].defense_cooldown;\n', '    }\n', '\n', '    function getIsland(uint256 _island_id) public view returns (\n', '        uint256 id,\n', '        bytes32 island_name,\n', '        address owner,\n', '        uint256 price,\n', '        uint256 treasury,\n', '        uint256 treasury_next_withdrawal_block,\n', '        uint256 previous_price,\n', '        uint256 attack_ships_count,\n', '        uint256 defense_ships_count,\n', '        uint256 transactions_count\n', '    ) {\n', '        id = _island_id;\n', '        island_name = islands[_island_id].name;\n', '        owner = islands[_island_id].owner;\n', '        price = islands[_island_id].price;\n', '        treasury = islands[_island_id].treasury;\n', '        treasury_next_withdrawal_block = islands[_island_id].treasury_next_withdrawal_block;\n', '        previous_price = islands[_island_id].previous_price;\n', '        attack_ships_count = islands[_island_id].attack_ships_count;\n', '        defense_ships_count = islands[_island_id].defense_ships_count;\n', '        transactions_count = islands[_island_id].transactions_count;\n', '    }\n', '\n', '    function getIslandPreviousOwners(uint256 _island_id) public view returns (\n', '        address[2] previous_owners\n', '    ) {\n', '        previous_owners = islands[_island_id].previous_owners;\n', '    }\n', '\n', '    function getIslands() public view returns (uint256[], address[], uint256[], uint256[], uint256[], uint256[], uint256[]) {\n', '        uint256[] memory ids = new uint256[](islands_count);\n', '        address[] memory owners = new address[](islands_count);\n', '        uint256[] memory prices = new uint256[](islands_count);\n', '        uint256[] memory treasuries = new uint256[](islands_count);\n', '        uint256[] memory attack_ships_counts = new uint256[](islands_count);\n', '        uint256[] memory defense_ships_counts = new uint256[](islands_count);\n', '        uint256[] memory transactions_count = new uint256[](islands_count);\n', '        for (uint256 _id = 0; _id < islands_count; _id++) {\n', '            ids[_id] = _id;\n', '            owners[_id] = islands[_id].owner;\n', '            prices[_id] = islands[_id].price;\n', '            treasuries[_id] = islands[_id].treasury;\n', '            attack_ships_counts[_id] = islands[_id].attack_ships_count;\n', '            defense_ships_counts[_id] = islands[_id].defense_ships_count;\n', '            transactions_count[_id] = islands[_id].transactions_count;\n', '        }\n', '        return (ids, owners, prices, treasuries, attack_ships_counts, defense_ships_counts, transactions_count);\n', '    }\n', '\n', '    /** PRIVATE METHODS **/\n', '    function _create_island(bytes32 _name, address _owner, uint256 _price, uint256 _previous_price, uint256 _attack_ships_count, uint256 _defense_ships_count) private {\n', '        islands[islands_count] = Island({\n', '            name : _name,\n', '            owner : _owner,\n', '            price : _price,\n', '            treasury : 0,\n', '            treasury_next_withdrawal_block : 0,\n', '            previous_price : _previous_price,\n', '            attack_ships_count : _attack_ships_count,\n', '            defense_ships_count : _defense_ships_count,\n', '            transactions_count : 0,\n', '            approve_transfer_to : address(0),\n', '            previous_owners : [_owner, _owner]\n', '            });\n', '\n', '        islandBattleStats[islands_count] = IslandBattleStats({\n', '            attacks_won : 0,\n', '            attacks_lost : 0,\n', '            defenses_won : 0,\n', '            defenses_lost : 0,\n', '            treasury_stolen : 0,\n', '            treasury_lost : 0,\n', '            attack_cooldown : 0,\n', '            defense_cooldown : 0\n', '            });\n', '\n', '        NewIsland(islands_count, _name, _owner);\n', '        Transfer(address(this), _owner, islands_count);\n', '        islands_count++;\n', '    }\n', '\n', '    function _import_island(bytes32 _name, address[3] _owners, uint256[7] _island_data, uint256[8] _island_battle_stats) private {\n', '        islands[islands_count] = Island({\n', '            name : _name,\n', '            owner : _owners[0],\n', '            price : _island_data[0],\n', '            treasury : _island_data[1],\n', '            treasury_next_withdrawal_block : _island_data[2],\n', '            previous_price : _island_data[3],\n', '            attack_ships_count : _island_data[4],\n', '            defense_ships_count : _island_data[5],\n', '            transactions_count : _island_data[6],\n', '            approve_transfer_to : address(0),\n', '            previous_owners : [_owners[1], _owners[2]]\n', '            });\n', '\n', '        islandBattleStats[islands_count] = IslandBattleStats({\n', '            attacks_won : _island_battle_stats[0],\n', '            attacks_lost : _island_battle_stats[1],\n', '            defenses_won : _island_battle_stats[2],\n', '            defenses_lost : _island_battle_stats[3],\n', '            treasury_stolen : _island_battle_stats[4],\n', '            treasury_lost : _island_battle_stats[5],\n', '            attack_cooldown : _island_battle_stats[6],\n', '            defense_cooldown : _island_battle_stats[7]\n', '            });\n', '\n', '        NewIsland(islands_count, _name, _owners[0]);\n', '        Transfer(address(this), _owners[0], islands_count);\n', '        islands_count++;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _island_id) private {\n', '        islands[_island_id].owner = _to;\n', '        islands[_island_id].approve_transfer_to = address(0);\n', '        ownerCount[_from] -= 1;\n', '        ownerCount[_to] += 1;\n', '        Transfer(_from, _to, _island_id);\n', '    }\n', '\n', '    /*** ERC-721 compliance. ***/\n', '    function approve(address _to, uint256 _island_id) public {\n', '        require(msg.sender == islands[_island_id].owner);\n', '        islands[_island_id].approve_transfer_to = _to;\n', '        Approval(msg.sender, _to, _island_id);\n', '    }\n', '\n', '    function ownerOf(uint256 _island_id) public view returns (address owner){\n', '        owner = islands[_island_id].owner;\n', '        require(owner != address(0));\n', '    }\n', '\n', '    function takeOwnership(uint256 _island_id) public {\n', '        address oldOwner = islands[_island_id].owner;\n', '        require(msg.sender != address(0));\n', '        require(islands[_island_id].approve_transfer_to == msg.sender);\n', '        _transfer(oldOwner, msg.sender, _island_id);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _island_id) public {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender == islands[_island_id].owner);\n', '        _transfer(msg.sender, _to, _island_id);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _island_id) public {\n', '        require(_from == islands[_island_id].owner);\n', '        require(islands[_island_id].approve_transfer_to == _to);\n', '        require(_to != address(0));\n', '        _transfer(_from, _to, _island_id);\n', '    }\n', '\n', '    function upgradeContract(address _newContract) public onlyOwner {\n', '        _newContract.transfer(this.balance);\n', '    }\n', '\n', '    function AddEth () public payable {}\n', '}']
