['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract _8thereum {\n', '\n', '\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyTokenHolders() \n', '    {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with profits\n', '    modifier onlyDividendPositive() \n', '    {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '    // only owner\n', '    modifier onlyOwner() \n', '    { \n', '        require (address(msg.sender) == owner); \n', '        _; \n', '    }\n', '    \n', '    // only non-whales\n', '    modifier onlyNonOwner() \n', '    { \n', '        require (address(msg.sender) != owner); \n', '        _; \n', '    }\n', '    \n', '    modifier onlyFoundersIfNotPublic() \n', '    {\n', '        if(!openToThePublic)\n', '        {\n', '            require (founders[address(msg.sender)] == true);   \n', '        }\n', '        _;\n', '    }    \n', '    \n', '    modifier onlyApprovedContracts()\n', '    {\n', '        if(!gameList[msg.sender])\n', '        {\n', '            require (msg.sender == tx.origin);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '    \n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    event lotteryPayout(\n', '        address customerAddress, \n', '        uint256 lotterySupply\n', '    );\n', '    \n', '    event whaleDump(\n', '        uint256 amount\n', '    );\n', '    \n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "8thereum";\n', '    string public symbol = "BIT";\n', '    bool public openToThePublic = false;\n', '    address public owner;\n', '    uint8 constant public decimals = 18;\n', '    uint8 constant internal dividendFee = 15;\n', '    uint256 constant internal tokenPrice = 500000000000000;//0.0005 ether\n', '    uint256 constant internal magnitude = 2**64;\n', '    uint256 constant public referralLinkRequirement = 5e18;// 5 token minimum for referral link\n', '    \n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    mapping(address => bool) internal gameList;\n', '    mapping(address => uint256) internal publicTokenLedger;\n', '    mapping(address => uint256) public   whaleLedger;\n', '    mapping(address => uint256) public   gameLedger;\n', '    mapping(address => uint256) internal referralBalances;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => mapping(address => uint256)) public gamePlayers;\n', '    mapping(address => bool) internal founders;\n', '    address[] lotteryPlayers;\n', '    uint256 internal lotterySupply = 0;\n', '    uint256 internal tokenSupply = 0;\n', '    uint256 internal gameSuppply = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    constructor()\n', '        public\n', '    {\n', '        // no admin, but the owner of the contract is the address used for whale\n', '        owner = address(msg.sender);\n', '\n', '        // add founders here... Founders don&#39;t get any special priveledges except being first in line at launch day\n', '        founders[owner] = true; //owner&#39;s address\n', '        founders[0x7e474fe5Cfb720804860215f407111183cbc2f85] = true; //KENNY\n', '        founders[0x5138240E96360ad64010C27eB0c685A8b2eDE4F2] = true; //crypt0b!t \n', '        founders[0xAA7A7C2DECB180f68F11E975e6D92B5Dc06083A6] = true; //NumberOfThings \n', '        founders[0x6DC622a04Fd13B6a1C3C5B229CA642b8e50e1e74] = true; //supermanlxvi\n', '        founders[0x41a21b264F9ebF6cF571D4543a5b3AB1c6bEd98C] = true; //Ravi\n', '    }\n', '    \n', '     \n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\n', '     */\n', '    function buy(address referredyBy)\n', '        onlyFoundersIfNotPublic()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        excludeWhale(referredyBy); \n', '    }\n', '    \n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     */\n', '    function()\n', '        onlyFoundersIfNotPublic()\n', '        payable\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        excludeWhale(0x0); \n', '    }\n', '    \n', '    /**\n', '     * Converts all of caller&#39;s dividends to tokens.\n', '     */\n', '    function reinvest()\n', '        onlyDividendPositive()\n', '        onlyNonOwner()\n', '        public\n', '    {   \n', '        \n', '        require (msg.sender == tx.origin);\n', '        \n', '        // fetch dividends\n', '        uint256 dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '        \n', '        // pay out the dividends virtually\n', '        address customerAddress = msg.sender;\n', '        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\n', '        \n', '        // retrieve ref. bonus\n', '        dividends += referralBalances[customerAddress];\n', '        referralBalances[customerAddress] = 0;\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(dividends, 0x0);\n', '        \n', '        // fire event for logging \n', '        emit onReinvestment(customerAddress, dividends, _tokens);\n', '    }\n', '    \n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit()\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // get token count for caller & sell them all\n', '        address customerAddress = address(msg.sender);\n', '        uint256 _tokens = publicTokenLedger[customerAddress];\n', '        \n', '        if(_tokens > 0) \n', '        {\n', '            sell(_tokens);\n', '        }\n', '\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        onlyNonOwner()\n', '        onlyDividendPositive()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        uint256 dividends = myDividends(false); // get ref. bonus later in the code\n', '        \n', '        // update dividend tracker\n', '        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\n', '        \n', '        // add ref. bonus\n', '        dividends += referralBalances[customerAddress];\n', '        referralBalances[customerAddress] = 0;\n', '        \n', '        customerAddress.transfer(dividends);\n', '        \n', '        // fire event for logging \n', '        emit onWithdraw(customerAddress, dividends);\n', '    }\n', '    \n', '    /**\n', '     * Liquifies tokens to ethereum.\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0));\n', '\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 ethereum = tokensToEthereum_(_tokens);\n', '        uint256 dividends = (ethereum * dividendFee) / 100;\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        \n', '        //Take some divs for the lottery and whale\n', '        uint256 lotteryAndWhaleFee = dividends / 3;\n', '        dividends -= lotteryAndWhaleFee;\n', '        \n', '        //figure out the lotteryFee\n', '        uint256 lotteryFee = lotteryAndWhaleFee / 2;\n', '        //add tokens to the whale\n', '        uint256 whaleFee = lotteryAndWhaleFee - lotteryFee;\n', '        whaleLedger[owner] += whaleFee;\n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryFee);\n', '        // burn the sold tokens\n', '        tokenSupply -=  _tokens;\n', '        publicTokenLedger[msg.sender] -= _tokens;\n', '        \n', '        \n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (taxedEthereum * magnitude));\n', '        payoutsTo_[msg.sender] -= _updatedPayouts;  \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply > 0) \n', '        {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (dividends * magnitude) / tokenSupply);\n', '        }\n', '        \n', '        // fire event for logging \n', '        emit onTokenSell(msg.sender, _tokens, taxedEthereum);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        onlyApprovedContracts()\n', '        public\n', '        returns(bool)\n', '    {\n', '        assert(_toAddress != owner);\n', '        \n', '        // setup\n', '        if(gameList[msg.sender] == true) //If game is transferring tokens\n', '        {\n', '            require((_amountOfTokens <= gameLedger[msg.sender]) && (_amountOfTokens > 0 ));\n', '             // exchange tokens\n', '            gameLedger[msg.sender] -= _amountOfTokens;\n', '            gameSuppply -= _amountOfTokens;\n', '            publicTokenLedger[_toAddress] += _amountOfTokens; \n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \n', '        }\n', '        else if (gameList[_toAddress] == true) //If customer transferring tokens to game\n', '        {\n', '            // make sure we have the requested tokens\n', '            //each game should only cost one token to play\n', '            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 && (_amountOfTokens == 1e18)));\n', '             \n', '             // exchange tokens\n', '            publicTokenLedger[msg.sender] -=  _amountOfTokens;\n', '            gameLedger[_toAddress] += _amountOfTokens; \n', '            gameSuppply += _amountOfTokens;\n', '            gamePlayers[_toAddress][msg.sender] += _amountOfTokens;\n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\n', '        }\n', '        else{\n', '            // make sure we have the requested tokens\n', '            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 ));\n', '                // exchange tokens\n', '            publicTokenLedger[msg.sender] -= _amountOfTokens;\n', '            publicTokenLedger[_toAddress] += _amountOfTokens; \n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\n', '            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \n', '            \n', '        }\n', '        \n', '        // fire event for logging \n', '        emit Transfer(msg.sender, _toAddress, _amountOfTokens); \n', '        \n', '        // ERC20\n', '        return true;\n', '       \n', '    }\n', '    \n', '    /*----------  OWNER ONLY FUNCTIONS  ----------*/\n', '\n', '    /**\n', '     * future games can be added so they can&#39;t earn divs on their token balances\n', '     */\n', '    function setGames(address newGameAddress)\n', '    onlyOwner()\n', '    public\n', '    {\n', '        gameList[newGameAddress] = true;\n', '    }\n', '    \n', '    /**\n', '     * Want to prevent snipers from buying prior to launch\n', '     */\n', '    function goPublic() \n', '        onlyOwner()\n', '        public \n', '        returns(bool)\n', '\n', '    {\n', '        openToThePublic = true;\n', '        return openToThePublic;\n', '    }\n', '    \n', '    \n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     */\n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (tokenSupply + lotterySupply + gameSuppply); //adds the tokens from ambassadors to the supply (but not to the dividends calculation which is based on the supply)\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balanceOf(msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     * If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     * But in the internal calculations, we want them separate. \n', '     */ \n', '    function myDividends(bool _includeReferralBonus) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        return _includeReferralBonus ? dividendsOf(msg.sender) + referralBalances[msg.sender] : dividendsOf(msg.sender) ;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 balance;\n', '\n', '        if (customerAddress == owner) \n', '        { \n', '            // to show div balance of owner\n', '            balance = whaleLedger[customerAddress]; \n', '        }\n', '        else if(gameList[customerAddress] == true) \n', '        {\n', '            // games can still see their token balance\n', '            balance = gameLedger[customerAddress];\n', '        }\n', '        else \n', '        {   \n', '            // to see token balance for anyone else\n', '            balance = publicTokenLedger[customerAddress];\n', '        }\n', '        return balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '      return (uint256) ((int256)(profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * Return the buy and sell price of 1 individual token.\n', '     */\n', '    function buyAndSellPrice()\n', '    public\n', '    pure \n', '    returns(uint256)\n', '    {\n', '        uint256 ethereum = tokenPrice;\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 ethereumToSpend) \n', '        public \n', '        pure \n', '        returns(uint256)\n', '    {\n', '        require(ethereumToSpend >= tokenPrice);\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereumToSpend, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends);\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of sell orders.\n', '     */\n', '    function calculateEthereumReceived(uint256 tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(tokensToSell <= tokenSupply);\n', '        uint256 ethereum = tokensToEthereum_(tokensToSell);\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    \n', '    \n', '    function excludeWhale(address referredyBy) \n', '        onlyNonOwner()\n', '        internal \n', '        returns(uint256) \n', '    { \n', '        require (msg.sender == tx.origin);\n', '        uint256 tokenAmount;\n', '\n', '        tokenAmount = purchaseTokens(msg.value, referredyBy); //redirects to purchaseTokens so same functionality\n', '\n', '        if(gameList[msg.sender] == true)\n', '        {\n', '            tokenSupply = SafeMath.sub(tokenSupply, tokenAmount); // takes out game&#39;s tokens from the tokenSupply (important for redistribution)\n', '            publicTokenLedger[msg.sender] = SafeMath.sub(publicTokenLedger[msg.sender], tokenAmount); // takes out game&#39;s tokens from its ledger so it is "officially" holding 0 tokens. (=> doesn&#39;t receive dividends anymore)\n', '            gameLedger[msg.sender] += tokenAmount;    //it gets a special ledger so it can&#39;t sell its tokens\n', '            gameSuppply += tokenAmount; // we need this for a correct totalSupply() number later\n', '        }\n', '\n', '        return tokenAmount;\n', '    }\n', '\n', '\n', '    function purchaseTokens(uint256 incomingEthereum, address referredyBy)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        // data setup\n', '        uint256 undividedDivs = SafeMath.div(SafeMath.mul(incomingEthereum, dividendFee ), 100);\n', '        \n', '        //divide the divs\n', '        uint256 lotteryAndWhaleFee = undividedDivs / 3;\n', '        uint256 referralBonus = lotteryAndWhaleFee;\n', '        uint256 dividends = SafeMath.sub(undividedDivs, (referralBonus + lotteryAndWhaleFee));\n', '        uint256 taxedEthereum = incomingEthereum - undividedDivs;\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '        uint256 whaleFee = lotteryAndWhaleFee / 2;\n', '        //add divs to whale\n', '        whaleLedger[owner] += whaleFee;\n', '        \n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryAndWhaleFee - whaleFee);\n', '        \n', '        //add entry to lottery\n', '        lotteryPlayers.push(msg.sender);\n', '       \n', '        uint256 fee = dividends * magnitude;\n', ' \n', '        require(amountOfTokens > 0 && (amountOfTokens + tokenSupply) > tokenSupply);\n', '        \n', '        // is the user referred by a masternode?\n', '        if(\n', '            // is this a referred purchase?\n', '            referredyBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // no cheating!\n', '            referredyBy != msg.sender && \n', '            \n', '            //can&#39;t use games for referralBonus\n', '            gameList[referredyBy] == false  &&\n', '            \n', '            // does the referrer have at least 5 tokens?\n', '            publicTokenLedger[referredyBy] >= referralLinkRequirement\n', '        )\n', '        {\n', '            // wealth redistribution\n', '            referralBalances[referredyBy] += referralBonus;\n', '        } else\n', '        {\n', '            // no ref purchase\n', '            // add the referral bonus back\n', '            dividends += referralBonus;\n', '            fee = dividends * magnitude;\n', '        }\n', '\n', '        uint256 payoutDividends = isWhalePaying();\n', '        \n', '        // we can&#39;t give people infinite ethereum\n', '        if(tokenSupply > 0)\n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply += amountOfTokens;\n', '            \n', '             // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += ((payoutDividends + dividends) * magnitude / (tokenSupply));\n', '            \n', '            // calculate the amount of tokens the customer receives over his purchase \n', '            fee -= fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)));\n', '        } else \n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply = amountOfTokens;\n', '            \n', '            //if there are zero tokens prior to this buy, and the whale is triggered, send dividends back to whale\n', '            if(whaleLedger[owner] == 0)\n', '            {\n', '                whaleLedger[owner] = payoutDividends;\n', '            }\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        publicTokenLedger[msg.sender] += amountOfTokens;\n', '        \n', '        // Tells the contract that the buyer doesn&#39;t deserve dividends for the tokens before they owned them;\n', '        // BUT, you still get the whale&#39;s divs from your purchase.... so, you still get SOMETHING.\n', '        int256 _updatedPayouts = int256((profitPerShare_ * amountOfTokens) - fee);\n', '        payoutsTo_[msg.sender] += _updatedPayouts;\n', '        \n', '     \n', '        // fire event for logging \n', '        emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens, referredyBy);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    \n', '     /**\n', '     * Calculate token sell value.\n', '     * It&#39;s a simple algorithm. Hopefully, you don&#39;t need a whitepaper with it in scientific notation.\n', '     */\n', '    function isWhalePaying()\n', '    private\n', '    returns(uint256)\n', '    {\n', '        uint256 payoutDividends = 0;\n', '         // this is where we check for lottery winner\n', '        if(whaleLedger[owner] >= 1 ether)\n', '        {\n', '            if(lotteryPlayers.length > 0)\n', '            {\n', '                uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length;\n', '                \n', '                publicTokenLedger[lotteryPlayers[winner]] += lotterySupply;\n', '                emit lotteryPayout(lotteryPlayers[winner], lotterySupply);\n', '                tokenSupply += lotterySupply;\n', '                lotterySupply = 0;\n', '                delete lotteryPlayers;\n', '               \n', '            }\n', '            //whale pays out everyone its divs\n', '            payoutDividends = whaleLedger[owner];\n', '            whaleLedger[owner] = 0;\n', '            emit whaleDump(payoutDividends);\n', '        }\n', '        return payoutDividends;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', '     *It&#39;s a simple algorithm. Hopefully, you don&#39;t need a whitepaper with it in scientific notation.\n', '     */\n', '    function ethereumToTokens_(uint256 ethereum)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 tokensReceived = ((ethereum / tokenPrice) * 1e18);\n', '               \n', '        return tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * Calculate token sell value.\n', '     * It&#39;s a simple algorithm. Hopefully, you don&#39;t need a whitepaper with it in scientific notation.\n', '     */\n', '     function tokensToEthereum_(uint256 coin)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 ethReceived = tokenPrice * (SafeMath.div(coin, 1e18));\n', '        \n', '        return ethReceived;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '     /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract _8thereum {\n', '\n', '\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyTokenHolders() \n', '    {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with profits\n', '    modifier onlyDividendPositive() \n', '    {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '    // only owner\n', '    modifier onlyOwner() \n', '    { \n', '        require (address(msg.sender) == owner); \n', '        _; \n', '    }\n', '    \n', '    // only non-whales\n', '    modifier onlyNonOwner() \n', '    { \n', '        require (address(msg.sender) != owner); \n', '        _; \n', '    }\n', '    \n', '    modifier onlyFoundersIfNotPublic() \n', '    {\n', '        if(!openToThePublic)\n', '        {\n', '            require (founders[address(msg.sender)] == true);   \n', '        }\n', '        _;\n', '    }    \n', '    \n', '    modifier onlyApprovedContracts()\n', '    {\n', '        if(!gameList[msg.sender])\n', '        {\n', '            require (msg.sender == tx.origin);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '    \n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    event lotteryPayout(\n', '        address customerAddress, \n', '        uint256 lotterySupply\n', '    );\n', '    \n', '    event whaleDump(\n', '        uint256 amount\n', '    );\n', '    \n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "8thereum";\n', '    string public symbol = "BIT";\n', '    bool public openToThePublic = false;\n', '    address public owner;\n', '    uint8 constant public decimals = 18;\n', '    uint8 constant internal dividendFee = 15;\n', '    uint256 constant internal tokenPrice = 500000000000000;//0.0005 ether\n', '    uint256 constant internal magnitude = 2**64;\n', '    uint256 constant public referralLinkRequirement = 5e18;// 5 token minimum for referral link\n', '    \n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    mapping(address => bool) internal gameList;\n', '    mapping(address => uint256) internal publicTokenLedger;\n', '    mapping(address => uint256) public   whaleLedger;\n', '    mapping(address => uint256) public   gameLedger;\n', '    mapping(address => uint256) internal referralBalances;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => mapping(address => uint256)) public gamePlayers;\n', '    mapping(address => bool) internal founders;\n', '    address[] lotteryPlayers;\n', '    uint256 internal lotterySupply = 0;\n', '    uint256 internal tokenSupply = 0;\n', '    uint256 internal gameSuppply = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    constructor()\n', '        public\n', '    {\n', '        // no admin, but the owner of the contract is the address used for whale\n', '        owner = address(msg.sender);\n', '\n', "        // add founders here... Founders don't get any special priveledges except being first in line at launch day\n", "        founders[owner] = true; //owner's address\n", '        founders[0x7e474fe5Cfb720804860215f407111183cbc2f85] = true; //KENNY\n', '        founders[0x5138240E96360ad64010C27eB0c685A8b2eDE4F2] = true; //crypt0b!t \n', '        founders[0xAA7A7C2DECB180f68F11E975e6D92B5Dc06083A6] = true; //NumberOfThings \n', '        founders[0x6DC622a04Fd13B6a1C3C5B229CA642b8e50e1e74] = true; //supermanlxvi\n', '        founders[0x41a21b264F9ebF6cF571D4543a5b3AB1c6bEd98C] = true; //Ravi\n', '    }\n', '    \n', '     \n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\n', '     */\n', '    function buy(address referredyBy)\n', '        onlyFoundersIfNotPublic()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        excludeWhale(referredyBy); \n', '    }\n', '    \n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     */\n', '    function()\n', '        onlyFoundersIfNotPublic()\n', '        payable\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        excludeWhale(0x0); \n', '    }\n', '    \n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    function reinvest()\n', '        onlyDividendPositive()\n', '        onlyNonOwner()\n', '        public\n', '    {   \n', '        \n', '        require (msg.sender == tx.origin);\n', '        \n', '        // fetch dividends\n', '        uint256 dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '        \n', '        // pay out the dividends virtually\n', '        address customerAddress = msg.sender;\n', '        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\n', '        \n', '        // retrieve ref. bonus\n', '        dividends += referralBalances[customerAddress];\n', '        referralBalances[customerAddress] = 0;\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(dividends, 0x0);\n', '        \n', '        // fire event for logging \n', '        emit onReinvestment(customerAddress, dividends, _tokens);\n', '    }\n', '    \n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit()\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // get token count for caller & sell them all\n', '        address customerAddress = address(msg.sender);\n', '        uint256 _tokens = publicTokenLedger[customerAddress];\n', '        \n', '        if(_tokens > 0) \n', '        {\n', '            sell(_tokens);\n', '        }\n', '\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        onlyNonOwner()\n', '        onlyDividendPositive()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        uint256 dividends = myDividends(false); // get ref. bonus later in the code\n', '        \n', '        // update dividend tracker\n', '        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\n', '        \n', '        // add ref. bonus\n', '        dividends += referralBalances[customerAddress];\n', '        referralBalances[customerAddress] = 0;\n', '        \n', '        customerAddress.transfer(dividends);\n', '        \n', '        // fire event for logging \n', '        emit onWithdraw(customerAddress, dividends);\n', '    }\n', '    \n', '    /**\n', '     * Liquifies tokens to ethereum.\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0));\n', '\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 ethereum = tokensToEthereum_(_tokens);\n', '        uint256 dividends = (ethereum * dividendFee) / 100;\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        \n', '        //Take some divs for the lottery and whale\n', '        uint256 lotteryAndWhaleFee = dividends / 3;\n', '        dividends -= lotteryAndWhaleFee;\n', '        \n', '        //figure out the lotteryFee\n', '        uint256 lotteryFee = lotteryAndWhaleFee / 2;\n', '        //add tokens to the whale\n', '        uint256 whaleFee = lotteryAndWhaleFee - lotteryFee;\n', '        whaleLedger[owner] += whaleFee;\n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryFee);\n', '        // burn the sold tokens\n', '        tokenSupply -=  _tokens;\n', '        publicTokenLedger[msg.sender] -= _tokens;\n', '        \n', '        \n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (taxedEthereum * magnitude));\n', '        payoutsTo_[msg.sender] -= _updatedPayouts;  \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply > 0) \n', '        {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (dividends * magnitude) / tokenSupply);\n', '        }\n', '        \n', '        // fire event for logging \n', '        emit onTokenSell(msg.sender, _tokens, taxedEthereum);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyNonOwner()\n', '        onlyTokenHolders()\n', '        onlyApprovedContracts()\n', '        public\n', '        returns(bool)\n', '    {\n', '        assert(_toAddress != owner);\n', '        \n', '        // setup\n', '        if(gameList[msg.sender] == true) //If game is transferring tokens\n', '        {\n', '            require((_amountOfTokens <= gameLedger[msg.sender]) && (_amountOfTokens > 0 ));\n', '             // exchange tokens\n', '            gameLedger[msg.sender] -= _amountOfTokens;\n', '            gameSuppply -= _amountOfTokens;\n', '            publicTokenLedger[_toAddress] += _amountOfTokens; \n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \n', '        }\n', '        else if (gameList[_toAddress] == true) //If customer transferring tokens to game\n', '        {\n', '            // make sure we have the requested tokens\n', '            //each game should only cost one token to play\n', '            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 && (_amountOfTokens == 1e18)));\n', '             \n', '             // exchange tokens\n', '            publicTokenLedger[msg.sender] -=  _amountOfTokens;\n', '            gameLedger[_toAddress] += _amountOfTokens; \n', '            gameSuppply += _amountOfTokens;\n', '            gamePlayers[_toAddress][msg.sender] += _amountOfTokens;\n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\n', '        }\n', '        else{\n', '            // make sure we have the requested tokens\n', '            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 ));\n', '                // exchange tokens\n', '            publicTokenLedger[msg.sender] -= _amountOfTokens;\n', '            publicTokenLedger[_toAddress] += _amountOfTokens; \n', '            \n', '            // update dividend trackers\n', '            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\n', '            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \n', '            \n', '        }\n', '        \n', '        // fire event for logging \n', '        emit Transfer(msg.sender, _toAddress, _amountOfTokens); \n', '        \n', '        // ERC20\n', '        return true;\n', '       \n', '    }\n', '    \n', '    /*----------  OWNER ONLY FUNCTIONS  ----------*/\n', '\n', '    /**\n', "     * future games can be added so they can't earn divs on their token balances\n", '     */\n', '    function setGames(address newGameAddress)\n', '    onlyOwner()\n', '    public\n', '    {\n', '        gameList[newGameAddress] = true;\n', '    }\n', '    \n', '    /**\n', '     * Want to prevent snipers from buying prior to launch\n', '     */\n', '    function goPublic() \n', '        onlyOwner()\n', '        public \n', '        returns(bool)\n', '\n', '    {\n', '        openToThePublic = true;\n', '        return openToThePublic;\n', '    }\n', '    \n', '    \n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     */\n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (tokenSupply + lotterySupply + gameSuppply); //adds the tokens from ambassadors to the supply (but not to the dividends calculation which is based on the supply)\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balanceOf(msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     * If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     * But in the internal calculations, we want them separate. \n', '     */ \n', '    function myDividends(bool _includeReferralBonus) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        return _includeReferralBonus ? dividendsOf(msg.sender) + referralBalances[msg.sender] : dividendsOf(msg.sender) ;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 balance;\n', '\n', '        if (customerAddress == owner) \n', '        { \n', '            // to show div balance of owner\n', '            balance = whaleLedger[customerAddress]; \n', '        }\n', '        else if(gameList[customerAddress] == true) \n', '        {\n', '            // games can still see their token balance\n', '            balance = gameLedger[customerAddress];\n', '        }\n', '        else \n', '        {   \n', '            // to see token balance for anyone else\n', '            balance = publicTokenLedger[customerAddress];\n', '        }\n', '        return balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '      return (uint256) ((int256)(profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * Return the buy and sell price of 1 individual token.\n', '     */\n', '    function buyAndSellPrice()\n', '    public\n', '    pure \n', '    returns(uint256)\n', '    {\n', '        uint256 ethereum = tokenPrice;\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 ethereumToSpend) \n', '        public \n', '        pure \n', '        returns(uint256)\n', '    {\n', '        require(ethereumToSpend >= tokenPrice);\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereumToSpend, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends);\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of sell orders.\n', '     */\n', '    function calculateEthereumReceived(uint256 tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(tokensToSell <= tokenSupply);\n', '        uint256 ethereum = tokensToEthereum_(tokensToSell);\n', '        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    \n', '    \n', '    function excludeWhale(address referredyBy) \n', '        onlyNonOwner()\n', '        internal \n', '        returns(uint256) \n', '    { \n', '        require (msg.sender == tx.origin);\n', '        uint256 tokenAmount;\n', '\n', '        tokenAmount = purchaseTokens(msg.value, referredyBy); //redirects to purchaseTokens so same functionality\n', '\n', '        if(gameList[msg.sender] == true)\n', '        {\n', "            tokenSupply = SafeMath.sub(tokenSupply, tokenAmount); // takes out game's tokens from the tokenSupply (important for redistribution)\n", '            publicTokenLedger[msg.sender] = SafeMath.sub(publicTokenLedger[msg.sender], tokenAmount); // takes out game\'s tokens from its ledger so it is "officially" holding 0 tokens. (=> doesn\'t receive dividends anymore)\n', "            gameLedger[msg.sender] += tokenAmount;    //it gets a special ledger so it can't sell its tokens\n", '            gameSuppply += tokenAmount; // we need this for a correct totalSupply() number later\n', '        }\n', '\n', '        return tokenAmount;\n', '    }\n', '\n', '\n', '    function purchaseTokens(uint256 incomingEthereum, address referredyBy)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        // data setup\n', '        uint256 undividedDivs = SafeMath.div(SafeMath.mul(incomingEthereum, dividendFee ), 100);\n', '        \n', '        //divide the divs\n', '        uint256 lotteryAndWhaleFee = undividedDivs / 3;\n', '        uint256 referralBonus = lotteryAndWhaleFee;\n', '        uint256 dividends = SafeMath.sub(undividedDivs, (referralBonus + lotteryAndWhaleFee));\n', '        uint256 taxedEthereum = incomingEthereum - undividedDivs;\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '        uint256 whaleFee = lotteryAndWhaleFee / 2;\n', '        //add divs to whale\n', '        whaleLedger[owner] += whaleFee;\n', '        \n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryAndWhaleFee - whaleFee);\n', '        \n', '        //add entry to lottery\n', '        lotteryPlayers.push(msg.sender);\n', '       \n', '        uint256 fee = dividends * magnitude;\n', ' \n', '        require(amountOfTokens > 0 && (amountOfTokens + tokenSupply) > tokenSupply);\n', '        \n', '        // is the user referred by a masternode?\n', '        if(\n', '            // is this a referred purchase?\n', '            referredyBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // no cheating!\n', '            referredyBy != msg.sender && \n', '            \n', "            //can't use games for referralBonus\n", '            gameList[referredyBy] == false  &&\n', '            \n', '            // does the referrer have at least 5 tokens?\n', '            publicTokenLedger[referredyBy] >= referralLinkRequirement\n', '        )\n', '        {\n', '            // wealth redistribution\n', '            referralBalances[referredyBy] += referralBonus;\n', '        } else\n', '        {\n', '            // no ref purchase\n', '            // add the referral bonus back\n', '            dividends += referralBonus;\n', '            fee = dividends * magnitude;\n', '        }\n', '\n', '        uint256 payoutDividends = isWhalePaying();\n', '        \n', "        // we can't give people infinite ethereum\n", '        if(tokenSupply > 0)\n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply += amountOfTokens;\n', '            \n', '             // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += ((payoutDividends + dividends) * magnitude / (tokenSupply));\n', '            \n', '            // calculate the amount of tokens the customer receives over his purchase \n', '            fee -= fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)));\n', '        } else \n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply = amountOfTokens;\n', '            \n', '            //if there are zero tokens prior to this buy, and the whale is triggered, send dividends back to whale\n', '            if(whaleLedger[owner] == 0)\n', '            {\n', '                whaleLedger[owner] = payoutDividends;\n', '            }\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        publicTokenLedger[msg.sender] += amountOfTokens;\n', '        \n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n", "        // BUT, you still get the whale's divs from your purchase.... so, you still get SOMETHING.\n", '        int256 _updatedPayouts = int256((profitPerShare_ * amountOfTokens) - fee);\n', '        payoutsTo_[msg.sender] += _updatedPayouts;\n', '        \n', '     \n', '        // fire event for logging \n', '        emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens, referredyBy);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    \n', '     /**\n', '     * Calculate token sell value.\n', "     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '    function isWhalePaying()\n', '    private\n', '    returns(uint256)\n', '    {\n', '        uint256 payoutDividends = 0;\n', '         // this is where we check for lottery winner\n', '        if(whaleLedger[owner] >= 1 ether)\n', '        {\n', '            if(lotteryPlayers.length > 0)\n', '            {\n', '                uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length;\n', '                \n', '                publicTokenLedger[lotteryPlayers[winner]] += lotterySupply;\n', '                emit lotteryPayout(lotteryPlayers[winner], lotterySupply);\n', '                tokenSupply += lotterySupply;\n', '                lotterySupply = 0;\n', '                delete lotteryPlayers;\n', '               \n', '            }\n', '            //whale pays out everyone its divs\n', '            payoutDividends = whaleLedger[owner];\n', '            whaleLedger[owner] = 0;\n', '            emit whaleDump(payoutDividends);\n', '        }\n', '        return payoutDividends;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', "     *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '    function ethereumToTokens_(uint256 ethereum)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 tokensReceived = ((ethereum / tokenPrice) * 1e18);\n', '               \n', '        return tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * Calculate token sell value.\n', "     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '     function tokensToEthereum_(uint256 coin)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 ethReceived = tokenPrice * (SafeMath.div(coin, 1e18));\n', '        \n', '        return ethReceived;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '     /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
