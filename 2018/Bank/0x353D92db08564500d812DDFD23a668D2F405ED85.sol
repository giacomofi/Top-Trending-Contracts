['///auto-generated single file for verifying contract on etherscan\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract R1Exchange is SafeMath, Ownable {\n', '    mapping(address => bool) public admins;\n', '    mapping(address => bool) public feeAccounts;\n', '    bool public withdrawEnabled = false;\n', '    mapping(address => mapping(address => uint256)) public tokenList;\n', '    mapping(address => mapping(bytes32 => uint256)) public orderFilled;//tokens filled\n', '    mapping(bytes32 => bool) public withdrawn;\n', '    mapping(address => mapping(address => uint256)) public withdrawAllowance;\n', '    mapping(address => mapping(address => uint256)) public applyList;//withdraw apply list\n', '    mapping(address => mapping(address => uint)) public latestApply;//save the latest apply timestamp\n', '    uint public applyWait = 7 days;\n', '    uint public feeRate = 1;\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '    event ApplyWithdraw(address indexed token, address indexed user, uint256 amount, uint256 time);\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender]);\n', '        _;\n', '    }\n', '    modifier isWithdrawEnabled {\n', '        require(withdrawEnabled);\n', '        _;\n', '    }\n', '    modifier isFeeAccount(address fa) {\n', '        require(feeAccounts[fa]);\n', '        _;\n', '    }\n', '    function() public {\n', '        revert();\n', '    }\n', '    function setAdmin(address admin, bool isAdmin) public onlyOwner {\n', '        require(admin != 0);\n', '        admins[admin] = isAdmin;\n', '    }\n', '    function setFeeAccount(address acc, bool asFee) public onlyOwner {\n', '        require(acc != 0);\n', '        feeAccounts[acc] = asFee;\n', '    }\n', '    function enableWithdraw(bool enabled) public onlyOwner {\n', '        withdrawEnabled = enabled;\n', '    }\n', '    function changeLockTime(uint lock) public onlyOwner {\n', '        require(lock <= 7 days);\n', '        applyWait = lock;\n', '    }\n', '    function changeFeeRate(uint fr) public onlyOwner {\n', '        require(fr > 0);\n', '        feeRate = fr;\n', '    }\n', '    function deposit() public payable {\n', '        tokenList[0][msg.sender] = safeAdd(tokenList[0][msg.sender], msg.value);\n', '        Deposit(0, msg.sender, msg.value, tokenList[0][msg.sender]);\n', '    }\n', '    function depositToken(address token, uint256 amount) public {\n', '        require(token != 0);\n', '        tokenList[token][msg.sender] = safeAdd(tokenList[token][msg.sender], amount);\n', '        require(Token(token).transferFrom(msg.sender, this, amount));\n', '        Deposit(token, msg.sender, amount, tokenList[token][msg.sender]);\n', '    }\n', '    function applyWithdraw(address token, uint256 amount) public {\n', '        uint256 apply = safeAdd(applyList[token][msg.sender], amount);\n', '        require(safeAdd(apply, withdrawAllowance[token][msg.sender]) <= tokenList[token][msg.sender]);\n', '        applyList[token][msg.sender] = apply;\n', '        latestApply[token][msg.sender] = block.timestamp;\n', '        ApplyWithdraw(token, msg.sender, amount, block.timestamp);\n', '    }\n', '    /**\n', "    * approve user's withdraw application\n", '    **/\n', '    function approveWithdraw(address token, address user) public onlyAdmin {\n', '        withdrawAllowance[token][user] = safeAdd(withdrawAllowance[token][user], applyList[token][user]);\n', '        applyList[token][user] = 0;\n', '        latestApply[token][user] = 0;\n', '    }\n', '    /**\n', "    * user's withdraw will success in two cases:\n", '    *    1. when the admin calls the approveWithdraw function;\n', '    * or 2. when the lock time has passed since the application;\n', '    **/\n', '    function withdraw(address token, uint256 amount) public {\n', '        require(amount <= tokenList[token][msg.sender]);\n', '        if (amount > withdrawAllowance[token][msg.sender]) {\n', '            //withdraw wait over time\n', '            require(latestApply[token][msg.sender] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender]) > applyWait);\n', '            withdrawAllowance[token][msg.sender] = safeAdd(withdrawAllowance[token][msg.sender], applyList[token][msg.sender]);\n', '            applyList[token][msg.sender] = 0;\n', '        }\n', '        require(amount <= withdrawAllowance[token][msg.sender]);\n', '        withdrawAllowance[token][msg.sender] = safeSub(withdrawAllowance[token][msg.sender], amount);\n', '        tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);\n', '        latestApply[token][msg.sender] = 0;\n', '        if (token == 0) {//withdraw ether\n', '            require(msg.sender.send(amount));\n', '        } else {//withdraw token\n', '            require(Token(token).transfer(msg.sender, amount));\n', '        }\n', '        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);\n', '    }\n', '    /**\n', '    * withdraw directly when withdrawEnabled=true\n', '    **/\n', '    function withdrawNoLimit(address token, uint256 amount) public isWithdrawEnabled {\n', '        require(amount <= tokenList[token][msg.sender]);\n', '        tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);\n', '        if (token == 0) {//withdraw ether\n', '            require(msg.sender.send(amount));\n', '        } else {//withdraw token\n', '            require(Token(token).transfer(msg.sender, amount));\n', '        }\n', '        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);\n', '    }\n', '    /**\n', "    * admin withdraw according to user's signed withdraw info\n", '    * PARAMS:\n', '    * addresses:\n', '    * [0] user\n', '    * [1] token\n', '    * [2] feeAccount\n', '    * values:\n', '    * [0] amount\n', '    * [1] nonce\n', '    * [2] fee\n', '    **/\n', '    function adminWithdraw(address[3] addresses, uint256[3] values, uint8 v, bytes32 r, bytes32 s)\n', '    public\n', '    onlyAdmin\n', '    isFeeAccount(addresses[2])\n', '    {\n', '        address user = addresses[0];\n', '        address token = addresses[1];\n', '        address feeAccount = addresses[2];\n', '        uint256 amount = values[0];\n', '        uint256 nonce = values[1];\n', '        uint256 fee = values[2];\n', '        require(amount <= tokenList[token][user]);\n', '        require(safeMul(fee, feeRate) < amount);\n', '        bytes32 hash = keccak256(user, token, amount, nonce);\n', '        require(!withdrawn[hash]);\n', '        withdrawn[hash] = true;\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user);\n', '        tokenList[token][user] = safeSub(tokenList[token][user], amount);\n', '        tokenList[token][feeAccount] = safeAdd(tokenList[token][feeAccount], fee);\n', '        amount = safeSub(amount, fee);\n', '        if (token == 0) {//withdraw ether\n', '            require(user.send(amount));\n', '        } else {//withdraw token\n', '            require(Token(token).transfer(user, amount));\n', '        }\n', '        Withdraw(token, user, amount, tokenList[token][user]);\n', '    }\n', '    function getOrderHash(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address base, uint256 expires, uint256 nonce, address feeToken) public pure returns (bytes32) {\n', '        return keccak256(tokenBuy, amountBuy, tokenSell, amountSell, base, expires, nonce, feeToken);\n', '    }\n', '    function balanceOf(address token, address user) public constant returns (uint256) {\n', '        return tokenList[token][user];\n', '    }\n', '    struct Order {\n', '        address tokenBuy;\n', '        address tokenSell;\n', '        uint256 amountBuy;\n', '        uint256 amountSell;\n', '        address user;\n', '        uint256 fee;\n', '        uint256 expires;\n', '        uint256 nonce;\n', '        bytes32 orderHash;\n', '        address baseToken;\n', '        address feeToken;//0:default;others:payed with erc-20 token\n', '    }\n', '    /**\n', "    * swap maker and taker's tokens according to their signed order info.\n", '    *\n', '    * PARAMS:\n', '    * addresses:\n', '    * [0]:maker tokenBuy\n', '    * [1]:taker tokenBuy\n', '    * [2]:maker tokenSell\n', '    * [3]:taker tokenSell\n', '    * [4]:maker user\n', '    * [5]:taker user\n', '    * [6]:maker baseTokenAddr .default:0 ,then baseToken is ETH\n', '    * [7]:taker baseTokenAddr .default:0 ,then baseToken is ETH\n', '    * [8]:maker feeToken .\n', '    * [9]:taker feeToken .\n', '    * [10]:feeAccount\n', '    * values:\n', '    * [0]:maker amountBuy\n', '    * [1]:taker amountBuy\n', '    * [2]:maker amountSell\n', '    * [3]:taker amountSell\n', '    * [4]:maker fee\n', '    * [5]:taker fee\n', '    * [6]:maker expires\n', '    * [7]:taker expires\n', '    * [8]:maker nonce\n', '    * [9]:taker nonce\n', '    * [10]:tradeAmount of token\n', "    * v,r,s:maker and taker's signature\n", '    **/\n', '    function trade(\n', '        address[11] addresses,\n', '        uint256[11] values,\n', '        uint8[2] v,\n', '        bytes32[2] r,\n', '        bytes32[2] s\n', '    ) public\n', '    onlyAdmin\n', '    isFeeAccount(addresses[10])\n', '    {\n', '        Order memory makerOrder = Order({\n', '            tokenBuy : addresses[0],\n', '            tokenSell : addresses[2],\n', '            user : addresses[4],\n', '            amountBuy : values[0],\n', '            amountSell : values[2],\n', '            fee : values[4],\n', '            expires : values[6],\n', '            nonce : values[8],\n', '            orderHash : 0,\n', '            baseToken : addresses[6],\n', '            feeToken : addresses[8]\n', '            });\n', '        Order memory takerOrder = Order({\n', '            tokenBuy : addresses[1],\n', '            tokenSell : addresses[3],\n', '            user : addresses[5],\n', '            amountBuy : values[1],\n', '            amountSell : values[3],\n', '            fee : values[5],\n', '            expires : values[7],\n', '            nonce : values[9],\n', '            orderHash : 0,\n', '            baseToken : addresses[7],\n', '            feeToken : addresses[9]\n', '            });\n', '        uint256 tradeAmount = values[10];\n', '        //check expires\n', '        require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);\n', '        //make sure both is the same trade pair\n', '        require(makerOrder.baseToken == takerOrder.baseToken && makerOrder.tokenBuy == takerOrder.tokenSell && makerOrder.tokenSell == takerOrder.tokenBuy);\n', '        require(takerOrder.baseToken == takerOrder.tokenBuy || takerOrder.baseToken == takerOrder.tokenSell);\n', '        makerOrder.orderHash = getOrderHash(makerOrder.tokenBuy, makerOrder.amountBuy, makerOrder.tokenSell, makerOrder.amountSell, makerOrder.baseToken, makerOrder.expires, makerOrder.nonce, makerOrder.feeToken);\n', '        takerOrder.orderHash = getOrderHash(takerOrder.tokenBuy, takerOrder.amountBuy, takerOrder.tokenSell, takerOrder.amountSell, takerOrder.baseToken, takerOrder.expires, takerOrder.nonce, takerOrder.feeToken);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", makerOrder.orderHash), v[0], r[0], s[0]) == makerOrder.user);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", takerOrder.orderHash), v[1], r[1], s[1]) == takerOrder.user);\n', '        balance(makerOrder, takerOrder, addresses[10], tradeAmount);\n', '    }\n', '    function balance(Order makerOrder, Order takerOrder, address feeAccount, uint256 tradeAmount) internal {\n', '        ///check the price meets the condition.\n', '        ///match condition: (makerOrder.amountSell*takerOrder.amountSell)/(makerOrder.amountBuy*takerOrder.amountBuy) >=1\n', '        require(safeMul(makerOrder.amountSell, takerOrder.amountSell) >= safeMul(makerOrder.amountBuy, takerOrder.amountBuy));\n', "        ///If the price is ok,always use maker's price first!\n", '        uint256 takerBuy = 0;\n', '        uint256 takerSell = 0;\n', '        if (takerOrder.baseToken == takerOrder.tokenBuy) {\n', '            //taker sell tokens\n', '            uint256 makerAmount = safeSub(makerOrder.amountBuy, orderFilled[makerOrder.user][makerOrder.orderHash]);\n', '            uint256 takerAmount = safeSub(takerOrder.amountSell, orderFilled[takerOrder.user][takerOrder.orderHash]);\n', '            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n', '            takerSell = tradeAmount;\n', '            takerBuy = safeMul(makerOrder.amountSell, takerSell) / makerOrder.amountBuy;\n', '            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerSell);\n', '            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerSell);\n', '        } else {\n', '            // taker buy tokens\n', '            takerAmount = safeSub(takerOrder.amountBuy, orderFilled[takerOrder.user][takerOrder.orderHash]);\n', '            makerAmount = safeSub(makerOrder.amountSell, orderFilled[makerOrder.user][makerOrder.orderHash]);\n', '            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n', '            takerBuy = tradeAmount;\n', '            takerSell = safeMul(makerOrder.amountBuy, takerBuy) / makerOrder.amountSell;\n', '            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerBuy);\n', '            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerBuy);\n', '        }\n', '        uint256 makerFee = chargeFee(makerOrder, feeAccount, takerSell);\n', '        uint256 takerFee = chargeFee(takerOrder, feeAccount, takerBuy);\n', '        //taker give tokens\n', '        tokenList[takerOrder.tokenSell][takerOrder.user] = safeSub(tokenList[takerOrder.tokenSell][takerOrder.user], takerSell);\n', '        //taker get tokens\n', '        tokenList[takerOrder.tokenBuy][takerOrder.user] = safeAdd(tokenList[takerOrder.tokenBuy][takerOrder.user], safeSub(takerBuy, takerFee));\n', '        //maker give tokens\n', '        tokenList[makerOrder.tokenSell][makerOrder.user] = safeSub(tokenList[makerOrder.tokenSell][makerOrder.user], takerBuy);\n', '        //maker get tokens\n', '        tokenList[makerOrder.tokenBuy][makerOrder.user] = safeAdd(tokenList[makerOrder.tokenBuy][makerOrder.user], safeSub(takerSell, makerFee));\n', '    }\n', '    ///charge fees.fee can be payed as other erc20 token or the tokens that user get\n', "    ///returns:fees to reduce from the user's tokenBuy\n", '    function chargeFee(Order order, address feeAccount, uint256 amountBuy) internal returns (uint256){\n', '        uint256 classicFee = 0;\n', '        if (order.feeToken != 0) {\n', '            ///use erc-20 token as fee .\n', '            //make sure the user has enough tokens\n', '            require(order.fee <= tokenList[order.feeToken][order.user]);\n', '            tokenList[order.feeToken][feeAccount] = safeAdd(tokenList[order.feeToken][feeAccount], order.fee);\n', '            tokenList[order.feeToken][order.user] = safeSub(tokenList[order.feeToken][order.user], order.fee);\n', '        } else {\n', '            classicFee = order.fee;\n', '            require(safeMul(order.fee, feeRate) <= amountBuy);\n', '            tokenList[order.tokenBuy][feeAccount] = safeAdd(tokenList[order.tokenBuy][feeAccount], order.fee);\n', '        }\n', '        return classicFee;\n', '    }\n', '    function batchTrade(\n', '        address[11][] addresses,\n', '        uint256[11][] values,\n', '        uint8[2][] v,\n', '        bytes32[2][] r,\n', '        bytes32[2][] s\n', '    ) public onlyAdmin {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            trade(addresses[i], values[i], v[i], r[i], s[i]);\n', '        }\n', '    }\n', '    ///help to refund token to users.this method is called when contract needs updating\n', '    function refund(address user, address[] tokens) public onlyAdmin {\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            uint256 amount = tokenList[token][user];\n', '            if (amount > 0) {\n', '                tokenList[token][user] = 0;\n', '                if (token == 0) {//withdraw ether\n', '                    require(user.send(amount));\n', '                } else {//withdraw token\n', '                    require(Token(token).transfer(user, amount));\n', '                }\n', '                Withdraw(token, user, amount, tokenList[token][user]);\n', '            }\n', '        }\n', '    }\n', '}']