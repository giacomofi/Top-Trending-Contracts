['pragma solidity ^0.4.25;\n', '\n', 'interface HourglassInterface {\n', '    function() payable external;\n', '    function buy(address _investorAddress) payable external returns(uint256);\n', '    function reinvest() external;\n', '    function exit() payable external;\n', '    function withdraw() payable external;\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function totalEthereumBalance() external;\n', '    function totalSupply() external;\n', '    function myTokens() external returns(uint256);\n', '    function myDividends(bool _includeReferralBonus) external returns (uint256);\n', '    function balanceOf(address _investorAddress) external returns (uint256);\n', '    function dividendsOf(address _investorAddress) external returns (uint256);\n', '    function sellPrice() payable external returns (uint256);\n', '    function buyPrice() external;\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) external;\n', '    function calculateEthereumReceived(uint256 _tokensToSell) external returns(uint256);\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) external;\n', '}\n', '\n', 'contract MinerTokenDaily {\n', '    using SafeMath\n', '    for uint;\n', '    \n', '      /* Marketing private wallet*/\n', '    address constant _parojectMarketing = 0x3d3B4a38caD44c2B77DAAC1D746124D2e2b8a27C;\n', '    address constant _cmtfContractAddress = 0x0a97094c19295E320D5121d72139A150021a2702;\n', '    /* Interface to main CMT contract */    \n', '    HourglassInterface constant CMTContract = HourglassInterface(_cmtfContractAddress);\n', '    \n', '    /* % Fee that will be deducted from initial transfer and sent to CMT contract */\n', '    uint constant _masterTaxOnInvestment = 8;\n', '    \n', '    uint constant basePercent = 36;\n', '    uint constant lowPercent = 40;\n', '    uint constant averagePercent = 45;\n', '    uint constant highPercent = 50;\n', '    /* Balance switches for % */\n', '    uint constant phasePreperation = 1000 ether;\n', '    uint constant phaseEngineStart = 2000 ether;\n', '    uint constant phaseLiftoff = 5000 ether;\n', '    uint constant depositLimit = 50.01 ether;\n', '    uint constant payOutInterval = 1 minutes;\n', '    uint _bonuss = 0;\n', '    \n', '    mapping (address => uint256) public invested;\n', '    mapping (address => uint256) public withdraws;\n', '    mapping (address => uint256) public atBlock;\n', '    mapping (address => uint256) public refearned;\n', '\n', '    function () external payable {\n', '        require(msg.value < depositLimit);\n', '        address referrer = bytesToAddress(msg.data);\n', '        \n', '        if (referrer > 0x0 && referrer != msg.sender) {\n', '            if(balanceOf(referrer) > 0.1 ether){\n', '            _bonuss = msg.value.mul(10).div(100);\n', '\t\t\trewardReferral(referrer);\n', '\t\t\trefearned[referrer] += _bonuss;\n', '            }\n', '\t\t}\n', '\t\t\n', '        if (msg.value == 0) {\n', '            withdraw();\n', '            atBlock[msg.sender] = now;\n', '        } else {\n', '            startDivDistribution();\n', '            atBlock[msg.sender] = now;\n', '            invested[msg.sender]+=msg.value;\n', '        }\n', '    }\n', '    \n', '    function withdraw() internal {\n', '        uint payout = availablePayOut();\n', '        withdraws[msg.sender] += payout;\n', '        msg.sender.transfer(payout);\n', '    }\n', '    \n', '    function rewardReferral(address referrer) internal {\n', '        referrer.transfer(_bonuss);\n', '    }\n', '    \n', '    function availablePayOut() public view returns(uint){\n', '            uint percentRate = resolvePercentRate();\n', '            uint balanceTimer = now.sub(atBlock[msg.sender]).div(payOutInterval);\n', '            if(balanceTimer > 1440){\n', '               return invested[msg.sender].mul(percentRate).div(1000);\n', '            }\n', '            else{\n', '               return invested[msg.sender].mul(percentRate).div(1000).div(1440).mul(balanceTimer);\n', '            }\n', '    }\n', '    \n', '    function outStandingPayoutFor(address wallet) public view returns(uint){\n', '            uint percentRate = resolvePercentRate();\n', '            uint balanceTimer = now.sub(atBlock[wallet]).div(payOutInterval);\n', '            if(balanceTimer > 1440){\n', '               return invested[wallet].mul(percentRate).div(1000);\n', '            }\n', '            else{\n', '               return invested[wallet].mul(percentRate).div(1000).div(1440).mul(balanceTimer);\n', '            }\n', '    }\n', '    \n', '    function exit() payable public {\n', '        uint percentRate = resolvePercentRate();\n', '        uint payout = invested[msg.sender];\n', '\t\tif(now.sub(atBlock[msg.sender]).mul(percentRate).div(1000) < invested[msg.sender]/2){\n', '\t\t    atBlock[msg.sender] = 0;\n', '            invested[msg.sender] = 0;\n', '            uint payoutTotal = payout.div(2).sub(withdraws[msg.sender]);\n', '            withdraws[msg.sender] = 0;\n', '\t\t msg.sender.transfer(payoutTotal);\n', '\t\t}\n', '\t\telse{\n', '\t\t msg.sender.transfer(payout);\n', '\t\t}\n', '      \n', '    }\n', '    \n', '        /* Internal function to distribute masterx tax fee into dividends to all CMT holders */\n', '    function startDivDistribution() internal{\n', '            /*#######################################  !  IMPORTANT  !  ##############################################\n', '            ## Here we buy CMT tokens with 8% from deposit and we intentionally use marketing wallet as masternode  ##\n', '            ## that results into 33% from 8% goes to marketing & server running  purposes by our team but the rest  ##\n', '            ## of 8% is distributet to all holder with selling CMT tokens & then reinvesting again (LOGIC FROM CMT) ##\n', '            ## This kindof functionality allows us to decrease the % tax on deposit since 1% from deposit is much   ##\n', '            ## more than 33% from 8%.                                                                               ##\n', '            ########################################################################################################*/\n', '            CMTContract.buy.value(msg.value.mul(_masterTaxOnInvestment).div(100))(_parojectMarketing);\n', '            uint _cmtBalance = getFundCMTBalance();\n', '            CMTContract.sell(_cmtBalance);\n', '            CMTContract.reinvest();\n', '    }\n', '      \n', '    \n', '    function resolvePercentRate() public view returns(uint) {\n', '        uint balance = address(this).balance;\n', '        if (balance < phasePreperation) {\n', '            return (basePercent);\n', '        }\n', '        if (balance >= phasePreperation && balance < phaseEngineStart) {\n', '            return (lowPercent);\n', '        }\n', '        if (balance >= phaseEngineStart && balance < phaseLiftoff) {\n', '            return (averagePercent);\n', '        }\n', '        if (balance >= phaseLiftoff) {\n', '            return (highPercent);\n', '        }\n', '    }\n', '    \n', '        /* Returns contracts balance on CMT contract */\n', '    function getFundCMTBalance() internal returns (uint256){\n', '        return CMTContract.myTokens();\n', '    }\n', '    \n', '    function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '\t\tassembly {\n', '\t\t\taddr := mload(add(bys, 20))\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _customerAddress) public view returns (uint256) {\n', '\t    return invested[_customerAddress];\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}']