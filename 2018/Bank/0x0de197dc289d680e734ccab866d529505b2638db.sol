['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send or transfer.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', 'contract CryptoMiningWar is PullPayment {\n', '    bool public initialized = false;\n', '    uint256 public roundNumber = 0;\n', '    uint256 public deadline;\n', '    uint256 public CRTSTAL_MINING_PERIOD = 86400; \n', '    uint256 public HALF_TIME = 8 hours;\n', '    uint256 public ROUND_TIME = 86400 * 7;\n', '\tuint256 public prizePool = 0;\n', '    uint256 BASE_PRICE = 0.005 ether;\n', '    uint256 RANK_LIST_LIMIT = 10000;\n', '    uint256 MINIMUM_LIMIT_SELL = 5000000;\n', '    uint256 randNonce = 0;\n', '    //miner info\n', '    mapping(uint256 => MinerData) private minerData;\n', '    uint256 private numberOfMiners;\n', '    // plyer info\n', '    mapping(address => PlayerData) private players;\n', '    //booster info\n', '    uint256 private numberOfBoosts;\n', '    mapping(uint256 => BoostData) private boostData;\n', '    //order info\n', '    uint256 private numberOfOrders;\n', '    mapping(uint256 => BuyOrderData) private buyOrderData;\n', '    mapping(uint256 => SellOrderData) private sellOrderData;\n', '    uint256 private numberOfRank;\n', '    address[21] rankList;\n', '    address public sponsor;\n', '    uint256 public sponsorLevel;\n', '    address public administrator;\n', '    /*** DATATYPES ***/\n', '    struct PlayerData {\n', '        uint256 roundNumber;\n', '        mapping(uint256 => uint256) minerCount;\n', '        uint256 hashrate;\n', '        uint256 crystals;\n', '        uint256 lastUpdateTime;\n', '        uint256 referral_count;\n', '        uint256 noQuest;\n', '    }\n', '    struct MinerData {\n', '        uint256 basePrice;\n', '        uint256 baseProduct;\n', '        uint256 limit;\n', '    }\n', '    struct BoostData {\n', '        address owner;\n', '        uint256 boostRate;\n', '        uint256 startingLevel;\n', '        uint256 startingTime;\n', '        uint256 halfLife;\n', '    }\n', '    struct BuyOrderData {\n', '        address owner;\n', '        string title;\n', '        string description;\n', '        uint256 unitPrice;\n', '        uint256 amount;\n', '    }\n', '    struct SellOrderData {\n', '        address owner;\n', '        string title;\n', '        string description;\n', '        uint256 unitPrice;\n', '        uint256 amount;\n', '    }\n', '    event eventDoQuest(\n', '        uint clientNumber,\n', '        uint randomNumber\n', '    );\n', '    modifier isNotOver() \n', '    {\n', '        require(now <= deadline);\n', '        _;\n', '    }\n', '    modifier disableContract()\n', '    {\n', '        require(tx.origin == msg.sender);\n', '        _;\n', '    }\n', '    modifier isCurrentRound() \n', '    {\n', '        require(players[msg.sender].roundNumber == roundNumber);\n', '        _;\n', '    }\n', '    modifier limitSell() \n', '    {\n', '        PlayerData storage p = players[msg.sender];\n', '        if(p.hashrate <= MINIMUM_LIMIT_SELL){\n', '            _;\n', '        }else{\n', '            uint256 limit_hashrate = 0;\n', '            if(rankList[9] != 0){\n', '                PlayerData storage rank_player = players[rankList[9]];\n', '                limit_hashrate = SafeMath.mul(rank_player.hashrate, 5);\n', '            }\n', '            require(p.hashrate <= limit_hashrate);\n', '            _;\n', '        }\n', '    }\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        numberOfMiners = 8;\n', '        numberOfBoosts = 5;\n', '        numberOfOrders = 5;\n', '        numberOfRank = 21;\n', '        //init miner data\n', '        //                      price,          prod.     limit\n', '        minerData[0] = MinerData(10,            10,         10);   //lv1\n', '        minerData[1] = MinerData(100,           200,        2);    //lv2\n', '        minerData[2] = MinerData(400,           800,        4);    //lv3\n', '        minerData[3] = MinerData(1600,          3200,       8);    //lv4 \n', '        minerData[4] = MinerData(6400,          9600,       16);   //lv5 \n', '        minerData[5] = MinerData(25600,         38400,      32);   //lv6 \n', '        minerData[6] = MinerData(204800,        204800,     64);   //lv7 \n', '        minerData[7] = MinerData(1638400,       819200,     65536); //lv8\n', '    }\n', '    function () public payable\n', '    {\n', '\t\tprizePool = SafeMath.add(prizePool, msg.value);\n', '    }\n', '    function startGame() public\n', '    {\n', '        require(msg.sender == administrator);\n', '        require(!initialized);\n', '        startNewRound();\n', '        initialized = true;\n', '    }\n', '\n', '    function startNewRound() private \n', '    {\n', '        deadline = SafeMath.add(now, ROUND_TIME);\n', '        roundNumber = SafeMath.add(roundNumber, 1);\n', '        initData();\n', '    }\n', '    function initData() private\n', '    {\n', '        sponsor = administrator;\n', '        sponsorLevel = 6;\n', '        //init booster data\n', '        boostData[0] = BoostData(0, 150, 1, now, HALF_TIME);\n', '        boostData[1] = BoostData(0, 175, 1, now, HALF_TIME);\n', '        boostData[2] = BoostData(0, 200, 1, now, HALF_TIME);\n', '        boostData[3] = BoostData(0, 225, 1, now, HALF_TIME);\n', '        boostData[4] = BoostData(msg.sender, 250, 2, now, HALF_TIME);\n', '        //init order data\n', '        uint256 idx;\n', '        for (idx = 0; idx < numberOfOrders; idx++) {\n', '            buyOrderData[idx] = BuyOrderData(0, "title", "description", 0, 0);\n', '            sellOrderData[idx] = SellOrderData(0, "title", "description", 0, 0);\n', '        }\n', '        for (idx = 0; idx < numberOfRank; idx++) {\n', '            rankList[idx] = 0;\n', '        }\n', '    }\n', '    function lottery() public disableContract\n', '    {\n', '        require(now > deadline);\n', '        uint256 balance = SafeMath.div(SafeMath.mul(prizePool, 90), 100);\n', '\t\tuint256 devFee = SafeMath.div(SafeMath.mul(prizePool, 5), 100);\n', '\t\tasyncSend(administrator, devFee);\n', '        uint8[10] memory profit = [30,20,10,8,7,5,5,5,5,5];\n', '\t\tuint256 totalPayment = 0;\n', '\t\tuint256 rankPayment = 0;\n', '        for(uint256 idx = 0; idx < 10; idx++){\n', '            if(rankList[idx] != 0){\n', '\t\t\t\trankPayment = SafeMath.div(SafeMath.mul(balance, profit[idx]),100);\n', '\t\t\t\tasyncSend(rankList[idx], rankPayment);\n', '\t\t\t\ttotalPayment = SafeMath.add(totalPayment, rankPayment);\n', '            }\n', '        }\n', '\t\tprizePool = SafeMath.add(devFee, SafeMath.sub(balance, totalPayment));\n', '        startNewRound();\n', '    }\n', '    function getRankList() public view returns(address[21])\n', '    {\n', '        return rankList;\n', '    }\n', '    //sponser\n', '    function becomeSponsor() public isNotOver payable\n', '    {\n', '        require(msg.value >= getSponsorFee());\n', '\t\trequire(msg.sender != sponsor);\n', '\t\tuint256 sponsorPrice = getCurrentPrice(sponsorLevel);\n', '\t\tasyncSend(sponsor, sponsorPrice);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.sub(msg.value, sponsorPrice));\n', '        sponsor = msg.sender;\n', '        sponsorLevel = SafeMath.add(sponsorLevel, 1);\n', '    }\n', '    function getSponsorFee() public view returns(uint256 sponsorFee)\n', '    {\n', '        sponsorFee = getCurrentPrice(SafeMath.add(sponsorLevel, 1));\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Miner \n', '    //--------------------------------------------------------------------------\n', '    function getFreeMiner(address ref) public disableContract isNotOver\n', '    {\n', '        require(players[msg.sender].roundNumber != roundNumber);\n', '        PlayerData storage p = players[msg.sender];\n', '        //reset player data\n', '        if(p.hashrate > 0){\n', '            for (uint idx = 1; idx < numberOfMiners; idx++) {\n', '                p.minerCount[idx] = 0;\n', '            }\n', '        }\n', '        p.crystals = 0;\n', '        p.roundNumber = roundNumber;\n', '        //free miner\n', '        p.lastUpdateTime = now;\n', '        p.referral_count = 0;\n', '        p.noQuest        = 0;\n', '        p.minerCount[0] = 1;\n', '        MinerData storage m0 = minerData[0];\n', '        p.hashrate = m0.baseProduct;\n', '    }\n', '\tfunction doQuest(uint256 clientNumber) disableContract isCurrentRound isNotOver public\n', '\t{\n', '\t\tPlayerData storage p = players[msg.sender];\n', '        p.noQuest            = SafeMath.add(p.noQuest, 1);\n', '\t\tuint256 randomNumber = getRandomNumber(msg.sender);\n', '\t\tif(clientNumber == randomNumber) {\n', '            p.referral_count = SafeMath.add(p.referral_count, 1);\n', '\t\t}\n', '\t\temit eventDoQuest(clientNumber, randomNumber);\n', '\t}\n', '    function buyMiner(uint256[] minerNumbers) public isNotOver isCurrentRound\n', '    {   \n', '        require(minerNumbers.length == numberOfMiners);\n', '        uint256 minerIdx = 0;\n', '        MinerData memory m;\n', '        for (; minerIdx < numberOfMiners; minerIdx++) {\n', '            m = minerData[minerIdx];\n', '            if(minerNumbers[minerIdx] > m.limit || minerNumbers[minerIdx] < 0){\n', '                revert();\n', '            }\n', '        }\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage p = players[msg.sender];\n', '        uint256 price = 0;\n', '        uint256 minerNumber = 0;\n', '        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\n', '            minerNumber = minerNumbers[minerIdx];\n', '            if (minerNumber > 0) {\n', '                m = minerData[minerIdx];\n', '                price = SafeMath.add(price, SafeMath.mul(m.basePrice, minerNumber));\n', '            }\n', '        }\n', '        price = SafeMath.mul(price, CRTSTAL_MINING_PERIOD);\n', '        if(p.crystals < price){\n', '            revert();\n', '        }\n', '        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\n', '            minerNumber = minerNumbers[minerIdx];\n', '            if (minerNumber > 0) {\n', '                m = minerData[minerIdx];\n', '                p.minerCount[minerIdx] = SafeMath.min(m.limit, SafeMath.add(p.minerCount[minerIdx], minerNumber));\n', '            }\n', '        }\n', '        p.crystals = SafeMath.sub(p.crystals, price);\n', '        updateHashrate(msg.sender);\n', '    }\n', '    function getPlayerData(address addr) public view\n', '    returns (uint256 crystals, uint256 lastupdate, uint256 hashratePerDay, uint256[8] miners, uint256 hasBoost, uint256 referral_count, uint256 playerBalance, uint256 noQuest )\n', '    {\n', '        PlayerData storage p = players[addr];\n', '        if(p.roundNumber != roundNumber){\n', '            p = players[0];\n', '        }\n', '        crystals   = SafeMath.div(p.crystals, CRTSTAL_MINING_PERIOD);\n', '        lastupdate = p.lastUpdateTime;\n', '        hashratePerDay = addReferralHashrate(addr, p.hashrate);\n', '        uint256 i = 0;\n', '        for(i = 0; i < numberOfMiners; i++)\n', '        {\n', '            miners[i] = p.minerCount[i];\n', '        }\n', '        hasBoost = hasBooster(addr);\n', '        referral_count = p.referral_count;\n', '        noQuest        = p.noQuest; \n', '\t\tplayerBalance = payments[addr];\n', '    }\n', '    function getHashratePerDay(address minerAddr) public view returns (uint256 personalProduction)\n', '    {\n', '        PlayerData storage p = players[minerAddr];   \n', '        personalProduction = addReferralHashrate(minerAddr, p.hashrate);\n', '        uint256 boosterIdx = hasBooster(minerAddr);\n', '        if (boosterIdx != 999) {\n', '            BoostData storage b = boostData[boosterIdx];\n', '            personalProduction = SafeMath.div(SafeMath.mul(personalProduction, b.boostRate), 100);\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // BOOSTER \n', '    //--------------------------------------------------------------------------\n', '    function buyBooster(uint256 idx) public isNotOver isCurrentRound payable \n', '    {\n', '        require(idx < numberOfBoosts);\n', '        BoostData storage b = boostData[idx];\n', '        if(msg.value < getBoosterPrice(idx) || msg.sender == b.owner){\n', '            revert();\n', '        }\n', '        address beneficiary = b.owner;\n', '\t\tuint256 devFeePrize = devFee(getBoosterPrice(idx));\n', '\t\tasyncSend(sponsor, devFeePrize);\n', '\t\tuint256 refundPrize = 0;\n', '        if(beneficiary != 0){\n', '\t\t\trefundPrize = SafeMath.div(SafeMath.mul(getBoosterPrice(idx), 55), 100);\n', '\t\t\tasyncSend(beneficiary, refundPrize);\n', '        }\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.sub(msg.value, SafeMath.add(devFeePrize, refundPrize)));\n', '        updateCrytal(msg.sender);\n', '        updateCrytal(beneficiary);\n', '        uint256 level = getCurrentLevel(b.startingLevel, b.startingTime, b.halfLife);\n', '        b.startingLevel = SafeMath.add(level, 1);\n', '        b.startingTime = now;\n', '        // transfer ownership    \n', '        b.owner = msg.sender;\n', '    }\n', '    function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel, \n', '        uint256 startingTime, uint256 currentPrice, uint256 halfLife)\n', '    {\n', '        require(idx < numberOfBoosts);\n', '        owner            = boostData[idx].owner;\n', '        boostRate        = boostData[idx].boostRate; \n', '        startingLevel    = boostData[idx].startingLevel;\n', '        startingTime     = boostData[idx].startingTime;\n', '        currentPrice     = getBoosterPrice(idx);\n', '        halfLife         = boostData[idx].halfLife;\n', '    }\n', '    function getBoosterPrice(uint256 index) public view returns (uint256)\n', '    {\n', '        BoostData storage booster = boostData[index];\n', '        return getCurrentPrice(getCurrentLevel(booster.startingLevel, booster.startingTime, booster.halfLife));\n', '    }\n', '    function hasBooster(address addr) public view returns (uint256 boostIdx)\n', '    {         \n', '        boostIdx = 999;\n', '        for(uint256 i = 0; i < numberOfBoosts; i++){\n', '            uint256 revert_i = numberOfBoosts - i - 1;\n', '            if(boostData[revert_i].owner == addr){\n', '                boostIdx = revert_i;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Market \n', '    //--------------------------------------------------------------------------\n', '    function buyCrystalDemand(uint256 amount, uint256 unitPrice,string title, string description) public isNotOver isCurrentRound payable \n', '    {\n', '        require(unitPrice >= 100000000000);\n', '        require(amount >= 1000);\n', '        require(SafeMath.mul(amount, unitPrice) <= msg.value);\n', '        uint256 lowestIdx = getLowestUnitPriceIdxFromBuy();\n', '        BuyOrderData storage o = buyOrderData[lowestIdx];\n', '        if(o.amount > 10 && unitPrice <= o.unitPrice){\n', '            revert();\n', '        }\n', '        uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\n', '        if (o.owner != 0){\n', '\t\t\tasyncSend(o.owner, balance);\n', '        }\n', '        o.owner = msg.sender;\n', '        o.unitPrice = unitPrice;\n', '        o.title = title;\n', '        o.description = description;\n', '        o.amount = amount;\n', '    }\n', '    function sellCrystal(uint256 amount, uint256 index) public isNotOver isCurrentRound limitSell\n', '    {\n', '        require(index < numberOfOrders);\n', '        require(amount > 0);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '\t\trequire(o.owner != msg.sender);\n', '        require(amount <= o.amount);\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage seller = players[msg.sender];\n', '        PlayerData storage buyer = players[o.owner];\n', '        require(seller.crystals >= SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        uint256 price = SafeMath.mul(amount, o.unitPrice);\n', '        uint256 fee = devFee(price);\n', '\t\tasyncSend(sponsor, fee);\n', '\t\tasyncSend(administrator, fee);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.div(SafeMath.mul(price, 40), 100));\n', '        buyer.crystals = SafeMath.add(buyer.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        seller.crystals = SafeMath.sub(seller.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        o.amount = SafeMath.sub(o.amount, amount);\n', '\t\tasyncSend(msg.sender, SafeMath.div(price, 2));\n', '    }\n', '    function withdrawBuyDemand(uint256 index) public isNotOver isCurrentRound\n', '    {\n', '        require(index < numberOfOrders);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '        require(o.owner == msg.sender);\n', '        if(o.amount > 0){\n', '            uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\n', '\t\t\tasyncSend(o.owner, balance);\n', '        }\n', '        o.unitPrice = 0;\n', '        o.amount = 0;  \n', '        o.title = "title";\n', '        o.description = "description";\n', '        o.owner = 0;\n', '    }\n', '    function getBuyDemand(uint256 index) public view returns(address owner, string title, string description,\n', '     uint256 amount, uint256 unitPrice)\n', '    {\n', '        require(index < numberOfOrders);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '        owner = o.owner;\n', '        title = o.title;\n', '        description = o.description;\n', '        amount = o.amount;\n', '        unitPrice = o.unitPrice;\n', '    }\n', '    function getLowestUnitPriceIdxFromBuy() public view returns(uint256 lowestIdx)\n', '    {\n', '        uint256 lowestPrice = 2**256 - 1;\n', '        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\n', '            BuyOrderData storage o = buyOrderData[idx];\n', '            //if empty\n', '            if (o.unitPrice == 0 || o.amount < 10) {\n', '                return idx;\n', '            }else if (o.unitPrice < lowestPrice) {\n', '                lowestPrice = o.unitPrice;\n', '                lowestIdx = idx;\n', '            }\n', '        }\n', '    }\n', '    //-------------------------Sell-----------------------------\n', '    function sellCrystalDemand(uint256 amount, uint256 unitPrice, string title, string description) \n', '    public isNotOver isCurrentRound limitSell\n', '    {\n', '        require(amount >= 1000);\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage seller = players[msg.sender];\n', '        if(seller.crystals < SafeMath.mul(amount, CRTSTAL_MINING_PERIOD)){\n', '            revert();\n', '        }\n', '        uint256 highestIdx = getHighestUnitPriceIdxFromSell();\n', '        SellOrderData storage o = sellOrderData[highestIdx];\n', '        if(o.amount > 10 && unitPrice >= o.unitPrice){\n', '            revert();\n', '        }\n', '        if (o.owner != 0){\n', '            PlayerData storage prev = players[o.owner];\n', '            prev.crystals = SafeMath.add(prev.crystals, SafeMath.mul(o.amount, CRTSTAL_MINING_PERIOD));\n', '        }\n', '        o.owner = msg.sender;\n', '        o.unitPrice = unitPrice;\n', '        o.title = title;\n', '        o.description = description;\n', '        o.amount = amount;\n', '        //sub crystals\n', '        seller.crystals = SafeMath.sub(seller.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '    }\n', '    function buyCrystal(uint256 amount, uint256 index) public isNotOver isCurrentRound payable\n', '    {\n', '        require(index < numberOfOrders);\n', '        require(amount > 0);\n', '        SellOrderData storage o = sellOrderData[index];\n', '\t\trequire(o.owner != msg.sender);\n', '        require(amount <= o.amount);\n', '\t\tuint256 price = SafeMath.mul(amount, o.unitPrice);\n', '        require(msg.value >= price);\n', '        PlayerData storage buyer = players[msg.sender];        \n', '        uint256 fee = devFee(price);\n', '\t\tasyncSend(sponsor, fee);\n', '\t\tasyncSend(administrator, fee);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.div(SafeMath.mul(price, 40), 100));\n', '        buyer.crystals = SafeMath.add(buyer.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        o.amount = SafeMath.sub(o.amount, amount);\n', '\t\tasyncSend(o.owner, SafeMath.div(price, 2));\n', '    }\n', '    function withdrawSellDemand(uint256 index) public isNotOver isCurrentRound\n', '    {\n', '        require(index < numberOfOrders);\n', '        SellOrderData storage o = sellOrderData[index];\n', '        require(o.owner == msg.sender);\n', '        if(o.amount > 0){\n', '            PlayerData storage p = players[o.owner];\n', '            p.crystals = SafeMath.add(p.crystals, SafeMath.mul(o.amount, CRTSTAL_MINING_PERIOD));\n', '        }\n', '        o.unitPrice = 0;\n', '        o.amount = 0; \n', '        o.title = "title";\n', '        o.description = "description";\n', '        o.owner = 0;\n', '    }\n', '    function getSellDemand(uint256 index) public view returns(address owner, string title, string description,\n', '     uint256 amount, uint256 unitPrice)\n', '    {\n', '        require(index < numberOfOrders);\n', '        SellOrderData storage o = sellOrderData[index];\n', '        owner = o.owner;\n', '        title = o.title;\n', '        description = o.description;\n', '        amount = o.amount;\n', '        unitPrice = o.unitPrice;\n', '    }\n', '    function getHighestUnitPriceIdxFromSell() public view returns(uint256 highestIdx)\n', '    {\n', '        uint256 highestPrice = 0;\n', '        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\n', '            SellOrderData storage o = sellOrderData[idx];\n', '            //if empty\n', '            if (o.unitPrice == 0 || o.amount < 10) {\n', '                return idx;\n', '            }else if (o.unitPrice > highestPrice) {\n', '                highestPrice = o.unitPrice;\n', '                highestIdx = idx;\n', '            }\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Other \n', '    //--------------------------------------------------------------------------\n', '    function devFee(uint256 amount) public pure returns(uint256)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(amount, 5), 100);\n', '    }\n', '    function getBalance() public view returns(uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '\t//@dev use this function in case of bug\n', '    function upgrade(address addr) public \n', '    {\n', '        require(msg.sender == administrator);\n', '        selfdestruct(addr);\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // Private \n', '    //--------------------------------------------------------------------------\n', '    function updateHashrate(address addr) private\n', '    {\n', '        PlayerData storage p = players[addr];\n', '        uint256 hashrate = 0;\n', '        for (uint idx = 0; idx < numberOfMiners; idx++) {\n', '            MinerData storage m = minerData[idx];\n', '            hashrate = SafeMath.add(hashrate, SafeMath.mul(p.minerCount[idx], m.baseProduct));\n', '        }\n', '        p.hashrate = hashrate;\n', '        if(hashrate > RANK_LIST_LIMIT){\n', '            updateRankList(addr);\n', '        }\n', '    }\n', '    function updateCrytal(address addr) private\n', '    {\n', '        require(now > players[addr].lastUpdateTime);\n', '        if (players[addr].lastUpdateTime != 0) {\n', '            PlayerData storage p = players[addr];\n', '            uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime);\n', '            uint256 revenue = getHashratePerDay(addr);\n', '            p.lastUpdateTime = now;\n', '            if (revenue > 0) {\n', '                revenue = SafeMath.mul(revenue, secondsPassed);\n', '                p.crystals = SafeMath.add(p.crystals, revenue);\n', '            }\n', '        }\n', '    }\n', '    function addReferralHashrate(address addr, uint256 hashrate) private view returns(uint256 personalProduction) \n', '    {\n', '        PlayerData storage p = players[addr];\n', '        if(p.referral_count < 5){\n', '            personalProduction = SafeMath.add(hashrate, SafeMath.mul(p.referral_count, 10));\n', '        }else if(p.referral_count < 10){\n', '            personalProduction = SafeMath.add(hashrate, SafeMath.add(50, SafeMath.mul(p.referral_count, 10)));\n', '        }else{\n', '            personalProduction = SafeMath.add(hashrate, 200);\n', '        }\n', '    }\n', '    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) private view returns(uint256) \n', '    {\n', '        uint256 timePassed=SafeMath.sub(now, startingTime);\n', '        uint256 levelsPassed=SafeMath.div(timePassed, halfLife);\n', '        if (startingLevel < levelsPassed) {\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(startingLevel, levelsPassed);\n', '    }\n', '    function getCurrentPrice(uint256 currentLevel) private view returns(uint256) \n', '    {\n', '        return SafeMath.mul(BASE_PRICE, 2**currentLevel);\n', '    }\n', '    function updateRankList(address addr) private returns(bool)\n', '    {\n', '        uint256 idx = 0;\n', '        PlayerData storage insert = players[addr];\n', '        PlayerData storage lastOne = players[rankList[19]];\n', '        if(insert.hashrate < lastOne.hashrate) {\n', '            return false;\n', '        }\n', '        address[21] memory tempList = rankList;\n', '        if(!inRankList(addr)){\n', '            tempList[20] = addr;\n', '            quickSort(tempList, 0, 20);\n', '        }else{\n', '            quickSort(tempList, 0, 19);\n', '        }\n', '        for(idx = 0;idx < 21; idx++){\n', '            if(tempList[idx] != rankList[idx]){\n', '                rankList[idx] = tempList[idx];\n', '            }\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    function inRankList(address addr) internal view returns(bool)\n', '    {\n', '        for(uint256 idx = 0;idx < 20; idx++){\n', '            if(addr == rankList[idx]){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\tfunction getRandomNumber(address playerAddress) internal returns(uint256 randomNumber) {\n', '        randNonce++;\n', '        randomNumber = uint256(keccak256(now, playerAddress, randNonce)) % 3;\n', '    }\n', '    function quickSort(address[21] list, int left, int right) internal\n', '    {\n', '        int i = left;\n', '        int j = right;\n', '        if(i == j) return;\n', '        address addr = list[uint(left + (right - left) / 2)];\n', '        PlayerData storage p = players[addr];\n', '        while (i <= j) {\n', '            while (players[list[uint(i)]].hashrate > p.hashrate) i++;\n', '            while (p.hashrate > players[list[uint(j)]].hashrate) j--;\n', '            if (i <= j) {\n', '                (list[uint(i)], list[uint(j)]) = (list[uint(j)], list[uint(i)]);\n', '                i++;\n', '                j--;\n', '            }\n', '        }\n', '        if (left < j)\n', '            quickSort(list, left, j);\n', '        if (i < right)\n', '            quickSort(list, i, right);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send or transfer.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', 'contract CryptoMiningWar is PullPayment {\n', '    bool public initialized = false;\n', '    uint256 public roundNumber = 0;\n', '    uint256 public deadline;\n', '    uint256 public CRTSTAL_MINING_PERIOD = 86400; \n', '    uint256 public HALF_TIME = 8 hours;\n', '    uint256 public ROUND_TIME = 86400 * 7;\n', '\tuint256 public prizePool = 0;\n', '    uint256 BASE_PRICE = 0.005 ether;\n', '    uint256 RANK_LIST_LIMIT = 10000;\n', '    uint256 MINIMUM_LIMIT_SELL = 5000000;\n', '    uint256 randNonce = 0;\n', '    //miner info\n', '    mapping(uint256 => MinerData) private minerData;\n', '    uint256 private numberOfMiners;\n', '    // plyer info\n', '    mapping(address => PlayerData) private players;\n', '    //booster info\n', '    uint256 private numberOfBoosts;\n', '    mapping(uint256 => BoostData) private boostData;\n', '    //order info\n', '    uint256 private numberOfOrders;\n', '    mapping(uint256 => BuyOrderData) private buyOrderData;\n', '    mapping(uint256 => SellOrderData) private sellOrderData;\n', '    uint256 private numberOfRank;\n', '    address[21] rankList;\n', '    address public sponsor;\n', '    uint256 public sponsorLevel;\n', '    address public administrator;\n', '    /*** DATATYPES ***/\n', '    struct PlayerData {\n', '        uint256 roundNumber;\n', '        mapping(uint256 => uint256) minerCount;\n', '        uint256 hashrate;\n', '        uint256 crystals;\n', '        uint256 lastUpdateTime;\n', '        uint256 referral_count;\n', '        uint256 noQuest;\n', '    }\n', '    struct MinerData {\n', '        uint256 basePrice;\n', '        uint256 baseProduct;\n', '        uint256 limit;\n', '    }\n', '    struct BoostData {\n', '        address owner;\n', '        uint256 boostRate;\n', '        uint256 startingLevel;\n', '        uint256 startingTime;\n', '        uint256 halfLife;\n', '    }\n', '    struct BuyOrderData {\n', '        address owner;\n', '        string title;\n', '        string description;\n', '        uint256 unitPrice;\n', '        uint256 amount;\n', '    }\n', '    struct SellOrderData {\n', '        address owner;\n', '        string title;\n', '        string description;\n', '        uint256 unitPrice;\n', '        uint256 amount;\n', '    }\n', '    event eventDoQuest(\n', '        uint clientNumber,\n', '        uint randomNumber\n', '    );\n', '    modifier isNotOver() \n', '    {\n', '        require(now <= deadline);\n', '        _;\n', '    }\n', '    modifier disableContract()\n', '    {\n', '        require(tx.origin == msg.sender);\n', '        _;\n', '    }\n', '    modifier isCurrentRound() \n', '    {\n', '        require(players[msg.sender].roundNumber == roundNumber);\n', '        _;\n', '    }\n', '    modifier limitSell() \n', '    {\n', '        PlayerData storage p = players[msg.sender];\n', '        if(p.hashrate <= MINIMUM_LIMIT_SELL){\n', '            _;\n', '        }else{\n', '            uint256 limit_hashrate = 0;\n', '            if(rankList[9] != 0){\n', '                PlayerData storage rank_player = players[rankList[9]];\n', '                limit_hashrate = SafeMath.mul(rank_player.hashrate, 5);\n', '            }\n', '            require(p.hashrate <= limit_hashrate);\n', '            _;\n', '        }\n', '    }\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        numberOfMiners = 8;\n', '        numberOfBoosts = 5;\n', '        numberOfOrders = 5;\n', '        numberOfRank = 21;\n', '        //init miner data\n', '        //                      price,          prod.     limit\n', '        minerData[0] = MinerData(10,            10,         10);   //lv1\n', '        minerData[1] = MinerData(100,           200,        2);    //lv2\n', '        minerData[2] = MinerData(400,           800,        4);    //lv3\n', '        minerData[3] = MinerData(1600,          3200,       8);    //lv4 \n', '        minerData[4] = MinerData(6400,          9600,       16);   //lv5 \n', '        minerData[5] = MinerData(25600,         38400,      32);   //lv6 \n', '        minerData[6] = MinerData(204800,        204800,     64);   //lv7 \n', '        minerData[7] = MinerData(1638400,       819200,     65536); //lv8\n', '    }\n', '    function () public payable\n', '    {\n', '\t\tprizePool = SafeMath.add(prizePool, msg.value);\n', '    }\n', '    function startGame() public\n', '    {\n', '        require(msg.sender == administrator);\n', '        require(!initialized);\n', '        startNewRound();\n', '        initialized = true;\n', '    }\n', '\n', '    function startNewRound() private \n', '    {\n', '        deadline = SafeMath.add(now, ROUND_TIME);\n', '        roundNumber = SafeMath.add(roundNumber, 1);\n', '        initData();\n', '    }\n', '    function initData() private\n', '    {\n', '        sponsor = administrator;\n', '        sponsorLevel = 6;\n', '        //init booster data\n', '        boostData[0] = BoostData(0, 150, 1, now, HALF_TIME);\n', '        boostData[1] = BoostData(0, 175, 1, now, HALF_TIME);\n', '        boostData[2] = BoostData(0, 200, 1, now, HALF_TIME);\n', '        boostData[3] = BoostData(0, 225, 1, now, HALF_TIME);\n', '        boostData[4] = BoostData(msg.sender, 250, 2, now, HALF_TIME);\n', '        //init order data\n', '        uint256 idx;\n', '        for (idx = 0; idx < numberOfOrders; idx++) {\n', '            buyOrderData[idx] = BuyOrderData(0, "title", "description", 0, 0);\n', '            sellOrderData[idx] = SellOrderData(0, "title", "description", 0, 0);\n', '        }\n', '        for (idx = 0; idx < numberOfRank; idx++) {\n', '            rankList[idx] = 0;\n', '        }\n', '    }\n', '    function lottery() public disableContract\n', '    {\n', '        require(now > deadline);\n', '        uint256 balance = SafeMath.div(SafeMath.mul(prizePool, 90), 100);\n', '\t\tuint256 devFee = SafeMath.div(SafeMath.mul(prizePool, 5), 100);\n', '\t\tasyncSend(administrator, devFee);\n', '        uint8[10] memory profit = [30,20,10,8,7,5,5,5,5,5];\n', '\t\tuint256 totalPayment = 0;\n', '\t\tuint256 rankPayment = 0;\n', '        for(uint256 idx = 0; idx < 10; idx++){\n', '            if(rankList[idx] != 0){\n', '\t\t\t\trankPayment = SafeMath.div(SafeMath.mul(balance, profit[idx]),100);\n', '\t\t\t\tasyncSend(rankList[idx], rankPayment);\n', '\t\t\t\ttotalPayment = SafeMath.add(totalPayment, rankPayment);\n', '            }\n', '        }\n', '\t\tprizePool = SafeMath.add(devFee, SafeMath.sub(balance, totalPayment));\n', '        startNewRound();\n', '    }\n', '    function getRankList() public view returns(address[21])\n', '    {\n', '        return rankList;\n', '    }\n', '    //sponser\n', '    function becomeSponsor() public isNotOver payable\n', '    {\n', '        require(msg.value >= getSponsorFee());\n', '\t\trequire(msg.sender != sponsor);\n', '\t\tuint256 sponsorPrice = getCurrentPrice(sponsorLevel);\n', '\t\tasyncSend(sponsor, sponsorPrice);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.sub(msg.value, sponsorPrice));\n', '        sponsor = msg.sender;\n', '        sponsorLevel = SafeMath.add(sponsorLevel, 1);\n', '    }\n', '    function getSponsorFee() public view returns(uint256 sponsorFee)\n', '    {\n', '        sponsorFee = getCurrentPrice(SafeMath.add(sponsorLevel, 1));\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Miner \n', '    //--------------------------------------------------------------------------\n', '    function getFreeMiner(address ref) public disableContract isNotOver\n', '    {\n', '        require(players[msg.sender].roundNumber != roundNumber);\n', '        PlayerData storage p = players[msg.sender];\n', '        //reset player data\n', '        if(p.hashrate > 0){\n', '            for (uint idx = 1; idx < numberOfMiners; idx++) {\n', '                p.minerCount[idx] = 0;\n', '            }\n', '        }\n', '        p.crystals = 0;\n', '        p.roundNumber = roundNumber;\n', '        //free miner\n', '        p.lastUpdateTime = now;\n', '        p.referral_count = 0;\n', '        p.noQuest        = 0;\n', '        p.minerCount[0] = 1;\n', '        MinerData storage m0 = minerData[0];\n', '        p.hashrate = m0.baseProduct;\n', '    }\n', '\tfunction doQuest(uint256 clientNumber) disableContract isCurrentRound isNotOver public\n', '\t{\n', '\t\tPlayerData storage p = players[msg.sender];\n', '        p.noQuest            = SafeMath.add(p.noQuest, 1);\n', '\t\tuint256 randomNumber = getRandomNumber(msg.sender);\n', '\t\tif(clientNumber == randomNumber) {\n', '            p.referral_count = SafeMath.add(p.referral_count, 1);\n', '\t\t}\n', '\t\temit eventDoQuest(clientNumber, randomNumber);\n', '\t}\n', '    function buyMiner(uint256[] minerNumbers) public isNotOver isCurrentRound\n', '    {   \n', '        require(minerNumbers.length == numberOfMiners);\n', '        uint256 minerIdx = 0;\n', '        MinerData memory m;\n', '        for (; minerIdx < numberOfMiners; minerIdx++) {\n', '            m = minerData[minerIdx];\n', '            if(minerNumbers[minerIdx] > m.limit || minerNumbers[minerIdx] < 0){\n', '                revert();\n', '            }\n', '        }\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage p = players[msg.sender];\n', '        uint256 price = 0;\n', '        uint256 minerNumber = 0;\n', '        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\n', '            minerNumber = minerNumbers[minerIdx];\n', '            if (minerNumber > 0) {\n', '                m = minerData[minerIdx];\n', '                price = SafeMath.add(price, SafeMath.mul(m.basePrice, minerNumber));\n', '            }\n', '        }\n', '        price = SafeMath.mul(price, CRTSTAL_MINING_PERIOD);\n', '        if(p.crystals < price){\n', '            revert();\n', '        }\n', '        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\n', '            minerNumber = minerNumbers[minerIdx];\n', '            if (minerNumber > 0) {\n', '                m = minerData[minerIdx];\n', '                p.minerCount[minerIdx] = SafeMath.min(m.limit, SafeMath.add(p.minerCount[minerIdx], minerNumber));\n', '            }\n', '        }\n', '        p.crystals = SafeMath.sub(p.crystals, price);\n', '        updateHashrate(msg.sender);\n', '    }\n', '    function getPlayerData(address addr) public view\n', '    returns (uint256 crystals, uint256 lastupdate, uint256 hashratePerDay, uint256[8] miners, uint256 hasBoost, uint256 referral_count, uint256 playerBalance, uint256 noQuest )\n', '    {\n', '        PlayerData storage p = players[addr];\n', '        if(p.roundNumber != roundNumber){\n', '            p = players[0];\n', '        }\n', '        crystals   = SafeMath.div(p.crystals, CRTSTAL_MINING_PERIOD);\n', '        lastupdate = p.lastUpdateTime;\n', '        hashratePerDay = addReferralHashrate(addr, p.hashrate);\n', '        uint256 i = 0;\n', '        for(i = 0; i < numberOfMiners; i++)\n', '        {\n', '            miners[i] = p.minerCount[i];\n', '        }\n', '        hasBoost = hasBooster(addr);\n', '        referral_count = p.referral_count;\n', '        noQuest        = p.noQuest; \n', '\t\tplayerBalance = payments[addr];\n', '    }\n', '    function getHashratePerDay(address minerAddr) public view returns (uint256 personalProduction)\n', '    {\n', '        PlayerData storage p = players[minerAddr];   \n', '        personalProduction = addReferralHashrate(minerAddr, p.hashrate);\n', '        uint256 boosterIdx = hasBooster(minerAddr);\n', '        if (boosterIdx != 999) {\n', '            BoostData storage b = boostData[boosterIdx];\n', '            personalProduction = SafeMath.div(SafeMath.mul(personalProduction, b.boostRate), 100);\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // BOOSTER \n', '    //--------------------------------------------------------------------------\n', '    function buyBooster(uint256 idx) public isNotOver isCurrentRound payable \n', '    {\n', '        require(idx < numberOfBoosts);\n', '        BoostData storage b = boostData[idx];\n', '        if(msg.value < getBoosterPrice(idx) || msg.sender == b.owner){\n', '            revert();\n', '        }\n', '        address beneficiary = b.owner;\n', '\t\tuint256 devFeePrize = devFee(getBoosterPrice(idx));\n', '\t\tasyncSend(sponsor, devFeePrize);\n', '\t\tuint256 refundPrize = 0;\n', '        if(beneficiary != 0){\n', '\t\t\trefundPrize = SafeMath.div(SafeMath.mul(getBoosterPrice(idx), 55), 100);\n', '\t\t\tasyncSend(beneficiary, refundPrize);\n', '        }\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.sub(msg.value, SafeMath.add(devFeePrize, refundPrize)));\n', '        updateCrytal(msg.sender);\n', '        updateCrytal(beneficiary);\n', '        uint256 level = getCurrentLevel(b.startingLevel, b.startingTime, b.halfLife);\n', '        b.startingLevel = SafeMath.add(level, 1);\n', '        b.startingTime = now;\n', '        // transfer ownership    \n', '        b.owner = msg.sender;\n', '    }\n', '    function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel, \n', '        uint256 startingTime, uint256 currentPrice, uint256 halfLife)\n', '    {\n', '        require(idx < numberOfBoosts);\n', '        owner            = boostData[idx].owner;\n', '        boostRate        = boostData[idx].boostRate; \n', '        startingLevel    = boostData[idx].startingLevel;\n', '        startingTime     = boostData[idx].startingTime;\n', '        currentPrice     = getBoosterPrice(idx);\n', '        halfLife         = boostData[idx].halfLife;\n', '    }\n', '    function getBoosterPrice(uint256 index) public view returns (uint256)\n', '    {\n', '        BoostData storage booster = boostData[index];\n', '        return getCurrentPrice(getCurrentLevel(booster.startingLevel, booster.startingTime, booster.halfLife));\n', '    }\n', '    function hasBooster(address addr) public view returns (uint256 boostIdx)\n', '    {         \n', '        boostIdx = 999;\n', '        for(uint256 i = 0; i < numberOfBoosts; i++){\n', '            uint256 revert_i = numberOfBoosts - i - 1;\n', '            if(boostData[revert_i].owner == addr){\n', '                boostIdx = revert_i;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Market \n', '    //--------------------------------------------------------------------------\n', '    function buyCrystalDemand(uint256 amount, uint256 unitPrice,string title, string description) public isNotOver isCurrentRound payable \n', '    {\n', '        require(unitPrice >= 100000000000);\n', '        require(amount >= 1000);\n', '        require(SafeMath.mul(amount, unitPrice) <= msg.value);\n', '        uint256 lowestIdx = getLowestUnitPriceIdxFromBuy();\n', '        BuyOrderData storage o = buyOrderData[lowestIdx];\n', '        if(o.amount > 10 && unitPrice <= o.unitPrice){\n', '            revert();\n', '        }\n', '        uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\n', '        if (o.owner != 0){\n', '\t\t\tasyncSend(o.owner, balance);\n', '        }\n', '        o.owner = msg.sender;\n', '        o.unitPrice = unitPrice;\n', '        o.title = title;\n', '        o.description = description;\n', '        o.amount = amount;\n', '    }\n', '    function sellCrystal(uint256 amount, uint256 index) public isNotOver isCurrentRound limitSell\n', '    {\n', '        require(index < numberOfOrders);\n', '        require(amount > 0);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '\t\trequire(o.owner != msg.sender);\n', '        require(amount <= o.amount);\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage seller = players[msg.sender];\n', '        PlayerData storage buyer = players[o.owner];\n', '        require(seller.crystals >= SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        uint256 price = SafeMath.mul(amount, o.unitPrice);\n', '        uint256 fee = devFee(price);\n', '\t\tasyncSend(sponsor, fee);\n', '\t\tasyncSend(administrator, fee);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.div(SafeMath.mul(price, 40), 100));\n', '        buyer.crystals = SafeMath.add(buyer.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        seller.crystals = SafeMath.sub(seller.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        o.amount = SafeMath.sub(o.amount, amount);\n', '\t\tasyncSend(msg.sender, SafeMath.div(price, 2));\n', '    }\n', '    function withdrawBuyDemand(uint256 index) public isNotOver isCurrentRound\n', '    {\n', '        require(index < numberOfOrders);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '        require(o.owner == msg.sender);\n', '        if(o.amount > 0){\n', '            uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\n', '\t\t\tasyncSend(o.owner, balance);\n', '        }\n', '        o.unitPrice = 0;\n', '        o.amount = 0;  \n', '        o.title = "title";\n', '        o.description = "description";\n', '        o.owner = 0;\n', '    }\n', '    function getBuyDemand(uint256 index) public view returns(address owner, string title, string description,\n', '     uint256 amount, uint256 unitPrice)\n', '    {\n', '        require(index < numberOfOrders);\n', '        BuyOrderData storage o = buyOrderData[index];\n', '        owner = o.owner;\n', '        title = o.title;\n', '        description = o.description;\n', '        amount = o.amount;\n', '        unitPrice = o.unitPrice;\n', '    }\n', '    function getLowestUnitPriceIdxFromBuy() public view returns(uint256 lowestIdx)\n', '    {\n', '        uint256 lowestPrice = 2**256 - 1;\n', '        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\n', '            BuyOrderData storage o = buyOrderData[idx];\n', '            //if empty\n', '            if (o.unitPrice == 0 || o.amount < 10) {\n', '                return idx;\n', '            }else if (o.unitPrice < lowestPrice) {\n', '                lowestPrice = o.unitPrice;\n', '                lowestIdx = idx;\n', '            }\n', '        }\n', '    }\n', '    //-------------------------Sell-----------------------------\n', '    function sellCrystalDemand(uint256 amount, uint256 unitPrice, string title, string description) \n', '    public isNotOver isCurrentRound limitSell\n', '    {\n', '        require(amount >= 1000);\n', '        updateCrytal(msg.sender);\n', '        PlayerData storage seller = players[msg.sender];\n', '        if(seller.crystals < SafeMath.mul(amount, CRTSTAL_MINING_PERIOD)){\n', '            revert();\n', '        }\n', '        uint256 highestIdx = getHighestUnitPriceIdxFromSell();\n', '        SellOrderData storage o = sellOrderData[highestIdx];\n', '        if(o.amount > 10 && unitPrice >= o.unitPrice){\n', '            revert();\n', '        }\n', '        if (o.owner != 0){\n', '            PlayerData storage prev = players[o.owner];\n', '            prev.crystals = SafeMath.add(prev.crystals, SafeMath.mul(o.amount, CRTSTAL_MINING_PERIOD));\n', '        }\n', '        o.owner = msg.sender;\n', '        o.unitPrice = unitPrice;\n', '        o.title = title;\n', '        o.description = description;\n', '        o.amount = amount;\n', '        //sub crystals\n', '        seller.crystals = SafeMath.sub(seller.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '    }\n', '    function buyCrystal(uint256 amount, uint256 index) public isNotOver isCurrentRound payable\n', '    {\n', '        require(index < numberOfOrders);\n', '        require(amount > 0);\n', '        SellOrderData storage o = sellOrderData[index];\n', '\t\trequire(o.owner != msg.sender);\n', '        require(amount <= o.amount);\n', '\t\tuint256 price = SafeMath.mul(amount, o.unitPrice);\n', '        require(msg.value >= price);\n', '        PlayerData storage buyer = players[msg.sender];        \n', '        uint256 fee = devFee(price);\n', '\t\tasyncSend(sponsor, fee);\n', '\t\tasyncSend(administrator, fee);\n', '\t\tprizePool = SafeMath.add(prizePool, SafeMath.div(SafeMath.mul(price, 40), 100));\n', '        buyer.crystals = SafeMath.add(buyer.crystals, SafeMath.mul(amount, CRTSTAL_MINING_PERIOD));\n', '        o.amount = SafeMath.sub(o.amount, amount);\n', '\t\tasyncSend(o.owner, SafeMath.div(price, 2));\n', '    }\n', '    function withdrawSellDemand(uint256 index) public isNotOver isCurrentRound\n', '    {\n', '        require(index < numberOfOrders);\n', '        SellOrderData storage o = sellOrderData[index];\n', '        require(o.owner == msg.sender);\n', '        if(o.amount > 0){\n', '            PlayerData storage p = players[o.owner];\n', '            p.crystals = SafeMath.add(p.crystals, SafeMath.mul(o.amount, CRTSTAL_MINING_PERIOD));\n', '        }\n', '        o.unitPrice = 0;\n', '        o.amount = 0; \n', '        o.title = "title";\n', '        o.description = "description";\n', '        o.owner = 0;\n', '    }\n', '    function getSellDemand(uint256 index) public view returns(address owner, string title, string description,\n', '     uint256 amount, uint256 unitPrice)\n', '    {\n', '        require(index < numberOfOrders);\n', '        SellOrderData storage o = sellOrderData[index];\n', '        owner = o.owner;\n', '        title = o.title;\n', '        description = o.description;\n', '        amount = o.amount;\n', '        unitPrice = o.unitPrice;\n', '    }\n', '    function getHighestUnitPriceIdxFromSell() public view returns(uint256 highestIdx)\n', '    {\n', '        uint256 highestPrice = 0;\n', '        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\n', '            SellOrderData storage o = sellOrderData[idx];\n', '            //if empty\n', '            if (o.unitPrice == 0 || o.amount < 10) {\n', '                return idx;\n', '            }else if (o.unitPrice > highestPrice) {\n', '                highestPrice = o.unitPrice;\n', '                highestIdx = idx;\n', '            }\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    // Other \n', '    //--------------------------------------------------------------------------\n', '    function devFee(uint256 amount) public pure returns(uint256)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(amount, 5), 100);\n', '    }\n', '    function getBalance() public view returns(uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '\t//@dev use this function in case of bug\n', '    function upgrade(address addr) public \n', '    {\n', '        require(msg.sender == administrator);\n', '        selfdestruct(addr);\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // Private \n', '    //--------------------------------------------------------------------------\n', '    function updateHashrate(address addr) private\n', '    {\n', '        PlayerData storage p = players[addr];\n', '        uint256 hashrate = 0;\n', '        for (uint idx = 0; idx < numberOfMiners; idx++) {\n', '            MinerData storage m = minerData[idx];\n', '            hashrate = SafeMath.add(hashrate, SafeMath.mul(p.minerCount[idx], m.baseProduct));\n', '        }\n', '        p.hashrate = hashrate;\n', '        if(hashrate > RANK_LIST_LIMIT){\n', '            updateRankList(addr);\n', '        }\n', '    }\n', '    function updateCrytal(address addr) private\n', '    {\n', '        require(now > players[addr].lastUpdateTime);\n', '        if (players[addr].lastUpdateTime != 0) {\n', '            PlayerData storage p = players[addr];\n', '            uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime);\n', '            uint256 revenue = getHashratePerDay(addr);\n', '            p.lastUpdateTime = now;\n', '            if (revenue > 0) {\n', '                revenue = SafeMath.mul(revenue, secondsPassed);\n', '                p.crystals = SafeMath.add(p.crystals, revenue);\n', '            }\n', '        }\n', '    }\n', '    function addReferralHashrate(address addr, uint256 hashrate) private view returns(uint256 personalProduction) \n', '    {\n', '        PlayerData storage p = players[addr];\n', '        if(p.referral_count < 5){\n', '            personalProduction = SafeMath.add(hashrate, SafeMath.mul(p.referral_count, 10));\n', '        }else if(p.referral_count < 10){\n', '            personalProduction = SafeMath.add(hashrate, SafeMath.add(50, SafeMath.mul(p.referral_count, 10)));\n', '        }else{\n', '            personalProduction = SafeMath.add(hashrate, 200);\n', '        }\n', '    }\n', '    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) private view returns(uint256) \n', '    {\n', '        uint256 timePassed=SafeMath.sub(now, startingTime);\n', '        uint256 levelsPassed=SafeMath.div(timePassed, halfLife);\n', '        if (startingLevel < levelsPassed) {\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(startingLevel, levelsPassed);\n', '    }\n', '    function getCurrentPrice(uint256 currentLevel) private view returns(uint256) \n', '    {\n', '        return SafeMath.mul(BASE_PRICE, 2**currentLevel);\n', '    }\n', '    function updateRankList(address addr) private returns(bool)\n', '    {\n', '        uint256 idx = 0;\n', '        PlayerData storage insert = players[addr];\n', '        PlayerData storage lastOne = players[rankList[19]];\n', '        if(insert.hashrate < lastOne.hashrate) {\n', '            return false;\n', '        }\n', '        address[21] memory tempList = rankList;\n', '        if(!inRankList(addr)){\n', '            tempList[20] = addr;\n', '            quickSort(tempList, 0, 20);\n', '        }else{\n', '            quickSort(tempList, 0, 19);\n', '        }\n', '        for(idx = 0;idx < 21; idx++){\n', '            if(tempList[idx] != rankList[idx]){\n', '                rankList[idx] = tempList[idx];\n', '            }\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    function inRankList(address addr) internal view returns(bool)\n', '    {\n', '        for(uint256 idx = 0;idx < 20; idx++){\n', '            if(addr == rankList[idx]){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\tfunction getRandomNumber(address playerAddress) internal returns(uint256 randomNumber) {\n', '        randNonce++;\n', '        randomNumber = uint256(keccak256(now, playerAddress, randNonce)) % 3;\n', '    }\n', '    function quickSort(address[21] list, int left, int right) internal\n', '    {\n', '        int i = left;\n', '        int j = right;\n', '        if(i == j) return;\n', '        address addr = list[uint(left + (right - left) / 2)];\n', '        PlayerData storage p = players[addr];\n', '        while (i <= j) {\n', '            while (players[list[uint(i)]].hashrate > p.hashrate) i++;\n', '            while (p.hashrate > players[list[uint(j)]].hashrate) j--;\n', '            if (i <= j) {\n', '                (list[uint(i)], list[uint(j)]) = (list[uint(j)], list[uint(i)]);\n', '                i++;\n', '                j--;\n', '            }\n', '        }\n', '        if (left < j)\n', '            quickSort(list, left, j);\n', '        if (i < right)\n', '            quickSort(list, i, right);\n', '    }\n', '}']
