['pragma solidity ^0.4.18;\n', '\n', '// @author - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f6809f80939d9c9f9481b6919b979f9ad895999b">[email&#160;protected]</a>\n', '// Website: http://CryptoStockMarket.co\n', '// Only CEO can change CEO and CFO address\n', '\n', 'contract CompanyAccessControl {\n', '    \n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    bool public paused = false;\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) \n', '    onlyCEO \n', '    external {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    function setCFO(address _newCFO) \n', '    onlyCEO \n', '    external {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() \n', '    onlyCLevel\n', '    external \n', '    whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() \n', '    onlyCLevel \n', '    whenPaused \n', '    external {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '// Keeps a mapping of onwerAddress to the number of shares owned\n', 'contract BookKeeping {\n', '    \n', '    struct ShareHolders {\n', '        mapping(address => uint) ownerAddressToShares;\n', '        uint numberOfShareHolders;\n', '    }\n', '    \n', '    // _amount should be greator than 0\n', '    function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) \n', '    internal {\n', '        // If user didn&#39;t have shares earlier, he is now a share holder!\n', '        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\n', '            _shareHolders.numberOfShareHolders += 1;\n', '        }\n', '        _shareHolders.ownerAddressToShares[_owner] += _amount;\n', '        \n', '    }\n', '\n', '    // _amount should be greator or equal to what user already have, otherwise will result in underflow\n', '    function _sharesSold(ShareHolders storage _shareHolders, address _owner, uint _amount) \n', '    internal {\n', '        _shareHolders.ownerAddressToShares[_owner] -= _amount;\n', '        \n', '        // if user sold all his tokens, then there is one less share holder\n', '        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\n', '            _shareHolders.numberOfShareHolders -= 1;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract CompanyConstants {\n', '    // Days after which trading volume competiton result will be annouced\n', '    uint constant TRADING_COMPETITION_PERIOD = 5 days;\n', '    \n', '    // Max Percentage of shares that can be released per cycle\n', '    uint constant MAX_PERCENTAGE_SHARE_RELEASE = 5;\n', '    \n', '    uint constant MAX_CLAIM_SHARES_PERCENTAGE = 5;\n', '    \n', '    // Release cycle! Every company needs to wait for "at least" 10 days\n', '    // before releasing next set of shares!\n', '    uint constant MIN_COOLDOWN_TIME = 10; // in days\n', '    uint constant MAX_COOLDOWN_TIME = 255;\n', '    \n', '    // A company can start with min 100 tokens or max 10K tokens\n', '    // and min(10%, 500) new tokens will be released every x days where\n', '    // x >= 10;\n', '    uint constant INIT_MAX_SHARES_IN_CIRCULATION = 10000;\n', '    uint constant INIT_MIN_SHARES_IN_CIRCULATION = 100;\n', '    uint constant MAX_SHARES_RELEASE_IN_ONE_CYCLE = 500;\n', '    \n', '    // Company will take a cut of 10% from the share sales!\n', '    uint constant SALES_CUT = 10;\n', '    \n', '    // Company will take a cut of 2% when an order is claimed.\n', '    uint constant ORDER_CUT = 2;\n', '    \n', '    // Type of orders\n', '    enum OrderType {Buy, Sell}\n', '    \n', '    // A new company is listed!\n', '    event Listed(uint companyId, string companyName, uint sharesInCirculation, uint pricePerShare,\n', '    uint percentageSharesToRelease, uint nextSharesReleaseTime, address owner);\n', '    \n', '    // Tokens are claimed!\n', '    event Claimed(uint companyId, uint numberOfShares, address owner);\n', '    \n', '    // Tokens are transfered\n', '    event Transfer(uint companyId, address from, address to, uint numberOfShares);\n', '    \n', '    // There is a new CEO of the company\n', '    event CEOChanged(uint companyId, address previousCEO, address newCEO);\n', '    \n', '    // Shares are relased for the company\n', '    event SharesReleased(uint companyId, address ceo, uint numberOfShares, uint nextSharesReleaseTime);\n', '    \n', '    // A new order is placed\n', '    event OrderPlaced(uint companyId, uint orderIndex, uint amount, uint pricePerShare, OrderType orderType, address owner);\n', '    \n', '    // An order is claimed!\n', '    event OrderFilled(uint companyId, uint orderIndex, uint amount, address buyer);\n', '    \n', '    // A placed order is cancelled!\n', '    event OrderCancelled(uint companyId, uint orderIndex);\n', '    \n', '    event TradingWinnerAnnounced(uint companyId, address winner, uint sharesAwarded);\n', '}\n', '\n', 'contract CompanyBase is BookKeeping, CompanyConstants {\n', '\n', '    struct Company {\n', '        // Company names are stored as hashes to save gas cost during execution\n', '        bytes32 companyNameHash;\n', '\n', '        // Percentage of shares to release\n', '        // will be less than maxPercentageSharesRelease\n', '        uint32 percentageSharesToRelease;\n', '\n', '        // The time of the release cycle in days. If it is set to 10\n', '        // then it means shares can only be released every 10 days \n', '        // Min values is 10\n', '        uint32 coolDownTime;\n', '        \n', '        // Total number of shares that are in circulation right now!\n', '        uint32 sharesInCirculation; \n', '\n', '        // Total number of shares that are still with the company and can be claimed by paying the price\n', '        uint32 unclaimedShares; \n', '        \n', '        // Address of the person who owns more tha 50% shares of the company.\n', '        address ceoOfCompany; \n', '\n', '        // Address of person who registered this company and will receive money from the share sales.\n', '        address ownedBy; \n', '        \n', '        // The exact time in future before which shares can&#39;t be released!\n', '        // if shares are just released then nextSharesReleaseTime will be (now + coolDownTime);\n', '        uint nextSharesReleaseTime; \n', '\n', '        // Price of one share as set by the company\n', '        uint pricePerShare; \n', '\n', '        // Share holders of the company\n', '        ShareHolders shareHolders;\n', '    }\n', '\n', '    Company[] companies;\n', '    \n', '    function getCompanyDetails(uint _companyId) \n', '    view\n', '    external \n', '    returns (\n', '        bytes32 companyNameHash,\n', '        uint percentageSharesToRelease,\n', '        uint coolDownTime,\n', '        uint nextSharesReleaseTime,\n', '        uint sharesInCirculation,\n', '        uint unclaimedShares,\n', '        uint pricePerShare,\n', '        uint sharesRequiredToBeCEO,\n', '        address ceoOfCompany,     \n', '        address owner,\n', '        uint numberOfShareHolders) {\n', '\n', '        Company storage company = companies[_companyId];\n', '\n', '        companyNameHash = company.companyNameHash;\n', '        percentageSharesToRelease = company.percentageSharesToRelease;\n', '        coolDownTime = company.coolDownTime;\n', '        nextSharesReleaseTime = company.nextSharesReleaseTime;\n', '        sharesInCirculation = company.sharesInCirculation;\n', '        unclaimedShares = company.unclaimedShares;\n', '        pricePerShare = company.pricePerShare; \n', '        sharesRequiredToBeCEO = (sharesInCirculation/2) + 1;\n', '        ceoOfCompany = company.ceoOfCompany;\n', '        owner = company.ownedBy;\n', '        numberOfShareHolders = company.shareHolders.numberOfShareHolders;\n', '    }\n', '\n', '    function getNumberOfShareHolders(uint _companyId) \n', '    view\n', '    external\n', '    returns (uint) {\n', '        return companies[_companyId].shareHolders.numberOfShareHolders;\n', '    }\n', '\n', '    function getNumberOfSharesForAddress(uint _companyId, address _user) \n', '    view\n', '    external \n', '    returns(uint) {\n', '        return companies[_companyId].shareHolders.ownerAddressToShares[_user];\n', '    }\n', '    \n', '    function getTotalNumberOfRegisteredCompanies()\n', '    view\n', '    external\n', '    returns (uint) {\n', '        return companies.length;\n', '    }\n', '}\n', '\n', 'contract TradingVolume is CompanyConstants {\n', '    \n', '    struct Traders {\n', '        uint relaseTime;\n', '        address winningTrader;\n', '        mapping (address => uint) sharesTraded;\n', '    }\n', '    \n', '    mapping (uint => Traders) companyIdToTraders;\n', '    \n', '    // unique _companyId\n', '    function _addNewCompanyTraders(uint _companyId) \n', '    internal {\n', '        Traders memory traders = Traders({\n', '            winningTrader : 0x0,\n', '            relaseTime : now + TRADING_COMPETITION_PERIOD \n', '        });\n', '        \n', '        companyIdToTraders[_companyId] = traders;\n', '    }\n', '    \n', '    // _from!=_to , _amount > 0\n', '    function _updateTradingVolume(Traders storage _traders, address _from, address _to, uint _amount) \n', '    internal {\n', '        _traders.sharesTraded[_from] += _amount;\n', '        _traders.sharesTraded[_to] += _amount;\n', '        \n', '        if (_traders.sharesTraded[_from] > _traders.sharesTraded[_traders.winningTrader]) {\n', '            _traders.winningTrader = _from;\n', '        } \n', '        \n', '        if (_traders.sharesTraded[_to] > _traders.sharesTraded[_traders.winningTrader]) {\n', '            _traders.winningTrader = _to;\n', '        } \n', '    }\n', '    \n', '    // Get reference of winningTrader before clearing\n', '    function _clearWinner(Traders storage _traders) \n', '    internal {\n', '        delete _traders.sharesTraded[_traders.winningTrader];\n', '        delete _traders.winningTrader;\n', '        _traders.relaseTime = now + TRADING_COMPETITION_PERIOD;\n', '    }\n', '}\n', '\n', 'contract ApprovalContract is CompanyAccessControl {\n', '    // Approver who are approved to launch a company a particular name\n', '    // the bytes32 hash is the hash of the company name!\n', '    mapping(bytes32 => address) public approvedToLaunch;\n', '    \n', '    // Make sure that we don&#39;t add two companies with same name\n', '    mapping(bytes32 => bool) public registredCompanyNames;\n', '    \n', '    // Approve addresses to launch a company with the given name\n', '    // Only ceo or cfo can approve a company;\n', '    // the owner who launched the company would receive 90% from the sales of\n', '    // shares and 10% will be kept by the contract!\n', '    function addApprover(address _owner, string _companyName) \n', '    onlyCLevel\n', '    whenNotPaused\n', '    external {\n', '        approvedToLaunch[keccak256(_companyName)] = _owner;\n', '    }\n', '}\n', '\n', 'contract CompanyMain is CompanyBase, ApprovalContract, TradingVolume {\n', '    uint public withdrawableBalance;\n', '    \n', '    // The cut contract takes from the share sales of an approved company.\n', '    // price is in wei\n', '    function _computeSalesCut(uint _price) \n', '    pure\n', '    internal \n', '    returns (uint) {\n', '        return (_price * SALES_CUT)/100;\n', '    }\n', '    \n', '    // Whenever there is transfer of tokens from _from to _to, CEO of company might get changed!\n', '    function _updateCEOIfRequired(Company storage _company, uint _companyId, address _to) \n', '    internal {\n', '        uint sharesRequiredToBecomeCEO = (_company.sharesInCirculation/2 ) + 1;\n', '        address currentCEO = _company.ceoOfCompany;\n', '        \n', '        if (_company.shareHolders.ownerAddressToShares[currentCEO] >= sharesRequiredToBecomeCEO) {\n', '            return;\n', '        } \n', '        \n', '        if (_to != address(this) && _company.shareHolders.ownerAddressToShares[_to] >= sharesRequiredToBecomeCEO) {\n', '            _company.ceoOfCompany = _to;\n', '            emit CEOChanged(_companyId, currentCEO, _to);\n', '            return;\n', '        }\n', '        \n', '        if (currentCEO == 0x0) {\n', '            return;\n', '        }\n', '        _company.ceoOfCompany = 0x0;\n', '        emit CEOChanged(_companyId, currentCEO, 0x0);\n', '    }\n', '    \n', '\n', '    /// Transfer tokens from _from to _to and verify if CEO of company has changed!\n', '    // _from should have enough tokens before calling this functions!\n', '    // _numberOfTokens should be greator than 0\n', '    function _transfer(uint _companyId, address _from, address _to, uint _numberOfTokens) \n', '    internal {\n', '        Company storage company = companies[_companyId];\n', '        \n', '        _sharesSold(company.shareHolders, _from, _numberOfTokens);\n', '        _sharesBought(company.shareHolders, _to, _numberOfTokens);\n', '\n', '        _updateCEOIfRequired(company, _companyId, _to);\n', '        \n', '        emit Transfer(_companyId, _from, _to, _numberOfTokens);\n', '    }\n', '    \n', '    function transferPromotionalShares(uint _companyId, address _to, uint _amount)\n', '    onlyCLevel\n', '    whenNotPaused\n', '    external\n', '    {\n', '        Company storage company = companies[_companyId];\n', '        // implies a promotional company\n', '        require(company.pricePerShare == 0);\n', '        require(companies[_companyId].shareHolders.ownerAddressToShares[msg.sender] >= _amount);\n', '        _transfer(_companyId, msg.sender, _to, _amount);\n', '    }\n', '    \n', '    function addPromotionalCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation)\n', '    onlyCLevel\n', '    whenNotPaused \n', '    external\n', '    {\n', '        bytes32 companyNameHash = keccak256(_companyName);\n', '        \n', '        // There shouldn&#39;t be a company that is already registered with same name!\n', '        require(registredCompanyNames[companyNameHash] == false);\n', '        \n', '        // Max 10% shares can be released in one release cycle, to control liquidation\n', '        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\n', '        // be released in one cycle can only be upto 500.\n', '        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\n', '        \n', '        // The min release cycle should be at least 10 days\n', '        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\n', '\n', '        uint _companyId = companies.length;\n', '        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\n', '        \n', '        Company memory company = Company({\n', '            companyNameHash: companyNameHash,\n', '            \n', '            percentageSharesToRelease : uint32(_precentageSharesToRelease),\n', '            coolDownTime : uint32(_coolDownTime),\n', '            \n', '            sharesInCirculation : uint32(_sharesInCirculation),\n', '            nextSharesReleaseTime : _nextSharesReleaseTime,\n', '            unclaimedShares : 0,\n', '            \n', '            pricePerShare : 0,\n', '            \n', '            ceoOfCompany : 0x0,\n', '            ownedBy : msg.sender,\n', '            shareHolders : ShareHolders({numberOfShareHolders : 0})\n', '            });\n', '\n', '        companies.push(company);\n', '        _addNewCompanyTraders(_companyId);\n', '        // Register company name\n', '        registredCompanyNames[companyNameHash] = true;\n', '        _sharesBought(companies[_companyId].shareHolders, msg.sender, _sharesInCirculation);\n', '        emit Listed(_companyId, _companyName, _sharesInCirculation, 0, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\n', '    }\n', '\n', '    // Add a new company with the given name  \n', '    function addNewCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation, uint _pricePerShare) \n', '    external \n', '    whenNotPaused \n', '    {\n', '        bytes32 companyNameHash = keccak256(_companyName);\n', '        \n', '        // There shouldn&#39;t be a company that is already registered with same name!\n', '        require(registredCompanyNames[companyNameHash] == false);\n', '        \n', '        // Owner have the permissions to launch the company\n', '        require(approvedToLaunch[companyNameHash] == msg.sender);\n', '        \n', '        // Max 10% shares can be released in one release cycle, to control liquidation\n', '        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\n', '        // be released in one cycle can only be upto 500.\n', '        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\n', '        \n', '        // The min release cycle should be at least 10 days\n', '        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\n', '        \n', '        require(_sharesInCirculation >= INIT_MIN_SHARES_IN_CIRCULATION &&\n', '        _sharesInCirculation <= INIT_MAX_SHARES_IN_CIRCULATION);\n', '\n', '        uint _companyId = companies.length;\n', '        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\n', '\n', '        Company memory company = Company({\n', '            companyNameHash: companyNameHash,\n', '            \n', '            percentageSharesToRelease : uint32(_precentageSharesToRelease),\n', '            nextSharesReleaseTime : _nextSharesReleaseTime,\n', '            coolDownTime : uint32(_coolDownTime),\n', '            \n', '            sharesInCirculation : uint32(_sharesInCirculation),\n', '            unclaimedShares : uint32(_sharesInCirculation),\n', '            \n', '            pricePerShare : _pricePerShare,\n', '            \n', '            ceoOfCompany : 0x0,\n', '            ownedBy : msg.sender,\n', '            shareHolders : ShareHolders({numberOfShareHolders : 0})\n', '            });\n', '\n', '        companies.push(company);\n', '        _addNewCompanyTraders(_companyId);\n', '        // Register company name\n', '        registredCompanyNames[companyNameHash] = true;\n', '        emit Listed(_companyId, _companyName, _sharesInCirculation, _pricePerShare, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\n', '    }\n', '    \n', '    // People can claim shares from the company! \n', '    // The share price is fixed. However, once bought the users can place buy/sell\n', '    // orders of any amount!\n', '    function claimShares(uint _companyId, uint _numberOfShares) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        Company storage company = companies[_companyId];\n', '        \n', '        require (_numberOfShares > 0 &&\n', '            _numberOfShares <= (company.sharesInCirculation * MAX_CLAIM_SHARES_PERCENTAGE)/100);\n', '\n', '        require(company.unclaimedShares >= _numberOfShares);\n', '        \n', '        uint totalPrice = company.pricePerShare * _numberOfShares;\n', '        require(msg.value >= totalPrice);\n', '\n', '        company.unclaimedShares -= uint32(_numberOfShares);\n', '\n', '        _sharesBought(company.shareHolders, msg.sender, _numberOfShares);\n', '        _updateCEOIfRequired(company, _companyId, msg.sender);\n', '\n', '        if (totalPrice > 0) {\n', '            uint salesCut = _computeSalesCut(totalPrice);\n', '            withdrawableBalance += salesCut;\n', '            uint sellerProceeds = totalPrice - salesCut;\n', '\n', '            company.ownedBy.transfer(sellerProceeds);\n', '        } \n', '\n', '        emit Claimed(_companyId, _numberOfShares, msg.sender);\n', '    }\n', '    \n', '    // Company&#39;s next shares can be released only by the CEO of the company! \n', '    // So there should exist a CEO first\n', '    function releaseNextShares(uint _companyId) \n', '    external \n', '    whenNotPaused {\n', '\n', '        Company storage company = companies[_companyId];\n', '        \n', '        require(company.ceoOfCompany == msg.sender);\n', '        \n', '        // If there are unclaimedShares with the company, then new shares can&#39;t be relased!\n', '        require(company.unclaimedShares == 0 );\n', '        \n', '        require(now >= company.nextSharesReleaseTime);\n', '\n', '        company.nextSharesReleaseTime = now + company.coolDownTime * 1 days;\n', '        \n', '        // In worst case, we will be relasing max 500 tokens every 10 days! \n', '        // If we will start with max(10K) tokens, then on average we will be adding\n', '        // 18000 tokens every year! In 100 years, it will be 1.8 millions. Multiplying it\n', '        // by 10 makes it 18 millions. There is no way we can overflow the multiplication here!\n', '        uint sharesToRelease = (company.sharesInCirculation * company.percentageSharesToRelease)/100;\n', '        \n', '        // Max 500 tokens can be relased\n', '        if (sharesToRelease > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\n', '            sharesToRelease = MAX_SHARES_RELEASE_IN_ONE_CYCLE;\n', '        }\n', '        \n', '        if (sharesToRelease > 0) {\n', '            company.sharesInCirculation += uint32(sharesToRelease);\n', '            _sharesBought(company.shareHolders, company.ceoOfCompany, sharesToRelease);\n', '            emit SharesReleased(_companyId, company.ceoOfCompany, sharesToRelease, company.nextSharesReleaseTime);\n', '        }\n', '    }\n', '    \n', '    function _updateTradingVolume(uint _companyId, address _from, address _to, uint _amount) \n', '    internal {\n', '        Traders storage traders = companyIdToTraders[_companyId];\n', '        _updateTradingVolume(traders, _from, _to, _amount);\n', '        \n', '        if (now < traders.relaseTime) {\n', '            return;\n', '        }\n', '        \n', '        Company storage company = companies[_companyId];\n', '        uint _newShares = company.sharesInCirculation/100;\n', '        if (_newShares > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\n', '            _newShares = 100;\n', '        }\n', '        company.sharesInCirculation += uint32(_newShares);\n', '         _sharesBought(company.shareHolders, traders.winningTrader, _newShares);\n', '        _updateCEOIfRequired(company, _companyId, traders.winningTrader);\n', '        emit TradingWinnerAnnounced(_companyId, traders.winningTrader, _newShares);\n', '        _clearWinner(traders);\n', '    }\n', '}\n', '\n', 'contract MarketBase is CompanyMain {\n', '    \n', '    function MarketBase() public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = msg.sender;\n', '    }\n', '    \n', '    struct Order {\n', '        // Owner who placed the order\n', '        address owner;\n', '                \n', '        // Total number of tokens in order\n', '        uint32 amount;\n', '        \n', '        // Amount of tokens that are already bought/sold by other people\n', '        uint32 amountFilled;\n', '        \n', '        // Type of the order\n', '        OrderType orderType;\n', '        \n', '        // Price of one share\n', '        uint pricePerShare;\n', '    }\n', '    \n', '    // A mapping of companyId to orders\n', '    mapping (uint => Order[]) companyIdToOrders;\n', '    \n', '    // _amount > 0\n', '    function _createOrder(uint _companyId, uint _amount, uint _pricePerShare, OrderType _orderType) \n', '    internal {\n', '        Order memory order = Order({\n', '            owner : msg.sender,\n', '            pricePerShare : _pricePerShare,\n', '            amount : uint32(_amount),\n', '            amountFilled : 0,\n', '            orderType : _orderType\n', '        });\n', '        \n', '        uint index = companyIdToOrders[_companyId].push(order) - 1;\n', '        emit OrderPlaced(_companyId, index, order.amount, order.pricePerShare, order.orderType, msg.sender);\n', '    }\n', '    \n', '    // Place a sell request if seller have enough tokens!\n', '    function placeSellRequest(uint _companyId, uint _amount, uint _pricePerShare) \n', '    whenNotPaused\n', '    external {\n', '        require (_amount > 0);\n', '        require (_pricePerShare > 0);\n', '\n', '        // Seller should have enough tokens to place a sell order!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\n', '\n', '        _transfer(_companyId, msg.sender, this, _amount);\n', '        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Sell);\n', '    }\n', '    \n', '    // Place a request to buy shares of a particular company!\n', '    function placeBuyRequest(uint _companyId, uint _amount, uint _pricePerShare) \n', '    external \n', '    payable \n', '    whenNotPaused {\n', '        require(_amount > 0);\n', '        require(_pricePerShare > 0);\n', '        require(_amount == uint(uint32(_amount)));\n', '        \n', '        // Should have enough eth!\n', '        require(msg.value >= _amount * _pricePerShare);\n', '\n', '        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Buy);\n', '    }\n', '    \n', '    // Cancel a placed order!\n', '    function cancelRequest(uint _companyId, uint _orderIndex) \n', '    external {        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        \n', '        require(order.owner == msg.sender);\n', '        \n', '        uint sharesRemaining = _getRemainingSharesInOrder(order);\n', '        \n', '        require(sharesRemaining > 0);\n', '\n', '        order.amountFilled += uint32(sharesRemaining);\n', '        \n', '        if (order.orderType == OrderType.Buy) {\n', '\n', '             // If its a buy order, transfer the ether back to owner;\n', '            uint price = _getTotalPrice(order, sharesRemaining);\n', '            \n', '            // Sends money back to owner!\n', '            msg.sender.transfer(price);\n', '        } else {\n', '            \n', '            // Send the tokens back to the owner\n', '            _transfer(_companyId, this, msg.sender, sharesRemaining);\n', '        }\n', '\n', '        emit OrderCancelled(_companyId, _orderIndex);\n', '    }\n', '    \n', '    // Fill the sell order!\n', '    function fillSellOrder(uint _companyId, uint _orderIndex, uint _amount) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        require(_amount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Sell);\n', '        \n', '        require(msg.sender != order.owner);\n', '       \n', '        _verifyRemainingSharesInOrder(order, _amount);\n', '\n', '        uint price = _getTotalPrice(order, _amount);\n', '        require(msg.value >= price);\n', '\n', '        order.amountFilled += uint32(_amount);\n', '        \n', '        // transfer tokens to the buyer\n', '        _transfer(_companyId, this, msg.sender, _amount);\n', '        \n', '        // send money to seller after taking a small share\n', '        _transferOrderMoney(price, order.owner);  \n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\n', '        \n', '        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\n', '    }\n', '    \n', '    // Fill the sell order!\n', '    function fillSellOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        require(_maxAmount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Sell);\n', '        \n', '        require(msg.sender != order.owner);\n', '       \n', '        uint buyableShares = _getRemainingSharesInOrder(order);\n', '        require(buyableShares > 0);\n', '        \n', '        if (buyableShares > _maxAmount) {\n', '            buyableShares = _maxAmount;\n', '        }\n', '\n', '        uint price = _getTotalPrice(order, buyableShares);\n', '        require(msg.value >= price);\n', '\n', '        order.amountFilled += uint32(buyableShares);\n', '        \n', '        // transfer tokens to the buyer\n', '        _transfer(_companyId, this, msg.sender, buyableShares);\n', '        \n', '        // send money to seller after taking a small share\n', '        _transferOrderMoney(price, order.owner); \n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\n', '        \n', '        uint buyerProceeds = msg.value - price;\n', '        msg.sender.transfer(buyerProceeds);\n', '        \n', '        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\n', '    }\n', '\n', '    // Fill the buy order!\n', '    function fillBuyOrder(uint _companyId, uint _orderIndex, uint _amount) \n', '    whenNotPaused\n', '    external {\n', '        require(_amount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Buy);\n', '        \n', '        require(msg.sender != order.owner);\n', '        \n', '        // There should exist enought shares to fulfill the request!\n', '        _verifyRemainingSharesInOrder(order, _amount);\n', '        \n', '        // The seller have enought tokens to fulfill the request!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\n', '        \n', '        order.amountFilled += uint32(_amount);\n', '        \n', '        // transfer the tokens from the seller to the buyer!\n', '        _transfer(_companyId, msg.sender, order.owner, _amount);\n', '        \n', '        uint price = _getTotalPrice(order, _amount);\n', '        \n', '        // transfer the money from this contract to the seller\n', '        _transferOrderMoney(price , msg.sender);\n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\n', '\n', '        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\n', '    }\n', '    \n', '    // Fill buy order partially if possible!\n', '    function fillBuyOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \n', '    whenNotPaused\n', '    external {\n', '        require(_maxAmount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Buy);\n', '        \n', '        require(msg.sender != order.owner);\n', '        \n', '        // There should exist enought shares to fulfill the request!\n', '        uint buyableShares = _getRemainingSharesInOrder(order);\n', '        require(buyableShares > 0);\n', '        \n', '        if ( buyableShares > _maxAmount) {\n', '            buyableShares = _maxAmount;\n', '        }\n', '        \n', '        // The seller have enought tokens to fulfill the request!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, buyableShares);\n', '        \n', '        order.amountFilled += uint32(buyableShares);\n', '        \n', '        // transfer the tokens from the seller to the buyer!\n', '        _transfer(_companyId, msg.sender, order.owner, buyableShares);\n', '        \n', '        uint price = _getTotalPrice(order, buyableShares);\n', '        \n', '        // transfer the money from this contract to the seller\n', '        _transferOrderMoney(price , msg.sender);\n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\n', '\n', '        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\n', '    }\n', '\n', '    // transfer money to the owner!\n', '    function _transferOrderMoney(uint _price, address _owner) \n', '    internal {\n', '        uint priceCut = (_price * ORDER_CUT)/100;\n', '        _owner.transfer(_price - priceCut);\n', '        withdrawableBalance += priceCut;\n', '    }\n', '\n', '    // Returns the price for _amount tokens for the given order\n', '    // _amount > 0\n', '    // order should be verified\n', '    function _getTotalPrice(Order storage _order, uint _amount) \n', '    view\n', '    internal \n', '    returns (uint) {\n', '        return _amount * _order.pricePerShare;\n', '    }\n', '    \n', '    // Gets the number of remaining shares that can be bought or sold under this order\n', '    function _getRemainingSharesInOrder(Order storage _order) \n', '    view\n', '    internal \n', '    returns (uint) {\n', '        return _order.amount - _order.amountFilled;\n', '    }\n', '\n', '    // Verifies if the order have _amount shares to buy/sell\n', '    // _amount > 0\n', '    function _verifyRemainingSharesInOrder(Order storage _order, uint _amount) \n', '    view\n', '    internal {\n', '        require(_getRemainingSharesInOrder(_order) >= _amount);\n', '    }\n', '\n', '    // Checks if the owner have at least &#39;_amount&#39; shares of the company\n', '    // _amount > 0\n', '    function _verifyOwnershipOfTokens(uint _companyId, address _owner, uint _amount) \n', '    view\n', '    internal {\n', '        require(companies[_companyId].shareHolders.ownerAddressToShares[_owner] >= _amount);\n', '    }\n', '    \n', '    // Returns the length of array! All orders might not be active\n', '    function getNumberOfOrders(uint _companyId) \n', '    view\n', '    external \n', '    returns (uint numberOfOrders) {\n', '        numberOfOrders = companyIdToOrders[_companyId].length;\n', '    }\n', '\n', '    function getOrderDetails(uint _comanyId, uint _orderIndex) \n', '    view\n', '    external \n', '    returns (address _owner,\n', '        uint _pricePerShare,\n', '        uint _amount,\n', '        uint _amountFilled,\n', '        OrderType _orderType) {\n', '            Order storage order =  companyIdToOrders[_comanyId][_orderIndex];\n', '            \n', '            _owner = order.owner;\n', '            _pricePerShare = order.pricePerShare;\n', '            _amount = order.amount;\n', '            _amountFilled = order.amountFilled;\n', '            _orderType = order.orderType;\n', '    }\n', '    \n', '    function withdrawBalance(address _address) \n', '    onlyCLevel\n', '    external {\n', '        require(_address != 0x0);\n', '        uint balance = withdrawableBalance;\n', '        withdrawableBalance = 0;\n', '        _address.transfer(balance);\n', '    }\n', '    \n', '    // Only when the contract is paused and there is a subtle bug!\n', '    function kill(address _address) \n', '    onlyCLevel\n', '    whenPaused\n', '    external {\n', '        require(_address != 0x0);\n', '        selfdestruct(_address);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// @author - vivekjibw@gmail.com\n', '// Website: http://CryptoStockMarket.co\n', '// Only CEO can change CEO and CFO address\n', '\n', 'contract CompanyAccessControl {\n', '    \n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    bool public paused = false;\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) \n', '    onlyCEO \n', '    external {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    function setCFO(address _newCFO) \n', '    onlyCEO \n', '    external {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() \n', '    onlyCLevel\n', '    external \n', '    whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() \n', '    onlyCLevel \n', '    whenPaused \n', '    external {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '// Keeps a mapping of onwerAddress to the number of shares owned\n', 'contract BookKeeping {\n', '    \n', '    struct ShareHolders {\n', '        mapping(address => uint) ownerAddressToShares;\n', '        uint numberOfShareHolders;\n', '    }\n', '    \n', '    // _amount should be greator than 0\n', '    function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) \n', '    internal {\n', "        // If user didn't have shares earlier, he is now a share holder!\n", '        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\n', '            _shareHolders.numberOfShareHolders += 1;\n', '        }\n', '        _shareHolders.ownerAddressToShares[_owner] += _amount;\n', '        \n', '    }\n', '\n', '    // _amount should be greator or equal to what user already have, otherwise will result in underflow\n', '    function _sharesSold(ShareHolders storage _shareHolders, address _owner, uint _amount) \n', '    internal {\n', '        _shareHolders.ownerAddressToShares[_owner] -= _amount;\n', '        \n', '        // if user sold all his tokens, then there is one less share holder\n', '        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\n', '            _shareHolders.numberOfShareHolders -= 1;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract CompanyConstants {\n', '    // Days after which trading volume competiton result will be annouced\n', '    uint constant TRADING_COMPETITION_PERIOD = 5 days;\n', '    \n', '    // Max Percentage of shares that can be released per cycle\n', '    uint constant MAX_PERCENTAGE_SHARE_RELEASE = 5;\n', '    \n', '    uint constant MAX_CLAIM_SHARES_PERCENTAGE = 5;\n', '    \n', '    // Release cycle! Every company needs to wait for "at least" 10 days\n', '    // before releasing next set of shares!\n', '    uint constant MIN_COOLDOWN_TIME = 10; // in days\n', '    uint constant MAX_COOLDOWN_TIME = 255;\n', '    \n', '    // A company can start with min 100 tokens or max 10K tokens\n', '    // and min(10%, 500) new tokens will be released every x days where\n', '    // x >= 10;\n', '    uint constant INIT_MAX_SHARES_IN_CIRCULATION = 10000;\n', '    uint constant INIT_MIN_SHARES_IN_CIRCULATION = 100;\n', '    uint constant MAX_SHARES_RELEASE_IN_ONE_CYCLE = 500;\n', '    \n', '    // Company will take a cut of 10% from the share sales!\n', '    uint constant SALES_CUT = 10;\n', '    \n', '    // Company will take a cut of 2% when an order is claimed.\n', '    uint constant ORDER_CUT = 2;\n', '    \n', '    // Type of orders\n', '    enum OrderType {Buy, Sell}\n', '    \n', '    // A new company is listed!\n', '    event Listed(uint companyId, string companyName, uint sharesInCirculation, uint pricePerShare,\n', '    uint percentageSharesToRelease, uint nextSharesReleaseTime, address owner);\n', '    \n', '    // Tokens are claimed!\n', '    event Claimed(uint companyId, uint numberOfShares, address owner);\n', '    \n', '    // Tokens are transfered\n', '    event Transfer(uint companyId, address from, address to, uint numberOfShares);\n', '    \n', '    // There is a new CEO of the company\n', '    event CEOChanged(uint companyId, address previousCEO, address newCEO);\n', '    \n', '    // Shares are relased for the company\n', '    event SharesReleased(uint companyId, address ceo, uint numberOfShares, uint nextSharesReleaseTime);\n', '    \n', '    // A new order is placed\n', '    event OrderPlaced(uint companyId, uint orderIndex, uint amount, uint pricePerShare, OrderType orderType, address owner);\n', '    \n', '    // An order is claimed!\n', '    event OrderFilled(uint companyId, uint orderIndex, uint amount, address buyer);\n', '    \n', '    // A placed order is cancelled!\n', '    event OrderCancelled(uint companyId, uint orderIndex);\n', '    \n', '    event TradingWinnerAnnounced(uint companyId, address winner, uint sharesAwarded);\n', '}\n', '\n', 'contract CompanyBase is BookKeeping, CompanyConstants {\n', '\n', '    struct Company {\n', '        // Company names are stored as hashes to save gas cost during execution\n', '        bytes32 companyNameHash;\n', '\n', '        // Percentage of shares to release\n', '        // will be less than maxPercentageSharesRelease\n', '        uint32 percentageSharesToRelease;\n', '\n', '        // The time of the release cycle in days. If it is set to 10\n', '        // then it means shares can only be released every 10 days \n', '        // Min values is 10\n', '        uint32 coolDownTime;\n', '        \n', '        // Total number of shares that are in circulation right now!\n', '        uint32 sharesInCirculation; \n', '\n', '        // Total number of shares that are still with the company and can be claimed by paying the price\n', '        uint32 unclaimedShares; \n', '        \n', '        // Address of the person who owns more tha 50% shares of the company.\n', '        address ceoOfCompany; \n', '\n', '        // Address of person who registered this company and will receive money from the share sales.\n', '        address ownedBy; \n', '        \n', "        // The exact time in future before which shares can't be released!\n", '        // if shares are just released then nextSharesReleaseTime will be (now + coolDownTime);\n', '        uint nextSharesReleaseTime; \n', '\n', '        // Price of one share as set by the company\n', '        uint pricePerShare; \n', '\n', '        // Share holders of the company\n', '        ShareHolders shareHolders;\n', '    }\n', '\n', '    Company[] companies;\n', '    \n', '    function getCompanyDetails(uint _companyId) \n', '    view\n', '    external \n', '    returns (\n', '        bytes32 companyNameHash,\n', '        uint percentageSharesToRelease,\n', '        uint coolDownTime,\n', '        uint nextSharesReleaseTime,\n', '        uint sharesInCirculation,\n', '        uint unclaimedShares,\n', '        uint pricePerShare,\n', '        uint sharesRequiredToBeCEO,\n', '        address ceoOfCompany,     \n', '        address owner,\n', '        uint numberOfShareHolders) {\n', '\n', '        Company storage company = companies[_companyId];\n', '\n', '        companyNameHash = company.companyNameHash;\n', '        percentageSharesToRelease = company.percentageSharesToRelease;\n', '        coolDownTime = company.coolDownTime;\n', '        nextSharesReleaseTime = company.nextSharesReleaseTime;\n', '        sharesInCirculation = company.sharesInCirculation;\n', '        unclaimedShares = company.unclaimedShares;\n', '        pricePerShare = company.pricePerShare; \n', '        sharesRequiredToBeCEO = (sharesInCirculation/2) + 1;\n', '        ceoOfCompany = company.ceoOfCompany;\n', '        owner = company.ownedBy;\n', '        numberOfShareHolders = company.shareHolders.numberOfShareHolders;\n', '    }\n', '\n', '    function getNumberOfShareHolders(uint _companyId) \n', '    view\n', '    external\n', '    returns (uint) {\n', '        return companies[_companyId].shareHolders.numberOfShareHolders;\n', '    }\n', '\n', '    function getNumberOfSharesForAddress(uint _companyId, address _user) \n', '    view\n', '    external \n', '    returns(uint) {\n', '        return companies[_companyId].shareHolders.ownerAddressToShares[_user];\n', '    }\n', '    \n', '    function getTotalNumberOfRegisteredCompanies()\n', '    view\n', '    external\n', '    returns (uint) {\n', '        return companies.length;\n', '    }\n', '}\n', '\n', 'contract TradingVolume is CompanyConstants {\n', '    \n', '    struct Traders {\n', '        uint relaseTime;\n', '        address winningTrader;\n', '        mapping (address => uint) sharesTraded;\n', '    }\n', '    \n', '    mapping (uint => Traders) companyIdToTraders;\n', '    \n', '    // unique _companyId\n', '    function _addNewCompanyTraders(uint _companyId) \n', '    internal {\n', '        Traders memory traders = Traders({\n', '            winningTrader : 0x0,\n', '            relaseTime : now + TRADING_COMPETITION_PERIOD \n', '        });\n', '        \n', '        companyIdToTraders[_companyId] = traders;\n', '    }\n', '    \n', '    // _from!=_to , _amount > 0\n', '    function _updateTradingVolume(Traders storage _traders, address _from, address _to, uint _amount) \n', '    internal {\n', '        _traders.sharesTraded[_from] += _amount;\n', '        _traders.sharesTraded[_to] += _amount;\n', '        \n', '        if (_traders.sharesTraded[_from] > _traders.sharesTraded[_traders.winningTrader]) {\n', '            _traders.winningTrader = _from;\n', '        } \n', '        \n', '        if (_traders.sharesTraded[_to] > _traders.sharesTraded[_traders.winningTrader]) {\n', '            _traders.winningTrader = _to;\n', '        } \n', '    }\n', '    \n', '    // Get reference of winningTrader before clearing\n', '    function _clearWinner(Traders storage _traders) \n', '    internal {\n', '        delete _traders.sharesTraded[_traders.winningTrader];\n', '        delete _traders.winningTrader;\n', '        _traders.relaseTime = now + TRADING_COMPETITION_PERIOD;\n', '    }\n', '}\n', '\n', 'contract ApprovalContract is CompanyAccessControl {\n', '    // Approver who are approved to launch a company a particular name\n', '    // the bytes32 hash is the hash of the company name!\n', '    mapping(bytes32 => address) public approvedToLaunch;\n', '    \n', "    // Make sure that we don't add two companies with same name\n", '    mapping(bytes32 => bool) public registredCompanyNames;\n', '    \n', '    // Approve addresses to launch a company with the given name\n', '    // Only ceo or cfo can approve a company;\n', '    // the owner who launched the company would receive 90% from the sales of\n', '    // shares and 10% will be kept by the contract!\n', '    function addApprover(address _owner, string _companyName) \n', '    onlyCLevel\n', '    whenNotPaused\n', '    external {\n', '        approvedToLaunch[keccak256(_companyName)] = _owner;\n', '    }\n', '}\n', '\n', 'contract CompanyMain is CompanyBase, ApprovalContract, TradingVolume {\n', '    uint public withdrawableBalance;\n', '    \n', '    // The cut contract takes from the share sales of an approved company.\n', '    // price is in wei\n', '    function _computeSalesCut(uint _price) \n', '    pure\n', '    internal \n', '    returns (uint) {\n', '        return (_price * SALES_CUT)/100;\n', '    }\n', '    \n', '    // Whenever there is transfer of tokens from _from to _to, CEO of company might get changed!\n', '    function _updateCEOIfRequired(Company storage _company, uint _companyId, address _to) \n', '    internal {\n', '        uint sharesRequiredToBecomeCEO = (_company.sharesInCirculation/2 ) + 1;\n', '        address currentCEO = _company.ceoOfCompany;\n', '        \n', '        if (_company.shareHolders.ownerAddressToShares[currentCEO] >= sharesRequiredToBecomeCEO) {\n', '            return;\n', '        } \n', '        \n', '        if (_to != address(this) && _company.shareHolders.ownerAddressToShares[_to] >= sharesRequiredToBecomeCEO) {\n', '            _company.ceoOfCompany = _to;\n', '            emit CEOChanged(_companyId, currentCEO, _to);\n', '            return;\n', '        }\n', '        \n', '        if (currentCEO == 0x0) {\n', '            return;\n', '        }\n', '        _company.ceoOfCompany = 0x0;\n', '        emit CEOChanged(_companyId, currentCEO, 0x0);\n', '    }\n', '    \n', '\n', '    /// Transfer tokens from _from to _to and verify if CEO of company has changed!\n', '    // _from should have enough tokens before calling this functions!\n', '    // _numberOfTokens should be greator than 0\n', '    function _transfer(uint _companyId, address _from, address _to, uint _numberOfTokens) \n', '    internal {\n', '        Company storage company = companies[_companyId];\n', '        \n', '        _sharesSold(company.shareHolders, _from, _numberOfTokens);\n', '        _sharesBought(company.shareHolders, _to, _numberOfTokens);\n', '\n', '        _updateCEOIfRequired(company, _companyId, _to);\n', '        \n', '        emit Transfer(_companyId, _from, _to, _numberOfTokens);\n', '    }\n', '    \n', '    function transferPromotionalShares(uint _companyId, address _to, uint _amount)\n', '    onlyCLevel\n', '    whenNotPaused\n', '    external\n', '    {\n', '        Company storage company = companies[_companyId];\n', '        // implies a promotional company\n', '        require(company.pricePerShare == 0);\n', '        require(companies[_companyId].shareHolders.ownerAddressToShares[msg.sender] >= _amount);\n', '        _transfer(_companyId, msg.sender, _to, _amount);\n', '    }\n', '    \n', '    function addPromotionalCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation)\n', '    onlyCLevel\n', '    whenNotPaused \n', '    external\n', '    {\n', '        bytes32 companyNameHash = keccak256(_companyName);\n', '        \n', "        // There shouldn't be a company that is already registered with same name!\n", '        require(registredCompanyNames[companyNameHash] == false);\n', '        \n', '        // Max 10% shares can be released in one release cycle, to control liquidation\n', '        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\n', '        // be released in one cycle can only be upto 500.\n', '        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\n', '        \n', '        // The min release cycle should be at least 10 days\n', '        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\n', '\n', '        uint _companyId = companies.length;\n', '        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\n', '        \n', '        Company memory company = Company({\n', '            companyNameHash: companyNameHash,\n', '            \n', '            percentageSharesToRelease : uint32(_precentageSharesToRelease),\n', '            coolDownTime : uint32(_coolDownTime),\n', '            \n', '            sharesInCirculation : uint32(_sharesInCirculation),\n', '            nextSharesReleaseTime : _nextSharesReleaseTime,\n', '            unclaimedShares : 0,\n', '            \n', '            pricePerShare : 0,\n', '            \n', '            ceoOfCompany : 0x0,\n', '            ownedBy : msg.sender,\n', '            shareHolders : ShareHolders({numberOfShareHolders : 0})\n', '            });\n', '\n', '        companies.push(company);\n', '        _addNewCompanyTraders(_companyId);\n', '        // Register company name\n', '        registredCompanyNames[companyNameHash] = true;\n', '        _sharesBought(companies[_companyId].shareHolders, msg.sender, _sharesInCirculation);\n', '        emit Listed(_companyId, _companyName, _sharesInCirculation, 0, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\n', '    }\n', '\n', '    // Add a new company with the given name  \n', '    function addNewCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation, uint _pricePerShare) \n', '    external \n', '    whenNotPaused \n', '    {\n', '        bytes32 companyNameHash = keccak256(_companyName);\n', '        \n', "        // There shouldn't be a company that is already registered with same name!\n", '        require(registredCompanyNames[companyNameHash] == false);\n', '        \n', '        // Owner have the permissions to launch the company\n', '        require(approvedToLaunch[companyNameHash] == msg.sender);\n', '        \n', '        // Max 10% shares can be released in one release cycle, to control liquidation\n', '        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\n', '        // be released in one cycle can only be upto 500.\n', '        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\n', '        \n', '        // The min release cycle should be at least 10 days\n', '        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\n', '        \n', '        require(_sharesInCirculation >= INIT_MIN_SHARES_IN_CIRCULATION &&\n', '        _sharesInCirculation <= INIT_MAX_SHARES_IN_CIRCULATION);\n', '\n', '        uint _companyId = companies.length;\n', '        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\n', '\n', '        Company memory company = Company({\n', '            companyNameHash: companyNameHash,\n', '            \n', '            percentageSharesToRelease : uint32(_precentageSharesToRelease),\n', '            nextSharesReleaseTime : _nextSharesReleaseTime,\n', '            coolDownTime : uint32(_coolDownTime),\n', '            \n', '            sharesInCirculation : uint32(_sharesInCirculation),\n', '            unclaimedShares : uint32(_sharesInCirculation),\n', '            \n', '            pricePerShare : _pricePerShare,\n', '            \n', '            ceoOfCompany : 0x0,\n', '            ownedBy : msg.sender,\n', '            shareHolders : ShareHolders({numberOfShareHolders : 0})\n', '            });\n', '\n', '        companies.push(company);\n', '        _addNewCompanyTraders(_companyId);\n', '        // Register company name\n', '        registredCompanyNames[companyNameHash] = true;\n', '        emit Listed(_companyId, _companyName, _sharesInCirculation, _pricePerShare, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\n', '    }\n', '    \n', '    // People can claim shares from the company! \n', '    // The share price is fixed. However, once bought the users can place buy/sell\n', '    // orders of any amount!\n', '    function claimShares(uint _companyId, uint _numberOfShares) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        Company storage company = companies[_companyId];\n', '        \n', '        require (_numberOfShares > 0 &&\n', '            _numberOfShares <= (company.sharesInCirculation * MAX_CLAIM_SHARES_PERCENTAGE)/100);\n', '\n', '        require(company.unclaimedShares >= _numberOfShares);\n', '        \n', '        uint totalPrice = company.pricePerShare * _numberOfShares;\n', '        require(msg.value >= totalPrice);\n', '\n', '        company.unclaimedShares -= uint32(_numberOfShares);\n', '\n', '        _sharesBought(company.shareHolders, msg.sender, _numberOfShares);\n', '        _updateCEOIfRequired(company, _companyId, msg.sender);\n', '\n', '        if (totalPrice > 0) {\n', '            uint salesCut = _computeSalesCut(totalPrice);\n', '            withdrawableBalance += salesCut;\n', '            uint sellerProceeds = totalPrice - salesCut;\n', '\n', '            company.ownedBy.transfer(sellerProceeds);\n', '        } \n', '\n', '        emit Claimed(_companyId, _numberOfShares, msg.sender);\n', '    }\n', '    \n', "    // Company's next shares can be released only by the CEO of the company! \n", '    // So there should exist a CEO first\n', '    function releaseNextShares(uint _companyId) \n', '    external \n', '    whenNotPaused {\n', '\n', '        Company storage company = companies[_companyId];\n', '        \n', '        require(company.ceoOfCompany == msg.sender);\n', '        \n', "        // If there are unclaimedShares with the company, then new shares can't be relased!\n", '        require(company.unclaimedShares == 0 );\n', '        \n', '        require(now >= company.nextSharesReleaseTime);\n', '\n', '        company.nextSharesReleaseTime = now + company.coolDownTime * 1 days;\n', '        \n', '        // In worst case, we will be relasing max 500 tokens every 10 days! \n', '        // If we will start with max(10K) tokens, then on average we will be adding\n', '        // 18000 tokens every year! In 100 years, it will be 1.8 millions. Multiplying it\n', '        // by 10 makes it 18 millions. There is no way we can overflow the multiplication here!\n', '        uint sharesToRelease = (company.sharesInCirculation * company.percentageSharesToRelease)/100;\n', '        \n', '        // Max 500 tokens can be relased\n', '        if (sharesToRelease > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\n', '            sharesToRelease = MAX_SHARES_RELEASE_IN_ONE_CYCLE;\n', '        }\n', '        \n', '        if (sharesToRelease > 0) {\n', '            company.sharesInCirculation += uint32(sharesToRelease);\n', '            _sharesBought(company.shareHolders, company.ceoOfCompany, sharesToRelease);\n', '            emit SharesReleased(_companyId, company.ceoOfCompany, sharesToRelease, company.nextSharesReleaseTime);\n', '        }\n', '    }\n', '    \n', '    function _updateTradingVolume(uint _companyId, address _from, address _to, uint _amount) \n', '    internal {\n', '        Traders storage traders = companyIdToTraders[_companyId];\n', '        _updateTradingVolume(traders, _from, _to, _amount);\n', '        \n', '        if (now < traders.relaseTime) {\n', '            return;\n', '        }\n', '        \n', '        Company storage company = companies[_companyId];\n', '        uint _newShares = company.sharesInCirculation/100;\n', '        if (_newShares > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\n', '            _newShares = 100;\n', '        }\n', '        company.sharesInCirculation += uint32(_newShares);\n', '         _sharesBought(company.shareHolders, traders.winningTrader, _newShares);\n', '        _updateCEOIfRequired(company, _companyId, traders.winningTrader);\n', '        emit TradingWinnerAnnounced(_companyId, traders.winningTrader, _newShares);\n', '        _clearWinner(traders);\n', '    }\n', '}\n', '\n', 'contract MarketBase is CompanyMain {\n', '    \n', '    function MarketBase() public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = msg.sender;\n', '    }\n', '    \n', '    struct Order {\n', '        // Owner who placed the order\n', '        address owner;\n', '                \n', '        // Total number of tokens in order\n', '        uint32 amount;\n', '        \n', '        // Amount of tokens that are already bought/sold by other people\n', '        uint32 amountFilled;\n', '        \n', '        // Type of the order\n', '        OrderType orderType;\n', '        \n', '        // Price of one share\n', '        uint pricePerShare;\n', '    }\n', '    \n', '    // A mapping of companyId to orders\n', '    mapping (uint => Order[]) companyIdToOrders;\n', '    \n', '    // _amount > 0\n', '    function _createOrder(uint _companyId, uint _amount, uint _pricePerShare, OrderType _orderType) \n', '    internal {\n', '        Order memory order = Order({\n', '            owner : msg.sender,\n', '            pricePerShare : _pricePerShare,\n', '            amount : uint32(_amount),\n', '            amountFilled : 0,\n', '            orderType : _orderType\n', '        });\n', '        \n', '        uint index = companyIdToOrders[_companyId].push(order) - 1;\n', '        emit OrderPlaced(_companyId, index, order.amount, order.pricePerShare, order.orderType, msg.sender);\n', '    }\n', '    \n', '    // Place a sell request if seller have enough tokens!\n', '    function placeSellRequest(uint _companyId, uint _amount, uint _pricePerShare) \n', '    whenNotPaused\n', '    external {\n', '        require (_amount > 0);\n', '        require (_pricePerShare > 0);\n', '\n', '        // Seller should have enough tokens to place a sell order!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\n', '\n', '        _transfer(_companyId, msg.sender, this, _amount);\n', '        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Sell);\n', '    }\n', '    \n', '    // Place a request to buy shares of a particular company!\n', '    function placeBuyRequest(uint _companyId, uint _amount, uint _pricePerShare) \n', '    external \n', '    payable \n', '    whenNotPaused {\n', '        require(_amount > 0);\n', '        require(_pricePerShare > 0);\n', '        require(_amount == uint(uint32(_amount)));\n', '        \n', '        // Should have enough eth!\n', '        require(msg.value >= _amount * _pricePerShare);\n', '\n', '        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Buy);\n', '    }\n', '    \n', '    // Cancel a placed order!\n', '    function cancelRequest(uint _companyId, uint _orderIndex) \n', '    external {        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        \n', '        require(order.owner == msg.sender);\n', '        \n', '        uint sharesRemaining = _getRemainingSharesInOrder(order);\n', '        \n', '        require(sharesRemaining > 0);\n', '\n', '        order.amountFilled += uint32(sharesRemaining);\n', '        \n', '        if (order.orderType == OrderType.Buy) {\n', '\n', '             // If its a buy order, transfer the ether back to owner;\n', '            uint price = _getTotalPrice(order, sharesRemaining);\n', '            \n', '            // Sends money back to owner!\n', '            msg.sender.transfer(price);\n', '        } else {\n', '            \n', '            // Send the tokens back to the owner\n', '            _transfer(_companyId, this, msg.sender, sharesRemaining);\n', '        }\n', '\n', '        emit OrderCancelled(_companyId, _orderIndex);\n', '    }\n', '    \n', '    // Fill the sell order!\n', '    function fillSellOrder(uint _companyId, uint _orderIndex, uint _amount) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        require(_amount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Sell);\n', '        \n', '        require(msg.sender != order.owner);\n', '       \n', '        _verifyRemainingSharesInOrder(order, _amount);\n', '\n', '        uint price = _getTotalPrice(order, _amount);\n', '        require(msg.value >= price);\n', '\n', '        order.amountFilled += uint32(_amount);\n', '        \n', '        // transfer tokens to the buyer\n', '        _transfer(_companyId, this, msg.sender, _amount);\n', '        \n', '        // send money to seller after taking a small share\n', '        _transferOrderMoney(price, order.owner);  \n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\n', '        \n', '        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\n', '    }\n', '    \n', '    // Fill the sell order!\n', '    function fillSellOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \n', '    whenNotPaused\n', '    external \n', '    payable {\n', '        require(_maxAmount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Sell);\n', '        \n', '        require(msg.sender != order.owner);\n', '       \n', '        uint buyableShares = _getRemainingSharesInOrder(order);\n', '        require(buyableShares > 0);\n', '        \n', '        if (buyableShares > _maxAmount) {\n', '            buyableShares = _maxAmount;\n', '        }\n', '\n', '        uint price = _getTotalPrice(order, buyableShares);\n', '        require(msg.value >= price);\n', '\n', '        order.amountFilled += uint32(buyableShares);\n', '        \n', '        // transfer tokens to the buyer\n', '        _transfer(_companyId, this, msg.sender, buyableShares);\n', '        \n', '        // send money to seller after taking a small share\n', '        _transferOrderMoney(price, order.owner); \n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\n', '        \n', '        uint buyerProceeds = msg.value - price;\n', '        msg.sender.transfer(buyerProceeds);\n', '        \n', '        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\n', '    }\n', '\n', '    // Fill the buy order!\n', '    function fillBuyOrder(uint _companyId, uint _orderIndex, uint _amount) \n', '    whenNotPaused\n', '    external {\n', '        require(_amount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Buy);\n', '        \n', '        require(msg.sender != order.owner);\n', '        \n', '        // There should exist enought shares to fulfill the request!\n', '        _verifyRemainingSharesInOrder(order, _amount);\n', '        \n', '        // The seller have enought tokens to fulfill the request!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\n', '        \n', '        order.amountFilled += uint32(_amount);\n', '        \n', '        // transfer the tokens from the seller to the buyer!\n', '        _transfer(_companyId, msg.sender, order.owner, _amount);\n', '        \n', '        uint price = _getTotalPrice(order, _amount);\n', '        \n', '        // transfer the money from this contract to the seller\n', '        _transferOrderMoney(price , msg.sender);\n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\n', '\n', '        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\n', '    }\n', '    \n', '    // Fill buy order partially if possible!\n', '    function fillBuyOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \n', '    whenNotPaused\n', '    external {\n', '        require(_maxAmount > 0);\n', '        \n', '        Order storage order = companyIdToOrders[_companyId][_orderIndex];\n', '        require(order.orderType == OrderType.Buy);\n', '        \n', '        require(msg.sender != order.owner);\n', '        \n', '        // There should exist enought shares to fulfill the request!\n', '        uint buyableShares = _getRemainingSharesInOrder(order);\n', '        require(buyableShares > 0);\n', '        \n', '        if ( buyableShares > _maxAmount) {\n', '            buyableShares = _maxAmount;\n', '        }\n', '        \n', '        // The seller have enought tokens to fulfill the request!\n', '        _verifyOwnershipOfTokens(_companyId, msg.sender, buyableShares);\n', '        \n', '        order.amountFilled += uint32(buyableShares);\n', '        \n', '        // transfer the tokens from the seller to the buyer!\n', '        _transfer(_companyId, msg.sender, order.owner, buyableShares);\n', '        \n', '        uint price = _getTotalPrice(order, buyableShares);\n', '        \n', '        // transfer the money from this contract to the seller\n', '        _transferOrderMoney(price , msg.sender);\n', '        \n', '        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\n', '\n', '        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\n', '    }\n', '\n', '    // transfer money to the owner!\n', '    function _transferOrderMoney(uint _price, address _owner) \n', '    internal {\n', '        uint priceCut = (_price * ORDER_CUT)/100;\n', '        _owner.transfer(_price - priceCut);\n', '        withdrawableBalance += priceCut;\n', '    }\n', '\n', '    // Returns the price for _amount tokens for the given order\n', '    // _amount > 0\n', '    // order should be verified\n', '    function _getTotalPrice(Order storage _order, uint _amount) \n', '    view\n', '    internal \n', '    returns (uint) {\n', '        return _amount * _order.pricePerShare;\n', '    }\n', '    \n', '    // Gets the number of remaining shares that can be bought or sold under this order\n', '    function _getRemainingSharesInOrder(Order storage _order) \n', '    view\n', '    internal \n', '    returns (uint) {\n', '        return _order.amount - _order.amountFilled;\n', '    }\n', '\n', '    // Verifies if the order have _amount shares to buy/sell\n', '    // _amount > 0\n', '    function _verifyRemainingSharesInOrder(Order storage _order, uint _amount) \n', '    view\n', '    internal {\n', '        require(_getRemainingSharesInOrder(_order) >= _amount);\n', '    }\n', '\n', "    // Checks if the owner have at least '_amount' shares of the company\n", '    // _amount > 0\n', '    function _verifyOwnershipOfTokens(uint _companyId, address _owner, uint _amount) \n', '    view\n', '    internal {\n', '        require(companies[_companyId].shareHolders.ownerAddressToShares[_owner] >= _amount);\n', '    }\n', '    \n', '    // Returns the length of array! All orders might not be active\n', '    function getNumberOfOrders(uint _companyId) \n', '    view\n', '    external \n', '    returns (uint numberOfOrders) {\n', '        numberOfOrders = companyIdToOrders[_companyId].length;\n', '    }\n', '\n', '    function getOrderDetails(uint _comanyId, uint _orderIndex) \n', '    view\n', '    external \n', '    returns (address _owner,\n', '        uint _pricePerShare,\n', '        uint _amount,\n', '        uint _amountFilled,\n', '        OrderType _orderType) {\n', '            Order storage order =  companyIdToOrders[_comanyId][_orderIndex];\n', '            \n', '            _owner = order.owner;\n', '            _pricePerShare = order.pricePerShare;\n', '            _amount = order.amount;\n', '            _amountFilled = order.amountFilled;\n', '            _orderType = order.orderType;\n', '    }\n', '    \n', '    function withdrawBalance(address _address) \n', '    onlyCLevel\n', '    external {\n', '        require(_address != 0x0);\n', '        uint balance = withdrawableBalance;\n', '        withdrawableBalance = 0;\n', '        _address.transfer(balance);\n', '    }\n', '    \n', '    // Only when the contract is paused and there is a subtle bug!\n', '    function kill(address _address) \n', '    onlyCLevel\n', '    whenPaused\n', '    external {\n', '        require(_address != 0x0);\n', '        selfdestruct(_address);\n', '    }\n', '}']
