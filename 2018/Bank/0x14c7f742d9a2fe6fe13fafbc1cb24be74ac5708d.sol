['pragma solidity ^0.4.23;\n', '\n', '/*\n', '\n', 'P3D Charity Mining Pool\n', '\n', '- Splits deposit according to feeDivisor (default is 4 = 25% donation)\n', '    - Sends user donation plus current dividends to charity address (Giveth)\n', '    - Uses the rest to buy P3D tokens under the sender&#39;s masternode\n', '    - feeDivisor can be from 2 to 10 (50% to 10% donation range)\n', '- Dividends accumulated by miner can be sent as donation at anytime\n', '- Donors can sell their share of tokens at anytime and withdraw the ETH value!\n', '\n', 'https://discord.gg/N4UShc3\n', '\n', '*/\n', '\n', 'contract ERC20Interface {\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', 'contract POWH {\n', '    function buy(address) public payable returns(uint256);\n', '    function sell(uint256) public;\n', '    function withdraw() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '}\n', '\n', 'contract CharityMiner {\n', '    using SafeMath for uint256;\n', '    \n', '    // Modifiers\n', '    modifier notP3d(address aContract) {\n', '        require(aContract != address(p3d));\n', '        _;\n', '    }\n', '    \n', '    // Events\n', '    event Deposit(uint256 amount, address depositer, uint256 donation);\n', '    event Withdraw(uint256 tokens, address depositer, uint256 tokenValue, uint256 donation);\n', '    event Dividends(uint256 amount, address sender);\n', '    event Paused(bool paused);\n', '    \n', '    // Public Variables\n', '    bool public paused = false;\n', '    address public charityAddress = 0x8f951903C9360345B4e1b536c7F5ae8f88A64e79; // Giveth\n', '    address public owner;\n', '    address public P3DAddress;\n', '    address public largestDonor;\n', '    address public lastDonor;\n', '    uint public totalDonors;\n', '    uint public totalDonated;\n', '    uint public totalDonations;\n', '    uint public largestDonation;\n', '    uint public currentHolders;\n', '    uint public totalDividends;\n', '    \n', '    // Public Mappings\n', '    mapping( address => bool ) public donor;\n', '    mapping( address => uint256 ) public userTokens;\n', '    mapping( address => uint256 ) public userDonations;\n', '    \n', '    // PoWH Contract\n', '    POWH p3d;\n', '\t\n', '\t// Constructor\n', '\tconstructor(address powh) public {\n', '\t    p3d = POWH(powh);\n', '\t    P3DAddress = powh;\n', '\t    owner = msg.sender;\n', '\t}\n', '\t\n', '\t// Pause\n', '\t// - In case charity address is no longer active or deposits have to be paused for unexpected reason\n', '\t// - Cannot be paused while anyone owns tokens\n', '\tfunction pause() public {\n', '\t    require(msg.sender == owner && myTokens() == 0);\n', '\t    paused = !paused;\n', '\t    \n', '\t    emit Paused(paused);\n', '\t}\n', '\t\n', '\t// Fallback\n', '\t// - Easy deposit, sets default feeDivisor\n', '\tfunction() payable public {\n', '\t    if(msg.sender != address(p3d)) { // Need to receive divs from P3D contract\n', '    \t    uint8 feeDivisor = 4; // Default 25% donation\n', '    \t    deposit(feeDivisor);\n', '\t    }\n', '\t}\n', '\n', '\t// Deposit\n', '    // - Divide deposit by feeDivisor then add divs and send as donation\n', '\t// - Use the rest to buy P3D tokens under sender&#39;s masternode\n', '\tfunction deposit(uint8 feeDivisor) payable public {\n', '\t    require(msg.value > 100000 && !paused);\n', '\t    require(feeDivisor >= 2 && feeDivisor <= 10); // 50% to 10% donation range\n', '\t    \n', '\t    // If we have divs, withdraw them\n', '\t    uint divs = myDividends();\n', '\t    if(divs > 0){\n', '\t        p3d.withdraw();\n', '\t    }\n', '\t    \n', '\t    // Split deposit\n', '\t    uint fee = msg.value.div(feeDivisor);\n', '\t    uint purchase = msg.value.sub(fee);\n', '\t    uint donation = divs.add(fee);\n', '\t    \n', '\t    // Send donation\n', '\t    charityAddress.transfer(donation);\n', '\t    \n', '\t    // Buy tokens\n', '\t    uint tokens = myTokens();\n', '\t    p3d.buy.value(purchase)(msg.sender);\n', '\t    uint newTokens = myTokens().sub(tokens);\n', '\t    \n', '\t    // If new donor, add them to stats\n', '\t    if(!donor[msg.sender]){\n', '\t        donor[msg.sender] = true;\n', '\t        totalDonors += 1;\n', '\t        currentHolders += 1;\n', '\t    }\n', '\t    \n', '\t    // If largest donor, update stats\n', '\t    // Don&#39;t include dividends or token value in user donations\n', '\t    if(fee > largestDonation){ \n', '\t        largestDonation = fee;\n', '\t        largestDonor = msg.sender;\n', '\t    }\n', '\t    \n', '\t    // Update stats and storage\n', '\t    totalDonations += 1;\n', '\t    totalDonated += donation;\n', '\t    totalDividends += divs;\n', '\t    lastDonor = msg.sender;\n', '\t    userDonations[msg.sender] = userDonations[msg.sender].add(fee); \n', '\t    userTokens[msg.sender] = userTokens[msg.sender].add(newTokens);\n', '\t    \n', '\t    // Deposit event\n', '\t    emit Deposit(purchase, msg.sender, donation);\n', '\t}\n', '\t\n', '\t// Withdraw\n', '\t// - Sell user&#39;s tokens and withdraw the eth value, sends divs as donation\n', '\t// - User doesn&#39;t get any of the excess divs\n', '\tfunction withdraw() public {\n', '\t    uint tokens = userTokens[msg.sender];\n', '\t    require(tokens > 0);\n', '\t    \n', '\t    // Save divs and balance\n', '\t    uint divs = myDividends();\n', '\t    uint balance = address(this).balance;\n', '\t    \n', '\t    // Update before we sell\n', '\t    userTokens[msg.sender] = 0;\n', '\t    \n', '\t    // Sell tokens and withdraw\n', '\t    p3d.sell(tokens);\n', '\t    p3d.withdraw();\n', '\t    \n', '\t    // Get value of sold tokens\n', '\t    uint tokenValue = address(this).balance.sub(divs).sub(balance);\n', '\t    \n', '\t    // Send donation and payout\n', '\t    charityAddress.transfer(divs);\n', '\t    msg.sender.transfer(tokenValue);\n', '\t    \n', '\t    // Update stats\n', '\t    totalDonated += divs;\n', '\t    totalDividends += divs;\n', '\t    totalDonations += 1;\n', '\t    currentHolders -= 1;\n', '\t    \n', '\t    // Withdraw event\n', '\t    emit Withdraw(tokens, msg.sender, tokenValue, divs);\n', '\t}\n', '\t\n', '\t// SendDividends\n', '\t// - Withdraw dividends and send as donation (can be called by anyone)\n', '\tfunction sendDividends() public {\n', '\t    uint divs = myDividends();\n', '\t    // Don&#39;t want to spam them with tiny donations\n', '\t    require(divs > 100000);\n', '\t    p3d.withdraw();\n', '\t    \n', '\t    // Send donation\n', '\t    charityAddress.transfer(divs);\n', '\t    \n', '\t    // Update stats\n', '\t    totalDonated += divs;\n', '\t    totalDividends += divs;\n', '\t    totalDonations += 1;\n', '\t    \n', '\t    // Dividends event\n', '\t    emit Dividends(divs, msg.sender);\n', '\t}\n', '\t\n', '    // MyTokens\n', '    // - Retun tokens owned by this contract\n', '    function myTokens() public view returns(uint256) {\n', '        return p3d.myTokens();\n', '    }\n', '    \n', '\t// MyDividends\n', '\t// - Return contract&#39;s current dividends including referral bonus\n', '\tfunction myDividends() public view returns(uint256) {\n', '        return p3d.myDividends(true);\n', '    }\n', '\t\n', '\t// Rescue function to transfer tokens. Cannot be used on P3D.\n', '\tfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public notP3d(tokenAddress) returns (bool success) {\n', '\t\trequire(msg.sender == owner);\n', '\t\treturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '\t}\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/*\n', '\n', 'P3D Charity Mining Pool\n', '\n', '- Splits deposit according to feeDivisor (default is 4 = 25% donation)\n', '    - Sends user donation plus current dividends to charity address (Giveth)\n', "    - Uses the rest to buy P3D tokens under the sender's masternode\n", '    - feeDivisor can be from 2 to 10 (50% to 10% donation range)\n', '- Dividends accumulated by miner can be sent as donation at anytime\n', '- Donors can sell their share of tokens at anytime and withdraw the ETH value!\n', '\n', 'https://discord.gg/N4UShc3\n', '\n', '*/\n', '\n', 'contract ERC20Interface {\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', 'contract POWH {\n', '    function buy(address) public payable returns(uint256);\n', '    function sell(uint256) public;\n', '    function withdraw() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '}\n', '\n', 'contract CharityMiner {\n', '    using SafeMath for uint256;\n', '    \n', '    // Modifiers\n', '    modifier notP3d(address aContract) {\n', '        require(aContract != address(p3d));\n', '        _;\n', '    }\n', '    \n', '    // Events\n', '    event Deposit(uint256 amount, address depositer, uint256 donation);\n', '    event Withdraw(uint256 tokens, address depositer, uint256 tokenValue, uint256 donation);\n', '    event Dividends(uint256 amount, address sender);\n', '    event Paused(bool paused);\n', '    \n', '    // Public Variables\n', '    bool public paused = false;\n', '    address public charityAddress = 0x8f951903C9360345B4e1b536c7F5ae8f88A64e79; // Giveth\n', '    address public owner;\n', '    address public P3DAddress;\n', '    address public largestDonor;\n', '    address public lastDonor;\n', '    uint public totalDonors;\n', '    uint public totalDonated;\n', '    uint public totalDonations;\n', '    uint public largestDonation;\n', '    uint public currentHolders;\n', '    uint public totalDividends;\n', '    \n', '    // Public Mappings\n', '    mapping( address => bool ) public donor;\n', '    mapping( address => uint256 ) public userTokens;\n', '    mapping( address => uint256 ) public userDonations;\n', '    \n', '    // PoWH Contract\n', '    POWH p3d;\n', '\t\n', '\t// Constructor\n', '\tconstructor(address powh) public {\n', '\t    p3d = POWH(powh);\n', '\t    P3DAddress = powh;\n', '\t    owner = msg.sender;\n', '\t}\n', '\t\n', '\t// Pause\n', '\t// - In case charity address is no longer active or deposits have to be paused for unexpected reason\n', '\t// - Cannot be paused while anyone owns tokens\n', '\tfunction pause() public {\n', '\t    require(msg.sender == owner && myTokens() == 0);\n', '\t    paused = !paused;\n', '\t    \n', '\t    emit Paused(paused);\n', '\t}\n', '\t\n', '\t// Fallback\n', '\t// - Easy deposit, sets default feeDivisor\n', '\tfunction() payable public {\n', '\t    if(msg.sender != address(p3d)) { // Need to receive divs from P3D contract\n', '    \t    uint8 feeDivisor = 4; // Default 25% donation\n', '    \t    deposit(feeDivisor);\n', '\t    }\n', '\t}\n', '\n', '\t// Deposit\n', '    // - Divide deposit by feeDivisor then add divs and send as donation\n', "\t// - Use the rest to buy P3D tokens under sender's masternode\n", '\tfunction deposit(uint8 feeDivisor) payable public {\n', '\t    require(msg.value > 100000 && !paused);\n', '\t    require(feeDivisor >= 2 && feeDivisor <= 10); // 50% to 10% donation range\n', '\t    \n', '\t    // If we have divs, withdraw them\n', '\t    uint divs = myDividends();\n', '\t    if(divs > 0){\n', '\t        p3d.withdraw();\n', '\t    }\n', '\t    \n', '\t    // Split deposit\n', '\t    uint fee = msg.value.div(feeDivisor);\n', '\t    uint purchase = msg.value.sub(fee);\n', '\t    uint donation = divs.add(fee);\n', '\t    \n', '\t    // Send donation\n', '\t    charityAddress.transfer(donation);\n', '\t    \n', '\t    // Buy tokens\n', '\t    uint tokens = myTokens();\n', '\t    p3d.buy.value(purchase)(msg.sender);\n', '\t    uint newTokens = myTokens().sub(tokens);\n', '\t    \n', '\t    // If new donor, add them to stats\n', '\t    if(!donor[msg.sender]){\n', '\t        donor[msg.sender] = true;\n', '\t        totalDonors += 1;\n', '\t        currentHolders += 1;\n', '\t    }\n', '\t    \n', '\t    // If largest donor, update stats\n', "\t    // Don't include dividends or token value in user donations\n", '\t    if(fee > largestDonation){ \n', '\t        largestDonation = fee;\n', '\t        largestDonor = msg.sender;\n', '\t    }\n', '\t    \n', '\t    // Update stats and storage\n', '\t    totalDonations += 1;\n', '\t    totalDonated += donation;\n', '\t    totalDividends += divs;\n', '\t    lastDonor = msg.sender;\n', '\t    userDonations[msg.sender] = userDonations[msg.sender].add(fee); \n', '\t    userTokens[msg.sender] = userTokens[msg.sender].add(newTokens);\n', '\t    \n', '\t    // Deposit event\n', '\t    emit Deposit(purchase, msg.sender, donation);\n', '\t}\n', '\t\n', '\t// Withdraw\n', "\t// - Sell user's tokens and withdraw the eth value, sends divs as donation\n", "\t// - User doesn't get any of the excess divs\n", '\tfunction withdraw() public {\n', '\t    uint tokens = userTokens[msg.sender];\n', '\t    require(tokens > 0);\n', '\t    \n', '\t    // Save divs and balance\n', '\t    uint divs = myDividends();\n', '\t    uint balance = address(this).balance;\n', '\t    \n', '\t    // Update before we sell\n', '\t    userTokens[msg.sender] = 0;\n', '\t    \n', '\t    // Sell tokens and withdraw\n', '\t    p3d.sell(tokens);\n', '\t    p3d.withdraw();\n', '\t    \n', '\t    // Get value of sold tokens\n', '\t    uint tokenValue = address(this).balance.sub(divs).sub(balance);\n', '\t    \n', '\t    // Send donation and payout\n', '\t    charityAddress.transfer(divs);\n', '\t    msg.sender.transfer(tokenValue);\n', '\t    \n', '\t    // Update stats\n', '\t    totalDonated += divs;\n', '\t    totalDividends += divs;\n', '\t    totalDonations += 1;\n', '\t    currentHolders -= 1;\n', '\t    \n', '\t    // Withdraw event\n', '\t    emit Withdraw(tokens, msg.sender, tokenValue, divs);\n', '\t}\n', '\t\n', '\t// SendDividends\n', '\t// - Withdraw dividends and send as donation (can be called by anyone)\n', '\tfunction sendDividends() public {\n', '\t    uint divs = myDividends();\n', "\t    // Don't want to spam them with tiny donations\n", '\t    require(divs > 100000);\n', '\t    p3d.withdraw();\n', '\t    \n', '\t    // Send donation\n', '\t    charityAddress.transfer(divs);\n', '\t    \n', '\t    // Update stats\n', '\t    totalDonated += divs;\n', '\t    totalDividends += divs;\n', '\t    totalDonations += 1;\n', '\t    \n', '\t    // Dividends event\n', '\t    emit Dividends(divs, msg.sender);\n', '\t}\n', '\t\n', '    // MyTokens\n', '    // - Retun tokens owned by this contract\n', '    function myTokens() public view returns(uint256) {\n', '        return p3d.myTokens();\n', '    }\n', '    \n', '\t// MyDividends\n', "\t// - Return contract's current dividends including referral bonus\n", '\tfunction myDividends() public view returns(uint256) {\n', '        return p3d.myDividends(true);\n', '    }\n', '\t\n', '\t// Rescue function to transfer tokens. Cannot be used on P3D.\n', '\tfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public notP3d(tokenAddress) returns (bool success) {\n', '\t\trequire(msg.sender == owner);\n', '\t\treturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '\t}\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
