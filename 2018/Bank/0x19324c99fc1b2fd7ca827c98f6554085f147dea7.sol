['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath Library\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title BlockMarketCore\n', ' */\n', 'contract BlockMarket is Ownable {\n', '  struct Stock {\n', '    string  name;\n', '    uint256 priceIncrease;\n', '    uint256 dividendAmount;\n', '    uint256 lastAction;\n', '    uint256 dividendsPaid;\n', '  }\n', '\n', '  struct Share {\n', '    address holder;\n', '    uint256 purchasePrice;\n', '  }\n', '\n', '  Stock[] public stocks;\n', '  Share[] public shares;\n', '  mapping (uint256 => uint256[]) public stockShares;\n', '\n', '  event CompanyListed(string company, uint256 basePrice);\n', '  event DividendPaid(address shareholder, uint256 amount);\n', '  event ShareSold(\n', '    uint256 stockId,\n', '    uint256 shareId,\n', '    uint256 oldPrice,\n', '    uint256 newPrice,\n', '    address oldOwner,\n', '    address newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev A fallback function to catch, uh... let&#39;s call them gifts.\n', '   */\n', '  function () payable public { }\n', '\n', '  /**\n', '   * @dev Adds a new stock to the game\n', '   * @param _name the name of the stock (e.g. "Kodak")\n', '   * @param _initialPrice the original cost of the stock&#39;s shares (in Wei)\n', '   * @param _priceIncrease the amount by which the shares should increase upon sale (i.e. 120 = 20% increase)\n', '   * @param _dividendAmount the amount of each purchase that should be split among dividend recipients\n', '   * @param _numShares the number of shares of this stock available for purchase\n', '   */\n', '  function addStock(\n', '    string  _name,\n', '    uint256 _initialPrice,\n', '    uint256 _priceIncrease,\n', '    uint256 _dividendAmount,\n', '    uint8   _numShares\n', '  ) public onlyOwner returns (uint256 stockId) {\n', '    stockId = stocks.length;\n', '\n', '    stocks.push(\n', '      Stock(\n', '        _name,\n', '        _priceIncrease == 0 ? 130 : _priceIncrease, // 30% by default\n', '        _dividendAmount == 0 ? 110 : _dividendAmount, // 10% by default\n', '        block.timestamp,\n', '        0\n', '      )\n', '    );\n', '\n', '    for(uint8 i = 0; i < _numShares; i++) {\n', '      stockShares[stockId].push(shares.length);\n', '      shares.push(Share(owner, _initialPrice));\n', '    }\n', '\n', '    CompanyListed(_name, _initialPrice);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase a share from its current owner\n', '   * @param _stockId the ID of the stock that owns the share\n', '   * @param _shareId the ID of the specific share to purchase\n', '   */\n', '  function purchase(uint256 _stockId, uint256 _shareId) public payable {\n', '    require(_stockId < stocks.length && _shareId < shares.length);\n', '\n', '    // look up the assets\n', '    Stock storage stock = stocks[_stockId];\n', '    uint256[] storage sharesForStock = stockShares[_stockId];\n', '    Share storage share = shares[sharesForStock[_shareId]];\n', '\n', '    // look up the share&#39;s current holder\n', '    address previousHolder = share.holder;\n', '\n', '    // determine the current price for the share\n', '    uint256 currentPrice = getPurchasePrice(\n', '      share.purchasePrice,\n', '      stock.priceIncrease\n', '    );\n', '    require(msg.value >= currentPrice);\n', '\n', '    // return any excess payment\n', '    if (msg.value > currentPrice) {\n', '      msg.sender.transfer(SafeMath.sub(msg.value, currentPrice));\n', '    }\n', '\n', '    // calculate dividend holders&#39; shares\n', '    uint256 dividendPerRecipient = getDividendPayout(\n', '      currentPrice,\n', '      stock.dividendAmount,\n', '      sharesForStock.length - 1\n', '    );\n', '\n', '    // calculate the previous owner&#39;s share\n', '    uint256 previousHolderShare = SafeMath.sub(\n', '      currentPrice,\n', '      SafeMath.mul(dividendPerRecipient, sharesForStock.length - 1)\n', '    );\n', '\n', '    // calculate the transaction fee - 1/40 = 2.5% fee\n', '    uint256 fee = SafeMath.div(previousHolderShare, 40);\n', '    owner.transfer(fee);\n', '\n', '    // payout the previous shareholder\n', '    previousHolder.transfer(SafeMath.sub(previousHolderShare, fee));\n', '\n', '    // payout the dividends\n', '    for(uint8 i = 0; i < sharesForStock.length; i++) {\n', '      if (i != _shareId) {\n', '        shares[sharesForStock[i]].holder.transfer(dividendPerRecipient);\n', '        stock.dividendsPaid = SafeMath.add(stock.dividendsPaid, dividendPerRecipient);\n', '        DividendPaid(\n', '          shares[sharesForStock[i]].holder,\n', '          dividendPerRecipient\n', '        );\n', '      }\n', '    }\n', '\n', '    ShareSold(\n', '      _stockId,\n', '      _shareId,\n', '      share.purchasePrice,\n', '      currentPrice,\n', '      share.holder,\n', '      msg.sender\n', '    );\n', '\n', '    // update share information\n', '    share.holder = msg.sender;\n', '    share.purchasePrice = currentPrice;\n', '    stock.lastAction = block.timestamp;\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the current purchase price for the given stock share\n', '   * @param _stockId the ID of the stock that owns the share\n', '   * @param _shareId the ID of the specific share to purchase\n', '   */\n', '  function getCurrentPrice(\n', '    uint256 _stockId,\n', '    uint256 _shareId\n', '  ) public view returns (uint256 currentPrice) {\n', '    require(_stockId < stocks.length && _shareId < shares.length);\n', '    currentPrice = SafeMath.div(\n', '      SafeMath.mul(stocks[_stockId].priceIncrease, shares[_shareId].purchasePrice),\n', '      100\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the current token owner&#39;s payout amount if the token sells\n', '   * @param _currentPrice the current total sale price of the asset\n', '   * @param _priceIncrease the percentage of price increase per sale\n', '   */\n', '  function getPurchasePrice(\n', '    uint256 _currentPrice,\n', '    uint256 _priceIncrease\n', '  ) internal pure returns (uint256 currentPrice) {\n', '    currentPrice = SafeMath.div(\n', '      SafeMath.mul(_currentPrice, _priceIncrease),\n', '      100\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the payout of each dividend recipient in the event of a share sale.\n', '   * @param _purchasePrice the current total sale price of the asset\n', '   * @param _stockDividend the percentage of the sale allocated for dividends\n', '   * @param _numDividends the number of dividend holders to share the total dividend amount\n', '   */\n', '  function getDividendPayout(\n', '    uint256 _purchasePrice,\n', '    uint256 _stockDividend,\n', '    uint256 _numDividends\n', '  ) public pure returns (uint256 dividend) {\n', '    uint256 dividendPerRecipient = SafeMath.sub(\n', '      SafeMath.div(SafeMath.mul(_purchasePrice, _stockDividend), 100),\n', '      _purchasePrice\n', '    );\n', '    dividend = SafeMath.div(dividendPerRecipient, _numDividends);\n', '  }\n', '\n', '  /**\n', '  * @dev Fetches the number of stocks available\n', '  */\n', '  function getStockCount() public view returns (uint256) {\n', '    return stocks.length;\n', '  }\n', '\n', '  /**\n', '  * @dev Fetches the share IDs connected to the given stock\n', '  * @param _stockId the ID of the stock to count shares of\n', '  */\n', '  function getStockShares(uint256 _stockId) public view returns (uint256[]) {\n', '    return stockShares[_stockId];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers a set amount of ETH from the contract to the specified address\n', '   * @notice Proceeds are paid out right away, but the contract might receive unexpected funds\n', '   */\n', '  function withdraw(uint256 _amount, address _destination) public onlyOwner {\n', '    require(_destination != address(0));\n', '    require(_amount <= this.balance);\n', '    _destination.transfer(_amount == 0 ? this.balance : _amount);\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath Library\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title BlockMarketCore\n', ' */\n', 'contract BlockMarket is Ownable {\n', '  struct Stock {\n', '    string  name;\n', '    uint256 priceIncrease;\n', '    uint256 dividendAmount;\n', '    uint256 lastAction;\n', '    uint256 dividendsPaid;\n', '  }\n', '\n', '  struct Share {\n', '    address holder;\n', '    uint256 purchasePrice;\n', '  }\n', '\n', '  Stock[] public stocks;\n', '  Share[] public shares;\n', '  mapping (uint256 => uint256[]) public stockShares;\n', '\n', '  event CompanyListed(string company, uint256 basePrice);\n', '  event DividendPaid(address shareholder, uint256 amount);\n', '  event ShareSold(\n', '    uint256 stockId,\n', '    uint256 shareId,\n', '    uint256 oldPrice,\n', '    uint256 newPrice,\n', '    address oldOwner,\n', '    address newOwner\n', '  );\n', '\n', '  /**\n', "   * @dev A fallback function to catch, uh... let's call them gifts.\n", '   */\n', '  function () payable public { }\n', '\n', '  /**\n', '   * @dev Adds a new stock to the game\n', '   * @param _name the name of the stock (e.g. "Kodak")\n', "   * @param _initialPrice the original cost of the stock's shares (in Wei)\n", '   * @param _priceIncrease the amount by which the shares should increase upon sale (i.e. 120 = 20% increase)\n', '   * @param _dividendAmount the amount of each purchase that should be split among dividend recipients\n', '   * @param _numShares the number of shares of this stock available for purchase\n', '   */\n', '  function addStock(\n', '    string  _name,\n', '    uint256 _initialPrice,\n', '    uint256 _priceIncrease,\n', '    uint256 _dividendAmount,\n', '    uint8   _numShares\n', '  ) public onlyOwner returns (uint256 stockId) {\n', '    stockId = stocks.length;\n', '\n', '    stocks.push(\n', '      Stock(\n', '        _name,\n', '        _priceIncrease == 0 ? 130 : _priceIncrease, // 30% by default\n', '        _dividendAmount == 0 ? 110 : _dividendAmount, // 10% by default\n', '        block.timestamp,\n', '        0\n', '      )\n', '    );\n', '\n', '    for(uint8 i = 0; i < _numShares; i++) {\n', '      stockShares[stockId].push(shares.length);\n', '      shares.push(Share(owner, _initialPrice));\n', '    }\n', '\n', '    CompanyListed(_name, _initialPrice);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase a share from its current owner\n', '   * @param _stockId the ID of the stock that owns the share\n', '   * @param _shareId the ID of the specific share to purchase\n', '   */\n', '  function purchase(uint256 _stockId, uint256 _shareId) public payable {\n', '    require(_stockId < stocks.length && _shareId < shares.length);\n', '\n', '    // look up the assets\n', '    Stock storage stock = stocks[_stockId];\n', '    uint256[] storage sharesForStock = stockShares[_stockId];\n', '    Share storage share = shares[sharesForStock[_shareId]];\n', '\n', "    // look up the share's current holder\n", '    address previousHolder = share.holder;\n', '\n', '    // determine the current price for the share\n', '    uint256 currentPrice = getPurchasePrice(\n', '      share.purchasePrice,\n', '      stock.priceIncrease\n', '    );\n', '    require(msg.value >= currentPrice);\n', '\n', '    // return any excess payment\n', '    if (msg.value > currentPrice) {\n', '      msg.sender.transfer(SafeMath.sub(msg.value, currentPrice));\n', '    }\n', '\n', "    // calculate dividend holders' shares\n", '    uint256 dividendPerRecipient = getDividendPayout(\n', '      currentPrice,\n', '      stock.dividendAmount,\n', '      sharesForStock.length - 1\n', '    );\n', '\n', "    // calculate the previous owner's share\n", '    uint256 previousHolderShare = SafeMath.sub(\n', '      currentPrice,\n', '      SafeMath.mul(dividendPerRecipient, sharesForStock.length - 1)\n', '    );\n', '\n', '    // calculate the transaction fee - 1/40 = 2.5% fee\n', '    uint256 fee = SafeMath.div(previousHolderShare, 40);\n', '    owner.transfer(fee);\n', '\n', '    // payout the previous shareholder\n', '    previousHolder.transfer(SafeMath.sub(previousHolderShare, fee));\n', '\n', '    // payout the dividends\n', '    for(uint8 i = 0; i < sharesForStock.length; i++) {\n', '      if (i != _shareId) {\n', '        shares[sharesForStock[i]].holder.transfer(dividendPerRecipient);\n', '        stock.dividendsPaid = SafeMath.add(stock.dividendsPaid, dividendPerRecipient);\n', '        DividendPaid(\n', '          shares[sharesForStock[i]].holder,\n', '          dividendPerRecipient\n', '        );\n', '      }\n', '    }\n', '\n', '    ShareSold(\n', '      _stockId,\n', '      _shareId,\n', '      share.purchasePrice,\n', '      currentPrice,\n', '      share.holder,\n', '      msg.sender\n', '    );\n', '\n', '    // update share information\n', '    share.holder = msg.sender;\n', '    share.purchasePrice = currentPrice;\n', '    stock.lastAction = block.timestamp;\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the current purchase price for the given stock share\n', '   * @param _stockId the ID of the stock that owns the share\n', '   * @param _shareId the ID of the specific share to purchase\n', '   */\n', '  function getCurrentPrice(\n', '    uint256 _stockId,\n', '    uint256 _shareId\n', '  ) public view returns (uint256 currentPrice) {\n', '    require(_stockId < stocks.length && _shareId < shares.length);\n', '    currentPrice = SafeMath.div(\n', '      SafeMath.mul(stocks[_stockId].priceIncrease, shares[_shareId].purchasePrice),\n', '      100\n', '    );\n', '  }\n', '\n', '  /**\n', "   * @dev Calculates the current token owner's payout amount if the token sells\n", '   * @param _currentPrice the current total sale price of the asset\n', '   * @param _priceIncrease the percentage of price increase per sale\n', '   */\n', '  function getPurchasePrice(\n', '    uint256 _currentPrice,\n', '    uint256 _priceIncrease\n', '  ) internal pure returns (uint256 currentPrice) {\n', '    currentPrice = SafeMath.div(\n', '      SafeMath.mul(_currentPrice, _priceIncrease),\n', '      100\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the payout of each dividend recipient in the event of a share sale.\n', '   * @param _purchasePrice the current total sale price of the asset\n', '   * @param _stockDividend the percentage of the sale allocated for dividends\n', '   * @param _numDividends the number of dividend holders to share the total dividend amount\n', '   */\n', '  function getDividendPayout(\n', '    uint256 _purchasePrice,\n', '    uint256 _stockDividend,\n', '    uint256 _numDividends\n', '  ) public pure returns (uint256 dividend) {\n', '    uint256 dividendPerRecipient = SafeMath.sub(\n', '      SafeMath.div(SafeMath.mul(_purchasePrice, _stockDividend), 100),\n', '      _purchasePrice\n', '    );\n', '    dividend = SafeMath.div(dividendPerRecipient, _numDividends);\n', '  }\n', '\n', '  /**\n', '  * @dev Fetches the number of stocks available\n', '  */\n', '  function getStockCount() public view returns (uint256) {\n', '    return stocks.length;\n', '  }\n', '\n', '  /**\n', '  * @dev Fetches the share IDs connected to the given stock\n', '  * @param _stockId the ID of the stock to count shares of\n', '  */\n', '  function getStockShares(uint256 _stockId) public view returns (uint256[]) {\n', '    return stockShares[_stockId];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers a set amount of ETH from the contract to the specified address\n', '   * @notice Proceeds are paid out right away, but the contract might receive unexpected funds\n', '   */\n', '  function withdraw(uint256 _amount, address _destination) public onlyOwner {\n', '    require(_destination != address(0));\n', '    require(_amount <= this.balance);\n', '    _destination.transfer(_amount == 0 ? this.balance : _amount);\n', '  }\n', '}']
