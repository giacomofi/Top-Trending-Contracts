['pragma solidity ^0.4.20;\n', '\n', 'contract Universe{\n', '    // Universe contract\n', '    // It is possible to buy planets or other universe-objects from other accounts.\n', '    // If an object has an owner, fees will be paid to that owner until no owner has been found.\n', '    \n', '    struct Item{\n', '        uint256 id;\n', '        string name;\n', '        uint256 price;\n', '        uint256 id_owner;\n', '        address owner;\n', '    }\n', '    \n', '   // bool TESTMODE = true;\n', '    \n', '  //  event pushuint(uint256 push);\n', ' //   event pushstr(string str);\n', '  //  event pusha(address addr);\n', '    \n', '    uint256[4] LevelLimits = [0.05 ether, 0.5 ether, 2 ether, 5 ether];\n', '    uint256[5] devFee = [5,4,3,2,2];\n', '    uint256[5] shareFee = [12,6,4,3,2];\n', '    uint256[5] raisePrice = [100, 35, 25, 17, 15];\n', '    \n', '    \n', '    mapping (uint256 => Item) public ItemList;\n', '    uint256 public current_item_index=1;\n', '    \n', '    address owner;\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function Universe() public{\n', '        owner=msg.sender;\n', '        AddItem("Sun", 1 finney, 0);\n', '        AddItem("Mercury", 1 finney, 1);\n', '        AddItem("Venus", 1 finney, 1);\n', '        AddItem("Earth", 1 finney, 1);\n', '        AddItem("Mars", 1 finney, 1);\n', '        AddItem("Jupiter", 1 finney, 1);\n', '        AddItem("Saturn", 1 finney, 1);\n', '        AddItem("Uranus", 1 finney, 1);\n', '        AddItem("Neptune", 1  finney, 1);\n', '        AddItem("Pluto", 1 finney, 1);\n', '        AddItem("Moon", 1 finney, 4);\n', '    }\n', '    \n', '    function CheckItemExists(uint256 _id) internal returns (bool boolean){\n', '        if (ItemList[_id].price == 0){\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    \n', ' //   function AddItem(string _name, uint256 _price, uint256 _id_owner) public {\n', '    function AddItem(string _name, uint256 _price, uint256 _id_owner) public onlyOwner {\n', '//if (TESTMODE){\n', '//if (_price < (1 finney)){\n', '  //              _price = (1 finney);\n', '    //        }\n', '//}\n', '        //require(_id != 0);\n', '        //require(_id == current_item_index);\n', '        uint256 _id = current_item_index;\n', '\n', '        require(_id_owner != _id);\n', '        require(_id_owner < _id);\n', '\n', '        require(_price >= (1 finney));\n', '        require(_id_owner == 0 || CheckItemExists(_id_owner));\n', '        require(CheckItemExists(_id) != true);\n', '        \n', '     //   uint256 current_id_owner = _id_owner;\n', '        \n', '     //   uint256[] mem_owner;\n', '        \n', '        //pushuint(mem_owner.length);\n', '        \n', '        /*while (current_id_owner != 0){\n', '           \n', '            mem_owner[mem_owner.length-1] = current_id_owner;\n', '            current_id_owner = ItemList[current_id_owner].id_owner;\n', '            \n', '          \n', '            for(uint256 c=0; c<mem_owner.length; c++){\n', '               if(c != (mem_owner.length-1)){\n', '                   if(mem_owner[c] == current_id_owner){\n', '                        pushstr("false");\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '            mem_owner.length += 1;\n', '        }*/\n', '        \n', '        var NewItem = Item(_id, _name, _price, _id_owner, owner);\n', '        ItemList[current_item_index] = NewItem;\n', '        current_item_index++;\n', '        \n', '    }\n', '    \n', '    function ChangeItemOwnerID(uint256 _id, uint256 _new_owner) public onlyOwner {\n', '        require(_new_owner != _id);\n', '        require(_id <= (current_item_index-1));\n', '        require(_id != 0);\n', '        require(_new_owner != 0);\n', '        require(_new_owner <= (current_item_index-1));\n', '        require(ItemList[_id].id_owner == 0);\n', '       \n', '        uint256 current_id_owner = _new_owner;\n', '        uint256[] mem_owner;   \n', '        \n', '         while (current_id_owner != 0){\n', '           \n', '            mem_owner[mem_owner.length-1] = current_id_owner;\n', '            current_id_owner = ItemList[current_id_owner].id_owner;\n', '            \n', '          \n', '            for(uint256 c=0; c<mem_owner.length; c++){\n', '               if(c != (mem_owner.length-1)){\n', '                   if(mem_owner[c] == current_id_owner || mem_owner[c] == _new_owner || mem_owner[c] == _id){\n', '//pushstr("false");\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '            mem_owner.length += 1;\n', '        }  \n', '        \n', '        ItemList[_id].id_owner = _new_owner;\n', '        \n', '    }\n', '\n', '    function DoDividend(uint256 _current_index, uint256 valueShareFee, uint256 id_owner) internal returns (uint256){\n', '            uint256 pow = 0;\n', '            uint256 totalShareFee = 0;\n', '            uint256 current_index = _current_index;\n', '            while (current_index != 0){\n', '                pow = pow + 1;\n', '                current_index = ItemList[current_index].id_owner;\n', '            }\n', '        \n', '            uint256 total_sum = 0;\n', '        \n', '            for (uint256 c2=0; c2<pow; c2++){\n', '                total_sum = total_sum + 2**c2;\n', '            }\n', '        \n', '            if (total_sum != 0){\n', '               // uint256 tot_value = 2**(pow-1);\n', '        \n', '                current_index = id_owner;\n', '        \n', '                while (current_index != 0){\n', '                    uint256 amount = div(mul(valueShareFee, 2**(pow-1)), total_sum);\n', '                    totalShareFee = add(amount, totalShareFee);\n', '                    ItemList[current_index].owner.transfer(amount);\n', '                //    pusha(ItemList[current_index].owner);\n', '                 //   pushuint(amount);\n', '                    \n', '                    pow = sub(pow, 1);\n', '                    current_index = ItemList[current_index].id_owner;\n', '                }\n', '            }\n', '            else{\n', '                ItemList[current_index].owner.transfer(valueShareFee);\n', '            //    pusha(ItemList[current_index].owner);\n', '             //   pushuint(valueShareFee);\n', '                totalShareFee = valueShareFee;\n', '            }\n', '            return totalShareFee;\n', '    }    \n', '    \n', '    function BuyItem(uint256 _id) public payable{\n', '        require(_id > 0 && _id < current_item_index);\n', '        var TheItem = ItemList[_id];\n', '        require(TheItem.owner != msg.sender);\n', '        require(msg.value >= TheItem.price);\n', '    \n', '        uint256 index=0;\n', '        \n', '        for (uint256 c=0; c<LevelLimits.length; c++){\n', '            uint256 value = LevelLimits[c];\n', '            if (TheItem.price < value){\n', '                break;\n', '            }\n', '            index++;\n', '        }\n', '        \n', '        uint256 valueShareFee = div(mul(TheItem.price, shareFee[index]), 100);\n', '        uint256 totalShareFee = 0;\n', '        uint256 valueDevFee = div(mul(TheItem.price, devFee[index]), 100);\n', '        uint256 valueRaisePrice = div(mul(TheItem.price, 100 + raisePrice[index]), 100);\n', '        \n', '        uint256 current_index = TheItem.id_owner;\n', '        \n', '        if (current_index != 0){\n', '            totalShareFee = DoDividend(current_index, valueShareFee, current_index);\n', '        }\n', '        \n', '        owner.transfer(valueDevFee);\n', '        \n', '      //  pushstr("dev");\n', '      //  pushuint(valueDevFee);\n', '        \n', '        \n', '        uint256 totalToOwner = sub(sub(TheItem.price, valueDevFee), totalShareFee);\n', '        \n', '        uint256 totalBack = sub(sub(sub(msg.value, totalToOwner), valueDevFee), totalShareFee);\n', '        \n', '        if (totalBack > 0){\n', '            msg.sender.transfer(totalBack);\n', '        }\n', '        \n', '       // pushstr("owner transfer");\n', '       // pushuint(totalToOwner);\n', '        TheItem.owner.transfer(totalToOwner);\n', '        \n', '        TheItem.owner = msg.sender;\n', '        TheItem.price = valueRaisePrice;\n', '    }\n', '    \n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', '      // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '      return c;\n', '   }\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '    \n', '}']