['pragma solidity ^0.4.16;\n', '\n', ' // ERC Token Standard #20 Interface\n', ' // https://github.com/ethereum/EIPs/issues/20\n', '\n', ' contract ERC20Interface {\n', '\t/// @notice Get the total token supply\n', '\tfunction totalSupply() constant returns (uint256 totalAmount);\n', '\n', '\t/// @notice  Get the account balance of another account with address _owner\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '\t/// @notice  Send _value amount of tokens to address _to\n', '\tfunction transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Send _value amount of tokens from address _from to address _to\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '\t/// @notice  If this function is called again it overwrites the current allowance with _value.\n', '\t/// @notice  this function is required for some DEX functionality\n', '\tfunction approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Returns the amount which _spender is still allowed to withdraw from _owner\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '\t/// @notice  Triggered when tokens are transferred.\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '\t/// @notice  Triggered whenever approve(address _spender, uint256 _value) is called.\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', ' }\n', ' \n', ' contract owned{\n', '\taddress public owner;\n', '\taddress constant supervisor  = 0x2d6808bC989CbEB46cc6dd75a6C90deA50e3e504;\n', '\t\n', '\tfunction owned(){\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/// @notice Functions with this modifier can only be executed by the owner\n', '\tmodifier isOwner {\n', '\t\tassert(msg.sender == owner || msg.sender == supervisor);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t/// @notice Transfer the ownership of this contract\n', '\tfunction transferOwnership(address newOwner);\n', '\t\n', '\tevent ownerChanged(address whoTransferredOwnership, address formerOwner, address newOwner);\n', ' }\n', '\n', 'contract METADOLLAR is ERC20Interface, owned{\n', '\n', '\tstring public constant name = "METADOLLAR";\n', '\tstring public constant symbol = "DOL";\n', '\tuint public constant decimals = 18;\n', '\tuint256 public _totalSupply = 1000000000000000000000000000000;\n', '\tuint256 public icoMin = 1000000000000000000000000000000;\t\t\t\t\t// = 300000; amount is in Tokens, 1.800.000\n', '\tuint256 public preIcoLimit = 1000000000000000000;\t\t\t// = 600000; amount is in tokens, 3.600.000\n', '\tuint256 public countHolders = 0;\t\t\t\t// count how many unique holders have tokens\n', '\tuint256 public amountOfInvestments = 0;\t// amount of collected wei\n', '\t\n', '\tuint256 preICOprice;\t\t\t\t\t\t\t\t\t// price of 1 token in weis for the preICO time\n', '\tuint256 ICOprice;\t\t\t\t\t\t\t\t\t\t// price of 1 token in weis for the ICO time\n', '\tuint256 public currentTokenPrice;\t\t\t\t// current token price in weis\n', '\tuint256 public sellPrice;      // buyback price of one token in weis\n', '\tuint256 public mtdPreAmount;\n', '\tuint256 public ethPreAmount;\n', '\tuint256 public mtdAmount;\n', '\tuint256 public ethAmount;\n', '\t\n', '\tbool public preIcoIsRunning;\n', '\tbool public minimalGoalReached;\n', '\tbool public icoIsClosed;\n', '\tbool icoExitIsPossible;\n', '\t\n', '\n', '\t//Balances for each account\n', '\tmapping (address => uint256) public tokenBalanceOf;\n', '\n', '\t// Owner of account approves the transfer of an amount to another account\n', '\tmapping(address => mapping (address => uint256)) allowed;\n', '\t\n', '\t//list with information about frozen accounts\n', '\tmapping(address => bool) frozenAccount;\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent FrozenFunds(address initiator, address account, string status);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent BonusChanged(uint8 bonusOld, uint8 bonusNew);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent minGoalReached(uint256 minIcoAmount, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent preIcoEnded(uint256 preIcoAmount, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent priceUpdated(uint256 oldPrice, uint256 newPrice, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent withdrawed(address _to, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent deposited(address _from, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent tokenCreated(address _creator, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent tokenDestroyed(address _destroyer, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent icoStatusUpdated(address _initiator, string status);\n', '\n', '\t/// @notice Constructor of the contract\n', '\tfunction STARTMETADOLLAR() {\n', '\t    sellPrice = 900000000000000;\n', '\t    mtdAmount = 1000000000000000000;\n', '\t    ethAmount = 1000000000000000;\n', '\t    mtdPreAmount = 1;\n', '\t    ethPreAmount = 1;\n', '\t\tpreIcoIsRunning = true;\n', '\t\tminimalGoalReached = false;\n', '\t\ticoExitIsPossible = false;\n', '\t\ticoIsClosed = false;\n', '\t\ttokenBalanceOf[this] += _totalSupply;\n', '\t\tallowed[this][owner] = _totalSupply;\n', '\t\tallowed[this][supervisor] = _totalSupply;\n', '\t\tcurrentTokenPrice = mtdAmount * ethAmount;\t// initial price of 1 Token\n', '\t\tpreICOprice = mtdPreAmount * ethPreAmount; \t\t\t// price of 1 token in weis for the preICO time\n', '\t\tICOprice = mtdAmount * ethAmount;\t\t\t\t// price of 1 token in weis for the ICO time\n', '\t\tsellPrice = 0;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\tif(msg.value > 0 && !frozenAccount[msg.sender]) {\n', '\t\t\tbuyToken();\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Returns a whole amount of tokens\n', '\tfunction totalSupply() constant returns (uint256 totalAmount) {\n', '\t\ttotalAmount = _totalSupply;\n', '\t}\n', '\n', '\t/// @notice What is the balance of a particular account?\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n', '\t\treturn tokenBalanceOf[_owner];\n', '\t}\n', '\n', '\t/// @notice Shows how much tokens _spender can spend from _owner address\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\t\n', '\t/// @notice Calculates amount of weis needed to buy more than one token\n', '\t/// @param howManyTokenToBuy - Amount of tokens to calculate\n', '\tfunction calculateTheEndPrice(uint256 howManyTokenToBuy) constant returns (uint256 summarizedPriceInWeis) {\n', '\t\tif(howManyTokenToBuy > 0) {\n', '\t\t\tsummarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice;\n', '\t\t}else {\n', '\t\t\tsummarizedPriceInWeis = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/// @notice Shows if account is frozen\n', '\t/// @param account - Accountaddress to check\n', '\tfunction checkFrozenAccounts(address account) constant returns (bool accountIsFrozen) {\n', '\t\taccountIsFrozen = frozenAccount[account];\n', '\t}\n', '\n', '\t/// @notice Buy tokens from contract by sending ether\n', '\tfunction buy() payable public {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(msg.value > 0);\n', '\t\tbuyToken();\n', '\t}\n', '\n', '\t/// @notice Sell tokens and receive ether from contract\n', '\tfunction sell(uint256 amount) {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] >= amount);         \t// checks if the sender has enough to sell\n', '\t\trequire(amount > 0);\n', '\t\trequire(sellPrice > 0);\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tuint256 revenue = amount * sellPrice;\n', '\t\trequire(this.balance >= revenue);\n', '\t\tmsg.sender.transfer(revenue);                \t\t// sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks\n', '\t}\n', '\t\n', '\t/// @notice Allow user to sell maximum possible amount of tokens, depend on ether amount on contract\n', '\tfunction sellMaximumPossibleAmountOfTokens() {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);\n', '\t\trequire(this.balance > sellPrice);\n', '\t\tif(tokenBalanceOf[msg.sender] * sellPrice <= this.balance) {\n', '\t\t\tsell(tokenBalanceOf[msg.sender]);\n', '\t\t}else {\n', '\t\t\tsell(this.balance / sellPrice);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Transfer amount of tokens from own wallet to someone else\n', '\tfunction transfer(address _to, uint256 _value) returns (bool success) {\n', '\t\tassert(msg.sender != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\trequire(tokenBalanceOf[msg.sender] >= _value);\n', '\t\trequire(tokenBalanceOf[msg.sender] - _value < tokenBalanceOf[msg.sender]);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(_value > 0);\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice  Send _value amount of tokens from address _from to address _to\n', '\t/// @notice  The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '\t/// @notice  tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '\t/// @notice  fees in sub-currencies; the command should fail unless the _from account has\n', '\t/// @notice  deliberately authorized the sender of the message via some mechanism; we propose\n', '\t/// @notice  these standardized APIs for approval:\n', '\tfunction transferFrom(address _from,\taddress _to,\tuint256 _value) returns (bool success) {\n', '\t\tassert(msg.sender != address(0));\n', '\t\tassert(_from != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\trequire(tokenBalanceOf[_from] >= _value);\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\n', '\t\trequire(tokenBalanceOf[_from] - _value < tokenBalanceOf[_from]);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(_value > 0);\n', '\t\torderToTransfer(msg.sender, _from, _to, _value, "Order to transfer tokens from allowed account");\n', '\t\t_transfer(_from, _to, _value);\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '\t/// @notice If this function is called again it overwrites the current allowance with _value.\n', '\tfunction approve(address _spender, uint256 _value) returns (bool success) {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\tassert(_spender != address(0));\n', '\t\trequire(_value >= 0);\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice Check if minimal goal of ICO is reached\n', '\tfunction checkMinimalGoal() internal {\n', '\t\tif(tokenBalanceOf[this] <= _totalSupply - icoMin) {\n', '\t\t\tminimalGoalReached = true;\n', '\t\t\tminGoalReached(icoMin, "Minimal goal of ICO is reached!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Check if preICO is ended\n', '\tfunction checkPreIcoStatus() internal {\n', '\t\tif(tokenBalanceOf[this] <= _totalSupply - preIcoLimit) {\n', '\t\t\tpreIcoIsRunning = false;\n', '\t\t\tpreIcoEnded(preIcoLimit, "Token amount for preICO sold!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Processing each buying\n', '\tfunction buyToken() internal {\n', '\t\tuint256 value = msg.value;\n', '\t\taddress sender = msg.sender;\n', '\t\trequire(!icoIsClosed);\n', '\t\trequire(!frozenAccount[sender]);\n', '\t\trequire(value > 0);\n', '\t\trequire(currentTokenPrice > 0);\n', '\t\tuint256 amount = value / currentTokenPrice;\t\t\t// calculates amount of tokens\n', '\t\tuint256 moneyBack = value - (amount * currentTokenPrice);\n', '\t\trequire(tokenBalanceOf[this] >= amount);              \t\t// checks if contract has enough to sell\n', '\t\tamountOfInvestments = amountOfInvestments + (value - moneyBack);\n', '\t\tupdatePrices();\n', '\t\t_transfer(this, sender, amount);\n', '\t\tif(!minimalGoalReached) {\n', '\t\t\tcheckMinimalGoal();\n', '\t\t}\n', '\t\tif(moneyBack > 0) {\n', '\t\t\tsender.transfer(moneyBack);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Internal transfer, can only be called by this contract\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n', '\t\tassert(_from != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(_value > 0);\n', '\t\trequire(tokenBalanceOf[_from] >= _value);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\tif(tokenBalanceOf[_to] == 0){\n', '\t\t\tcountHolders += 1;\n', '\t\t}\n', '\t\ttokenBalanceOf[_from] -= _value;\n', '\t\tif(tokenBalanceOf[_from] == 0){\n', '\t\t\tcountHolders -= 1;\n', '\t\t}\n', '\t\ttokenBalanceOf[_to] += _value;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\tTransfer(_from, _to, _value);\n', '\t}\n', '\n', '\t/// @notice Set current ICO prices in wei for one token\n', '\tfunction updatePrices() internal {\n', '\t\tuint256 oldPrice = currentTokenPrice;\n', '\t\tif(preIcoIsRunning) {\n', '\t\t\tcheckPreIcoStatus();\n', '\t\t}\n', '\t\tif(preIcoIsRunning) {\n', '\t\t\tcurrentTokenPrice = preICOprice;\n', '\t\t}else{\n', '\t\t\tcurrentTokenPrice = ICOprice;\n', '\t\t}\n', '\t\t\n', '\t\tif(oldPrice != currentTokenPrice) {\n', '\t\t\tpriceUpdated(oldPrice, currentTokenPrice, "Token price updated!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Set current preICO price in wei for one token\n', '\t/// @param priceForPreIcoInWei - is the amount in wei for one token\n', '\tfunction setPreICOPrice(uint256 priceForPreIcoInWei) isOwner {\n', '\t\trequire(priceForPreIcoInWei > 0);\n', '\t\trequire(preICOprice != priceForPreIcoInWei);\n', '\t\tpreICOprice = priceForPreIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set current ICO price in wei for one token\n', '\t/// @param priceForIcoInWei - is the amount in wei for one token\n', '\tfunction setICOPrice(uint256 priceForIcoInWei) isOwner {\n', '\t\trequire(priceForIcoInWei > 0);\n', '\t\trequire(ICOprice != priceForIcoInWei);\n', '\t\tICOprice = priceForIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set both prices at the same time\n', '\t/// @param priceForPreIcoInWei - Price of the token in pre ICO\n', '\t/// @param priceForIcoInWei - Price of the token in ICO\n', '\tfunction setPrices(uint256 priceForPreIcoInWei, uint256 priceForIcoInWei) isOwner {\n', '\t\trequire(priceForPreIcoInWei > 0);\n', '\t\trequire(priceForIcoInWei > 0);\n', '\t\tpreICOprice = priceForPreIcoInWei;\n', '\t\tICOprice = priceForIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\t\n', '\t/// @notice Set current mtdAmount price in wei for one token\n', '\t/// @param mtdAmountInWei - is the amount in wei for one token\n', '\tfunction setMtdAmount(uint256 mtdAmountInWei) isOwner {\n', '\t\trequire(mtdAmountInWei > 0);\n', '\t\trequire(mtdAmount != mtdAmountInWei);\n', '\t\tmtdAmount = mtdAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set current ethAmount price in wei for one token\n', '\t/// @param ethAmountInWei - is the amount in wei for one token\n', '\tfunction setEthAmount(uint256 ethAmountInWei) isOwner {\n', '\t\trequire(ethAmountInWei > 0);\n', '\t\trequire(ethAmount != ethAmountInWei);\n', '\t\tethAmount = ethAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set both ethAmount and mtdAmount at the same time\n', '\t/// @param mtdAmountInWei - is the amount in wei for one token\n', '\t/// @param ethAmountInWei - is the amount in wei for one token\n', '\tfunction setAmounts(uint256 mtdAmountInWei, uint256 ethAmountInWei) isOwner {\n', '\t\trequire(mtdAmountInWei > 0);\n', '\t\trequire(ethAmountInWei > 0);\n', '\t\tmtdAmount = mtdAmountInWei;\n', '\t\tethAmount = ethAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set the current sell price in wei for one token\n', '\t/// @param priceInWei - is the amount in wei for one token\n', '\tfunction setSellPrice(uint256 priceInWei) isOwner {\n', '\t\trequire(priceInWei >= 0);\n', '\t\tsellPrice = priceInWei;\n', '\t}\n', '\n', '\t/// @notice &#39;freeze? Prevent | Allow&#39; &#39;account&#39; from sending and receiving tokens\n', '\t/// @param account - address to be frozen\n', '\t/// @param freeze - select is the account frozen or not\n', '\tfunction freezeAccount(address account, bool freeze) isOwner {\n', '\t\trequire(account != owner);\n', '\t\trequire(account != supervisor);\n', '\t\tfrozenAccount[account] = freeze;\n', '\t\tif(freeze) {\n', '\t\t\tFrozenFunds(msg.sender, account, "Account set frozen!");\n', '\t\t}else {\n', '\t\t\tFrozenFunds(msg.sender, account, "Account set free for use!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Create an amount of token\n', '\t/// @param amount - token to create\n', '\tfunction mintToken(uint256 amount) isOwner {\n', '\t\trequire(amount > 0);\n', '\t\trequire(tokenBalanceOf[this] <= icoMin);\t// owner can create token only if the initial amount is strongly not enough to supply and demand ICO\n', '\t\trequire(_totalSupply + amount > _totalSupply);\n', '\t\trequire(tokenBalanceOf[this] + amount > tokenBalanceOf[this]);\n', '\t\t_totalSupply += amount;\n', '\t\ttokenBalanceOf[this] += amount;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\ttokenCreated(msg.sender, amount, "Additional tokens created!");\n', '\t}\n', '\n', '\t/// @notice Destroy an amount of token\n', '\t/// @param amount - token to destroy\n', '\tfunction destroyToken(uint256 amount) isOwner {\n', '\t\trequire(amount > 0);\n', '\t\trequire(tokenBalanceOf[this] >= amount);\n', '\t\trequire(_totalSupply >= amount);\n', '\t\trequire(tokenBalanceOf[this] - amount >= 0);\n', '\t\trequire(_totalSupply - amount >= 0);\n', '\t\ttokenBalanceOf[this] -= amount;\n', '\t\t_totalSupply -= amount;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\ttokenDestroyed(msg.sender, amount, "An amount of tokens destroyed!");\n', '\t}\n', '\n', '\t/// @notice Transfer the ownership to another account\n', '\t/// @param newOwner - address who get the ownership\n', '\tfunction transferOwnership(address newOwner) isOwner {\n', '\t\tassert(newOwner != address(0));\n', '\t\taddress oldOwner = owner;\n', '\t\towner = newOwner;\n', '\t\townerChanged(msg.sender, oldOwner, newOwner);\n', '\t\tallowed[this][oldOwner] = 0;\n', '\t\tallowed[this][newOwner] = tokenBalanceOf[this];\n', '\t}\n', '\n', '\t/// @notice Transfer ether from smartcontract to owner\n', '\tfunction collect() isOwner {\n', '        require(this.balance > 0);\n', '\t\twithdraw(this.balance);\n', '    }\n', '\n', '\t/// @notice Withdraw an amount of ether\n', '\t/// @param summeInWei - amout to withdraw\n', '\tfunction withdraw(uint256 summeInWei) isOwner {\n', '\t\tuint256 contractbalance = this.balance;\n', '\t\taddress sender = msg.sender;\n', '\t\trequire(contractbalance >= summeInWei);\n', '\t\twithdrawed(sender, summeInWei, "wei withdrawed");\n', '        sender.transfer(summeInWei);\n', '\t}\n', '\n', '\t/// @notice Deposit an amount of ether\n', '\tfunction deposit() payable isOwner {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(msg.sender.balance >= msg.value);\n', '\t\tdeposited(msg.sender, msg.value, "wei deposited");\n', '\t}\n', '\n', '\t/// @notice Allow user to exit ICO\n', '\t/// @param exitAllowed - status if the exit is allowed\n', '\tfunction allowIcoExit(bool exitAllowed) isOwner {\n', '\t\trequire(icoExitIsPossible != exitAllowed);\n', '\t\ticoExitIsPossible = exitAllowed;\n', '\t}\n', '\n', '\t/// @notice Stop running ICO\n', '\t/// @param icoIsStopped - status if this ICO is stopped\n', '\tfunction stopThisIco(bool icoIsStopped) isOwner {\n', '\t\trequire(icoIsClosed != icoIsStopped);\n', '\t\ticoIsClosed = icoIsStopped;\n', '\t\tif(icoIsStopped) {\n', '\t\t\ticoStatusUpdated(msg.sender, "Coin offering was stopped!");\n', '\t\t}else {\n', '\t\t\ticoStatusUpdated(msg.sender, "Coin offering is running!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Sell all tokens for half of a price and exit this ICO\n', '\tfunction exitThisIcoForHalfOfTokenPrice() {\n', '\t\trequire(icoExitIsPossible);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t// checks if the sender has enough to sell\n', '\t\trequire(currentTokenPrice > 1);\n', '\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\n', '\t\tuint256 revenue = amount * currentTokenPrice / 2;\n', '\t\trequire(this.balance >= revenue);\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tmsg.sender.transfer(revenue);                \t// sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks\n', '\t}\n', '\n', '\t/// @notice Sell all of tokens for all ether of this smartcontract\n', '\tfunction getAllMyTokensForAllEtherOnContract() {\n', '\t\trequire(icoExitIsPossible);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t// checks if the sender has enough to sell\n', '\t\trequire(currentTokenPrice > 1);\n', '\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\n', '\t\tuint256 revenue = amount * currentTokenPrice / 2;\n', '\t\trequire(this.balance <= revenue);\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tmsg.sender.transfer(this.balance); \n', '\t}\n', '}']
['pragma solidity ^0.4.16;\n', '\n', ' // ERC Token Standard #20 Interface\n', ' // https://github.com/ethereum/EIPs/issues/20\n', '\n', ' contract ERC20Interface {\n', '\t/// @notice Get the total token supply\n', '\tfunction totalSupply() constant returns (uint256 totalAmount);\n', '\n', '\t/// @notice  Get the account balance of another account with address _owner\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '\t/// @notice  Send _value amount of tokens to address _to\n', '\tfunction transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Send _value amount of tokens from address _from to address _to\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '\t/// @notice  If this function is called again it overwrites the current allowance with _value.\n', '\t/// @notice  this function is required for some DEX functionality\n', '\tfunction approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '\t/// @notice  Returns the amount which _spender is still allowed to withdraw from _owner\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '\t/// @notice  Triggered when tokens are transferred.\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '\t/// @notice  Triggered whenever approve(address _spender, uint256 _value) is called.\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', ' }\n', ' \n', ' contract owned{\n', '\taddress public owner;\n', '\taddress constant supervisor  = 0x2d6808bC989CbEB46cc6dd75a6C90deA50e3e504;\n', '\t\n', '\tfunction owned(){\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/// @notice Functions with this modifier can only be executed by the owner\n', '\tmodifier isOwner {\n', '\t\tassert(msg.sender == owner || msg.sender == supervisor);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t/// @notice Transfer the ownership of this contract\n', '\tfunction transferOwnership(address newOwner);\n', '\t\n', '\tevent ownerChanged(address whoTransferredOwnership, address formerOwner, address newOwner);\n', ' }\n', '\n', 'contract METADOLLAR is ERC20Interface, owned{\n', '\n', '\tstring public constant name = "METADOLLAR";\n', '\tstring public constant symbol = "DOL";\n', '\tuint public constant decimals = 18;\n', '\tuint256 public _totalSupply = 1000000000000000000000000000000;\n', '\tuint256 public icoMin = 1000000000000000000000000000000;\t\t\t\t\t// = 300000; amount is in Tokens, 1.800.000\n', '\tuint256 public preIcoLimit = 1000000000000000000;\t\t\t// = 600000; amount is in tokens, 3.600.000\n', '\tuint256 public countHolders = 0;\t\t\t\t// count how many unique holders have tokens\n', '\tuint256 public amountOfInvestments = 0;\t// amount of collected wei\n', '\t\n', '\tuint256 preICOprice;\t\t\t\t\t\t\t\t\t// price of 1 token in weis for the preICO time\n', '\tuint256 ICOprice;\t\t\t\t\t\t\t\t\t\t// price of 1 token in weis for the ICO time\n', '\tuint256 public currentTokenPrice;\t\t\t\t// current token price in weis\n', '\tuint256 public sellPrice;      // buyback price of one token in weis\n', '\tuint256 public mtdPreAmount;\n', '\tuint256 public ethPreAmount;\n', '\tuint256 public mtdAmount;\n', '\tuint256 public ethAmount;\n', '\t\n', '\tbool public preIcoIsRunning;\n', '\tbool public minimalGoalReached;\n', '\tbool public icoIsClosed;\n', '\tbool icoExitIsPossible;\n', '\t\n', '\n', '\t//Balances for each account\n', '\tmapping (address => uint256) public tokenBalanceOf;\n', '\n', '\t// Owner of account approves the transfer of an amount to another account\n', '\tmapping(address => mapping (address => uint256)) allowed;\n', '\t\n', '\t//list with information about frozen accounts\n', '\tmapping(address => bool) frozenAccount;\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent FrozenFunds(address initiator, address account, string status);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent BonusChanged(uint8 bonusOld, uint8 bonusNew);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent minGoalReached(uint256 minIcoAmount, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent preIcoEnded(uint256 preIcoAmount, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent priceUpdated(uint256 oldPrice, uint256 newPrice, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent withdrawed(address _to, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent deposited(address _from, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent tokenCreated(address _creator, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent tokenDestroyed(address _destroyer, uint256 summe, string notice);\n', '\t\n', '\t//this generate a public event on a blockchain that will notify clients\n', '\tevent icoStatusUpdated(address _initiator, string status);\n', '\n', '\t/// @notice Constructor of the contract\n', '\tfunction STARTMETADOLLAR() {\n', '\t    sellPrice = 900000000000000;\n', '\t    mtdAmount = 1000000000000000000;\n', '\t    ethAmount = 1000000000000000;\n', '\t    mtdPreAmount = 1;\n', '\t    ethPreAmount = 1;\n', '\t\tpreIcoIsRunning = true;\n', '\t\tminimalGoalReached = false;\n', '\t\ticoExitIsPossible = false;\n', '\t\ticoIsClosed = false;\n', '\t\ttokenBalanceOf[this] += _totalSupply;\n', '\t\tallowed[this][owner] = _totalSupply;\n', '\t\tallowed[this][supervisor] = _totalSupply;\n', '\t\tcurrentTokenPrice = mtdAmount * ethAmount;\t// initial price of 1 Token\n', '\t\tpreICOprice = mtdPreAmount * ethPreAmount; \t\t\t// price of 1 token in weis for the preICO time\n', '\t\tICOprice = mtdAmount * ethAmount;\t\t\t\t// price of 1 token in weis for the ICO time\n', '\t\tsellPrice = 0;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\tif(msg.value > 0 && !frozenAccount[msg.sender]) {\n', '\t\t\tbuyToken();\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Returns a whole amount of tokens\n', '\tfunction totalSupply() constant returns (uint256 totalAmount) {\n', '\t\ttotalAmount = _totalSupply;\n', '\t}\n', '\n', '\t/// @notice What is the balance of a particular account?\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n', '\t\treturn tokenBalanceOf[_owner];\n', '\t}\n', '\n', '\t/// @notice Shows how much tokens _spender can spend from _owner address\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\t\n', '\t/// @notice Calculates amount of weis needed to buy more than one token\n', '\t/// @param howManyTokenToBuy - Amount of tokens to calculate\n', '\tfunction calculateTheEndPrice(uint256 howManyTokenToBuy) constant returns (uint256 summarizedPriceInWeis) {\n', '\t\tif(howManyTokenToBuy > 0) {\n', '\t\t\tsummarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice;\n', '\t\t}else {\n', '\t\t\tsummarizedPriceInWeis = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/// @notice Shows if account is frozen\n', '\t/// @param account - Accountaddress to check\n', '\tfunction checkFrozenAccounts(address account) constant returns (bool accountIsFrozen) {\n', '\t\taccountIsFrozen = frozenAccount[account];\n', '\t}\n', '\n', '\t/// @notice Buy tokens from contract by sending ether\n', '\tfunction buy() payable public {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(msg.value > 0);\n', '\t\tbuyToken();\n', '\t}\n', '\n', '\t/// @notice Sell tokens and receive ether from contract\n', '\tfunction sell(uint256 amount) {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] >= amount);         \t// checks if the sender has enough to sell\n', '\t\trequire(amount > 0);\n', '\t\trequire(sellPrice > 0);\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tuint256 revenue = amount * sellPrice;\n', '\t\trequire(this.balance >= revenue);\n', "\t\tmsg.sender.transfer(revenue);                \t\t// sends ether to the seller: it's important to do this last to prevent recursion attacks\n", '\t}\n', '\t\n', '\t/// @notice Allow user to sell maximum possible amount of tokens, depend on ether amount on contract\n', '\tfunction sellMaximumPossibleAmountOfTokens() {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);\n', '\t\trequire(this.balance > sellPrice);\n', '\t\tif(tokenBalanceOf[msg.sender] * sellPrice <= this.balance) {\n', '\t\t\tsell(tokenBalanceOf[msg.sender]);\n', '\t\t}else {\n', '\t\t\tsell(this.balance / sellPrice);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Transfer amount of tokens from own wallet to someone else\n', '\tfunction transfer(address _to, uint256 _value) returns (bool success) {\n', '\t\tassert(msg.sender != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\trequire(tokenBalanceOf[msg.sender] >= _value);\n', '\t\trequire(tokenBalanceOf[msg.sender] - _value < tokenBalanceOf[msg.sender]);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(_value > 0);\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice  Send _value amount of tokens from address _from to address _to\n', '\t/// @notice  The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '\t/// @notice  tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '\t/// @notice  fees in sub-currencies; the command should fail unless the _from account has\n', '\t/// @notice  deliberately authorized the sender of the message via some mechanism; we propose\n', '\t/// @notice  these standardized APIs for approval:\n', '\tfunction transferFrom(address _from,\taddress _to,\tuint256 _value) returns (bool success) {\n', '\t\tassert(msg.sender != address(0));\n', '\t\tassert(_from != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\trequire(tokenBalanceOf[_from] >= _value);\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\n', '\t\trequire(tokenBalanceOf[_from] - _value < tokenBalanceOf[_from]);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(_value > 0);\n', '\t\torderToTransfer(msg.sender, _from, _to, _value, "Order to transfer tokens from allowed account");\n', '\t\t_transfer(_from, _to, _value);\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '\t/// @notice If this function is called again it overwrites the current allowance with _value.\n', '\tfunction approve(address _spender, uint256 _value) returns (bool success) {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\tassert(_spender != address(0));\n', '\t\trequire(_value >= 0);\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @notice Check if minimal goal of ICO is reached\n', '\tfunction checkMinimalGoal() internal {\n', '\t\tif(tokenBalanceOf[this] <= _totalSupply - icoMin) {\n', '\t\t\tminimalGoalReached = true;\n', '\t\t\tminGoalReached(icoMin, "Minimal goal of ICO is reached!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Check if preICO is ended\n', '\tfunction checkPreIcoStatus() internal {\n', '\t\tif(tokenBalanceOf[this] <= _totalSupply - preIcoLimit) {\n', '\t\t\tpreIcoIsRunning = false;\n', '\t\t\tpreIcoEnded(preIcoLimit, "Token amount for preICO sold!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Processing each buying\n', '\tfunction buyToken() internal {\n', '\t\tuint256 value = msg.value;\n', '\t\taddress sender = msg.sender;\n', '\t\trequire(!icoIsClosed);\n', '\t\trequire(!frozenAccount[sender]);\n', '\t\trequire(value > 0);\n', '\t\trequire(currentTokenPrice > 0);\n', '\t\tuint256 amount = value / currentTokenPrice;\t\t\t// calculates amount of tokens\n', '\t\tuint256 moneyBack = value - (amount * currentTokenPrice);\n', '\t\trequire(tokenBalanceOf[this] >= amount);              \t\t// checks if contract has enough to sell\n', '\t\tamountOfInvestments = amountOfInvestments + (value - moneyBack);\n', '\t\tupdatePrices();\n', '\t\t_transfer(this, sender, amount);\n', '\t\tif(!minimalGoalReached) {\n', '\t\t\tcheckMinimalGoal();\n', '\t\t}\n', '\t\tif(moneyBack > 0) {\n', '\t\t\tsender.transfer(moneyBack);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Internal transfer, can only be called by this contract\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n', '\t\tassert(_from != address(0));\n', '\t\tassert(_to != address(0));\n', '\t\trequire(_value > 0);\n', '\t\trequire(tokenBalanceOf[_from] >= _value);\n', '\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\tif(tokenBalanceOf[_to] == 0){\n', '\t\t\tcountHolders += 1;\n', '\t\t}\n', '\t\ttokenBalanceOf[_from] -= _value;\n', '\t\tif(tokenBalanceOf[_from] == 0){\n', '\t\t\tcountHolders -= 1;\n', '\t\t}\n', '\t\ttokenBalanceOf[_to] += _value;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\tTransfer(_from, _to, _value);\n', '\t}\n', '\n', '\t/// @notice Set current ICO prices in wei for one token\n', '\tfunction updatePrices() internal {\n', '\t\tuint256 oldPrice = currentTokenPrice;\n', '\t\tif(preIcoIsRunning) {\n', '\t\t\tcheckPreIcoStatus();\n', '\t\t}\n', '\t\tif(preIcoIsRunning) {\n', '\t\t\tcurrentTokenPrice = preICOprice;\n', '\t\t}else{\n', '\t\t\tcurrentTokenPrice = ICOprice;\n', '\t\t}\n', '\t\t\n', '\t\tif(oldPrice != currentTokenPrice) {\n', '\t\t\tpriceUpdated(oldPrice, currentTokenPrice, "Token price updated!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Set current preICO price in wei for one token\n', '\t/// @param priceForPreIcoInWei - is the amount in wei for one token\n', '\tfunction setPreICOPrice(uint256 priceForPreIcoInWei) isOwner {\n', '\t\trequire(priceForPreIcoInWei > 0);\n', '\t\trequire(preICOprice != priceForPreIcoInWei);\n', '\t\tpreICOprice = priceForPreIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set current ICO price in wei for one token\n', '\t/// @param priceForIcoInWei - is the amount in wei for one token\n', '\tfunction setICOPrice(uint256 priceForIcoInWei) isOwner {\n', '\t\trequire(priceForIcoInWei > 0);\n', '\t\trequire(ICOprice != priceForIcoInWei);\n', '\t\tICOprice = priceForIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set both prices at the same time\n', '\t/// @param priceForPreIcoInWei - Price of the token in pre ICO\n', '\t/// @param priceForIcoInWei - Price of the token in ICO\n', '\tfunction setPrices(uint256 priceForPreIcoInWei, uint256 priceForIcoInWei) isOwner {\n', '\t\trequire(priceForPreIcoInWei > 0);\n', '\t\trequire(priceForIcoInWei > 0);\n', '\t\tpreICOprice = priceForPreIcoInWei;\n', '\t\tICOprice = priceForIcoInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\t\n', '\t/// @notice Set current mtdAmount price in wei for one token\n', '\t/// @param mtdAmountInWei - is the amount in wei for one token\n', '\tfunction setMtdAmount(uint256 mtdAmountInWei) isOwner {\n', '\t\trequire(mtdAmountInWei > 0);\n', '\t\trequire(mtdAmount != mtdAmountInWei);\n', '\t\tmtdAmount = mtdAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set current ethAmount price in wei for one token\n', '\t/// @param ethAmountInWei - is the amount in wei for one token\n', '\tfunction setEthAmount(uint256 ethAmountInWei) isOwner {\n', '\t\trequire(ethAmountInWei > 0);\n', '\t\trequire(ethAmount != ethAmountInWei);\n', '\t\tethAmount = ethAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set both ethAmount and mtdAmount at the same time\n', '\t/// @param mtdAmountInWei - is the amount in wei for one token\n', '\t/// @param ethAmountInWei - is the amount in wei for one token\n', '\tfunction setAmounts(uint256 mtdAmountInWei, uint256 ethAmountInWei) isOwner {\n', '\t\trequire(mtdAmountInWei > 0);\n', '\t\trequire(ethAmountInWei > 0);\n', '\t\tmtdAmount = mtdAmountInWei;\n', '\t\tethAmount = ethAmountInWei;\n', '\t\tupdatePrices();\n', '\t}\n', '\n', '\t/// @notice Set the current sell price in wei for one token\n', '\t/// @param priceInWei - is the amount in wei for one token\n', '\tfunction setSellPrice(uint256 priceInWei) isOwner {\n', '\t\trequire(priceInWei >= 0);\n', '\t\tsellPrice = priceInWei;\n', '\t}\n', '\n', "\t/// @notice 'freeze? Prevent | Allow' 'account' from sending and receiving tokens\n", '\t/// @param account - address to be frozen\n', '\t/// @param freeze - select is the account frozen or not\n', '\tfunction freezeAccount(address account, bool freeze) isOwner {\n', '\t\trequire(account != owner);\n', '\t\trequire(account != supervisor);\n', '\t\tfrozenAccount[account] = freeze;\n', '\t\tif(freeze) {\n', '\t\t\tFrozenFunds(msg.sender, account, "Account set frozen!");\n', '\t\t}else {\n', '\t\t\tFrozenFunds(msg.sender, account, "Account set free for use!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Create an amount of token\n', '\t/// @param amount - token to create\n', '\tfunction mintToken(uint256 amount) isOwner {\n', '\t\trequire(amount > 0);\n', '\t\trequire(tokenBalanceOf[this] <= icoMin);\t// owner can create token only if the initial amount is strongly not enough to supply and demand ICO\n', '\t\trequire(_totalSupply + amount > _totalSupply);\n', '\t\trequire(tokenBalanceOf[this] + amount > tokenBalanceOf[this]);\n', '\t\t_totalSupply += amount;\n', '\t\ttokenBalanceOf[this] += amount;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\ttokenCreated(msg.sender, amount, "Additional tokens created!");\n', '\t}\n', '\n', '\t/// @notice Destroy an amount of token\n', '\t/// @param amount - token to destroy\n', '\tfunction destroyToken(uint256 amount) isOwner {\n', '\t\trequire(amount > 0);\n', '\t\trequire(tokenBalanceOf[this] >= amount);\n', '\t\trequire(_totalSupply >= amount);\n', '\t\trequire(tokenBalanceOf[this] - amount >= 0);\n', '\t\trequire(_totalSupply - amount >= 0);\n', '\t\ttokenBalanceOf[this] -= amount;\n', '\t\t_totalSupply -= amount;\n', '\t\tallowed[this][owner] = tokenBalanceOf[this];\n', '\t\tallowed[this][supervisor] = tokenBalanceOf[this];\n', '\t\ttokenDestroyed(msg.sender, amount, "An amount of tokens destroyed!");\n', '\t}\n', '\n', '\t/// @notice Transfer the ownership to another account\n', '\t/// @param newOwner - address who get the ownership\n', '\tfunction transferOwnership(address newOwner) isOwner {\n', '\t\tassert(newOwner != address(0));\n', '\t\taddress oldOwner = owner;\n', '\t\towner = newOwner;\n', '\t\townerChanged(msg.sender, oldOwner, newOwner);\n', '\t\tallowed[this][oldOwner] = 0;\n', '\t\tallowed[this][newOwner] = tokenBalanceOf[this];\n', '\t}\n', '\n', '\t/// @notice Transfer ether from smartcontract to owner\n', '\tfunction collect() isOwner {\n', '        require(this.balance > 0);\n', '\t\twithdraw(this.balance);\n', '    }\n', '\n', '\t/// @notice Withdraw an amount of ether\n', '\t/// @param summeInWei - amout to withdraw\n', '\tfunction withdraw(uint256 summeInWei) isOwner {\n', '\t\tuint256 contractbalance = this.balance;\n', '\t\taddress sender = msg.sender;\n', '\t\trequire(contractbalance >= summeInWei);\n', '\t\twithdrawed(sender, summeInWei, "wei withdrawed");\n', '        sender.transfer(summeInWei);\n', '\t}\n', '\n', '\t/// @notice Deposit an amount of ether\n', '\tfunction deposit() payable isOwner {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(msg.sender.balance >= msg.value);\n', '\t\tdeposited(msg.sender, msg.value, "wei deposited");\n', '\t}\n', '\n', '\t/// @notice Allow user to exit ICO\n', '\t/// @param exitAllowed - status if the exit is allowed\n', '\tfunction allowIcoExit(bool exitAllowed) isOwner {\n', '\t\trequire(icoExitIsPossible != exitAllowed);\n', '\t\ticoExitIsPossible = exitAllowed;\n', '\t}\n', '\n', '\t/// @notice Stop running ICO\n', '\t/// @param icoIsStopped - status if this ICO is stopped\n', '\tfunction stopThisIco(bool icoIsStopped) isOwner {\n', '\t\trequire(icoIsClosed != icoIsStopped);\n', '\t\ticoIsClosed = icoIsStopped;\n', '\t\tif(icoIsStopped) {\n', '\t\t\ticoStatusUpdated(msg.sender, "Coin offering was stopped!");\n', '\t\t}else {\n', '\t\t\ticoStatusUpdated(msg.sender, "Coin offering is running!");\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Sell all tokens for half of a price and exit this ICO\n', '\tfunction exitThisIcoForHalfOfTokenPrice() {\n', '\t\trequire(icoExitIsPossible);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t// checks if the sender has enough to sell\n', '\t\trequire(currentTokenPrice > 1);\n', '\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\n', '\t\tuint256 revenue = amount * currentTokenPrice / 2;\n', '\t\trequire(this.balance >= revenue);\n', '\t\t_transfer(msg.sender, this, amount);\n', "\t\tmsg.sender.transfer(revenue);                \t// sends ether to the seller: it's important to do this last to prevent recursion attacks\n", '\t}\n', '\n', '\t/// @notice Sell all of tokens for all ether of this smartcontract\n', '\tfunction getAllMyTokensForAllEtherOnContract() {\n', '\t\trequire(icoExitIsPossible);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t// checks if the sender has enough to sell\n', '\t\trequire(currentTokenPrice > 1);\n', '\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\n', '\t\tuint256 revenue = amount * currentTokenPrice / 2;\n', '\t\trequire(this.balance <= revenue);\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tmsg.sender.transfer(this.balance); \n', '\t}\n', '}']
