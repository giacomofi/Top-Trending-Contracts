['pragma solidity ^0.4.18;\n', '\n', 'contract CryptoLandmarks {\n', '    using SafeMath for uint256;\n', '\n', '    // ERC721 required events\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Event fired whenever landmark is sold\n', '    event LandmarkSold(uint256 tokenId, uint256 price, uint256 nextPrice, address prevOwner, address owner);\n', '    \n', '    // Event fired when price of landmark changes\n', '    event PriceChanged(uint256 tokenId, uint256 price);\n', '\n', '    // Event fired for every new landmark created\n', '    event LandmarkCreated(uint256 tokenId, uint256 groupId, uint256 price, address owner);\n', '\n', '   \n', '    string public constant NAME = "CryptoLandmarks.co Landmarks"; \n', '    string public constant SYMBOL = "LANDMARK"; \n', '\n', '    // Initial price of new Landmark\n', '    uint256 private startingPrice = 0.03 ether;\n', '    // Initial price of new Ambassador\n', '    uint256 private ambassadorStartingPrice = 3 ether;\n', '\n', '    // count transactions after every withdrawal\n', '    uint256 public transactions = 0;\n', '\n', '    // Contract roles\n', '    address public ceo;\n', '    address public coo;\n', '\n', '    uint256[] private landmarks;\n', '    \n', '    // landmark to prices\n', '    mapping (uint256 => uint256) landmarkToMaxPrice;\n', '    mapping (uint256 => uint256) landmarkToPrice;\n', '    \n', '    // landmark to owner\n', '    mapping (uint256 => address) landmarkToOwner;\n', '    \n', '    // landmark to ambassador id\n', '    // ambassador is also landmark token\n', '    // every ambassador belongs to self\n', '    mapping (uint256 => uint256) landmarkToAmbassador;\n', '    \n', '    // ambassadors&#39;s landmarks count\n', '    mapping (uint256 => uint256) groupLandmarksCount;\n', '\n', '    // withdraw cooldown date of landmark owner\n', '    mapping (address => uint256) public withdrawCooldown;\n', '\n', '    mapping (uint256 => address) landmarkToApproved;\n', '    mapping (address => uint256) landmarkOwnershipCount;\n', '\n', '\n', '    function CryptoLandmarks() public {\n', '        ceo = msg.sender;\n', '        coo = msg.sender;\n', '    }\n', '\n', '    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n', '        if (_price < 0.2 ether)\n', '            return _price.mul(2); // 200%\n', '        if (_price < 4 ether)\n', '            return _price.mul(17).div(10); // 170%\n', '        if (_price < 15 ether)\n', '            return _price.mul(141).div(100); // 141%\n', '        else\n', '            return _price.mul(134).div(100); // 134%\n', '    }\n', '\n', '    function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {\n', '        if (_price < 0.2 ether)\n', '            return 5; // 5%\n', '        if (_price < 4 ether)\n', '            return 4; // 4%\n', '        if (_price < 15 ether)\n', '            return 3; // 3%\n', '        else\n', '            return 2; // 2%\n', '    }   \n', '\n', '    /*\n', '        Buy Landmark or Ambassador from contract for calculated price that ensures that:\n', '         - previous owner gets a profit\n', '         - specific Ambassador gets his/her fee\n', '         - every owner of Landmark in an Ambassador group gets a cut\n', '        All funds are sent directly to players and are never stored in the contract.\n', '\n', '        Ambassador -> _tokenId < 1000\n', '        Landmark -> _tokenId >= 1000\n', '\n', '    */\n', '    function buy(uint256 _tokenId) public payable {\n', '        address oldOwner = landmarkToOwner[_tokenId];\n', '        require(oldOwner != msg.sender);\n', '        require(msg.sender != address(0));\n', '        uint256 sellingPrice = priceOfLandmark(_tokenId);\n', '        require(msg.value >= sellingPrice);\n', '\n', '        // excess that will be refunded\n', '        uint256 excess = msg.value.sub(sellingPrice);\n', '\n', '        // id of a group = ambassador id\n', '        uint256 groupId = landmarkToAmbassador[_tokenId];\n', '\n', '        // number of Landmarks in the group\n', '        uint256 groupMembersCount = groupLandmarksCount[groupId];\n', '\n', '        // developer&#39;s cut in % (2-5)\n', '        uint256 devCut = calculateDevCut(sellingPrice);\n', '\n', '        // for previous owner\n', '        uint256 payment;\n', '        \n', '        if (_tokenId < 1000) {\n', '            // Buying Ambassador\n', '            payment = sellingPrice.mul(SafeMath.sub(95, devCut)).div(100);\n', '        } else {\n', '            // Buying Landmark\n', '            payment = sellingPrice.mul(SafeMath.sub(90, devCut)).div(100);\n', '        }\n', '\n', '        // 5% splitted per all group memebrs\n', '        uint256 feeGroupMember = (sellingPrice.mul(5).div(100)).div(groupMembersCount);\n', '\n', '\n', '        for (uint i = 0; i < totalSupply(); i++) {\n', '            uint id = landmarks[i];\n', '            if ( landmarkToAmbassador[id] == groupId ) {\n', '                if ( _tokenId == id) {\n', '                    // Transfer payment to previous owner\n', '                    oldOwner.transfer(payment);\n', '                }\n', '                if (groupId == id && _tokenId >= 1000) {\n', '                    // Transfer 5% to Ambassador\n', '                    landmarkToOwner[id].transfer(sellingPrice.mul(5).div(100));\n', '                }\n', '\n', '                // Transfer cut to every member of a group\n', '                // since ambassador and old owner are also members they get a cut again too\n', '                landmarkToOwner[id].transfer(feeGroupMember);\n', '            }\n', '        }\n', '        \n', '        uint256 nextPrice = calculateNextPrice(sellingPrice);\n', '\n', '        // Set new price\n', '        landmarkToPrice[_tokenId] = nextPrice;\n', '\n', '        // Set new maximum price\n', '        landmarkToMaxPrice[_tokenId] = nextPrice;\n', '\n', '        // Transfer token\n', '        _transfer(oldOwner, msg.sender, _tokenId);\n', '\n', '        // if overpaid, transfer excess back to sender\n', '        if (excess > 0) {\n', '            msg.sender.transfer(excess);\n', '        }\n', '\n', '        // increment transactions counter\n', '        transactions++;\n', '\n', '        // emit event\n', '        LandmarkSold(_tokenId, sellingPrice, nextPrice, oldOwner, msg.sender);\n', '    }\n', '\n', '\n', '    // owner can change price\n', '    function changePrice(uint256 _tokenId, uint256 _price) public {\n', '        // only owner can change price\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '\n', '        // price cannot be higher than maximum price\n', '        require(landmarkToMaxPrice[_tokenId] >= _price);\n', '\n', '        // set new price\n', '        landmarkToPrice[_tokenId] = _price;\n', '        \n', '        // emit event\n', '        PriceChanged(_tokenId, _price);\n', '    }\n', '\n', '    function createLandmark(uint256 _tokenId, uint256 _groupId, address _owner, uint256 _price) public onlyCOO {\n', '        // token with id below 1000 is a Ambassador\n', '        if (_price <= 0 && _tokenId >= 1000) {\n', '            _price = startingPrice;\n', '        } else if (_price <= 0 && _tokenId < 1000) {\n', '            _price = ambassadorStartingPrice;\n', '        }\n', '        if (_owner == address(0)) {\n', '            _owner = coo;\n', '        }\n', '\n', '        if (_tokenId < 1000) {\n', '            _groupId == _tokenId;\n', '        }\n', '\n', '        landmarkToPrice[_tokenId] = _price;\n', '        landmarkToMaxPrice[_tokenId] = _price;\n', '        landmarkToAmbassador[_tokenId] = _groupId;\n', '        groupLandmarksCount[_groupId]++;\n', '        _transfer(address(0), _owner, _tokenId);\n', '\n', '        landmarks.push(_tokenId);\n', '\n', '        LandmarkCreated(_tokenId, _groupId, _price, _owner);\n', '    }\n', '\n', '    function getLandmark(uint256 _tokenId) public view returns (\n', '        uint256 ambassadorId,\n', '        uint256 sellingPrice,\n', '        uint256 maxPrice,\n', '        uint256 nextPrice,\n', '        address owner\n', '    ) {\n', '        ambassadorId = landmarkToAmbassador[_tokenId];\n', '        sellingPrice = landmarkToPrice[_tokenId];\n', '        maxPrice = landmarkToMaxPrice[_tokenId];\n', '        nextPrice = calculateNextPrice(sellingPrice);\n', '        owner = landmarkToOwner[_tokenId];\n', '    }\n', '\n', '    function priceOfLandmark(uint256 _tokenId) public view returns (uint256) {\n', '        return landmarkToPrice[_tokenId];\n', '    }\n', '\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceo);\n', '        _;\n', '    }\n', '    modifier onlyCOO() {\n', '        require(msg.sender == coo);\n', '        _;\n', '    }\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == ceo ||\n', '            msg.sender == coo\n', '        );\n', '        _;\n', '    }\n', '    modifier notCLevel() {\n', '        require(\n', '            msg.sender != ceo ||\n', '            msg.sender != coo\n', '        );\n', '        _;\n', '    }\n', '\n', '    /*\n', '        Transfer 0.3% per token to sender\n', '        This function can be invoked by anyone who:\n', '         - has at least 3 tokens\n', '         - waited at least 1 week from previous withdrawal\n', '         - is not a ceo/coo\n', '        Additionally it can be invoked only:\n', '         - when total balance is greater than 1 eth\n', '         - after 10 transactions from previous withdrawal\n', '\n', '\n', '    */\n', '    function withdrawBalance() external notCLevel {\n', '        // only person owning more than 3 tokens can whitdraw\n', '        require(landmarkOwnershipCount[msg.sender] >= 3);\n', '        \n', '        // player can withdraw only week after his previous withdrawal\n', '        require(withdrawCooldown[msg.sender] <= now);\n', '\n', '        // can be invoked after any 10 purchases from previous withdrawal\n', '        require(transactions >= 10);\n', '\n', '        uint256 balance = this.balance;\n', '\n', '        // balance must be greater than 0.3 ether\n', '        require(balance >= 0.3 ether);\n', '\n', '        uint256 senderCut = balance.mul(3).div(1000).mul(landmarkOwnershipCount[msg.sender]);\n', '        \n', '        // transfer 0.3% per Landmark or Ambassador to sender\n', '        msg.sender.transfer(senderCut);\n', '\n', '        // set sender withdraw cooldown\n', '        withdrawCooldown[msg.sender] = now + 1 weeks;\n', '\n', '        // transfer rest to CEO \n', '        ceo.transfer(balance.sub(senderCut));\n', '\n', '        // set transactions counter to 0\n', '        transactions = 0;\n', '\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyCEO {\n', '        if (newOwner != address(0)) {\n', '            ceo = newOwner;\n', '        }\n', '    }\n', '\n', '    function setCOO(address newCOO) public onlyCOO {\n', '        if (newCOO != address(0)) {\n', '            coo = newCOO;\n', '        }\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        landmarkOwnershipCount[_to]++;\n', '        landmarkToOwner[_tokenId] = _to;\n', '\n', '        if (_from != address(0)) {\n', '            landmarkOwnershipCount[_from]--;\n', '            delete landmarkToApproved[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    //ERC721 methods\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return landmarks.length;\n', '    }\n', '\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return landmarkOwnershipCount[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n', '        owner = landmarkToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '    function transfer(address _to, uint256 _tokenId) public {\n', '        require(_to != address(0));\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    function approve(address _to, uint256 _tokenId) public {\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '        landmarkToApproved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '        require(landmarkToApproved[_tokenId] == _to);\n', '        require(_to != address(0));\n', '        require(landmarkToOwner[_tokenId] == _from);\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) public view returns(uint256[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint256[] memory result = new uint256[](tokenCount);\n', '        uint256 total = totalSupply();\n', '        uint256 resultIndex = 0;\n', '\n', '        for(uint256 i = 0; i <= total; i++) {\n', '            if (landmarkToOwner[i] == _owner) {\n', '                result[resultIndex] = i;\n', '                resultIndex++;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']