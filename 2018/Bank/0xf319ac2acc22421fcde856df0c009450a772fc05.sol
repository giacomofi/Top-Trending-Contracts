['pragma solidity ^0.4.24;\n', '\n', '/**\n', '*\n', 'WaitOrReinvest HYIP strategy:\n', 'Withdraw dividends will reduce investments.\n', 'Reinvest dividends will increase investments.\n', '50% dividends per day.\n', '*/\n', 'contract WaitOrReinvest{\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) investments;\n', '    mapping(address => uint256) joined;\n', '    mapping(address => address) referrer;\n', '\t\n', '    uint256 public stepUp = 50; //50% per day\n', '    address public ownerWallet;\n', '\n', '    event Invest(address investor, uint256 amount);\n', '    event Withdraw(address investor, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    /**\n', '     * @dev Сonstructor Sets the original roles of the contract \n', '     */\n', '     \n', '    constructor() public {\n', '        ownerWallet = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifiers\n', '     */\n', '     \n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerWallet);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwnerWallet The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwnerWallet) public onlyOwner {\n', '        require(newOwnerWallet != address(0));\n', '        emit OwnershipTransferred(ownerWallet, newOwnerWallet);\n', '        ownerWallet = newOwnerWallet;\n', '    }\n', '\n', '    /**\n', '     * @dev Investments\n', '     */\n', '\t \n', '    function () public payable {\n', '\t\tinvest(address(0));\n', '\t}\n', '\t\n', '    function invest(address _ref) public payable {\n', '        require(msg.value >= 0);\n', '        if (investments[msg.sender] > 0){\n', '            reinvest(); \n', '        }\n', '        investments[msg.sender] = investments[msg.sender].add(msg.value);\n', '        joined[msg.sender] = now;\n', '\t\t\n', '\t\tuint256 dfFee = msg.value.div(100).mul(5); //dev or ref fee\n', '        ownerWallet.transfer(dfFee);\n', '\t\t\n', '\t\t\n', '\t\tif (referrer[msg.sender] == address(0) && address(_ref) > 0 && address(_ref) != msg.sender)\n', '\t\t\treferrer[msg.sender] = _ref;\n', '\t\t\n', '\t\taddress ref = referrer[msg.sender];\t\n', '        if (ref > 0 ) \n', '\t\t\tref.transfer(dfFee); // bounty program\n', '\t\t\t\n', '        emit Invest(msg.sender, msg.value);\n', '    }\n', '\t\n', '    function reinvest() public {\n', '\t\trequire(investments[msg.sender] > 0);\n', '\t\trequire((now - joined[msg.sender]) > 5);\n', '\t\t\n', '\t\tuint256 balance = getDivsBalance(msg.sender);\n', '\t\t\n', '\t\tuint256 dfFee = balance.div(100).mul(5); //dev or ref fee\n', '\t\t\n', '\t\tif (address(this).balance > dfFee) {\n', '\t\t\taddress ref = referrer[msg.sender];\t \n', '\t\t\tif (ref != address(0))\n', '\t\t\t\tref.transfer(dfFee); // bounty program\n', '\t\t\telse \n', '\t\t\t\townerWallet.transfer(dfFee); // or dev fee\n', '\t\t\tbalance = balance.sub(dfFee); \n', '\t\t}\n', '\t\t\t\n', '\t\tinvestments[msg.sender] += balance;\n', '\t\tjoined[msg.sender] = now;\n', '\t}\t\n', '\n', '    /**\n', '    * @dev Evaluate current balance\n', '    * @param _address Address of investor\n', '    */\n', '    function getDivsBalance(address _address) view public returns (uint256) {\n', '        uint256 secondsCount = now.sub(joined[_address]);\n', '        uint256 percentDivs = investments[_address].mul(stepUp).div(100);\n', '        uint256 dividends = percentDivs.mul(secondsCount).div(86400);\n', '\n', '        return dividends;\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw dividends from contract\n', '    */\n', '    function withdraw() public returns (bool){\n', '        require(joined[msg.sender] > 0);\n', '        uint256 balance = getDivsBalance(msg.sender);\n', '        if (address(this).balance > balance){\n', '            if (balance > 0){\n', '\t\t\t\tjoined[msg.sender]=now;\n', '                msg.sender.transfer(balance);\n', '\t\t\t\t\n', '\t\t\t\tif (investments[msg.sender] > balance)\n', '\t\t\t\t\tinvestments[msg.sender] = SafeMath.sub(investments[msg.sender],balance);\n', '\t\t\t\telse \n', '\t\t\t\t\tinvestments[msg.sender] = 0;\n', '\t\t\t\t\t\n', '                emit Withdraw(msg.sender, balance);\n', '            }\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '\n', '    /**\n', '    * @dev Gets balance of the sender address.\n', '    * @return An uint256 representing the amount owned by the msg.sender.\n', '    */\n', '    function checkDivsBalance() public view returns (uint256) {\n', '        return getDivsBalance(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Gets investments of the specified address.\n', '    * @param _investor The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function checkInvestments(address _investor) public view returns (uint256) {\n', '        return investments[_investor];\n', '    }\n', '\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', '*\n', 'WaitOrReinvest HYIP strategy:\n', 'Withdraw dividends will reduce investments.\n', 'Reinvest dividends will increase investments.\n', '50% dividends per day.\n', '*/\n', 'contract WaitOrReinvest{\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) investments;\n', '    mapping(address => uint256) joined;\n', '    mapping(address => address) referrer;\n', '\t\n', '    uint256 public stepUp = 50; //50% per day\n', '    address public ownerWallet;\n', '\n', '    event Invest(address investor, uint256 amount);\n', '    event Withdraw(address investor, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    /**\n', '     * @dev Сonstructor Sets the original roles of the contract \n', '     */\n', '     \n', '    constructor() public {\n', '        ownerWallet = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifiers\n', '     */\n', '     \n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerWallet);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwnerWallet The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwnerWallet) public onlyOwner {\n', '        require(newOwnerWallet != address(0));\n', '        emit OwnershipTransferred(ownerWallet, newOwnerWallet);\n', '        ownerWallet = newOwnerWallet;\n', '    }\n', '\n', '    /**\n', '     * @dev Investments\n', '     */\n', '\t \n', '    function () public payable {\n', '\t\tinvest(address(0));\n', '\t}\n', '\t\n', '    function invest(address _ref) public payable {\n', '        require(msg.value >= 0);\n', '        if (investments[msg.sender] > 0){\n', '            reinvest(); \n', '        }\n', '        investments[msg.sender] = investments[msg.sender].add(msg.value);\n', '        joined[msg.sender] = now;\n', '\t\t\n', '\t\tuint256 dfFee = msg.value.div(100).mul(5); //dev or ref fee\n', '        ownerWallet.transfer(dfFee);\n', '\t\t\n', '\t\t\n', '\t\tif (referrer[msg.sender] == address(0) && address(_ref) > 0 && address(_ref) != msg.sender)\n', '\t\t\treferrer[msg.sender] = _ref;\n', '\t\t\n', '\t\taddress ref = referrer[msg.sender];\t\n', '        if (ref > 0 ) \n', '\t\t\tref.transfer(dfFee); // bounty program\n', '\t\t\t\n', '        emit Invest(msg.sender, msg.value);\n', '    }\n', '\t\n', '    function reinvest() public {\n', '\t\trequire(investments[msg.sender] > 0);\n', '\t\trequire((now - joined[msg.sender]) > 5);\n', '\t\t\n', '\t\tuint256 balance = getDivsBalance(msg.sender);\n', '\t\t\n', '\t\tuint256 dfFee = balance.div(100).mul(5); //dev or ref fee\n', '\t\t\n', '\t\tif (address(this).balance > dfFee) {\n', '\t\t\taddress ref = referrer[msg.sender];\t \n', '\t\t\tif (ref != address(0))\n', '\t\t\t\tref.transfer(dfFee); // bounty program\n', '\t\t\telse \n', '\t\t\t\townerWallet.transfer(dfFee); // or dev fee\n', '\t\t\tbalance = balance.sub(dfFee); \n', '\t\t}\n', '\t\t\t\n', '\t\tinvestments[msg.sender] += balance;\n', '\t\tjoined[msg.sender] = now;\n', '\t}\t\n', '\n', '    /**\n', '    * @dev Evaluate current balance\n', '    * @param _address Address of investor\n', '    */\n', '    function getDivsBalance(address _address) view public returns (uint256) {\n', '        uint256 secondsCount = now.sub(joined[_address]);\n', '        uint256 percentDivs = investments[_address].mul(stepUp).div(100);\n', '        uint256 dividends = percentDivs.mul(secondsCount).div(86400);\n', '\n', '        return dividends;\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw dividends from contract\n', '    */\n', '    function withdraw() public returns (bool){\n', '        require(joined[msg.sender] > 0);\n', '        uint256 balance = getDivsBalance(msg.sender);\n', '        if (address(this).balance > balance){\n', '            if (balance > 0){\n', '\t\t\t\tjoined[msg.sender]=now;\n', '                msg.sender.transfer(balance);\n', '\t\t\t\t\n', '\t\t\t\tif (investments[msg.sender] > balance)\n', '\t\t\t\t\tinvestments[msg.sender] = SafeMath.sub(investments[msg.sender],balance);\n', '\t\t\t\telse \n', '\t\t\t\t\tinvestments[msg.sender] = 0;\n', '\t\t\t\t\t\n', '                emit Withdraw(msg.sender, balance);\n', '            }\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '\n', '    /**\n', '    * @dev Gets balance of the sender address.\n', '    * @return An uint256 representing the amount owned by the msg.sender.\n', '    */\n', '    function checkDivsBalance() public view returns (uint256) {\n', '        return getDivsBalance(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Gets investments of the specified address.\n', '    * @param _investor The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function checkInvestments(address _investor) public view returns (uint256) {\n', '        return investments[_investor];\n', '    }\n', '\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
