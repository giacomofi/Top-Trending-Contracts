['pragma solidity ^0.4.20;\n', '\n', 'contract EtherPaint {\n', '   // scaleFactor is used to convert Ether into tokens and vice-versa: they&#39;re of different\n', '   // orders of magnitude, hence the need to bridge between the two.\n', '   uint256 constant scaleFactor = 0x10000000000000000; //0x10000000000000000;  // 2^64\n', '\n', '   // CRR = 50%\n', '   // CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\n', '   // For more on this: check out https://en.wikipedia.org/wiki/Reserve_requirement\n', '   int constant crr_n = 1; // CRR numerator\n', '   int constant crr_d = 2; // CRR denominator\n', '\n', '   // The price coefficient. Chosen such that at 1 token total supply\n', '   // the amount in reserve is 0.5 ether and token price is 1 Ether.\n', '   int constant price_coeff = -0x296ABF784A358468C;\n', '\n', '   // Array between each address and their number of tokens.\n', '   mapping(address => uint256[16]) public tokenBalance;\n', '\n', '   uint256[128][128] public colorPerCoordinate;\n', '   uint256[16] public colorPerCanvas;\n', '\n', '   event colorUpdate(uint8 posx, uint8 posy, uint8 colorid);\n', '   event priceUpdate(uint8 colorid);\n', '   event tokenUpdate(uint8 colorid, address who);\n', '   event dividendUpdate();\n', '\n', '   event pushuint(uint256 s);\n', '      \n', '   // Array between each address and how much Ether has been paid out to it.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   mapping(address => int256[16]) public payouts;\n', '\n', '   // Variable tracking how many tokens are in existence overall.\n', '   uint256[16] public totalSupply;\n', '\n', '   uint256 public allTotalSupply;\n', '\n', '   // Aggregate sum of all payouts.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   int256[16] totalPayouts;\n', '\n', '   // Variable tracking how much Ether each token is currently worth.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   uint256[16] earningsPerToken;\n', '   \n', '   // Current contract balance in Ether\n', '   uint256[16] public contractBalance;\n', '\n', '   address public owner;\n', '\n', '   uint256 public ownerFee;\n', '\n', '\n', '\n', '   function EtherPaint() public {\n', '       owner = msg.sender;\n', '       colorPerCanvas[0] = 128*128;\n', '      pushuint(1 finney);\n', '   }\n', '\n', '   // Returns the number of tokens currently held by _owner.\n', '   function balanceOf(address _owner, uint8 colorid) public constant returns (uint256 balance) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return tokenBalance[_owner][colorid];\n', '   }\n', '\n', '   // Withdraws all dividends held by the caller sending the transaction, updates\n', '   // the requisite global variables, and transfers Ether back to the caller.\n', '   function withdraw(uint8 colorid) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      // Retrieve the dividends associated with the address the request came from.\n', '      var balance = dividends(msg.sender, colorid);\n', '      \n', '      // Update the payouts array, incrementing the request address by `balance`.\n', '      payouts[msg.sender][colorid] += (int256) (balance * scaleFactor);\n', '      \n', '      // Increase the total amount that&#39;s been paid out to maintain invariance.\n', '      totalPayouts[colorid] += (int256) (balance * scaleFactor);\n', '      \n', '      // Send the dividends to the address that requested the withdraw.\n', '      contractBalance[colorid] = sub(contractBalance[colorid], div(mul(balance, 95),100));\n', '      msg.sender.transfer(balance);\n', '   }\n', '\n', '   function withdrawOwnerFee() public{\n', '      if (msg.sender == owner){\n', '         owner.transfer(ownerFee);\n', '         ownerFee = 0;\n', '      }\n', '   }\n', '\n', '   // Sells your tokens for Ether. This Ether is assigned to the callers entry\n', '   // in the tokenBalance array, and therefore is shown as a dividend. A second\n', '   // call to withdraw() must be made to invoke the transfer of Ether back to your address.\n', '   function sellMyTokens(uint8 colorid) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      var balance = balanceOf(msg.sender, colorid);\n', '      sell(balance, colorid);\n', '      priceUpdate(colorid);\n', '      dividendUpdate();\n', '      tokenUpdate(colorid, msg.sender);\n', '   }\n', '   \n', '    function sellMyTokensAmount(uint8 colorid, uint256 amount) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      var balance = balanceOf(msg.sender, colorid);\n', '      if (amount <= balance){\n', '        sell(amount, colorid);\n', '        priceUpdate(colorid);\n', '        dividendUpdate();\n', '        tokenUpdate(colorid, msg.sender);\n', '      }\n', '   }\n', '\n', '   // The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\n', '   // invokes the withdraw() function, sending the resulting Ether to the callers address.\n', '    function getMeOutOfHere() public {\n', '      for (uint8 i=0; i<16; i++){\n', '         sellMyTokens(i);\n', '         withdraw(i);\n', '      }\n', '\n', '   }\n', '\n', '   // Gatekeeper function to check if the amount of Ether being sent isn&#39;t either\n', '   // too small or too large. If it passes, goes direct to buy().\n', '   function fund(uint8 colorid, uint8 posx, uint8 posy) payable public {\n', '      // Don&#39;t allow for funding if the amount of Ether sent is less than 1 szabo.\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      if ((msg.value > 0.000001 ether) && (posx >= 0) && (posx <= 127) && (posy >= 0) && (posy <= 127)) {\n', '         contractBalance[colorid] = add(contractBalance[colorid], div(mul(msg.value, 95),100));\n', '         buy(colorid);\n', '         colorPerCanvas[colorPerCoordinate[posx][posy]] = sub(colorPerCanvas[colorPerCoordinate[posx][posy]], 1);\n', '         colorPerCoordinate[posx][posy] = colorid;\n', '         colorPerCanvas[colorid] = add(colorPerCanvas[colorid],1);\n', '         colorUpdate(posx, posy, colorid);\n', '         priceUpdate(colorid);\n', '         dividendUpdate();\n', '         tokenUpdate(colorid, msg.sender);\n', '\n', '      } else {\n', '         revert();\n', '      }\n', '    }\n', '\n', '   // Function that returns the (dynamic) price of buying a finney worth of tokens.\n', '   function buyPrice(uint8 colorid) public constant returns (uint) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return getTokensForEther(1 finney, colorid);\n', '   }\n', '\n', '   // Function that returns the (dynamic) price of selling a single token.\n', '   function sellPrice(uint8 colorid) public constant returns (uint) {\n', '         if (colorid >= 16){\n', '            revert();\n', '         }\n', '        var eth = getEtherForTokens(1 finney, colorid);\n', '        var fee = div(eth, 10);\n', '        return eth - fee;\n', '    }\n', '\n', '   // Calculate the current dividends associated with the caller address. This is the net result\n', '   // of multiplying the number of tokens held by their current value in Ether and subtracting the\n', '   // Ether that has already been paid out.\n', '   function dividends(address _owner, uint8 colorid) public constant returns (uint256 amount) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return (uint256) ((int256)(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor;\n', '   }\n', '\n', '   // Version of withdraw that extracts the dividends and sends the Ether to the caller.\n', '   // This is only used in the case when there is no transaction data, and that should be\n', '   // quite rare unless interacting directly with the smart contract.\n', '   //function withdrawOld(address to) public {\n', '      // Retrieve the dividends associated with the address the request came from.\n', '     // var balance = dividends(msg.sender);\n', '      \n', '      // Update the payouts array, incrementing the request address by `balance`.\n', '      //payouts[msg.sender] += (int256) (balance * scaleFactor);\n', '      \n', '      // Increase the total amount that&#39;s been paid out to maintain invariance.\n', '      //totalPayouts += (int256) (balance * scaleFactor);\n', '      \n', '      // Send the dividends to the address that requested the withdraw.\n', '      //contractBalance = sub(contractBalance, balance);\n', '      //to.transfer(balance);      \n', '   //}\n', '\n', '   // Internal balance function, used to calculate the dynamic reserve value.\n', '   function balance(uint8 colorid) internal constant returns (uint256 amount) {\n', '\n', '      // msg.value is the amount of Ether sent by the transaction.\n', '      return contractBalance[colorid] - msg.value;\n', '   }\n', '\n', '   function buy(uint8 colorid) internal {\n', '\n', '      // Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\n', '\n', '      if (msg.value < 0.000001 ether || msg.value > 1000000 ether)\n', '         revert();\n', '                  \n', '      // msg.sender is the address of the caller.\n', '      //var sender = msg.sender;\n', '      \n', '      // 10% of the total Ether sent is used to pay existing holders.\n', '      var fee = mul(div(msg.value, 20), 4);\n', '      \n', '      // The amount of Ether used to purchase new tokens for the caller.\n', '      //var numEther = msg.value - fee;\n', '      \n', '      // The number of tokens which can be purchased for numEther.\n', '      var numTokens = getTokensForEther(msg.value - fee, colorid);\n', '      \n', '      // The buyer fee, scaled by the scaleFactor variable.\n', '      uint256 buyerFee = 0;\n', '      \n', '      // Check that we have tokens in existence (this should always be true), or\n', '      // else you&#39;re gonna have a bad time.\n', '      if (totalSupply[colorid] > 0) {\n', '         // Compute the bonus co-efficient for all existing holders and the buyer.\n', '         // The buyer receives part of the distribution for each token bought in the\n', '         // same way they would have if they bought each token individually.\n', '\n', '         for (uint8 c=0; c<16; c++){\n', '            if (totalSupply[c] > 0){\n', '               var theExtraFee = mul(div(mul(div(fee,4), scaleFactor), allTotalSupply), totalSupply[c]) + mul(div(div(fee,4), 128*128),mul(colorPerCanvas[c], scaleFactor));\n', '               //var globalFee = div(mul(mul(div(div(fee,4), allTotalSupply), totalSupply[c]), scaleFactor),totalSupply[c]);\n', '\n', '               if (c==colorid){\n', '                  \n', '                buyerFee = (div(fee,4) + div(theExtraFee,scaleFactor))*scaleFactor - (div(fee, 4) + div(theExtraFee,scaleFactor)) * (scaleFactor - (reserve(colorid) + msg.value - fee) * numTokens * scaleFactor / (totalSupply[colorid] + numTokens) / (msg.value - fee))\n', '\t\t\t    * (uint)(crr_d) / (uint)(crr_d-crr_n);\n', '             \n', '\n', '\n', '\n', '\n', '               }\n', '               else{\n', '\n', '                   \n', '                  earningsPerToken[c] = add(earningsPerToken[c], div(theExtraFee, totalSupply[c]));\n', '\n', '\n', '               }\n', '            }\n', '         }\n', '         \n', '\n', '\n', '         \n', '\n', '\n', '\n', '         ownerFee = add(ownerFee, div(fee,4));\n', '            \n', '         // The total reward to be distributed amongst the masses is the fee (in Ether)\n', '         // multiplied by the bonus co-efficient.\n', '\n', '\n', '         // Fee is distributed to all existing token holders before the new tokens are purchased.\n', '         // rewardPerShare is the amount gained per token thanks to this buy-in.\n', '\n', '         \n', '         // The Ether value per token is increased proportionally.\n', '         // 5%\n', '\n', '         earningsPerToken[colorid] = earningsPerToken[colorid] +  buyerFee / (totalSupply[colorid]);\n', '\n', '             \n', '         \n', '      }\n', '\n', '         totalSupply[colorid] = add(totalSupply[colorid], numTokens);\n', '\n', '         allTotalSupply = add(allTotalSupply, numTokens);\n', '\n', '      // Add the numTokens which were just created to the total supply. We&#39;re a crypto central bank!\n', '\n', '\n', '      \n', '\n', '      // Assign the tokens to the balance of the buyer.\n', '      tokenBalance[msg.sender][colorid] = add(tokenBalance[msg.sender][colorid], numTokens);\n', '\n', '      // Update the payout array so that the buyer cannot claim dividends on previous purchases.\n', '      // Also include the fee paid for entering the scheme.\n', '      // First we compute how much was just paid out to the buyer...\n', '\n', '      \n', '      // Then we update the payouts array for the buyer with this amount...\n', '      payouts[msg.sender][colorid] +=  (int256) ((earningsPerToken[colorid] * numTokens) - buyerFee);\n', '      \n', '      // And then we finally add it to the variable tracking the total amount spent to maintain invariance.\n', '      totalPayouts[colorid]    +=  (int256) ((earningsPerToken[colorid] * numTokens) - buyerFee);\n', '      \n', '   }\n', '\n', '   // Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\n', '   // to discouraging dumping, and means that if someone near the top sells, the fee distributed\n', '   // will be *significant*.\n', '   function sell(uint256 amount, uint8 colorid) internal {\n', '       // Calculate the amount of Ether that the holders tokens sell for at the current sell price.\n', '      var numEthersBeforeFee = getEtherForTokens(amount, colorid);\n', '      \n', '      // 20% of the resulting Ether is used to pay remaining holders.\n', '      var fee = mul(div(numEthersBeforeFee, 20), 4);\n', '      \n', '      // Net Ether for the seller after the fee has been subtracted.\n', '      var numEthers = numEthersBeforeFee - fee;\n', '      \n', '      // *Remove* the numTokens which were just sold from the total supply. We&#39;re /definitely/ a crypto central bank.\n', '      totalSupply[colorid] = sub(totalSupply[colorid], amount);\n', '      allTotalSupply = sub(allTotalSupply, amount);\n', '      \n', '        // Remove the tokens from the balance of the buyer.\n', '      tokenBalance[msg.sender][colorid] = sub(tokenBalance[msg.sender][colorid], amount);\n', '\n', '        // Update the payout array so that the seller cannot claim future dividends unless they buy back in.\n', '      // First we compute how much was just paid out to the seller...\n', '      var payoutDiff = (int256) (earningsPerToken[colorid] * amount + (numEthers * scaleFactor));\n', '      \n', '        // We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\n', '      // since they&#39;re selling all of their tokens). This makes sure the seller isn&#39;t disadvantaged if\n', '      // they decide to buy back in.\n', '      payouts[msg.sender][colorid] -= payoutDiff;     \n', '      \n', '      // Decrease the total amount that&#39;s been paid out to maintain invariance.\n', '      totalPayouts[colorid] -= payoutDiff;\n', '      \n', '      // Check that we have tokens in existence (this is a bit of an irrelevant check since we&#39;re\n', '      // selling tokens, but it guards against division by zero).\n', '      if (totalSupply[colorid] > 0) {\n', '         // Scale the Ether taken as the selling fee by the scaleFactor variable.\n', '\n', '         for (uint8 c=0; c<16; c++){\n', '            if (totalSupply[c] > 0){\n', '               var theExtraFee = mul(div(mul(div(fee,4), scaleFactor), allTotalSupply), totalSupply[c]) + mul(div(div(fee,4), 128*128),mul(colorPerCanvas[c], scaleFactor));\n', '            \n', '               earningsPerToken[c] = add(earningsPerToken[c], div(theExtraFee,totalSupply[c]));\n', '            }\n', '         }\n', '\n', '         ownerFee = add(ownerFee, div(fee,4));\n', '\n', '         var etherFee = div(fee,4) * scaleFactor;\n', '         \n', '         // Fee is distributed to all remaining token holders.\n', '         // rewardPerShare is the amount gained per token thanks to this sell.\n', '         var rewardPerShare = etherFee / totalSupply[colorid];\n', '         \n', '         // The Ether value per token is increased proportionally.\n', '         earningsPerToken[colorid] = add(earningsPerToken[colorid], rewardPerShare);\n', '\n', '         \n', '      }\n', '   }\n', '\n', '   // Dynamic value of Ether in reserve, according to the CRR requirement.\n', '   function reserve(uint8 colorid) internal constant returns (uint256 amount) {\n', '      return sub(balance(colorid),\n', '          ((uint256) ((int256) (earningsPerToken[colorid] * totalSupply[colorid]) - totalPayouts[colorid]) / scaleFactor));\n', '   }\n', '\n', '   // Calculates the number of tokens that can be bought for a given amount of Ether, according to the\n', '   // dynamic reserve and totalSupply values (derived from the buy and sell prices).\n', '   function getTokensForEther(uint256 ethervalue, uint8 colorid) public constant returns (uint256 tokens) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return sub(fixedExp(fixedLog(reserve(colorid) + ethervalue)*crr_n/crr_d + price_coeff), totalSupply[colorid]);\n', '   }\n', '\n', '\n', '\n', '   // Converts a number tokens into an Ether value.\n', '   function getEtherForTokens(uint256 tokens, uint8 colorid) public constant returns (uint256 ethervalue) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      // How much reserve Ether do we have left in the contract?\n', '      var reserveAmount = reserve(colorid);\n', '\n', '      // If you&#39;re the Highlander (or bagholder), you get The Prize. Everything left in the vault.\n', '      if (tokens == totalSupply[colorid])\n', '         return reserveAmount;\n', '\n', '      // If there would be excess Ether left after the transaction this is called within, return the Ether\n', '      // corresponding to the equation in Dr Jochen Hoenicke&#39;s original Ponzi paper, which can be found\n', '      // at https://test.jochen-hoenicke.de/eth/ponzitoken/ in the third equation, with the CRR numerator \n', '      // and denominator altered to 1 and 2 respectively.\n', '      return sub(reserveAmount, fixedExp((fixedLog(totalSupply[colorid] - tokens) - price_coeff) * crr_d/crr_n));\n', '   }\n', '\n', '// You don&#39;t care about these, but if you really do they&#39;re hex values for \n', '   // co-efficients used to simulate approximations of the log and exp functions.\n', '   int256  constant one        = 0x10000000000000000;\n', '   uint256 constant sqrt2      = 0x16a09e667f3bcc908;\n', '   uint256 constant sqrtdot5   = 0x0b504f333f9de6484;\n', '   int256  constant ln2        = 0x0b17217f7d1cf79ac;\n', '   int256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\n', '   int256  constant c1         = 0x1ffffffffff9dac9b;\n', '   int256  constant c3         = 0x0aaaaaaac16877908;\n', '   int256  constant c5         = 0x0666664e5e9fa0c99;\n', '   int256  constant c7         = 0x049254026a7630acf;\n', '   int256  constant c9         = 0x038bd75ed37753d68;\n', '   int256  constant c11        = 0x03284a0c14610924f;\n', '\n', '   // The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\n', '   // approximates the function log(1+x)-log(1-x)\n', '   // Hence R(s) = log((1+s)/(1-s)) = log(a)\n', '   function fixedLog(uint256 a) internal pure returns (int256 log) {\n', '      int32 scale = 0;\n', '      while (a > sqrt2) {\n', '         a /= 2;\n', '         scale++;\n', '      }\n', '      while (a <= sqrtdot5) {\n', '         a *= 2;\n', '         scale--;\n', '      }\n', '      int256 s = (((int256)(a) - one) * one) / ((int256)(a) + one);\n', '      var z = (s*s) / one;\n', '      return scale * ln2 +\n', '         (s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one))\n', '            /one))/one))/one))/one))/one);\n', '   }\n', '\n', '   int256 constant c2 =  0x02aaaaaaaaa015db0;\n', '   int256 constant c4 = -0x000b60b60808399d1;\n', '   int256 constant c6 =  0x0000455956bccdd06;\n', '   int256 constant c8 = -0x000001b893ad04b3a;\n', '   \n', '   // The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\n', '   // approximates the function x*(exp(x)+1)/(exp(x)-1)\n', '   // Hence exp(x) = (R(x)+x)/(R(x)-x)\n', '   function fixedExp(int256 a) internal pure returns (uint256 exp) {\n', '      int256 scale = (a + (ln2_64dot5)) / ln2 - 64;\n', '      a -= scale*ln2;\n', '      int256 z = (a*a) / one;\n', '      int256 R = ((int256)(2) * one) +\n', '         (z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one);\n', '      exp = (uint256) (((R + a) * one) / (R - a));\n', '      if (scale >= 0)\n', '         exp <<= scale;\n', '      else\n', '         exp >>= -scale;\n', '      return exp;\n', '   }\n', '   \n', '   // The below are safemath implementations of the four arithmetic operators\n', '   // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', '      // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '      return c;\n', '   }\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '\n', '   // This allows you to buy tokens by sending Ether directly to the smart contract\n', '   // without including any transaction data (useful for, say, mobile wallet apps).\n', '   function () payable public {\n', '      // msg.value is the amount of Ether sent by the transaction.\n', '      revert();\n', '      //if (msg.value > 0) {\n', '      //   revert();\n', '      //} else {\n', '      //   for (uint8 i=0; i<16; i++){\n', '      //     withdraw(i);\n', '      //   }\n', '\n', '      //}\n', '   }\n', '   \n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract EtherPaint {\n', "   // scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\n", '   // orders of magnitude, hence the need to bridge between the two.\n', '   uint256 constant scaleFactor = 0x10000000000000000; //0x10000000000000000;  // 2^64\n', '\n', '   // CRR = 50%\n', '   // CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\n', '   // For more on this: check out https://en.wikipedia.org/wiki/Reserve_requirement\n', '   int constant crr_n = 1; // CRR numerator\n', '   int constant crr_d = 2; // CRR denominator\n', '\n', '   // The price coefficient. Chosen such that at 1 token total supply\n', '   // the amount in reserve is 0.5 ether and token price is 1 Ether.\n', '   int constant price_coeff = -0x296ABF784A358468C;\n', '\n', '   // Array between each address and their number of tokens.\n', '   mapping(address => uint256[16]) public tokenBalance;\n', '\n', '   uint256[128][128] public colorPerCoordinate;\n', '   uint256[16] public colorPerCanvas;\n', '\n', '   event colorUpdate(uint8 posx, uint8 posy, uint8 colorid);\n', '   event priceUpdate(uint8 colorid);\n', '   event tokenUpdate(uint8 colorid, address who);\n', '   event dividendUpdate();\n', '\n', '   event pushuint(uint256 s);\n', '      \n', '   // Array between each address and how much Ether has been paid out to it.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   mapping(address => int256[16]) public payouts;\n', '\n', '   // Variable tracking how many tokens are in existence overall.\n', '   uint256[16] public totalSupply;\n', '\n', '   uint256 public allTotalSupply;\n', '\n', '   // Aggregate sum of all payouts.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   int256[16] totalPayouts;\n', '\n', '   // Variable tracking how much Ether each token is currently worth.\n', '   // Note that this is scaled by the scaleFactor variable.\n', '   uint256[16] earningsPerToken;\n', '   \n', '   // Current contract balance in Ether\n', '   uint256[16] public contractBalance;\n', '\n', '   address public owner;\n', '\n', '   uint256 public ownerFee;\n', '\n', '\n', '\n', '   function EtherPaint() public {\n', '       owner = msg.sender;\n', '       colorPerCanvas[0] = 128*128;\n', '      pushuint(1 finney);\n', '   }\n', '\n', '   // Returns the number of tokens currently held by _owner.\n', '   function balanceOf(address _owner, uint8 colorid) public constant returns (uint256 balance) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return tokenBalance[_owner][colorid];\n', '   }\n', '\n', '   // Withdraws all dividends held by the caller sending the transaction, updates\n', '   // the requisite global variables, and transfers Ether back to the caller.\n', '   function withdraw(uint8 colorid) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      // Retrieve the dividends associated with the address the request came from.\n', '      var balance = dividends(msg.sender, colorid);\n', '      \n', '      // Update the payouts array, incrementing the request address by `balance`.\n', '      payouts[msg.sender][colorid] += (int256) (balance * scaleFactor);\n', '      \n', "      // Increase the total amount that's been paid out to maintain invariance.\n", '      totalPayouts[colorid] += (int256) (balance * scaleFactor);\n', '      \n', '      // Send the dividends to the address that requested the withdraw.\n', '      contractBalance[colorid] = sub(contractBalance[colorid], div(mul(balance, 95),100));\n', '      msg.sender.transfer(balance);\n', '   }\n', '\n', '   function withdrawOwnerFee() public{\n', '      if (msg.sender == owner){\n', '         owner.transfer(ownerFee);\n', '         ownerFee = 0;\n', '      }\n', '   }\n', '\n', '   // Sells your tokens for Ether. This Ether is assigned to the callers entry\n', '   // in the tokenBalance array, and therefore is shown as a dividend. A second\n', '   // call to withdraw() must be made to invoke the transfer of Ether back to your address.\n', '   function sellMyTokens(uint8 colorid) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      var balance = balanceOf(msg.sender, colorid);\n', '      sell(balance, colorid);\n', '      priceUpdate(colorid);\n', '      dividendUpdate();\n', '      tokenUpdate(colorid, msg.sender);\n', '   }\n', '   \n', '    function sellMyTokensAmount(uint8 colorid, uint256 amount) public {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      var balance = balanceOf(msg.sender, colorid);\n', '      if (amount <= balance){\n', '        sell(amount, colorid);\n', '        priceUpdate(colorid);\n', '        dividendUpdate();\n', '        tokenUpdate(colorid, msg.sender);\n', '      }\n', '   }\n', '\n', '   // The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\n', '   // invokes the withdraw() function, sending the resulting Ether to the callers address.\n', '    function getMeOutOfHere() public {\n', '      for (uint8 i=0; i<16; i++){\n', '         sellMyTokens(i);\n', '         withdraw(i);\n', '      }\n', '\n', '   }\n', '\n', "   // Gatekeeper function to check if the amount of Ether being sent isn't either\n", '   // too small or too large. If it passes, goes direct to buy().\n', '   function fund(uint8 colorid, uint8 posx, uint8 posy) payable public {\n', "      // Don't allow for funding if the amount of Ether sent is less than 1 szabo.\n", '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      if ((msg.value > 0.000001 ether) && (posx >= 0) && (posx <= 127) && (posy >= 0) && (posy <= 127)) {\n', '         contractBalance[colorid] = add(contractBalance[colorid], div(mul(msg.value, 95),100));\n', '         buy(colorid);\n', '         colorPerCanvas[colorPerCoordinate[posx][posy]] = sub(colorPerCanvas[colorPerCoordinate[posx][posy]], 1);\n', '         colorPerCoordinate[posx][posy] = colorid;\n', '         colorPerCanvas[colorid] = add(colorPerCanvas[colorid],1);\n', '         colorUpdate(posx, posy, colorid);\n', '         priceUpdate(colorid);\n', '         dividendUpdate();\n', '         tokenUpdate(colorid, msg.sender);\n', '\n', '      } else {\n', '         revert();\n', '      }\n', '    }\n', '\n', '   // Function that returns the (dynamic) price of buying a finney worth of tokens.\n', '   function buyPrice(uint8 colorid) public constant returns (uint) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return getTokensForEther(1 finney, colorid);\n', '   }\n', '\n', '   // Function that returns the (dynamic) price of selling a single token.\n', '   function sellPrice(uint8 colorid) public constant returns (uint) {\n', '         if (colorid >= 16){\n', '            revert();\n', '         }\n', '        var eth = getEtherForTokens(1 finney, colorid);\n', '        var fee = div(eth, 10);\n', '        return eth - fee;\n', '    }\n', '\n', '   // Calculate the current dividends associated with the caller address. This is the net result\n', '   // of multiplying the number of tokens held by their current value in Ether and subtracting the\n', '   // Ether that has already been paid out.\n', '   function dividends(address _owner, uint8 colorid) public constant returns (uint256 amount) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return (uint256) ((int256)(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor;\n', '   }\n', '\n', '   // Version of withdraw that extracts the dividends and sends the Ether to the caller.\n', '   // This is only used in the case when there is no transaction data, and that should be\n', '   // quite rare unless interacting directly with the smart contract.\n', '   //function withdrawOld(address to) public {\n', '      // Retrieve the dividends associated with the address the request came from.\n', '     // var balance = dividends(msg.sender);\n', '      \n', '      // Update the payouts array, incrementing the request address by `balance`.\n', '      //payouts[msg.sender] += (int256) (balance * scaleFactor);\n', '      \n', "      // Increase the total amount that's been paid out to maintain invariance.\n", '      //totalPayouts += (int256) (balance * scaleFactor);\n', '      \n', '      // Send the dividends to the address that requested the withdraw.\n', '      //contractBalance = sub(contractBalance, balance);\n', '      //to.transfer(balance);      \n', '   //}\n', '\n', '   // Internal balance function, used to calculate the dynamic reserve value.\n', '   function balance(uint8 colorid) internal constant returns (uint256 amount) {\n', '\n', '      // msg.value is the amount of Ether sent by the transaction.\n', '      return contractBalance[colorid] - msg.value;\n', '   }\n', '\n', '   function buy(uint8 colorid) internal {\n', '\n', '      // Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\n', '\n', '      if (msg.value < 0.000001 ether || msg.value > 1000000 ether)\n', '         revert();\n', '                  \n', '      // msg.sender is the address of the caller.\n', '      //var sender = msg.sender;\n', '      \n', '      // 10% of the total Ether sent is used to pay existing holders.\n', '      var fee = mul(div(msg.value, 20), 4);\n', '      \n', '      // The amount of Ether used to purchase new tokens for the caller.\n', '      //var numEther = msg.value - fee;\n', '      \n', '      // The number of tokens which can be purchased for numEther.\n', '      var numTokens = getTokensForEther(msg.value - fee, colorid);\n', '      \n', '      // The buyer fee, scaled by the scaleFactor variable.\n', '      uint256 buyerFee = 0;\n', '      \n', '      // Check that we have tokens in existence (this should always be true), or\n', "      // else you're gonna have a bad time.\n", '      if (totalSupply[colorid] > 0) {\n', '         // Compute the bonus co-efficient for all existing holders and the buyer.\n', '         // The buyer receives part of the distribution for each token bought in the\n', '         // same way they would have if they bought each token individually.\n', '\n', '         for (uint8 c=0; c<16; c++){\n', '            if (totalSupply[c] > 0){\n', '               var theExtraFee = mul(div(mul(div(fee,4), scaleFactor), allTotalSupply), totalSupply[c]) + mul(div(div(fee,4), 128*128),mul(colorPerCanvas[c], scaleFactor));\n', '               //var globalFee = div(mul(mul(div(div(fee,4), allTotalSupply), totalSupply[c]), scaleFactor),totalSupply[c]);\n', '\n', '               if (c==colorid){\n', '                  \n', '                buyerFee = (div(fee,4) + div(theExtraFee,scaleFactor))*scaleFactor - (div(fee, 4) + div(theExtraFee,scaleFactor)) * (scaleFactor - (reserve(colorid) + msg.value - fee) * numTokens * scaleFactor / (totalSupply[colorid] + numTokens) / (msg.value - fee))\n', '\t\t\t    * (uint)(crr_d) / (uint)(crr_d-crr_n);\n', '             \n', '\n', '\n', '\n', '\n', '               }\n', '               else{\n', '\n', '                   \n', '                  earningsPerToken[c] = add(earningsPerToken[c], div(theExtraFee, totalSupply[c]));\n', '\n', '\n', '               }\n', '            }\n', '         }\n', '         \n', '\n', '\n', '         \n', '\n', '\n', '\n', '         ownerFee = add(ownerFee, div(fee,4));\n', '            \n', '         // The total reward to be distributed amongst the masses is the fee (in Ether)\n', '         // multiplied by the bonus co-efficient.\n', '\n', '\n', '         // Fee is distributed to all existing token holders before the new tokens are purchased.\n', '         // rewardPerShare is the amount gained per token thanks to this buy-in.\n', '\n', '         \n', '         // The Ether value per token is increased proportionally.\n', '         // 5%\n', '\n', '         earningsPerToken[colorid] = earningsPerToken[colorid] +  buyerFee / (totalSupply[colorid]);\n', '\n', '             \n', '         \n', '      }\n', '\n', '         totalSupply[colorid] = add(totalSupply[colorid], numTokens);\n', '\n', '         allTotalSupply = add(allTotalSupply, numTokens);\n', '\n', "      // Add the numTokens which were just created to the total supply. We're a crypto central bank!\n", '\n', '\n', '      \n', '\n', '      // Assign the tokens to the balance of the buyer.\n', '      tokenBalance[msg.sender][colorid] = add(tokenBalance[msg.sender][colorid], numTokens);\n', '\n', '      // Update the payout array so that the buyer cannot claim dividends on previous purchases.\n', '      // Also include the fee paid for entering the scheme.\n', '      // First we compute how much was just paid out to the buyer...\n', '\n', '      \n', '      // Then we update the payouts array for the buyer with this amount...\n', '      payouts[msg.sender][colorid] +=  (int256) ((earningsPerToken[colorid] * numTokens) - buyerFee);\n', '      \n', '      // And then we finally add it to the variable tracking the total amount spent to maintain invariance.\n', '      totalPayouts[colorid]    +=  (int256) ((earningsPerToken[colorid] * numTokens) - buyerFee);\n', '      \n', '   }\n', '\n', '   // Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\n', '   // to discouraging dumping, and means that if someone near the top sells, the fee distributed\n', '   // will be *significant*.\n', '   function sell(uint256 amount, uint8 colorid) internal {\n', '       // Calculate the amount of Ether that the holders tokens sell for at the current sell price.\n', '      var numEthersBeforeFee = getEtherForTokens(amount, colorid);\n', '      \n', '      // 20% of the resulting Ether is used to pay remaining holders.\n', '      var fee = mul(div(numEthersBeforeFee, 20), 4);\n', '      \n', '      // Net Ether for the seller after the fee has been subtracted.\n', '      var numEthers = numEthersBeforeFee - fee;\n', '      \n', "      // *Remove* the numTokens which were just sold from the total supply. We're /definitely/ a crypto central bank.\n", '      totalSupply[colorid] = sub(totalSupply[colorid], amount);\n', '      allTotalSupply = sub(allTotalSupply, amount);\n', '      \n', '        // Remove the tokens from the balance of the buyer.\n', '      tokenBalance[msg.sender][colorid] = sub(tokenBalance[msg.sender][colorid], amount);\n', '\n', '        // Update the payout array so that the seller cannot claim future dividends unless they buy back in.\n', '      // First we compute how much was just paid out to the seller...\n', '      var payoutDiff = (int256) (earningsPerToken[colorid] * amount + (numEthers * scaleFactor));\n', '      \n', '        // We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\n', "      // since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\n", '      // they decide to buy back in.\n', '      payouts[msg.sender][colorid] -= payoutDiff;     \n', '      \n', "      // Decrease the total amount that's been paid out to maintain invariance.\n", '      totalPayouts[colorid] -= payoutDiff;\n', '      \n', "      // Check that we have tokens in existence (this is a bit of an irrelevant check since we're\n", '      // selling tokens, but it guards against division by zero).\n', '      if (totalSupply[colorid] > 0) {\n', '         // Scale the Ether taken as the selling fee by the scaleFactor variable.\n', '\n', '         for (uint8 c=0; c<16; c++){\n', '            if (totalSupply[c] > 0){\n', '               var theExtraFee = mul(div(mul(div(fee,4), scaleFactor), allTotalSupply), totalSupply[c]) + mul(div(div(fee,4), 128*128),mul(colorPerCanvas[c], scaleFactor));\n', '            \n', '               earningsPerToken[c] = add(earningsPerToken[c], div(theExtraFee,totalSupply[c]));\n', '            }\n', '         }\n', '\n', '         ownerFee = add(ownerFee, div(fee,4));\n', '\n', '         var etherFee = div(fee,4) * scaleFactor;\n', '         \n', '         // Fee is distributed to all remaining token holders.\n', '         // rewardPerShare is the amount gained per token thanks to this sell.\n', '         var rewardPerShare = etherFee / totalSupply[colorid];\n', '         \n', '         // The Ether value per token is increased proportionally.\n', '         earningsPerToken[colorid] = add(earningsPerToken[colorid], rewardPerShare);\n', '\n', '         \n', '      }\n', '   }\n', '\n', '   // Dynamic value of Ether in reserve, according to the CRR requirement.\n', '   function reserve(uint8 colorid) internal constant returns (uint256 amount) {\n', '      return sub(balance(colorid),\n', '          ((uint256) ((int256) (earningsPerToken[colorid] * totalSupply[colorid]) - totalPayouts[colorid]) / scaleFactor));\n', '   }\n', '\n', '   // Calculates the number of tokens that can be bought for a given amount of Ether, according to the\n', '   // dynamic reserve and totalSupply values (derived from the buy and sell prices).\n', '   function getTokensForEther(uint256 ethervalue, uint8 colorid) public constant returns (uint256 tokens) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      return sub(fixedExp(fixedLog(reserve(colorid) + ethervalue)*crr_n/crr_d + price_coeff), totalSupply[colorid]);\n', '   }\n', '\n', '\n', '\n', '   // Converts a number tokens into an Ether value.\n', '   function getEtherForTokens(uint256 tokens, uint8 colorid) public constant returns (uint256 ethervalue) {\n', '      if (colorid >= 16){\n', '         revert();\n', '      }\n', '      // How much reserve Ether do we have left in the contract?\n', '      var reserveAmount = reserve(colorid);\n', '\n', "      // If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\n", '      if (tokens == totalSupply[colorid])\n', '         return reserveAmount;\n', '\n', '      // If there would be excess Ether left after the transaction this is called within, return the Ether\n', "      // corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\n", '      // at https://test.jochen-hoenicke.de/eth/ponzitoken/ in the third equation, with the CRR numerator \n', '      // and denominator altered to 1 and 2 respectively.\n', '      return sub(reserveAmount, fixedExp((fixedLog(totalSupply[colorid] - tokens) - price_coeff) * crr_d/crr_n));\n', '   }\n', '\n', "// You don't care about these, but if you really do they're hex values for \n", '   // co-efficients used to simulate approximations of the log and exp functions.\n', '   int256  constant one        = 0x10000000000000000;\n', '   uint256 constant sqrt2      = 0x16a09e667f3bcc908;\n', '   uint256 constant sqrtdot5   = 0x0b504f333f9de6484;\n', '   int256  constant ln2        = 0x0b17217f7d1cf79ac;\n', '   int256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\n', '   int256  constant c1         = 0x1ffffffffff9dac9b;\n', '   int256  constant c3         = 0x0aaaaaaac16877908;\n', '   int256  constant c5         = 0x0666664e5e9fa0c99;\n', '   int256  constant c7         = 0x049254026a7630acf;\n', '   int256  constant c9         = 0x038bd75ed37753d68;\n', '   int256  constant c11        = 0x03284a0c14610924f;\n', '\n', '   // The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\n', '   // approximates the function log(1+x)-log(1-x)\n', '   // Hence R(s) = log((1+s)/(1-s)) = log(a)\n', '   function fixedLog(uint256 a) internal pure returns (int256 log) {\n', '      int32 scale = 0;\n', '      while (a > sqrt2) {\n', '         a /= 2;\n', '         scale++;\n', '      }\n', '      while (a <= sqrtdot5) {\n', '         a *= 2;\n', '         scale--;\n', '      }\n', '      int256 s = (((int256)(a) - one) * one) / ((int256)(a) + one);\n', '      var z = (s*s) / one;\n', '      return scale * ln2 +\n', '         (s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one))\n', '            /one))/one))/one))/one))/one);\n', '   }\n', '\n', '   int256 constant c2 =  0x02aaaaaaaaa015db0;\n', '   int256 constant c4 = -0x000b60b60808399d1;\n', '   int256 constant c6 =  0x0000455956bccdd06;\n', '   int256 constant c8 = -0x000001b893ad04b3a;\n', '   \n', '   // The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\n', '   // approximates the function x*(exp(x)+1)/(exp(x)-1)\n', '   // Hence exp(x) = (R(x)+x)/(R(x)-x)\n', '   function fixedExp(int256 a) internal pure returns (uint256 exp) {\n', '      int256 scale = (a + (ln2_64dot5)) / ln2 - 64;\n', '      a -= scale*ln2;\n', '      int256 z = (a*a) / one;\n', '      int256 R = ((int256)(2) * one) +\n', '         (z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one);\n', '      exp = (uint256) (((R + a) * one) / (R - a));\n', '      if (scale >= 0)\n', '         exp <<= scale;\n', '      else\n', '         exp >>= -scale;\n', '      return exp;\n', '   }\n', '   \n', '   // The below are safemath implementations of the four arithmetic operators\n', '   // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return c;\n', '   }\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '\n', '   // This allows you to buy tokens by sending Ether directly to the smart contract\n', '   // without including any transaction data (useful for, say, mobile wallet apps).\n', '   function () payable public {\n', '      // msg.value is the amount of Ether sent by the transaction.\n', '      revert();\n', '      //if (msg.value > 0) {\n', '      //   revert();\n', '      //} else {\n', '      //   for (uint8 i=0; i<16; i++){\n', '      //     withdraw(i);\n', '      //   }\n', '\n', '      //}\n', '   }\n', '   \n', '}']
