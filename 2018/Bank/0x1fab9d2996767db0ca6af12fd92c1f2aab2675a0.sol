['/*\n', '  Zethr | https://zethr.io\n', '  (c) Copyright 2018 | All Rights Reserved\n', '  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Libraries/SafeMath.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Libraries/ZethrTierLibrary.sol\n', '\n', 'library ZethrTierLibrary {\n', '  uint constant internal magnitude = 2 ** 64;\n', '\n', '  // Gets the tier (1-7) of the divs sent based off of average dividend rate\n', '  // This is an index used to call into the correct sub-bankroll to withdraw tokens\n', '  function getTier(uint divRate) internal pure returns (uint8) {\n', '\n', '    // Divide the average dividned rate by magnitude\n', '    // Remainder doesn&#39;t matter because of the below logic\n', '    uint actualDiv = divRate / magnitude;\n', '    if (actualDiv >= 30) {\n', '      return 6;\n', '    } else if (actualDiv >= 25) {\n', '      return 5;\n', '    } else if (actualDiv >= 20) {\n', '      return 4;\n', '    } else if (actualDiv >= 15) {\n', '      return 3;\n', '    } else if (actualDiv >= 10) {\n', '      return 2;\n', '    } else if (actualDiv >= 5) {\n', '      return 1;\n', '    } else if (actualDiv >= 2) {\n', '      return 0;\n', '    } else {\n', '      // Impossible\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function getDivRate(uint _tier)\n', '  internal pure\n', '  returns (uint8)\n', '  {\n', '    if (_tier == 0) {\n', '      return 2;\n', '    } else if (_tier == 1) {\n', '      return 5;\n', '    } else if (_tier == 2) {\n', '      return 10;\n', '    } else if (_tier == 3) {\n', '      return 15;\n', '    } else if (_tier == 4) {\n', '      return 20;\n', '    } else if (_tier == 5) {\n', '      return 25;\n', '    } else if (_tier == 6) {\n', '      return 33;\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/ERC/ERC223Receiving.sol\n', '\n', 'contract ERC223Receiving {\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// File: contracts/ZethrMultiSigWallet.sol\n', '\n', '/* Zethr MultisigWallet\n', ' *\n', ' * Standard multisig wallet\n', ' * Holds the bankroll ETH, as well as the bankroll 33% ZTH tokens.\n', '*/ \n', 'contract ZethrMultiSigWallet is ERC223Receiving {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =              EVENTS            =\n', '  =================================*/\n', '\n', '  event Confirmation(address indexed sender, uint indexed transactionId);\n', '  event Revocation(address indexed sender, uint indexed transactionId);\n', '  event Submission(uint indexed transactionId);\n', '  event Execution(uint indexed transactionId);\n', '  event ExecutionFailure(uint indexed transactionId);\n', '  event Deposit(address indexed sender, uint value);\n', '  event OwnerAddition(address indexed owner);\n', '  event OwnerRemoval(address indexed owner);\n', '  event WhiteListAddition(address indexed contractAddress);\n', '  event WhiteListRemoval(address indexed contractAddress);\n', '  event RequirementChange(uint required);\n', '  event BankrollInvest(uint amountReceived);\n', '\n', '  /*=================================\n', '  =             VARIABLES           =\n', '  =================================*/\n', '\n', '  mapping (uint => Transaction) public transactions;\n', '  mapping (uint => mapping (address => bool)) public confirmations;\n', '  mapping (address => bool) public isOwner;\n', '  address[] public owners;\n', '  uint public required;\n', '  uint public transactionCount;\n', '  bool internal reEntered = false;\n', '  uint constant public MAX_OWNER_COUNT = 15;\n', '\n', '  /*=================================\n', '  =         CUSTOM CONSTRUCTS       =\n', '  =================================*/\n', '\n', '  struct Transaction {\n', '    address destination;\n', '    uint value;\n', '    bytes data;\n', '    bool executed;\n', '  }\n', '\n', '  struct TKN {\n', '    address sender;\n', '    uint value;\n', '  }\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyWallet() {\n', '    if (msg.sender != address(this))\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier isAnOwner() {\n', '    address caller = msg.sender;\n', '    if (isOwner[caller])\n', '      _;\n', '    else\n', '      revert();\n', '  }\n', '\n', '  modifier ownerDoesNotExist(address owner) {\n', '    if (isOwner[owner]) \n', '      revert();\n', '      _;\n', '  }\n', '\n', '  modifier ownerExists(address owner) {\n', '    if (!isOwner[owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier transactionExists(uint transactionId) {\n', '    if (transactions[transactionId].destination == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier confirmed(uint transactionId, address owner) {\n', '    if (!confirmations[transactionId][owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notConfirmed(uint transactionId, address owner) {\n', '    if (confirmations[transactionId][owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notExecuted(uint transactionId) {\n', '    if (transactions[transactionId].executed)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notNull(address _address) {\n', '    if (_address == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier validRequirement(uint ownerCount, uint _required) {\n', '    if ( ownerCount > MAX_OWNER_COUNT\n', '      || _required > ownerCount\n', '      || _required == 0\n', '      || ownerCount == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '\n', '  /*=================================\n', '  =         PUBLIC FUNCTIONS        =\n', '  =================================*/\n', '\n', '  /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '  /// @param _owners List of initial owners.\n', '  /// @param _required Number of required confirmations.\n', '  constructor (address[] _owners, uint _required)\n', '    public\n', '    validRequirement(_owners.length, _required)\n', '  {\n', '    // Add owners\n', '    for (uint i=0; i<_owners.length; i++) {\n', '      if (isOwner[_owners[i]] || _owners[i] == 0)\n', '        revert();\n', '      isOwner[_owners[i]] = true;\n', '    }\n', '\n', '    // Set owners\n', '    owners = _owners;\n', '\n', '    // Set required\n', '    required = _required;\n', '  }\n', '\n', '  /** Testing only.\n', '  function exitAll()\n', '    public\n', '  {\n', '    uint tokenBalance = ZTHTKN.balanceOf(address(this));\n', '    ZTHTKN.sell(tokenBalance - 1e18);\n', '    ZTHTKN.sell(1e18);\n', '    ZTHTKN.withdraw(address(0x0));\n', '  }\n', '  **/\n', '\n', '  /// @dev Fallback function allows Ether to be deposited.\n', '  function()\n', '    public\n', '    payable\n', '  {\n', '\n', '  }\n', '    \n', '  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of new owner.\n', '  function addOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerDoesNotExist(owner)\n', '    notNull(owner)\n', '    validRequirement(owners.length + 1, required)\n', '  {\n', '    isOwner[owner] = true;\n', '    owners.push(owner);\n', '    emit OwnerAddition(owner);\n', '  }\n', '\n', '  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of owner.\n', '  function removeOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    validRequirement(owners.length, required)\n', '  {\n', '    isOwner[owner] = false;\n', '    for (uint i=0; i<owners.length - 1; i++)\n', '      if (owners[i] == owner) {\n', '        owners[i] = owners[owners.length - 1];\n', '        break;\n', '      }\n', '\n', '    owners.length -= 1;\n', '    if (required > owners.length)\n', '      changeRequirement(owners.length);\n', '    emit OwnerRemoval(owner);\n', '  }\n', '\n', '  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of owner to be replaced.\n', '  /// @param owner Address of new owner.\n', '  function replaceOwner(address owner, address newOwner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    ownerDoesNotExist(newOwner)\n', '  {\n', '    for (uint i=0; i<owners.length; i++)\n', '      if (owners[i] == owner) {\n', '        owners[i] = newOwner;\n', '        break;\n', '      }\n', '\n', '    isOwner[owner] = false;\n', '    isOwner[newOwner] = true;\n', '    emit OwnerRemoval(owner);\n', '    emit OwnerAddition(newOwner);\n', '  }\n', '\n', '  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '  /// @param _required Number of required confirmations.\n', '  function changeRequirement(uint _required)\n', '    public\n', '    onlyWallet\n', '    validRequirement(owners.length, _required)\n', '  {\n', '    required = _required;\n', '    emit RequirementChange(_required);\n', '  }\n', '\n', '  /// @dev Allows an owner to submit and confirm a transaction.\n', '  /// @param destination Transaction target address.\n', '  /// @param value Transaction ether value.\n', '  /// @param data Transaction data payload.\n', '  /// @return Returns transaction ID.\n', '  function submitTransaction(address destination, uint value, bytes data)\n', '    public\n', '    returns (uint transactionId)\n', '  {\n', '    transactionId = addTransaction(destination, value, data);\n', '    confirmTransaction(transactionId);\n', '  }\n', '\n', '  /// @dev Allows an owner to confirm a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function confirmTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    transactionExists(transactionId)\n', '    notConfirmed(transactionId, msg.sender)\n', '  {\n', '    confirmations[transactionId][msg.sender] = true;\n', '    emit Confirmation(msg.sender, transactionId);\n', '    executeTransaction(transactionId);\n', '  }\n', '\n', '  /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function revokeConfirmation(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '  {\n', '    confirmations[transactionId][msg.sender] = false;\n', '    emit Revocation(msg.sender, transactionId);\n', '  }\n', '\n', '  /// @dev Allows anyone to execute a confirmed transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function executeTransaction(uint transactionId)\n', '    public\n', '    notExecuted(transactionId)\n', '  {\n', '    if (isConfirmed(transactionId)) {\n', '      Transaction storage txToExecute = transactions[transactionId];\n', '      txToExecute.executed = true;\n', '      if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data))\n', '        emit Execution(transactionId);\n', '      else {\n', '        emit ExecutionFailure(transactionId);\n', '        txToExecute.executed = false;\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the confirmation status of a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Confirmation status.\n', '  function isConfirmed(uint transactionId)\n', '    public\n', '    constant\n', '    returns (bool)\n', '  {\n', '    uint count = 0;\n', '    for (uint i=0; i<owners.length; i++) {\n', '      if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '      if (count == required)\n', '        return true;\n', '    }\n', '  }\n', '\n', '  /*=================================\n', '  =        OPERATOR FUNCTIONS       =\n', '  =================================*/\n', '\n', '  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '  /// @param destination Transaction target address.\n', '  /// @param value Transaction ether value.\n', '  /// @param data Transaction data payload.\n', '  /// @return Returns transaction ID.\n', '  function addTransaction(address destination, uint value, bytes data)\n', '    internal\n', '    notNull(destination)\n', '    returns (uint transactionId)\n', '  {\n', '    transactionId = transactionCount;\n', '\n', '    transactions[transactionId] = Transaction({\n', '        destination: destination,\n', '        value: value,\n', '        data: data,\n', '        executed: false\n', '    });\n', '\n', '    transactionCount += 1;\n', '    emit Submission(transactionId);\n', '  }\n', '\n', '  /*\n', '   * Web3 call functions\n', '   */\n', '  /// @dev Returns number of confirmations of a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Number of confirmations.\n', '  function getConfirmationCount(uint transactionId)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<owners.length; i++)\n', '      if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '  }\n', '\n', '  /// @dev Returns total number of transactions after filers are applied.\n', '  /// @param pending Include pending transactions.\n', '  /// @param executed Include executed transactions.\n', '  /// @return Total number of transactions after filters are applied.\n', '  function getTransactionCount(bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<transactionCount; i++)\n', '      if (pending && !transactions[i].executed || executed && transactions[i].executed)\n', '        count += 1;\n', '  }\n', '\n', '  /// @dev Returns list of owners.\n', '  /// @return List of owner addresses.\n', '  function getOwners()\n', '    public\n', '    constant\n', '    returns (address[])\n', '  {\n', '    return owners;\n', '  }\n', '\n', '  /// @dev Returns array with owner addresses, which confirmed transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Returns array of owner addresses.\n', '  function getConfirmations(uint transactionId)\n', '    public\n', '    constant\n', '    returns (address[] _confirmations)\n', '  {\n', '    address[] memory confirmationsTemp = new address[](owners.length);\n', '    uint count = 0;\n', '    uint i;\n', '    for (i=0; i<owners.length; i++)\n', '      if (confirmations[transactionId][owners[i]]) {\n', '        confirmationsTemp[count] = owners[i];\n', '        count += 1;\n', '      }\n', '\n', '      _confirmations = new address[](count);\n', '\n', '      for (i=0; i<count; i++)\n', '        _confirmations[i] = confirmationsTemp[i];\n', '  }\n', '\n', '  /// @dev Returns list of transaction IDs in defined range.\n', '  /// @param from Index start position of transaction array.\n', '  /// @param to Index end position of transaction array.\n', '  /// @param pending Include pending transactions.\n', '  /// @param executed Include executed transactions.\n', '  /// @return Returns array of transaction IDs.\n', '  function getTransactionIds(uint from, uint to, bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint[] _transactionIds)\n', '  {\n', '    uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '    uint count = 0;\n', '    uint i;\n', '\n', '    for (i=0; i<transactionCount; i++)\n', '      if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n', '        transactionIdsTemp[count] = i;\n', '        count += 1;\n', '      }\n', '\n', '      _transactionIds = new uint[](to - from);\n', '\n', '    for (i=from; i<to; i++)\n', '      _transactionIds[i - from] = transactionIdsTemp[i];\n', '  }\n', '\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\n', '  public\n', '  returns (bool)\n', '  {\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/Interfaces/ZethrTokenBankrollInterface.sol\n', '\n', '// Zethr token bankroll function prototypes\n', 'contract ZethrTokenBankrollInterface is ERC223Receiving {\n', '  uint public jackpotBalance;\n', '  \n', '  function getMaxProfit(address) public view returns (uint);\n', '  function gameTokenResolution(uint _toWinnerAmount, address _winnerAddress, uint _toJackpotAmount, address _jackpotAddress, uint _originalBetSize) external;\n', '  function payJackpotToWinner(address _winnerAddress, uint payoutDivisor) public;\n', '}\n', '\n', '// File: contracts/Bankroll/Interfaces/ZethrBankrollControllerInterface.sol\n', '\n', 'contract ZethrBankrollControllerInterface is ERC223Receiving {\n', '  address public jackpotAddress;\n', '\n', '  ZethrTokenBankrollInterface[7] public tokenBankrolls; \n', '  \n', '  ZethrMultiSigWallet public multiSigWallet;\n', '\n', '  mapping(address => bool) public validGameAddresses;\n', '\n', '  function gamePayoutResolver(address _resolver, uint _tokenAmount) public;\n', '\n', '  function isTokenBankroll(address _address) public view returns (bool);\n', '\n', '  function getTokenBankrollAddressFromTier(uint8 _tier) public view returns (address);\n', '\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// File: contracts/ERC/ERC721Interface.sol\n', '\n', 'contract ERC721Interface {\n', '  function approve(address _to, uint _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint _tokenId) public;\n', '  function totalSupply() public view returns (uint total);\n', '  function transferFrom(address _from, address _to, uint _tokenId) public;\n', '  function transfer(address _to, uint _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint tokenId);\n', '}\n', '\n', '// File: contracts/Libraries/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '// File: contracts/Games/ZethrDividendCards.sol\n', '\n', 'contract ZethrDividendCards is ERC721Interface {\n', '    using SafeMath for uint;\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new dividend card comes into existence.\n', '  event Birth(uint tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token (dividend card, in this case) is sold.\n', '  event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721.\n', '  ///  Ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint tokenId);\n', '\n', '  // Events for calculating card profits / errors\n', '  event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner);\n', '  event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner);\n', '  event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner);\n', '  event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner);\n', '  event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId);\n', '  event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId);\n', '  event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId);\n', '  event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME           = "ZethrDividendCard";\n', '  string public constant SYMBOL         = "ZDC";\n', '  address public         BANKROLL;\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev A mapping from dividend card indices to the address that owns them.\n', '  ///  All dividend cards have a valid owner address.\n', '\n', '  mapping (uint => address) public      divCardIndexToOwner;\n', '\n', '  // A mapping from a dividend rate to the card index.\n', '\n', '  mapping (uint => uint) public         divCardRateToIndex;\n', '\n', '  // @dev A mapping from owner address to the number of dividend cards that address owns.\n', '  //  Used internally inside balanceOf() to resolve ownership count.\n', '\n', '  mapping (address => uint) private     ownershipDivCardCount;\n', '\n', '  /// @dev A mapping from dividend card indices to an address that has been approved to call\n', '  ///  transferFrom(). Each dividend card can only have one approved address for transfer\n', '  ///  at any time. A zero value means no approval is outstanding.\n', '\n', '  mapping (uint => address) public      divCardIndexToApproved;\n', '\n', '  // @dev A mapping from dividend card indices to the price of the dividend card.\n', '\n', '  mapping (uint => uint) private        divCardIndexToPrice;\n', '\n', '  mapping (address => bool) internal    administrators;\n', '\n', '  address public                        creator;\n', '  bool    public                        onSale;\n', '\n', '  /*** DATATYPES ***/\n', '\n', '  struct Card {\n', '    string name;\n', '    uint percentIncrease;\n', '  }\n', '\n', '  Card[] private divCards;\n', '\n', '  modifier onlyCreator() {\n', '    require(msg.sender == creator);\n', '    _;\n', '  }\n', '\n', '  constructor (address _bankroll) public {\n', '    creator = msg.sender;\n', '    BANKROLL = _bankroll;\n', '\n', '    createDivCard("2%", 1 ether, 2);\n', '    divCardRateToIndex[2] = 0;\n', '\n', '    createDivCard("5%", 1 ether, 5);\n', '    divCardRateToIndex[5] = 1;\n', '\n', '    createDivCard("10%", 1 ether, 10);\n', '    divCardRateToIndex[10] = 2;\n', '\n', '    createDivCard("15%", 1 ether, 15);\n', '    divCardRateToIndex[15] = 3;\n', '\n', '    createDivCard("20%", 1 ether, 20);\n', '    divCardRateToIndex[20] = 4;\n', '\n', '    createDivCard("25%", 1 ether, 25);\n', '    divCardRateToIndex[25] = 5;\n', '\n', '    createDivCard("33%", 1 ether, 33);\n', '    divCardRateToIndex[33] = 6;\n', '\n', '    createDivCard("MASTER", 5 ether, 10);\n', '    divCardRateToIndex[999] = 7;\n', '\n', '\t  onSale = true;\n', '\n', '    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true; // Norsefire\n', '    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true; // klob\n', '    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true; // Etherguy\n', '    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true; // blurr\n', '\n', '    administrators[msg.sender] = true; // Helps with debugging\n', '  }\n', '\n', '  /*** MODIFIERS ***/\n', '\n', '  // Modifier to prevent contracts from interacting with the flip cards\n', '  modifier isNotContract()\n', '  {\n', '    require (msg.sender == tx.origin);\n', '    _;\n', '  }\n', '\n', '\t// Modifier to prevent purchases before we open them up to everyone\n', '\tmodifier hasStarted()\n', '  {\n', '\t\trequire (onSale == true);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier isAdmin()\n', '  {\n', '\t  require(administrators[msg.sender]);\n', '\t  _;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  // Administrative update of the bankroll contract address\n', '  function setBankroll(address where)\n', '    public\n', '    isAdmin\n', '  {\n', '    BANKROLL = where;\n', '  }\n', '\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(address _to, uint _tokenId)\n', '    public\n', '    isNotContract\n', '  {\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    divCardIndexToApproved[_tokenId] = _to;\n', '\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner)\n', '    public\n', '    view\n', '    returns (uint balance)\n', '  {\n', '    return ownershipDivCardCount[_owner];\n', '  }\n', '\n', '  // Creates a div card with bankroll as the owner\n', '  function createDivCard(string _name, uint _price, uint _percentIncrease)\n', '    public\n', '    onlyCreator\n', '  {\n', '    _createDivCard(_name, BANKROLL, _price, _percentIncrease);\n', '  }\n', '\n', '\t// Opens the dividend cards up for sale.\n', '\tfunction startCardSale()\n', '        public\n', '        isAdmin\n', '  {\n', '\t\tonSale = true;\n', '\t}\n', '\n', '  /// @notice Returns all the relevant information about a specific div card\n', '  /// @param _divCardId The tokenId of the div card of interest.\n', '  function getDivCard(uint _divCardId)\n', '    public\n', '    view\n', '    returns (string divCardName, uint sellingPrice, address owner)\n', '  {\n', '    Card storage divCard = divCards[_divCardId];\n', '    divCardName = divCard.name;\n', '    sellingPrice = divCardIndexToPrice[_divCardId];\n', '    owner = divCardIndexToOwner[_divCardId];\n', '  }\n', '\n', '  function implementsERC721()\n', '    public\n', '    pure\n', '    returns (bool)\n', '  {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name()\n', '    public\n', '    pure\n', '    returns (string)\n', '  {\n', '    return NAME;\n', '  }\n', '\n', '  /// For querying owner of token\n', '  /// @param _divCardId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint _divCardId)\n', '    public\n', '    view\n', '    returns (address owner)\n', '  {\n', '    owner = divCardIndexToOwner[_divCardId];\n', '    require(owner != address(0));\n', '\treturn owner;\n', '  }\n', '\n', '  // Allows someone to send Ether and obtain a card\n', '  function purchase(uint _divCardId)\n', '    public\n', '    payable\n', '    hasStarted\n', '    isNotContract\n', '  {\n', '    address oldOwner  = divCardIndexToOwner[_divCardId];\n', '    address newOwner  = msg.sender;\n', '\n', '    // Get the current price of the card\n', '    uint currentPrice = divCardIndexToPrice[_divCardId];\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= currentPrice);\n', '\n', '    // To find the total profit, we need to know the previous price\n', '    // currentPrice      = previousPrice * (100 + percentIncrease);\n', '    // previousPrice     = currentPrice / (100 + percentIncrease);\n', '    uint percentIncrease = divCards[_divCardId].percentIncrease;\n', '    uint previousPrice   = SafeMath.mul(currentPrice, 100).div(100 + percentIncrease);\n', '\n', '    // Calculate total profit and allocate 50% to old owner, 50% to bankroll\n', '    uint totalProfit     = SafeMath.sub(currentPrice, previousPrice);\n', '    uint oldOwnerProfit  = SafeMath.div(totalProfit, 2);\n', '    uint bankrollProfit  = SafeMath.sub(totalProfit, oldOwnerProfit);\n', '    oldOwnerProfit       = SafeMath.add(oldOwnerProfit, previousPrice);\n', '\n', '    // Refund the sender the excess he sent\n', '    uint purchaseExcess  = SafeMath.sub(msg.value, currentPrice);\n', '\n', '    // Raise the price by the percentage specified by the card\n', '    divCardIndexToPrice[_divCardId] = SafeMath.div(SafeMath.mul(currentPrice, (100 + percentIncrease)), 100);\n', '\n', '    // Transfer ownership\n', '    _transfer(oldOwner, newOwner, _divCardId);\n', '\n', '    // Using send rather than transfer to prevent contract exploitability.\n', '    if(BANKROLL.send(bankrollProfit)) {\n', '      emit BankrollDivCardProfit(bankrollProfit, percentIncrease, oldOwner);\n', '    } else {\n', '      emit BankrollProfitFailure(bankrollProfit, percentIncrease, oldOwner);\n', '    }\n', '\n', '    if(oldOwner.send(oldOwnerProfit)) {\n', '      emit UserDivCardProfit(oldOwnerProfit, percentIncrease, oldOwner);\n', '    } else {\n', '      emit DivCardProfitFailure(oldOwnerProfit, percentIncrease, oldOwner);\n', '    }\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '\n', '  function priceOf(uint _divCardId)\n', '    public\n', '    view\n', '    returns (uint price)\n', '  {\n', '    return divCardIndexToPrice[_divCardId];\n', '  }\n', '\n', '  function setCreator(address _creator)\n', '    public\n', '    onlyCreator\n', '  {\n', '    require(_creator != address(0));\n', '\n', '    creator = _creator;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol()\n', '    public\n', '    pure\n', '    returns (string)\n', '  {\n', '    return SYMBOL;\n', '  }\n', '\n', '  /// @notice Allow pre-approved user to take ownership of a dividend card.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = divCardIndexToOwner[_divCardId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _divCardId));\n', '\n', '    _transfer(oldOwner, newOwner, _divCardId);\n', '  }\n', '\n', '  /// For querying totalSupply of token\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply()\n', '    public\n', '    view\n', '    returns (uint total)\n', '  {\n', '    return divCards.length;\n', '  }\n', '\n', '  /// Owner initates the transfer of the card to another account\n', '  /// @param _to The address for the card to be transferred to.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(address _to, uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    require(_owns(msg.sender, _divCardId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _divCardId);\n', '  }\n', '\n', '  /// Third-party initiates transfer of a card from address _from to address _to\n', '  /// @param _from The address for the card to be transferred from.\n', '  /// @param _to The address for the card to be transferred to.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(address _from, address _to, uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    require(_owns(_from, _divCardId));\n', '    require(_approved(_to, _divCardId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _divCardId);\n', '  }\n', '\n', '  function receiveDividends(uint _divCardRate)\n', '    public\n', '    payable\n', '  {\n', '    uint _divCardId = divCardRateToIndex[_divCardRate];\n', '    address _regularAddress = divCardIndexToOwner[_divCardId];\n', '    address _masterAddress = divCardIndexToOwner[7];\n', '\n', '    uint toMaster = msg.value.div(2);\n', '    uint toRegular = msg.value.sub(toMaster);\n', '\n', '    if(_masterAddress.send(toMaster)){\n', '      emit masterCardProfit(toMaster, _masterAddress, _divCardId);\n', '    } else {\n', '      emit masterCardProfitFailure(toMaster, _masterAddress, _divCardId);\n', '    }\n', '\n', '    if(_regularAddress.send(toRegular)) {\n', '      emit regularCardProfit(toRegular, _regularAddress, _divCardId);\n', '    } else {\n', '      emit regularCardProfitFailure(toRegular, _regularAddress, _divCardId);\n', '    }\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to)\n', '    private\n', '    pure\n', '    returns (bool)\n', '  {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint _divCardId)\n', '    private\n', '    view\n', '    returns (bool)\n', '  {\n', '    return divCardIndexToApproved[_divCardId] == _to;\n', '  }\n', '\n', '  /// For creating a dividend card\n', '  function _createDivCard(string _name, address _owner, uint _price, uint _percentIncrease)\n', '    private\n', '  {\n', '    Card memory _divcard = Card({\n', '      name: _name,\n', '      percentIncrease: _percentIncrease\n', '    });\n', '    uint newCardId = divCards.push(_divcard) - 1;\n', '\n', '    // It&#39;s probably never going to happen, 4 billion tokens are A LOT, but\n', '    // let&#39;s just be 100% sure we never let this happen.\n', '    require(newCardId == uint(uint32(newCardId)));\n', '\n', '    emit Birth(newCardId, _name, _owner);\n', '\n', '    divCardIndexToPrice[newCardId] = _price;\n', '\n', '    // This will assign ownership, and also emit the Transfer event as per ERC721 draft\n', '    _transfer(BANKROLL, _owner, newCardId);\n', '  }\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint _divCardId)\n', '    private\n', '    view\n', '    returns (bool)\n', '  {\n', '    return claimant == divCardIndexToOwner[_divCardId];\n', '  }\n', '\n', '  /// @dev Assigns ownership of a specific Card to an address.\n', '  function _transfer(address _from, address _to, uint _divCardId)\n', '    private\n', '  {\n', '    // Since the number of cards is capped to 2^32 we can&#39;t overflow this\n', '    ownershipDivCardCount[_to]++;\n', '    //transfer ownership\n', '    divCardIndexToOwner[_divCardId] = _to;\n', '\n', '    // When creating new div cards _from is 0x0, but we can&#39;t account that address.\n', '    if (_from != address(0)) {\n', '      ownershipDivCardCount[_from]--;\n', '      // clear any previously approved ownership exchange\n', '      delete divCardIndexToApproved[_divCardId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    emit Transfer(_from, _to, _divCardId);\n', '  }\n', '}\n', '\n', '// File: contracts/Zethr.sol\n', '\n', 'contract Zethr {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyHolders() {\n', '    require(myFrontEndTokens() > 0);\n', '    _;\n', '  }\n', '\n', '  modifier dividendHolder() {\n', '    require(myDividends(true) > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdministrator(){\n', '    address _customerAddress = msg.sender;\n', '    require(administrators[_customerAddress]);\n', '    _;\n', '  }\n', '\n', '  /*==============================\n', '  =            EVENTS            =\n', '  ==============================*/\n', '\n', '  event onTokenPurchase(\n', '    address indexed customerAddress,\n', '    uint incomingEthereum,\n', '    uint tokensMinted,\n', '    address indexed referredBy\n', '  );\n', '\n', '  event UserDividendRate(\n', '    address user,\n', '    uint divRate\n', '  );\n', '\n', '  event onTokenSell(\n', '    address indexed customerAddress,\n', '    uint tokensBurned,\n', '    uint ethereumEarned\n', '  );\n', '\n', '  event onReinvestment(\n', '    address indexed customerAddress,\n', '    uint ethereumReinvested,\n', '    uint tokensMinted\n', '  );\n', '\n', '  event onWithdraw(\n', '    address indexed customerAddress,\n', '    uint ethereumWithdrawn\n', '  );\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens\n', '  );\n', '\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens\n', '  );\n', '\n', '  event Allocation(\n', '    uint toBankRoll,\n', '    uint toReferrer,\n', '    uint toTokenHolders,\n', '    uint toDivCardHolders,\n', '    uint forTokens\n', '  );\n', '\n', '  event Referral(\n', '    address referrer,\n', '    uint amountReceived\n', '  );\n', '\n', '  /*=====================================\n', '  =            CONSTANTS                =\n', '  =====================================*/\n', '\n', '  uint8 constant public                decimals = 18;\n', '\n', '  uint constant internal               tokenPriceInitial_ = 0.000653 ether;\n', '  uint constant internal               magnitude = 2 ** 64;\n', '\n', '  uint constant internal               icoHardCap = 250 ether;\n', '  uint constant internal               addressICOLimit = 1   ether;\n', '  uint constant internal               icoMinBuyIn = 0.1 finney;\n', '  uint constant internal               icoMaxGasPrice = 50000000000 wei;\n', '\n', '  uint constant internal               MULTIPLIER = 9615;\n', '\n', '  uint constant internal               MIN_ETH_BUYIN = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_TRANSFER = 1e10;\n', '  uint constant internal               referrer_percentage = 25;\n', '\n', '  uint public                          stakingRequirement = 100e18;\n', '\n', '  /*================================\n', '   =          CONFIGURABLES         =\n', '   ================================*/\n', '\n', '  string public                        name = "Zethr";\n', '  string public                        symbol = "ZTH";\n', '\n', '  //bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262); // public\n', '  bytes32 constant public              icoHashedPass = bytes32(0x8a6ddee3fb2508ff4a5b02b48e9bc4566d0f3e11f306b0f75341bf235662a9e3); // test hunter2\n', '\n', '  address internal                     bankrollAddress;\n', '\n', '  ZethrDividendCards                   divCardContract;\n', '\n', '  /*================================\n', '   =            DATASETS            =\n', '   ================================*/\n', '\n', '  // Tracks front & backend tokens\n', '  mapping(address => uint) internal    frontTokenBalanceLedger_;\n', '  mapping(address => uint) internal    dividendTokenBalanceLedger_;\n', '  mapping(address =>\n', '  mapping(address => uint))\n', '  public      allowed;\n', '\n', '  // Tracks dividend rates for users\n', '  mapping(uint8 => bool)    internal validDividendRates_;\n', '  mapping(address => bool)    internal userSelectedRate;\n', '  mapping(address => uint8)   internal userDividendRate;\n', '\n', '  // Payout tracking\n', '  mapping(address => uint)    internal referralBalance_;\n', '  mapping(address => int256)  internal payoutsTo_;\n', '\n', '  // ICO per-address limit tracking\n', '  mapping(address => uint)    internal ICOBuyIn;\n', '\n', '  uint public                          tokensMintedDuringICO;\n', '  uint public                          ethInvestedDuringICO;\n', '\n', '  uint public                          currentEthInvested;\n', '\n', '  uint internal                        tokenSupply = 0;\n', '  uint internal                        divTokenSupply = 0;\n', '\n', '  uint internal                        profitPerDivToken;\n', '\n', '  mapping(address => bool) public      administrators;\n', '\n', '  bool public                          icoPhase = false;\n', '  bool public                          regularPhase = false;\n', '\n', '  uint                                 icoOpenTime;\n', '\n', '  /*=======================================\n', '  =            PUBLIC FUNCTIONS           =\n', '  =======================================*/\n', '  constructor (address _bankrollAddress, address _divCardAddress)\n', '  public\n', '  {\n', '    bankrollAddress = _bankrollAddress;\n', '    divCardContract = ZethrDividendCards(_divCardAddress);\n', '\n', '    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;\n', '    // Norsefire\n', '    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true;\n', '    // klob\n', '    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true;\n', '    // Etherguy\n', '    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true;\n', '    // blurr\n', '    administrators[0x8537aa2911b193e5B377938A723D805bb0865670] = true;\n', '    // oguzhanox\n', '    administrators[0x9D221b2100CbE5F05a0d2048E2556a6Df6f9a6C3] = true;\n', '    // Randall\n', '    administrators[0xDa83156106c4dba7A26E9bF2Ca91E273350aa551] = true;\n', '    // TropicalRogue\n', '    administrators[0x71009e9E4e5e68e77ECc7ef2f2E95cbD98c6E696] = true;\n', '    // cryptodude\n', '\n', '    administrators[msg.sender] = true;\n', '    // Helps with debugging!\n', '\n', '    validDividendRates_[2] = true;\n', '    validDividendRates_[5] = true;\n', '    validDividendRates_[10] = true;\n', '    validDividendRates_[15] = true;\n', '    validDividendRates_[20] = true;\n', '    validDividendRates_[25] = true;\n', '    validDividendRates_[33] = true;\n', '\n', '    userSelectedRate[bankrollAddress] = true;\n', '    userDividendRate[bankrollAddress] = 33;\n', '\n', '  }\n', '\n', '  /**\n', '   * Same as buy, but explicitly sets your dividend percentage.\n', '   * If this has been called before, it will update your `default&#39; dividend\n', '   *   percentage for regular buy transactions going forward.\n', '   */\n', '  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string /*providedUnhashedPass*/)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(icoPhase || regularPhase);\n', '\n', '    if (icoPhase) {\n', '\n', '      // Anti-bot measures - not perfect, but should help some.\n', '      // bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\n', '      //require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress); // test; remove\n', '\n', '      uint gasPrice = tx.gasprice;\n', '\n', '      // Prevents ICO buyers from getting substantially burned if the ICO is reached\n', '      //   before their transaction is processed.\n', '      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\n', '\n', '    }\n', '\n', '    // Dividend percentage should be a currently accepted value.\n', '    require(validDividendRates_[_divChoice]);\n', '\n', '    // Set the dividend fee percentage denominator.\n', '    userSelectedRate[msg.sender] = true;\n', '    userDividendRate[msg.sender] = _divChoice;\n', '    emit UserDividendRate(msg.sender, _divChoice);\n', '\n', '    // Finally, purchase tokens.\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  // All buys except for the above one require regular phase.\n', '\n', '  function buy(address _referredBy)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target)\n', '  public\n', '  payable\n', '  {\n', '    bytes memory empty;\n', '    buyAndTransfer(_referredBy, target, empty, 20);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data)\n', '  public\n', '  payable\n', '  {\n', '    buyAndTransfer(_referredBy, target, _data, 20);\n', '  }\n', '\n', '  // Overload\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\n', '  public\n', '  payable\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n', '    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n', '      purchaseTokens(msg.value, _referredBy);\n', '    } else {\n', '      buyAndSetDivPercentage(_referredBy, divChoice, "0x0");\n', '    }\n', '    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n', '    transferTo(msg.sender, target, difference, _data);\n', '  }\n', '\n', '  // Fallback function only works during regular phase - part of anti-bot protection.\n', '  function()\n', '  payable\n', '  public\n', '  {\n', '    /**\n', '    / If the user has previously set a dividend rate, sending\n', '    /   Ether directly to the contract simply purchases more at\n', '    /   the most recent rate. If this is their first time, they\n', '    /   are automatically placed into the 20% rate `bucket&#39;.\n', '    **/\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    if (userSelectedRate[_customerAddress]) {\n', '      purchaseTokens(msg.value, 0x0);\n', '    } else {\n', '      buyAndSetDivPercentage(0x0, 20, "0x0");\n', '    }\n', '  }\n', '\n', '  function reinvest()\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    uint _dividends = myDividends(false);\n', '\n', '    // Pay out requisite `virtual&#39; dividends.\n', '    address _customerAddress = msg.sender;\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    uint _tokens = purchaseTokens(_dividends, 0x0);\n', '\n', '    // Fire logging event.\n', '    emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '  }\n', '\n', '  function exit()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Retrieve token balance for caller, then sell them all.\n', '    address _customerAddress = msg.sender;\n', '    uint _tokens = frontTokenBalanceLedger_[_customerAddress];\n', '\n', '    if (_tokens > 0) sell(_tokens);\n', '\n', '    withdraw(_customerAddress);\n', '  }\n', '\n', '  function withdraw(address _recipient)\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Setup data\n', '    address _customerAddress = msg.sender;\n', '    uint _dividends = myDividends(false);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    if (_recipient == address(0x0)) {\n', '      _recipient = msg.sender;\n', '    }\n', '    _recipient.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_recipient, _dividends);\n', '  }\n', '\n', '  // Sells front-end tokens.\n', '  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\n', '  function sell(uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  {\n', '    // No selling during the ICO. You don&#39;t get to flip that fast, sorry!\n', '    require(!icoPhase);\n', '    require(regularPhase);\n', '\n', '    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '\n', '    uint _frontEndTokensToBurn = _amountOfTokens;\n', '\n', '    // Calculate how many dividend tokens this action burns.\n', '    // Computed as the caller&#39;s average dividend rate multiplied by the number of front-end tokens held.\n', '    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n', '    uint userDivRate = getUserAverageDividendRate(msg.sender);\n', '    require((2 * magnitude) <= userDivRate && (50 * magnitude) >= userDivRate);\n', '    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n', '\n', '    // Calculate ethereum received before dividends\n', '    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\n', '\n', '    if (_ethereum > currentEthInvested) {\n', '      // Well, congratulations, you&#39;ve emptied the coffers.\n', '      currentEthInvested = 0;\n', '    } else {currentEthInvested = currentEthInvested - _ethereum;}\n', '\n', '    // Calculate dividends generated from the sale.\n', '    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n', '\n', '    // Calculate Ethereum receivable net of dividends.\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '\n', '    // Burn the sold tokens (both front-end and back-end variants).\n', '    tokenSupply = tokenSupply.sub(_frontEndTokensToBurn);\n', '    divTokenSupply = divTokenSupply.sub(_divTokensToBurn);\n', '\n', '    // Subtract the token balances for the seller\n', '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n', '\n', '    // Update dividends tracker\n', '    int256 _updatedPayouts = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\n', '    payoutsTo_[msg.sender] -= _updatedPayouts;\n', '\n', '    // Let&#39;s avoid breaking arithmetic where we can, eh?\n', '    if (divTokenSupply > 0) {\n', '      // Update the value of each remaining back-end dividend token.\n', '      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder.\n', '   * No charge incurred for the transfer. We&#39;d make a terrible bank.\n', '   */\n', '  function transfer(address _toAddress, uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  returns (bool)\n', '  {\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '    bytes memory empty;\n', '    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    allowed[_customerAddress][spender] = tokens;\n', '\n', '    // Fire logging event.\n', '    emit Approval(_customerAddress, spender, tokens);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n', '   * No charge incurred for the transfer. No seriously, we&#39;d make a terrible bank.\n', '   */\n', '  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    // Setup variables\n', '    address _customerAddress = _from;\n', '    bytes memory empty;\n', '    // Make sure we own the tokens we&#39;re transferring, are ALLOWED to transfer that many tokens,\n', '    // and are transferring at least one full token.\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\n', '    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n', '\n', '    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '\n', '  }\n', '\n', '  function transferTo(address _from, address _to, uint _amountOfTokens, bytes _data)\n', '  public\n', '  {\n', '    if (_from != msg.sender) {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\n', '      && _amountOfTokens <= allowed[_from][msg.sender]);\n', '    }\n', '    else {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n', '    }\n', '\n', '    transferFromInternal(_from, _to, _amountOfTokens, _data);\n', '  }\n', '\n', '  // Who&#39;d have thought we&#39;d need this thing floating around?\n', '  function totalSupply()\n', '  public\n', '  view\n', '  returns (uint256)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\n', '  // In case the devs die. Or something.\n', '  function publicStartRegularPhase()\n', '  public\n', '  {\n', '    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\n', '\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '\n', '  // Fire the starting gun and then duck for cover.\n', '  function startICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // Prevent us from startaring the ICO phase again\n', '    require(icoOpenTime == 0);\n', '    icoPhase = true;\n', '    icoOpenTime = now;\n', '  }\n', '\n', '  // Fire the ... ending gun?\n', '  function endICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    icoPhase = false;\n', '  }\n', '\n', '  function startRegularPhase()\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    // disable ico phase in case if that was not disabled yet\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  // The death of a great man demands the birth of a great son.\n', '  function setAdministrator(address _newAdmin, bool _status)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    administrators[_newAdmin] = _status;\n', '  }\n', '\n', '  function setStakingRequirement(uint _amountOfTokens)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // This plane only goes one way, lads. Never below the initial.\n', '    require(_amountOfTokens >= 100e18);\n', '    stakingRequirement = _amountOfTokens;\n', '  }\n', '\n', '  function setName(string _name)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    name = _name;\n', '  }\n', '\n', '  function setSymbol(string _symbol)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    symbol = _symbol;\n', '  }\n', '\n', '  function changeBankroll(address _newBankrollAddress)\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    bankrollAddress = _newBankrollAddress;\n', '  }\n', '\n', '  /*----------  HELPERS AND CALCULATORS  ----------*/\n', '\n', '  function totalEthereumBalance()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function totalEthereumICOReceived()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return ethInvestedDuringICO;\n', '  }\n', '\n', '  /**\n', '   * Retrieves your currently selected dividend rate.\n', '   */\n', '  function getMyDividendRate()\n', '  public\n', '  view\n', '  returns (uint8)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    return userDividendRate[_customerAddress];\n', '  }\n', '\n', '  /**\n', '   * Retrieve the total frontend token supply\n', '   */\n', '  function getFrontEndTokenSupply()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retreive the total dividend token supply\n', '   */\n', '  function getDividendTokenSupply()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return divTokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retrieve the frontend tokens owned by the caller\n', '   */\n', '  function myFrontEndTokens()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getFrontEndTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  /**\n', '   * Retrieve the dividend tokens owned by the caller\n', '   */\n', '  function myDividendTokens()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getDividendTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  function myReferralDividends()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return myDividends(true) - myDividends(false);\n', '  }\n', '\n', '  function myDividends(bool _includeReferralBonus)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function getFrontEndTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return frontTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return getFrontEndTokenBalanceOf(_owner);\n', '  }\n', '\n', '  function getDividendTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return dividendTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function dividendsOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '  }\n', '\n', '  // Get the sell price at the user&#39;s average dividend rate\n', '  function sellPrice()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', '    // Factor in the user&#39;s average dividend rate\n', '    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n', '\n', '    return theSellPrice;\n', '  }\n', '\n', '  // Get the buy price at a particular dividend rate\n', '  function buyPrice(uint dividendRate)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', '    // Factor in the user&#39;s selected dividend rate\n', '    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n', '\n', '    return theBuyPrice;\n', '  }\n', '\n', '  function calculateTokensReceived(uint _ethereumToSpend)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint _dividends = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\n', '    uint _taxedEthereum = _ethereumToSpend.sub(_dividends);\n', '    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '    return _amountOfTokens;\n', '  }\n', '\n', '  // When selling tokens, we need to calculate the user&#39;s current dividend rate.\n', '  // This is different from their selected dividend rate.\n', '  function calculateEthereumReceived(uint _tokensToSell)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_tokensToSell <= tokenSupply);\n', '    uint _ethereum = tokensToEthereum_(_tokensToSell);\n', '    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n', '    uint _dividends = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '    return _taxedEthereum;\n', '  }\n', '\n', '  /*\n', '   * Get&#39;s a user&#39;s average dividend rate - which is just their divTokenBalance / tokenBalance\n', '   * We multiply by magnitude to avoid precision errors.\n', '   */\n', '\n', '  function getUserAverageDividendRate(address user) public view returns (uint) {\n', '    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n', '  }\n', '\n', '  function getMyAverageDividendRate() public view returns (uint) {\n', '    return getUserAverageDividendRate(msg.sender);\n', '  }\n', '\n', '  /*==========================================\n', '  =            INTERNAL FUNCTIONS            =\n', '  ==========================================*/\n', '\n', '  /* Purchase tokens with Ether.\n', '     During ICO phase, dividends should go to the bankroll\n', '     During normal operation:\n', '       0.5% should go to the master dividend card\n', '       0.5% should go to the matching dividend card\n', '       25% of dividends should go to the referrer, if any is provided. */\n', '  function purchaseTokens(uint _incomingEthereum, address _referredBy)\n', '  internal\n', '  returns (uint)\n', '  {\n', '    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, "Tried to buy below the min eth buyin threshold.");\n', '\n', '    uint toBankRoll;\n', '    uint toReferrer;\n', '    uint toTokenHolders;\n', '    uint toDivCardHolders;\n', '\n', '    uint dividendAmount;\n', '\n', '    uint tokensBought;\n', '    uint dividendTokensBought;\n', '\n', '    uint remainingEth = _incomingEthereum;\n', '\n', '    uint fee;\n', '\n', '    // 1% for dividend card holders is taken off before anything else\n', '    if (regularPhase) {\n', '      toDivCardHolders = _incomingEthereum.div(100);\n', '      remainingEth = remainingEth.sub(toDivCardHolders);\n', '    }\n', '\n', '    /* Next, we tax for dividends:\n', '       Dividends = (ethereum * div%) / 100\n', '       Important note: if we&#39;re out of the ICO phase, the 1% sent to div-card holders\n', '                       is handled prior to any dividend taxes are considered. */\n', '\n', '    // Grab the user&#39;s dividend rate\n', '    uint dividendRate = userDividendRate[msg.sender];\n', '\n', '    // Calculate the total dividends on this buy\n', '    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\n', '\n', '    remainingEth = remainingEth.sub(dividendAmount);\n', '\n', '    // If we&#39;re in the ICO and bankroll is buying, don&#39;t tax\n', '    if (icoPhase && msg.sender == bankrollAddress) {\n', '      remainingEth = remainingEth + dividendAmount;\n', '    }\n', '\n', '    // Calculate how many tokens to buy:\n', '    tokensBought = ethereumToTokens_(remainingEth);\n', '    dividendTokensBought = tokensBought.mul(dividendRate);\n', '\n', '    // This is where we actually mint tokens:\n', '    tokenSupply = tokenSupply.add(tokensBought);\n', '    divTokenSupply = divTokenSupply.add(dividendTokensBought);\n', '\n', '    /* Update the total investment tracker\n', '       Note that this must be done AFTER we calculate how many tokens are bought -\n', '       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\n', '\n', '    currentEthInvested = currentEthInvested + remainingEth;\n', '\n', '    // If ICO phase, all the dividends go to the bankroll\n', '    if (icoPhase) {\n', '      toBankRoll = dividendAmount;\n', '\n', '      // If the bankroll is buying, we don&#39;t want to send eth back to the bankroll\n', '      // Instead, let&#39;s just give it the tokens it would get in an infinite recursive buy\n', '      if (msg.sender == bankrollAddress) {\n', '        toBankRoll = 0;\n', '      }\n', '\n', '      toReferrer = 0;\n', '      toTokenHolders = 0;\n', '\n', '      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\n', '         not how much Ether we get total.\n', '         this is so that our calculation using "investment" is accurate. */\n', '      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\n', '      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\n', '\n', '      // Cannot purchase more than the hard cap during ICO.\n', '      require(ethInvestedDuringICO <= icoHardCap);\n', '      // Contracts aren&#39;t allowed to participate in the ICO.\n', '      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\n', '\n', '      // Cannot purchase more then the limit per address during the ICO.\n', '      ICOBuyIn[msg.sender] += remainingEth;\n', '      //require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress); // test:remove\n', '\n', '      // Stop the ICO phase if we reach the hard cap\n', '      if (ethInvestedDuringICO == icoHardCap) {\n', '        icoPhase = false;\n', '      }\n', '\n', '    } else {\n', '      // Not ICO phase, check for referrals\n', '\n', '      // 25% goes to referrers, if set\n', '      // toReferrer = (dividends * 25)/100\n', '      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '      _referredBy != msg.sender &&\n', '      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\n', '      {\n', '        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n', '        referralBalance_[_referredBy] += toReferrer;\n', '        emit Referral(_referredBy, toReferrer);\n', '      }\n', '\n', '      // The rest of the dividends go to token holders\n', '      toTokenHolders = dividendAmount.sub(toReferrer);\n', '\n', '      fee = toTokenHolders * magnitude;\n', '      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\n', '\n', '      // Finally, increase the divToken value\n', '      profitPerDivToken = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n', '      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\n', '    }\n', '\n', '    // Update the buyer&#39;s token amounts\n', '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\n', '\n', '    // Transfer to bankroll and div cards\n', '    if (toBankRoll != 0) {ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)();}\n', '    if (regularPhase) {divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate);}\n', '\n', '    // This event should help us track where all the eth is going\n', '    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\n', '\n', '    // Sanity checking\n', '    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\n', '    assert(sum == 0);\n', '  }\n', '\n', '  // How many tokens one gets from a certain amount of ethereum.\n', '  function ethereumToTokens_(uint _ethereumAmount)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_ethereumAmount > MIN_ETH_BUYIN, "Tried to buy tokens with too little eth.");\n', '\n', '    if (icoPhase) {\n', '      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\n', '    }\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the buy into two segments:\n', '    //  1) the amount of eth going towards ico-price tokens\n', '    //  2) the amount of eth going towards pyramid-price (variable) tokens\n', '    uint ethTowardsICOPriceTokens = 0;\n', '    uint ethTowardsVariablePriceTokens = 0;\n', '\n', '    if (currentEthInvested >= ethInvestedDuringICO) {\n', '      // Option One: All the ETH goes towards variable-price tokens\n', '      ethTowardsVariablePriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\n', '      // Option Two: All the ETH goes towards ICO-price tokens\n', '      ethTowardsICOPriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\n', '      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\n', '      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\n', '      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\n', '    } else {\n', '      // Option Four: Should be impossible, and compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\n', '\n', '    // Separate out the number of tokens of each type this will buy:\n', '    uint icoPriceTokens = 0;\n', '    uint varPriceTokens = 0;\n', '\n', '    // Now calculate each one per the above formulas.\n', '    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\n', '    if (ethTowardsICOPriceTokens != 0) {\n', '      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\n', '    }\n', '\n', '    if (ethTowardsVariablePriceTokens != 0) {\n', '      // Note: we can&#39;t use "currentEthInvested" for this calculation, we must use:\n', '      //  currentEthInvested + ethTowardsICOPriceTokens\n', '      // This is because a split-buy essentially needs to simulate two separate buys -\n', '      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\n', '\n', '      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\n', '      uint simulatedEthAfterInvested = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\n', '\n', '      /* We have the equations for total tokens above; note that this is for TOTAL.\n', '         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\n', '         and the simulatedEthInvestedAfter and calculate the difference in tokens.\n', '         This is how many we get. */\n', '\n', '      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '      uint tokensAfter = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '\n', '      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\n', '         either should work.\n', '\n', '         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n', '         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n', '\n', '      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n', '    }\n', '\n', '    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\n', '\n', '    assert(totalTokensReceived > 0);\n', '    return totalTokensReceived;\n', '  }\n', '\n', '  // How much Ether we get from selling N tokens\n', '  function tokensToEthereum_(uint _tokens)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_tokens >= MIN_TOKEN_SELL_AMOUNT, "Tried to sell too few tokens.");\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the sell into two segments:\n', '    //  1) the amount of tokens selling at the ICO price.\n', '    //  2) the amount of tokens selling at the variable (pyramid) price\n', '    uint tokensToSellAtICOPrice = 0;\n', '    uint tokensToSellAtVariablePrice = 0;\n', '\n', '    if (tokenSupply <= tokensMintedDuringICO) {\n', '      // Option One: All the tokens sell at the ICO price.\n', '      tokensToSellAtICOPrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\n', '      // Option Two: All the tokens sell at the variable price.\n', '      tokensToSellAtVariablePrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\n', '      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\n', '      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\n', '      tokensToSellAtICOPrice = _tokens.sub(tokensToSellAtVariablePrice);\n', '\n', '    } else {\n', '      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\n', '\n', '    // Track how much Ether we get from selling at each price function:\n', '    uint ethFromICOPriceTokens;\n', '    uint ethFromVarPriceTokens;\n', '\n', '    // Now, actually calculate:\n', '\n', '    if (tokensToSellAtICOPrice != 0) {\n', '\n', '      /* Here, unlike the sister equation in ethereumToTokens, we DON&#39;T need to multiply by 1e18, since\n', '         we will be passed in an amount of tokens to sell that&#39;s already at the 18-decimal precision.\n', '         We need to divide by 1e18 or we&#39;ll have too much Ether. */\n', '\n', '      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\n', '    }\n', '\n', '    if (tokensToSellAtVariablePrice != 0) {\n', '\n', '      /* Note: Unlike the sister function in ethereumToTokens, we don&#39;t have to calculate any "virtual" token count.\n', '         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\n', '         Thus there isn&#39;t any weird stuff going on with the token supply.\n', '\n', '         We have the equations for total investment above; note that this is for TOTAL.\n', '         To get the eth received from this sell, we calculate the new total investment after this sell.\n', '         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\n', '\n', '      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint investmentAfter = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '\n', '      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n', '    }\n', '\n', '    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\n', '\n', '    assert(totalEthReceived > 0);\n', '    return totalEthReceived;\n', '  }\n', '\n', '  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n', '  internal\n', '  {\n', '    require(regularPhase);\n', '    require(_toAddress != address(0x0));\n', '    address _customerAddress = _from;\n', '    uint _amountOfFrontEndTokens = _amountOfTokens;\n', '\n', '    // Withdraw all outstanding dividends first (including those generated from referrals).\n', '    if (theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n', '\n', '    // Calculate how many back-end dividend tokens to transfer.\n', '    // This amount is proportional to the caller&#39;s average dividend rate multiplied by the proportion of tokens being transferred.\n', '    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n', '\n', '    if (_customerAddress != msg.sender) {\n', '      // Update the allowed balance.\n', '      // Don&#39;t update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n', '      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n', '    }\n', '\n', '    // Exchange tokens\n', '    frontTokenBalanceLedger_[_customerAddress] = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n', '    frontTokenBalanceLedger_[_toAddress] = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n', '    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n', '    dividendTokenBalanceLedger_[_toAddress] = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n', '\n', '    // Recipient inherits dividend percentage if they have not already selected one.\n', '    if (!userSelectedRate[_toAddress])\n', '    {\n', '      userSelectedRate[_toAddress] = true;\n', '      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n', '    }\n', '\n', '    // Update dividend trackers\n', '    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\n', '    payoutsTo_[_toAddress] += (int256) (profitPerDivToken * _amountOfDivTokens);\n', '\n', '    uint length;\n', '\n', '    assembly {\n', '      length := extcodesize(_toAddress)\n', '    }\n', '\n', '    if (length > 0) {\n', '      // its a contract\n', '      // note: at ethereum update ALL addresses are contracts\n', '      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n', '      receiver.tokenFallback(_from, _amountOfTokens, _data);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n', '  }\n', '\n', '  // Called from transferFrom. Always checks if _customerAddress has dividends.\n', '  function withdrawFrom(address _customerAddress)\n', '  internal\n', '  {\n', '    // Setup data\n', '    uint _dividends = theDividendsOf(false, _customerAddress);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    _customerAddress.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_customerAddress, _dividends);\n', '  }\n', '\n', '\n', '  /*=======================\n', '   =    RESET FUNCTIONS   =\n', '   ======================*/\n', '\n', '  function injectEther()\n', '  public\n', '  payable\n', '  onlyAdministrator\n', '  {\n', '\n', '  }\n', '\n', '  /*=======================\n', '   =   MATHS FUNCTIONS    =\n', '   ======================*/\n', '\n', '  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\n', '    // m = 3, n = 2\n', '    // sqrt(x^3)\n', '    return sqrt(x ** 3);\n', '  }\n', '\n', '  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\n', '    // m = 2, n = 3\n', '    // cbrt(x^2)\n', '    return cbrt(x ** 2);\n', '  }\n', '\n', '  function sqrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / z + z) / 2;\n', '    }\n', '  }\n', '\n', '  function cbrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 3;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / (z * z) + 2 * z) / 3;\n', '    }\n', '  }\n', '}\n', '\n', '/*=======================\n', ' =     INTERFACES       =\n', ' ======================*/\n', '\n', 'contract ZethrBankroll {\n', '  function receiveDividends() public payable {}\n', '}\n', '\n', '// File: contracts/Games/JackpotHolding.sol\n', '\n', '/*\n', '*\n', '* Jackpot holding contract.\n', '*  \n', '* This accepts token payouts from a game for every player loss,\n', '* and on a win, pays out *half* of the jackpot to the winner.\n', '*\n', '* Jackpot payout should only be called from the game.\n', '*\n', '*/\n', 'contract JackpotHolding is ERC223Receiving {\n', '\n', '  /****************************\n', '   * FIELDS\n', '   ****************************/\n', '\n', '  // How many times we&#39;ve paid out the jackpot\n', '  uint public payOutNumber = 0;\n', '\n', '  // The amount to divide the token balance by for a pay out (defaults to half the token balance)\n', '  uint public payOutDivisor = 2;\n', '\n', '  // Holds the bankroll controller info\n', '  ZethrBankrollControllerInterface controller;\n', '\n', '  // Zethr contract\n', '  Zethr zethr;\n', '\n', '  /****************************\n', '   * CONSTRUCTOR\n', '   ****************************/\n', '\n', '  constructor (address _controllerAddress, address _zethrAddress) public {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '    zethr = Zethr(_zethrAddress);\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes/*_data*/)\n', '  public\n', '  returns (bool)\n', '  {\n', '    // Do nothing, we can track the jackpot by this balance\n', '  }\n', '\n', '  /****************************\n', '   * VIEWS\n', '   ****************************/\n', '  function getJackpotBalance()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    // Half of this balance + half of jackpotBalance in each token bankroll\n', '    uint tempBalance;\n', '\n', '    for (uint i=0; i<7; i++) {\n', '      tempBalance += controller.tokenBankrolls(i).jackpotBalance() > 0 ? controller.tokenBankrolls(i).jackpotBalance() / payOutDivisor : 0;\n', '    }\n', '\n', '    tempBalance += zethr.balanceOf(address(this)) > 0 ? zethr.balanceOf(address(this)) / payOutDivisor : 0;\n', '\n', '    return tempBalance;\n', '  }\n', '\n', '  /****************************\n', '   * OWNER FUNCTIONS\n', '   ****************************/\n', '\n', '  /** @dev Sets the pay out divisor\n', '    * @param _divisor The value to set the new divisor to\n', '    */\n', '  function ownerSetPayOutDivisor(uint _divisor)\n', '  public\n', '  ownerOnly\n', '  {\n', '    require(_divisor != 0);\n', '\n', '    payOutDivisor = _divisor;\n', '  }\n', '\n', '  /** @dev Sets the address of the game controller\n', '    * @param _controllerAddress The new address of the controller\n', '    */\n', '  function ownerSetControllerAddress(address _controllerAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '  }\n', '\n', '  /** @dev Transfers the jackpot to _to\n', '    * @param _to Address to send the jackpot tokens to\n', '    */\n', '  function ownerWithdrawZth(address _to)\n', '  public\n', '  ownerOnly\n', '  {\n', '    uint balance = zethr.balanceOf(address(this));\n', '    zethr.transfer(_to, balance);\n', '  }\n', '\n', '  /** @dev Transfers any ETH received from dividends to _to\n', '    * @param _to Address to send the ETH to\n', '    */\n', '  function ownerWithdrawEth(address _to)\n', '  public\n', '  ownerOnly\n', '  {\n', '    _to.transfer(address(this).balance);\n', '  }\n', '\n', '  /****************************\n', '   * GAME FUNCTIONS\n', '   ****************************/\n', '\n', '  function gamePayOutWinner(address _winner)\n', '  public\n', '  gameOnly\n', '  {\n', '    // Call the payout function on all 7 token bankrolls\n', '    for (uint i=0; i<7; i++) {\n', '      controller.tokenBankrolls(i).payJackpotToWinner(_winner, payOutDivisor);\n', '    }\n', '\n', '    uint payOutAmount;\n', '\n', '    // Calculate pay out & pay out\n', '    if (zethr.balanceOf(address(this)) >= 1e10) {\n', '      payOutAmount = zethr.balanceOf(address(this)) / payOutDivisor;\n', '    }\n', '\n', '    if (payOutAmount >= 1e10) {\n', '      zethr.transfer(_winner, payOutAmount);\n', '    }\n', '\n', '    // Increment the statistics fields\n', '    payOutNumber += 1;\n', '\n', '    // Emit jackpot event\n', '    emit JackpotPayOut(_winner, payOutNumber);\n', '  }\n', '\n', '  /****************************\n', '   * EVENTS\n', '   ****************************/\n', '\n', '  event JackpotPayOut(\n', '    address winner,\n', '    uint payOutNumber\n', '  );\n', '\n', '  /****************************\n', '   * MODIFIERS\n', '   ****************************/\n', '\n', '  // Only an owner can call this method (controller is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // Only a game can call this method\n', '  modifier gameOnly()\n', '  {\n', '    require(controller.validGameAddresses(msg.sender));\n', '    _;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/ZethrGame.sol\n', '\n', '/* Zethr Game Interface\n', ' *\n', ' * Contains the necessary functions to integrate with\n', ' * the Zethr Token bankrolls & the Zethr game ecosystem.\n', ' *\n', ' * Token Bankroll Functions:\n', ' *  - execute\n', ' *\n', ' * Player Functions:\n', ' *  - finish\n', ' *\n', ' * Bankroll Controller / Owner Functions:\n', ' *  - pauseGame\n', ' *  - resumeGame\n', ' *  - set resolver percentage\n', ' *  - set controller address\n', ' *\n', ' * Player/Token Bankroll Functions:\n', ' *  - resolvePendingBets\n', '*/\n', 'contract ZethrGame {\n', '  using SafeMath for uint;\n', '  using SafeMath for uint56;\n', '\n', '  // Default events:\n', '  event Result (address player, uint amountWagered, int amountOffset);\n', '  event Wager (address player, uint amount, bytes data);\n', '\n', '  // Queue of pending/unresolved bets\n', '  address[] pendingBetsQueue;\n', '  uint queueHead = 0;\n', '  uint queueTail = 0;\n', '\n', '  // Store each player&#39;s latest bet via mapping\n', '  mapping(address => BetBase) bets;\n', '\n', '  // Bet structures must start with this layout\n', '  struct BetBase {\n', '    // Must contain these in this order\n', '    uint56 tokenValue;    // Multiply by 1e14 to get tokens\n', '    uint48 blockNumber;\n', '    uint8 tier;\n', '    // Game specific structures can add more after this\n', '  }\n', '\n', '  // Mapping of addresses to their *position* in the queue\n', '  // Zero = they aren&#39;t in the queue\n', '  mapping(address => uint) pendingBetsMapping;\n', '\n', '  // Holds the bankroll controller info\n', '  ZethrBankrollControllerInterface controller;\n', '\n', '  // Is the game paused?\n', '  bool paused;\n', '\n', '  // Minimum bet should always be >= 1\n', '  uint minBet = 1e18;\n', '\n', '  // Percentage that a resolver gets when he resolves bets for the house\n', '  uint resolverPercentage;\n', '\n', '  // Every game has a name\n', '  string gameName;\n', '\n', '  constructor (address _controllerAddress, uint _resolverPercentage, string _name) public {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '    resolverPercentage = _resolverPercentage;\n', '    gameName = _name;\n', '  }\n', '\n', '  /** @dev Gets the max profit of this game as decided by the token bankroll\n', '    * @return uint The maximum profit\n', '    */\n', '  function getMaxProfit()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    return ZethrTokenBankrollInterface(msg.sender).getMaxProfit(address(this));\n', '  }\n', '\n', '  /** @dev Pauses the game, preventing anyone from placing bets\n', '    */\n', '  function ownerPauseGame()\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = true;\n', '  }\n', '\n', '  /** @dev Resumes the game, allowing bets\n', '    */\n', '  function ownerResumeGame()\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = false;\n', '  }\n', '\n', '  /** @dev Sets the percentage of the bets that a resolver gets when resolving tokens.\n', '    * @param _percentage The percentage as x/1,000,000 that the resolver gets\n', '    */\n', '  function ownerSetResolverPercentage(uint _percentage)\n', '  public\n', '  ownerOnly\n', '  {\n', '    require(_percentage <= 1000000);\n', '    resolverPercentage = _percentage;\n', '  }\n', '\n', '  /** @dev Sets the address of the game controller\n', '    * @param _controllerAddress The new address of the controller\n', '    */\n', '  function ownerSetControllerAddress(address _controllerAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '  }\n', '\n', '  // Every game should have a name\n', '  /** @dev Sets the name of the game\n', '    * @param _name The name of the game\n', '    */\n', '  function ownerSetGameName(string _name)\n', '  ownerOnly\n', '  public\n', '  {\n', '    gameName = _name;\n', '  }\n', '\n', '  /** @dev Gets the game name\n', '    * @return The name of the game\n', '    */\n', '  function getGameName()\n', '  public view\n', '  returns (string)\n', '  {\n', '    return gameName;\n', '  }\n', '\n', '  /** @dev Resolve expired bets in the queue. Gives a percentage of the house edge to the resolver as ZTH\n', '    * @param _numToResolve The number of bets to resolve.\n', '    * @return tokensEarned The number of tokens earned\n', '    * @return queueHead The new head of the queue\n', '    */\n', '  function resolveExpiredBets(uint _numToResolve)\n', '  public\n', '  returns (uint tokensEarned_, uint queueHead_)\n', '  {\n', '    uint mQueue = queueHead;\n', '    uint head;\n', '    uint tail = (mQueue + _numToResolve) > pendingBetsQueue.length ? pendingBetsQueue.length : (mQueue + _numToResolve);\n', '    uint tokensEarned = 0;\n', '\n', '    for (head = mQueue; head < tail; head++) {\n', '      // Check the head of the queue to see if there is a resolvable bet\n', '      // This means the bet at the queue head is older than 255 blocks AND is not 0\n', '      // (However, if the address at the head is null, skip it, it&#39;s already been resolved)\n', '      if (pendingBetsQueue[head] == address(0x0)) {\n', '        continue;\n', '      }\n', '\n', '      if (bets[pendingBetsQueue[head]].blockNumber != 0 && block.number > 256 + bets[pendingBetsQueue[head]].blockNumber) {\n', '        // Resolve the bet\n', '        // finishBetfrom returns the *player* profit\n', '        // this will be negative if the player lost and the house won\n', '        // so flip it to get the house profit, if any\n', '        int sum = - finishBetFrom(pendingBetsQueue[head]);\n', '\n', '        // Tokens earned is a percentage of the loss\n', '        if (sum > 0) {\n', '          tokensEarned += (uint(sum).mul(resolverPercentage)).div(1000000);\n', '        }\n', '\n', '        // Queue-tail is always the "next" open spot, so queue head and tail will never overlap\n', '      } else {\n', '        // If we can&#39;t resolve a bet, stop going down the queue\n', '        break;\n', '      }\n', '    }\n', '\n', '    queueHead = head;\n', '\n', '    // Send the earned tokens to the resolver\n', '    if (tokensEarned >= 1e14) {\n', '      controller.gamePayoutResolver(msg.sender, tokensEarned);\n', '    }\n', '\n', '    return (tokensEarned, head);\n', '  }\n', '\n', '  /** @dev Finishes the bet of the sender, if it exists.\n', '    * @return int The total profit (positive or negative) earned by the sender\n', '    */\n', '  function finishBet()\n', '  public\n', '  hasNotBetThisBlock(msg.sender)\n', '  returns (int)\n', '  {\n', '    return finishBetFrom(msg.sender);\n', '  }\n', '\n', '  /** @dev Resturns a random number\n', '    * @param _blockn The block number to base the random number off of\n', '    * @param _entropy Data to use in the random generation\n', '    * @param _index Data to use in the random generation\n', '    * @return randomNumber The random number to return\n', '    */\n', '  function maxRandom(uint _blockn, address _entropy, uint _index)\n', '  private view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(_blockn),\n', '          _entropy,\n', '          _index\n', '        )));\n', '  }\n', '\n', '  /** @dev Returns a random number\n', '    * @param _upper The upper end of the range, exclusive\n', '    * @param _blockn The block number to use for the random number\n', '    * @param _entropy An address to be used for entropy\n', '    * @param _index A number to get the next random number\n', '    * @return randomNumber The random number\n', '    */\n', '  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\n', '  internal view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(_blockn, _entropy, _index) % _upper;\n', '  }\n', '\n', '  // Prevents the user from placing two bets in one block\n', '  modifier hasNotBetThisBlock(address _sender)\n', '  {\n', '    require(bets[_sender].blockNumber != block.number);\n', '    _;\n', '  }\n', '\n', '  // Requires that msg.sender is one of the token bankrolls\n', '  modifier bankrollOnly {\n', '    require(controller.isTokenBankroll(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // Requires that the game is not paused\n', '  modifier isNotPaused {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  // Requires that the bet given has max profit low enough\n', '  modifier betIsValid(uint _betSize, uint _tier, bytes _data) {\n', '    uint divRate = ZethrTierLibrary.getDivRate(_tier);\n', '    require(isBetValid(_betSize, divRate, _data));\n', '    _;\n', '  }\n', '\n', '  // Only an owner can call this method (controller is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\n', '    _;\n', '  }\n', '\n', '  /** @dev Places a bet. Callable only by token bankrolls\n', '    * @param _player The player that is placing the bet\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _divRate The dividend rate of the player\n', '    * @param _data The game-specific data, encoded in bytes-form\n', '    */\n', '  function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;\n', '\n', '  /** @dev Resolves the bet of the supplied player.\n', '    * @param _playerAddress The address of the player whos bet we are resolving\n', '    * @return int The total profit the player earned, positive or negative\n', '    */\n', '  function finishBetFrom(address _playerAddress) internal returns (int);\n', '\n', '  /** @dev Determines if a supplied bet is valid\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _divRate The dividend rate of the bet\n', '    * @param _data The game-specific bet data\n', '    * @return bool Whether or not the bet is valid\n', '    */\n', '  function isBetValid(uint _tokenCount, uint _divRate, bytes _data) public view returns (bool);\n', '}\n', '\n', '// File: contracts/Games/ZethrSlots.sol\n', '\n', '/* The actual game contract.\n', ' *\n', ' * This contract contains the actual game logic,\n', ' * including placing bets (execute), resolving bets,\n', ' * and resolving expired bets.\n', '*/\n', 'contract ZethrSlots is ZethrGame {\n', '\n', '  /****************************\n', '   * GAME SPECIFIC\n', '   ****************************/\n', '\n', '  // Slots-specific bet structure\n', '  struct Bet {\n', '    // Must contain these in this order\n', '    uint56 tokenValue;\n', '    uint48 blockNumber;\n', '    uint8 tier;\n', '    // Game specific\n', '    uint8 numSpins;\n', '  }\n', '\n', '  /****************************\n', '   * FIELDS\n', '   ****************************/\n', '\n', '  // Sections with identical multipliers compressed for optimization\n', '  uint[14] MULTIPLIER_BOUNDARIES = [uint(299), 3128, 44627, 46627, 49127, 51627, 53127, 82530, 150423, 310818, 364283, 417748, 471213, ~uint256(0)];\n', '\n', '  // Maps indexes of results sections to multipliers as x/100\n', '  uint[14] MULTIPLIERS = [uint(5000), 2000, 300, 1100, 750, 900, 1300, 250, 150, 100, 200, 125, 133, 250];\n', '\n', '  // The holding contract for jackpot tokens\n', '  JackpotHolding public jackpotHoldingContract;\n', '\n', '  /****************************\n', '   * CONSTRUCTOR\n', '   ****************************/\n', '\n', '  constructor (address _controllerAddress, uint _resolverPercentage, string _name)\n', '  ZethrGame(_controllerAddress, _resolverPercentage, _name)\n', '  public\n', '  {\n', '  }\n', '\n', '  /****************************\n', '   * USER METHODS\n', '   ****************************/\n', '\n', '  /** @dev Retrieve the results of the last spin of a plyer, for web3 calls.\n', '    * @param _playerAddress The address of the player\n', '    */\n', '  function getLastSpinOutput(address _playerAddress)\n', '  public view\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint[] memory output)\n', '  {\n', '    // Cast to Bet and read from storage\n', '    Bet storage playerBetInStorage = getBet(_playerAddress);\n', '    Bet memory playerBet = playerBetInStorage;\n', '\n', '    // Safety check\n', '    require(playerBet.blockNumber != 0);\n', '\n', '    (winAmount, lossAmount, jackpotAmount, jackpotWins, output) = getSpinOutput(playerBet.blockNumber, playerBet.numSpins, playerBet.tokenValue.mul(1e14), _playerAddress);\n', '\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins, output);\n', '  }\n', '    \n', '    event SlotsResult(\n', '        uint    _blockNumber,\n', '        address _target,\n', '        uint    _numSpins,\n', '        uint    _tokenValue,\n', '        uint    _winAmount,\n', '        uint    _lossAmount,\n', '        uint[]  _output\n', '    );\n', '    \n', '  /** @dev Retrieve the results of the spin, for web3 calls.\n', '    * @param _blockNumber The block number of the spin\n', '    * @param _numSpins The number of spins of this bet\n', '    * @param _tokenValue The total number of tokens bet\n', '    * @param _target The address of the better\n', '    * @return winAmount The total number of tokens won\n', '    * @return lossAmount The total number of tokens lost\n', '    * @return jackpotAmount The total amount of tokens won in the jackpot\n', '    * @return output An array of all of the results of a multispin\n', '    */\n', '  function getSpinOutput(uint _blockNumber, uint _numSpins, uint _tokenValue, address _target)\n', '  public view\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint[] memory output)\n', '  {\n', '    output = new uint[](_numSpins);\n', '    // Where the result sections start and stop\n', '\n', '    // If current block for the first spin is older than 255 blocks, ALL spins are losses\n', '    if (block.number - _blockNumber > 255) {\n', '      // Output stays 0 for eveything, this is a loss\n', '      // No jackpot wins\n', '      // No wins\n', '      // Loss is the total tokens bet\n', '      lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);\n', '      jackpotAmount = _tokenValue.mul(_numSpins).div(100);\n', '    } else {\n', '\n', '      for (uint i = 0; i < _numSpins; i++) {\n', '        // Store the output\n', '        output[i] = random(1000000, _blockNumber, _target, i) + 1;\n', '\n', '        if (output[i] < 2) {\n', '          // Jackpot get\n', '          jackpotWins++;\n', '          lossAmount += _tokenValue;\n', '        } else if (output[i] > 506856) {\n', '          // Player loss\n', '          lossAmount += (_tokenValue.mul(99)).div(100);\n', '          jackpotAmount += _tokenValue.div(100);\n', '        } else {\n', '          // Player win\n', '\n', '          // Iterate over the array of win results to find the correct multiplier array index\n', '          uint index;\n', '          for (index = 0; index < MULTIPLIER_BOUNDARIES.length; index++) {\n', '            if (output[i] < MULTIPLIER_BOUNDARIES[index]) break;\n', '          }\n', '          // Use index to find the correct multipliers\n', '          winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);\n', '        }\n', '      }\n', '    }\n', '    emit SlotsResult(_blockNumber, _target, _numSpins, _tokenValue, winAmount, lossAmount, output);\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins, output);\n', '  }\n', '\n', '  /** @dev Retrieve the results of the spin, for contract calls.\n', '    * @param _blockNumber The block number of the spin\n', '    * @param _numSpins The number of spins of this bet\n', '    * @param _tokenValue The total number of tokens bet\n', '    * @param _target The address of the better\n', '    * @return winAmount The total number of tokens won\n', '    * @return lossAmount The total number of tokens lost\n', '    * @return jackpotAmount The total amount of tokens won in the jackpot\n', '    */\n', '  function getSpinResults(uint _blockNumber, uint _numSpins, uint _tokenValue, address _target)\n', '  public\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins)\n', '  {\n', '    // Where the result sections start and stop\n', '\n', '    // If current block for the first spin is older than 255 blocks, ALL spins are losses\n', '    if (block.number - _blockNumber > 255) {\n', '      // Output stays 0 for eveything, this is a loss\n', '      // No jackpot wins\n', '      // No wins\n', '      // Loss is the total tokens bet\n', '      lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);\n', '      jackpotAmount = _tokenValue.mul(_numSpins).div(100);\n', '    } else {\n', '\n', '      uint result;\n', '\n', '      for (uint i = 0; i < _numSpins; i++) {\n', '        // Store the output\n', '        result = random(1000000, _blockNumber, _target, i) + 1;\n', '\n', '        if (result < 2) {\n', '          // Jackpot get\n', '          jackpotWins++;\n', '        } else if (result > 506856) {\n', '          // Player loss\n', '          lossAmount += (_tokenValue.mul(99)).div(100);\n', '          jackpotAmount += _tokenValue.div(100);\n', '        } else {\n', '          // Player win\n', '\n', '          // Iterate over the array of win results to find the correct multiplier array index\n', '          uint index;\n', '          for (index = 0; index < MULTIPLIER_BOUNDARIES.length; index++) {\n', '            if (result < MULTIPLIER_BOUNDARIES[index]) break;\n', '          }\n', '          // Use index to find the correct multipliers\n', '          winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);\n', '        }\n', '      }\n', '    }\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins);\n', '  }\n', '\n', '  /****************************\n', '   * OWNER METHODS\n', '   ****************************/\n', '\n', '  /** @dev Set the address of the jackpot contract\n', '    * @param _jackpotAddress The address of the jackpot contract\n', '    */\n', '  function ownerSetJackpotAddress(address _jackpotAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    jackpotHoldingContract = JackpotHolding(_jackpotAddress);\n', '  }\n', '\n', '  /****************************\n', '   * INTERNALS\n', '   ****************************/\n', '\n', '  /** @dev Returs the bet struct of a player\n', '    * @param _playerAddress The address of the player\n', '    * @return Bet The bet of the player\n', '    */\n', '  function getBet(address _playerAddress)\n', '  internal view\n', '  returns (Bet storage)\n', '  {\n', '    // Cast BetBase to Bet\n', '    BetBase storage betBase = bets[_playerAddress];\n', '\n', '    Bet storage playerBet;\n', '    assembly {\n', '    // tmp is pushed onto stack and points to betBase slot in storage\n', '      let tmp := betBase_slot\n', '\n', '    // swap1 swaps tmp and playerBet pointers\n', '      swap1\n', '    }\n', '    // tmp is popped off the stack\n', '\n', '    // playerBet now points to betBase\n', '    return playerBet;\n', '  }\n', '\n', '  /** @dev Resturns a random number\n', '    * @param _blockn The block number to base the random number off of\n', '    * @param _entropy Data to use in the random generation\n', '    * @param _index Data to use in the random generation\n', '    * @return randomNumber The random number to return\n', '    */\n', '  function maxRandom(uint _blockn, address _entropy, uint _index)\n', '  private view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(_blockn),\n', '          _entropy,\n', '          _index\n', '        )));\n', '  }\n', '\n', '  /** @dev Returns a random number\n', '    * @param _upper The upper end of the range, exclusive\n', '    * @param _blockn The block number to use for the random number\n', '    * @param _entropy An address to be used for entropy\n', '    * @param _index A number to get the next random number\n', '    * @return randomNumber The random number\n', '    */\n', '  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\n', '  internal view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(_blockn, _entropy, _index) % _upper;\n', '  }\n', '\n', '  /****************************\n', '   * OVERRIDDEN METHODS\n', '   ****************************/\n', '\n', '  /** @dev Resolves the bet of the supplied player.\n', '    * @param _playerAddress The address of the player whos bet we are resolving\n', '    * @return totalProfit The total profit the player earned, positive or negative\n', '    */\n', '  function finishBetFrom(address _playerAddress)\n', '  internal\n', '  returns (int /*totalProfit*/)\n', '  {\n', '    // Memory vars to hold data as we compute it\n', '    uint winAmount;\n', '    uint lossAmount;\n', '    uint jackpotAmount;\n', '    uint jackpotWins;\n', '\n', '    // Cast to Bet and read from storage\n', '    Bet storage playerBetInStorage = getBet(_playerAddress);\n', '    Bet memory playerBet = playerBetInStorage;\n', '\n', '    // Player should not be able to resolve twice!\n', '    require(playerBet.blockNumber != 0);\n', '\n', '    // Safety check\n', '    require(playerBet.blockNumber != 0);\n', '    playerBetInStorage.blockNumber = 0;\n', '\n', '    // Iterate over the number of spins and calculate totals:\n', '    //  - player win amount\n', '    //  - bankroll win amount\n', '    //  - jackpot wins\n', '    (winAmount, lossAmount, jackpotAmount, jackpotWins) = getSpinResults(playerBet.blockNumber, playerBet.numSpins, playerBet.tokenValue.mul(1e14), _playerAddress);\n', '\n', '    // Figure out the token bankroll address\n', '    address tokenBankrollAddress = controller.getTokenBankrollAddressFromTier(playerBet.tier);\n', '    ZethrTokenBankrollInterface bankroll = ZethrTokenBankrollInterface(tokenBankrollAddress);\n', '\n', '    // Call into the bankroll to do some token accounting\n', '    bankroll.gameTokenResolution(winAmount, _playerAddress, jackpotAmount, address(jackpotHoldingContract), playerBet.tokenValue.mul(1e14).mul(playerBet.numSpins));\n', '\n', '    // Pay out jackpot if won\n', '    if (jackpotWins > 0) {\n', '      for (uint x = 0; x < jackpotWins; x++) {\n', '        jackpotHoldingContract.gamePayOutWinner(_playerAddress);\n', '      }\n', '    }\n', '\n', '    // Grab the position of the player in the pending bets queue\n', '    uint index = pendingBetsMapping[_playerAddress];\n', '\n', '    // Remove the player from the pending bets queue by setting the address to 0x0\n', '    pendingBetsQueue[index] = address(0x0);\n', '\n', '    // Delete the player&#39;s bet by setting the mapping to zero\n', '    pendingBetsMapping[_playerAddress] = 0;\n', '\n', '    emit Result(_playerAddress, playerBet.tokenValue.mul(1e14), int(winAmount) - int(lossAmount) - int(jackpotAmount));\n', '\n', '    // Return all bet results + total *player* profit\n', '    return (int(winAmount) - int(lossAmount) - int(jackpotAmount));\n', '  }\n', '\n', '  /** @dev Places a bet. Callable only by token bankrolls\n', '    * @param _player The player that is placing the bet\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _tier The div rate tier the player falls in\n', '    * @param _data The game-specific data, encoded in bytes-form\n', '    */\n', '  function execute(address _player, uint _tokenCount, uint _tier, bytes _data)\n', '  isNotPaused\n', '  bankrollOnly\n', '  betIsValid(_tokenCount, _tier, _data)\n', '  hasNotBetThisBlock(_player)\n', '  public\n', '  {\n', '    Bet storage playerBet = getBet(_player);\n', '\n', '    // Check for a player bet and resolve if necessary\n', '    if (playerBet.blockNumber != 0) {\n', '      finishBetFrom(_player);\n', '    }\n', '\n', '    uint8 spins = uint8(_data[0]);\n', '\n', '    // Set bet information\n', '    playerBet.tokenValue = uint56(_tokenCount.div(spins).div(1e14));\n', '    playerBet.blockNumber = uint48(block.number);\n', '    playerBet.tier = uint8(_tier);\n', '    playerBet.numSpins = spins;\n', '\n', '    // Add player to the pending bets queue\n', '    pendingBetsQueue.length++;\n', '    pendingBetsQueue[queueTail] = _player;\n', '    queueTail++;\n', '\n', '    // Add the player&#39;s position in the queue to the pending bets mapping\n', '    pendingBetsMapping[_player] = queueTail - 1;\n', '\n', '    // Emit event\n', '    emit Wager(_player, _tokenCount, _data);\n', '  }\n', '\n', '  /** @dev Determines if a supplied bet is valid\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _data The game-specific bet data\n', '    * @return bool Whether or not the bet is valid\n', '    */\n', '  function isBetValid(uint _tokenCount, uint /*_divRate*/, bytes _data)\n', '  public view\n', '  returns (bool)\n', '  {\n', '    // Since the max win is 50x (for slots), the bet size must be\n', '    // <= 1/50 * the maximum profit.\n', '    uint8 spins = uint8(_data[0]);\n', '    return (_tokenCount.div(spins).mul(50) <= getMaxProfit()) && (_tokenCount.div(spins) >= minBet);\n', '  }\n', '}']
['/*\n', '  Zethr | https://zethr.io\n', '  (c) Copyright 2018 | All Rights Reserved\n', '  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Libraries/SafeMath.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Libraries/ZethrTierLibrary.sol\n', '\n', 'library ZethrTierLibrary {\n', '  uint constant internal magnitude = 2 ** 64;\n', '\n', '  // Gets the tier (1-7) of the divs sent based off of average dividend rate\n', '  // This is an index used to call into the correct sub-bankroll to withdraw tokens\n', '  function getTier(uint divRate) internal pure returns (uint8) {\n', '\n', '    // Divide the average dividned rate by magnitude\n', "    // Remainder doesn't matter because of the below logic\n", '    uint actualDiv = divRate / magnitude;\n', '    if (actualDiv >= 30) {\n', '      return 6;\n', '    } else if (actualDiv >= 25) {\n', '      return 5;\n', '    } else if (actualDiv >= 20) {\n', '      return 4;\n', '    } else if (actualDiv >= 15) {\n', '      return 3;\n', '    } else if (actualDiv >= 10) {\n', '      return 2;\n', '    } else if (actualDiv >= 5) {\n', '      return 1;\n', '    } else if (actualDiv >= 2) {\n', '      return 0;\n', '    } else {\n', '      // Impossible\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function getDivRate(uint _tier)\n', '  internal pure\n', '  returns (uint8)\n', '  {\n', '    if (_tier == 0) {\n', '      return 2;\n', '    } else if (_tier == 1) {\n', '      return 5;\n', '    } else if (_tier == 2) {\n', '      return 10;\n', '    } else if (_tier == 3) {\n', '      return 15;\n', '    } else if (_tier == 4) {\n', '      return 20;\n', '    } else if (_tier == 5) {\n', '      return 25;\n', '    } else if (_tier == 6) {\n', '      return 33;\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/ERC/ERC223Receiving.sol\n', '\n', 'contract ERC223Receiving {\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// File: contracts/ZethrMultiSigWallet.sol\n', '\n', '/* Zethr MultisigWallet\n', ' *\n', ' * Standard multisig wallet\n', ' * Holds the bankroll ETH, as well as the bankroll 33% ZTH tokens.\n', '*/ \n', 'contract ZethrMultiSigWallet is ERC223Receiving {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =              EVENTS            =\n', '  =================================*/\n', '\n', '  event Confirmation(address indexed sender, uint indexed transactionId);\n', '  event Revocation(address indexed sender, uint indexed transactionId);\n', '  event Submission(uint indexed transactionId);\n', '  event Execution(uint indexed transactionId);\n', '  event ExecutionFailure(uint indexed transactionId);\n', '  event Deposit(address indexed sender, uint value);\n', '  event OwnerAddition(address indexed owner);\n', '  event OwnerRemoval(address indexed owner);\n', '  event WhiteListAddition(address indexed contractAddress);\n', '  event WhiteListRemoval(address indexed contractAddress);\n', '  event RequirementChange(uint required);\n', '  event BankrollInvest(uint amountReceived);\n', '\n', '  /*=================================\n', '  =             VARIABLES           =\n', '  =================================*/\n', '\n', '  mapping (uint => Transaction) public transactions;\n', '  mapping (uint => mapping (address => bool)) public confirmations;\n', '  mapping (address => bool) public isOwner;\n', '  address[] public owners;\n', '  uint public required;\n', '  uint public transactionCount;\n', '  bool internal reEntered = false;\n', '  uint constant public MAX_OWNER_COUNT = 15;\n', '\n', '  /*=================================\n', '  =         CUSTOM CONSTRUCTS       =\n', '  =================================*/\n', '\n', '  struct Transaction {\n', '    address destination;\n', '    uint value;\n', '    bytes data;\n', '    bool executed;\n', '  }\n', '\n', '  struct TKN {\n', '    address sender;\n', '    uint value;\n', '  }\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyWallet() {\n', '    if (msg.sender != address(this))\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier isAnOwner() {\n', '    address caller = msg.sender;\n', '    if (isOwner[caller])\n', '      _;\n', '    else\n', '      revert();\n', '  }\n', '\n', '  modifier ownerDoesNotExist(address owner) {\n', '    if (isOwner[owner]) \n', '      revert();\n', '      _;\n', '  }\n', '\n', '  modifier ownerExists(address owner) {\n', '    if (!isOwner[owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier transactionExists(uint transactionId) {\n', '    if (transactions[transactionId].destination == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier confirmed(uint transactionId, address owner) {\n', '    if (!confirmations[transactionId][owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notConfirmed(uint transactionId, address owner) {\n', '    if (confirmations[transactionId][owner])\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notExecuted(uint transactionId) {\n', '    if (transactions[transactionId].executed)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier notNull(address _address) {\n', '    if (_address == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '  modifier validRequirement(uint ownerCount, uint _required) {\n', '    if ( ownerCount > MAX_OWNER_COUNT\n', '      || _required > ownerCount\n', '      || _required == 0\n', '      || ownerCount == 0)\n', '      revert();\n', '    _;\n', '  }\n', '\n', '\n', '  /*=================================\n', '  =         PUBLIC FUNCTIONS        =\n', '  =================================*/\n', '\n', '  /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '  /// @param _owners List of initial owners.\n', '  /// @param _required Number of required confirmations.\n', '  constructor (address[] _owners, uint _required)\n', '    public\n', '    validRequirement(_owners.length, _required)\n', '  {\n', '    // Add owners\n', '    for (uint i=0; i<_owners.length; i++) {\n', '      if (isOwner[_owners[i]] || _owners[i] == 0)\n', '        revert();\n', '      isOwner[_owners[i]] = true;\n', '    }\n', '\n', '    // Set owners\n', '    owners = _owners;\n', '\n', '    // Set required\n', '    required = _required;\n', '  }\n', '\n', '  /** Testing only.\n', '  function exitAll()\n', '    public\n', '  {\n', '    uint tokenBalance = ZTHTKN.balanceOf(address(this));\n', '    ZTHTKN.sell(tokenBalance - 1e18);\n', '    ZTHTKN.sell(1e18);\n', '    ZTHTKN.withdraw(address(0x0));\n', '  }\n', '  **/\n', '\n', '  /// @dev Fallback function allows Ether to be deposited.\n', '  function()\n', '    public\n', '    payable\n', '  {\n', '\n', '  }\n', '    \n', '  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of new owner.\n', '  function addOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerDoesNotExist(owner)\n', '    notNull(owner)\n', '    validRequirement(owners.length + 1, required)\n', '  {\n', '    isOwner[owner] = true;\n', '    owners.push(owner);\n', '    emit OwnerAddition(owner);\n', '  }\n', '\n', '  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of owner.\n', '  function removeOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    validRequirement(owners.length, required)\n', '  {\n', '    isOwner[owner] = false;\n', '    for (uint i=0; i<owners.length - 1; i++)\n', '      if (owners[i] == owner) {\n', '        owners[i] = owners[owners.length - 1];\n', '        break;\n', '      }\n', '\n', '    owners.length -= 1;\n', '    if (required > owners.length)\n', '      changeRequirement(owners.length);\n', '    emit OwnerRemoval(owner);\n', '  }\n', '\n', '  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '  /// @param owner Address of owner to be replaced.\n', '  /// @param owner Address of new owner.\n', '  function replaceOwner(address owner, address newOwner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    ownerDoesNotExist(newOwner)\n', '  {\n', '    for (uint i=0; i<owners.length; i++)\n', '      if (owners[i] == owner) {\n', '        owners[i] = newOwner;\n', '        break;\n', '      }\n', '\n', '    isOwner[owner] = false;\n', '    isOwner[newOwner] = true;\n', '    emit OwnerRemoval(owner);\n', '    emit OwnerAddition(newOwner);\n', '  }\n', '\n', '  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '  /// @param _required Number of required confirmations.\n', '  function changeRequirement(uint _required)\n', '    public\n', '    onlyWallet\n', '    validRequirement(owners.length, _required)\n', '  {\n', '    required = _required;\n', '    emit RequirementChange(_required);\n', '  }\n', '\n', '  /// @dev Allows an owner to submit and confirm a transaction.\n', '  /// @param destination Transaction target address.\n', '  /// @param value Transaction ether value.\n', '  /// @param data Transaction data payload.\n', '  /// @return Returns transaction ID.\n', '  function submitTransaction(address destination, uint value, bytes data)\n', '    public\n', '    returns (uint transactionId)\n', '  {\n', '    transactionId = addTransaction(destination, value, data);\n', '    confirmTransaction(transactionId);\n', '  }\n', '\n', '  /// @dev Allows an owner to confirm a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function confirmTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    transactionExists(transactionId)\n', '    notConfirmed(transactionId, msg.sender)\n', '  {\n', '    confirmations[transactionId][msg.sender] = true;\n', '    emit Confirmation(msg.sender, transactionId);\n', '    executeTransaction(transactionId);\n', '  }\n', '\n', '  /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function revokeConfirmation(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '  {\n', '    confirmations[transactionId][msg.sender] = false;\n', '    emit Revocation(msg.sender, transactionId);\n', '  }\n', '\n', '  /// @dev Allows anyone to execute a confirmed transaction.\n', '  /// @param transactionId Transaction ID.\n', '  function executeTransaction(uint transactionId)\n', '    public\n', '    notExecuted(transactionId)\n', '  {\n', '    if (isConfirmed(transactionId)) {\n', '      Transaction storage txToExecute = transactions[transactionId];\n', '      txToExecute.executed = true;\n', '      if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data))\n', '        emit Execution(transactionId);\n', '      else {\n', '        emit ExecutionFailure(transactionId);\n', '        txToExecute.executed = false;\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the confirmation status of a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Confirmation status.\n', '  function isConfirmed(uint transactionId)\n', '    public\n', '    constant\n', '    returns (bool)\n', '  {\n', '    uint count = 0;\n', '    for (uint i=0; i<owners.length; i++) {\n', '      if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '      if (count == required)\n', '        return true;\n', '    }\n', '  }\n', '\n', '  /*=================================\n', '  =        OPERATOR FUNCTIONS       =\n', '  =================================*/\n', '\n', '  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '  /// @param destination Transaction target address.\n', '  /// @param value Transaction ether value.\n', '  /// @param data Transaction data payload.\n', '  /// @return Returns transaction ID.\n', '  function addTransaction(address destination, uint value, bytes data)\n', '    internal\n', '    notNull(destination)\n', '    returns (uint transactionId)\n', '  {\n', '    transactionId = transactionCount;\n', '\n', '    transactions[transactionId] = Transaction({\n', '        destination: destination,\n', '        value: value,\n', '        data: data,\n', '        executed: false\n', '    });\n', '\n', '    transactionCount += 1;\n', '    emit Submission(transactionId);\n', '  }\n', '\n', '  /*\n', '   * Web3 call functions\n', '   */\n', '  /// @dev Returns number of confirmations of a transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Number of confirmations.\n', '  function getConfirmationCount(uint transactionId)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<owners.length; i++)\n', '      if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '  }\n', '\n', '  /// @dev Returns total number of transactions after filers are applied.\n', '  /// @param pending Include pending transactions.\n', '  /// @param executed Include executed transactions.\n', '  /// @return Total number of transactions after filters are applied.\n', '  function getTransactionCount(bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<transactionCount; i++)\n', '      if (pending && !transactions[i].executed || executed && transactions[i].executed)\n', '        count += 1;\n', '  }\n', '\n', '  /// @dev Returns list of owners.\n', '  /// @return List of owner addresses.\n', '  function getOwners()\n', '    public\n', '    constant\n', '    returns (address[])\n', '  {\n', '    return owners;\n', '  }\n', '\n', '  /// @dev Returns array with owner addresses, which confirmed transaction.\n', '  /// @param transactionId Transaction ID.\n', '  /// @return Returns array of owner addresses.\n', '  function getConfirmations(uint transactionId)\n', '    public\n', '    constant\n', '    returns (address[] _confirmations)\n', '  {\n', '    address[] memory confirmationsTemp = new address[](owners.length);\n', '    uint count = 0;\n', '    uint i;\n', '    for (i=0; i<owners.length; i++)\n', '      if (confirmations[transactionId][owners[i]]) {\n', '        confirmationsTemp[count] = owners[i];\n', '        count += 1;\n', '      }\n', '\n', '      _confirmations = new address[](count);\n', '\n', '      for (i=0; i<count; i++)\n', '        _confirmations[i] = confirmationsTemp[i];\n', '  }\n', '\n', '  /// @dev Returns list of transaction IDs in defined range.\n', '  /// @param from Index start position of transaction array.\n', '  /// @param to Index end position of transaction array.\n', '  /// @param pending Include pending transactions.\n', '  /// @param executed Include executed transactions.\n', '  /// @return Returns array of transaction IDs.\n', '  function getTransactionIds(uint from, uint to, bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint[] _transactionIds)\n', '  {\n', '    uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '    uint count = 0;\n', '    uint i;\n', '\n', '    for (i=0; i<transactionCount; i++)\n', '      if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n', '        transactionIdsTemp[count] = i;\n', '        count += 1;\n', '      }\n', '\n', '      _transactionIds = new uint[](to - from);\n', '\n', '    for (i=from; i<to; i++)\n', '      _transactionIds[i - from] = transactionIdsTemp[i];\n', '  }\n', '\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\n', '  public\n', '  returns (bool)\n', '  {\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/Interfaces/ZethrTokenBankrollInterface.sol\n', '\n', '// Zethr token bankroll function prototypes\n', 'contract ZethrTokenBankrollInterface is ERC223Receiving {\n', '  uint public jackpotBalance;\n', '  \n', '  function getMaxProfit(address) public view returns (uint);\n', '  function gameTokenResolution(uint _toWinnerAmount, address _winnerAddress, uint _toJackpotAmount, address _jackpotAddress, uint _originalBetSize) external;\n', '  function payJackpotToWinner(address _winnerAddress, uint payoutDivisor) public;\n', '}\n', '\n', '// File: contracts/Bankroll/Interfaces/ZethrBankrollControllerInterface.sol\n', '\n', 'contract ZethrBankrollControllerInterface is ERC223Receiving {\n', '  address public jackpotAddress;\n', '\n', '  ZethrTokenBankrollInterface[7] public tokenBankrolls; \n', '  \n', '  ZethrMultiSigWallet public multiSigWallet;\n', '\n', '  mapping(address => bool) public validGameAddresses;\n', '\n', '  function gamePayoutResolver(address _resolver, uint _tokenAmount) public;\n', '\n', '  function isTokenBankroll(address _address) public view returns (bool);\n', '\n', '  function getTokenBankrollAddressFromTier(uint8 _tier) public view returns (address);\n', '\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// File: contracts/ERC/ERC721Interface.sol\n', '\n', 'contract ERC721Interface {\n', '  function approve(address _to, uint _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint _tokenId) public;\n', '  function totalSupply() public view returns (uint total);\n', '  function transferFrom(address _from, address _to, uint _tokenId) public;\n', '  function transfer(address _to, uint _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint tokenId);\n', '}\n', '\n', '// File: contracts/Libraries/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '// File: contracts/Games/ZethrDividendCards.sol\n', '\n', 'contract ZethrDividendCards is ERC721Interface {\n', '    using SafeMath for uint;\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new dividend card comes into existence.\n', '  event Birth(uint tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token (dividend card, in this case) is sold.\n', '  event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721.\n', '  ///  Ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint tokenId);\n', '\n', '  // Events for calculating card profits / errors\n', '  event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner);\n', '  event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner);\n', '  event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner);\n', '  event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner);\n', '  event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId);\n', '  event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId);\n', '  event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId);\n', '  event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME           = "ZethrDividendCard";\n', '  string public constant SYMBOL         = "ZDC";\n', '  address public         BANKROLL;\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev A mapping from dividend card indices to the address that owns them.\n', '  ///  All dividend cards have a valid owner address.\n', '\n', '  mapping (uint => address) public      divCardIndexToOwner;\n', '\n', '  // A mapping from a dividend rate to the card index.\n', '\n', '  mapping (uint => uint) public         divCardRateToIndex;\n', '\n', '  // @dev A mapping from owner address to the number of dividend cards that address owns.\n', '  //  Used internally inside balanceOf() to resolve ownership count.\n', '\n', '  mapping (address => uint) private     ownershipDivCardCount;\n', '\n', '  /// @dev A mapping from dividend card indices to an address that has been approved to call\n', '  ///  transferFrom(). Each dividend card can only have one approved address for transfer\n', '  ///  at any time. A zero value means no approval is outstanding.\n', '\n', '  mapping (uint => address) public      divCardIndexToApproved;\n', '\n', '  // @dev A mapping from dividend card indices to the price of the dividend card.\n', '\n', '  mapping (uint => uint) private        divCardIndexToPrice;\n', '\n', '  mapping (address => bool) internal    administrators;\n', '\n', '  address public                        creator;\n', '  bool    public                        onSale;\n', '\n', '  /*** DATATYPES ***/\n', '\n', '  struct Card {\n', '    string name;\n', '    uint percentIncrease;\n', '  }\n', '\n', '  Card[] private divCards;\n', '\n', '  modifier onlyCreator() {\n', '    require(msg.sender == creator);\n', '    _;\n', '  }\n', '\n', '  constructor (address _bankroll) public {\n', '    creator = msg.sender;\n', '    BANKROLL = _bankroll;\n', '\n', '    createDivCard("2%", 1 ether, 2);\n', '    divCardRateToIndex[2] = 0;\n', '\n', '    createDivCard("5%", 1 ether, 5);\n', '    divCardRateToIndex[5] = 1;\n', '\n', '    createDivCard("10%", 1 ether, 10);\n', '    divCardRateToIndex[10] = 2;\n', '\n', '    createDivCard("15%", 1 ether, 15);\n', '    divCardRateToIndex[15] = 3;\n', '\n', '    createDivCard("20%", 1 ether, 20);\n', '    divCardRateToIndex[20] = 4;\n', '\n', '    createDivCard("25%", 1 ether, 25);\n', '    divCardRateToIndex[25] = 5;\n', '\n', '    createDivCard("33%", 1 ether, 33);\n', '    divCardRateToIndex[33] = 6;\n', '\n', '    createDivCard("MASTER", 5 ether, 10);\n', '    divCardRateToIndex[999] = 7;\n', '\n', '\t  onSale = true;\n', '\n', '    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true; // Norsefire\n', '    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true; // klob\n', '    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true; // Etherguy\n', '    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true; // blurr\n', '\n', '    administrators[msg.sender] = true; // Helps with debugging\n', '  }\n', '\n', '  /*** MODIFIERS ***/\n', '\n', '  // Modifier to prevent contracts from interacting with the flip cards\n', '  modifier isNotContract()\n', '  {\n', '    require (msg.sender == tx.origin);\n', '    _;\n', '  }\n', '\n', '\t// Modifier to prevent purchases before we open them up to everyone\n', '\tmodifier hasStarted()\n', '  {\n', '\t\trequire (onSale == true);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier isAdmin()\n', '  {\n', '\t  require(administrators[msg.sender]);\n', '\t  _;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  // Administrative update of the bankroll contract address\n', '  function setBankroll(address where)\n', '    public\n', '    isAdmin\n', '  {\n', '    BANKROLL = where;\n', '  }\n', '\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(address _to, uint _tokenId)\n', '    public\n', '    isNotContract\n', '  {\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    divCardIndexToApproved[_tokenId] = _to;\n', '\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner)\n', '    public\n', '    view\n', '    returns (uint balance)\n', '  {\n', '    return ownershipDivCardCount[_owner];\n', '  }\n', '\n', '  // Creates a div card with bankroll as the owner\n', '  function createDivCard(string _name, uint _price, uint _percentIncrease)\n', '    public\n', '    onlyCreator\n', '  {\n', '    _createDivCard(_name, BANKROLL, _price, _percentIncrease);\n', '  }\n', '\n', '\t// Opens the dividend cards up for sale.\n', '\tfunction startCardSale()\n', '        public\n', '        isAdmin\n', '  {\n', '\t\tonSale = true;\n', '\t}\n', '\n', '  /// @notice Returns all the relevant information about a specific div card\n', '  /// @param _divCardId The tokenId of the div card of interest.\n', '  function getDivCard(uint _divCardId)\n', '    public\n', '    view\n', '    returns (string divCardName, uint sellingPrice, address owner)\n', '  {\n', '    Card storage divCard = divCards[_divCardId];\n', '    divCardName = divCard.name;\n', '    sellingPrice = divCardIndexToPrice[_divCardId];\n', '    owner = divCardIndexToOwner[_divCardId];\n', '  }\n', '\n', '  function implementsERC721()\n', '    public\n', '    pure\n', '    returns (bool)\n', '  {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name()\n', '    public\n', '    pure\n', '    returns (string)\n', '  {\n', '    return NAME;\n', '  }\n', '\n', '  /// For querying owner of token\n', '  /// @param _divCardId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint _divCardId)\n', '    public\n', '    view\n', '    returns (address owner)\n', '  {\n', '    owner = divCardIndexToOwner[_divCardId];\n', '    require(owner != address(0));\n', '\treturn owner;\n', '  }\n', '\n', '  // Allows someone to send Ether and obtain a card\n', '  function purchase(uint _divCardId)\n', '    public\n', '    payable\n', '    hasStarted\n', '    isNotContract\n', '  {\n', '    address oldOwner  = divCardIndexToOwner[_divCardId];\n', '    address newOwner  = msg.sender;\n', '\n', '    // Get the current price of the card\n', '    uint currentPrice = divCardIndexToPrice[_divCardId];\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= currentPrice);\n', '\n', '    // To find the total profit, we need to know the previous price\n', '    // currentPrice      = previousPrice * (100 + percentIncrease);\n', '    // previousPrice     = currentPrice / (100 + percentIncrease);\n', '    uint percentIncrease = divCards[_divCardId].percentIncrease;\n', '    uint previousPrice   = SafeMath.mul(currentPrice, 100).div(100 + percentIncrease);\n', '\n', '    // Calculate total profit and allocate 50% to old owner, 50% to bankroll\n', '    uint totalProfit     = SafeMath.sub(currentPrice, previousPrice);\n', '    uint oldOwnerProfit  = SafeMath.div(totalProfit, 2);\n', '    uint bankrollProfit  = SafeMath.sub(totalProfit, oldOwnerProfit);\n', '    oldOwnerProfit       = SafeMath.add(oldOwnerProfit, previousPrice);\n', '\n', '    // Refund the sender the excess he sent\n', '    uint purchaseExcess  = SafeMath.sub(msg.value, currentPrice);\n', '\n', '    // Raise the price by the percentage specified by the card\n', '    divCardIndexToPrice[_divCardId] = SafeMath.div(SafeMath.mul(currentPrice, (100 + percentIncrease)), 100);\n', '\n', '    // Transfer ownership\n', '    _transfer(oldOwner, newOwner, _divCardId);\n', '\n', '    // Using send rather than transfer to prevent contract exploitability.\n', '    if(BANKROLL.send(bankrollProfit)) {\n', '      emit BankrollDivCardProfit(bankrollProfit, percentIncrease, oldOwner);\n', '    } else {\n', '      emit BankrollProfitFailure(bankrollProfit, percentIncrease, oldOwner);\n', '    }\n', '\n', '    if(oldOwner.send(oldOwnerProfit)) {\n', '      emit UserDivCardProfit(oldOwnerProfit, percentIncrease, oldOwner);\n', '    } else {\n', '      emit DivCardProfitFailure(oldOwnerProfit, percentIncrease, oldOwner);\n', '    }\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '\n', '  function priceOf(uint _divCardId)\n', '    public\n', '    view\n', '    returns (uint price)\n', '  {\n', '    return divCardIndexToPrice[_divCardId];\n', '  }\n', '\n', '  function setCreator(address _creator)\n', '    public\n', '    onlyCreator\n', '  {\n', '    require(_creator != address(0));\n', '\n', '    creator = _creator;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol()\n', '    public\n', '    pure\n', '    returns (string)\n', '  {\n', '    return SYMBOL;\n', '  }\n', '\n', '  /// @notice Allow pre-approved user to take ownership of a dividend card.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = divCardIndexToOwner[_divCardId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _divCardId));\n', '\n', '    _transfer(oldOwner, newOwner, _divCardId);\n', '  }\n', '\n', '  /// For querying totalSupply of token\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply()\n', '    public\n', '    view\n', '    returns (uint total)\n', '  {\n', '    return divCards.length;\n', '  }\n', '\n', '  /// Owner initates the transfer of the card to another account\n', '  /// @param _to The address for the card to be transferred to.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(address _to, uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    require(_owns(msg.sender, _divCardId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _divCardId);\n', '  }\n', '\n', '  /// Third-party initiates transfer of a card from address _from to address _to\n', '  /// @param _from The address for the card to be transferred from.\n', '  /// @param _to The address for the card to be transferred to.\n', '  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(address _from, address _to, uint _divCardId)\n', '    public\n', '    isNotContract\n', '  {\n', '    require(_owns(_from, _divCardId));\n', '    require(_approved(_to, _divCardId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _divCardId);\n', '  }\n', '\n', '  function receiveDividends(uint _divCardRate)\n', '    public\n', '    payable\n', '  {\n', '    uint _divCardId = divCardRateToIndex[_divCardRate];\n', '    address _regularAddress = divCardIndexToOwner[_divCardId];\n', '    address _masterAddress = divCardIndexToOwner[7];\n', '\n', '    uint toMaster = msg.value.div(2);\n', '    uint toRegular = msg.value.sub(toMaster);\n', '\n', '    if(_masterAddress.send(toMaster)){\n', '      emit masterCardProfit(toMaster, _masterAddress, _divCardId);\n', '    } else {\n', '      emit masterCardProfitFailure(toMaster, _masterAddress, _divCardId);\n', '    }\n', '\n', '    if(_regularAddress.send(toRegular)) {\n', '      emit regularCardProfit(toRegular, _regularAddress, _divCardId);\n', '    } else {\n', '      emit regularCardProfitFailure(toRegular, _regularAddress, _divCardId);\n', '    }\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to)\n', '    private\n', '    pure\n', '    returns (bool)\n', '  {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint _divCardId)\n', '    private\n', '    view\n', '    returns (bool)\n', '  {\n', '    return divCardIndexToApproved[_divCardId] == _to;\n', '  }\n', '\n', '  /// For creating a dividend card\n', '  function _createDivCard(string _name, address _owner, uint _price, uint _percentIncrease)\n', '    private\n', '  {\n', '    Card memory _divcard = Card({\n', '      name: _name,\n', '      percentIncrease: _percentIncrease\n', '    });\n', '    uint newCardId = divCards.push(_divcard) - 1;\n', '\n', "    // It's probably never going to happen, 4 billion tokens are A LOT, but\n", "    // let's just be 100% sure we never let this happen.\n", '    require(newCardId == uint(uint32(newCardId)));\n', '\n', '    emit Birth(newCardId, _name, _owner);\n', '\n', '    divCardIndexToPrice[newCardId] = _price;\n', '\n', '    // This will assign ownership, and also emit the Transfer event as per ERC721 draft\n', '    _transfer(BANKROLL, _owner, newCardId);\n', '  }\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint _divCardId)\n', '    private\n', '    view\n', '    returns (bool)\n', '  {\n', '    return claimant == divCardIndexToOwner[_divCardId];\n', '  }\n', '\n', '  /// @dev Assigns ownership of a specific Card to an address.\n', '  function _transfer(address _from, address _to, uint _divCardId)\n', '    private\n', '  {\n', "    // Since the number of cards is capped to 2^32 we can't overflow this\n", '    ownershipDivCardCount[_to]++;\n', '    //transfer ownership\n', '    divCardIndexToOwner[_divCardId] = _to;\n', '\n', "    // When creating new div cards _from is 0x0, but we can't account that address.\n", '    if (_from != address(0)) {\n', '      ownershipDivCardCount[_from]--;\n', '      // clear any previously approved ownership exchange\n', '      delete divCardIndexToApproved[_divCardId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    emit Transfer(_from, _to, _divCardId);\n', '  }\n', '}\n', '\n', '// File: contracts/Zethr.sol\n', '\n', 'contract Zethr {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyHolders() {\n', '    require(myFrontEndTokens() > 0);\n', '    _;\n', '  }\n', '\n', '  modifier dividendHolder() {\n', '    require(myDividends(true) > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdministrator(){\n', '    address _customerAddress = msg.sender;\n', '    require(administrators[_customerAddress]);\n', '    _;\n', '  }\n', '\n', '  /*==============================\n', '  =            EVENTS            =\n', '  ==============================*/\n', '\n', '  event onTokenPurchase(\n', '    address indexed customerAddress,\n', '    uint incomingEthereum,\n', '    uint tokensMinted,\n', '    address indexed referredBy\n', '  );\n', '\n', '  event UserDividendRate(\n', '    address user,\n', '    uint divRate\n', '  );\n', '\n', '  event onTokenSell(\n', '    address indexed customerAddress,\n', '    uint tokensBurned,\n', '    uint ethereumEarned\n', '  );\n', '\n', '  event onReinvestment(\n', '    address indexed customerAddress,\n', '    uint ethereumReinvested,\n', '    uint tokensMinted\n', '  );\n', '\n', '  event onWithdraw(\n', '    address indexed customerAddress,\n', '    uint ethereumWithdrawn\n', '  );\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens\n', '  );\n', '\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens\n', '  );\n', '\n', '  event Allocation(\n', '    uint toBankRoll,\n', '    uint toReferrer,\n', '    uint toTokenHolders,\n', '    uint toDivCardHolders,\n', '    uint forTokens\n', '  );\n', '\n', '  event Referral(\n', '    address referrer,\n', '    uint amountReceived\n', '  );\n', '\n', '  /*=====================================\n', '  =            CONSTANTS                =\n', '  =====================================*/\n', '\n', '  uint8 constant public                decimals = 18;\n', '\n', '  uint constant internal               tokenPriceInitial_ = 0.000653 ether;\n', '  uint constant internal               magnitude = 2 ** 64;\n', '\n', '  uint constant internal               icoHardCap = 250 ether;\n', '  uint constant internal               addressICOLimit = 1   ether;\n', '  uint constant internal               icoMinBuyIn = 0.1 finney;\n', '  uint constant internal               icoMaxGasPrice = 50000000000 wei;\n', '\n', '  uint constant internal               MULTIPLIER = 9615;\n', '\n', '  uint constant internal               MIN_ETH_BUYIN = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_TRANSFER = 1e10;\n', '  uint constant internal               referrer_percentage = 25;\n', '\n', '  uint public                          stakingRequirement = 100e18;\n', '\n', '  /*================================\n', '   =          CONFIGURABLES         =\n', '   ================================*/\n', '\n', '  string public                        name = "Zethr";\n', '  string public                        symbol = "ZTH";\n', '\n', '  //bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262); // public\n', '  bytes32 constant public              icoHashedPass = bytes32(0x8a6ddee3fb2508ff4a5b02b48e9bc4566d0f3e11f306b0f75341bf235662a9e3); // test hunter2\n', '\n', '  address internal                     bankrollAddress;\n', '\n', '  ZethrDividendCards                   divCardContract;\n', '\n', '  /*================================\n', '   =            DATASETS            =\n', '   ================================*/\n', '\n', '  // Tracks front & backend tokens\n', '  mapping(address => uint) internal    frontTokenBalanceLedger_;\n', '  mapping(address => uint) internal    dividendTokenBalanceLedger_;\n', '  mapping(address =>\n', '  mapping(address => uint))\n', '  public      allowed;\n', '\n', '  // Tracks dividend rates for users\n', '  mapping(uint8 => bool)    internal validDividendRates_;\n', '  mapping(address => bool)    internal userSelectedRate;\n', '  mapping(address => uint8)   internal userDividendRate;\n', '\n', '  // Payout tracking\n', '  mapping(address => uint)    internal referralBalance_;\n', '  mapping(address => int256)  internal payoutsTo_;\n', '\n', '  // ICO per-address limit tracking\n', '  mapping(address => uint)    internal ICOBuyIn;\n', '\n', '  uint public                          tokensMintedDuringICO;\n', '  uint public                          ethInvestedDuringICO;\n', '\n', '  uint public                          currentEthInvested;\n', '\n', '  uint internal                        tokenSupply = 0;\n', '  uint internal                        divTokenSupply = 0;\n', '\n', '  uint internal                        profitPerDivToken;\n', '\n', '  mapping(address => bool) public      administrators;\n', '\n', '  bool public                          icoPhase = false;\n', '  bool public                          regularPhase = false;\n', '\n', '  uint                                 icoOpenTime;\n', '\n', '  /*=======================================\n', '  =            PUBLIC FUNCTIONS           =\n', '  =======================================*/\n', '  constructor (address _bankrollAddress, address _divCardAddress)\n', '  public\n', '  {\n', '    bankrollAddress = _bankrollAddress;\n', '    divCardContract = ZethrDividendCards(_divCardAddress);\n', '\n', '    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;\n', '    // Norsefire\n', '    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true;\n', '    // klob\n', '    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true;\n', '    // Etherguy\n', '    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true;\n', '    // blurr\n', '    administrators[0x8537aa2911b193e5B377938A723D805bb0865670] = true;\n', '    // oguzhanox\n', '    administrators[0x9D221b2100CbE5F05a0d2048E2556a6Df6f9a6C3] = true;\n', '    // Randall\n', '    administrators[0xDa83156106c4dba7A26E9bF2Ca91E273350aa551] = true;\n', '    // TropicalRogue\n', '    administrators[0x71009e9E4e5e68e77ECc7ef2f2E95cbD98c6E696] = true;\n', '    // cryptodude\n', '\n', '    administrators[msg.sender] = true;\n', '    // Helps with debugging!\n', '\n', '    validDividendRates_[2] = true;\n', '    validDividendRates_[5] = true;\n', '    validDividendRates_[10] = true;\n', '    validDividendRates_[15] = true;\n', '    validDividendRates_[20] = true;\n', '    validDividendRates_[25] = true;\n', '    validDividendRates_[33] = true;\n', '\n', '    userSelectedRate[bankrollAddress] = true;\n', '    userDividendRate[bankrollAddress] = 33;\n', '\n', '  }\n', '\n', '  /**\n', '   * Same as buy, but explicitly sets your dividend percentage.\n', "   * If this has been called before, it will update your `default' dividend\n", '   *   percentage for regular buy transactions going forward.\n', '   */\n', '  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string /*providedUnhashedPass*/)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(icoPhase || regularPhase);\n', '\n', '    if (icoPhase) {\n', '\n', '      // Anti-bot measures - not perfect, but should help some.\n', '      // bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\n', '      //require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress); // test; remove\n', '\n', '      uint gasPrice = tx.gasprice;\n', '\n', '      // Prevents ICO buyers from getting substantially burned if the ICO is reached\n', '      //   before their transaction is processed.\n', '      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\n', '\n', '    }\n', '\n', '    // Dividend percentage should be a currently accepted value.\n', '    require(validDividendRates_[_divChoice]);\n', '\n', '    // Set the dividend fee percentage denominator.\n', '    userSelectedRate[msg.sender] = true;\n', '    userDividendRate[msg.sender] = _divChoice;\n', '    emit UserDividendRate(msg.sender, _divChoice);\n', '\n', '    // Finally, purchase tokens.\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  // All buys except for the above one require regular phase.\n', '\n', '  function buy(address _referredBy)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target)\n', '  public\n', '  payable\n', '  {\n', '    bytes memory empty;\n', '    buyAndTransfer(_referredBy, target, empty, 20);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data)\n', '  public\n', '  payable\n', '  {\n', '    buyAndTransfer(_referredBy, target, _data, 20);\n', '  }\n', '\n', '  // Overload\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\n', '  public\n', '  payable\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n', '    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n', '      purchaseTokens(msg.value, _referredBy);\n', '    } else {\n', '      buyAndSetDivPercentage(_referredBy, divChoice, "0x0");\n', '    }\n', '    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n', '    transferTo(msg.sender, target, difference, _data);\n', '  }\n', '\n', '  // Fallback function only works during regular phase - part of anti-bot protection.\n', '  function()\n', '  payable\n', '  public\n', '  {\n', '    /**\n', '    / If the user has previously set a dividend rate, sending\n', '    /   Ether directly to the contract simply purchases more at\n', '    /   the most recent rate. If this is their first time, they\n', "    /   are automatically placed into the 20% rate `bucket'.\n", '    **/\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    if (userSelectedRate[_customerAddress]) {\n', '      purchaseTokens(msg.value, 0x0);\n', '    } else {\n', '      buyAndSetDivPercentage(0x0, 20, "0x0");\n', '    }\n', '  }\n', '\n', '  function reinvest()\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    uint _dividends = myDividends(false);\n', '\n', "    // Pay out requisite `virtual' dividends.\n", '    address _customerAddress = msg.sender;\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    uint _tokens = purchaseTokens(_dividends, 0x0);\n', '\n', '    // Fire logging event.\n', '    emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '  }\n', '\n', '  function exit()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Retrieve token balance for caller, then sell them all.\n', '    address _customerAddress = msg.sender;\n', '    uint _tokens = frontTokenBalanceLedger_[_customerAddress];\n', '\n', '    if (_tokens > 0) sell(_tokens);\n', '\n', '    withdraw(_customerAddress);\n', '  }\n', '\n', '  function withdraw(address _recipient)\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Setup data\n', '    address _customerAddress = msg.sender;\n', '    uint _dividends = myDividends(false);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    if (_recipient == address(0x0)) {\n', '      _recipient = msg.sender;\n', '    }\n', '    _recipient.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_recipient, _dividends);\n', '  }\n', '\n', '  // Sells front-end tokens.\n', '  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\n', '  function sell(uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  {\n', "    // No selling during the ICO. You don't get to flip that fast, sorry!\n", '    require(!icoPhase);\n', '    require(regularPhase);\n', '\n', '    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '\n', '    uint _frontEndTokensToBurn = _amountOfTokens;\n', '\n', '    // Calculate how many dividend tokens this action burns.\n', "    // Computed as the caller's average dividend rate multiplied by the number of front-end tokens held.\n", '    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n', '    uint userDivRate = getUserAverageDividendRate(msg.sender);\n', '    require((2 * magnitude) <= userDivRate && (50 * magnitude) >= userDivRate);\n', '    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n', '\n', '    // Calculate ethereum received before dividends\n', '    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\n', '\n', '    if (_ethereum > currentEthInvested) {\n', "      // Well, congratulations, you've emptied the coffers.\n", '      currentEthInvested = 0;\n', '    } else {currentEthInvested = currentEthInvested - _ethereum;}\n', '\n', '    // Calculate dividends generated from the sale.\n', '    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n', '\n', '    // Calculate Ethereum receivable net of dividends.\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '\n', '    // Burn the sold tokens (both front-end and back-end variants).\n', '    tokenSupply = tokenSupply.sub(_frontEndTokensToBurn);\n', '    divTokenSupply = divTokenSupply.sub(_divTokensToBurn);\n', '\n', '    // Subtract the token balances for the seller\n', '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n', '\n', '    // Update dividends tracker\n', '    int256 _updatedPayouts = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\n', '    payoutsTo_[msg.sender] -= _updatedPayouts;\n', '\n', "    // Let's avoid breaking arithmetic where we can, eh?\n", '    if (divTokenSupply > 0) {\n', '      // Update the value of each remaining back-end dividend token.\n', '      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder.\n', "   * No charge incurred for the transfer. We'd make a terrible bank.\n", '   */\n', '  function transfer(address _toAddress, uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  returns (bool)\n', '  {\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '    bytes memory empty;\n', '    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    allowed[_customerAddress][spender] = tokens;\n', '\n', '    // Fire logging event.\n', '    emit Approval(_customerAddress, spender, tokens);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n', "   * No charge incurred for the transfer. No seriously, we'd make a terrible bank.\n", '   */\n', '  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    // Setup variables\n', '    address _customerAddress = _from;\n', '    bytes memory empty;\n', "    // Make sure we own the tokens we're transferring, are ALLOWED to transfer that many tokens,\n", '    // and are transferring at least one full token.\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\n', '    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n', '\n', '    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '\n', '  }\n', '\n', '  function transferTo(address _from, address _to, uint _amountOfTokens, bytes _data)\n', '  public\n', '  {\n', '    if (_from != msg.sender) {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\n', '      && _amountOfTokens <= allowed[_from][msg.sender]);\n', '    }\n', '    else {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n', '    }\n', '\n', '    transferFromInternal(_from, _to, _amountOfTokens, _data);\n', '  }\n', '\n', "  // Who'd have thought we'd need this thing floating around?\n", '  function totalSupply()\n', '  public\n', '  view\n', '  returns (uint256)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\n', '  // In case the devs die. Or something.\n', '  function publicStartRegularPhase()\n', '  public\n', '  {\n', '    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\n', '\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '\n', '  // Fire the starting gun and then duck for cover.\n', '  function startICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // Prevent us from startaring the ICO phase again\n', '    require(icoOpenTime == 0);\n', '    icoPhase = true;\n', '    icoOpenTime = now;\n', '  }\n', '\n', '  // Fire the ... ending gun?\n', '  function endICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    icoPhase = false;\n', '  }\n', '\n', '  function startRegularPhase()\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    // disable ico phase in case if that was not disabled yet\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  // The death of a great man demands the birth of a great son.\n', '  function setAdministrator(address _newAdmin, bool _status)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    administrators[_newAdmin] = _status;\n', '  }\n', '\n', '  function setStakingRequirement(uint _amountOfTokens)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // This plane only goes one way, lads. Never below the initial.\n', '    require(_amountOfTokens >= 100e18);\n', '    stakingRequirement = _amountOfTokens;\n', '  }\n', '\n', '  function setName(string _name)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    name = _name;\n', '  }\n', '\n', '  function setSymbol(string _symbol)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    symbol = _symbol;\n', '  }\n', '\n', '  function changeBankroll(address _newBankrollAddress)\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    bankrollAddress = _newBankrollAddress;\n', '  }\n', '\n', '  /*----------  HELPERS AND CALCULATORS  ----------*/\n', '\n', '  function totalEthereumBalance()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function totalEthereumICOReceived()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return ethInvestedDuringICO;\n', '  }\n', '\n', '  /**\n', '   * Retrieves your currently selected dividend rate.\n', '   */\n', '  function getMyDividendRate()\n', '  public\n', '  view\n', '  returns (uint8)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    return userDividendRate[_customerAddress];\n', '  }\n', '\n', '  /**\n', '   * Retrieve the total frontend token supply\n', '   */\n', '  function getFrontEndTokenSupply()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retreive the total dividend token supply\n', '   */\n', '  function getDividendTokenSupply()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return divTokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retrieve the frontend tokens owned by the caller\n', '   */\n', '  function myFrontEndTokens()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getFrontEndTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  /**\n', '   * Retrieve the dividend tokens owned by the caller\n', '   */\n', '  function myDividendTokens()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getDividendTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  function myReferralDividends()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return myDividends(true) - myDividends(false);\n', '  }\n', '\n', '  function myDividends(bool _includeReferralBonus)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function getFrontEndTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return frontTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return getFrontEndTokenBalanceOf(_owner);\n', '  }\n', '\n', '  function getDividendTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return dividendTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function dividendsOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns (uint)\n', '  {\n', '    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '  }\n', '\n', "  // Get the sell price at the user's average dividend rate\n", '  function sellPrice()\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', "    // Factor in the user's average dividend rate\n", '    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n', '\n', '    return theSellPrice;\n', '  }\n', '\n', '  // Get the buy price at a particular dividend rate\n', '  function buyPrice(uint dividendRate)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', "    // Factor in the user's selected dividend rate\n", '    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n', '\n', '    return theBuyPrice;\n', '  }\n', '\n', '  function calculateTokensReceived(uint _ethereumToSpend)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    uint _dividends = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\n', '    uint _taxedEthereum = _ethereumToSpend.sub(_dividends);\n', '    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '    return _amountOfTokens;\n', '  }\n', '\n', "  // When selling tokens, we need to calculate the user's current dividend rate.\n", '  // This is different from their selected dividend rate.\n', '  function calculateEthereumReceived(uint _tokensToSell)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_tokensToSell <= tokenSupply);\n', '    uint _ethereum = tokensToEthereum_(_tokensToSell);\n', '    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n', '    uint _dividends = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '    return _taxedEthereum;\n', '  }\n', '\n', '  /*\n', "   * Get's a user's average dividend rate - which is just their divTokenBalance / tokenBalance\n", '   * We multiply by magnitude to avoid precision errors.\n', '   */\n', '\n', '  function getUserAverageDividendRate(address user) public view returns (uint) {\n', '    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n', '  }\n', '\n', '  function getMyAverageDividendRate() public view returns (uint) {\n', '    return getUserAverageDividendRate(msg.sender);\n', '  }\n', '\n', '  /*==========================================\n', '  =            INTERNAL FUNCTIONS            =\n', '  ==========================================*/\n', '\n', '  /* Purchase tokens with Ether.\n', '     During ICO phase, dividends should go to the bankroll\n', '     During normal operation:\n', '       0.5% should go to the master dividend card\n', '       0.5% should go to the matching dividend card\n', '       25% of dividends should go to the referrer, if any is provided. */\n', '  function purchaseTokens(uint _incomingEthereum, address _referredBy)\n', '  internal\n', '  returns (uint)\n', '  {\n', '    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, "Tried to buy below the min eth buyin threshold.");\n', '\n', '    uint toBankRoll;\n', '    uint toReferrer;\n', '    uint toTokenHolders;\n', '    uint toDivCardHolders;\n', '\n', '    uint dividendAmount;\n', '\n', '    uint tokensBought;\n', '    uint dividendTokensBought;\n', '\n', '    uint remainingEth = _incomingEthereum;\n', '\n', '    uint fee;\n', '\n', '    // 1% for dividend card holders is taken off before anything else\n', '    if (regularPhase) {\n', '      toDivCardHolders = _incomingEthereum.div(100);\n', '      remainingEth = remainingEth.sub(toDivCardHolders);\n', '    }\n', '\n', '    /* Next, we tax for dividends:\n', '       Dividends = (ethereum * div%) / 100\n', "       Important note: if we're out of the ICO phase, the 1% sent to div-card holders\n", '                       is handled prior to any dividend taxes are considered. */\n', '\n', "    // Grab the user's dividend rate\n", '    uint dividendRate = userDividendRate[msg.sender];\n', '\n', '    // Calculate the total dividends on this buy\n', '    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\n', '\n', '    remainingEth = remainingEth.sub(dividendAmount);\n', '\n', "    // If we're in the ICO and bankroll is buying, don't tax\n", '    if (icoPhase && msg.sender == bankrollAddress) {\n', '      remainingEth = remainingEth + dividendAmount;\n', '    }\n', '\n', '    // Calculate how many tokens to buy:\n', '    tokensBought = ethereumToTokens_(remainingEth);\n', '    dividendTokensBought = tokensBought.mul(dividendRate);\n', '\n', '    // This is where we actually mint tokens:\n', '    tokenSupply = tokenSupply.add(tokensBought);\n', '    divTokenSupply = divTokenSupply.add(dividendTokensBought);\n', '\n', '    /* Update the total investment tracker\n', '       Note that this must be done AFTER we calculate how many tokens are bought -\n', '       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\n', '\n', '    currentEthInvested = currentEthInvested + remainingEth;\n', '\n', '    // If ICO phase, all the dividends go to the bankroll\n', '    if (icoPhase) {\n', '      toBankRoll = dividendAmount;\n', '\n', "      // If the bankroll is buying, we don't want to send eth back to the bankroll\n", "      // Instead, let's just give it the tokens it would get in an infinite recursive buy\n", '      if (msg.sender == bankrollAddress) {\n', '        toBankRoll = 0;\n', '      }\n', '\n', '      toReferrer = 0;\n', '      toTokenHolders = 0;\n', '\n', '      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\n', '         not how much Ether we get total.\n', '         this is so that our calculation using "investment" is accurate. */\n', '      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\n', '      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\n', '\n', '      // Cannot purchase more than the hard cap during ICO.\n', '      require(ethInvestedDuringICO <= icoHardCap);\n', "      // Contracts aren't allowed to participate in the ICO.\n", '      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\n', '\n', '      // Cannot purchase more then the limit per address during the ICO.\n', '      ICOBuyIn[msg.sender] += remainingEth;\n', '      //require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress); // test:remove\n', '\n', '      // Stop the ICO phase if we reach the hard cap\n', '      if (ethInvestedDuringICO == icoHardCap) {\n', '        icoPhase = false;\n', '      }\n', '\n', '    } else {\n', '      // Not ICO phase, check for referrals\n', '\n', '      // 25% goes to referrers, if set\n', '      // toReferrer = (dividends * 25)/100\n', '      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '      _referredBy != msg.sender &&\n', '      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\n', '      {\n', '        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n', '        referralBalance_[_referredBy] += toReferrer;\n', '        emit Referral(_referredBy, toReferrer);\n', '      }\n', '\n', '      // The rest of the dividends go to token holders\n', '      toTokenHolders = dividendAmount.sub(toReferrer);\n', '\n', '      fee = toTokenHolders * magnitude;\n', '      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\n', '\n', '      // Finally, increase the divToken value\n', '      profitPerDivToken = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n', '      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\n', '    }\n', '\n', "    // Update the buyer's token amounts\n", '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\n', '\n', '    // Transfer to bankroll and div cards\n', '    if (toBankRoll != 0) {ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)();}\n', '    if (regularPhase) {divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate);}\n', '\n', '    // This event should help us track where all the eth is going\n', '    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\n', '\n', '    // Sanity checking\n', '    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\n', '    assert(sum == 0);\n', '  }\n', '\n', '  // How many tokens one gets from a certain amount of ethereum.\n', '  function ethereumToTokens_(uint _ethereumAmount)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_ethereumAmount > MIN_ETH_BUYIN, "Tried to buy tokens with too little eth.");\n', '\n', '    if (icoPhase) {\n', '      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\n', '    }\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the buy into two segments:\n', '    //  1) the amount of eth going towards ico-price tokens\n', '    //  2) the amount of eth going towards pyramid-price (variable) tokens\n', '    uint ethTowardsICOPriceTokens = 0;\n', '    uint ethTowardsVariablePriceTokens = 0;\n', '\n', '    if (currentEthInvested >= ethInvestedDuringICO) {\n', '      // Option One: All the ETH goes towards variable-price tokens\n', '      ethTowardsVariablePriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\n', '      // Option Two: All the ETH goes towards ICO-price tokens\n', '      ethTowardsICOPriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\n', '      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\n', '      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\n', '      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\n', '    } else {\n', '      // Option Four: Should be impossible, and compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\n', '\n', '    // Separate out the number of tokens of each type this will buy:\n', '    uint icoPriceTokens = 0;\n', '    uint varPriceTokens = 0;\n', '\n', '    // Now calculate each one per the above formulas.\n', '    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\n', '    if (ethTowardsICOPriceTokens != 0) {\n', '      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\n', '    }\n', '\n', '    if (ethTowardsVariablePriceTokens != 0) {\n', '      // Note: we can\'t use "currentEthInvested" for this calculation, we must use:\n', '      //  currentEthInvested + ethTowardsICOPriceTokens\n', '      // This is because a split-buy essentially needs to simulate two separate buys -\n', '      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\n', '\n', '      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\n', '      uint simulatedEthAfterInvested = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\n', '\n', '      /* We have the equations for total tokens above; note that this is for TOTAL.\n', '         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\n', '         and the simulatedEthInvestedAfter and calculate the difference in tokens.\n', '         This is how many we get. */\n', '\n', '      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '      uint tokensAfter = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '\n', '      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\n', '         either should work.\n', '\n', '         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n', '         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n', '\n', '      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n', '    }\n', '\n', '    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\n', '\n', '    assert(totalTokensReceived > 0);\n', '    return totalTokensReceived;\n', '  }\n', '\n', '  // How much Ether we get from selling N tokens\n', '  function tokensToEthereum_(uint _tokens)\n', '  public\n', '  view\n', '  returns (uint)\n', '  {\n', '    require(_tokens >= MIN_TOKEN_SELL_AMOUNT, "Tried to sell too few tokens.");\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the sell into two segments:\n', '    //  1) the amount of tokens selling at the ICO price.\n', '    //  2) the amount of tokens selling at the variable (pyramid) price\n', '    uint tokensToSellAtICOPrice = 0;\n', '    uint tokensToSellAtVariablePrice = 0;\n', '\n', '    if (tokenSupply <= tokensMintedDuringICO) {\n', '      // Option One: All the tokens sell at the ICO price.\n', '      tokensToSellAtICOPrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\n', '      // Option Two: All the tokens sell at the variable price.\n', '      tokensToSellAtVariablePrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\n', '      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\n', '      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\n', '      tokensToSellAtICOPrice = _tokens.sub(tokensToSellAtVariablePrice);\n', '\n', '    } else {\n', '      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\n', '\n', '    // Track how much Ether we get from selling at each price function:\n', '    uint ethFromICOPriceTokens;\n', '    uint ethFromVarPriceTokens;\n', '\n', '    // Now, actually calculate:\n', '\n', '    if (tokensToSellAtICOPrice != 0) {\n', '\n', "      /* Here, unlike the sister equation in ethereumToTokens, we DON'T need to multiply by 1e18, since\n", "         we will be passed in an amount of tokens to sell that's already at the 18-decimal precision.\n", "         We need to divide by 1e18 or we'll have too much Ether. */\n", '\n', '      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\n', '    }\n', '\n', '    if (tokensToSellAtVariablePrice != 0) {\n', '\n', '      /* Note: Unlike the sister function in ethereumToTokens, we don\'t have to calculate any "virtual" token count.\n', '         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\n', "         Thus there isn't any weird stuff going on with the token supply.\n", '\n', '         We have the equations for total investment above; note that this is for TOTAL.\n', '         To get the eth received from this sell, we calculate the new total investment after this sell.\n', '         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\n', '\n', '      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint investmentAfter = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '\n', '      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n', '    }\n', '\n', '    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\n', '\n', '    assert(totalEthReceived > 0);\n', '    return totalEthReceived;\n', '  }\n', '\n', '  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n', '  internal\n', '  {\n', '    require(regularPhase);\n', '    require(_toAddress != address(0x0));\n', '    address _customerAddress = _from;\n', '    uint _amountOfFrontEndTokens = _amountOfTokens;\n', '\n', '    // Withdraw all outstanding dividends first (including those generated from referrals).\n', '    if (theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n', '\n', '    // Calculate how many back-end dividend tokens to transfer.\n', "    // This amount is proportional to the caller's average dividend rate multiplied by the proportion of tokens being transferred.\n", '    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n', '\n', '    if (_customerAddress != msg.sender) {\n', '      // Update the allowed balance.\n', "      // Don't update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n", '      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n', '    }\n', '\n', '    // Exchange tokens\n', '    frontTokenBalanceLedger_[_customerAddress] = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n', '    frontTokenBalanceLedger_[_toAddress] = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n', '    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n', '    dividendTokenBalanceLedger_[_toAddress] = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n', '\n', '    // Recipient inherits dividend percentage if they have not already selected one.\n', '    if (!userSelectedRate[_toAddress])\n', '    {\n', '      userSelectedRate[_toAddress] = true;\n', '      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n', '    }\n', '\n', '    // Update dividend trackers\n', '    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\n', '    payoutsTo_[_toAddress] += (int256) (profitPerDivToken * _amountOfDivTokens);\n', '\n', '    uint length;\n', '\n', '    assembly {\n', '      length := extcodesize(_toAddress)\n', '    }\n', '\n', '    if (length > 0) {\n', '      // its a contract\n', '      // note: at ethereum update ALL addresses are contracts\n', '      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n', '      receiver.tokenFallback(_from, _amountOfTokens, _data);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n', '  }\n', '\n', '  // Called from transferFrom. Always checks if _customerAddress has dividends.\n', '  function withdrawFrom(address _customerAddress)\n', '  internal\n', '  {\n', '    // Setup data\n', '    uint _dividends = theDividendsOf(false, _customerAddress);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    _customerAddress.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_customerAddress, _dividends);\n', '  }\n', '\n', '\n', '  /*=======================\n', '   =    RESET FUNCTIONS   =\n', '   ======================*/\n', '\n', '  function injectEther()\n', '  public\n', '  payable\n', '  onlyAdministrator\n', '  {\n', '\n', '  }\n', '\n', '  /*=======================\n', '   =   MATHS FUNCTIONS    =\n', '   ======================*/\n', '\n', '  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\n', '    // m = 3, n = 2\n', '    // sqrt(x^3)\n', '    return sqrt(x ** 3);\n', '  }\n', '\n', '  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\n', '    // m = 2, n = 3\n', '    // cbrt(x^2)\n', '    return cbrt(x ** 2);\n', '  }\n', '\n', '  function sqrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / z + z) / 2;\n', '    }\n', '  }\n', '\n', '  function cbrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 3;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / (z * z) + 2 * z) / 3;\n', '    }\n', '  }\n', '}\n', '\n', '/*=======================\n', ' =     INTERFACES       =\n', ' ======================*/\n', '\n', 'contract ZethrBankroll {\n', '  function receiveDividends() public payable {}\n', '}\n', '\n', '// File: contracts/Games/JackpotHolding.sol\n', '\n', '/*\n', '*\n', '* Jackpot holding contract.\n', '*  \n', '* This accepts token payouts from a game for every player loss,\n', '* and on a win, pays out *half* of the jackpot to the winner.\n', '*\n', '* Jackpot payout should only be called from the game.\n', '*\n', '*/\n', 'contract JackpotHolding is ERC223Receiving {\n', '\n', '  /****************************\n', '   * FIELDS\n', '   ****************************/\n', '\n', "  // How many times we've paid out the jackpot\n", '  uint public payOutNumber = 0;\n', '\n', '  // The amount to divide the token balance by for a pay out (defaults to half the token balance)\n', '  uint public payOutDivisor = 2;\n', '\n', '  // Holds the bankroll controller info\n', '  ZethrBankrollControllerInterface controller;\n', '\n', '  // Zethr contract\n', '  Zethr zethr;\n', '\n', '  /****************************\n', '   * CONSTRUCTOR\n', '   ****************************/\n', '\n', '  constructor (address _controllerAddress, address _zethrAddress) public {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '    zethr = Zethr(_zethrAddress);\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes/*_data*/)\n', '  public\n', '  returns (bool)\n', '  {\n', '    // Do nothing, we can track the jackpot by this balance\n', '  }\n', '\n', '  /****************************\n', '   * VIEWS\n', '   ****************************/\n', '  function getJackpotBalance()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    // Half of this balance + half of jackpotBalance in each token bankroll\n', '    uint tempBalance;\n', '\n', '    for (uint i=0; i<7; i++) {\n', '      tempBalance += controller.tokenBankrolls(i).jackpotBalance() > 0 ? controller.tokenBankrolls(i).jackpotBalance() / payOutDivisor : 0;\n', '    }\n', '\n', '    tempBalance += zethr.balanceOf(address(this)) > 0 ? zethr.balanceOf(address(this)) / payOutDivisor : 0;\n', '\n', '    return tempBalance;\n', '  }\n', '\n', '  /****************************\n', '   * OWNER FUNCTIONS\n', '   ****************************/\n', '\n', '  /** @dev Sets the pay out divisor\n', '    * @param _divisor The value to set the new divisor to\n', '    */\n', '  function ownerSetPayOutDivisor(uint _divisor)\n', '  public\n', '  ownerOnly\n', '  {\n', '    require(_divisor != 0);\n', '\n', '    payOutDivisor = _divisor;\n', '  }\n', '\n', '  /** @dev Sets the address of the game controller\n', '    * @param _controllerAddress The new address of the controller\n', '    */\n', '  function ownerSetControllerAddress(address _controllerAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '  }\n', '\n', '  /** @dev Transfers the jackpot to _to\n', '    * @param _to Address to send the jackpot tokens to\n', '    */\n', '  function ownerWithdrawZth(address _to)\n', '  public\n', '  ownerOnly\n', '  {\n', '    uint balance = zethr.balanceOf(address(this));\n', '    zethr.transfer(_to, balance);\n', '  }\n', '\n', '  /** @dev Transfers any ETH received from dividends to _to\n', '    * @param _to Address to send the ETH to\n', '    */\n', '  function ownerWithdrawEth(address _to)\n', '  public\n', '  ownerOnly\n', '  {\n', '    _to.transfer(address(this).balance);\n', '  }\n', '\n', '  /****************************\n', '   * GAME FUNCTIONS\n', '   ****************************/\n', '\n', '  function gamePayOutWinner(address _winner)\n', '  public\n', '  gameOnly\n', '  {\n', '    // Call the payout function on all 7 token bankrolls\n', '    for (uint i=0; i<7; i++) {\n', '      controller.tokenBankrolls(i).payJackpotToWinner(_winner, payOutDivisor);\n', '    }\n', '\n', '    uint payOutAmount;\n', '\n', '    // Calculate pay out & pay out\n', '    if (zethr.balanceOf(address(this)) >= 1e10) {\n', '      payOutAmount = zethr.balanceOf(address(this)) / payOutDivisor;\n', '    }\n', '\n', '    if (payOutAmount >= 1e10) {\n', '      zethr.transfer(_winner, payOutAmount);\n', '    }\n', '\n', '    // Increment the statistics fields\n', '    payOutNumber += 1;\n', '\n', '    // Emit jackpot event\n', '    emit JackpotPayOut(_winner, payOutNumber);\n', '  }\n', '\n', '  /****************************\n', '   * EVENTS\n', '   ****************************/\n', '\n', '  event JackpotPayOut(\n', '    address winner,\n', '    uint payOutNumber\n', '  );\n', '\n', '  /****************************\n', '   * MODIFIERS\n', '   ****************************/\n', '\n', '  // Only an owner can call this method (controller is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // Only a game can call this method\n', '  modifier gameOnly()\n', '  {\n', '    require(controller.validGameAddresses(msg.sender));\n', '    _;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/ZethrGame.sol\n', '\n', '/* Zethr Game Interface\n', ' *\n', ' * Contains the necessary functions to integrate with\n', ' * the Zethr Token bankrolls & the Zethr game ecosystem.\n', ' *\n', ' * Token Bankroll Functions:\n', ' *  - execute\n', ' *\n', ' * Player Functions:\n', ' *  - finish\n', ' *\n', ' * Bankroll Controller / Owner Functions:\n', ' *  - pauseGame\n', ' *  - resumeGame\n', ' *  - set resolver percentage\n', ' *  - set controller address\n', ' *\n', ' * Player/Token Bankroll Functions:\n', ' *  - resolvePendingBets\n', '*/\n', 'contract ZethrGame {\n', '  using SafeMath for uint;\n', '  using SafeMath for uint56;\n', '\n', '  // Default events:\n', '  event Result (address player, uint amountWagered, int amountOffset);\n', '  event Wager (address player, uint amount, bytes data);\n', '\n', '  // Queue of pending/unresolved bets\n', '  address[] pendingBetsQueue;\n', '  uint queueHead = 0;\n', '  uint queueTail = 0;\n', '\n', "  // Store each player's latest bet via mapping\n", '  mapping(address => BetBase) bets;\n', '\n', '  // Bet structures must start with this layout\n', '  struct BetBase {\n', '    // Must contain these in this order\n', '    uint56 tokenValue;    // Multiply by 1e14 to get tokens\n', '    uint48 blockNumber;\n', '    uint8 tier;\n', '    // Game specific structures can add more after this\n', '  }\n', '\n', '  // Mapping of addresses to their *position* in the queue\n', "  // Zero = they aren't in the queue\n", '  mapping(address => uint) pendingBetsMapping;\n', '\n', '  // Holds the bankroll controller info\n', '  ZethrBankrollControllerInterface controller;\n', '\n', '  // Is the game paused?\n', '  bool paused;\n', '\n', '  // Minimum bet should always be >= 1\n', '  uint minBet = 1e18;\n', '\n', '  // Percentage that a resolver gets when he resolves bets for the house\n', '  uint resolverPercentage;\n', '\n', '  // Every game has a name\n', '  string gameName;\n', '\n', '  constructor (address _controllerAddress, uint _resolverPercentage, string _name) public {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '    resolverPercentage = _resolverPercentage;\n', '    gameName = _name;\n', '  }\n', '\n', '  /** @dev Gets the max profit of this game as decided by the token bankroll\n', '    * @return uint The maximum profit\n', '    */\n', '  function getMaxProfit()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    return ZethrTokenBankrollInterface(msg.sender).getMaxProfit(address(this));\n', '  }\n', '\n', '  /** @dev Pauses the game, preventing anyone from placing bets\n', '    */\n', '  function ownerPauseGame()\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = true;\n', '  }\n', '\n', '  /** @dev Resumes the game, allowing bets\n', '    */\n', '  function ownerResumeGame()\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = false;\n', '  }\n', '\n', '  /** @dev Sets the percentage of the bets that a resolver gets when resolving tokens.\n', '    * @param _percentage The percentage as x/1,000,000 that the resolver gets\n', '    */\n', '  function ownerSetResolverPercentage(uint _percentage)\n', '  public\n', '  ownerOnly\n', '  {\n', '    require(_percentage <= 1000000);\n', '    resolverPercentage = _percentage;\n', '  }\n', '\n', '  /** @dev Sets the address of the game controller\n', '    * @param _controllerAddress The new address of the controller\n', '    */\n', '  function ownerSetControllerAddress(address _controllerAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    controller = ZethrBankrollControllerInterface(_controllerAddress);\n', '  }\n', '\n', '  // Every game should have a name\n', '  /** @dev Sets the name of the game\n', '    * @param _name The name of the game\n', '    */\n', '  function ownerSetGameName(string _name)\n', '  ownerOnly\n', '  public\n', '  {\n', '    gameName = _name;\n', '  }\n', '\n', '  /** @dev Gets the game name\n', '    * @return The name of the game\n', '    */\n', '  function getGameName()\n', '  public view\n', '  returns (string)\n', '  {\n', '    return gameName;\n', '  }\n', '\n', '  /** @dev Resolve expired bets in the queue. Gives a percentage of the house edge to the resolver as ZTH\n', '    * @param _numToResolve The number of bets to resolve.\n', '    * @return tokensEarned The number of tokens earned\n', '    * @return queueHead The new head of the queue\n', '    */\n', '  function resolveExpiredBets(uint _numToResolve)\n', '  public\n', '  returns (uint tokensEarned_, uint queueHead_)\n', '  {\n', '    uint mQueue = queueHead;\n', '    uint head;\n', '    uint tail = (mQueue + _numToResolve) > pendingBetsQueue.length ? pendingBetsQueue.length : (mQueue + _numToResolve);\n', '    uint tokensEarned = 0;\n', '\n', '    for (head = mQueue; head < tail; head++) {\n', '      // Check the head of the queue to see if there is a resolvable bet\n', '      // This means the bet at the queue head is older than 255 blocks AND is not 0\n', "      // (However, if the address at the head is null, skip it, it's already been resolved)\n", '      if (pendingBetsQueue[head] == address(0x0)) {\n', '        continue;\n', '      }\n', '\n', '      if (bets[pendingBetsQueue[head]].blockNumber != 0 && block.number > 256 + bets[pendingBetsQueue[head]].blockNumber) {\n', '        // Resolve the bet\n', '        // finishBetfrom returns the *player* profit\n', '        // this will be negative if the player lost and the house won\n', '        // so flip it to get the house profit, if any\n', '        int sum = - finishBetFrom(pendingBetsQueue[head]);\n', '\n', '        // Tokens earned is a percentage of the loss\n', '        if (sum > 0) {\n', '          tokensEarned += (uint(sum).mul(resolverPercentage)).div(1000000);\n', '        }\n', '\n', '        // Queue-tail is always the "next" open spot, so queue head and tail will never overlap\n', '      } else {\n', "        // If we can't resolve a bet, stop going down the queue\n", '        break;\n', '      }\n', '    }\n', '\n', '    queueHead = head;\n', '\n', '    // Send the earned tokens to the resolver\n', '    if (tokensEarned >= 1e14) {\n', '      controller.gamePayoutResolver(msg.sender, tokensEarned);\n', '    }\n', '\n', '    return (tokensEarned, head);\n', '  }\n', '\n', '  /** @dev Finishes the bet of the sender, if it exists.\n', '    * @return int The total profit (positive or negative) earned by the sender\n', '    */\n', '  function finishBet()\n', '  public\n', '  hasNotBetThisBlock(msg.sender)\n', '  returns (int)\n', '  {\n', '    return finishBetFrom(msg.sender);\n', '  }\n', '\n', '  /** @dev Resturns a random number\n', '    * @param _blockn The block number to base the random number off of\n', '    * @param _entropy Data to use in the random generation\n', '    * @param _index Data to use in the random generation\n', '    * @return randomNumber The random number to return\n', '    */\n', '  function maxRandom(uint _blockn, address _entropy, uint _index)\n', '  private view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(_blockn),\n', '          _entropy,\n', '          _index\n', '        )));\n', '  }\n', '\n', '  /** @dev Returns a random number\n', '    * @param _upper The upper end of the range, exclusive\n', '    * @param _blockn The block number to use for the random number\n', '    * @param _entropy An address to be used for entropy\n', '    * @param _index A number to get the next random number\n', '    * @return randomNumber The random number\n', '    */\n', '  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\n', '  internal view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(_blockn, _entropy, _index) % _upper;\n', '  }\n', '\n', '  // Prevents the user from placing two bets in one block\n', '  modifier hasNotBetThisBlock(address _sender)\n', '  {\n', '    require(bets[_sender].blockNumber != block.number);\n', '    _;\n', '  }\n', '\n', '  // Requires that msg.sender is one of the token bankrolls\n', '  modifier bankrollOnly {\n', '    require(controller.isTokenBankroll(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // Requires that the game is not paused\n', '  modifier isNotPaused {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  // Requires that the bet given has max profit low enough\n', '  modifier betIsValid(uint _betSize, uint _tier, bytes _data) {\n', '    uint divRate = ZethrTierLibrary.getDivRate(_tier);\n', '    require(isBetValid(_betSize, divRate, _data));\n', '    _;\n', '  }\n', '\n', '  // Only an owner can call this method (controller is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\n', '    _;\n', '  }\n', '\n', '  /** @dev Places a bet. Callable only by token bankrolls\n', '    * @param _player The player that is placing the bet\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _divRate The dividend rate of the player\n', '    * @param _data The game-specific data, encoded in bytes-form\n', '    */\n', '  function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;\n', '\n', '  /** @dev Resolves the bet of the supplied player.\n', '    * @param _playerAddress The address of the player whos bet we are resolving\n', '    * @return int The total profit the player earned, positive or negative\n', '    */\n', '  function finishBetFrom(address _playerAddress) internal returns (int);\n', '\n', '  /** @dev Determines if a supplied bet is valid\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _divRate The dividend rate of the bet\n', '    * @param _data The game-specific bet data\n', '    * @return bool Whether or not the bet is valid\n', '    */\n', '  function isBetValid(uint _tokenCount, uint _divRate, bytes _data) public view returns (bool);\n', '}\n', '\n', '// File: contracts/Games/ZethrSlots.sol\n', '\n', '/* The actual game contract.\n', ' *\n', ' * This contract contains the actual game logic,\n', ' * including placing bets (execute), resolving bets,\n', ' * and resolving expired bets.\n', '*/\n', 'contract ZethrSlots is ZethrGame {\n', '\n', '  /****************************\n', '   * GAME SPECIFIC\n', '   ****************************/\n', '\n', '  // Slots-specific bet structure\n', '  struct Bet {\n', '    // Must contain these in this order\n', '    uint56 tokenValue;\n', '    uint48 blockNumber;\n', '    uint8 tier;\n', '    // Game specific\n', '    uint8 numSpins;\n', '  }\n', '\n', '  /****************************\n', '   * FIELDS\n', '   ****************************/\n', '\n', '  // Sections with identical multipliers compressed for optimization\n', '  uint[14] MULTIPLIER_BOUNDARIES = [uint(299), 3128, 44627, 46627, 49127, 51627, 53127, 82530, 150423, 310818, 364283, 417748, 471213, ~uint256(0)];\n', '\n', '  // Maps indexes of results sections to multipliers as x/100\n', '  uint[14] MULTIPLIERS = [uint(5000), 2000, 300, 1100, 750, 900, 1300, 250, 150, 100, 200, 125, 133, 250];\n', '\n', '  // The holding contract for jackpot tokens\n', '  JackpotHolding public jackpotHoldingContract;\n', '\n', '  /****************************\n', '   * CONSTRUCTOR\n', '   ****************************/\n', '\n', '  constructor (address _controllerAddress, uint _resolverPercentage, string _name)\n', '  ZethrGame(_controllerAddress, _resolverPercentage, _name)\n', '  public\n', '  {\n', '  }\n', '\n', '  /****************************\n', '   * USER METHODS\n', '   ****************************/\n', '\n', '  /** @dev Retrieve the results of the last spin of a plyer, for web3 calls.\n', '    * @param _playerAddress The address of the player\n', '    */\n', '  function getLastSpinOutput(address _playerAddress)\n', '  public view\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint[] memory output)\n', '  {\n', '    // Cast to Bet and read from storage\n', '    Bet storage playerBetInStorage = getBet(_playerAddress);\n', '    Bet memory playerBet = playerBetInStorage;\n', '\n', '    // Safety check\n', '    require(playerBet.blockNumber != 0);\n', '\n', '    (winAmount, lossAmount, jackpotAmount, jackpotWins, output) = getSpinOutput(playerBet.blockNumber, playerBet.numSpins, playerBet.tokenValue.mul(1e14), _playerAddress);\n', '\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins, output);\n', '  }\n', '    \n', '    event SlotsResult(\n', '        uint    _blockNumber,\n', '        address _target,\n', '        uint    _numSpins,\n', '        uint    _tokenValue,\n', '        uint    _winAmount,\n', '        uint    _lossAmount,\n', '        uint[]  _output\n', '    );\n', '    \n', '  /** @dev Retrieve the results of the spin, for web3 calls.\n', '    * @param _blockNumber The block number of the spin\n', '    * @param _numSpins The number of spins of this bet\n', '    * @param _tokenValue The total number of tokens bet\n', '    * @param _target The address of the better\n', '    * @return winAmount The total number of tokens won\n', '    * @return lossAmount The total number of tokens lost\n', '    * @return jackpotAmount The total amount of tokens won in the jackpot\n', '    * @return output An array of all of the results of a multispin\n', '    */\n', '  function getSpinOutput(uint _blockNumber, uint _numSpins, uint _tokenValue, address _target)\n', '  public view\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint[] memory output)\n', '  {\n', '    output = new uint[](_numSpins);\n', '    // Where the result sections start and stop\n', '\n', '    // If current block for the first spin is older than 255 blocks, ALL spins are losses\n', '    if (block.number - _blockNumber > 255) {\n', '      // Output stays 0 for eveything, this is a loss\n', '      // No jackpot wins\n', '      // No wins\n', '      // Loss is the total tokens bet\n', '      lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);\n', '      jackpotAmount = _tokenValue.mul(_numSpins).div(100);\n', '    } else {\n', '\n', '      for (uint i = 0; i < _numSpins; i++) {\n', '        // Store the output\n', '        output[i] = random(1000000, _blockNumber, _target, i) + 1;\n', '\n', '        if (output[i] < 2) {\n', '          // Jackpot get\n', '          jackpotWins++;\n', '          lossAmount += _tokenValue;\n', '        } else if (output[i] > 506856) {\n', '          // Player loss\n', '          lossAmount += (_tokenValue.mul(99)).div(100);\n', '          jackpotAmount += _tokenValue.div(100);\n', '        } else {\n', '          // Player win\n', '\n', '          // Iterate over the array of win results to find the correct multiplier array index\n', '          uint index;\n', '          for (index = 0; index < MULTIPLIER_BOUNDARIES.length; index++) {\n', '            if (output[i] < MULTIPLIER_BOUNDARIES[index]) break;\n', '          }\n', '          // Use index to find the correct multipliers\n', '          winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);\n', '        }\n', '      }\n', '    }\n', '    emit SlotsResult(_blockNumber, _target, _numSpins, _tokenValue, winAmount, lossAmount, output);\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins, output);\n', '  }\n', '\n', '  /** @dev Retrieve the results of the spin, for contract calls.\n', '    * @param _blockNumber The block number of the spin\n', '    * @param _numSpins The number of spins of this bet\n', '    * @param _tokenValue The total number of tokens bet\n', '    * @param _target The address of the better\n', '    * @return winAmount The total number of tokens won\n', '    * @return lossAmount The total number of tokens lost\n', '    * @return jackpotAmount The total amount of tokens won in the jackpot\n', '    */\n', '  function getSpinResults(uint _blockNumber, uint _numSpins, uint _tokenValue, address _target)\n', '  public\n', '  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins)\n', '  {\n', '    // Where the result sections start and stop\n', '\n', '    // If current block for the first spin is older than 255 blocks, ALL spins are losses\n', '    if (block.number - _blockNumber > 255) {\n', '      // Output stays 0 for eveything, this is a loss\n', '      // No jackpot wins\n', '      // No wins\n', '      // Loss is the total tokens bet\n', '      lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);\n', '      jackpotAmount = _tokenValue.mul(_numSpins).div(100);\n', '    } else {\n', '\n', '      uint result;\n', '\n', '      for (uint i = 0; i < _numSpins; i++) {\n', '        // Store the output\n', '        result = random(1000000, _blockNumber, _target, i) + 1;\n', '\n', '        if (result < 2) {\n', '          // Jackpot get\n', '          jackpotWins++;\n', '        } else if (result > 506856) {\n', '          // Player loss\n', '          lossAmount += (_tokenValue.mul(99)).div(100);\n', '          jackpotAmount += _tokenValue.div(100);\n', '        } else {\n', '          // Player win\n', '\n', '          // Iterate over the array of win results to find the correct multiplier array index\n', '          uint index;\n', '          for (index = 0; index < MULTIPLIER_BOUNDARIES.length; index++) {\n', '            if (result < MULTIPLIER_BOUNDARIES[index]) break;\n', '          }\n', '          // Use index to find the correct multipliers\n', '          winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);\n', '        }\n', '      }\n', '    }\n', '    return (winAmount, lossAmount, jackpotAmount, jackpotWins);\n', '  }\n', '\n', '  /****************************\n', '   * OWNER METHODS\n', '   ****************************/\n', '\n', '  /** @dev Set the address of the jackpot contract\n', '    * @param _jackpotAddress The address of the jackpot contract\n', '    */\n', '  function ownerSetJackpotAddress(address _jackpotAddress)\n', '  public\n', '  ownerOnly\n', '  {\n', '    jackpotHoldingContract = JackpotHolding(_jackpotAddress);\n', '  }\n', '\n', '  /****************************\n', '   * INTERNALS\n', '   ****************************/\n', '\n', '  /** @dev Returs the bet struct of a player\n', '    * @param _playerAddress The address of the player\n', '    * @return Bet The bet of the player\n', '    */\n', '  function getBet(address _playerAddress)\n', '  internal view\n', '  returns (Bet storage)\n', '  {\n', '    // Cast BetBase to Bet\n', '    BetBase storage betBase = bets[_playerAddress];\n', '\n', '    Bet storage playerBet;\n', '    assembly {\n', '    // tmp is pushed onto stack and points to betBase slot in storage\n', '      let tmp := betBase_slot\n', '\n', '    // swap1 swaps tmp and playerBet pointers\n', '      swap1\n', '    }\n', '    // tmp is popped off the stack\n', '\n', '    // playerBet now points to betBase\n', '    return playerBet;\n', '  }\n', '\n', '  /** @dev Resturns a random number\n', '    * @param _blockn The block number to base the random number off of\n', '    * @param _entropy Data to use in the random generation\n', '    * @param _index Data to use in the random generation\n', '    * @return randomNumber The random number to return\n', '    */\n', '  function maxRandom(uint _blockn, address _entropy, uint _index)\n', '  private view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(_blockn),\n', '          _entropy,\n', '          _index\n', '        )));\n', '  }\n', '\n', '  /** @dev Returns a random number\n', '    * @param _upper The upper end of the range, exclusive\n', '    * @param _blockn The block number to use for the random number\n', '    * @param _entropy An address to be used for entropy\n', '    * @param _index A number to get the next random number\n', '    * @return randomNumber The random number\n', '    */\n', '  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\n', '  internal view\n', '  returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(_blockn, _entropy, _index) % _upper;\n', '  }\n', '\n', '  /****************************\n', '   * OVERRIDDEN METHODS\n', '   ****************************/\n', '\n', '  /** @dev Resolves the bet of the supplied player.\n', '    * @param _playerAddress The address of the player whos bet we are resolving\n', '    * @return totalProfit The total profit the player earned, positive or negative\n', '    */\n', '  function finishBetFrom(address _playerAddress)\n', '  internal\n', '  returns (int /*totalProfit*/)\n', '  {\n', '    // Memory vars to hold data as we compute it\n', '    uint winAmount;\n', '    uint lossAmount;\n', '    uint jackpotAmount;\n', '    uint jackpotWins;\n', '\n', '    // Cast to Bet and read from storage\n', '    Bet storage playerBetInStorage = getBet(_playerAddress);\n', '    Bet memory playerBet = playerBetInStorage;\n', '\n', '    // Player should not be able to resolve twice!\n', '    require(playerBet.blockNumber != 0);\n', '\n', '    // Safety check\n', '    require(playerBet.blockNumber != 0);\n', '    playerBetInStorage.blockNumber = 0;\n', '\n', '    // Iterate over the number of spins and calculate totals:\n', '    //  - player win amount\n', '    //  - bankroll win amount\n', '    //  - jackpot wins\n', '    (winAmount, lossAmount, jackpotAmount, jackpotWins) = getSpinResults(playerBet.blockNumber, playerBet.numSpins, playerBet.tokenValue.mul(1e14), _playerAddress);\n', '\n', '    // Figure out the token bankroll address\n', '    address tokenBankrollAddress = controller.getTokenBankrollAddressFromTier(playerBet.tier);\n', '    ZethrTokenBankrollInterface bankroll = ZethrTokenBankrollInterface(tokenBankrollAddress);\n', '\n', '    // Call into the bankroll to do some token accounting\n', '    bankroll.gameTokenResolution(winAmount, _playerAddress, jackpotAmount, address(jackpotHoldingContract), playerBet.tokenValue.mul(1e14).mul(playerBet.numSpins));\n', '\n', '    // Pay out jackpot if won\n', '    if (jackpotWins > 0) {\n', '      for (uint x = 0; x < jackpotWins; x++) {\n', '        jackpotHoldingContract.gamePayOutWinner(_playerAddress);\n', '      }\n', '    }\n', '\n', '    // Grab the position of the player in the pending bets queue\n', '    uint index = pendingBetsMapping[_playerAddress];\n', '\n', '    // Remove the player from the pending bets queue by setting the address to 0x0\n', '    pendingBetsQueue[index] = address(0x0);\n', '\n', "    // Delete the player's bet by setting the mapping to zero\n", '    pendingBetsMapping[_playerAddress] = 0;\n', '\n', '    emit Result(_playerAddress, playerBet.tokenValue.mul(1e14), int(winAmount) - int(lossAmount) - int(jackpotAmount));\n', '\n', '    // Return all bet results + total *player* profit\n', '    return (int(winAmount) - int(lossAmount) - int(jackpotAmount));\n', '  }\n', '\n', '  /** @dev Places a bet. Callable only by token bankrolls\n', '    * @param _player The player that is placing the bet\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _tier The div rate tier the player falls in\n', '    * @param _data The game-specific data, encoded in bytes-form\n', '    */\n', '  function execute(address _player, uint _tokenCount, uint _tier, bytes _data)\n', '  isNotPaused\n', '  bankrollOnly\n', '  betIsValid(_tokenCount, _tier, _data)\n', '  hasNotBetThisBlock(_player)\n', '  public\n', '  {\n', '    Bet storage playerBet = getBet(_player);\n', '\n', '    // Check for a player bet and resolve if necessary\n', '    if (playerBet.blockNumber != 0) {\n', '      finishBetFrom(_player);\n', '    }\n', '\n', '    uint8 spins = uint8(_data[0]);\n', '\n', '    // Set bet information\n', '    playerBet.tokenValue = uint56(_tokenCount.div(spins).div(1e14));\n', '    playerBet.blockNumber = uint48(block.number);\n', '    playerBet.tier = uint8(_tier);\n', '    playerBet.numSpins = spins;\n', '\n', '    // Add player to the pending bets queue\n', '    pendingBetsQueue.length++;\n', '    pendingBetsQueue[queueTail] = _player;\n', '    queueTail++;\n', '\n', "    // Add the player's position in the queue to the pending bets mapping\n", '    pendingBetsMapping[_player] = queueTail - 1;\n', '\n', '    // Emit event\n', '    emit Wager(_player, _tokenCount, _data);\n', '  }\n', '\n', '  /** @dev Determines if a supplied bet is valid\n', '    * @param _tokenCount The total number of tokens bet\n', '    * @param _data The game-specific bet data\n', '    * @return bool Whether or not the bet is valid\n', '    */\n', '  function isBetValid(uint _tokenCount, uint /*_divRate*/, bytes _data)\n', '  public view\n', '  returns (bool)\n', '  {\n', '    // Since the max win is 50x (for slots), the bet size must be\n', '    // <= 1/50 * the maximum profit.\n', '    uint8 spins = uint8(_data[0]);\n', '    return (_tokenCount.div(spins).mul(50) <= getMaxProfit()) && (_tokenCount.div(spins) >= minBet);\n', '  }\n', '}']
