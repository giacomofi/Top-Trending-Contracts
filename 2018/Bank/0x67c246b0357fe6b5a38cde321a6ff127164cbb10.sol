['pragma solidity ^0.4.21;\n', '\n', '// WARNING. The examples used in the formulas in the comments are the right formulas. However, they are not implemented like this to prevent overflows. \n', '// The formulas in the contract do work the same as in the comments. \n', '\n', '// NOTE: In part two of the contract, the DIVIDEND is explained. \n', '// The dividend has a very easy implementation\n', '// the price of the token rise when bought.\n', '// when it&#39;s sold, price will decrease with 50% of rate of price bought\n', '// if you sell, you will sell all tokens, and you have thus to buy in at higher price\n', '// make sure you hold dividend for a long time.\n', '\n', 'contract RobinHood{\n', '    // Owner of this contract\n', '    address public owner;\n', '    \n', '    // % of dev fee (can be set to 0,1,2,3,4,5 %);\n', '    uint8 devFee = 5;\n', '    // Users who want to create their own Robin Hood tower have to pay this. Can be reset to any value.\n', '    uint256 public amountToCreate = 20000000000000000;\n', '    \n', '    // If this is false, you cannot use the contract. It can be opened by owner. After that, it cannot be closed anymore.\n', '    // If it is not open, you cannot interact with the contract.\n', '    bool public open = false;\n', '    \n', '    event TowerCreated(uint256 id);\n', '    event TowerBought(uint256 id);\n', '    event TowerWon(uint256 id);\n', '\n', '    // Tower struct. \n', '    struct Tower{\n', '        //Timer in seconds: Base time for how long the new owner of the Tower has to wait until he can pay the amount.\n', '        uint32 timer; \n', '        // Timestamp: if this is 0, the contract does not run. If it runs it is set to the blockchain timestamp. \n', '        // If Timestamp + GetTime() > Blockchain timestamp the user will be paid out  by the person who tries to buy the tower OR the user can decide to buy himself.\n', '        uint256 timestamp;\n', '        // Payout of the amount in percent. Ranges from 0 - 10000. Here 0 is 0 % and 10000 is 100%.\n', '        // This percentage of amount is paid to owner of tower. \n', '        // The other part of amount stays in Tower and can be collected by new people.\n', '        // However, if the amount is larger or equal than the minPrice, the Tower will immediately change the timestamp and move on.\n', '        // This means that the owner of the tower does not change, and can possibly collect the amount more times, if no one buys!!\n', '        uint16 payout; \n', '        // Price increasate, ranged again from 0-10000 (0 = 0%, 10000 = 100%), which decides how much the price increases if someone buys the tower.\n', '        // Ex: 5000 means that if the price is 1 ETH and if someone buys it, then the new price is 1 * (1 + 5000/10000) = 1.5 ETH.\n', '        uint16 priceIncrease; // priceIncrease in percent (same)\n', '        // Price, which can be checked to see how much the tower costs. Initially set to minPrice.\n', '        uint256 price;\n', '        // Amount which the Tower has to pay to the owner.\n', '        uint256 amount; \n', '        // Min Price: the minimum price in wei. Is also the setting to make the contract move on if someone has been paid (if amount >= minPrice);\n', '        // The minimum price is 1 szabo, maximum price is 1 ether. Both are included in the range.\n', '        uint256 minPrice; \n', '        // If you create a contract (not developer) then you are allowed to set a fee which you will get from people who buy your Tower.\n', '        // Ranged again from 0 -> 10000,  but the maximum value is 2500 (25%) minimum is 0 (0%).\n', '        // Developer is not allowed to set creatorFee.\n', '        uint16 creatorFee; \n', '        // This is the amount, in wei, to set at which amount the time necessary to wait will reduce by half.\n', '        // If this is set to 0, this option is not allowed and the time delta is always the same.\n', '        // The minimum wait time is 5 minutes.\n', '        // The time to wait is calculated by: Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime)\n', '        uint256 amountToHalfTime; \n', '        // If someone wins, the price is reduced by this. The new price is calculated by:\n', '        // Tower.price = max(Tower.price * Tower.minPriceAfterWin/10000, Tower.minPrice);\n', '        // Again, this value is ranged from 0 (0%) to 10000 (100%), all values allowed.\n', '        // Note that price will always be the minimum price or higher.\n', '        // If this is set to 0, price will always be set back to new price.\n', '        // If it is set to 10000, the price will NOT change!\n', '        uint16 minPriceAfterWin; // also in percent. \n', '        // Address of the creator of this tower. Used to pay creatorFee. Developer will not receive creatorFee because his creatorFee is automatically set to 0.\n', '        address creator;\n', '        // The current owner of this Tower. If he owns it for longer than getTime() of this Tower, he will receive his portion of the amount in the Tower.\n', '        address owner;\n', '        // You can add a quote to troll your fellow friends. Hopefully they won&#39;t buy your tower!\n', '        string quote;\n', '    }\n', '    \n', '   \n', '    // Mapping of all towers, indexed by ID. Starting at 0. \n', '    mapping(uint256 => Tower) public Towers;\n', '    \n', '    // Take track of at what position we insert the Tower. \n', '    uint256 public next_tower_index=0;\n', '\n', '    // Check if contract is open. \n', '    // If value is send and contract is not open, it is reverted and you will get it back. \n', '    // Note that if contract is open it cannot be closed anymore.\n', '    modifier onlyOpen(){\n', '        if (open){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Check if owner or if contract is open. This works for the AddTower function so owner (developer) can already add Towers. \n', '    // Note that if contract is open it cannot be closed anymore. \n', '    // If value is send it will be reverted if you are not owner or the contract is not open. \n', '    modifier onlyOpenOrOwner(){\n', '        if (open || msg.sender == owner){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Functions only for owner (developer)\n', '    // If you send something to a owner function you will get your ethers back via revert. \n', '    modifier onlyOwner(){\n', '        if (msg.sender == owner){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    \n', '    // Constructor. \n', '    // Setups 4 towers. \n', '    function RobinHood() public{\n', '        // Log contract developer\n', '        owner = msg.sender;\n', '    \n', '        \n', '        \n', '        // FIRST tower. (ID = 0)\n', '        // Robin Hood has to climb a tower!\n', '        // 10 minutes time range!\n', '        // 90% payout of the amount \n', '        // 30% price increase \n', '        // Timer halfs at 5 ETH. This is a lot, but realize that this high value is choosen because the timer cannot shrink to fast. \n', '        // At 5 ETH the limit is only 5 minutes, the minimum!\n', '        // Minimum price is 2 finney. \n', '        // Price reduces 90% (100% - 10%) after someone has won the tower!\n', '        // 0% creator fee. \n', '       \n', '       \n', '        AddTower(600, 9000, 3000, 5000000000000000000, 2000000000000000, 1000, 0);\n', '    \n', '    \n', '        // SECOND tower (ID = 1)\n', '        // Robin Hood has to search a house!\n', '        // 10 minutes tme range \n', '        // 50% payout \n', '        // 1.5% price increase \n', '        // Timer halfs at 2.5 ETH (also a lot, but at this time then timer is minimum (5 min))\n', '        // Price is 4 finney\n', '        // Price is reduced to 4 finney if won \n', '        // 0% fee \n', '        \n', '        AddTower(600, 5000,150 , 2500000000000000000, 4000000000000000, 0, 0);\n', '  \n', '        // THIRD tower. (ID = 2)\n', '        // Robin Hood has to explore a forest!\n', '        // 1 hour time range!\n', '        // 50% payout of the amount \n', '        // 10% price increase \n', '        // Timer halfs at 1 ETH. \n', '        // Minimum price is 5 finney. \n', '        // Price reduces 50% (100% - 50%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(3600, 5000, 1000, (1000000000000000000), 5000000000000000, 5000, 0);\n', '\n', '        // FOURTH tower. (ID = 3)\n', '        // Robin Hood has to cross a sea to an island!\n', '        // 1 day time range!\n', '        // 75% payout of the amount \n', '        // 20% price increase \n', '        // Timer halfs at 2 ETH.\n', '        // Minimum price is 10 finney. \n', '        // Price reduces 75% (100% - 25%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(86400, 7500, 2000, (2000000000000000000), 10000000000000000, 2500, 0);\n', '         \n', '\n', '  \n', '        // FIFTH tower (ID = 4)\n', '        // Robin Hood has to fly with a rocket to a nearby asteroid!\n', '        // 1 week time range!\n', '        // 75% payout of the amount \n', '        // 25% price increase \n', '        // Timer halfs at 2.5 ETH.\n', '        // Minimum price is 50 finney. \n', '        // Price reduces 100% (100% - 0%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(604800, 7500, 2500, (2500000000000000000), 50000000000000000, 0, 0);\n', '    }\n', '    \n', '    // Developer (owner) can open game \n', '    // Open can only be set true once, can never be set false again. \n', '    function OpenGame() public onlyOwner{\n', '        open = true;\n', '    }\n', '    \n', '    // Developer can change fee. \n', '    // DevFee is only a simple int, so can  be 0,1,2,3,4,5 \n', '    // Fee has to be less or equal to 5, otherwise it is reverted. \n', '    function ChangeFee(uint8 _fee) public onlyOwner{\n', '        require(_fee <= 5);\n', '        devFee = _fee;\n', '    }\n', '    \n', '    // Developer change amount price to add tower. \n', '    function ChangeAmountPrice(uint256 _newPrice) public onlyOwner{\n', '        amountToCreate = _newPrice;\n', '    }\n', '    \n', '    // Add Tower. Only possible if you are developer OR if contract is open. \n', '    // If you want to buy a tower, you have to pay amountToCreate (= wei) to developer. \n', '    // The default value is 0.02 ETH.\n', '    // You can check the price (in wei) either on site or by reading the contract on etherscan.\n', '    \n', '    // _timer: Timer in seconds for how long someone has to wait before he wins the tower. This is constant and will not be changed. \n', '    // If you set _amountToHalfTime to nonzero, getTimer will reduce less amounts (minimum 300 seconds, maximum _timer) from the formula Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) \n', '    // _timer has to be between 300 seconds ( 5 minutes) and maximally 366 days (366*24*60*60) (which is maximally one year);\n', '    \n', '    //_payout: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage of the Tower.amount is paid to Tower.owner if he wins. \n', '    // The rest of the amount of that tower which stays over will be kept inside the tower, up for a new round. \n', '    // If someone wins and amount is more than the minPrice, timestamp is set to the blockchain timer and new round is started without changing the owner of the Tower!\n', '    \n', '    // _priceIncrease: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage the price will increase. Note that "100%" is always added. \n', '    // If you set it at 5000 (which is 50%) then the total increase of price is 150%. So if someone buys tower for price at 1 ETH, the new price is then 1.5 ETH. \n', '    \n', '    // _amountToHalfTime: number of Wei which sets how much Wei you need in order to reduce the time necessary to hold tower to win for 50%.\n', '    // Formula used is Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) to calculate the time necessary.\n', '    // If you set 0, then this formula is not used and Tower.time is always returned.\n', '    // Due to overflows the minimum amount (which is reasonable) is still 1/1000 finney. \n', '    // Do not make this number extremely high. \n', '    \n', '    // _minPrice: amount of Wei which the starting price of the Tower is. Minimum is 1/1000 finney, max is 1 ETH. \n', '    // This is also the check value to see if the round moves on after someone has won. If amount >= minPrice then the timestamp will be upgraded and a new round will start\n', '    // Of course that is after paying the owner of this tower. The owner of the tower does not change. He can win multiple times, in theory. \n', '    \n', '    // _minPriceAfterWin: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. After someone wins, the new price of the game is calculated.\n', '    // This is done by doing Tower.price * (Tower.minPriceAfterWin) / 10000; \n', '    // If Tower.price is now less than Tower.minPrice then the Tower.price will be set to Tower.minPrice.\n', '\n', '    // _creatorFee: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Maximum is 2500 (25%), with 2500 included. \n', '    // If you create a tower, you can set this value. If people pay the tower, then this percentage of the price is taken and is sent to you.\n', '    // The rest, after subtracting the dev fee, will be put into Tower.amount. \n', '    \n', '    function AddTower(uint32 _timer, uint16 _payout, uint16 _priceIncrease, uint256 _amountToHalfTime, uint256 _minPrice, uint16 _minPriceAfterWin, uint16 _creatorFee) public payable onlyOpenOrOwner returns (uint256) {\n', '        require (_timer >= 300); // Need at least 5 minutes\n', '        require (_timer <= 31622400);\n', '        require (_payout >= 0 && _payout <= 10000);\n', '        require (_priceIncrease >= 0 && _priceIncrease <= 10000);\n', '        require (_minPriceAfterWin >= 0 && _minPriceAfterWin <= 10000);\n', '       //amount to half time can be everything, but has to be 0 OR 1000000000000 due to division rules\n', '        require(_amountToHalfTime == 0 || _amountToHalfTime >= 1000000000000);\n', '        require(_creatorFee >= 0 && _creatorFee <= 2500);\n', '        require(_minPrice >= (1 szabo) && _minPrice <= (1 ether));\n', '        if (msg.sender == owner){\n', '            // If owner make sure creator fee is 0.\n', '            _creatorFee = 0;\n', '            if (msg.value > 0){\n', '                owner.transfer(msg.value);\n', '            }\n', '        }\n', '        else{\n', '            if (msg.value >= amountToCreate){\n', '                uint256 toDiv = (mul(amountToCreate, tokenDividend))/100;\n', '                uint256 left = sub(amountToCreate, toDiv);\n', '                owner.transfer(left);\n', '                addDividend(toDiv);\n', '                processBuyAmount(amountToCreate);\n', '            }\n', '            else{\n', '                revert(); // not enough ETH send.\n', '            }\n', '            uint256 diff = sub(msg.value, amountToCreate);\n', '            // If you send to much, you will get rest back.\n', '            // Might be case if amountToCreate is transferred and this is not seen. \n', '            if (diff >= 0){\n', '                msg.sender.transfer(diff);\n', '            }\n', '        }\n', '   \n', '        // Check latest values. \n', '\n', '        \n', '        // Create tower. \n', '        var NewTower = Tower(_timer, 0, _payout, _priceIncrease, _minPrice, 0, _minPrice, _creatorFee, _amountToHalfTime, _minPriceAfterWin, msg.sender, msg.sender, "");\n', '        \n', '        // Insert this into array. \n', '        Towers[next_tower_index] = NewTower;\n', '        \n', '        // Emit TowerCreated event. \n', '        emit TowerCreated(next_tower_index);\n', '        \n', '        // Upgrade index for next tower.\n', '        next_tower_index = add(next_tower_index, 1);\n', '        return (next_tower_index - 1);\n', '    }\n', '    \n', '    // getTimer of TowerID to see how much time (in seconds) you need to win that tower. \n', '    // only works if contract is open. \n', '    // id = tower id (note that "first tower" has ID 0 into the mapping)\n', '    function getTimer(uint256 _id) public onlyOpen returns (uint256)  {\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        //unsigned long long int pr =  totalPriceHalf/((total)/1000000000000+ totalPriceHalf/1000000000000);    \n', '        // No half time? Return tower.\n', '        if (UsedTower.amountToHalfTime == 0){\n', '            return UsedTower.timer;\n', '        }\n', '        \n', '        uint256 var2 = UsedTower.amountToHalfTime;\n', '        uint256 var3 = add(UsedTower.amount / 1000000000000, UsedTower.amountToHalfTime / 1000000000000);\n', '        \n', '        \n', '       if (var2 == 0 && var3 == 0){\n', '           // exception, both are zero!? Weird, return timer.\n', '           return UsedTower.timer;\n', '       }\n', '       \n', '\n', '       \n', '       uint256 target = (mul(UsedTower.timer, var2/var3 )/1000000000000);\n', '       \n', '       // Warning, if for some reason the calculation get super low, it will return 300, which is the absolute minimum.\n', '       //This prevents users from winning because people don&#39;t have enough time to edit gas, which would be unfair.\n', '       if (target < 300){\n', '           return 300;\n', '       }\n', '       \n', '       return target;\n', '    }\n', '    \n', '    // Internal payout function. \n', '    function Payout_intern(uint256 _id) internal {\n', '        //payout.\n', '        \n', '        var UsedTower = Towers[_id];\n', '        // Calculate how much has to be paid. \n', '        uint256 Paid = mul(UsedTower.amount, UsedTower.payout) / 10000;\n', '        \n', '        // Remove paid from amount. \n', '        UsedTower.amount = sub(UsedTower.amount, Paid);\n', '        \n', '        // Send this Paid amount to owner. \n', '        UsedTower.owner.transfer(Paid);\n', '        \n', '        // Calculate new price. \n', '        uint256 newPrice = (UsedTower.price * UsedTower.minPriceAfterWin)/10000;\n', '        \n', '        // Check if lower than minPrice; if yes, set it to minPrice. \n', '        if (newPrice < UsedTower.minPrice){\n', '            newPrice = UsedTower.minPrice;\n', '        }\n', '        \n', '        // Upgrade tower price. \n', '        UsedTower.price = newPrice;\n', '        \n', '         // Will we move on with game?\n', '        if (UsedTower.amount > UsedTower.minPrice){\n', '            // RESTART game. OWNER STAYS SAME \n', '            UsedTower.timestamp = block.timestamp;\n', '        }\n', '        else{\n', '            // amount too low. do not restart.\n', '            UsedTower.timestamp = 0;\n', '        }\n', '    \n', '        // Emit TowerWon event. \n', '        emit TowerWon(_id);\n', '    }\n', '    \n', '    \n', '    // TakePrize, can be called by everyone if contract is open.\n', '    // Usually owner of tower can call this. \n', '    // Note that if you are too late because someone else paid it, then this person will pay you. \n', '    // There is no way to cheat that.\n', '    // id = tower id. (id&#39;s start with 0, not 1!)\n', '    function TakePrize(uint256 _id) public onlyOpen{\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        require(UsedTower.timestamp > 0); // otherwise game has not started.\n', '        var Timing = getTimer(_id);\n', '        if (block.timestamp > (add(UsedTower.timestamp,  Timing))){\n', '            Payout_intern(_id);\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Shoot the previous Robin Hood! \n', '    // If you want, you can also buy your own tower again. This might be used to extract leftovers into the amount. \n', '    \n', '    // _id = tower id   (starts at 0 for first tower);\n', '    // _quote is optional: you can upload a quote to troll your enemies.\n', '    function ShootRobinHood(uint256 _id, string _quote) public payable onlyOpen{\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        var Timing = getTimer(_id);\n', '    \n', '        // Check if game has started and if we are too late. If yes, we pay out and return. \n', '        if (UsedTower.timestamp != 0 && block.timestamp > (add(UsedTower.timestamp,  Timing))){\n', '            Payout_intern(_id);\n', '            // We will not buy, give tokens back. \n', '            if (msg.value > 0){\n', '                msg.sender.transfer(msg.value);\n', '            }\n', '            return;\n', '        }\n', '        \n', '        // Check if enough price. \n', '        require(msg.value >= UsedTower.price);\n', '        // Tower can still be bought, great. \n', '        \n', '        uint256 devFee_used = (mul( UsedTower.price, 5))/100;\n', '        uint256 creatorFee = (mul(UsedTower.creatorFee, UsedTower.price)) / 10000;\n', '        uint256 divFee = (mul(UsedTower.price,  tokenDividend)) / 100;\n', '        \n', '        // Add dividend\n', '        addDividend(divFee);\n', '        // Buy div tokens \n', '        processBuyAmount(UsedTower.price);\n', '        \n', '        // Calculate what we put into amount (ToPay)\n', '        \n', '        uint256 ToPay = sub(sub(UsedTower.price, devFee_used), creatorFee);\n', '        \n', '        //Pay creator the creator fee. \n', '        uint256 diff = sub(msg.value, UsedTower.price);\n', '        if (creatorFee != 0){\n', '            UsedTower.creator.transfer(creatorFee);\n', '        }\n', '        // Did you send too much? Get back difference. \n', '        if (diff > 0){\n', '            msg.sender.transfer(diff); \n', '        }\n', '        \n', '        // Pay dev. \n', '        owner.transfer(devFee_used);\n', '        \n', '        // Change results. \n', '        // Set timestamp to current time. \n', '        UsedTower.timestamp = block.timestamp;\n', '        // Set you as owner \n', '        UsedTower.owner = msg.sender;\n', '        // Set (or reset) quote \n', '        UsedTower.quote = _quote;\n', '        // Add ToPay to amount, which you can earn if you win. \n', '        UsedTower.amount = add(UsedTower.amount, sub(ToPay, divFee));\n', '        // Upgrade price of tower\n', '        UsedTower.price = (UsedTower.price * (10000 + UsedTower.priceIncrease)) / 10000;\n', '        \n', '        // Emit TowerBought event \n', '        emit TowerBought(_id);\n', '    }\n', '    \n', '\n', '    \n', '    \n', '    \n', '    \n', '    // Not interesting, safe math functions\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', '      // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '      return c;\n', '   }\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '    \n', '    \n', '    // START OF DIVIDEND PART\n', '\n', '\n', '    // total number of tokens\n', '    uint256 public numTokens;\n', '    // amount of dividend in pool \n', '    uint256 public ethDividendAmount;\n', '    // 15 szabo start price per token \n', '    uint256 constant public tokenStartPrice = 1000000000000;\n', '    // 1 szabo increase per token \n', '    uint256 constant public tokenIncrease = 100000000000;\n', '    \n', '    // token price tracker. \n', '    uint256 public tokenPrice = tokenStartPrice;\n', '    \n', '    // percentage token dividend \n', '    uint8 constant public tokenDividend = 5;\n', '    \n', '    // token scale factor to make sure math is correct.\n', '    uint256 constant public tokenScaleFactor = 1000;\n', '    \n', '    // address link to how much token that address has \n', '    mapping(address => uint256) public tokensPerAddress;\n', '    //mapping(address => uint256) public payments;\n', '    \n', '    \n', '    // add dividend to pool\n', '    function addDividend(uint256 amt) internal {\n', '        ethDividendAmount = ethDividendAmount + amt;\n', '    }\n', '    \n', '    // get how much tokens you get for amount \n', '    // bah area calculation results in a quadratic equation\n', '    // i hate square roots in solidity\n', '    function getNumTokens(uint256 amt) internal  returns (uint256){\n', '        uint256 a = tokenIncrease;\n', '        uint256 b = 2*tokenPrice - tokenIncrease;\n', '      //  var c = -2*amt;\n', '        uint256 D = b*b + 8*a*amt;\n', '        uint256 sqrtD = tokenScaleFactor*sqrt(D);\n', '        //uint256 (sqrtD - b) / (2*a);\n', '        return (sqrtD - (b * tokenScaleFactor)) / (2*a);\n', '    }\n', '    \n', '    // buy tokens, only being called from robinhood. \n', '    function processBuyAmount(uint256 amt) internal {\n', '        uint256 tokens = getNumTokens(amt );\n', '        tokensPerAddress[msg.sender] = add(tokensPerAddress[msg.sender], tokens);\n', '\n', '        \n', '        numTokens = add(numTokens, tokens);\n', '        //uint256 tokens_normscale = tokens;\n', '        //pushuint(tokens);\n', '        \n', '        // check new price.\n', '        \n', '        //tokenPrice = tokenPrice + (( (tokens * tokens ) + tokens) / 2) * tokenIncrease;\n', '        \n', '       tokenPrice = add(tokenPrice , ((mul(tokenIncrease, tokens))/tokenScaleFactor));\n', '\n', '    }\n', '    \n', '    // sell ALL your tokens to claim your dividend \n', '    function sellTokens() public {\n', '        uint256 tokens = tokensPerAddress[msg.sender];\n', '        if (tokens > 0 && numTokens >= tokens){\n', '            // get amount of tokens: \n', '            uint256 usetk = numTokens;\n', '            uint256 amt = 0;\n', '            if (numTokens > 0){\n', '             amt = (mul(tokens, ethDividendAmount))/numTokens ;\n', '            }\n', '            if (numTokens < tokens){\n', '                usetk = tokens;\n', '            }\n', '            \n', '            // update price. \n', '            \n', '            uint256 nPrice = (sub(tokenPrice, ((mul(tokenIncrease, tokens))/ (2*tokenScaleFactor)))) ;\n', '            \n', '            if (nPrice < tokenStartPrice){\n', '                nPrice = tokenStartPrice;\n', '            }\n', '            tokenPrice = nPrice; \n', '            \n', '            // update tokens \n', '            \n', '            tokensPerAddress[msg.sender] = 0; \n', '            \n', '            // update total tokens \n', '            \n', '            if (tokens <= numTokens){\n', '                numTokens = numTokens - tokens; \n', '            }\n', '            else{\n', '                numTokens = 0;\n', '            }\n', '            \n', '            \n', '            // update dividend \n', '            \n', '            if (amt <= ethDividendAmount){\n', '                ethDividendAmount = ethDividendAmount - amt;\n', '            }\n', '            else{\n', '                ethDividendAmount = 0;\n', '            }\n', '            \n', '            // pay \n', '            \n', '            if (amt > 0){\n', '                msg.sender.transfer(amt);\n', '            }\n', '        }\n', '    }\n', '    \n', '    // square root function, taken from ethereum stack exchange \n', '    function sqrt(uint x) internal returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    \n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// WARNING. The examples used in the formulas in the comments are the right formulas. However, they are not implemented like this to prevent overflows. \n', '// The formulas in the contract do work the same as in the comments. \n', '\n', '// NOTE: In part two of the contract, the DIVIDEND is explained. \n', '// The dividend has a very easy implementation\n', '// the price of the token rise when bought.\n', "// when it's sold, price will decrease with 50% of rate of price bought\n", '// if you sell, you will sell all tokens, and you have thus to buy in at higher price\n', '// make sure you hold dividend for a long time.\n', '\n', 'contract RobinHood{\n', '    // Owner of this contract\n', '    address public owner;\n', '    \n', '    // % of dev fee (can be set to 0,1,2,3,4,5 %);\n', '    uint8 devFee = 5;\n', '    // Users who want to create their own Robin Hood tower have to pay this. Can be reset to any value.\n', '    uint256 public amountToCreate = 20000000000000000;\n', '    \n', '    // If this is false, you cannot use the contract. It can be opened by owner. After that, it cannot be closed anymore.\n', '    // If it is not open, you cannot interact with the contract.\n', '    bool public open = false;\n', '    \n', '    event TowerCreated(uint256 id);\n', '    event TowerBought(uint256 id);\n', '    event TowerWon(uint256 id);\n', '\n', '    // Tower struct. \n', '    struct Tower{\n', '        //Timer in seconds: Base time for how long the new owner of the Tower has to wait until he can pay the amount.\n', '        uint32 timer; \n', '        // Timestamp: if this is 0, the contract does not run. If it runs it is set to the blockchain timestamp. \n', '        // If Timestamp + GetTime() > Blockchain timestamp the user will be paid out  by the person who tries to buy the tower OR the user can decide to buy himself.\n', '        uint256 timestamp;\n', '        // Payout of the amount in percent. Ranges from 0 - 10000. Here 0 is 0 % and 10000 is 100%.\n', '        // This percentage of amount is paid to owner of tower. \n', '        // The other part of amount stays in Tower and can be collected by new people.\n', '        // However, if the amount is larger or equal than the minPrice, the Tower will immediately change the timestamp and move on.\n', '        // This means that the owner of the tower does not change, and can possibly collect the amount more times, if no one buys!!\n', '        uint16 payout; \n', '        // Price increasate, ranged again from 0-10000 (0 = 0%, 10000 = 100%), which decides how much the price increases if someone buys the tower.\n', '        // Ex: 5000 means that if the price is 1 ETH and if someone buys it, then the new price is 1 * (1 + 5000/10000) = 1.5 ETH.\n', '        uint16 priceIncrease; // priceIncrease in percent (same)\n', '        // Price, which can be checked to see how much the tower costs. Initially set to minPrice.\n', '        uint256 price;\n', '        // Amount which the Tower has to pay to the owner.\n', '        uint256 amount; \n', '        // Min Price: the minimum price in wei. Is also the setting to make the contract move on if someone has been paid (if amount >= minPrice);\n', '        // The minimum price is 1 szabo, maximum price is 1 ether. Both are included in the range.\n', '        uint256 minPrice; \n', '        // If you create a contract (not developer) then you are allowed to set a fee which you will get from people who buy your Tower.\n', '        // Ranged again from 0 -> 10000,  but the maximum value is 2500 (25%) minimum is 0 (0%).\n', '        // Developer is not allowed to set creatorFee.\n', '        uint16 creatorFee; \n', '        // This is the amount, in wei, to set at which amount the time necessary to wait will reduce by half.\n', '        // If this is set to 0, this option is not allowed and the time delta is always the same.\n', '        // The minimum wait time is 5 minutes.\n', '        // The time to wait is calculated by: Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime)\n', '        uint256 amountToHalfTime; \n', '        // If someone wins, the price is reduced by this. The new price is calculated by:\n', '        // Tower.price = max(Tower.price * Tower.minPriceAfterWin/10000, Tower.minPrice);\n', '        // Again, this value is ranged from 0 (0%) to 10000 (100%), all values allowed.\n', '        // Note that price will always be the minimum price or higher.\n', '        // If this is set to 0, price will always be set back to new price.\n', '        // If it is set to 10000, the price will NOT change!\n', '        uint16 minPriceAfterWin; // also in percent. \n', '        // Address of the creator of this tower. Used to pay creatorFee. Developer will not receive creatorFee because his creatorFee is automatically set to 0.\n', '        address creator;\n', '        // The current owner of this Tower. If he owns it for longer than getTime() of this Tower, he will receive his portion of the amount in the Tower.\n', '        address owner;\n', "        // You can add a quote to troll your fellow friends. Hopefully they won't buy your tower!\n", '        string quote;\n', '    }\n', '    \n', '   \n', '    // Mapping of all towers, indexed by ID. Starting at 0. \n', '    mapping(uint256 => Tower) public Towers;\n', '    \n', '    // Take track of at what position we insert the Tower. \n', '    uint256 public next_tower_index=0;\n', '\n', '    // Check if contract is open. \n', '    // If value is send and contract is not open, it is reverted and you will get it back. \n', '    // Note that if contract is open it cannot be closed anymore.\n', '    modifier onlyOpen(){\n', '        if (open){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Check if owner or if contract is open. This works for the AddTower function so owner (developer) can already add Towers. \n', '    // Note that if contract is open it cannot be closed anymore. \n', '    // If value is send it will be reverted if you are not owner or the contract is not open. \n', '    modifier onlyOpenOrOwner(){\n', '        if (open || msg.sender == owner){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Functions only for owner (developer)\n', '    // If you send something to a owner function you will get your ethers back via revert. \n', '    modifier onlyOwner(){\n', '        if (msg.sender == owner){\n', '            _;\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    \n', '    // Constructor. \n', '    // Setups 4 towers. \n', '    function RobinHood() public{\n', '        // Log contract developer\n', '        owner = msg.sender;\n', '    \n', '        \n', '        \n', '        // FIRST tower. (ID = 0)\n', '        // Robin Hood has to climb a tower!\n', '        // 10 minutes time range!\n', '        // 90% payout of the amount \n', '        // 30% price increase \n', '        // Timer halfs at 5 ETH. This is a lot, but realize that this high value is choosen because the timer cannot shrink to fast. \n', '        // At 5 ETH the limit is only 5 minutes, the minimum!\n', '        // Minimum price is 2 finney. \n', '        // Price reduces 90% (100% - 10%) after someone has won the tower!\n', '        // 0% creator fee. \n', '       \n', '       \n', '        AddTower(600, 9000, 3000, 5000000000000000000, 2000000000000000, 1000, 0);\n', '    \n', '    \n', '        // SECOND tower (ID = 1)\n', '        // Robin Hood has to search a house!\n', '        // 10 minutes tme range \n', '        // 50% payout \n', '        // 1.5% price increase \n', '        // Timer halfs at 2.5 ETH (also a lot, but at this time then timer is minimum (5 min))\n', '        // Price is 4 finney\n', '        // Price is reduced to 4 finney if won \n', '        // 0% fee \n', '        \n', '        AddTower(600, 5000,150 , 2500000000000000000, 4000000000000000, 0, 0);\n', '  \n', '        // THIRD tower. (ID = 2)\n', '        // Robin Hood has to explore a forest!\n', '        // 1 hour time range!\n', '        // 50% payout of the amount \n', '        // 10% price increase \n', '        // Timer halfs at 1 ETH. \n', '        // Minimum price is 5 finney. \n', '        // Price reduces 50% (100% - 50%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(3600, 5000, 1000, (1000000000000000000), 5000000000000000, 5000, 0);\n', '\n', '        // FOURTH tower. (ID = 3)\n', '        // Robin Hood has to cross a sea to an island!\n', '        // 1 day time range!\n', '        // 75% payout of the amount \n', '        // 20% price increase \n', '        // Timer halfs at 2 ETH.\n', '        // Minimum price is 10 finney. \n', '        // Price reduces 75% (100% - 25%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(86400, 7500, 2000, (2000000000000000000), 10000000000000000, 2500, 0);\n', '         \n', '\n', '  \n', '        // FIFTH tower (ID = 4)\n', '        // Robin Hood has to fly with a rocket to a nearby asteroid!\n', '        // 1 week time range!\n', '        // 75% payout of the amount \n', '        // 25% price increase \n', '        // Timer halfs at 2.5 ETH.\n', '        // Minimum price is 50 finney. \n', '        // Price reduces 100% (100% - 0%) after someone has won the tower!\n', '        // 0% creator fee. \n', '        AddTower(604800, 7500, 2500, (2500000000000000000), 50000000000000000, 0, 0);\n', '    }\n', '    \n', '    // Developer (owner) can open game \n', '    // Open can only be set true once, can never be set false again. \n', '    function OpenGame() public onlyOwner{\n', '        open = true;\n', '    }\n', '    \n', '    // Developer can change fee. \n', '    // DevFee is only a simple int, so can  be 0,1,2,3,4,5 \n', '    // Fee has to be less or equal to 5, otherwise it is reverted. \n', '    function ChangeFee(uint8 _fee) public onlyOwner{\n', '        require(_fee <= 5);\n', '        devFee = _fee;\n', '    }\n', '    \n', '    // Developer change amount price to add tower. \n', '    function ChangeAmountPrice(uint256 _newPrice) public onlyOwner{\n', '        amountToCreate = _newPrice;\n', '    }\n', '    \n', '    // Add Tower. Only possible if you are developer OR if contract is open. \n', '    // If you want to buy a tower, you have to pay amountToCreate (= wei) to developer. \n', '    // The default value is 0.02 ETH.\n', '    // You can check the price (in wei) either on site or by reading the contract on etherscan.\n', '    \n', '    // _timer: Timer in seconds for how long someone has to wait before he wins the tower. This is constant and will not be changed. \n', '    // If you set _amountToHalfTime to nonzero, getTimer will reduce less amounts (minimum 300 seconds, maximum _timer) from the formula Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) \n', '    // _timer has to be between 300 seconds ( 5 minutes) and maximally 366 days (366*24*60*60) (which is maximally one year);\n', '    \n', '    //_payout: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage of the Tower.amount is paid to Tower.owner if he wins. \n', '    // The rest of the amount of that tower which stays over will be kept inside the tower, up for a new round. \n', '    // If someone wins and amount is more than the minPrice, timestamp is set to the blockchain timer and new round is started without changing the owner of the Tower!\n', '    \n', '    // _priceIncrease: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage the price will increase. Note that "100%" is always added. \n', '    // If you set it at 5000 (which is 50%) then the total increase of price is 150%. So if someone buys tower for price at 1 ETH, the new price is then 1.5 ETH. \n', '    \n', '    // _amountToHalfTime: number of Wei which sets how much Wei you need in order to reduce the time necessary to hold tower to win for 50%.\n', '    // Formula used is Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) to calculate the time necessary.\n', '    // If you set 0, then this formula is not used and Tower.time is always returned.\n', '    // Due to overflows the minimum amount (which is reasonable) is still 1/1000 finney. \n', '    // Do not make this number extremely high. \n', '    \n', '    // _minPrice: amount of Wei which the starting price of the Tower is. Minimum is 1/1000 finney, max is 1 ETH. \n', '    // This is also the check value to see if the round moves on after someone has won. If amount >= minPrice then the timestamp will be upgraded and a new round will start\n', '    // Of course that is after paying the owner of this tower. The owner of the tower does not change. He can win multiple times, in theory. \n', '    \n', '    // _minPriceAfterWin: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. After someone wins, the new price of the game is calculated.\n', '    // This is done by doing Tower.price * (Tower.minPriceAfterWin) / 10000; \n', '    // If Tower.price is now less than Tower.minPrice then the Tower.price will be set to Tower.minPrice.\n', '\n', '    // _creatorFee: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Maximum is 2500 (25%), with 2500 included. \n', '    // If you create a tower, you can set this value. If people pay the tower, then this percentage of the price is taken and is sent to you.\n', '    // The rest, after subtracting the dev fee, will be put into Tower.amount. \n', '    \n', '    function AddTower(uint32 _timer, uint16 _payout, uint16 _priceIncrease, uint256 _amountToHalfTime, uint256 _minPrice, uint16 _minPriceAfterWin, uint16 _creatorFee) public payable onlyOpenOrOwner returns (uint256) {\n', '        require (_timer >= 300); // Need at least 5 minutes\n', '        require (_timer <= 31622400);\n', '        require (_payout >= 0 && _payout <= 10000);\n', '        require (_priceIncrease >= 0 && _priceIncrease <= 10000);\n', '        require (_minPriceAfterWin >= 0 && _minPriceAfterWin <= 10000);\n', '       //amount to half time can be everything, but has to be 0 OR 1000000000000 due to division rules\n', '        require(_amountToHalfTime == 0 || _amountToHalfTime >= 1000000000000);\n', '        require(_creatorFee >= 0 && _creatorFee <= 2500);\n', '        require(_minPrice >= (1 szabo) && _minPrice <= (1 ether));\n', '        if (msg.sender == owner){\n', '            // If owner make sure creator fee is 0.\n', '            _creatorFee = 0;\n', '            if (msg.value > 0){\n', '                owner.transfer(msg.value);\n', '            }\n', '        }\n', '        else{\n', '            if (msg.value >= amountToCreate){\n', '                uint256 toDiv = (mul(amountToCreate, tokenDividend))/100;\n', '                uint256 left = sub(amountToCreate, toDiv);\n', '                owner.transfer(left);\n', '                addDividend(toDiv);\n', '                processBuyAmount(amountToCreate);\n', '            }\n', '            else{\n', '                revert(); // not enough ETH send.\n', '            }\n', '            uint256 diff = sub(msg.value, amountToCreate);\n', '            // If you send to much, you will get rest back.\n', '            // Might be case if amountToCreate is transferred and this is not seen. \n', '            if (diff >= 0){\n', '                msg.sender.transfer(diff);\n', '            }\n', '        }\n', '   \n', '        // Check latest values. \n', '\n', '        \n', '        // Create tower. \n', '        var NewTower = Tower(_timer, 0, _payout, _priceIncrease, _minPrice, 0, _minPrice, _creatorFee, _amountToHalfTime, _minPriceAfterWin, msg.sender, msg.sender, "");\n', '        \n', '        // Insert this into array. \n', '        Towers[next_tower_index] = NewTower;\n', '        \n', '        // Emit TowerCreated event. \n', '        emit TowerCreated(next_tower_index);\n', '        \n', '        // Upgrade index for next tower.\n', '        next_tower_index = add(next_tower_index, 1);\n', '        return (next_tower_index - 1);\n', '    }\n', '    \n', '    // getTimer of TowerID to see how much time (in seconds) you need to win that tower. \n', '    // only works if contract is open. \n', '    // id = tower id (note that "first tower" has ID 0 into the mapping)\n', '    function getTimer(uint256 _id) public onlyOpen returns (uint256)  {\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        //unsigned long long int pr =  totalPriceHalf/((total)/1000000000000+ totalPriceHalf/1000000000000);    \n', '        // No half time? Return tower.\n', '        if (UsedTower.amountToHalfTime == 0){\n', '            return UsedTower.timer;\n', '        }\n', '        \n', '        uint256 var2 = UsedTower.amountToHalfTime;\n', '        uint256 var3 = add(UsedTower.amount / 1000000000000, UsedTower.amountToHalfTime / 1000000000000);\n', '        \n', '        \n', '       if (var2 == 0 && var3 == 0){\n', '           // exception, both are zero!? Weird, return timer.\n', '           return UsedTower.timer;\n', '       }\n', '       \n', '\n', '       \n', '       uint256 target = (mul(UsedTower.timer, var2/var3 )/1000000000000);\n', '       \n', '       // Warning, if for some reason the calculation get super low, it will return 300, which is the absolute minimum.\n', "       //This prevents users from winning because people don't have enough time to edit gas, which would be unfair.\n", '       if (target < 300){\n', '           return 300;\n', '       }\n', '       \n', '       return target;\n', '    }\n', '    \n', '    // Internal payout function. \n', '    function Payout_intern(uint256 _id) internal {\n', '        //payout.\n', '        \n', '        var UsedTower = Towers[_id];\n', '        // Calculate how much has to be paid. \n', '        uint256 Paid = mul(UsedTower.amount, UsedTower.payout) / 10000;\n', '        \n', '        // Remove paid from amount. \n', '        UsedTower.amount = sub(UsedTower.amount, Paid);\n', '        \n', '        // Send this Paid amount to owner. \n', '        UsedTower.owner.transfer(Paid);\n', '        \n', '        // Calculate new price. \n', '        uint256 newPrice = (UsedTower.price * UsedTower.minPriceAfterWin)/10000;\n', '        \n', '        // Check if lower than minPrice; if yes, set it to minPrice. \n', '        if (newPrice < UsedTower.minPrice){\n', '            newPrice = UsedTower.minPrice;\n', '        }\n', '        \n', '        // Upgrade tower price. \n', '        UsedTower.price = newPrice;\n', '        \n', '         // Will we move on with game?\n', '        if (UsedTower.amount > UsedTower.minPrice){\n', '            // RESTART game. OWNER STAYS SAME \n', '            UsedTower.timestamp = block.timestamp;\n', '        }\n', '        else{\n', '            // amount too low. do not restart.\n', '            UsedTower.timestamp = 0;\n', '        }\n', '    \n', '        // Emit TowerWon event. \n', '        emit TowerWon(_id);\n', '    }\n', '    \n', '    \n', '    // TakePrize, can be called by everyone if contract is open.\n', '    // Usually owner of tower can call this. \n', '    // Note that if you are too late because someone else paid it, then this person will pay you. \n', '    // There is no way to cheat that.\n', "    // id = tower id. (id's start with 0, not 1!)\n", '    function TakePrize(uint256 _id) public onlyOpen{\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        require(UsedTower.timestamp > 0); // otherwise game has not started.\n', '        var Timing = getTimer(_id);\n', '        if (block.timestamp > (add(UsedTower.timestamp,  Timing))){\n', '            Payout_intern(_id);\n', '        }\n', '        else{\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    // Shoot the previous Robin Hood! \n', '    // If you want, you can also buy your own tower again. This might be used to extract leftovers into the amount. \n', '    \n', '    // _id = tower id   (starts at 0 for first tower);\n', '    // _quote is optional: you can upload a quote to troll your enemies.\n', '    function ShootRobinHood(uint256 _id, string _quote) public payable onlyOpen{\n', '        require(_id < next_tower_index);\n', '        var UsedTower = Towers[_id];\n', '        var Timing = getTimer(_id);\n', '    \n', '        // Check if game has started and if we are too late. If yes, we pay out and return. \n', '        if (UsedTower.timestamp != 0 && block.timestamp > (add(UsedTower.timestamp,  Timing))){\n', '            Payout_intern(_id);\n', '            // We will not buy, give tokens back. \n', '            if (msg.value > 0){\n', '                msg.sender.transfer(msg.value);\n', '            }\n', '            return;\n', '        }\n', '        \n', '        // Check if enough price. \n', '        require(msg.value >= UsedTower.price);\n', '        // Tower can still be bought, great. \n', '        \n', '        uint256 devFee_used = (mul( UsedTower.price, 5))/100;\n', '        uint256 creatorFee = (mul(UsedTower.creatorFee, UsedTower.price)) / 10000;\n', '        uint256 divFee = (mul(UsedTower.price,  tokenDividend)) / 100;\n', '        \n', '        // Add dividend\n', '        addDividend(divFee);\n', '        // Buy div tokens \n', '        processBuyAmount(UsedTower.price);\n', '        \n', '        // Calculate what we put into amount (ToPay)\n', '        \n', '        uint256 ToPay = sub(sub(UsedTower.price, devFee_used), creatorFee);\n', '        \n', '        //Pay creator the creator fee. \n', '        uint256 diff = sub(msg.value, UsedTower.price);\n', '        if (creatorFee != 0){\n', '            UsedTower.creator.transfer(creatorFee);\n', '        }\n', '        // Did you send too much? Get back difference. \n', '        if (diff > 0){\n', '            msg.sender.transfer(diff); \n', '        }\n', '        \n', '        // Pay dev. \n', '        owner.transfer(devFee_used);\n', '        \n', '        // Change results. \n', '        // Set timestamp to current time. \n', '        UsedTower.timestamp = block.timestamp;\n', '        // Set you as owner \n', '        UsedTower.owner = msg.sender;\n', '        // Set (or reset) quote \n', '        UsedTower.quote = _quote;\n', '        // Add ToPay to amount, which you can earn if you win. \n', '        UsedTower.amount = add(UsedTower.amount, sub(ToPay, divFee));\n', '        // Upgrade price of tower\n', '        UsedTower.price = (UsedTower.price * (10000 + UsedTower.priceIncrease)) / 10000;\n', '        \n', '        // Emit TowerBought event \n', '        emit TowerBought(_id);\n', '    }\n', '    \n', '\n', '    \n', '    \n', '    \n', '    \n', '    // Not interesting, safe math functions\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return c;\n', '   }\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '    \n', '    \n', '    // START OF DIVIDEND PART\n', '\n', '\n', '    // total number of tokens\n', '    uint256 public numTokens;\n', '    // amount of dividend in pool \n', '    uint256 public ethDividendAmount;\n', '    // 15 szabo start price per token \n', '    uint256 constant public tokenStartPrice = 1000000000000;\n', '    // 1 szabo increase per token \n', '    uint256 constant public tokenIncrease = 100000000000;\n', '    \n', '    // token price tracker. \n', '    uint256 public tokenPrice = tokenStartPrice;\n', '    \n', '    // percentage token dividend \n', '    uint8 constant public tokenDividend = 5;\n', '    \n', '    // token scale factor to make sure math is correct.\n', '    uint256 constant public tokenScaleFactor = 1000;\n', '    \n', '    // address link to how much token that address has \n', '    mapping(address => uint256) public tokensPerAddress;\n', '    //mapping(address => uint256) public payments;\n', '    \n', '    \n', '    // add dividend to pool\n', '    function addDividend(uint256 amt) internal {\n', '        ethDividendAmount = ethDividendAmount + amt;\n', '    }\n', '    \n', '    // get how much tokens you get for amount \n', '    // bah area calculation results in a quadratic equation\n', '    // i hate square roots in solidity\n', '    function getNumTokens(uint256 amt) internal  returns (uint256){\n', '        uint256 a = tokenIncrease;\n', '        uint256 b = 2*tokenPrice - tokenIncrease;\n', '      //  var c = -2*amt;\n', '        uint256 D = b*b + 8*a*amt;\n', '        uint256 sqrtD = tokenScaleFactor*sqrt(D);\n', '        //uint256 (sqrtD - b) / (2*a);\n', '        return (sqrtD - (b * tokenScaleFactor)) / (2*a);\n', '    }\n', '    \n', '    // buy tokens, only being called from robinhood. \n', '    function processBuyAmount(uint256 amt) internal {\n', '        uint256 tokens = getNumTokens(amt );\n', '        tokensPerAddress[msg.sender] = add(tokensPerAddress[msg.sender], tokens);\n', '\n', '        \n', '        numTokens = add(numTokens, tokens);\n', '        //uint256 tokens_normscale = tokens;\n', '        //pushuint(tokens);\n', '        \n', '        // check new price.\n', '        \n', '        //tokenPrice = tokenPrice + (( (tokens * tokens ) + tokens) / 2) * tokenIncrease;\n', '        \n', '       tokenPrice = add(tokenPrice , ((mul(tokenIncrease, tokens))/tokenScaleFactor));\n', '\n', '    }\n', '    \n', '    // sell ALL your tokens to claim your dividend \n', '    function sellTokens() public {\n', '        uint256 tokens = tokensPerAddress[msg.sender];\n', '        if (tokens > 0 && numTokens >= tokens){\n', '            // get amount of tokens: \n', '            uint256 usetk = numTokens;\n', '            uint256 amt = 0;\n', '            if (numTokens > 0){\n', '             amt = (mul(tokens, ethDividendAmount))/numTokens ;\n', '            }\n', '            if (numTokens < tokens){\n', '                usetk = tokens;\n', '            }\n', '            \n', '            // update price. \n', '            \n', '            uint256 nPrice = (sub(tokenPrice, ((mul(tokenIncrease, tokens))/ (2*tokenScaleFactor)))) ;\n', '            \n', '            if (nPrice < tokenStartPrice){\n', '                nPrice = tokenStartPrice;\n', '            }\n', '            tokenPrice = nPrice; \n', '            \n', '            // update tokens \n', '            \n', '            tokensPerAddress[msg.sender] = 0; \n', '            \n', '            // update total tokens \n', '            \n', '            if (tokens <= numTokens){\n', '                numTokens = numTokens - tokens; \n', '            }\n', '            else{\n', '                numTokens = 0;\n', '            }\n', '            \n', '            \n', '            // update dividend \n', '            \n', '            if (amt <= ethDividendAmount){\n', '                ethDividendAmount = ethDividendAmount - amt;\n', '            }\n', '            else{\n', '                ethDividendAmount = 0;\n', '            }\n', '            \n', '            // pay \n', '            \n', '            if (amt > 0){\n', '                msg.sender.transfer(amt);\n', '            }\n', '        }\n', '    }\n', '    \n', '    // square root function, taken from ethereum stack exchange \n', '    function sqrt(uint x) internal returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    \n', '}']
