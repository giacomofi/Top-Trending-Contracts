['pragma solidity 0.4.20;\n', '\n', '/*\n', '* Team AppX presents - Moon, Inc. | Competitive Ethereum Idle Pyramid\n', '* Website: https://mooninc.io/\n', '* Backup: https://mooninc.surge.sh/\n', '* Discord: https://discord.gg/9Ab8Az3\n', '* \n', '* There are 2 contracts:\n', '* 1. MoonInc: handle Cookie production, cookie price calulation and cookie selling\n', '*      - Reference: [Goo] https://etherscan.io/address/0x57b116da40f21f91aec57329ecb763d29c1b2355#code\n', '* 2. ProductionUnitToken: handle production units tokens buy, sell, reinvest and withdraw\n', '*      - Reference: [PoWTF] https://etherscan.io/address/0x702392282255f8c0993dbbbb148d80d2ef6795b1#code\n', '*\n', '* Features:\n', '* - You can buy workers with ETH to increase your cookies production.\n', '* - You can sell your cookies and claim a proportion of the cookie fund.\n', '* - You cannot sell cookies within the first hour of a new production unit launch.\n', '* - The selling price of a cookie depends on the Cookie Fund and the total cookies supply, the formula is:\n', '*   CookiePrice = CookieFund / TotalCookieSupply * Multiplier\n', '*   * Where Multiplier is a number from 0.5 to 1, which starts with 0.5 after a new production unit started, and reaches maximum value (1) after 5 days.\n', '* - You can sell your workers at any time like normal tokens\n', '*\n', '* Developed by by AppX Matthew, ft. MrBlobby | GOO\n', '*\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', 'contract ProductionUnitToken {\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /// @dev Only people with tokens\n', '    modifier onlyBagholders {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only people with profits\n', '    modifier onlyStronghands {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '\n', '\n', '    /*=====================================\n', '    =            DEPENDENCIES             =\n', '    =====================================*/\n', '\n', '    // MoonInc contract\n', '    MoonInc public moonIncContract;\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '\n', '    string public name = "Production Unit | Moon, Inc.";\n', '    string public symbol = "ProductionUnit";\n', '    uint8 constant public decimals = 18;\n', '\n', '    /// @dev dividends for token purchase\n', '    uint8 public entryFee_;\n', '\n', '    /// @dev dividends for token transfer\n', '    uint8 public transferFee_;\n', '\n', '    /// @dev dividends for token selling\n', '    uint8 public exitFee_;\n', '\n', '    /// @dev 20% of entryFee_ is given to referrer\n', '    uint8 constant internal refferalFee_ = 20;\n', '\n', '    uint256 public tokenPriceInitial_; // original is 0.0000001 ether\n', '    uint256 public tokenPriceIncremental_; // original is 0.00000001 ether\n', '    uint256 constant internal magnitude = 2 ** 64;\n', '\n', '    /// @dev proof of stake (10 tokens)\n', '    uint256 public stakingRequirement = 10e18;\n', '\n', '    // cookie production multiplier (how many cookies do 1 token make per second)\n', '    uint256 public cookieProductionMultiplier;\n', '\n', '    // auto start timer\n', '    uint256 public startTime;\n', '\n', '    // Maximum amount of dev one time pre-mine\n', '    mapping(address => uint) public ambassadorsMaxPremine;\n', '    mapping(address => bool) public ambassadorsPremined;\n', '    mapping(address => address) public ambassadorsPrerequisite;\n', '\n', '\n', '   /*=================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    uint256 internal tokenSupply_;\n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS           =\n', '    =======================================*/\n', '\n', '    /// @dev Set the MoonInc contract address to notify when token amount changes\n', '    function ProductionUnitToken(\n', '        address _moonIncContractAddress, uint8 _entryFee, uint8 _transferFee, uint8 _exitFee,\n', '        uint _tokenPriceInitial, uint _tokenPriceIncremental, uint _cookieProductionMultiplier, uint _startTime\n', '    ) public {\n', '        moonIncContract = MoonInc(_moonIncContractAddress);\n', '        entryFee_ = _entryFee;\n', '        transferFee_ = _transferFee;\n', '        exitFee_ = _exitFee;\n', '        tokenPriceInitial_ = _tokenPriceInitial;\n', '        tokenPriceIncremental_ = _tokenPriceIncremental;\n', '        cookieProductionMultiplier = _cookieProductionMultiplier;\n', '        startTime = _startTime;\n', '\n', '        // Set ambassadors&#39; maximum one time pre-mine amount (Total 1.47 ETH pre-mine including last 2 ambassadors from contest).\n', '        // MA\n', '        ambassadorsMaxPremine[0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD] = 0.28 ether;\n', '        ambassadorsPremined[address(0)] = true; // first ambassador don&#39;t need prerequisite\n', '\n', '        // BL\n', '        ambassadorsMaxPremine[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0.28 ether;\n', '        ambassadorsPrerequisite[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD;\n', '\n', '        // PH\n', '        ambassadorsMaxPremine[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0.28 ether;\n', '        ambassadorsPrerequisite[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f;\n', '\n', '        // RS\n', '        ambassadorsMaxPremine[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05;\n', '\n', '        // LN\n', '        ambassadorsMaxPremine[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d;\n', '\n', '        // LE\n', '        ambassadorsMaxPremine[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05;\n', '\n', '        // MI\n', '        ambassadorsMaxPremine[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41;\n', '\n', '        // PO\n', '        ambassadorsMaxPremine[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0x0a3239799518E7F7F339867A4739282014b97Dcf;\n', '    }\n', '\n', '    bool public lastTwoAmbassadorsAdded;\n', '\n', '    /// @dev Add the last 2 ambassadors from the invite contest because they both offline in the time the contract is deployed.\n', '    function addLastTwoAmbassadors(address _address1, address _address2) public {\n', '        require(msg.sender == 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD && !lastTwoAmbassadorsAdded);\n', '\n', '        lastTwoAmbassadorsAdded = true;\n', '\n', '        // KHAN\n', '        ambassadorsMaxPremine[_address1] = 0.09 ether;\n', '        ambassadorsPrerequisite[_address1] = 0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87;\n', '\n', '        // CRYPTOWHALE\n', '        ambassadorsMaxPremine[_address2] = 0.09 ether;\n', '        ambassadorsPrerequisite[_address2] = _address1;\n', '    }\n', '\n', '    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n', '    function buy(address _referredBy) public payable returns (uint256) {\n', '        purchaseTokens(msg.value, _referredBy);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function to handle ethereum that was send straight to the contract\n', '     *  Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function() payable public {\n', '        purchaseTokens(msg.value, 0x0);\n', '    }\n', '\n', '    /// @dev Converts all of caller&#39;s dividends to tokens.\n', '    function reinvest() onlyStronghands public {\n', '        // fetch dividends\n', '        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '\n', '        // pay out the dividends virtually\n', '        address _customerAddress = msg.sender;\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '\n', '        // retrieve ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(_dividends, 0x0);\n', '\n', '        // fire event\n', '        onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '\n', '    /// @dev Alias of sell() and withdraw().\n', '    function exit() public {\n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if (_tokens > 0) sell(_tokens);\n', '\n', '        // lambo delivery service\n', '        withdraw();\n', '    }\n', '\n', '    /// @dev Withdraws all of the callers earnings.\n', '    function withdraw() onlyStronghands public {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '        // add ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // lambo delivery service\n', '        _customerAddress.transfer(_dividends);\n', '\n', '        // fire event\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '    /// @dev Liquifies tokens to ethereum.\n', '    function sell(uint256 _amountOfTokens) onlyBagholders public {\n', '        require(now >= startTime);\n', '\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        // russian hackers BTFO\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (_taxedEthereum * magnitude);\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _tokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from the caller to a new holder.\n', '     *  Remember, there&#39;s a fee here as well.\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders public returns (bool) {\n', '        // setup\n', '        address _customerAddress = msg.sender;\n', '\n', '        // make sure we have the requested tokens\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        // withdraw all outstanding dividends first\n', '        if (myDividends(true) > 0) {\n', '            withdraw();\n', '        }\n', '\n', '        // liquify 10% of the tokens that are transfered\n', '        // these are dispersed to shareholders\n', '        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '        // burn the fee tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\n', '        moonIncContract.handleProductionIncrease(_toAddress, _taxedTokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '        // ERC20\n', '        return true;\n', '    }\n', '\n', '\n', '    /*=====================================\n', '    =      HELPERS AND CALCULATORS        =\n', '    =====================================*/\n', '\n', '    function getSettings() public view returns (uint8, uint8, uint8, uint256, uint256, uint256, uint256) {\n', '        return (entryFee_, transferFee_, exitFee_, tokenPriceInitial_,\n', '            tokenPriceIncremental_, cookieProductionMultiplier, startTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Method to view the current Ethereum stored in the contract\n', '     *  Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    /// @dev Retrieve the total token supply.\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /// @dev Retrieve the tokens owned by the caller.\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Retrieve the dividends owned by the caller.\n', '     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     *  But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '    }\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /// @dev Retrieve the dividend balance of any single address.\n', '    function dividendsOf(address _customerAddress) public view returns (uint256) {\n', '        return (uint256) ((int256) (-payoutsTo_[_customerAddress])) / magnitude;\n', '    }\n', '\n', '    /// @dev Return the sell price of 1 individual token.\n', '    function sellPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /// @dev Return the buy price of 1 individual token.\n', '    function buyPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, entryFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '\n', '    /// @dev Internal function to actually purchase the tokens.\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) internal returns (uint256) {\n', '        require(\n', '            // auto start\n', '            now >= startTime ||\n', '            // ambassador pre-mine within 1 hour before startTime, sequences enforced\n', '            (now >= startTime - 1 hours && !ambassadorsPremined[msg.sender] && ambassadorsPremined[ambassadorsPrerequisite[msg.sender]] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender]) ||\n', '            // ambassador pre-mine within 10 minutes before startTime, sequences not enforced\n', '            (now >= startTime - 10 minutes && !ambassadorsPremined[msg.sender] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender])\n', '        );\n', '\n', '        if (now < startTime) {\n', '            ambassadorsPremined[msg.sender] = true;\n', '        }\n', '\n', '        // data setup\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n', '        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, refferalFee_), 100);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        // no point in continuing execution if OP is a poorfag russian hacker\n', '        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n', '        // (or hackers)\n', '        // and yes we know that the safemath function automatically rules out the "greater then" equasion.\n', '        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '        // is the user referred by a masternode?\n', '        if (\n', '            // is this a referred purchase?\n', '            _referredBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // no cheating!\n', '            _referredBy != _customerAddress &&\n', '\n', '            // does the referrer have at least X whole tokens?\n', '            // i.e is the referrer a godly chad masternode\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '        }\n', '\n', '        // add tokens to the pool\n', '        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionIncrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Token price based on an amount of incoming ethereum\n', '     *  It&#39;s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n', '     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256) {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '         (\n', '            (\n', '                // underflow attempts BTFO\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial ** 2)\n', '                            +\n', '                            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\n', '                            +\n', '                            ((tokenPriceIncremental_ ** 2) * (tokenSupply_ ** 2))\n', '                            +\n', '                            (2 * tokenPriceIncremental_ * _tokenPriceInitial*tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            ) / (tokenPriceIncremental_)\n', '        ) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate token sell value.\n', '     *  It&#39;s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n', '     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256) {\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n', '                        ) - tokenPriceIncremental_\n', '                    ) * (tokens_ - 1e18)\n', '                ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\n', '            )\n', '        / 1e18);\n', '\n', '        return _etherReceived;\n', '    }\n', '\n', '    /// @dev This is where all your gas goes.\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = (x + 1) / 2;\n', '        y = x;\n', '\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract MoonInc {\n', '\n', '    string public constant name  = "Cookie | Moon, Inc.";\n', '    string public constant symbol = "Cookie";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // Global balances\n', '    uint256 public totalCookieProduction;\n', '    uint256 private roughSupply;\n', '    uint256 private lastTotalCookieSaveTime; // Last time any player claimed their produced cookie\n', '\n', '    // Balances for each player\n', '    mapping(address => uint256) public cookieProduction;\n', '    mapping(address => uint256) public cookieBalance;\n', '    mapping(address => uint256) private lastCookieSaveTime; // Last time player claimed their produced cookie\n', '\n', '    // Mapping of approved ERC20 transfers (by player)\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '    // Production unit contracts\n', '    ProductionUnitToken[] public productionUnitTokenContracts;\n', '    mapping(address => bool) productionUnitTokenContractAddresses;\n', '\n', '    // Store the production unit start time to calculate sell price.\n', '    uint256[] public tokenContractStartTime;\n', '\n', '    // Public launch at: Wed, 23 May 2018, 21:00 GMT\n', '    uint256 public constant firstUnitStartTime = 1527109200;\n', '    \n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    // Constructor\n', '    function MoonInc() public payable {\n', '        // Create first production unit (Space Kitty)\n', '        createProductionUnit1();\n', '    }\n', '\n', '    // No fallback function to avoid accidentally sending money to this contract instead of ProductionUnitToken contract.\n', '    // function() public payable {}\n', '\n', '    // Public function to create the ProductionUnitToken contracts.\n', '\n', '    function createProductionUnit1() public {\n', '        require(productionUnitTokenContracts.length == 0);\n', '\n', '        createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether, 0.00000001 ether, 1, firstUnitStartTime);\n', '    }\n', '\n', '    function createProductionUnit2() public {\n', '        require(productionUnitTokenContracts.length == 1);\n', '\n', '        createProductionUnitTokenContract(15, 15, 15, 0.0000001 ether, 0.00000001 ether, 3, firstUnitStartTime + 2 days);\n', '    }\n', '\n', '    function createProductionUnit3() public {\n', '        require(productionUnitTokenContracts.length == 2);\n', '\n', '        createProductionUnitTokenContract(20, 20, 20, 0.0000001 ether, 0.00000001 ether, 9, firstUnitStartTime + 4 days);\n', '    }\n', '\n', '    function createProductionUnit4() public {\n', '        require(productionUnitTokenContracts.length == 3);\n', '\n', '        createProductionUnitTokenContract(25, 25, 25, 0.0000001 ether, 0.00000001 ether, 3**3, firstUnitStartTime + 7 days);\n', '    }\n', '\n', '    function createProductionUnit5() public {\n', '        require(productionUnitTokenContracts.length == 4);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**4, firstUnitStartTime + 11 days);\n', '    }\n', '\n', '    function createProductionUnit6() public {\n', '        require(productionUnitTokenContracts.length == 5);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**5, firstUnitStartTime + 16 days);\n', '    }\n', '\n', '    function createProductionUnit7() public {\n', '        require(productionUnitTokenContracts.length == 6);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**6, firstUnitStartTime + 21 days);\n', '    }\n', '\n', '    function createProductionUnitTokenContract(\n', '        uint8 _entryFee, uint8 _transferFee, uint8 _exitFee, uint256 _tokenPriceInitial, \n', '        uint256 _tokenPriceIncremental, uint256 _cookieProductionMultiplier, uint256 _startTime\n', '    ) internal {\n', '        ProductionUnitToken newContract = new ProductionUnitToken(address(this),\n', '            _entryFee, _transferFee, _exitFee, _tokenPriceInitial, _tokenPriceIncremental, _cookieProductionMultiplier, _startTime);\n', '        productionUnitTokenContracts.push(newContract);\n', '        productionUnitTokenContractAddresses[address(newContract)] = true;\n', '\n', '        tokenContractStartTime.push(_startTime);\n', '    }\n', '\n', '    function productionUnitTokenContractCount() public view returns (uint) {\n', '        return productionUnitTokenContracts.length;\n', '    }\n', '\n', '    function handleProductionIncrease(address player, uint256 amount) public payable {\n', '        require(productionUnitTokenContractAddresses[msg.sender]);\n', '\n', '        updatePlayersCookie(player);\n', '\n', '        totalCookieProduction = SafeMath.add(totalCookieProduction, amount);\n', '        cookieProduction[player] = SafeMath.add(cookieProduction[player], amount);\n', '    }\n', '\n', '    function handleProductionDecrease(address player, uint256 amount) public payable {\n', '        require(productionUnitTokenContractAddresses[msg.sender]);\n', '\n', '        updatePlayersCookie(player);\n', '\n', '        totalCookieProduction = SafeMath.sub(totalCookieProduction, amount);\n', '        cookieProduction[player] = SafeMath.sub(cookieProduction[player], amount);\n', '    }\n', '\n', '    function getState() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (totalCookieProduction, cookieProduction[msg.sender], totalSupply(), balanceOf(msg.sender), \n', '            address(this).balance, lastTotalCookieSaveTime, computeSellPrice());\n', '    }\n', '\n', '    function totalSupply() public constant returns(uint256) {\n', '        return roughSupply + balanceOfTotalUnclaimedCookie();\n', '    }\n', '\n', '    function balanceOf(address player) public constant returns(uint256) {\n', '        return cookieBalance[player] + balanceOfUnclaimedCookie(player);\n', '    }\n', '\n', '    function balanceOfTotalUnclaimedCookie() public constant returns(uint256) {\n', '        if (lastTotalCookieSaveTime > 0 && lastTotalCookieSaveTime < block.timestamp) {\n', '            return (totalCookieProduction * (block.timestamp - lastTotalCookieSaveTime));\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {\n', '        uint256 lastSave = lastCookieSaveTime[player];\n', '\n', '        if (lastSave > 0 && lastSave < block.timestamp) {\n', '            return (cookieProduction[player] * (block.timestamp - lastSave));\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersCookie(msg.sender);\n', '        require(amount <= cookieBalance[msg.sender]);\n', '\n', '        cookieBalance[msg.sender] -= amount;\n', '        cookieBalance[recipient] += amount;\n', '\n', '        Transfer(msg.sender, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersCookie(player);\n', '        require(amount <= allowed[player][msg.sender] && amount <= cookieBalance[player]);\n', '\n', '        cookieBalance[player] -= amount;\n', '        cookieBalance[recipient] += amount;\n', '        allowed[player][msg.sender] -= amount;\n', '\n', '        Transfer(player, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address approvee, uint256 amount) public returns (bool){\n', '        allowed[msg.sender][approvee] = amount;\n', '        Approval(msg.sender, approvee, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address player, address approvee) public constant returns(uint256){\n', '        return allowed[player][approvee];\n', '    }\n', '\n', '    function updatePlayersCookie(address player) internal {\n', '        roughSupply += balanceOfTotalUnclaimedCookie();\n', '        cookieBalance[player] += balanceOfUnclaimedCookie(player);\n', '        lastTotalCookieSaveTime = block.timestamp;\n', '        lastCookieSaveTime[player] = block.timestamp;\n', '    }\n', '\n', '    // Sell all cookies, the eth earned is calculated by the proportion of cookies owned.\n', '    // Selling of cookie is forbidden within one hour of new production unit launch.\n', '    function sellAllCookies() public {\n', '        updatePlayersCookie(msg.sender);\n', '\n', '        uint256 sellPrice = computeSellPrice();\n', '\n', '        require(sellPrice > 0);\n', '\n', '        uint256 myCookies = cookieBalance[msg.sender];\n', '        uint256 value = myCookies * sellPrice / (1 ether);\n', '\n', '        cookieBalance[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    // Compute sell price for 1 cookie, it is 0.5 when a new token contract is deployed,\n', '    // and then goes up until it reaches the maximum sell price after 5 days.\n', '    function computeSellPrice() public view returns (uint) {\n', '        uint256 supply = totalSupply();\n', '\n', '        if (supply == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint index;\n', '        uint lastTokenContractStartTime = now;\n', '\n', '        while (index < tokenContractStartTime.length && tokenContractStartTime[index] < now) {\n', '            lastTokenContractStartTime = tokenContractStartTime[index];\n', '            index++;\n', '        }\n', '\n', '        if (now < lastTokenContractStartTime + 1 hours) {\n', '            return 0;\n', '        }\n', '\n', '        uint timeToMaxValue = 5 days;\n', '\n', '        uint256 secondsPassed = now - lastTokenContractStartTime;\n', '        secondsPassed = secondsPassed <= timeToMaxValue ? secondsPassed : timeToMaxValue;\n', '        uint256 multiplier = 5000 + 5000 * secondsPassed / timeToMaxValue;\n', '\n', '        return 1 ether * address(this).balance / supply * multiplier / 10000;\n', '    }\n', '\n', '}']
['pragma solidity 0.4.20;\n', '\n', '/*\n', '* Team AppX presents - Moon, Inc. | Competitive Ethereum Idle Pyramid\n', '* Website: https://mooninc.io/\n', '* Backup: https://mooninc.surge.sh/\n', '* Discord: https://discord.gg/9Ab8Az3\n', '* \n', '* There are 2 contracts:\n', '* 1. MoonInc: handle Cookie production, cookie price calulation and cookie selling\n', '*      - Reference: [Goo] https://etherscan.io/address/0x57b116da40f21f91aec57329ecb763d29c1b2355#code\n', '* 2. ProductionUnitToken: handle production units tokens buy, sell, reinvest and withdraw\n', '*      - Reference: [PoWTF] https://etherscan.io/address/0x702392282255f8c0993dbbbb148d80d2ef6795b1#code\n', '*\n', '* Features:\n', '* - You can buy workers with ETH to increase your cookies production.\n', '* - You can sell your cookies and claim a proportion of the cookie fund.\n', '* - You cannot sell cookies within the first hour of a new production unit launch.\n', '* - The selling price of a cookie depends on the Cookie Fund and the total cookies supply, the formula is:\n', '*   CookiePrice = CookieFund / TotalCookieSupply * Multiplier\n', '*   * Where Multiplier is a number from 0.5 to 1, which starts with 0.5 after a new production unit started, and reaches maximum value (1) after 5 days.\n', '* - You can sell your workers at any time like normal tokens\n', '*\n', '* Developed by by AppX Matthew, ft. MrBlobby | GOO\n', '*\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', 'contract ProductionUnitToken {\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /// @dev Only people with tokens\n', '    modifier onlyBagholders {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only people with profits\n', '    modifier onlyStronghands {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '\n', '\n', '    /*=====================================\n', '    =            DEPENDENCIES             =\n', '    =====================================*/\n', '\n', '    // MoonInc contract\n', '    MoonInc public moonIncContract;\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '\n', '    string public name = "Production Unit | Moon, Inc.";\n', '    string public symbol = "ProductionUnit";\n', '    uint8 constant public decimals = 18;\n', '\n', '    /// @dev dividends for token purchase\n', '    uint8 public entryFee_;\n', '\n', '    /// @dev dividends for token transfer\n', '    uint8 public transferFee_;\n', '\n', '    /// @dev dividends for token selling\n', '    uint8 public exitFee_;\n', '\n', '    /// @dev 20% of entryFee_ is given to referrer\n', '    uint8 constant internal refferalFee_ = 20;\n', '\n', '    uint256 public tokenPriceInitial_; // original is 0.0000001 ether\n', '    uint256 public tokenPriceIncremental_; // original is 0.00000001 ether\n', '    uint256 constant internal magnitude = 2 ** 64;\n', '\n', '    /// @dev proof of stake (10 tokens)\n', '    uint256 public stakingRequirement = 10e18;\n', '\n', '    // cookie production multiplier (how many cookies do 1 token make per second)\n', '    uint256 public cookieProductionMultiplier;\n', '\n', '    // auto start timer\n', '    uint256 public startTime;\n', '\n', '    // Maximum amount of dev one time pre-mine\n', '    mapping(address => uint) public ambassadorsMaxPremine;\n', '    mapping(address => bool) public ambassadorsPremined;\n', '    mapping(address => address) public ambassadorsPrerequisite;\n', '\n', '\n', '   /*=================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    uint256 internal tokenSupply_;\n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS           =\n', '    =======================================*/\n', '\n', '    /// @dev Set the MoonInc contract address to notify when token amount changes\n', '    function ProductionUnitToken(\n', '        address _moonIncContractAddress, uint8 _entryFee, uint8 _transferFee, uint8 _exitFee,\n', '        uint _tokenPriceInitial, uint _tokenPriceIncremental, uint _cookieProductionMultiplier, uint _startTime\n', '    ) public {\n', '        moonIncContract = MoonInc(_moonIncContractAddress);\n', '        entryFee_ = _entryFee;\n', '        transferFee_ = _transferFee;\n', '        exitFee_ = _exitFee;\n', '        tokenPriceInitial_ = _tokenPriceInitial;\n', '        tokenPriceIncremental_ = _tokenPriceIncremental;\n', '        cookieProductionMultiplier = _cookieProductionMultiplier;\n', '        startTime = _startTime;\n', '\n', "        // Set ambassadors' maximum one time pre-mine amount (Total 1.47 ETH pre-mine including last 2 ambassadors from contest).\n", '        // MA\n', '        ambassadorsMaxPremine[0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD] = 0.28 ether;\n', "        ambassadorsPremined[address(0)] = true; // first ambassador don't need prerequisite\n", '\n', '        // BL\n', '        ambassadorsMaxPremine[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0.28 ether;\n', '        ambassadorsPrerequisite[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD;\n', '\n', '        // PH\n', '        ambassadorsMaxPremine[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0.28 ether;\n', '        ambassadorsPrerequisite[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f;\n', '\n', '        // RS\n', '        ambassadorsMaxPremine[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05;\n', '\n', '        // LN\n', '        ambassadorsMaxPremine[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d;\n', '\n', '        // LE\n', '        ambassadorsMaxPremine[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05;\n', '\n', '        // MI\n', '        ambassadorsMaxPremine[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41;\n', '\n', '        // PO\n', '        ambassadorsMaxPremine[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0.09 ether;\n', '        ambassadorsPrerequisite[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0x0a3239799518E7F7F339867A4739282014b97Dcf;\n', '    }\n', '\n', '    bool public lastTwoAmbassadorsAdded;\n', '\n', '    /// @dev Add the last 2 ambassadors from the invite contest because they both offline in the time the contract is deployed.\n', '    function addLastTwoAmbassadors(address _address1, address _address2) public {\n', '        require(msg.sender == 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD && !lastTwoAmbassadorsAdded);\n', '\n', '        lastTwoAmbassadorsAdded = true;\n', '\n', '        // KHAN\n', '        ambassadorsMaxPremine[_address1] = 0.09 ether;\n', '        ambassadorsPrerequisite[_address1] = 0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87;\n', '\n', '        // CRYPTOWHALE\n', '        ambassadorsMaxPremine[_address2] = 0.09 ether;\n', '        ambassadorsPrerequisite[_address2] = _address1;\n', '    }\n', '\n', '    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n', '    function buy(address _referredBy) public payable returns (uint256) {\n', '        purchaseTokens(msg.value, _referredBy);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function to handle ethereum that was send straight to the contract\n', '     *  Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function() payable public {\n', '        purchaseTokens(msg.value, 0x0);\n', '    }\n', '\n', "    /// @dev Converts all of caller's dividends to tokens.\n", '    function reinvest() onlyStronghands public {\n', '        // fetch dividends\n', '        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\n', '\n', '        // pay out the dividends virtually\n', '        address _customerAddress = msg.sender;\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n', '\n', '        // retrieve ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(_dividends, 0x0);\n', '\n', '        // fire event\n', '        onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '\n', '    /// @dev Alias of sell() and withdraw().\n', '    function exit() public {\n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if (_tokens > 0) sell(_tokens);\n', '\n', '        // lambo delivery service\n', '        withdraw();\n', '    }\n', '\n', '    /// @dev Withdraws all of the callers earnings.\n', '    function withdraw() onlyStronghands public {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '        // add ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // lambo delivery service\n', '        _customerAddress.transfer(_dividends);\n', '\n', '        // fire event\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '    /// @dev Liquifies tokens to ethereum.\n', '    function sell(uint256 _amountOfTokens) onlyBagholders public {\n', '        require(now >= startTime);\n', '\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        // russian hackers BTFO\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (_taxedEthereum * magnitude);\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _tokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from the caller to a new holder.\n', "     *  Remember, there's a fee here as well.\n", '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders public returns (bool) {\n', '        // setup\n', '        address _customerAddress = msg.sender;\n', '\n', '        // make sure we have the requested tokens\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        // withdraw all outstanding dividends first\n', '        if (myDividends(true) > 0) {\n', '            withdraw();\n', '        }\n', '\n', '        // liquify 10% of the tokens that are transfered\n', '        // these are dispersed to shareholders\n', '        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '        // burn the fee tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\n', '        moonIncContract.handleProductionIncrease(_toAddress, _taxedTokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '        // ERC20\n', '        return true;\n', '    }\n', '\n', '\n', '    /*=====================================\n', '    =      HELPERS AND CALCULATORS        =\n', '    =====================================*/\n', '\n', '    function getSettings() public view returns (uint8, uint8, uint8, uint256, uint256, uint256, uint256) {\n', '        return (entryFee_, transferFee_, exitFee_, tokenPriceInitial_,\n', '            tokenPriceIncremental_, cookieProductionMultiplier, startTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Method to view the current Ethereum stored in the contract\n', '     *  Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    /// @dev Retrieve the total token supply.\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /// @dev Retrieve the tokens owned by the caller.\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Retrieve the dividends owned by the caller.\n', '     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     *  But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '    }\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /// @dev Retrieve the dividend balance of any single address.\n', '    function dividendsOf(address _customerAddress) public view returns (uint256) {\n', '        return (uint256) ((int256) (-payoutsTo_[_customerAddress])) / magnitude;\n', '    }\n', '\n', '    /// @dev Return the sell price of 1 individual token.\n', '    function sellPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /// @dev Return the buy price of 1 individual token.\n', '    function buyPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, entryFee_), 100);\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '\n', '    /// @dev Internal function to actually purchase the tokens.\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) internal returns (uint256) {\n', '        require(\n', '            // auto start\n', '            now >= startTime ||\n', '            // ambassador pre-mine within 1 hour before startTime, sequences enforced\n', '            (now >= startTime - 1 hours && !ambassadorsPremined[msg.sender] && ambassadorsPremined[ambassadorsPrerequisite[msg.sender]] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender]) ||\n', '            // ambassador pre-mine within 10 minutes before startTime, sequences not enforced\n', '            (now >= startTime - 10 minutes && !ambassadorsPremined[msg.sender] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender])\n', '        );\n', '\n', '        if (now < startTime) {\n', '            ambassadorsPremined[msg.sender] = true;\n', '        }\n', '\n', '        // data setup\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n', '        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, refferalFee_), 100);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        // no point in continuing execution if OP is a poorfag russian hacker\n', '        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n', '        // (or hackers)\n', '        // and yes we know that the safemath function automatically rules out the "greater then" equasion.\n', '        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '        // is the user referred by a masternode?\n', '        if (\n', '            // is this a referred purchase?\n', '            _referredBy != 0x0000000000000000000000000000000000000000 &&\n', '\n', '            // no cheating!\n', '            _referredBy != _customerAddress &&\n', '\n', '            // does the referrer have at least X whole tokens?\n', '            // i.e is the referrer a godly chad masternode\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '        }\n', '\n', '        // add tokens to the pool\n', '        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '        // Tell MoonInc contract for tokens amount change, and transfer dividends.\n', '        moonIncContract.handleProductionIncrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\n', '\n', '        // fire event\n', '        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Token price based on an amount of incoming ethereum\n', "     *  It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256) {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '         (\n', '            (\n', '                // underflow attempts BTFO\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial ** 2)\n', '                            +\n', '                            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\n', '                            +\n', '                            ((tokenPriceIncremental_ ** 2) * (tokenSupply_ ** 2))\n', '                            +\n', '                            (2 * tokenPriceIncremental_ * _tokenPriceInitial*tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            ) / (tokenPriceIncremental_)\n', '        ) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate token sell value.\n', "     *  It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256) {\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n', '                        ) - tokenPriceIncremental_\n', '                    ) * (tokens_ - 1e18)\n', '                ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\n', '            )\n', '        / 1e18);\n', '\n', '        return _etherReceived;\n', '    }\n', '\n', '    /// @dev This is where all your gas goes.\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = (x + 1) / 2;\n', '        y = x;\n', '\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract MoonInc {\n', '\n', '    string public constant name  = "Cookie | Moon, Inc.";\n', '    string public constant symbol = "Cookie";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // Global balances\n', '    uint256 public totalCookieProduction;\n', '    uint256 private roughSupply;\n', '    uint256 private lastTotalCookieSaveTime; // Last time any player claimed their produced cookie\n', '\n', '    // Balances for each player\n', '    mapping(address => uint256) public cookieProduction;\n', '    mapping(address => uint256) public cookieBalance;\n', '    mapping(address => uint256) private lastCookieSaveTime; // Last time player claimed their produced cookie\n', '\n', '    // Mapping of approved ERC20 transfers (by player)\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '    // Production unit contracts\n', '    ProductionUnitToken[] public productionUnitTokenContracts;\n', '    mapping(address => bool) productionUnitTokenContractAddresses;\n', '\n', '    // Store the production unit start time to calculate sell price.\n', '    uint256[] public tokenContractStartTime;\n', '\n', '    // Public launch at: Wed, 23 May 2018, 21:00 GMT\n', '    uint256 public constant firstUnitStartTime = 1527109200;\n', '    \n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    // Constructor\n', '    function MoonInc() public payable {\n', '        // Create first production unit (Space Kitty)\n', '        createProductionUnit1();\n', '    }\n', '\n', '    // No fallback function to avoid accidentally sending money to this contract instead of ProductionUnitToken contract.\n', '    // function() public payable {}\n', '\n', '    // Public function to create the ProductionUnitToken contracts.\n', '\n', '    function createProductionUnit1() public {\n', '        require(productionUnitTokenContracts.length == 0);\n', '\n', '        createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether, 0.00000001 ether, 1, firstUnitStartTime);\n', '    }\n', '\n', '    function createProductionUnit2() public {\n', '        require(productionUnitTokenContracts.length == 1);\n', '\n', '        createProductionUnitTokenContract(15, 15, 15, 0.0000001 ether, 0.00000001 ether, 3, firstUnitStartTime + 2 days);\n', '    }\n', '\n', '    function createProductionUnit3() public {\n', '        require(productionUnitTokenContracts.length == 2);\n', '\n', '        createProductionUnitTokenContract(20, 20, 20, 0.0000001 ether, 0.00000001 ether, 9, firstUnitStartTime + 4 days);\n', '    }\n', '\n', '    function createProductionUnit4() public {\n', '        require(productionUnitTokenContracts.length == 3);\n', '\n', '        createProductionUnitTokenContract(25, 25, 25, 0.0000001 ether, 0.00000001 ether, 3**3, firstUnitStartTime + 7 days);\n', '    }\n', '\n', '    function createProductionUnit5() public {\n', '        require(productionUnitTokenContracts.length == 4);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**4, firstUnitStartTime + 11 days);\n', '    }\n', '\n', '    function createProductionUnit6() public {\n', '        require(productionUnitTokenContracts.length == 5);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**5, firstUnitStartTime + 16 days);\n', '    }\n', '\n', '    function createProductionUnit7() public {\n', '        require(productionUnitTokenContracts.length == 6);\n', '\n', '        createProductionUnitTokenContract(30, 30, 30, 0.0000001 ether, 0.00000001 ether, 3**6, firstUnitStartTime + 21 days);\n', '    }\n', '\n', '    function createProductionUnitTokenContract(\n', '        uint8 _entryFee, uint8 _transferFee, uint8 _exitFee, uint256 _tokenPriceInitial, \n', '        uint256 _tokenPriceIncremental, uint256 _cookieProductionMultiplier, uint256 _startTime\n', '    ) internal {\n', '        ProductionUnitToken newContract = new ProductionUnitToken(address(this),\n', '            _entryFee, _transferFee, _exitFee, _tokenPriceInitial, _tokenPriceIncremental, _cookieProductionMultiplier, _startTime);\n', '        productionUnitTokenContracts.push(newContract);\n', '        productionUnitTokenContractAddresses[address(newContract)] = true;\n', '\n', '        tokenContractStartTime.push(_startTime);\n', '    }\n', '\n', '    function productionUnitTokenContractCount() public view returns (uint) {\n', '        return productionUnitTokenContracts.length;\n', '    }\n', '\n', '    function handleProductionIncrease(address player, uint256 amount) public payable {\n', '        require(productionUnitTokenContractAddresses[msg.sender]);\n', '\n', '        updatePlayersCookie(player);\n', '\n', '        totalCookieProduction = SafeMath.add(totalCookieProduction, amount);\n', '        cookieProduction[player] = SafeMath.add(cookieProduction[player], amount);\n', '    }\n', '\n', '    function handleProductionDecrease(address player, uint256 amount) public payable {\n', '        require(productionUnitTokenContractAddresses[msg.sender]);\n', '\n', '        updatePlayersCookie(player);\n', '\n', '        totalCookieProduction = SafeMath.sub(totalCookieProduction, amount);\n', '        cookieProduction[player] = SafeMath.sub(cookieProduction[player], amount);\n', '    }\n', '\n', '    function getState() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (totalCookieProduction, cookieProduction[msg.sender], totalSupply(), balanceOf(msg.sender), \n', '            address(this).balance, lastTotalCookieSaveTime, computeSellPrice());\n', '    }\n', '\n', '    function totalSupply() public constant returns(uint256) {\n', '        return roughSupply + balanceOfTotalUnclaimedCookie();\n', '    }\n', '\n', '    function balanceOf(address player) public constant returns(uint256) {\n', '        return cookieBalance[player] + balanceOfUnclaimedCookie(player);\n', '    }\n', '\n', '    function balanceOfTotalUnclaimedCookie() public constant returns(uint256) {\n', '        if (lastTotalCookieSaveTime > 0 && lastTotalCookieSaveTime < block.timestamp) {\n', '            return (totalCookieProduction * (block.timestamp - lastTotalCookieSaveTime));\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {\n', '        uint256 lastSave = lastCookieSaveTime[player];\n', '\n', '        if (lastSave > 0 && lastSave < block.timestamp) {\n', '            return (cookieProduction[player] * (block.timestamp - lastSave));\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersCookie(msg.sender);\n', '        require(amount <= cookieBalance[msg.sender]);\n', '\n', '        cookieBalance[msg.sender] -= amount;\n', '        cookieBalance[recipient] += amount;\n', '\n', '        Transfer(msg.sender, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersCookie(player);\n', '        require(amount <= allowed[player][msg.sender] && amount <= cookieBalance[player]);\n', '\n', '        cookieBalance[player] -= amount;\n', '        cookieBalance[recipient] += amount;\n', '        allowed[player][msg.sender] -= amount;\n', '\n', '        Transfer(player, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address approvee, uint256 amount) public returns (bool){\n', '        allowed[msg.sender][approvee] = amount;\n', '        Approval(msg.sender, approvee, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address player, address approvee) public constant returns(uint256){\n', '        return allowed[player][approvee];\n', '    }\n', '\n', '    function updatePlayersCookie(address player) internal {\n', '        roughSupply += balanceOfTotalUnclaimedCookie();\n', '        cookieBalance[player] += balanceOfUnclaimedCookie(player);\n', '        lastTotalCookieSaveTime = block.timestamp;\n', '        lastCookieSaveTime[player] = block.timestamp;\n', '    }\n', '\n', '    // Sell all cookies, the eth earned is calculated by the proportion of cookies owned.\n', '    // Selling of cookie is forbidden within one hour of new production unit launch.\n', '    function sellAllCookies() public {\n', '        updatePlayersCookie(msg.sender);\n', '\n', '        uint256 sellPrice = computeSellPrice();\n', '\n', '        require(sellPrice > 0);\n', '\n', '        uint256 myCookies = cookieBalance[msg.sender];\n', '        uint256 value = myCookies * sellPrice / (1 ether);\n', '\n', '        cookieBalance[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    // Compute sell price for 1 cookie, it is 0.5 when a new token contract is deployed,\n', '    // and then goes up until it reaches the maximum sell price after 5 days.\n', '    function computeSellPrice() public view returns (uint) {\n', '        uint256 supply = totalSupply();\n', '\n', '        if (supply == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint index;\n', '        uint lastTokenContractStartTime = now;\n', '\n', '        while (index < tokenContractStartTime.length && tokenContractStartTime[index] < now) {\n', '            lastTokenContractStartTime = tokenContractStartTime[index];\n', '            index++;\n', '        }\n', '\n', '        if (now < lastTokenContractStartTime + 1 hours) {\n', '            return 0;\n', '        }\n', '\n', '        uint timeToMaxValue = 5 days;\n', '\n', '        uint256 secondsPassed = now - lastTokenContractStartTime;\n', '        secondsPassed = secondsPassed <= timeToMaxValue ? secondsPassed : timeToMaxValue;\n', '        uint256 multiplier = 5000 + 5000 * secondsPassed / timeToMaxValue;\n', '\n', '        return 1 ether * address(this).balance / supply * multiplier / 10000;\n', '    }\n', '\n', '}']
