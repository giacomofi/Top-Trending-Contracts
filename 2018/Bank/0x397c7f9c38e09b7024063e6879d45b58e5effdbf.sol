['pragma solidity ^0.4.21;\n', '\n', '\n', '/** @title Manager\n', '  * @author M.H. Kang\n', '  */\n', 'contract Managed {\n', '\n', '  event Commission(uint256 basisPoint);\n', '\n', '  address public manager;\n', '  uint256 public commission;\n', '\n', '  function Managed() public {\n', '    manager = msg.sender;\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '  /* FUNCTION */\n', '\n', '  function setCommission(uint256 _commission) external {\n', '    require(_commission < 10000);\n', '    commission = _commission;\n', '\n', '    emit Commission(commission);\n', '  }\n', '\n', '  function withdrawBalance() external {\n', '    manager.transfer(address(this).balance);\n', '  }\n', '\n', '  function transferPower(address _newManager) external onlyManager {\n', '    manager = _newManager;\n', '  }\n', '\n', '  function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n', '    external\n', '    payable\n', '    onlyManager\n', '    returns (bool)\n', '  {\n', '    return _to.call.value(_value).gas(_gas)(_code);\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyManager\n', '  {\n', '    require(msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '/** @title EthernameRaw\n', '  * @author M.H. Kang\n', '  */\n', 'contract EthernameRaw is Managed {\n', '\n', '  /* EVENT */\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    bytes32 indexed name\n', '  );\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed approved,\n', '    bytes32 indexed name\n', '  );\n', '  event SendEther(\n', '    address indexed from,\n', '    address indexed to,\n', '    bytes32 sender,\n', '    bytes32 recipient,\n', '    uint256 value\n', '  );\n', '  event Name(address indexed owner, bytes32 indexed name);\n', '  event Price(bytes32 indexed name, uint256 price);\n', '  event Buy(bytes32 indexed name, address buyer, uint256 price);\n', '  event Attribute(bytes32 indexed name, bytes32 key);\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Record {\n', '    address owner;\n', '    uint256 price;\n', '    mapping (bytes32 => bytes) attrs;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  string public constant name = "Ethername";\n', '  string public constant symbol = "ENM";\n', '\n', '  mapping (address => bytes32) public ownerToName;\n', '  mapping (bytes32 => Record) public nameToRecord;\n', '  mapping (bytes32 => address) public nameToApproved;\n', '\n', '  /* FUNCTION */\n', '\n', '  function rawRegister(bytes32 _name) public payable {\n', '    _register(_name, msg.sender);\n', '  }\n', '\n', '  function rawTransfer(address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    _transfer(msg.sender, _to, _name);\n', '  }\n', '\n', '  function rawApprove(address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    _approve(msg.sender, _to, _name);\n', '  }\n', '\n', '  function rawTransferFrom(address _from, address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(_from, _name)\n', '    onlyApproved(msg.sender, _name)\n', '  {\n', '    _transfer(_from, _to, _name);\n', '  }\n', '\n', '  function rawSetPrice(bytes32 _name, uint256 _price)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    require(_price == uint256(uint128(_price)));\n', '    nameToRecord[_name].price = _price;\n', '\n', '    emit Price(_name, _price);\n', '  }\n', '\n', '  function rawBuy(bytes32 _name) public payable {\n', '    Record memory _record = nameToRecord[_name];\n', '    require(_record.price > 0);\n', '    uint256 _price = _computePrice(_record.price);\n', '    require(msg.value >= _price);\n', '\n', '    _record.owner.transfer(_record.price);\n', '    _transfer(_record.owner, msg.sender, _name);\n', '    msg.sender.transfer(msg.value - _price);\n', '\n', '    emit Buy(_name, msg.sender, _price);\n', '  }\n', '\n', '  function rawUseName(bytes32 _name) public onlyOwner(msg.sender, _name) {\n', '    _useName(msg.sender, _name);\n', '  }\n', '\n', '  function rawSetAttribute(bytes32 _name, bytes32 _key, bytes _value)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    nameToRecord[_name].attrs[_key] = _value;\n', '\n', '    emit Attribute(_name, _key);\n', '  }\n', '\n', '  function rawWipeAttributes(bytes32 _name, bytes32[] _keys)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    mapping (bytes32 => bytes) attrs = nameToRecord[_name].attrs;\n', '\t\tfor (uint i = 0; i < _keys.length; i++) {\n', '      delete attrs[_keys[i]];\n', '\n', '      emit Attribute(_name, _keys[i]);\n', '\t\t}\n', '  }\n', '\n', '  function rawSendEther(bytes32 _name) public payable returns (bool _result) {\n', '    address _to = nameToRecord[_name].owner;\n', '    _result = (_name != bytes32(0)) &&\n', '      (_to != address(0)) &&\n', '      _to.send(msg.value);\n', '    if (_result) {\n', '      emit SendEther(\n', '        msg.sender,\n', '        _to,\n', '        rawNameOf(msg.sender),\n', '        _name,\n', '        msg.value\n', '      );\n', '    }\n', '  }\n', '\n', '  /* VIEW FUNCTION */\n', '\n', '  function rawNameOf(address _address) public view returns (bytes32 _name) {\n', '    _name = ownerToName[_address];\n', '  }\n', '\n', '  function rawOwnerOf(bytes32 _name) public view returns (address _owner) {\n', '    _owner = nameToRecord[_name].owner;\n', '  }\n', '\n', '  function rawDetailsOf(bytes32 _name, bytes32 _key)\n', '    public\n', '    view\n', '    returns (address _owner, uint256 _price, bytes _value)\n', '  {\n', '    _owner = nameToRecord[_name].owner;\n', '    _price = _computePrice(nameToRecord[_name].price);\n', '    _value = nameToRecord[_name].attrs[_key];\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _register(bytes32 _name, address _to) internal {\n', '    require(nameToRecord[_name].owner == address(0));\n', '\t\tfor (uint i = 0; i < _name.length; i++) {\n', '\t\t \trequire((_name[i] == 0) ||\n', '              (_name[i] > 96 && _name[i] < 123) ||\n', '              (_name[i] > 47 && _name[i] < 58));\n', '\t\t}\n', '\n', '    _transfer(0, _to, _name);\n', '  }\n', '\n', '  /**\n', '   * @dev When transferred,\n', '   *  price and approved are set to 0 but attrs remains.\n', '   */\n', '  function _transfer(address _from, address _to, bytes32 _name) internal {\n', '    address _null = address(0);\n', '\n', '    if (nameToApproved[_name] != _null) {\n', '      _approve(_from, _null, _name);\n', '    }\n', '\n', '    if (ownerToName[_from] == _name) {\n', '      _useName(_from, 0);\n', '    }\n', '\n', '    nameToRecord[_name] = Record(_to, 0);\n', '\n', '    if (ownerToName[_to] == bytes32(0)) {\n', '      _useName(_to, _name);\n', '    }\n', '\n', '    emit Transfer(_from, _to, _name);\n', '  }\n', '\n', '  function _approve(address _owner, address _to, bytes32 _name) internal {\n', '    nameToApproved[_name] = _to;\n', '    emit Approval(_owner, _to, _name);\n', '  }\n', '\n', '  function _useName(address _owner, bytes32 _name) internal {\n', '    ownerToName[_owner] = _name;\n', '    emit Name(_owner, _name);\n', '  }\n', '\n', '  function _computePrice(uint256 _price) internal view returns (uint256) {\n', '    return _price * (10000 + commission) / 10000;\n', '  }\n', '\n', '  function _stringToBytes32(string _string)\n', '    internal\n', '    pure\n', '    returns (bytes32 _bytes32)\n', '  {\n', '    require(bytes(_string).length < 33);\n', '    assembly {\n', '      _bytes32 := mload(add(_string, 0x20))\n', '    }\n', '  }\n', '\n', '  function _bytes32ToString(bytes32 _bytes32)\n', '    internal\n', '    pure\n', '    returns (string _string)\n', '  {\n', '    assembly {\n', '      let m := mload(0x40)\n', '      mstore(m, 0x20)\n', '      mstore(add(m, 0x20), _bytes32)\n', '      mstore(0x40, add(m, 0x40))\n', '      _string := m\n', '    }\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyOwner(address _claimant, bytes32 _name) {\n', '    require(nameToRecord[_name].owner == _claimant);\n', '    _;\n', '  }\n', '\n', '  modifier onlyApproved(address _claimant, bytes32 _name) {\n', '    require(nameToApproved[_name] == _claimant);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '/** @title Ethername\n', '  * @author M.H. Kang\n', '  * @notice This contract is designed for any DAPPs to have\n', '  *  username feature without additional implementation.\n', '  */\n', 'contract Ethername is EthernameRaw {\n', '\n', '  /* CONSTRUCTOR */\n', '\n', '  function Ethername() public {\n', '    commission = 200;\n', '\n', '    // reserved word\n', '    nameToRecord[bytes32(&#39;&#39;)] = Record(this, 0);\n', '\n', '    // initial register\n', '    _register(bytes32(&#39;ethername&#39;), this);\n', '    _register(bytes32(&#39;root&#39;), msg.sender);\n', '  }\n', '\n', '\n', '  /* FUNCTION */\n', '\n', '  function register(string _name) external payable {\n', '    rawRegister(_stringToBytes32(_name));\n', '  }\n', '\n', '  function transfer(address _to, string _name) external {\n', '    rawTransfer(_to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function approve(address _to, string _name) external {\n', '    rawApprove(_to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, string _name) external {\n', '    rawTransferFrom(_from, _to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function setPrice(string _name, uint256 _price) external {\n', '    rawSetPrice(_stringToBytes32(_name), _price);\n', '  }\n', '\n', '  function buy(string _name) external payable {\n', '    rawBuy(_stringToBytes32(_name));\n', '  }\n', '\n', '  function useName(string _name) external {\n', '    rawUseName(_stringToBytes32(_name));\n', '  }\n', '\n', '  function setAttribute(string _name, string _key, bytes _value) external {\n', '    rawSetAttribute(_stringToBytes32(_name), _stringToBytes32(_key), _value);\n', '  }\n', '\n', '  function wipeAttributes(string _name, bytes32[] _keys) external {\n', '    rawWipeAttributes(_stringToBytes32(_name), _keys);\n', '  }\n', '\n', '  function sendEther(string _name) external payable returns (bool _result) {\n', '    _result = rawSendEther(_stringToBytes32(_name));\n', '  }\n', '\n', '  /* VIEW FUNCTION */\n', '\n', '  function nameOf(address _address) external view returns (string _name) {\n', '    _name = _bytes32ToString(rawNameOf(_address));\n', '  }\n', '\n', '  function ownerOf(string _name) external view returns (address _owner) {\n', '    _owner = rawOwnerOf(_stringToBytes32(_name));\n', '  }\n', '\n', '  function detailsOf(string _name, string _key)\n', '    external\n', '    view\n', '    returns (address _owner, uint256 _price, bytes _value)\n', '  {\n', '    return rawDetailsOf(_stringToBytes32(_name), _stringToBytes32(_key));\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', '/** @title Manager\n', '  * @author M.H. Kang\n', '  */\n', 'contract Managed {\n', '\n', '  event Commission(uint256 basisPoint);\n', '\n', '  address public manager;\n', '  uint256 public commission;\n', '\n', '  function Managed() public {\n', '    manager = msg.sender;\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '  /* FUNCTION */\n', '\n', '  function setCommission(uint256 _commission) external {\n', '    require(_commission < 10000);\n', '    commission = _commission;\n', '\n', '    emit Commission(commission);\n', '  }\n', '\n', '  function withdrawBalance() external {\n', '    manager.transfer(address(this).balance);\n', '  }\n', '\n', '  function transferPower(address _newManager) external onlyManager {\n', '    manager = _newManager;\n', '  }\n', '\n', '  function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n', '    external\n', '    payable\n', '    onlyManager\n', '    returns (bool)\n', '  {\n', '    return _to.call.value(_value).gas(_gas)(_code);\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyManager\n', '  {\n', '    require(msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '/** @title EthernameRaw\n', '  * @author M.H. Kang\n', '  */\n', 'contract EthernameRaw is Managed {\n', '\n', '  /* EVENT */\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    bytes32 indexed name\n', '  );\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed approved,\n', '    bytes32 indexed name\n', '  );\n', '  event SendEther(\n', '    address indexed from,\n', '    address indexed to,\n', '    bytes32 sender,\n', '    bytes32 recipient,\n', '    uint256 value\n', '  );\n', '  event Name(address indexed owner, bytes32 indexed name);\n', '  event Price(bytes32 indexed name, uint256 price);\n', '  event Buy(bytes32 indexed name, address buyer, uint256 price);\n', '  event Attribute(bytes32 indexed name, bytes32 key);\n', '\n', '  /* DATA STRUCT */\n', '\n', '  struct Record {\n', '    address owner;\n', '    uint256 price;\n', '    mapping (bytes32 => bytes) attrs;\n', '  }\n', '\n', '  /* STORAGE */\n', '\n', '  string public constant name = "Ethername";\n', '  string public constant symbol = "ENM";\n', '\n', '  mapping (address => bytes32) public ownerToName;\n', '  mapping (bytes32 => Record) public nameToRecord;\n', '  mapping (bytes32 => address) public nameToApproved;\n', '\n', '  /* FUNCTION */\n', '\n', '  function rawRegister(bytes32 _name) public payable {\n', '    _register(_name, msg.sender);\n', '  }\n', '\n', '  function rawTransfer(address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    _transfer(msg.sender, _to, _name);\n', '  }\n', '\n', '  function rawApprove(address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    _approve(msg.sender, _to, _name);\n', '  }\n', '\n', '  function rawTransferFrom(address _from, address _to, bytes32 _name)\n', '    public\n', '    onlyOwner(_from, _name)\n', '    onlyApproved(msg.sender, _name)\n', '  {\n', '    _transfer(_from, _to, _name);\n', '  }\n', '\n', '  function rawSetPrice(bytes32 _name, uint256 _price)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    require(_price == uint256(uint128(_price)));\n', '    nameToRecord[_name].price = _price;\n', '\n', '    emit Price(_name, _price);\n', '  }\n', '\n', '  function rawBuy(bytes32 _name) public payable {\n', '    Record memory _record = nameToRecord[_name];\n', '    require(_record.price > 0);\n', '    uint256 _price = _computePrice(_record.price);\n', '    require(msg.value >= _price);\n', '\n', '    _record.owner.transfer(_record.price);\n', '    _transfer(_record.owner, msg.sender, _name);\n', '    msg.sender.transfer(msg.value - _price);\n', '\n', '    emit Buy(_name, msg.sender, _price);\n', '  }\n', '\n', '  function rawUseName(bytes32 _name) public onlyOwner(msg.sender, _name) {\n', '    _useName(msg.sender, _name);\n', '  }\n', '\n', '  function rawSetAttribute(bytes32 _name, bytes32 _key, bytes _value)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    nameToRecord[_name].attrs[_key] = _value;\n', '\n', '    emit Attribute(_name, _key);\n', '  }\n', '\n', '  function rawWipeAttributes(bytes32 _name, bytes32[] _keys)\n', '    public\n', '    onlyOwner(msg.sender, _name)\n', '  {\n', '    mapping (bytes32 => bytes) attrs = nameToRecord[_name].attrs;\n', '\t\tfor (uint i = 0; i < _keys.length; i++) {\n', '      delete attrs[_keys[i]];\n', '\n', '      emit Attribute(_name, _keys[i]);\n', '\t\t}\n', '  }\n', '\n', '  function rawSendEther(bytes32 _name) public payable returns (bool _result) {\n', '    address _to = nameToRecord[_name].owner;\n', '    _result = (_name != bytes32(0)) &&\n', '      (_to != address(0)) &&\n', '      _to.send(msg.value);\n', '    if (_result) {\n', '      emit SendEther(\n', '        msg.sender,\n', '        _to,\n', '        rawNameOf(msg.sender),\n', '        _name,\n', '        msg.value\n', '      );\n', '    }\n', '  }\n', '\n', '  /* VIEW FUNCTION */\n', '\n', '  function rawNameOf(address _address) public view returns (bytes32 _name) {\n', '    _name = ownerToName[_address];\n', '  }\n', '\n', '  function rawOwnerOf(bytes32 _name) public view returns (address _owner) {\n', '    _owner = nameToRecord[_name].owner;\n', '  }\n', '\n', '  function rawDetailsOf(bytes32 _name, bytes32 _key)\n', '    public\n', '    view\n', '    returns (address _owner, uint256 _price, bytes _value)\n', '  {\n', '    _owner = nameToRecord[_name].owner;\n', '    _price = _computePrice(nameToRecord[_name].price);\n', '    _value = nameToRecord[_name].attrs[_key];\n', '  }\n', '\n', '  /* INTERNAL FUNCTION */\n', '\n', '  function _register(bytes32 _name, address _to) internal {\n', '    require(nameToRecord[_name].owner == address(0));\n', '\t\tfor (uint i = 0; i < _name.length; i++) {\n', '\t\t \trequire((_name[i] == 0) ||\n', '              (_name[i] > 96 && _name[i] < 123) ||\n', '              (_name[i] > 47 && _name[i] < 58));\n', '\t\t}\n', '\n', '    _transfer(0, _to, _name);\n', '  }\n', '\n', '  /**\n', '   * @dev When transferred,\n', '   *  price and approved are set to 0 but attrs remains.\n', '   */\n', '  function _transfer(address _from, address _to, bytes32 _name) internal {\n', '    address _null = address(0);\n', '\n', '    if (nameToApproved[_name] != _null) {\n', '      _approve(_from, _null, _name);\n', '    }\n', '\n', '    if (ownerToName[_from] == _name) {\n', '      _useName(_from, 0);\n', '    }\n', '\n', '    nameToRecord[_name] = Record(_to, 0);\n', '\n', '    if (ownerToName[_to] == bytes32(0)) {\n', '      _useName(_to, _name);\n', '    }\n', '\n', '    emit Transfer(_from, _to, _name);\n', '  }\n', '\n', '  function _approve(address _owner, address _to, bytes32 _name) internal {\n', '    nameToApproved[_name] = _to;\n', '    emit Approval(_owner, _to, _name);\n', '  }\n', '\n', '  function _useName(address _owner, bytes32 _name) internal {\n', '    ownerToName[_owner] = _name;\n', '    emit Name(_owner, _name);\n', '  }\n', '\n', '  function _computePrice(uint256 _price) internal view returns (uint256) {\n', '    return _price * (10000 + commission) / 10000;\n', '  }\n', '\n', '  function _stringToBytes32(string _string)\n', '    internal\n', '    pure\n', '    returns (bytes32 _bytes32)\n', '  {\n', '    require(bytes(_string).length < 33);\n', '    assembly {\n', '      _bytes32 := mload(add(_string, 0x20))\n', '    }\n', '  }\n', '\n', '  function _bytes32ToString(bytes32 _bytes32)\n', '    internal\n', '    pure\n', '    returns (string _string)\n', '  {\n', '    assembly {\n', '      let m := mload(0x40)\n', '      mstore(m, 0x20)\n', '      mstore(add(m, 0x20), _bytes32)\n', '      mstore(0x40, add(m, 0x40))\n', '      _string := m\n', '    }\n', '  }\n', '\n', '  /* MODIFIER */\n', '\n', '  modifier onlyOwner(address _claimant, bytes32 _name) {\n', '    require(nameToRecord[_name].owner == _claimant);\n', '    _;\n', '  }\n', '\n', '  modifier onlyApproved(address _claimant, bytes32 _name) {\n', '    require(nameToApproved[_name] == _claimant);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '/** @title Ethername\n', '  * @author M.H. Kang\n', '  * @notice This contract is designed for any DAPPs to have\n', '  *  username feature without additional implementation.\n', '  */\n', 'contract Ethername is EthernameRaw {\n', '\n', '  /* CONSTRUCTOR */\n', '\n', '  function Ethername() public {\n', '    commission = 200;\n', '\n', '    // reserved word\n', "    nameToRecord[bytes32('')] = Record(this, 0);\n", '\n', '    // initial register\n', "    _register(bytes32('ethername'), this);\n", "    _register(bytes32('root'), msg.sender);\n", '  }\n', '\n', '\n', '  /* FUNCTION */\n', '\n', '  function register(string _name) external payable {\n', '    rawRegister(_stringToBytes32(_name));\n', '  }\n', '\n', '  function transfer(address _to, string _name) external {\n', '    rawTransfer(_to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function approve(address _to, string _name) external {\n', '    rawApprove(_to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, string _name) external {\n', '    rawTransferFrom(_from, _to, _stringToBytes32(_name));\n', '  }\n', '\n', '  function setPrice(string _name, uint256 _price) external {\n', '    rawSetPrice(_stringToBytes32(_name), _price);\n', '  }\n', '\n', '  function buy(string _name) external payable {\n', '    rawBuy(_stringToBytes32(_name));\n', '  }\n', '\n', '  function useName(string _name) external {\n', '    rawUseName(_stringToBytes32(_name));\n', '  }\n', '\n', '  function setAttribute(string _name, string _key, bytes _value) external {\n', '    rawSetAttribute(_stringToBytes32(_name), _stringToBytes32(_key), _value);\n', '  }\n', '\n', '  function wipeAttributes(string _name, bytes32[] _keys) external {\n', '    rawWipeAttributes(_stringToBytes32(_name), _keys);\n', '  }\n', '\n', '  function sendEther(string _name) external payable returns (bool _result) {\n', '    _result = rawSendEther(_stringToBytes32(_name));\n', '  }\n', '\n', '  /* VIEW FUNCTION */\n', '\n', '  function nameOf(address _address) external view returns (string _name) {\n', '    _name = _bytes32ToString(rawNameOf(_address));\n', '  }\n', '\n', '  function ownerOf(string _name) external view returns (address _owner) {\n', '    _owner = rawOwnerOf(_stringToBytes32(_name));\n', '  }\n', '\n', '  function detailsOf(string _name, string _key)\n', '    external\n', '    view\n', '    returns (address _owner, uint256 _price, bytes _value)\n', '  {\n', '    return rawDetailsOf(_stringToBytes32(_name), _stringToBytes32(_key));\n', '  }\n', '\n', '}']
