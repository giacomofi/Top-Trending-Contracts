['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' *\n', ' *\n', ' *\n', ' * ATTENTION!\n', ' *\n', ' *  HALO3D token machine!\n', ' */\n', '\n', 'contract ERC20Interface {\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', 'contract Halo3D {\n', '\n', '    function buy(address) public payable returns(uint256);\n', '    function transfer(address, uint256) public returns(bool);\n', '    function withdraw() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '    function reinvest() public;\n', '}\n', '\n', '/**\n', ' * Definition of contract accepting Halo3D tokens\n', ' * Games, casinos, anything can reuse this contract to support Halo3D tokens\n', ' */\n', 'contract AcceptsHalo3D {\n', '    Halo3D public tokenContract;\n', '\n', '    function AcceptsHalo3D(address _tokenContract) public {\n', '        tokenContract = Halo3D(_tokenContract);\n', '    }\n', '\n', '    modifier onlyTokenContract {\n', '        require(msg.sender == address(tokenContract));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Standard ERC677 function that will handle incoming token transfers.\n', '    *\n', '    * @param _from  Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data  Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public ownerCandidate;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        ownerCandidate = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == ownerCandidate);\n', '        owner = ownerCandidate;\n', '    }\n', '\n', '}\n', '\n', 'contract Halo3DDoublr is Owned, AcceptsHalo3D {\n', '\n', '    /**\n', '     * Events\n', '     */\n', '    event Deposit(uint256 amount, address depositer);\n', '    event Payout(uint256 amount, address creditor);\n', '\n', '    /**\n', '     * Structs\n', '     */\n', '    struct Participant {\n', '        address etherAddress;\n', '        uint256 payout;\n', '    }\n', '\n', '    //Total ETH managed over the lifetime of the contract\n', '    uint256 throughput;\n', '    //Total ETH received from dividends\n', '    uint256 dividends;\n', '    //The percent to return to depositers. 100 for 00%, 200 to double, etc.\n', '    uint256 public multiplier;\n', '    //Where in the line we are with creditors\n', '    uint256 public payoutOrder = 0;\n', '    //How much is owed to people\n', '    uint256 public backlog = 0;\n', '    //The creditor line\n', '    Participant[] public participants;\n', '    //How much each person is owed\n', '    mapping(address => uint256) public creditRemaining;\n', '\n', '\n', '    /**\n', '     * Constructor\n', '     */\n', '    function Halo3DDoublr(uint multiplierPercent, address _baseContract)\n', '      AcceptsHalo3D(_baseContract)\n', '      public {\n', '        multiplier = multiplierPercent;\n', '    }\n', '\n', '\n', '    /**\n', '     * Fallback function for the contract, protect investors\n', '     */\n', '    function() payable public {\n', '      // Not accepting Ether directly\n', '    }\n', '\n', '    /**\n', '    * Deposit Halo3D tokens to get in line to be credited back the multiplier as percent.\n', '    * This function can be called only via Halo3D contract using function\n', '    * Halo3D.transferAndCall(address, uint256, bytes)\n', '    *\n', '    * @dev Standard ERC677 function that will handle incoming token transfers.\n', '    * @param _from  Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data  Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data)\n', '      external\n', '      onlyTokenContract\n', '      returns (bool) {\n', '        require(!_isContract(_from));\n', '        require(_value <= 100 ether); // 100 H3D tokens\n', '        require(_value >= 1 ether); // 1 H3D token\n', '        //Compute how much to pay them\n', '        uint256 amountCredited = (_value * multiplier) / 100;\n', '        //Get in line to be paid back.\n', '        participants.push(Participant(_from, amountCredited));\n', '        //Increase the backlog by the amount owed\n', '        backlog += amountCredited;\n', '        //Increase the amount owed to this address\n', '        creditRemaining[_from] += amountCredited;\n', '        //Emit a deposit event.\n', '        emit Deposit(_value, _from);\n', '\n', '        //Increase our total throughput\n', '        throughput += _value;\n', '\n', '        uint balance = _value;\n', '\n', '        //While we still have money to send\n', '        reinvest(); // protect from people sending tokens to contract\n', '        while (balance > 0) {\n', '            //Either pay them what they are owed or however much we have, whichever is lower.\n', '            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n', '            //if we have something to pay them\n', '            if(payoutToSend > 0){\n', '                //subtract how much we&#39;ve spent\n', '                balance -= payoutToSend;\n', '                //subtract the amount paid from the amount owed\n', '                backlog -= payoutToSend;\n', '                //subtract the amount remaining they are owed\n', '                creditRemaining[participants[payoutOrder].etherAddress] -= payoutToSend;\n', '                //credit their account the amount they are being paid\n', '                participants[payoutOrder].payout -= payoutToSend;\n', '\n', '                //Try and pay them, making best effort. But if we fail? Run out of gas? That&#39;s not our problem any more\n', '                if(tokenContract.transfer(participants[payoutOrder].etherAddress, payoutToSend)) {\n', '                  //Record that they were paid\n', '                  emit Payout(payoutToSend, participants[payoutOrder].etherAddress);\n', '                }else{\n', '                    //undo the accounting, they are being skipped because they are not payable.\n', '                    balance += payoutToSend;\n', '                    backlog += payoutToSend;\n', '                    creditRemaining[participants[payoutOrder].etherAddress] += payoutToSend;\n', '                    participants[payoutOrder].payout += payoutToSend;\n', '                }\n', '\n', '            }\n', '            //If we still have balance left over\n', '            if(balance > 0){\n', '                // go to the next person in line\n', '                payoutOrder += 1;\n', '            }\n', '            //If we&#39;ve run out of people to pay, stop\n', '            if(payoutOrder >= participants.length){\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function _isContract(address _user) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(_user) }\n', '        return size > 0;\n', '    }\n', '\n', '    // Reinvest Halo3D Doublr dividends\n', '    // All the dividends this contract makes will be used to grow token fund for players\n', '    function reinvest() public {\n', '       if(tokenContract.myDividends(true) > 1) {\n', '         tokenContract.reinvest();\n', '       }\n', '    }\n', '\n', '    /**\n', '     * Number of participants who are still owed.\n', '     */\n', '    function backlogLength() public view returns (uint256){\n', '        return participants.length - payoutOrder;\n', '    }\n', '\n', '    /**\n', '     * Total amount still owed in credit to depositors.\n', '     */\n', '    function backlogAmount() public view returns (uint256){\n', '        return backlog;\n', '    }\n', '\n', '    /**\n', '     * Total number of deposits in the lifetime of the contract.\n', '     */\n', '    function totalParticipants() public view returns (uint256){\n', '        return participants.length;\n', '    }\n', '\n', '    /**\n', '     * Total amount of Halo3D that the contract has delt with so far.\n', '     */\n', '    function totalSpent() public view returns (uint256){\n', '        return throughput;\n', '    }\n', '\n', '    /**\n', '     * Amount still owed to an individual address\n', '     */\n', '    function amountOwed(address anAddress) public view returns (uint256) {\n', '        return creditRemaining[anAddress];\n', '    }\n', '\n', '     /**\n', '      * Amount owed to this person.\n', '      */\n', '    function amountIAmOwed() public view returns (uint256){\n', '        return amountOwed(msg.sender);\n', '    }\n', '}']