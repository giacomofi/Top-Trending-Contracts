['// hevm: flattened sources of contracts/LightPool.sol\n', 'pragma solidity ^0.4.21;\n', '\n', '////// contracts/interfaces/ERC20.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function decimals() public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '}\n', '\n', '////// contracts/interfaces/PriceSanityInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract PriceSanityInterface {\n', '    function checkPrice(address base, address quote, bool buy, uint256 baseAmount, uint256 quoteAmount) external view returns (bool result);\n', '}\n', '\n', '////// contracts/interfaces/WETHInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./ERC20.sol"; */\n', '\n', 'contract WETHInterface is ERC20 {\n', '  function() external payable;\n', '  function deposit() external payable;\n', '  function withdraw(uint wad) external;\n', '}\n', '\n', '////// contracts/LightPool.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./interfaces/WETHInterface.sol"; */\n', '/* import "./interfaces/PriceSanityInterface.sol"; */\n', '/* import "./interfaces/ERC20.sol"; */\n', '\n', 'contract LightPool {\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    struct TokenData {\n', '        address walletAddress;\n', '        PriceSanityInterface priceSanityContract;\n', '    }\n', '\n', '    // key = keccak256(token, base, walletAddress)\n', '    mapping(bytes32 => TokenData)       public markets;\n', '    mapping(address => bool)            public traders;\n', '    address                             public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWalletAddress(address base, address quote) {\n', '        bytes32 key = keccak256(base, quote, msg.sender);\n', '        require(markets[key].walletAddress == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTrader() {\n', '        require(traders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function LightPool() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setTrader(address trader, bool enabled) onlyOwner external {\n', '        traders[trader] = enabled;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner external {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '\n', '    event AddMarket(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function addMarket(ERC20 base, ERC20 quote, PriceSanityInterface priceSanityContract) external {\n', '        require(base != address(0));\n', '        require(quote != address(0));\n', '\n', '        // Make sure there&#39;s no such configured token\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        require(markets[tokenHash].walletAddress == address(0));\n', '\n', '        // Initialize token pool data\n', '        markets[tokenHash] = TokenData(msg.sender, priceSanityContract);\n', '        emit AddMarket(base, quote, msg.sender, priceSanityContract);\n', '    }\n', '\n', '    event RemoveMarket(address indexed base, address indexed quote, address indexed walletAddress);\n', '    function removeMarket(ERC20 base, ERC20 quote) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '\n', '        emit RemoveMarket(base, quote, tokenData.walletAddress);\n', '        delete markets[tokenHash];\n', '    }\n', '\n', '    event ChangePriceSanityContract(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function changePriceSanityContract(ERC20 base, ERC20 quote, PriceSanityInterface _priceSanityContract) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        tokenData.priceSanityContract = _priceSanityContract;\n', '        emit ChangePriceSanityContract(base, quote, msg.sender, _priceSanityContract);\n', '    }\n', '\n', '    event Trade(address indexed trader, address indexed baseToken, address indexed quoteToken, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount);\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) onlyTrader external {\n', '        bytes32 tokenHash = keccak256(base, quote, walletAddress);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        require(tokenData.walletAddress != address(0));\n', '        if (tokenData.priceSanityContract != address(0)) {\n', '            require(tokenData.priceSanityContract.checkPrice.gas(EXTERNAL_QUERY_GAS_LIMIT)(base, quote, buy, baseAmount, quoteAmount)); // Limit gas to prevent reentrancy\n', '        }\n', '        ERC20 takenToken;\n', '        ERC20 givenToken;\n', '        uint256 takenTokenAmount;\n', '        uint256 givenTokenAmount;\n', '        if (buy) {\n', '            takenToken = quote;\n', '            givenToken = base;\n', '            takenTokenAmount = quoteAmount;\n', '            givenTokenAmount = baseAmount;\n', '        } else {\n', '            takenToken = base;\n', '            givenToken = quote;\n', '            takenTokenAmount = baseAmount;\n', '            givenTokenAmount = quoteAmount;\n', '        }\n', '        require(takenTokenAmount != 0 && givenTokenAmount != 0);\n', '\n', '        // Swap!\n', '        require(takenToken.transferFrom(msg.sender, tokenData.walletAddress, takenTokenAmount));\n', '        require(givenToken.transferFrom(tokenData.walletAddress, msg.sender, givenTokenAmount));\n', '        emit Trade(msg.sender, base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '    }\n', '}']
['// hevm: flattened sources of contracts/LightPool.sol\n', 'pragma solidity ^0.4.21;\n', '\n', '////// contracts/interfaces/ERC20.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function decimals() public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '}\n', '\n', '////// contracts/interfaces/PriceSanityInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', 'contract PriceSanityInterface {\n', '    function checkPrice(address base, address quote, bool buy, uint256 baseAmount, uint256 quoteAmount) external view returns (bool result);\n', '}\n', '\n', '////// contracts/interfaces/WETHInterface.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./ERC20.sol"; */\n', '\n', 'contract WETHInterface is ERC20 {\n', '  function() external payable;\n', '  function deposit() external payable;\n', '  function withdraw(uint wad) external;\n', '}\n', '\n', '////// contracts/LightPool.sol\n', '/* pragma solidity ^0.4.21; */\n', '\n', '/* import "./interfaces/WETHInterface.sol"; */\n', '/* import "./interfaces/PriceSanityInterface.sol"; */\n', '/* import "./interfaces/ERC20.sol"; */\n', '\n', 'contract LightPool {\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    struct TokenData {\n', '        address walletAddress;\n', '        PriceSanityInterface priceSanityContract;\n', '    }\n', '\n', '    // key = keccak256(token, base, walletAddress)\n', '    mapping(bytes32 => TokenData)       public markets;\n', '    mapping(address => bool)            public traders;\n', '    address                             public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWalletAddress(address base, address quote) {\n', '        bytes32 key = keccak256(base, quote, msg.sender);\n', '        require(markets[key].walletAddress == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTrader() {\n', '        require(traders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function LightPool() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setTrader(address trader, bool enabled) onlyOwner external {\n', '        traders[trader] = enabled;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner external {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '\n', '    event AddMarket(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function addMarket(ERC20 base, ERC20 quote, PriceSanityInterface priceSanityContract) external {\n', '        require(base != address(0));\n', '        require(quote != address(0));\n', '\n', "        // Make sure there's no such configured token\n", '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        require(markets[tokenHash].walletAddress == address(0));\n', '\n', '        // Initialize token pool data\n', '        markets[tokenHash] = TokenData(msg.sender, priceSanityContract);\n', '        emit AddMarket(base, quote, msg.sender, priceSanityContract);\n', '    }\n', '\n', '    event RemoveMarket(address indexed base, address indexed quote, address indexed walletAddress);\n', '    function removeMarket(ERC20 base, ERC20 quote) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '\n', '        emit RemoveMarket(base, quote, tokenData.walletAddress);\n', '        delete markets[tokenHash];\n', '    }\n', '\n', '    event ChangePriceSanityContract(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\n', '    function changePriceSanityContract(ERC20 base, ERC20 quote, PriceSanityInterface _priceSanityContract) onlyWalletAddress(base, quote) external {\n', '        bytes32 tokenHash = keccak256(base, quote, msg.sender);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        tokenData.priceSanityContract = _priceSanityContract;\n', '        emit ChangePriceSanityContract(base, quote, msg.sender, _priceSanityContract);\n', '    }\n', '\n', '    event Trade(address indexed trader, address indexed baseToken, address indexed quoteToken, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount);\n', '    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) onlyTrader external {\n', '        bytes32 tokenHash = keccak256(base, quote, walletAddress);\n', '        TokenData storage tokenData = markets[tokenHash];\n', '        require(tokenData.walletAddress != address(0));\n', '        if (tokenData.priceSanityContract != address(0)) {\n', '            require(tokenData.priceSanityContract.checkPrice.gas(EXTERNAL_QUERY_GAS_LIMIT)(base, quote, buy, baseAmount, quoteAmount)); // Limit gas to prevent reentrancy\n', '        }\n', '        ERC20 takenToken;\n', '        ERC20 givenToken;\n', '        uint256 takenTokenAmount;\n', '        uint256 givenTokenAmount;\n', '        if (buy) {\n', '            takenToken = quote;\n', '            givenToken = base;\n', '            takenTokenAmount = quoteAmount;\n', '            givenTokenAmount = baseAmount;\n', '        } else {\n', '            takenToken = base;\n', '            givenToken = quote;\n', '            takenTokenAmount = baseAmount;\n', '            givenTokenAmount = quoteAmount;\n', '        }\n', '        require(takenTokenAmount != 0 && givenTokenAmount != 0);\n', '\n', '        // Swap!\n', '        require(takenToken.transferFrom(msg.sender, tokenData.walletAddress, takenTokenAmount));\n', '        require(givenToken.transferFrom(tokenData.walletAddress, msg.sender, givenTokenAmount));\n', '        emit Trade(msg.sender, base, quote, walletAddress, buy, baseAmount, quoteAmount);\n', '    }\n', '}']
