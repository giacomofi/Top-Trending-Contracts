['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/ReinvestProxy.sol\n', '\n', '/*\n', ' * Visit: https://p4rty.io\n', ' * Discord: https://discord.gg/7y3DHYF\n', ' * Copyright Mako Labs LLC 2018 All Rights Reseerved\n', '*/\n', 'interface ReinvestProxy {\n', '\n', '    /// @dev Converts all incoming ethereum to tokens for the caller,\n', '    function reinvestFor(address customer) external payable;\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable {\n', '  mapping(address => bool) public whitelist;\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    require(whitelist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (!whitelist[addr]) {\n', '      whitelist[addr] = true;\n', '      emit WhitelistedAddressAdded(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (addAddressToWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (whitelist[addr]) {\n', '      whitelist[addr] = false;\n', '      emit WhitelistedAddressRemoved(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (removeAddressFromWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/P4RTYDaoVault.sol\n', '\n', '/*\n', ' * Visit: https://p4rty.io\n', ' * Discord: https://discord.gg/7y3DHYF\n', ' * Copyright Mako Labs LLC 2018 All Rights Reseerved\n', '*/\n', '\n', 'contract P4RTYDaoVault is Whitelist {\n', '\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /// @dev Only people with profits\n', '    modifier onlyDivis {\n', '        require(myDividends() > 0);\n', '        _;\n', '    }\n', '\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '\n', '    event onStake(\n', '        address indexed customerAddress,\n', '        uint256 stakedTokens,\n', '        uint256 timestamp\n', '    );\n', '\n', '    event onDeposit(\n', '        address indexed fundingSource,\n', '        uint256 ethDeposited,\n', '        uint    timestamp\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn,\n', '        uint timestamp\n', '    );\n', '\n', '    event onReinvestmentProxy(\n', '        address indexed customerAddress,\n', '        address indexed destinationAddress,\n', '        uint256 ethereumReinvested\n', '    );\n', '\n', '\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '\n', '\n', '    uint256 constant internal magnitude = 2 ** 64;\n', '\n', '\n', '    /*=================================\n', '     =            DATASETS            =\n', '     ================================*/\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '\n', '    //Initial deposits backed by one virtual share that cannot be unstaked\n', '    uint256 internal tokenSupply_ = 1;\n', '    uint256 internal profitPerShare_;\n', '\n', '    ERC20 public p4rty;\n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS           =\n', '    =======================================*/\n', '\n', '    constructor(address _p4rtyAddress) Ownable() public {\n', '\n', '        p4rty = ERC20(_p4rtyAddress);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function to handle ethereum that was send straight to the contract\n', '     */\n', '    function() payable public {\n', '        deposit();\n', '    }\n', '\n', '    /// @dev Internal function to actually purchase the tokens.\n', '    function deposit() payable public  {\n', '\n', '        uint256 _incomingEthereum = msg.value;\n', '        address _fundingSource = msg.sender;\n', '\n', '        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '        profitPerShare_ += (_incomingEthereum * magnitude / tokenSupply_);\n', '\n', '\n', '        // fire event\n', '        emit onDeposit(_fundingSource, _incomingEthereum, now);\n', '\n', '    }\n', '\n', '    function stake(uint _amountOfTokens) public {\n', '\n', '\n', '        //Approval has to happen separately directly with p4rty\n', '        //p4rty.approve(<DAO>, _amountOfTokens);\n', '\n', '        address _customerAddress = msg.sender;\n', '\n', '        //Customer needs to have P4RTY\n', '        require(p4rty.balanceOf(_customerAddress) > 0);\n', '\n', '\n', '\n', '        uint256 _balance = p4rty.balanceOf(_customerAddress);\n', '        uint256 _stakeAmount = Math.min256(_balance,_amountOfTokens);\n', '\n', '        require(_stakeAmount > 0);\n', '        p4rty.transferFrom(_customerAddress, address(this), _stakeAmount);\n', '\n', '        //Add to the tokenSupply_\n', '        tokenSupply_ = SafeMath.add(tokenSupply_, _stakeAmount);\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _stakeAmount);\n', '\n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n", "        // really i know you think you do but you don't\n", '        int256 _updatedPayouts = (int256) (profitPerShare_ * _stakeAmount);\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '\n', '        emit onStake(_customerAddress, _amountOfTokens, now);\n', '    }\n', '\n', '    /// @dev Withdraws all of the callers earnings.\n', '    function withdraw() onlyDivis public {\n', '\n', '        address _customerAddress = msg.sender;\n', '        // setup data\n', '        uint256 _dividends = dividendsOf(_customerAddress);\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '\n', '        // lambo delivery service\n', '        _customerAddress.transfer(_dividends);\n', '\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends, now);\n', '    }\n', '\n', '    function reinvestByProxy(address _customerAddress) onlyWhitelisted public {\n', '        // setup data\n', '        uint256 _dividends = dividendsOf(_customerAddress);\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        ReinvestProxy reinvestProxy =  ReinvestProxy(msg.sender);\n', '        reinvestProxy.reinvestFor.value(_dividends)(_customerAddress);\n', '\n', '        emit onReinvestmentProxy(_customerAddress,msg.sender,_dividends);\n', '\n', '    }\n', '\n', '\n', '    /*=====================================\n', '    =      HELPERS AND CALCULATORS        =\n', '    =====================================*/\n', '\n', '    /**\n', '     * @dev Method to view the current Ethereum stored in the contract\n', '     *  Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /// @dev Retrieve the total token supply.\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /// @dev Retrieve the tokens owned by the caller.\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /// @dev The percentage of the\n', '    function votingPower(address _customerAddress) public view returns (uint256) {\n', '        return SafeMath.div(balanceOf(_customerAddress), totalSupply());\n', '    }\n', '\n', '    /**\n', '     * @dev Retrieve the dividends owned by the caller.\n', '     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     *  But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends() public view returns (uint256) {\n', '        return dividendsOf(msg.sender);\n', '\n', '    }\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /// @dev Retrieve the dividend balance of any single address.\n', '    function dividendsOf(address _customerAddress) public view returns (uint256) {\n', '        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Bankroll.sol\n', '\n', 'interface Bankroll {\n', '\n', '    //Customer functions\n', '\n', '    /// @dev Stores ETH funds for customer\n', '    function credit(address _customerAddress, uint256 amount) external returns (uint256);\n', '\n', '    /// @dev Debits address by an amount\n', '    function debit(address _customerAddress, uint256 amount) external returns (uint256);\n', '\n', '    /// @dev Withraws balance for address; returns amount sent\n', '    function withdraw(address _customerAddress) external returns (uint256);\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress) external view returns (uint256);\n', '\n', '    /// @dev Stats of any single address\n', '    function statsOf(address _customerAddress) external view returns (uint256[8]);\n', '\n', '\n', '    // System functions\n', '\n', '    // @dev Deposit funds\n', '    function deposit() external payable;\n', '\n', '    // @dev Deposit on behalf of an address; it is not a credit\n', '    function depositBy(address _customerAddress) external payable;\n', '\n', '    // @dev Distribute house profit\n', '    function houseProfit(uint256 amount)  external;\n', '\n', '\n', '    /// @dev Get all the ETH stored in contract minus credits to customers\n', '    function netEthereumBalance() external view returns (uint256);\n', '\n', '\n', '    /// @dev Get all the ETH stored in contract\n', '    function totalEthereumBalance() external view returns (uint256);\n', '\n', '}\n', '\n', '// File: contracts/P4RTYRelay.sol\n', '\n', '/*\n', ' * Visit: https://p4rty.io\n', ' * Discord: https://discord.gg/7y3DHYF\n', '*/\n', '\n', 'interface P4RTYRelay {\n', '    /**\n', '    * @dev Will relay to internal implementation\n', '    * @param beneficiary Token purchaser\n', '    * @param tokenAmount Number of tokens to be minted\n', '    */\n', '    function relay(address beneficiary, uint256 tokenAmount) external;\n', '}\n', '\n', '// File: contracts/SessionQueue.sol\n', '\n', '/// A FIFO queue for storing addresses\n', 'contract SessionQueue {\n', '\n', '    mapping(uint256 => address) private queue;\n', '    uint256 private first = 1;\n', '    uint256 private last = 0;\n', '\n', '    /// @dev Push into queue\n', '    function enqueue(address data) internal {\n', '        last += 1;\n', '        queue[last] = data;\n', '    }\n', '\n', '    /// @dev Returns true if the queue has elements in it\n', '    function available() internal view returns (bool) {\n', '        return last >= first;\n', '    }\n', '\n', '    /// @dev Returns the size of the queue\n', '    function depth() internal view returns (uint256) {\n', '        return last - first + 1;\n', '    }\n', '\n', '    /// @dev Pops from the head of the queue\n', '    function dequeue() internal returns (address data) {\n', '        require(last >= first);\n', '        // non-empty queue\n', '\n', '        data = queue[first];\n', '\n', '        delete queue[first];\n', '        first += 1;\n', '    }\n', '\n', '    /// @dev Returns the head of the queue without a pop\n', '    function peek() internal view returns (address data) {\n', '        require(last >= first);\n', '        // non-empty queue\n', '\n', '        data = queue[first];\n', '    }\n', '}\n', '\n', '// File: contracts/P6.sol\n', '\n', '// solhint-disable-line\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', ' * Visit: https://p4rty.io\n', ' * Discord: https://discord.gg/7y3DHYF\n', ' * Stable + DIVIS: Whale and Minow Friendly\n', ' * Fees balanced for maximum dividends for ALL\n', ' * Active depositors rewarded with P4RTY tokens\n', ' * 50% of ETH value in earned P4RTY token rewards\n', ' * 2% of dividends fund a gaming bankroll; gaming profits are paid back into P6\n', ' * P4RTYRelay is notified on all dividend producing transactions\n', ' * Smart Launch phase which is anti-whale & anti-snipe\n', ' *\n', ' * P6\n', ' * The worry free way to earn A TON OF ETH & P4RTY reward tokens\n', ' *\n', ' * -> What?\n', ' * The first Ethereum Bonded Pure Dividend Token:\n', ' * [✓] The only dividend printing press that is part of the P4RTY Entertainment Network\n', ' * [✓] Earn ERC20 P4RTY tokens on all ETH deposit activities\n', ' * [✓] 3% P6 Faucet for free P6 / P4RTY\n', ' * [✓] Auto-Reinvests\n', ' * [✓] 10% exchange fees on buys and sells\n', ' * [✓] 100 tokens to activate faucet\n', ' *\n', ' * -> How?\n', ' * To replay or use the faucet the contract must be fully launched\n', ' * To sell or transfer you need to be vested (maximum of 3 days) after a reinvest\n', '*/\n', '\n', 'contract P6 is Whitelist, SessionQueue {\n', '\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /// @dev Only people with tokens\n', '    modifier onlyTokenHolders {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only people with profits\n', '    modifier onlyDivis {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only invested; If participating in prelaunch have to buy tokens\n', '    modifier invested {\n', '        require(stats[msg.sender].invested > 0, "Must buy tokens once to withdraw");\n', '\n', '        _;\n', '\n', '    }\n', '\n', '    /// @dev After every reinvest features are protected by a cooloff to vest funds\n', '    modifier cooledOff {\n', '        require(msg.sender == owner && !contractIsLaunched || now - bot[msg.sender].coolOff > coolOffPeriod);\n', '        _;\n', '    }\n', '\n', '    /// @dev The faucet has a rewardPeriod\n', '    modifier teamPlayer {\n', '        require(msg.sender == owner || now - lastReward[msg.sender] > rewardProcessingPeriod, "No spamming");\n', '        _;\n', '    }\n', '\n', '    /// @dev Functions only available after launch\n', '    modifier launched {\n', '        require(contractIsLaunched || msg.sender == owner, "Contract not lauched");\n', '        _;\n', '    }\n', '\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '\n', '    event onLog(\n', '        string heading,\n', '        address caller,\n', '        address subj,\n', '        uint val\n', '    );\n', '\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned,\n', '        uint timestamp,\n', '        uint256 price\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '\n', '    event onCommunityReward(\n', '        address indexed sourceAddress,\n', '        address indexed destinationAddress,\n', '        uint256 ethereumEarned\n', '    );\n', '\n', '    event onReinvestmentProxy(\n', '        address indexed customerAddress,\n', '        address indexed destinationAddress,\n', '        uint256 ethereumReinvested\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    event onDeposit(\n', '        address indexed customerAddress,\n', '        uint256 ethereumDeposited\n', '    );\n', '\n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '\n', '    /// @dev 10% dividends for token purchase\n', '    uint256  internal entryFee_ = 10;\n', '\n', '    /// @dev 1% dividends for token transfer\n', '    uint256  internal transferFee_ = 1;\n', '\n', '    /// @dev 10% dividends for token selling\n', '    uint256  internal exitFee_ = 10;\n', '\n', '    /// @dev 3% of entryFee_  is given to faucet\n', '    /// traditional referral mechanism repurposed as a many to many faucet\n', '    /// powers auto reinvest\n', '    uint256  internal referralFee_ = 30;\n', '\n', '    /// @dev 20% of entryFee/exit fee is given to Bankroll\n', '    uint256  internal maintenanceFee_ = 20;\n', '    address  internal maintenanceAddress;\n', '\n', '    //Advanced Config\n', '    uint256 constant internal bankrollThreshold = 0.5 ether;\n', '    uint256 constant internal botThreshold = 0.01 ether;\n', '    uint256 constant rewardProcessingPeriod = 6 hours;\n', '    uint256 constant reapPeriod = 7 days;\n', '    uint256 public  maxProcessingCap = 10;\n', '\n', '    uint256 public coolOffPeriod = 3 days;\n', '    uint256 public launchETHMaximum = 20 ether;\n', '    bool public contractIsLaunched = false;\n', '    uint public lastReaped;\n', '\n', '\n', '    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\n', '    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\n', '\n', '    uint256 constant internal magnitude = 2 ** 64;\n', '\n', '    /// @dev proof of stake (defaults at 100 tokens)\n', '    uint256 public stakingRequirement = 100e18;\n', '\n', '\n', '    /*=================================\n', '     =            DATASETS            =\n', '     ================================*/\n', '\n', '    // bookkeeping for autoreinvest\n', '    struct Bot {\n', '        bool active;\n', '        bool queued;\n', '        uint256 lastBlock;\n', '        uint256 coolOff;\n', '    }\n', '\n', '    // Onchain Stats!!!\n', '    struct Stats {\n', '        uint invested;\n', '        uint reinvested;\n', '        uint withdrawn;\n', '        uint rewarded;\n', '        uint contributed;\n', '        uint transferredTokens;\n', '        uint receivedTokens;\n', '        uint xInvested;\n', '        uint xReinvested;\n', '        uint xRewarded;\n', '        uint xContributed;\n', '        uint xWithdrawn;\n', '        uint xTransferredTokens;\n', '        uint xReceivedTokens;\n', '    }\n', '\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal lastReward;\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => Bot) internal bot;\n', '    mapping(address => Stats) internal stats;\n', '    //on chain referral tracking\n', '    mapping(address => address) public referrals;\n', '    uint256 internal tokenSupply_;\n', '    uint256 internal profitPerShare_;\n', '\n', '    P4RTYRelay public relay;\n', '    Bankroll public bankroll;\n', '    bool internal bankrollEnabled = true;\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS           =\n', '    =======================================*/\n', '\n', '    constructor(address relayAddress)  public {\n', '\n', '        relay = P4RTYRelay(relayAddress);\n', '        updateMaintenanceAddress(msg.sender);\n', '    }\n', '\n', '    //Maintenance Functions\n', '\n', '    /// @dev Minted P4RTY tokens are sent to the maintenance address\n', '    function updateMaintenanceAddress(address maintenance) onlyOwner public {\n', '        maintenanceAddress = maintenance;\n', '    }\n', '\n', '    /// @dev Update the bankroll; 2% of dividends go to the bankroll\n', '    function updateBankrollAddress(address bankrollAddress) onlyOwner public {\n', '        bankroll = Bankroll(bankrollAddress);\n', '    }\n', '\n', '    /// @dev The cap determines the amount of addresses processed when a user runs the faucet\n', '    function updateProcessingCap(uint cap) onlyOwner public {\n', '        require(cap >= 5 && cap <= 15, "Capacity set outside of policy range");\n', '        maxProcessingCap = cap;\n', '    }\n', '\n', '    /// @dev Updates the coolOff period where reinvest must vest\n', '    function updateCoolOffPeriod(uint coolOff) onlyOwner public {\n', '        require(coolOff >= 5 minutes && coolOff <= 3 days);\n', '        coolOffPeriod = coolOff;\n', '    }\n', '\n', '    /// @dev Opens the contract for public use outside of the launch phase\n', '    function launchContract() onlyOwner public {\n', '        contractIsLaunched = true;\n', '    }\n', '\n', '\n', '    //Bot Functions\n', '\n', '    /* Activates the bot and queues if necessary; else removes */\n', '    function activateBot(bool auto) public {\n', '        bot[msg.sender].active = auto;\n', '\n', '        //Spam protection for customerAddress\n', '        if (bot[msg.sender].active) {\n', '            if (!bot[msg.sender].queued) {\n', '                bot[msg.sender].queued = true;\n', '                enqueue(msg.sender);\n', '            }\n', '        }\n', '    }\n', '\n', '    /* Returns if the sender has the reinvestment not enabled */\n', '    function botEnabled() public view returns (bool){\n', '        return bot[msg.sender].active;\n', '    }\n', '\n', '\n', '    function fundBankRoll(uint256 amount) internal {\n', '        bankroll.deposit.value(amount)();\n', '    }\n', '\n', '    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n', '    function buyFor(address _customerAddress) onlyWhitelisted public payable returns (uint256) {\n', '        return purchaseTokens(_customerAddress, msg.value);\n', '    }\n', '\n', '    /// @dev Converts all incoming ethereum to tokens for the caller\n', '    function buy() public payable returns (uint256) {\n', '        if (contractIsLaunched){\n', '            //ETH sent during prelaunch needs to be processed\n', '            if(stats[msg.sender].invested == 0 && referralBalance_[msg.sender] > 0){\n', '                reinvestFor(msg.sender);\n', '            }\n', '            return purchaseTokens(msg.sender, msg.value);\n', '        }  else {\n', '            //Just deposit funds\n', '            return deposit();\n', '        }\n', '    }\n', '\n', '    function deposit() internal returns (uint256) {\n', '        require(msg.value > 0);\n', '\n', '        //Just add to the referrals for sidelined ETH\n', '        referralBalance_[msg.sender] = SafeMath.add(referralBalance_[msg.sender], msg.value);\n', '\n', '        require(referralBalance_[msg.sender] <= launchETHMaximum, "Exceeded investment cap");\n', '\n', '        emit onDeposit(msg.sender, msg.value);\n', '\n', '        return 0;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function to handle ethereum that was send straight to the contract\n', '     *  Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function() payable public {\n', '        purchaseTokens(msg.sender, msg.value);\n', '    }\n', '\n', "    /// @dev Converts all of caller's dividends to tokens.\n", '    function reinvest() onlyDivis launched public {\n', '        reinvestFor(msg.sender);\n', '    }\n', '\n', '    /// @dev Allows owner to reinvest on behalf of a supporter\n', '    function investSupporter(address _customerAddress) public onlyOwner {\n', '        require(!contractIsLaunched, "Contract already opened");\n', '        reinvestFor(_customerAddress);\n', '    }\n', '\n', '    /// @dev Internal utility method for reinvesting\n', '    function reinvestFor(address _customerAddress) internal {\n', '\n', '        // fetch dividends\n', '        uint256 _dividends = totalDividends(_customerAddress, false);\n', '        // retrieve ref. bonus later in the code\n', '\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '        // retrieve ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(_customerAddress, _dividends);\n', '\n', '        // fire event\n', '        emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '\n', '        //Stats\n', '        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\n', '        stats[_customerAddress].xReinvested += 1;\n', '\n', '        //Refresh the coolOff\n', '        bot[_customerAddress].coolOff = now;\n', '\n', '    }\n', '\n', '    /// @dev Withdraws all of the callers earnings.\n', '    function withdraw() onlyDivis  invested public {\n', '        withdrawFor(msg.sender);\n', '    }\n', '\n', '    /// @dev Utility function for withdrawing earnings\n', '    function withdrawFor(address _customerAddress) internal {\n', '\n', '        // setup data\n', '        uint256 _dividends = totalDividends(_customerAddress, false);\n', '        // get ref. bonus later in the code\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n', '\n', '        // add ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // lambo delivery service\n', '        _customerAddress.transfer(_dividends);\n', '\n', '        //stats\n', '        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\n', '        stats[_customerAddress].xWithdrawn += 1;\n', '\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '\n', '    /// @dev Liquifies tokens to ethereum.\n', '    function sell(uint256 _amountOfTokens) onlyTokenHolders cooledOff public {\n', '        address _customerAddress = msg.sender;\n', '\n', '        //Selling deactivates auto reinvest\n', '        bot[_customerAddress].active = false;\n', '\n', '\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '\n', '\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\n', '        //maintenance and referral come out of the exitfee\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _maintenance);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _undividedDividends);\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '\n', '        //Apply maintenance fee to the bankroll\n', '        fundBankRoll(_maintenance);\n', '\n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply_ > 0) {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        }\n', '\n', '        // fire event\n', '        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\n', '\n', '        //GO!!! Bankroll Bot GO!!!\n', '        brbReinvest(_customerAddress);\n', '    }\n', '\n', '    //@dev Bankroll Bot can only transfer 10% of funds during a reapPeriod\n', '    //Its funds will always be locked because it always reinvests\n', '    function reap(address _toAddress) public onlyOwner {\n', '        require(now - lastReaped > reapPeriod, "Reap not available, too soon");\n', '        lastReaped = now;\n', '        transferTokens(owner, _toAddress, SafeMath.div(balanceOf(owner), 10));\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from the caller to a new holder.\n', "     *  Remember, there's a 1% fee here as well.\n", '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders cooledOff external returns (bool){\n', '        address _customerAddress = msg.sender;\n', '        return transferTokens(_customerAddress, _toAddress, _amountOfTokens);\n', '    }\n', '\n', '    /// @dev Utility function for transfering tokens\n', '    function transferTokens(address _customerAddress, address _toAddress, uint256 _amountOfTokens)  internal returns (bool){\n', '\n', '        // make sure we have the requested tokens\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        // withdraw all outstanding dividends first\n', '        if (totalDividends(_customerAddress,true) > 0) {\n', '            withdrawFor(_customerAddress);\n', '        }\n', '\n', '        // liquify a percentage of the tokens that are transfered\n', '        // these are dispersed to shareholders\n', '        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '        // burn the fee tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '        // update dividend trackers\n', '        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n', '\n', '        // disperse dividends among holders\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '\n', '        // fire event\n', '        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '        //Stats\n', '        stats[_customerAddress].xTransferredTokens += 1;\n', '        stats[_customerAddress].transferredTokens += _amountOfTokens;\n', '        stats[_toAddress].receivedTokens += _taxedTokens;\n', '        stats[_toAddress].xReceivedTokens += 1;\n', '\n', '        // ERC20\n', '        return true;\n', '    }\n', '\n', '\n', '    /*=====================================\n', '    =      HELPERS AND CALCULATORS        =\n', '    =====================================*/\n', '\n', '    /**\n', '     * @dev Method to view the current Ethereum stored in the contract\n', '     *  Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /// @dev Retrieve the total token supply.\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /// @dev Retrieve the tokens owned by the caller.\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Retrieve the dividends owned by the caller.\n', '     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     *  But in the internal calculations, we want them separate.\n', '     */\n', '    /**\n', '     * @dev Retrieve the dividends owned by the caller.\n', '     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n', '     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     *  But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n', '        return totalDividends(msg.sender, _includeReferralBonus);\n', '    }\n', '\n', '    function totalDividends(address _customerAddress, bool _includeReferralBonus) internal view returns (uint256) {\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '    }\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /// @dev Stats of any single address\n', '    function statsOf(address _customerAddress) public view returns (uint256[14]){\n', '        Stats memory s = stats[_customerAddress];\n', '        uint256[14] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested];\n', '        return statArray;\n', '    }\n', '\n', '    /// @dev Retrieve the dividend balance of any single address.\n', '    function dividendsOf(address _customerAddress) public view returns (uint256) {\n', '        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '\n', '    /// @dev Return the sell price of 1 individual token.\n', '    function sellPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, exitFee_);\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '\n', '    }\n', '\n', '    /// @dev Return the buy price of 1 individual token.\n', '    function buyPrice() public view returns (uint256) {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, entryFee_);\n', '            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '\n', '    /// @dev Internal function to actually purchase the tokens.\n', '    function purchaseTokens(address _customerAddress, uint256 _incomingEthereum) internal returns (uint256) {\n', '        // data setup\n', '        address _referredBy = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n', '        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\n', '        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\n', '        //maintenance and referral come out of the buyin\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, SafeMath.add(_referralBonus, _maintenance));\n', '        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        uint256 _fee = _dividends * magnitude;\n', '        uint256 _tokenAllocation = SafeMath.div(_incomingEthereum, 2);\n', '\n', '\n', '        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n', '        // (or hackers)\n', '        // and yes we know that the safemath function automatically rules out the "greater then" equasion.\n', '        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '        //Apply maintenance fee to bankroll\n', '        fundBankRoll(_maintenance);\n', '\n', '        // is the user referred by a masternode?\n', '        if (\n', '\n', '        // no cheating!\n', '            _referredBy != _customerAddress &&\n', '\n', '            // does the referrer have at least X whole tokens?\n', '            // i.e is the referrer a godly chad masternode\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '\n', '            //Stats\n', '            stats[_referredBy].rewarded = SafeMath.add(stats[_referredBy].rewarded, _referralBonus);\n', '            stats[_referredBy].xRewarded += 1;\n', '            stats[_customerAddress].contributed = SafeMath.add(stats[_customerAddress].contributed, _referralBonus);\n', '            stats[_customerAddress].xContributed += 1;\n', '\n', '            //It pays to play\n', '            emit onCommunityReward(_customerAddress, _referredBy, _referralBonus);\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '            _fee = _dividends * magnitude;\n', '        }\n', '\n', "        // we can't give people infinite ethereum\n", '        if (tokenSupply_ > 0) {\n', '            // add tokens to the pool\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n', '\n', '            // calculate the amount of tokens the customer receives over his purchase\n', '            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n", "        // really i know you think you do but you don't\n", '        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens - _fee);\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '\n', '        //Notifying the relay is simple and should represent the total economic activity which is the _incomingEthereum\n', '        //Every player is a customer and mints their own tokens when the buy or reinvest, relay P4RTY 50/50\n', '        relay.relay(maintenanceAddress, _tokenAllocation);\n', '        relay.relay(_customerAddress, _tokenAllocation);\n', '\n', '        // fire event\n', '        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\n', '\n', '        //Stats\n', '        stats[_customerAddress].invested = SafeMath.add(stats[_customerAddress].invested, _incomingEthereum);\n', '        stats[_customerAddress].xInvested += 1;\n', '\n', '        //GO!!! Bankroll Bot GO!!!\n', '        brbReinvest(_customerAddress);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', "     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '        (\n', '        (\n', '        // underflow attempts BTFO\n', '        SafeMath.sub(\n', '            (sqrt\n', '        (\n', '            (_tokenPriceInitial ** 2)\n', '            +\n', '            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\n', '            +\n', '            (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2))\n', '            +\n', '            (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\n', '        )\n', '            ), _tokenPriceInitial\n', '        )\n', '        ) / (tokenPriceIncremental_)\n', '        ) - (tokenSupply_)\n', '        ;\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * Calculate token sell value.\n', "     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256)\n', '    {\n', '\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '        (\n', '        // underflow attempts BTFO\n', '        SafeMath.sub(\n', '            (\n', '            (\n', '            (\n', '            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n', '            ) - tokenPriceIncremental_\n', '            ) * (tokens_ - 1e18)\n', '            ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\n', '        )\n', '        / 1e18);\n', '        return _etherReceived;\n', '    }\n', '\n', '\n', '    /// @dev Returns true if the tokens are fully vested after a reinvest\n', '    function isVested() public view returns (bool) {\n', '        return now - bot[msg.sender].coolOff > coolOffPeriod;\n', '    }\n', '\n', '    /*\n', '        Is end user eligible to process rewards?\n', '    */\n', '    function rewardAvailable() public view returns (bool){\n', '        return available() && now - lastReward[msg.sender] > rewardProcessingPeriod &&\n', '        tokenBalanceLedger_[msg.sender] >= stakingRequirement;\n', '    }\n', '\n', '    /// @dev Returns timer info used for the vesting and the faucet\n', '    function timerInfo() public view returns (uint, uint[2], uint[2]){\n', '        return (now, [bot[msg.sender].coolOff, coolOffPeriod], [lastReward[msg.sender], rewardProcessingPeriod]);\n', '    }\n', '\n', '\n', '    //This is where all your gas goes, sorry\n', '    //Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    //\n', '    // BankRollBot Functions\n', '    //\n', '\n', '    //Reinvest on all buys and sells\n', '    function brbReinvest(address _customerAddress) internal {\n', '        if (_customerAddress != owner && bankrollEnabled) {\n', '            if (totalDividends(owner, true) > bankrollThreshold) {\n', '                reinvestFor(owner);\n', '            }\n', '        }\n', '\n', '\n', '    }\n', '\n', '    /*\n', '        Can only be run once per day from the caller avoid bots\n', '        Minimum of 100 P6\n', '        Minimum of 5 P4RTY + amount minted based on dividends processed in 24 hour period\n', '    */\n', '    function processRewards() public teamPlayer launched {\n', '        require(tokenBalanceLedger_[msg.sender] >= stakingRequirement, "Must meet staking requirement");\n', '\n', '\n', '        uint256 count = 0;\n', '        address _customer;\n', '\n', '        while (available() && count < maxProcessingCap) {\n', '\n', '            //If this queue has already been processed in this block exit without altering the queue\n', '            _customer = peek();\n', '\n', '            if (bot[_customer].lastBlock == block.number){\n', '                break;\n', '            }\n', '\n', '            //Pop\n', '            dequeue();\n', '\n', '\n', '            //Update tracking\n', '            bot[_customer].lastBlock = block.number;\n', '            bot[_customer].queued = false;\n', '\n', '            //User could have deactivated while still being queued\n', '            if (bot[_customer].active) {\n', '\n', '                //Reinvest divs; be gas efficient\n', '                if (totalDividends(_customer, true) > botThreshold) {\n', '\n', '                    //No bankroll reinvest when processing the queue\n', '                    bankrollEnabled = false;\n', '                    reinvestFor(_customer);\n', '                    bankrollEnabled = true;\n', '                }\n', '\n', '\n', '                enqueue(_customer);\n', '                bot[_customer].queued = true;\n', '            }\n', '\n', '            count++;\n', '        }\n', '\n', '        lastReward[msg.sender] = now;\n', '        reinvestFor(msg.sender);\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '// File: contracts/P4RTYBankrollVault.sol\n', '\n', '/*\n', ' * Visit: https://p4rty.io\n', ' * Discord: https://discord.gg/7y3DHYF\n', '*/\n', '\n', 'contract P4RTYBankrollVault is Whitelist {\n', '\n', '    using SafeMath for uint;\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '\n', '    event onDeposit(\n', '        address indexed fundingSource,\n', '        uint256 ethDeposited,\n', '        uint    timestamp\n', '    );\n', '\n', '    event onCredit(\n', '        address indexed customerAddress,\n', '        uint256 ethCredited,\n', '        uint    timestamp\n', '    );\n', '\n', '    event onDebit(\n', '        address indexed customerAddress,\n', '        uint256 ethDedited,\n', '        uint    timestamp\n', '    );\n', '\n', '\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn,\n', '        uint timestamp\n', '    );\n', '\n', '    event onAirdrop(\n', '        address contractAddress,\n', '        uint256 ethereumSent,\n', '        uint timestamp\n', '    );\n', '\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '\n', '    uint256 public daoFee = 10;\n', '    uint256 public p6Fee = 15;\n', '    uint256 constant public outboundThreshold = 0.5 ether;\n', '    uint256 internal p6Outbound = 0;\n', '    uint256 internal daoOutbound =0;\n', '\n', '\n', '    /*=================================\n', '     =            DATASETS            =\n', '     ================================*/\n', '\n', '    struct Stats {\n', '        uint deposit;\n', '        uint credit;\n', '        uint debit;\n', '        uint withdrawn;\n', '        uint xDeposit;\n', '        uint xCredit;\n', '        uint xDebit;\n', '        uint xWithdrawn;\n', '    }\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal vault;\n', '    mapping(address => Stats) internal stats;\n', '    uint256 internal totalCustomerCredit;\n', '    P6 public p6;\n', '    P4RTYDaoVault public dao;\n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS           =\n', '    =======================================*/\n', '\n', '    constructor(address daoAddress) public {\n', '        dao = P4RTYDaoVault(daoAddress);\n', '    }\n', '\n', '    function updateP6Fee(uint256 fee) public onlyOwner {\n', '        require ( fee >= 1 && fee <= 25);\n', '        p6Fee = fee;\n', '    }\n', '\n', '    function updateDaoFee(uint256 fee) public onlyOwner {\n', '        require ( fee >= 1 && fee <= 25);\n', '        daoFee = fee;\n', '    }\n', '\n', '    function updateP6Address(address p6Address) public onlyOwner {\n', '        p6 = P6(p6Address);\n', '    }\n', '\n', '    //Customer functions\n', '\n', '\n', '    /// @dev Stores ETH funds for customer\n', '    function credit(address _customerAddress, uint256 amount) onlyWhitelisted external returns (uint256){\n', '        vault[_customerAddress] = vault[_customerAddress].add(amount);\n', '\n', '        totalCustomerCredit = totalCustomerCredit.add(amount);\n', '\n', '        //Stats\n', '        stats[_customerAddress].credit = stats[_customerAddress].credit.add(amount);\n', '        stats[_customerAddress].xCredit += 1;\n', '\n', '        emit onCredit(_customerAddress, amount, now);\n', '\n', '        return vault[_customerAddress];\n', '\n', '    }\n', '\n', '    /// @dev Debits address by an amount or sets to zero\n', '    function debit(address _customerAddress, uint256 amount) onlyWhitelisted external returns (uint256){\n', '\n', '        //No money movement; usually a lost wager\n', '        vault[_customerAddress] = Math.max256(0, vault[_customerAddress].sub(amount));\n', '\n', '        totalCustomerCredit = totalCustomerCredit.sub(amount);\n', '\n', '        //Stats\n', '        stats[_customerAddress].debit = stats[_customerAddress].debit.add(amount);\n', '        stats[_customerAddress].xDebit += 1;\n', '\n', '        emit onWithdraw(_customerAddress, amount, now);\n', '\n', '        return vault[_customerAddress];\n', '    }\n', '\n', '    /// @dev Withraws balance for address; returns amount sent\n', '    function withdraw(address _customerAddress) onlyWhitelisted external returns (uint256){\n', '        require(vault[_customerAddress] > 0);\n', '\n', '        uint256 amount = vault[_customerAddress];\n', '\n', '        vault[_customerAddress] = 0;\n', '        totalCustomerCredit = totalCustomerCredit.sub(amount);\n', '\n', '        _customerAddress.transfer(amount);\n', '\n', '        //Stats\n', '        stats[_customerAddress].withdrawn = stats[_customerAddress].withdrawn.add(amount);\n', '        stats[_customerAddress].xWithdrawn += 1;\n', '\n', '        emit onWithdraw(_customerAddress, amount, now);\n', '    }\n', '\n', '    function houseProfit(uint256 amount) onlyWhitelisted external {\n', '        fundP6(amount);\n', '        fundDao(amount);\n', '    }\n', '\n', '    /// @dev Retrieve the token balance of any single address.\n', '    function balanceOf(address _customerAddress)  onlyWhitelisted external view returns (uint256) {\n', '        return vault[_customerAddress];\n', '    }\n', '\n', '    /// @dev Stats of any single address\n', '    function statsOf(address _customerAddress) public view returns (uint256[8]){\n', '        Stats memory s = stats[_customerAddress];\n', '        uint256[8] memory statArray = [s.deposit, s.credit, s.debit, s.withdrawn,\n', '        s.xDeposit, s.xCredit, s.xDebit, s.xWithdrawn];\n', '        return statArray;\n', '    }\n', '\n', '\n', '    // System functions\n', '\n', '\n', '    /**\n', '     * @dev Fallback function to handle ethereum that was send straight to the contract\n', '     * Should just deposit so that we can accept funds from contracts as well using transfer\n', '     */\n', '    function() payable public {\n', '        emit onDeposit(msg.sender, msg.value, now);\n', '    }\n', '\n', "    /// @dev Proper way to fund bankrollvault; don't use fallback\n", '    function deposit() payable public  {\n', '        // fire event\n', '        emit onDeposit(msg.sender, msg.value, now);\n', '    }\n', '\n', '    /// @dev Proper way to fund bankrollvault by a specific customer\n', '    function depositBy(address _customerAddress ) onlyWhitelisted payable external {\n', '        // fire event; profit do not immediately shared with Snowfall\n', '\n', '        //Stats\n', '        stats[_customerAddress].deposit = stats[_customerAddress].deposit.add(msg.value);\n', '        stats[_customerAddress].xDeposit += 1;\n', '\n', '        emit onDeposit(_customerAddress, msg.value, now);\n', '    }\n', '\n', '    /**\n', '    * @dev The bridge to the launch ecosystem. Community has to participate to dump divs\n', '    * Should\n', '    */\n', '    function fundP6(uint256 amount) internal {\n', '        uint256 fee = amount.mul(p6Fee).div(100);\n', '\n', '        p6Outbound = p6Outbound.add(fee);\n', '\n', '        //GO P6 GO!!!\n', '        if (p6Outbound >= outboundThreshold){\n', '            fee = p6Outbound;\n', '            p6Outbound = 0;\n', '            p6.buyFor.value(fee)(owner);\n', '            emit onAirdrop(address(p6), fee, now);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev The bridge to the launch ecosystem. Community has to participate to dump divs\n', '    * Should\n', '    */\n', '    function fundDao(uint256 amount) internal {\n', '        uint256 fee = amount.mul(daoFee).div(100);\n', '\n', '        daoOutbound = daoOutbound.add(fee);\n', '\n', '        //GO P6 GO!!!\n', '        if (daoOutbound >= outboundThreshold){\n', '            fee = daoOutbound;\n', '            daoOutbound = 0;\n', '            dao.deposit.value(fee)();\n', '            emit onAirdrop(address(dao), fee, now);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '      * @dev Get all the ETH stored in contract\n', '      *\n', '      */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /**\n', '     * @dev Get all the ETH stored in contract minus credits to customers\n', '     *\n', '     */\n', '    function netEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance.sub(totalCustomerCredit);\n', '    }\n', '}']