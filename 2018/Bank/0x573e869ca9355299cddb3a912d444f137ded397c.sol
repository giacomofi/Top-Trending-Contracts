['pragma solidity ^0.4.24;\n', '\n', '/**\n', '\n', '  https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com\n', '\n', '                                                                                                  \n', 'FFFFFFFFFFFFFFFFFFFFFF                                           tttt            iiii                   \n', 'F::::::::::::::::::::F                                        ttt:::t           i::::i                  \n', 'F::::::::::::::::::::F                                        t:::::t            iiii                   \n', 'FF::::::FFFFFFFFF::::F                                        t:::::t                                   \n', '  F:::::F       FFFFFFooooooooooo   rrrrr   rrrrrrrrr   ttttttt:::::ttttttt    iiiiiii     ssssssssss   \n', '  F:::::F           oo:::::::::::oo r::::rrr:::::::::r  t:::::::::::::::::t    i:::::i   ss::::::::::s  \n', '  F::::::FFFFFFFFFFo:::::::::::::::or:::::::::::::::::r t:::::::::::::::::t     i::::i ss:::::::::::::s \n', '  F:::::::::::::::Fo:::::ooooo:::::orr::::::rrrrr::::::rtttttt:::::::tttttt     i::::i s::::::ssss:::::s\n', '  F:::::::::::::::Fo::::o     o::::o r:::::r     r:::::r      t:::::t           i::::i  s:::::s  ssssss \n', '  F::::::FFFFFFFFFFo::::o     o::::o r:::::r     rrrrrrr      t:::::t           i::::i    s::::::s      \n', '  F:::::F          o::::o     o::::o r:::::r                  t:::::t           i::::i       s::::::s   \n', '  F:::::F          o::::o     o::::o r:::::r                  t:::::t    tttttt i::::i ssssss   s:::::s \n', 'FF:::::::FF        o:::::ooooo:::::o r:::::r                  t::::::tttt:::::ti::::::is:::::ssss::::::s\n', 'F::::::::FF        o:::::::::::::::o r:::::r                  tt::::::::::::::ti::::::is::::::::::::::s \n', 'F::::::::FF         oo:::::::::::oo  r:::::r                    tt:::::::::::tti::::::i s:::::::::::ss  \n', 'FFFFFFFFFFF           ooooooooooo    rrrrrrr                      ttttttttttt  iiiiiiii  sssssssssss    \n', '                                                                                                        \n', '\n', 'An interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles.\n', '\n', 'Discord:   https://discord.gg/gDtTX62\n', '\n', '\n', '**/\n', '\n', '\n', 'contract Fortis {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyHolders() {\n', '    require(myFrontEndTokens() > 0);\n', '    _;\n', '  }\n', '\n', '  modifier dividendHolder() {\n', '    require(myDividends(true) > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdministrator(){\n', '    address _customerAddress = msg.sender;\n', '    require(administrators[_customerAddress]);\n', '    _;\n', '  }\n', '\n', '  /*==============================\n', '  =            EVENTS            =\n', '  ==============================*/\n', '\n', '  event onTokenPurchase(\n', '    address indexed customerAddress,\n', '    uint incomingEthereum,\n', '    uint tokensMinted,\n', '    address indexed referredBy\n', '  );\n', '\n', '  event UserDividendRate(\n', '    address user,\n', '    uint divRate\n', '  );\n', '\n', '  event onTokenSell(\n', '    address indexed customerAddress,\n', '    uint tokensBurned,\n', '    uint ethereumEarned\n', '  );\n', '\n', '  event onReinvestment(\n', '    address indexed customerAddress,\n', '    uint ethereumReinvested,\n', '    uint tokensMinted\n', '  );\n', '\n', '  event onWithdraw(\n', '    address indexed customerAddress,\n', '    uint ethereumWithdrawn\n', '  );\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens\n', '  );\n', '\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens\n', '  );\n', '\n', '  event Allocation(\n', '    uint toBankRoll,\n', '    uint toReferrer,\n', '    uint toTokenHolders,\n', '    uint toDivCardHolders,\n', '    uint forTokens\n', '  );\n', '\n', '  event Referral(\n', '    address referrer,\n', '    uint amountReceived\n', '  );\n', '\n', '  /*=====================================\n', '  =            CONSTANTS                =\n', '  =====================================*/\n', '\n', '  uint8 constant public                decimals              = 18;\n', '\n', '  uint constant internal               tokenPriceInitial_    = 0.000653 ether;\n', '  uint constant internal               magnitude             = 2**64;\n', '\n', '  uint constant internal               icoHardCap            = 250 ether;\n', '  uint constant internal               addressICOLimit       = 1   ether;\n', '  uint constant internal               icoMinBuyIn           = 0.1 finney;\n', '  uint constant internal               icoMaxGasPrice        = 50000000000 wei;\n', '\n', '  uint constant internal               MULTIPLIER            = 9615;\n', '\n', '  uint constant internal               MIN_ETH_BUYIN         = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_TRANSFER    = 1e10;\n', '  uint constant internal               referrer_percentage   = 25;\n', '\n', '  uint public                          stakingRequirement    = 100e18;\n', '\n', '  /*================================\n', '   =          CONFIGURABLES         =\n', '   ================================*/\n', '\n', '  string public                        name               = "Fortis";\n', '  string public                        symbol             = "IRON";\n', '\n', '  bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262);\n', '\n', '  address internal                     bankrollAddress;\n', '\n', '  ZethrDividendCards                   divCardContract;\n', '\n', '  /*================================\n', '   =            DATASETS            =\n', '   ================================*/\n', '\n', '  // Tracks front & backend tokens\n', '  mapping(address => uint) internal    frontTokenBalanceLedger_;\n', '  mapping(address => uint) internal    dividendTokenBalanceLedger_;\n', '  mapping(address =>\n', '  mapping (address => uint))\n', '  public      allowed;\n', '\n', '  // Tracks dividend rates for users\n', '  mapping(uint8   => bool)    internal validDividendRates_;\n', '  mapping(address => bool)    internal userSelectedRate;\n', '  mapping(address => uint8)   internal userDividendRate;\n', '\n', '  // Payout tracking\n', '  mapping(address => uint)    internal referralBalance_;\n', '  mapping(address => int256)  internal payoutsTo_;\n', '\n', '  // ICO per-address limit tracking\n', '  mapping(address => uint)    internal ICOBuyIn;\n', '\n', '  uint public                          tokensMintedDuringICO;\n', '  uint public                          ethInvestedDuringICO;\n', '\n', '  uint public                          currentEthInvested;\n', '\n', '  uint internal                        tokenSupply    = 0;\n', '  uint internal                        divTokenSupply = 0;\n', '\n', '  uint internal                        profitPerDivToken;\n', '\n', '  mapping(address => bool) public      administrators;\n', '\n', '  bool public                          icoPhase     = false;\n', '  bool public                          regularPhase = false;\n', '\n', '  uint                                 icoOpenTime;\n', '\n', '  /*=======================================\n', '  =            PUBLIC FUNCTIONS           =\n', '  =======================================*/\n', '  constructor (address _bankrollAddress, address _divCardAddress)\n', '  public\n', '  {\n', '    bankrollAddress = _bankrollAddress;\n', '    divCardContract = ZethrDividendCards(_divCardAddress);\n', '\n', '    administrators[0x9b3bb44b1a9243db229e5ccc6d20cada9efce5f8] = true; // Rayner\n', '    administrators[0x487a03097b4d7320d5a0e7451f6a0e1224c37f09] = true; // Rustam\n', '    administrators[0x24d6e2d15a85c27b0282bbc2afbc06cfbd9c15a0] = true; // Glandur\n', '\n', '    administrators[msg.sender] = true; // Helps with debugging!\n', '\n', '    validDividendRates_[2] = true;\n', '    validDividendRates_[5] = true;\n', '    validDividendRates_[10] = true;\n', '    validDividendRates_[15] = true;\n', '    validDividendRates_[20] = true;\n', '    validDividendRates_[25] = true;\n', '    validDividendRates_[33] = true;\n', '\n', '    userSelectedRate[bankrollAddress] = true;\n', '    userDividendRate[bankrollAddress] = 33;\n', '\n', '  }\n', '\n', '  /**\n', '   * Same as buy, but explicitly sets your dividend percentage.\n', '   * If this has been called before, it will update your `default&#39; dividend\n', '   *   percentage for regular buy transactions going forward.\n', '   */\n', '  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(icoPhase || regularPhase);\n', '\n', '    if (icoPhase) {\n', ' \n', '      // Anti-bot measures - not perfect, but should help some.\n', '      bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\n', '      require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress);\n', '\n', '      uint gasPrice = tx.gasprice;\n', '\n', '      // Prevents ICO buyers from getting substantially burned if the ICO is reached\n', '      //   before their transaction is processed.\n', '      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\n', '\n', '    }\n', '\n', '    // Dividend percentage should be a currently accepted value.\n', '    require (validDividendRates_[_divChoice]);\n', '\n', '    // Set the dividend fee percentage denominator.\n', '    userSelectedRate[msg.sender] = true;\n', '    userDividendRate[msg.sender] = _divChoice;\n', '    emit UserDividendRate(msg.sender, _divChoice);\n', '\n', '    // Finally, purchase tokens.\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  // All buys except for the above one require regular phase.\n', '\n', '  function buy(address _referredBy)\n', '  public\n', '  payable\n', '  returns(uint)\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    require (userSelectedRate[_customerAddress]);\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target)\n', '  public\n', '  payable\n', '  {\n', '    bytes memory empty;\n', '    buyAndTransfer(_referredBy,target, empty, 20);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data)\n', '  public\n', '  payable\n', '  {\n', '    buyAndTransfer(_referredBy, target, _data, 20);\n', '  }\n', '\n', '  // Overload\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\n', '  public\n', '  payable\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n', '    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n', '      purchaseTokens(msg.value, _referredBy);\n', '    } else {\n', '      buyAndSetDivPercentage(_referredBy, divChoice, "0x0");\n', '    }\n', '    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n', '    transferTo(msg.sender, target, difference, _data);\n', '  }\n', '\n', '  // Fallback function only works during regular phase - part of anti-bot protection.\n', '  function()\n', '  payable\n', '  public\n', '  {\n', '    /**\n', '    / If the user has previously set a dividend rate, sending\n', '    /   Ether directly to the contract simply purchases more at\n', '    /   the most recent rate. If this is their first time, they\n', '    /   are automatically placed into the 20% rate `bucket&#39;.\n', '    **/\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    if (userSelectedRate[_customerAddress]) {\n', '      purchaseTokens(msg.value, 0x0);\n', '    } else {\n', '      buyAndSetDivPercentage(0x0, 20, "0x0");\n', '    }\n', '  }\n', '\n', '  function reinvest()\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    uint _dividends = myDividends(false);\n', '\n', '    // Pay out requisite `virtual&#39; dividends.\n', '    address _customerAddress            = msg.sender;\n', '    payoutsTo_[_customerAddress]       += (int256) (_dividends * magnitude);\n', '\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    uint _tokens                        = purchaseTokens(_dividends, 0x0);\n', '\n', '    // Fire logging event.\n', '    emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '  }\n', '\n', '  function exit()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Retrieve token balance for caller, then sell them all.\n', '    address _customerAddress = msg.sender;\n', '    uint _tokens             = frontTokenBalanceLedger_[_customerAddress];\n', '\n', '    if(_tokens > 0) sell(_tokens);\n', '\n', '    withdraw(_customerAddress);\n', '  }\n', '\n', '  function withdraw(address _recipient)\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Setup data\n', '    address _customerAddress           = msg.sender;\n', '    uint _dividends                    = myDividends(false);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    if (_recipient == address(0x0)){\n', '      _recipient = msg.sender;\n', '    }\n', '    _recipient.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_recipient, _dividends);\n', '  }\n', '\n', '  // Sells front-end tokens.\n', '  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\n', '  function sell(uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  {\n', '    // No selling during the ICO. You don&#39;t get to flip that fast, sorry!\n', '    require(!icoPhase);\n', '    require(regularPhase);\n', '\n', '    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '\n', '    uint _frontEndTokensToBurn = _amountOfTokens;\n', '\n', '    // Calculate how many dividend tokens this action burns.\n', '    // Computed as the caller&#39;s average dividend rate multiplied by the number of front-end tokens held.\n', '    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n', '    uint userDivRate  = getUserAverageDividendRate(msg.sender);\n', '    require ((2*magnitude) <= userDivRate && (50*magnitude) >= userDivRate );\n', '    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n', '\n', '    // Calculate ethereum received before dividends\n', '    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\n', '\n', '    if (_ethereum > currentEthInvested){\n', '      // Well, congratulations, you&#39;ve emptied the coffers.\n', '      currentEthInvested = 0;\n', '    } else { currentEthInvested = currentEthInvested - _ethereum; }\n', '\n', '    // Calculate dividends generated from the sale.\n', '    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n', '\n', '    // Calculate Ethereum receivable net of dividends.\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '\n', '    // Burn the sold tokens (both front-end and back-end variants).\n', '    tokenSupply         = tokenSupply.sub(_frontEndTokensToBurn);\n', '    divTokenSupply      = divTokenSupply.sub(_divTokensToBurn);\n', '\n', '    // Subtract the token balances for the seller\n', '    frontTokenBalanceLedger_[msg.sender]    = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n', '\n', '    // Update dividends tracker\n', '    int256 _updatedPayouts  = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\n', '    payoutsTo_[msg.sender] -= _updatedPayouts;\n', '\n', '    // Let&#39;s avoid breaking arithmetic where we can, eh?\n', '    if (divTokenSupply > 0) {\n', '      // Update the value of each remaining back-end dividend token.\n', '      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder.\n', '   * No charge incurred for the transfer. We&#39;d make a terrible bank.\n', '   */\n', '  function transfer(address _toAddress, uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  returns(bool)\n', '  {\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '    bytes memory empty;\n', '    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n', '    return true;\n', '\n', '  }\n', '\n', '  function approve(address spender, uint tokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    address _customerAddress           = msg.sender;\n', '    allowed[_customerAddress][spender] = tokens;\n', '\n', '    // Fire logging event.\n', '    emit Approval(_customerAddress, spender, tokens);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n', '   * No charge incurred for the transfer. No seriously, we&#39;d make a terrible bank.\n', '   */\n', '  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n', '  public\n', '  returns(bool)\n', '  {\n', '    // Setup variables\n', '    address _customerAddress     = _from;\n', '    bytes memory empty;\n', '    // Make sure we own the tokens we&#39;re transferring, are ALLOWED to transfer that many tokens,\n', '    // and are transferring at least one full token.\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\n', '    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n', '\n', '    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '\n', '  }\n', '\n', '  function transferTo (address _from, address _to, uint _amountOfTokens, bytes _data)\n', '  public\n', '  {\n', '    if (_from != msg.sender){\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\n', '      && _amountOfTokens <= allowed[_from][msg.sender]);\n', '    }\n', '    else{\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n', '    }\n', '\n', '    transferFromInternal(_from, _to, _amountOfTokens, _data);\n', '  }\n', '\n', '  // Who&#39;d have thought we&#39;d need this thing floating around?\n', '  function totalSupply()\n', '  public\n', '  view\n', '  returns (uint256)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\n', '  // In case the devs die. Or something.\n', '  function publicStartRegularPhase()\n', '  public\n', '  {\n', '    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\n', '\n', '    icoPhase     = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '\n', '  // Fire the starting gun and then duck for cover.\n', '  function startICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // Prevent us from startaring the ICO phase again\n', '    require(icoOpenTime == 0);\n', '    icoPhase = true;\n', '    icoOpenTime = now;\n', '  }\n', '\n', '  // Fire the ... ending gun?\n', '  function endICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    icoPhase = false;\n', '  }\n', '\n', '  function startRegularPhase()\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    // disable ico phase in case if that was not disabled yet\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  // The death of a great man demands the birth of a great son.\n', '  function setAdministrator(address _newAdmin, bool _status)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    administrators[_newAdmin] = _status;\n', '  }\n', '\n', '  function setStakingRequirement(uint _amountOfTokens)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // This plane only goes one way, lads. Never below the initial.\n', '    require (_amountOfTokens >= 100e18);\n', '    stakingRequirement = _amountOfTokens;\n', '  }\n', '\n', '  function setName(string _name)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    name = _name;\n', '  }\n', '\n', '  function setSymbol(string _symbol)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    symbol = _symbol;\n', '  }\n', '\n', '  function changeBankroll(address _newBankrollAddress)\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    bankrollAddress = _newBankrollAddress;\n', '  }\n', '\n', '  /*----------  HELPERS AND CALCULATORS  ----------*/\n', '\n', '  function totalEthereumBalance()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function totalEthereumICOReceived()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return ethInvestedDuringICO;\n', '  }\n', '\n', '  /**\n', '   * Retrieves your currently selected dividend rate.\n', '   */\n', '  function getMyDividendRate()\n', '  public\n', '  view\n', '  returns(uint8)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    return userDividendRate[_customerAddress];\n', '  }\n', '\n', '  /**\n', '   * Retrieve the total frontend token supply\n', '   */\n', '  function getFrontEndTokenSupply()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retreive the total dividend token supply\n', '   */\n', '  function getDividendTokenSupply()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return divTokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retrieve the frontend tokens owned by the caller\n', '   */\n', '  function myFrontEndTokens()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getFrontEndTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  /**\n', '   * Retrieve the dividend tokens owned by the caller\n', '   */\n', '  function myDividendTokens()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getDividendTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  function myReferralDividends()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return myDividends(true) - myDividends(false);\n', '  }\n', '\n', '  function myDividends(bool _includeReferralBonus)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '  }\n', '\n', '  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '  }\n', '\n', '  function getFrontEndTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return frontTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return getFrontEndTokenBalanceOf(_owner);\n', '  }\n', '\n', '  function getDividendTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return dividendTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function dividendsOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '  }\n', '\n', '  // Get the sell price at the user&#39;s average dividend rate\n', '  function sellPrice()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', '    // Factor in the user&#39;s average dividend rate\n', '    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n', '\n', '    return theSellPrice;\n', '  }\n', '\n', '  // Get the buy price at a particular dividend rate\n', '  function buyPrice(uint dividendRate)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', '    // Factor in the user&#39;s selected dividend rate\n', '    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n', '\n', '    return theBuyPrice;\n', '  }\n', '\n', '  function calculateTokensReceived(uint _ethereumToSpend)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint _dividends      = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\n', '    uint _taxedEthereum  = _ethereumToSpend.sub(_dividends);\n', '    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '    return  _amountOfTokens;\n', '  }\n', '\n', '  // When selling tokens, we need to calculate the user&#39;s current dividend rate.\n', '  // This is different from their selected dividend rate.\n', '  function calculateEthereumReceived(uint _tokensToSell)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require(_tokensToSell <= tokenSupply);\n', '    uint _ethereum               = tokensToEthereum_(_tokensToSell);\n', '    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n', '    uint _dividends              = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\n', '    uint _taxedEthereum          = _ethereum.sub(_dividends);\n', '    return  _taxedEthereum;\n', '  }\n', '\n', '  /*\n', '   * Get&#39;s a user&#39;s average dividend rate - which is just their divTokenBalance / tokenBalance\n', '   * We multiply by magnitude to avoid precision errors.\n', '   */\n', '\n', '  function getUserAverageDividendRate(address user) public view returns (uint) {\n', '    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n', '  }\n', '\n', '  function getMyAverageDividendRate() public view returns (uint) {\n', '    return getUserAverageDividendRate(msg.sender);\n', '  }\n', '\n', '  /*==========================================\n', '  =            INTERNAL FUNCTIONS            =\n', '  ==========================================*/\n', '\n', '  /* Purchase tokens with Ether.\n', '     During ICO phase, dividends should go to the bankroll\n', '     During normal operation:\n', '       0.5% should go to the master dividend card\n', '       0.5% should go to the matching dividend card\n', '       25% of dividends should go to the referrer, if any is provided. */\n', '  function purchaseTokens(uint _incomingEthereum, address _referredBy)\n', '  internal\n', '  returns(uint)\n', '  {\n', '    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, "Tried to buy below the min eth buyin threshold.");\n', '\n', '    uint toBankRoll;\n', '    uint toReferrer;\n', '    uint toTokenHolders;\n', '    uint toDivCardHolders;\n', '\n', '    uint dividendAmount;\n', '\n', '    uint tokensBought;\n', '    uint dividendTokensBought;\n', '\n', '    uint remainingEth = _incomingEthereum;\n', '\n', '    uint fee;\n', '\n', '    // 1% for dividend card holders is taken off before anything else\n', '    if (regularPhase) {\n', '      toDivCardHolders = _incomingEthereum.div(100);\n', '      remainingEth = remainingEth.sub(toDivCardHolders);\n', '    }\n', '\n', '    /* Next, we tax for dividends:\n', '       Dividends = (ethereum * div%) / 100\n', '       Important note: if we&#39;re out of the ICO phase, the 1% sent to div-card holders\n', '                       is handled prior to any dividend taxes are considered. */\n', '\n', '    // Grab the user&#39;s dividend rate\n', '    uint dividendRate = userDividendRate[msg.sender];\n', '\n', '    // Calculate the total dividends on this buy\n', '    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\n', '\n', '    remainingEth   = remainingEth.sub(dividendAmount);\n', '\n', '    // If we&#39;re in the ICO and bankroll is buying, don&#39;t tax\n', '    if (icoPhase && msg.sender == bankrollAddress) {\n', '      remainingEth = remainingEth + dividendAmount;\n', '    }\n', '\n', '    // Calculate how many tokens to buy:\n', '    tokensBought         = ethereumToTokens_(remainingEth);\n', '    dividendTokensBought = tokensBought.mul(dividendRate);\n', '\n', '    // This is where we actually mint tokens:\n', '    tokenSupply    = tokenSupply.add(tokensBought);\n', '    divTokenSupply = divTokenSupply.add(dividendTokensBought);\n', '\n', '    /* Update the total investment tracker\n', '       Note that this must be done AFTER we calculate how many tokens are bought -\n', '       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\n', '\n', '    currentEthInvested = currentEthInvested + remainingEth;\n', '\n', '    // If ICO phase, all the dividends go to the bankroll\n', '    if (icoPhase) {\n', '      toBankRoll     = dividendAmount;\n', '\n', '      // If the bankroll is buying, we don&#39;t want to send eth back to the bankroll\n', '      // Instead, let&#39;s just give it the tokens it would get in an infinite recursive buy\n', '      if (msg.sender == bankrollAddress) {\n', '        toBankRoll = 0;\n', '      }\n', '\n', '      toReferrer     = 0;\n', '      toTokenHolders = 0;\n', '\n', '      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\n', '         not how much Ether we get total.\n', '         this is so that our calculation using "investment" is accurate. */\n', '      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\n', '      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\n', '\n', '      // Cannot purchase more than the hard cap during ICO.\n', '      require(ethInvestedDuringICO <= icoHardCap);\n', '      // Contracts aren&#39;t allowed to participate in the ICO.\n', '      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\n', '\n', '      // Cannot purchase more then the limit per address during the ICO.\n', '      ICOBuyIn[msg.sender] += remainingEth;\n', '      require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress);\n', '\n', '      // Stop the ICO phase if we reach the hard cap\n', '      if (ethInvestedDuringICO == icoHardCap){\n', '        icoPhase = false;\n', '      }\n', '\n', '    } else {\n', '      // Not ICO phase, check for referrals\n', '\n', '      // 25% goes to referrers, if set\n', '      // toReferrer = (dividends * 25)/100\n', '      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '      _referredBy != msg.sender &&\n', '      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\n', '      {\n', '        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n', '        referralBalance_[_referredBy] += toReferrer;\n', '        emit Referral(_referredBy, toReferrer);\n', '      }\n', '\n', '      // The rest of the dividends go to token holders\n', '      toTokenHolders = dividendAmount.sub(toReferrer);\n', '\n', '      fee = toTokenHolders * magnitude;\n', '      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\n', '\n', '      // Finally, increase the divToken value\n', '      profitPerDivToken       = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n', '      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\n', '    }\n', '\n', '    // Update the buyer&#39;s token amounts\n', '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\n', '\n', '    // Transfer to bankroll and div cards\n', '    if (toBankRoll != 0) { ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)(); }\n', '    if (regularPhase) { divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate); }\n', '\n', '    // This event should help us track where all the eth is going\n', '    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\n', '\n', '    // Sanity checking\n', '    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\n', '    assert(sum == 0);\n', '  }\n', '\n', '  // How many tokens one gets from a certain amount of ethereum.\n', '  function ethereumToTokens_(uint _ethereumAmount)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require(_ethereumAmount > MIN_ETH_BUYIN, "Tried to buy tokens with too little eth.");\n', '\n', '    if (icoPhase) {\n', '      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\n', '    }\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the buy into two segments:\n', '    //  1) the amount of eth going towards ico-price tokens\n', '    //  2) the amount of eth going towards pyramid-price (variable) tokens\n', '    uint ethTowardsICOPriceTokens = 0;\n', '    uint ethTowardsVariablePriceTokens = 0;\n', '\n', '    if (currentEthInvested >= ethInvestedDuringICO) {\n', '      // Option One: All the ETH goes towards variable-price tokens\n', '      ethTowardsVariablePriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\n', '      // Option Two: All the ETH goes towards ICO-price tokens\n', '      ethTowardsICOPriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\n', '      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\n', '      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\n', '      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\n', '    } else {\n', '      // Option Four: Should be impossible, and compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\n', '\n', '    // Separate out the number of tokens of each type this will buy:\n', '    uint icoPriceTokens = 0;\n', '    uint varPriceTokens = 0;\n', '\n', '    // Now calculate each one per the above formulas.\n', '    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\n', '    if (ethTowardsICOPriceTokens != 0) {\n', '      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\n', '    }\n', '\n', '    if (ethTowardsVariablePriceTokens != 0) {\n', '      // Note: we can&#39;t use "currentEthInvested" for this calculation, we must use:\n', '      //  currentEthInvested + ethTowardsICOPriceTokens\n', '      // This is because a split-buy essentially needs to simulate two separate buys -\n', '      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\n', '\n', '      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\n', '      uint simulatedEthAfterInvested  = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\n', '\n', '      /* We have the equations for total tokens above; note that this is for TOTAL.\n', '         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\n', '         and the simulatedEthInvestedAfter and calculate the difference in tokens.\n', '         This is how many we get. */\n', '\n', '      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '      uint tokensAfter  = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '\n', '      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\n', '         either should work.\n', '\n', '         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n', '         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n', '\n', '      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n', '    }\n', '\n', '    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\n', '\n', '    assert(totalTokensReceived > 0);\n', '    return totalTokensReceived;\n', '  }\n', '\n', '  // How much Ether we get from selling N tokens\n', '  function tokensToEthereum_(uint _tokens)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require (_tokens >= MIN_TOKEN_SELL_AMOUNT, "Tried to sell too few tokens.");\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the sell into two segments:\n', '    //  1) the amount of tokens selling at the ICO price.\n', '    //  2) the amount of tokens selling at the variable (pyramid) price\n', '    uint tokensToSellAtICOPrice = 0;\n', '    uint tokensToSellAtVariablePrice = 0;\n', '\n', '    if (tokenSupply <= tokensMintedDuringICO) {\n', '      // Option One: All the tokens sell at the ICO price.\n', '      tokensToSellAtICOPrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\n', '      // Option Two: All the tokens sell at the variable price.\n', '      tokensToSellAtVariablePrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\n', '      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\n', '      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\n', '      tokensToSellAtICOPrice      = _tokens.sub(tokensToSellAtVariablePrice);\n', '\n', '    } else {\n', '      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\n', '\n', '    // Track how much Ether we get from selling at each price function:\n', '    uint ethFromICOPriceTokens;\n', '    uint ethFromVarPriceTokens;\n', '\n', '    // Now, actually calculate:\n', '\n', '    if (tokensToSellAtICOPrice != 0) {\n', '\n', '      /* Here, unlike the sister equation in ethereumToTokens, we DON&#39;T need to multiply by 1e18, since\n', '         we will be passed in an amount of tokens to sell that&#39;s already at the 18-decimal precision.\n', '         We need to divide by 1e18 or we&#39;ll have too much Ether. */\n', '\n', '      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\n', '    }\n', '\n', '    if (tokensToSellAtVariablePrice != 0) {\n', '\n', '      /* Note: Unlike the sister function in ethereumToTokens, we don&#39;t have to calculate any "virtual" token count.\n', '         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\n', '         Thus there isn&#39;t any weird stuff going on with the token supply.\n', '\n', '         We have the equations for total investment above; note that this is for TOTAL.\n', '         To get the eth received from this sell, we calculate the new total investment after this sell.\n', '         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\n', '\n', '      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint investmentAfter  = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '\n', '      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n', '    }\n', '\n', '    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\n', '\n', '    assert(totalEthReceived > 0);\n', '    return totalEthReceived;\n', '  }\n', '\n', '  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n', '  internal\n', '  {\n', '    require(regularPhase);\n', '    require(_toAddress != address(0x0));\n', '    address _customerAddress     = _from;\n', '    uint _amountOfFrontEndTokens = _amountOfTokens;\n', '\n', '    // Withdraw all outstanding dividends first (including those generated from referrals).\n', '    if(theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n', '\n', '    // Calculate how many back-end dividend tokens to transfer.\n', '    // This amount is proportional to the caller&#39;s average dividend rate multiplied by the proportion of tokens being transferred.\n', '    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n', '\n', '    if (_customerAddress != msg.sender){\n', '      // Update the allowed balance.\n', '      // Don&#39;t update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n', '      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n', '    }\n', '\n', '    // Exchange tokens\n', '    frontTokenBalanceLedger_[_customerAddress]    = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n', '    frontTokenBalanceLedger_[_toAddress]          = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n', '    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n', '    dividendTokenBalanceLedger_[_toAddress]       = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n', '\n', '    // Recipient inherits dividend percentage if they have not already selected one.\n', '    if(!userSelectedRate[_toAddress])\n', '    {\n', '      userSelectedRate[_toAddress] = true;\n', '      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n', '    }\n', '\n', '    // Update dividend trackers\n', '    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\n', '    payoutsTo_[_toAddress]       += (int256) (profitPerDivToken * _amountOfDivTokens);\n', '\n', '    uint length;\n', '\n', '    assembly {\n', '      length := extcodesize(_toAddress)\n', '    }\n', '\n', '    if (length > 0){\n', '      // its a contract\n', '      // note: at ethereum update ALL addresses are contracts\n', '      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n', '      receiver.tokenFallback(_from, _amountOfTokens, _data);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n', '  }\n', '\n', '  // Called from transferFrom. Always checks if _customerAddress has dividends.\n', '  function withdrawFrom(address _customerAddress)\n', '  internal\n', '  {\n', '    // Setup data\n', '    uint _dividends                    = theDividendsOf(false, _customerAddress);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    _customerAddress.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_customerAddress, _dividends);\n', '  }\n', '\n', '\n', '  /*=======================\n', '   =    RESET FUNCTIONS   =\n', '   ======================*/\n', '\n', '  function injectEther()\n', '  public\n', '  payable\n', '  onlyAdministrator\n', '  {\n', '\n', '  }\n', '\n', '  /*=======================\n', '   =   MATHS FUNCTIONS    =\n', '   ======================*/\n', '\n', '  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\n', '    // m = 3, n = 2\n', '    // sqrt(x^3)\n', '    return sqrt(x**3);\n', '  }\n', '\n', '  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\n', '    // m = 2, n = 3\n', '    // cbrt(x^2)\n', '    return cbrt(x**2);\n', '  }\n', '\n', '  function sqrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / z + z) / 2;\n', '    }\n', '  }\n', '\n', '  function cbrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 3;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / (z*z) + 2 * z) / 3;\n', '    }\n', '  }\n', '}\n', '\n', '/*=======================\n', ' =     INTERFACES       =\n', ' ======================*/\n', '\n', '\n', 'contract ZethrDividendCards {\n', '  function ownerOf(uint /*_divCardId*/) public pure returns (address) {}\n', '  function receiveDividends(uint /*_divCardRate*/) public payable {}\n', '}\n', '\n', 'contract ZethrBankroll{\n', '  function receiveDividends() public payable {}\n', '}\n', '\n', '\n', 'contract ERC223Receiving {\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// Think it&#39;s safe to say y&#39;all know what this is.\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', '\n', '  https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com\n', '\n', '                                                                                                  \n', 'FFFFFFFFFFFFFFFFFFFFFF                                           tttt            iiii                   \n', 'F::::::::::::::::::::F                                        ttt:::t           i::::i                  \n', 'F::::::::::::::::::::F                                        t:::::t            iiii                   \n', 'FF::::::FFFFFFFFF::::F                                        t:::::t                                   \n', '  F:::::F       FFFFFFooooooooooo   rrrrr   rrrrrrrrr   ttttttt:::::ttttttt    iiiiiii     ssssssssss   \n', '  F:::::F           oo:::::::::::oo r::::rrr:::::::::r  t:::::::::::::::::t    i:::::i   ss::::::::::s  \n', '  F::::::FFFFFFFFFFo:::::::::::::::or:::::::::::::::::r t:::::::::::::::::t     i::::i ss:::::::::::::s \n', '  F:::::::::::::::Fo:::::ooooo:::::orr::::::rrrrr::::::rtttttt:::::::tttttt     i::::i s::::::ssss:::::s\n', '  F:::::::::::::::Fo::::o     o::::o r:::::r     r:::::r      t:::::t           i::::i  s:::::s  ssssss \n', '  F::::::FFFFFFFFFFo::::o     o::::o r:::::r     rrrrrrr      t:::::t           i::::i    s::::::s      \n', '  F:::::F          o::::o     o::::o r:::::r                  t:::::t           i::::i       s::::::s   \n', '  F:::::F          o::::o     o::::o r:::::r                  t:::::t    tttttt i::::i ssssss   s:::::s \n', 'FF:::::::FF        o:::::ooooo:::::o r:::::r                  t::::::tttt:::::ti::::::is:::::ssss::::::s\n', 'F::::::::FF        o:::::::::::::::o r:::::r                  tt::::::::::::::ti::::::is::::::::::::::s \n', 'F::::::::FF         oo:::::::::::oo  r:::::r                    tt:::::::::::tti::::::i s:::::::::::ss  \n', 'FFFFFFFFFFF           ooooooooooo    rrrrrrr                      ttttttttttt  iiiiiiii  sssssssssss    \n', '                                                                                                        \n', '\n', 'An interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles.\n', '\n', 'Discord:   https://discord.gg/gDtTX62\n', '\n', '\n', '**/\n', '\n', '\n', 'contract Fortis {\n', '  using SafeMath for uint;\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyHolders() {\n', '    require(myFrontEndTokens() > 0);\n', '    _;\n', '  }\n', '\n', '  modifier dividendHolder() {\n', '    require(myDividends(true) > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdministrator(){\n', '    address _customerAddress = msg.sender;\n', '    require(administrators[_customerAddress]);\n', '    _;\n', '  }\n', '\n', '  /*==============================\n', '  =            EVENTS            =\n', '  ==============================*/\n', '\n', '  event onTokenPurchase(\n', '    address indexed customerAddress,\n', '    uint incomingEthereum,\n', '    uint tokensMinted,\n', '    address indexed referredBy\n', '  );\n', '\n', '  event UserDividendRate(\n', '    address user,\n', '    uint divRate\n', '  );\n', '\n', '  event onTokenSell(\n', '    address indexed customerAddress,\n', '    uint tokensBurned,\n', '    uint ethereumEarned\n', '  );\n', '\n', '  event onReinvestment(\n', '    address indexed customerAddress,\n', '    uint ethereumReinvested,\n', '    uint tokensMinted\n', '  );\n', '\n', '  event onWithdraw(\n', '    address indexed customerAddress,\n', '    uint ethereumWithdrawn\n', '  );\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens\n', '  );\n', '\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens\n', '  );\n', '\n', '  event Allocation(\n', '    uint toBankRoll,\n', '    uint toReferrer,\n', '    uint toTokenHolders,\n', '    uint toDivCardHolders,\n', '    uint forTokens\n', '  );\n', '\n', '  event Referral(\n', '    address referrer,\n', '    uint amountReceived\n', '  );\n', '\n', '  /*=====================================\n', '  =            CONSTANTS                =\n', '  =====================================*/\n', '\n', '  uint8 constant public                decimals              = 18;\n', '\n', '  uint constant internal               tokenPriceInitial_    = 0.000653 ether;\n', '  uint constant internal               magnitude             = 2**64;\n', '\n', '  uint constant internal               icoHardCap            = 250 ether;\n', '  uint constant internal               addressICOLimit       = 1   ether;\n', '  uint constant internal               icoMinBuyIn           = 0.1 finney;\n', '  uint constant internal               icoMaxGasPrice        = 50000000000 wei;\n', '\n', '  uint constant internal               MULTIPLIER            = 9615;\n', '\n', '  uint constant internal               MIN_ETH_BUYIN         = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n', '  uint constant internal               MIN_TOKEN_TRANSFER    = 1e10;\n', '  uint constant internal               referrer_percentage   = 25;\n', '\n', '  uint public                          stakingRequirement    = 100e18;\n', '\n', '  /*================================\n', '   =          CONFIGURABLES         =\n', '   ================================*/\n', '\n', '  string public                        name               = "Fortis";\n', '  string public                        symbol             = "IRON";\n', '\n', '  bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262);\n', '\n', '  address internal                     bankrollAddress;\n', '\n', '  ZethrDividendCards                   divCardContract;\n', '\n', '  /*================================\n', '   =            DATASETS            =\n', '   ================================*/\n', '\n', '  // Tracks front & backend tokens\n', '  mapping(address => uint) internal    frontTokenBalanceLedger_;\n', '  mapping(address => uint) internal    dividendTokenBalanceLedger_;\n', '  mapping(address =>\n', '  mapping (address => uint))\n', '  public      allowed;\n', '\n', '  // Tracks dividend rates for users\n', '  mapping(uint8   => bool)    internal validDividendRates_;\n', '  mapping(address => bool)    internal userSelectedRate;\n', '  mapping(address => uint8)   internal userDividendRate;\n', '\n', '  // Payout tracking\n', '  mapping(address => uint)    internal referralBalance_;\n', '  mapping(address => int256)  internal payoutsTo_;\n', '\n', '  // ICO per-address limit tracking\n', '  mapping(address => uint)    internal ICOBuyIn;\n', '\n', '  uint public                          tokensMintedDuringICO;\n', '  uint public                          ethInvestedDuringICO;\n', '\n', '  uint public                          currentEthInvested;\n', '\n', '  uint internal                        tokenSupply    = 0;\n', '  uint internal                        divTokenSupply = 0;\n', '\n', '  uint internal                        profitPerDivToken;\n', '\n', '  mapping(address => bool) public      administrators;\n', '\n', '  bool public                          icoPhase     = false;\n', '  bool public                          regularPhase = false;\n', '\n', '  uint                                 icoOpenTime;\n', '\n', '  /*=======================================\n', '  =            PUBLIC FUNCTIONS           =\n', '  =======================================*/\n', '  constructor (address _bankrollAddress, address _divCardAddress)\n', '  public\n', '  {\n', '    bankrollAddress = _bankrollAddress;\n', '    divCardContract = ZethrDividendCards(_divCardAddress);\n', '\n', '    administrators[0x9b3bb44b1a9243db229e5ccc6d20cada9efce5f8] = true; // Rayner\n', '    administrators[0x487a03097b4d7320d5a0e7451f6a0e1224c37f09] = true; // Rustam\n', '    administrators[0x24d6e2d15a85c27b0282bbc2afbc06cfbd9c15a0] = true; // Glandur\n', '\n', '    administrators[msg.sender] = true; // Helps with debugging!\n', '\n', '    validDividendRates_[2] = true;\n', '    validDividendRates_[5] = true;\n', '    validDividendRates_[10] = true;\n', '    validDividendRates_[15] = true;\n', '    validDividendRates_[20] = true;\n', '    validDividendRates_[25] = true;\n', '    validDividendRates_[33] = true;\n', '\n', '    userSelectedRate[bankrollAddress] = true;\n', '    userDividendRate[bankrollAddress] = 33;\n', '\n', '  }\n', '\n', '  /**\n', '   * Same as buy, but explicitly sets your dividend percentage.\n', "   * If this has been called before, it will update your `default' dividend\n", '   *   percentage for regular buy transactions going forward.\n', '   */\n', '  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass)\n', '  public\n', '  payable\n', '  returns (uint)\n', '  {\n', '    require(icoPhase || regularPhase);\n', '\n', '    if (icoPhase) {\n', ' \n', '      // Anti-bot measures - not perfect, but should help some.\n', '      bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\n', '      require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress);\n', '\n', '      uint gasPrice = tx.gasprice;\n', '\n', '      // Prevents ICO buyers from getting substantially burned if the ICO is reached\n', '      //   before their transaction is processed.\n', '      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\n', '\n', '    }\n', '\n', '    // Dividend percentage should be a currently accepted value.\n', '    require (validDividendRates_[_divChoice]);\n', '\n', '    // Set the dividend fee percentage denominator.\n', '    userSelectedRate[msg.sender] = true;\n', '    userDividendRate[msg.sender] = _divChoice;\n', '    emit UserDividendRate(msg.sender, _divChoice);\n', '\n', '    // Finally, purchase tokens.\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  // All buys except for the above one require regular phase.\n', '\n', '  function buy(address _referredBy)\n', '  public\n', '  payable\n', '  returns(uint)\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    require (userSelectedRate[_customerAddress]);\n', '    purchaseTokens(msg.value, _referredBy);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target)\n', '  public\n', '  payable\n', '  {\n', '    bytes memory empty;\n', '    buyAndTransfer(_referredBy,target, empty, 20);\n', '  }\n', '\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data)\n', '  public\n', '  payable\n', '  {\n', '    buyAndTransfer(_referredBy, target, _data, 20);\n', '  }\n', '\n', '  // Overload\n', '  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\n', '  public\n', '  payable\n', '  {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n', '    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n', '      purchaseTokens(msg.value, _referredBy);\n', '    } else {\n', '      buyAndSetDivPercentage(_referredBy, divChoice, "0x0");\n', '    }\n', '    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n', '    transferTo(msg.sender, target, difference, _data);\n', '  }\n', '\n', '  // Fallback function only works during regular phase - part of anti-bot protection.\n', '  function()\n', '  payable\n', '  public\n', '  {\n', '    /**\n', '    / If the user has previously set a dividend rate, sending\n', '    /   Ether directly to the contract simply purchases more at\n', '    /   the most recent rate. If this is their first time, they\n', "    /   are automatically placed into the 20% rate `bucket'.\n", '    **/\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    if (userSelectedRate[_customerAddress]) {\n', '      purchaseTokens(msg.value, 0x0);\n', '    } else {\n', '      buyAndSetDivPercentage(0x0, 20, "0x0");\n', '    }\n', '  }\n', '\n', '  function reinvest()\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    uint _dividends = myDividends(false);\n', '\n', "    // Pay out requisite `virtual' dividends.\n", '    address _customerAddress            = msg.sender;\n', '    payoutsTo_[_customerAddress]       += (int256) (_dividends * magnitude);\n', '\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    uint _tokens                        = purchaseTokens(_dividends, 0x0);\n', '\n', '    // Fire logging event.\n', '    emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '  }\n', '\n', '  function exit()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Retrieve token balance for caller, then sell them all.\n', '    address _customerAddress = msg.sender;\n', '    uint _tokens             = frontTokenBalanceLedger_[_customerAddress];\n', '\n', '    if(_tokens > 0) sell(_tokens);\n', '\n', '    withdraw(_customerAddress);\n', '  }\n', '\n', '  function withdraw(address _recipient)\n', '  dividendHolder()\n', '  public\n', '  {\n', '    require(regularPhase);\n', '    // Setup data\n', '    address _customerAddress           = msg.sender;\n', '    uint _dividends                    = myDividends(false);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    if (_recipient == address(0x0)){\n', '      _recipient = msg.sender;\n', '    }\n', '    _recipient.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_recipient, _dividends);\n', '  }\n', '\n', '  // Sells front-end tokens.\n', '  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\n', '  function sell(uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  {\n', "    // No selling during the ICO. You don't get to flip that fast, sorry!\n", '    require(!icoPhase);\n', '    require(regularPhase);\n', '\n', '    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '\n', '    uint _frontEndTokensToBurn = _amountOfTokens;\n', '\n', '    // Calculate how many dividend tokens this action burns.\n', "    // Computed as the caller's average dividend rate multiplied by the number of front-end tokens held.\n", '    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n', '    uint userDivRate  = getUserAverageDividendRate(msg.sender);\n', '    require ((2*magnitude) <= userDivRate && (50*magnitude) >= userDivRate );\n', '    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n', '\n', '    // Calculate ethereum received before dividends\n', '    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\n', '\n', '    if (_ethereum > currentEthInvested){\n', "      // Well, congratulations, you've emptied the coffers.\n", '      currentEthInvested = 0;\n', '    } else { currentEthInvested = currentEthInvested - _ethereum; }\n', '\n', '    // Calculate dividends generated from the sale.\n', '    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n', '\n', '    // Calculate Ethereum receivable net of dividends.\n', '    uint _taxedEthereum = _ethereum.sub(_dividends);\n', '\n', '    // Burn the sold tokens (both front-end and back-end variants).\n', '    tokenSupply         = tokenSupply.sub(_frontEndTokensToBurn);\n', '    divTokenSupply      = divTokenSupply.sub(_divTokensToBurn);\n', '\n', '    // Subtract the token balances for the seller\n', '    frontTokenBalanceLedger_[msg.sender]    = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n', '\n', '    // Update dividends tracker\n', '    int256 _updatedPayouts  = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\n', '    payoutsTo_[msg.sender] -= _updatedPayouts;\n', '\n', "    // Let's avoid breaking arithmetic where we can, eh?\n", '    if (divTokenSupply > 0) {\n', '      // Update the value of each remaining back-end dividend token.\n', '      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder.\n', "   * No charge incurred for the transfer. We'd make a terrible bank.\n", '   */\n', '  function transfer(address _toAddress, uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  returns(bool)\n', '  {\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '    bytes memory empty;\n', '    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n', '    return true;\n', '\n', '  }\n', '\n', '  function approve(address spender, uint tokens)\n', '  public\n', '  returns (bool)\n', '  {\n', '    address _customerAddress           = msg.sender;\n', '    allowed[_customerAddress][spender] = tokens;\n', '\n', '    // Fire logging event.\n', '    emit Approval(_customerAddress, spender, tokens);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n', "   * No charge incurred for the transfer. No seriously, we'd make a terrible bank.\n", '   */\n', '  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n', '  public\n', '  returns(bool)\n', '  {\n', '    // Setup variables\n', '    address _customerAddress     = _from;\n', '    bytes memory empty;\n', "    // Make sure we own the tokens we're transferring, are ALLOWED to transfer that many tokens,\n", '    // and are transferring at least one full token.\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\n', '    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n', '\n', '    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '\n', '  }\n', '\n', '  function transferTo (address _from, address _to, uint _amountOfTokens, bytes _data)\n', '  public\n', '  {\n', '    if (_from != msg.sender){\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\n', '      && _amountOfTokens <= allowed[_from][msg.sender]);\n', '    }\n', '    else{\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n', '      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n', '    }\n', '\n', '    transferFromInternal(_from, _to, _amountOfTokens, _data);\n', '  }\n', '\n', "  // Who'd have thought we'd need this thing floating around?\n", '  function totalSupply()\n', '  public\n', '  view\n', '  returns (uint256)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\n', '  // In case the devs die. Or something.\n', '  function publicStartRegularPhase()\n', '  public\n', '  {\n', '    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\n', '\n', '    icoPhase     = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '\n', '  // Fire the starting gun and then duck for cover.\n', '  function startICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // Prevent us from startaring the ICO phase again\n', '    require(icoOpenTime == 0);\n', '    icoPhase = true;\n', '    icoOpenTime = now;\n', '  }\n', '\n', '  // Fire the ... ending gun?\n', '  function endICOPhase()\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    icoPhase = false;\n', '  }\n', '\n', '  function startRegularPhase()\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    // disable ico phase in case if that was not disabled yet\n', '    icoPhase = false;\n', '    regularPhase = true;\n', '  }\n', '\n', '  // The death of a great man demands the birth of a great son.\n', '  function setAdministrator(address _newAdmin, bool _status)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    administrators[_newAdmin] = _status;\n', '  }\n', '\n', '  function setStakingRequirement(uint _amountOfTokens)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    // This plane only goes one way, lads. Never below the initial.\n', '    require (_amountOfTokens >= 100e18);\n', '    stakingRequirement = _amountOfTokens;\n', '  }\n', '\n', '  function setName(string _name)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    name = _name;\n', '  }\n', '\n', '  function setSymbol(string _symbol)\n', '  onlyAdministrator()\n', '  public\n', '  {\n', '    symbol = _symbol;\n', '  }\n', '\n', '  function changeBankroll(address _newBankrollAddress)\n', '  onlyAdministrator\n', '  public\n', '  {\n', '    bankrollAddress = _newBankrollAddress;\n', '  }\n', '\n', '  /*----------  HELPERS AND CALCULATORS  ----------*/\n', '\n', '  function totalEthereumBalance()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function totalEthereumICOReceived()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return ethInvestedDuringICO;\n', '  }\n', '\n', '  /**\n', '   * Retrieves your currently selected dividend rate.\n', '   */\n', '  function getMyDividendRate()\n', '  public\n', '  view\n', '  returns(uint8)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    return userDividendRate[_customerAddress];\n', '  }\n', '\n', '  /**\n', '   * Retrieve the total frontend token supply\n', '   */\n', '  function getFrontEndTokenSupply()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retreive the total dividend token supply\n', '   */\n', '  function getDividendTokenSupply()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return divTokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retrieve the frontend tokens owned by the caller\n', '   */\n', '  function myFrontEndTokens()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getFrontEndTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  /**\n', '   * Retrieve the dividend tokens owned by the caller\n', '   */\n', '  function myDividendTokens()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return getDividendTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  function myReferralDividends()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return myDividends(true) - myDividends(false);\n', '  }\n', '\n', '  function myDividends(bool _includeReferralBonus)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    address _customerAddress = msg.sender;\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '  }\n', '\n', '  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '  }\n', '\n', '  function getFrontEndTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return frontTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return getFrontEndTokenBalanceOf(_owner);\n', '  }\n', '\n', '  function getDividendTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return dividendTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function dividendsOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint)\n', '  {\n', '    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '  }\n', '\n', "  // Get the sell price at the user's average dividend rate\n", '  function sellPrice()\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', "    // Factor in the user's average dividend rate\n", '    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n', '\n', '    return theSellPrice;\n', '  }\n', '\n', '  // Get the buy price at a particular dividend rate\n', '  function buyPrice(uint dividendRate)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint price;\n', '\n', '    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n', '      price = tokenPriceInitial_;\n', '    } else {\n', '\n', '      // Calculate the tokens received for 100 finney.\n', '      // Divide to find the average, to calculate the price.\n', '      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n', '\n', '      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n', '    }\n', '\n', "    // Factor in the user's selected dividend rate\n", '    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n', '\n', '    return theBuyPrice;\n', '  }\n', '\n', '  function calculateTokensReceived(uint _ethereumToSpend)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    uint _dividends      = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\n', '    uint _taxedEthereum  = _ethereumToSpend.sub(_dividends);\n', '    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '    return  _amountOfTokens;\n', '  }\n', '\n', "  // When selling tokens, we need to calculate the user's current dividend rate.\n", '  // This is different from their selected dividend rate.\n', '  function calculateEthereumReceived(uint _tokensToSell)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require(_tokensToSell <= tokenSupply);\n', '    uint _ethereum               = tokensToEthereum_(_tokensToSell);\n', '    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n', '    uint _dividends              = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\n', '    uint _taxedEthereum          = _ethereum.sub(_dividends);\n', '    return  _taxedEthereum;\n', '  }\n', '\n', '  /*\n', "   * Get's a user's average dividend rate - which is just their divTokenBalance / tokenBalance\n", '   * We multiply by magnitude to avoid precision errors.\n', '   */\n', '\n', '  function getUserAverageDividendRate(address user) public view returns (uint) {\n', '    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n', '  }\n', '\n', '  function getMyAverageDividendRate() public view returns (uint) {\n', '    return getUserAverageDividendRate(msg.sender);\n', '  }\n', '\n', '  /*==========================================\n', '  =            INTERNAL FUNCTIONS            =\n', '  ==========================================*/\n', '\n', '  /* Purchase tokens with Ether.\n', '     During ICO phase, dividends should go to the bankroll\n', '     During normal operation:\n', '       0.5% should go to the master dividend card\n', '       0.5% should go to the matching dividend card\n', '       25% of dividends should go to the referrer, if any is provided. */\n', '  function purchaseTokens(uint _incomingEthereum, address _referredBy)\n', '  internal\n', '  returns(uint)\n', '  {\n', '    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, "Tried to buy below the min eth buyin threshold.");\n', '\n', '    uint toBankRoll;\n', '    uint toReferrer;\n', '    uint toTokenHolders;\n', '    uint toDivCardHolders;\n', '\n', '    uint dividendAmount;\n', '\n', '    uint tokensBought;\n', '    uint dividendTokensBought;\n', '\n', '    uint remainingEth = _incomingEthereum;\n', '\n', '    uint fee;\n', '\n', '    // 1% for dividend card holders is taken off before anything else\n', '    if (regularPhase) {\n', '      toDivCardHolders = _incomingEthereum.div(100);\n', '      remainingEth = remainingEth.sub(toDivCardHolders);\n', '    }\n', '\n', '    /* Next, we tax for dividends:\n', '       Dividends = (ethereum * div%) / 100\n', "       Important note: if we're out of the ICO phase, the 1% sent to div-card holders\n", '                       is handled prior to any dividend taxes are considered. */\n', '\n', "    // Grab the user's dividend rate\n", '    uint dividendRate = userDividendRate[msg.sender];\n', '\n', '    // Calculate the total dividends on this buy\n', '    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\n', '\n', '    remainingEth   = remainingEth.sub(dividendAmount);\n', '\n', "    // If we're in the ICO and bankroll is buying, don't tax\n", '    if (icoPhase && msg.sender == bankrollAddress) {\n', '      remainingEth = remainingEth + dividendAmount;\n', '    }\n', '\n', '    // Calculate how many tokens to buy:\n', '    tokensBought         = ethereumToTokens_(remainingEth);\n', '    dividendTokensBought = tokensBought.mul(dividendRate);\n', '\n', '    // This is where we actually mint tokens:\n', '    tokenSupply    = tokenSupply.add(tokensBought);\n', '    divTokenSupply = divTokenSupply.add(dividendTokensBought);\n', '\n', '    /* Update the total investment tracker\n', '       Note that this must be done AFTER we calculate how many tokens are bought -\n', '       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\n', '\n', '    currentEthInvested = currentEthInvested + remainingEth;\n', '\n', '    // If ICO phase, all the dividends go to the bankroll\n', '    if (icoPhase) {\n', '      toBankRoll     = dividendAmount;\n', '\n', "      // If the bankroll is buying, we don't want to send eth back to the bankroll\n", "      // Instead, let's just give it the tokens it would get in an infinite recursive buy\n", '      if (msg.sender == bankrollAddress) {\n', '        toBankRoll = 0;\n', '      }\n', '\n', '      toReferrer     = 0;\n', '      toTokenHolders = 0;\n', '\n', '      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\n', '         not how much Ether we get total.\n', '         this is so that our calculation using "investment" is accurate. */\n', '      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\n', '      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\n', '\n', '      // Cannot purchase more than the hard cap during ICO.\n', '      require(ethInvestedDuringICO <= icoHardCap);\n', "      // Contracts aren't allowed to participate in the ICO.\n", '      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\n', '\n', '      // Cannot purchase more then the limit per address during the ICO.\n', '      ICOBuyIn[msg.sender] += remainingEth;\n', '      require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress);\n', '\n', '      // Stop the ICO phase if we reach the hard cap\n', '      if (ethInvestedDuringICO == icoHardCap){\n', '        icoPhase = false;\n', '      }\n', '\n', '    } else {\n', '      // Not ICO phase, check for referrals\n', '\n', '      // 25% goes to referrers, if set\n', '      // toReferrer = (dividends * 25)/100\n', '      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '      _referredBy != msg.sender &&\n', '      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\n', '      {\n', '        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n', '        referralBalance_[_referredBy] += toReferrer;\n', '        emit Referral(_referredBy, toReferrer);\n', '      }\n', '\n', '      // The rest of the dividends go to token holders\n', '      toTokenHolders = dividendAmount.sub(toReferrer);\n', '\n', '      fee = toTokenHolders * magnitude;\n', '      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\n', '\n', '      // Finally, increase the divToken value\n', '      profitPerDivToken       = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n', '      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\n', '    }\n', '\n', "    // Update the buyer's token amounts\n", '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\n', '\n', '    // Transfer to bankroll and div cards\n', '    if (toBankRoll != 0) { ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)(); }\n', '    if (regularPhase) { divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate); }\n', '\n', '    // This event should help us track where all the eth is going\n', '    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\n', '\n', '    // Sanity checking\n', '    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\n', '    assert(sum == 0);\n', '  }\n', '\n', '  // How many tokens one gets from a certain amount of ethereum.\n', '  function ethereumToTokens_(uint _ethereumAmount)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require(_ethereumAmount > MIN_ETH_BUYIN, "Tried to buy tokens with too little eth.");\n', '\n', '    if (icoPhase) {\n', '      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\n', '    }\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the buy into two segments:\n', '    //  1) the amount of eth going towards ico-price tokens\n', '    //  2) the amount of eth going towards pyramid-price (variable) tokens\n', '    uint ethTowardsICOPriceTokens = 0;\n', '    uint ethTowardsVariablePriceTokens = 0;\n', '\n', '    if (currentEthInvested >= ethInvestedDuringICO) {\n', '      // Option One: All the ETH goes towards variable-price tokens\n', '      ethTowardsVariablePriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\n', '      // Option Two: All the ETH goes towards ICO-price tokens\n', '      ethTowardsICOPriceTokens = _ethereumAmount;\n', '\n', '    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\n', '      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\n', '      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\n', '      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\n', '    } else {\n', '      // Option Four: Should be impossible, and compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\n', '\n', '    // Separate out the number of tokens of each type this will buy:\n', '    uint icoPriceTokens = 0;\n', '    uint varPriceTokens = 0;\n', '\n', '    // Now calculate each one per the above formulas.\n', '    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\n', '    if (ethTowardsICOPriceTokens != 0) {\n', '      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\n', '    }\n', '\n', '    if (ethTowardsVariablePriceTokens != 0) {\n', '      // Note: we can\'t use "currentEthInvested" for this calculation, we must use:\n', '      //  currentEthInvested + ethTowardsICOPriceTokens\n', '      // This is because a split-buy essentially needs to simulate two separate buys -\n', '      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\n', '\n', '      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\n', '      uint simulatedEthAfterInvested  = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\n', '\n', '      /* We have the equations for total tokens above; note that this is for TOTAL.\n', '         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\n', '         and the simulatedEthInvestedAfter and calculate the difference in tokens.\n', '         This is how many we get. */\n', '\n', '      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '      uint tokensAfter  = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '\n', '      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\n', '         either should work.\n', '\n', '         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n', '         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n', '\n', '      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n', '    }\n', '\n', '    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\n', '\n', '    assert(totalTokensReceived > 0);\n', '    return totalTokensReceived;\n', '  }\n', '\n', '  // How much Ether we get from selling N tokens\n', '  function tokensToEthereum_(uint _tokens)\n', '  public\n', '  view\n', '  returns(uint)\n', '  {\n', '    require (_tokens >= MIN_TOKEN_SELL_AMOUNT, "Tried to sell too few tokens.");\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    // First, separate out the sell into two segments:\n', '    //  1) the amount of tokens selling at the ICO price.\n', '    //  2) the amount of tokens selling at the variable (pyramid) price\n', '    uint tokensToSellAtICOPrice = 0;\n', '    uint tokensToSellAtVariablePrice = 0;\n', '\n', '    if (tokenSupply <= tokensMintedDuringICO) {\n', '      // Option One: All the tokens sell at the ICO price.\n', '      tokensToSellAtICOPrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\n', '      // Option Two: All the tokens sell at the variable price.\n', '      tokensToSellAtVariablePrice = _tokens;\n', '\n', '    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\n', '      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\n', '      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\n', '      tokensToSellAtICOPrice      = _tokens.sub(tokensToSellAtVariablePrice);\n', '\n', '    } else {\n', '      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\n', '      revert();\n', '    }\n', '\n', '    // Sanity check:\n', '    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\n', '\n', '    // Track how much Ether we get from selling at each price function:\n', '    uint ethFromICOPriceTokens;\n', '    uint ethFromVarPriceTokens;\n', '\n', '    // Now, actually calculate:\n', '\n', '    if (tokensToSellAtICOPrice != 0) {\n', '\n', "      /* Here, unlike the sister equation in ethereumToTokens, we DON'T need to multiply by 1e18, since\n", "         we will be passed in an amount of tokens to sell that's already at the 18-decimal precision.\n", "         We need to divide by 1e18 or we'll have too much Ether. */\n", '\n', '      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\n', '    }\n', '\n', '    if (tokensToSellAtVariablePrice != 0) {\n', '\n', '      /* Note: Unlike the sister function in ethereumToTokens, we don\'t have to calculate any "virtual" token count.\n', '         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\n', "         Thus there isn't any weird stuff going on with the token supply.\n", '\n', '         We have the equations for total investment above; note that this is for TOTAL.\n', '         To get the eth received from this sell, we calculate the new total investment after this sell.\n', '         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\n', '\n', '      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint investmentAfter  = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '\n', '      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n', '    }\n', '\n', '    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\n', '\n', '    assert(totalEthReceived > 0);\n', '    return totalEthReceived;\n', '  }\n', '\n', '  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n', '  internal\n', '  {\n', '    require(regularPhase);\n', '    require(_toAddress != address(0x0));\n', '    address _customerAddress     = _from;\n', '    uint _amountOfFrontEndTokens = _amountOfTokens;\n', '\n', '    // Withdraw all outstanding dividends first (including those generated from referrals).\n', '    if(theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n', '\n', '    // Calculate how many back-end dividend tokens to transfer.\n', "    // This amount is proportional to the caller's average dividend rate multiplied by the proportion of tokens being transferred.\n", '    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n', '\n', '    if (_customerAddress != msg.sender){\n', '      // Update the allowed balance.\n', "      // Don't update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n", '      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n', '    }\n', '\n', '    // Exchange tokens\n', '    frontTokenBalanceLedger_[_customerAddress]    = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n', '    frontTokenBalanceLedger_[_toAddress]          = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n', '    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n', '    dividendTokenBalanceLedger_[_toAddress]       = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n', '\n', '    // Recipient inherits dividend percentage if they have not already selected one.\n', '    if(!userSelectedRate[_toAddress])\n', '    {\n', '      userSelectedRate[_toAddress] = true;\n', '      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n', '    }\n', '\n', '    // Update dividend trackers\n', '    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\n', '    payoutsTo_[_toAddress]       += (int256) (profitPerDivToken * _amountOfDivTokens);\n', '\n', '    uint length;\n', '\n', '    assembly {\n', '      length := extcodesize(_toAddress)\n', '    }\n', '\n', '    if (length > 0){\n', '      // its a contract\n', '      // note: at ethereum update ALL addresses are contracts\n', '      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n', '      receiver.tokenFallback(_from, _amountOfTokens, _data);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n', '  }\n', '\n', '  // Called from transferFrom. Always checks if _customerAddress has dividends.\n', '  function withdrawFrom(address _customerAddress)\n', '  internal\n', '  {\n', '    // Setup data\n', '    uint _dividends                    = theDividendsOf(false, _customerAddress);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends                         += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress]  = 0;\n', '\n', '    _customerAddress.transfer(_dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_customerAddress, _dividends);\n', '  }\n', '\n', '\n', '  /*=======================\n', '   =    RESET FUNCTIONS   =\n', '   ======================*/\n', '\n', '  function injectEther()\n', '  public\n', '  payable\n', '  onlyAdministrator\n', '  {\n', '\n', '  }\n', '\n', '  /*=======================\n', '   =   MATHS FUNCTIONS    =\n', '   ======================*/\n', '\n', '  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\n', '    // m = 3, n = 2\n', '    // sqrt(x^3)\n', '    return sqrt(x**3);\n', '  }\n', '\n', '  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\n', '    // m = 2, n = 3\n', '    // cbrt(x^2)\n', '    return cbrt(x**2);\n', '  }\n', '\n', '  function sqrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / z + z) / 2;\n', '    }\n', '  }\n', '\n', '  function cbrt(uint x) public pure returns (uint y) {\n', '    uint z = (x + 1) / 3;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / (z*z) + 2 * z) / 3;\n', '    }\n', '  }\n', '}\n', '\n', '/*=======================\n', ' =     INTERFACES       =\n', ' ======================*/\n', '\n', '\n', 'contract ZethrDividendCards {\n', '  function ownerOf(uint /*_divCardId*/) public pure returns (address) {}\n', '  function receiveDividends(uint /*_divCardRate*/) public payable {}\n', '}\n', '\n', 'contract ZethrBankroll{\n', '  function receiveDividends() public payable {}\n', '}\n', '\n', '\n', 'contract ERC223Receiving {\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', "// Think it's safe to say y'all know what this is.\n", '\n', 'library SafeMath {\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
