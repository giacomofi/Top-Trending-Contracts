['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Starter Kit Contract \n', '/// @author Julia Altenried, Yuriy Kashnikov\n', 'contract StarterKit is Ownable {\n', '\n', '    /**  CONSTANTS **/\n', '    uint256 public constant COPPER_AMOUNT_NDC = 1000 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_TPT = 1500 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_SKL = 25 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_XPER = 12 * 10**2;\n', '\n', '    uint256 public constant BRONZE_AMOUNT_NDC = 2000 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_TPT = 4000 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_SKL = 50 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_XPER = 25 * 10**2;\n', '\n', '    uint256 public constant SILVER_AMOUNT_NDC = 11000 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_TPT = 33000 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_SKL = 100 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_XPER = 50 * 10**2;\n', '\n', '    uint256 public constant GOLD_AMOUNT_NDC = 25000 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_TPT = 100000 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_SKL = 200 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_XPER = 100 * 10**2;\n', '\n', '    uint256 public constant PLATINUM_AMOUNT_NDC = 250000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_TPT = 1250000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_SKL = 2000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_XPER = 500 * 10**2;\n', '\n', '\n', '    /* set of predefined token contract addresses and instances, can be set by owner only */\n', '    ERC20 public tpt;\n', '    ERC20 public ndc;\n', '    ERC20 public skl;\n', '    ERC20 public xper;\n', '\n', '    /* signer address, can be set by owner only */\n', '    address public neverdieSigner;\n', '\n', '    event BuyCopper(\n', '        address indexed to,\n', '        uint256 CopperPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyBronze(\n', '        address indexed to,\n', '        uint256 BronzePrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuySilver(\n', '        address indexed to,\n', '        uint256 SilverPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyGold(\n', '        address indexed to,\n', '        uint256 GoldPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyPlatinum(\n', '        address indexed to,\n', '        uint256 PlatinumPrice,\n', '        uint256 value\n', '    );\n', '\n', '\n', '    /// @dev handy constructor to initialize StarerKit with a set of proper parameters\n', '    /// @param _tptContractAddress TPT token address \n', '    /// @param _ndcContractAddress NDC token address\n', '    /// @param _signer signer address\n', '    function StarterKit(address _tptContractAddress, address _ndcContractAddress,\n', '                        address _sklContractAddress, address _xperContractAddress,\n', '                        address _signer) public {\n', '        tpt = ERC20(_tptContractAddress);\n', '        ndc = ERC20(_ndcContractAddress);\n', '        skl = ERC20(_sklContractAddress);\n', '        xper = ERC20(_xperContractAddress);\n', '        neverdieSigner = _signer;\n', '    }\n', '\n', '    function setNDCContractAddress(address _to) external onlyOwner {\n', '        ndc = ERC20(_to);\n', '    }\n', '\n', '    function setTPTContractAddress(address _to) external onlyOwner {\n', '        tpt = ERC20(_to);\n', '    }\n', '\n', '    function setSKLContractAddress(address _to) external onlyOwner {\n', '        skl = ERC20(_to);\n', '    }\n', '\n', '    function setXPERContractAddress(address _to) external onlyOwner {\n', '        xper = ERC20(_to);\n', '    }\n', '\n', '    function setSignerAddress(address _to) external onlyOwner {\n', '        neverdieSigner = _to;\n', '    }\n', '\n', '    /// @dev buy Copper with ether\n', '    /// @param _CopperPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyCopper(uint256 _CopperPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_CopperPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _CopperPrice);\n', '        \n', '        assert(ndc.transfer(msg.sender, COPPER_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, COPPER_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, COPPER_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, COPPER_AMOUNT_XPER));\n', '           \n', '\n', '        // Emit BuyCopper event\n', '        emit BuyCopper(msg.sender, _CopperPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Bronze with ether\n', '    /// @param _BronzePrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyBronze(uint256 _BronzePrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_BronzePrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _BronzePrice);\n', '        assert(ndc.transfer(msg.sender, BRONZE_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, BRONZE_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, BRONZE_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, BRONZE_AMOUNT_XPER));\n', '\n', '        // Emit BuyBronze event\n', '        emit BuyBronze(msg.sender, _BronzePrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Silver with ether\n', '    /// @param _SilverPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buySilver(uint256 _SilverPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_SilverPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _SilverPrice);\n', '        assert(ndc.transfer(msg.sender, SILVER_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, SILVER_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, SILVER_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, SILVER_AMOUNT_XPER));\n', '\n', '        // Emit BuySilver event\n', '        emit BuySilver(msg.sender, _SilverPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Gold with ether\n', '    /// @param _GoldPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyGold(uint256 _GoldPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_GoldPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _GoldPrice);\n', '        assert(ndc.transfer(msg.sender, GOLD_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, GOLD_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, GOLD_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, GOLD_AMOUNT_XPER));\n', '\n', '        // Emit BuyGold event\n', '        emit BuyGold(msg.sender, _GoldPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Platinum with ether\n', '    /// @param _PlatinumPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyPlatinum(uint256 _PlatinumPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_PlatinumPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _PlatinumPrice);\n', '        assert(ndc.transfer(msg.sender, PLATINUM_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, PLATINUM_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, PLATINUM_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, PLATINUM_AMOUNT_XPER));\n', '\n', '        // Emit BuyPlatinum event\n', '        emit BuyPlatinum(msg.sender, _PlatinumPrice, msg.value);\n', '    }\n', '\n', '    /// @dev withdraw all ether\n', '    function withdrawEther() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '      uint256 allNDC= ndc.balanceOf(this);\n', '      uint256 allTPT = tpt.balanceOf(this);\n', '      uint256 allSKL = skl.balanceOf(this);\n', '      uint256 allXPER = xper.balanceOf(this);\n', '      if (allNDC > 0) ndc.transfer(msg.sender, allNDC);\n', '      if (allTPT > 0) tpt.transfer(msg.sender, allTPT);\n', '      if (allSKL > 0) skl.transfer(msg.sender, allSKL);\n', '      if (allXPER > 0) xper.transfer(msg.sender, allXPER);\n', '    }\n', '\n', '    /// @dev withdraw token\n', '    /// @param _tokenContract any kind of ERC20 token to withdraw from\n', '    function withdrawToken(address _tokenContract) external onlyOwner {\n', '        ERC20 token = ERC20(_tokenContract);\n', '        uint256 balance = token.balanceOf(this);\n', '        assert(token.transfer(owner, balance));\n', '    }\n', '\n', '    /// @dev kill contract, but before transfer all tokens and ether to owner\n', '    function kill() onlyOwner public {\n', '      withdraw();\n', '      selfdestruct(owner);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Starter Kit Contract \n', '/// @author Julia Altenried, Yuriy Kashnikov\n', 'contract StarterKit is Ownable {\n', '\n', '    /**  CONSTANTS **/\n', '    uint256 public constant COPPER_AMOUNT_NDC = 1000 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_TPT = 1500 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_SKL = 25 * 10**18;\n', '    uint256 public constant COPPER_AMOUNT_XPER = 12 * 10**2;\n', '\n', '    uint256 public constant BRONZE_AMOUNT_NDC = 2000 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_TPT = 4000 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_SKL = 50 * 10**18;\n', '    uint256 public constant BRONZE_AMOUNT_XPER = 25 * 10**2;\n', '\n', '    uint256 public constant SILVER_AMOUNT_NDC = 11000 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_TPT = 33000 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_SKL = 100 * 10**18;\n', '    uint256 public constant SILVER_AMOUNT_XPER = 50 * 10**2;\n', '\n', '    uint256 public constant GOLD_AMOUNT_NDC = 25000 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_TPT = 100000 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_SKL = 200 * 10**18;\n', '    uint256 public constant GOLD_AMOUNT_XPER = 100 * 10**2;\n', '\n', '    uint256 public constant PLATINUM_AMOUNT_NDC = 250000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_TPT = 1250000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_SKL = 2000 * 10**18;\n', '    uint256 public constant PLATINUM_AMOUNT_XPER = 500 * 10**2;\n', '\n', '\n', '    /* set of predefined token contract addresses and instances, can be set by owner only */\n', '    ERC20 public tpt;\n', '    ERC20 public ndc;\n', '    ERC20 public skl;\n', '    ERC20 public xper;\n', '\n', '    /* signer address, can be set by owner only */\n', '    address public neverdieSigner;\n', '\n', '    event BuyCopper(\n', '        address indexed to,\n', '        uint256 CopperPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyBronze(\n', '        address indexed to,\n', '        uint256 BronzePrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuySilver(\n', '        address indexed to,\n', '        uint256 SilverPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyGold(\n', '        address indexed to,\n', '        uint256 GoldPrice,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyPlatinum(\n', '        address indexed to,\n', '        uint256 PlatinumPrice,\n', '        uint256 value\n', '    );\n', '\n', '\n', '    /// @dev handy constructor to initialize StarerKit with a set of proper parameters\n', '    /// @param _tptContractAddress TPT token address \n', '    /// @param _ndcContractAddress NDC token address\n', '    /// @param _signer signer address\n', '    function StarterKit(address _tptContractAddress, address _ndcContractAddress,\n', '                        address _sklContractAddress, address _xperContractAddress,\n', '                        address _signer) public {\n', '        tpt = ERC20(_tptContractAddress);\n', '        ndc = ERC20(_ndcContractAddress);\n', '        skl = ERC20(_sklContractAddress);\n', '        xper = ERC20(_xperContractAddress);\n', '        neverdieSigner = _signer;\n', '    }\n', '\n', '    function setNDCContractAddress(address _to) external onlyOwner {\n', '        ndc = ERC20(_to);\n', '    }\n', '\n', '    function setTPTContractAddress(address _to) external onlyOwner {\n', '        tpt = ERC20(_to);\n', '    }\n', '\n', '    function setSKLContractAddress(address _to) external onlyOwner {\n', '        skl = ERC20(_to);\n', '    }\n', '\n', '    function setXPERContractAddress(address _to) external onlyOwner {\n', '        xper = ERC20(_to);\n', '    }\n', '\n', '    function setSignerAddress(address _to) external onlyOwner {\n', '        neverdieSigner = _to;\n', '    }\n', '\n', '    /// @dev buy Copper with ether\n', '    /// @param _CopperPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyCopper(uint256 _CopperPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_CopperPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _CopperPrice);\n', '        \n', '        assert(ndc.transfer(msg.sender, COPPER_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, COPPER_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, COPPER_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, COPPER_AMOUNT_XPER));\n', '           \n', '\n', '        // Emit BuyCopper event\n', '        emit BuyCopper(msg.sender, _CopperPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Bronze with ether\n', '    /// @param _BronzePrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyBronze(uint256 _BronzePrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_BronzePrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _BronzePrice);\n', '        assert(ndc.transfer(msg.sender, BRONZE_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, BRONZE_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, BRONZE_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, BRONZE_AMOUNT_XPER));\n', '\n', '        // Emit BuyBronze event\n', '        emit BuyBronze(msg.sender, _BronzePrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Silver with ether\n', '    /// @param _SilverPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buySilver(uint256 _SilverPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_SilverPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _SilverPrice);\n', '        assert(ndc.transfer(msg.sender, SILVER_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, SILVER_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, SILVER_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, SILVER_AMOUNT_XPER));\n', '\n', '        // Emit BuySilver event\n', '        emit BuySilver(msg.sender, _SilverPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Gold with ether\n', '    /// @param _GoldPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyGold(uint256 _GoldPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_GoldPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _GoldPrice);\n', '        assert(ndc.transfer(msg.sender, GOLD_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, GOLD_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, GOLD_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, GOLD_AMOUNT_XPER));\n', '\n', '        // Emit BuyGold event\n', '        emit BuyGold(msg.sender, _GoldPrice, msg.value);\n', '    }\n', '\n', '    /// @dev buy Platinum with ether\n', '    /// @param _PlatinumPrice price in Wei\n', '    /// @param _expiration expiration timestamp\n', '    /// @param _v ECDCA signature\n', '    /// @param _r ECDSA signature\n', '    /// @param _s ECDSA signature\n', '    function buyPlatinum(uint256 _PlatinumPrice,\n', '                       uint256 _expiration,\n', '                       uint8 _v,\n', '                       bytes32 _r,\n', '                       bytes32 _s\n', '                      ) payable external {\n', '        // Check if the signature did not expire yet by inspecting the timestamp\n', '        require(_expiration >= block.timestamp);\n', '\n', '        // Check if the signature is coming from the neverdie address\n', '        address signer = ecrecover(keccak256(_PlatinumPrice, _expiration), _v, _r, _s);\n', '        require(signer == neverdieSigner);\n', '\n', '        require(msg.value >= _PlatinumPrice);\n', '        assert(ndc.transfer(msg.sender, PLATINUM_AMOUNT_NDC) \n', '            && tpt.transfer(msg.sender, PLATINUM_AMOUNT_TPT)\n', '            && skl.transfer(msg.sender, PLATINUM_AMOUNT_SKL)\n', '            && xper.transfer(msg.sender, PLATINUM_AMOUNT_XPER));\n', '\n', '        // Emit BuyPlatinum event\n', '        emit BuyPlatinum(msg.sender, _PlatinumPrice, msg.value);\n', '    }\n', '\n', '    /// @dev withdraw all ether\n', '    function withdrawEther() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '      uint256 allNDC= ndc.balanceOf(this);\n', '      uint256 allTPT = tpt.balanceOf(this);\n', '      uint256 allSKL = skl.balanceOf(this);\n', '      uint256 allXPER = xper.balanceOf(this);\n', '      if (allNDC > 0) ndc.transfer(msg.sender, allNDC);\n', '      if (allTPT > 0) tpt.transfer(msg.sender, allTPT);\n', '      if (allSKL > 0) skl.transfer(msg.sender, allSKL);\n', '      if (allXPER > 0) xper.transfer(msg.sender, allXPER);\n', '    }\n', '\n', '    /// @dev withdraw token\n', '    /// @param _tokenContract any kind of ERC20 token to withdraw from\n', '    function withdrawToken(address _tokenContract) external onlyOwner {\n', '        ERC20 token = ERC20(_tokenContract);\n', '        uint256 balance = token.balanceOf(this);\n', '        assert(token.transfer(owner, balance));\n', '    }\n', '\n', '    /// @dev kill contract, but before transfer all tokens and ether to owner\n', '    function kill() onlyOwner public {\n', '      withdraw();\n', '      selfdestruct(owner);\n', '    }\n', '\n', '}']
