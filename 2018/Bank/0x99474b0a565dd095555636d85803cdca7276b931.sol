['pragma solidity ^0.4.18;\n', '\n', 'contract AccessControl {\n', '    address public owner;\n', '    address[] public admins;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmins {\n', '        bool found = false;\n', '\n', '        for (uint i = 0; i < admins.length; i++) {\n', '            if (admins[i] == msg.sender) {\n', '                found = true;\n', '                break;\n', '            }\n', '        }\n', '        require(found);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address _adminAddress) public onlyOwner {\n', '        admins.push(_adminAddress);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract ERC721 {\n', '    // Required Functions\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) public view returns (address);\n', '    function transfer(address _to, uint _tokenId) public;\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '\n', '    // Optional Functions\n', '    function name() public pure returns (string);\n', '    function symbol() public pure returns (string);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '\n', '    // Required Events\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '}\n', '\n', '\n', 'contract CryptoLandmarks is AccessControl, ERC721 {\n', '    // Event fired for every new landmark created\n', '    event Creation(uint256 tokenId, string name, address owner);\n', '\n', '    // Event fired whenever landmark is sold\n', '    event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId);\n', '\n', '    // Event fired when price of landmark changes\n', '    event PriceChange(uint256 tokenId, uint256 price);\n', '\n', '    // Event fired when charities are modified\n', '    event Charity(uint256 charityId, address charity);\n', '\n', '    string public constant NAME = "Crypto Landmarks"; \n', '    string public constant SYMBOL = "LANDMARK"; \n', '\n', '    // Initial price of card\n', '    uint256 private startingPrice = 0.001 ether;\n', '\n', '    // Charities enabled in the future\n', '    bool charityEnabled;\n', '\n', '    // Landmark card\n', '    struct Landmark {\n', '        // unique name of landmark\n', '        string name;\n', '\n', '        // selling price\n', '        uint256 price;\n', '\n', '        // maximum price\n', '        uint256 maxPrice;\n', '    }\n', '\n', '    Landmark[] public landmarks;\n', '\n', '    address[] public charities;\n', '    \n', '    mapping (uint256 => address) public landmarkToOwner;\n', '    mapping (address => uint256) public landmarkOwnershipCount;\n', '    mapping (uint256 => address) public landmarkToApproved;\n', '\n', '    function CryptoLandmarks() public {\n', '        owner = msg.sender;\n', '        admins.push(msg.sender);\n', '        charityEnabled = false;\n', '    }\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return landmarks.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return landmarkOwnershipCount[_owner];\n', '    }\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n', '        owner = landmarkToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '    function transfer(address _to, uint256 _tokenId) public {\n', '        require(_to != address(0));\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    function approve(address _to, uint256 _tokenId) public {\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '        landmarkToApproved[_tokenId] = _to;\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '        require(landmarkToApproved[_tokenId] == _to);\n', '        require(_to != address(0));\n', '        require(landmarkToOwner[_tokenId] == _from);\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function addCharity(address _charity) public onlyAdmins {\n', '        require(_charity != address(0));\n', '\n', '        uint256 newCharityId = charities.push(_charity) - 1;\n', '\n', '        // emit charity event\n', '        Charity(newCharityId, _charity);\n', '    }\n', '\n', '    function deleteCharity(uint256 _charityId) public onlyAdmins {\n', '        delete charities[_charityId];\n', '\n', '        // emit charity event\n', '        Charity(_charityId, address(0));\n', '    }\n', '\n', '    function getCharity(uint256 _charityId) public view returns (address) {\n', '        return charities[_charityId];\n', '    }\n', '\n', '    function createLandmark(string _name, address _owner, uint256 _price) public onlyAdmins {\n', '        if (_price <= 0) {\n', '            _price = startingPrice;\n', '        }\n', '        \n', '        Landmark memory _landmark = Landmark({\n', '            name: _name,\n', '            price: _price,\n', '            maxPrice: _price\n', '        });\n', '        uint256 newLandmarkId = landmarks.push(_landmark) - 1;\n', '\n', '        Creation(newLandmarkId, _name, _owner);\n', '\n', '        _transfer(address(0), _owner, newLandmarkId);\n', '\n', '\n', '    }\n', '\n', '    function getLandmark(uint256 _tokenId) public view returns (\n', '        string landmarkName,\n', '        uint256 sellingPrice,\n', '        uint256 maxPrice,\n', '        address owner\n', '    ) {\n', '        Landmark storage landmark = landmarks[_tokenId];\n', '        landmarkName = landmark.name;\n', '        sellingPrice = landmark.price;\n', '        maxPrice = landmark.maxPrice;\n', '        owner = landmarkToOwner[_tokenId];\n', '    }\n', '\n', '    function purchase(uint256 _tokenId, uint256 _charityId) public payable {\n', '        // seller\n', '        address oldOwner = landmarkToOwner[_tokenId];\n', '        // current price\n', '        uint sellingPrice = landmarks[_tokenId].price;\n', '        // buyer\n', '        address newOwner = msg.sender;\n', '        \n', '        \n', '        require(oldOwner != newOwner);\n', '        require(newOwner != address(0));\n', '        require(msg.value >= sellingPrice);\n', '\n', '        uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 95), 100));\n', '        uint256 excess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '        if (charityEnabled == true) {\n', '            \n', '            // address of choosen charity\n', '            address charity = charities[_charityId];\n', '\n', '            // check if charity address is not null\n', '            require(charity != address(0));\n', '            \n', '            // 1% of selling price\n', '            uint256 donate = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 1), 100));\n', '\n', '            // transfer money to charity\n', '            charity.transfer(donate);\n', '            \n', '        }\n', '\n', '        uint priceIncrease = 120;\n', '\n', '        // price doubles below 32 finney\n', '        if (sellingPrice <= 32 finney) {\n', '            priceIncrease = 200;\n', '        }\n', '\n', '        // set new price\n', '        landmarks[_tokenId].price = SafeMath.div(SafeMath.mul(sellingPrice, priceIncrease), 95);\n', '        \n', '        // set maximum price\n', '        landmarks[_tokenId].maxPrice = SafeMath.div(SafeMath.mul(sellingPrice, priceIncrease), 95);\n', '\n', '        // transfer card to buyer\n', '        _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '        // transfer money to seller\n', '        if (oldOwner != address(this)) {\n', '            oldOwner.transfer(payment);\n', '        }\n', '\n', '        // emit event that landamrk was sold;\n', '        Purchase(_tokenId, sellingPrice, landmarks[_tokenId].price, oldOwner, newOwner, _charityId);\n', '        \n', '\n', '        // transfer excess back to buyer\n', '        newOwner.transfer(excess);\n', '    }\n', '\n', '    // owner can change price\n', '    function changePrice(uint256 _tokenId, uint256 _price) public {\n', '        // only owner can change price\n', '        require(landmarkToOwner[_tokenId] == msg.sender);\n', '\n', '        // price cannot be higher than maximum price\n', '        require(landmarks[_tokenId].maxPrice >= _price);\n', '\n', '        // set new price\n', '        landmarks[_tokenId].price = _price;\n', '        \n', '        // emit event\n', '        PriceChange(_tokenId, _price);\n', '    }\n', '\n', '    function priceOfLandmark(uint256 _tokenId) public view returns (uint256) {\n', '        return landmarks[_tokenId].price;\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) public view returns(uint256[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint256[] memory result = new uint256[](tokenCount);\n', '        uint256 total = totalSupply();\n', '        uint256 resultIndex = 0;\n', '\n', '        for(uint256 i = 0; i <= total; i++) {\n', '            if (landmarkToOwner[i] == _owner) {\n', '                result[resultIndex] = i;\n', '                resultIndex++;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '        landmarkOwnershipCount[_to]++;\n', '        landmarkToOwner[_tokenId] = _to;\n', '\n', '        if (_from != address(0)) {\n', '            landmarkOwnershipCount[_from]--;\n', '            delete landmarkToApproved[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function enableCharity() external onlyOwner {\n', '        require(!charityEnabled);\n', '        charityEnabled = true;\n', '    }\n', '\n', '    function disableCharity() external onlyOwner {\n', '        require(charityEnabled);\n', '        charityEnabled = false;\n', '    }\n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']