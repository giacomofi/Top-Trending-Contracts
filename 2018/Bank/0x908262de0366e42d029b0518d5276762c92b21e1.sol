['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    * @notice Renouncing to ownership will leave the contract without an owner.\n', '    * It will not be possible to call the functions with the `onlyOwner`\n', '    * modifier anymore.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @notice The Orderbook contract stores the state and priority of orders and\n', '/// allows the Darknodes to easily reach consensus. Eventually, this contract\n', '/// will only store a subset of order states, such as cancellation, to improve\n', '/// the throughput of orders.\n', 'contract Orderbook  {\n', '    /// @notice OrderState enumerates the possible states of an order. All\n', '    /// orders default to the Undefined state.\n', '    enum OrderState {Undefined, Open, Confirmed, Canceled}\n', '\n', '    /// @notice returns a list of matched orders to the given orderID.\n', '    function orderMatch(bytes32 _orderID) external view returns (bytes32);\n', '\n', '    /// @notice returns the trader of the given orderID.\n', '    /// Trader is the one who signs the message and does the actual trading.\n', '    function orderTrader(bytes32 _orderID) external view returns (address);\n', '\n', '    /// @notice returns status of the given orderID.\n', '    function orderState(bytes32 _orderID) external view returns (OrderState);\n', '\n', '    /// @notice returns the darknode address which confirms the given orderID.\n', '    function orderConfirmer(bytes32 _orderID) external view returns (address);\n', '}\n', '\n', '\n', '/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\n', 'contract RenExTokens is Ownable {\n', '    struct TokenDetails {\n', '        address addr;\n', '        uint8 decimals;\n', '        bool registered;\n', '    }\n', '\n', '    mapping(uint32 => TokenDetails) public tokens;\n', '\n', '    /// @notice Allows the owner to register and the details for a token.\n', '    /// Once details have been submitted, they cannot be overwritten.\n', '    /// To re-register the same token with different details (e.g. if the address\n', '    /// has changed), a different token identifier should be used and the\n', '    /// previous token identifier should be deregistered.\n', '    /// If a token is not Ethereum-based, the address will be set to 0x0.\n', '    ///\n', '    /// @param _tokenCode A unique 32-bit token identifier.\n', '    /// @param _tokenAddress The address of the token.\n', '    /// @param _tokenDecimals The decimals to use for the token.\n', '    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner;\n', '\n', '    /// @notice Sets a token as being deregistered. The details are still stored\n', '    /// to prevent the token from being re-registered with different details.\n', '    ///\n', '    /// @param _tokenCode The unique 32-bit token identifier.\n', '    function deregisterToken(uint32 _tokenCode) external onlyOwner;\n', '}\n', '\n', '\n', '/// @notice RenExBalances is responsible for holding RenEx trader funds.\n', 'contract RenExBalances {\n', '    address public settlementContract;\n', '\n', '    /// @notice Restricts a function to only being called by the RenExSettlement\n', '    /// contract.\n', '    modifier onlyRenExSettlementContract() {\n', '        require(msg.sender == address(settlementContract), "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice Transfer a token value from one trader to another, transferring\n', '    /// a fee to the RewardVault. Can only be called by the RenExSettlement\n', '    /// contract.\n', '    ///\n', '    /// @param _traderFrom The address of the trader to decrement the balance of.\n', '    /// @param _traderTo The address of the trader to increment the balance of.\n', '    /// @param _token The token&#39;s address.\n', '    /// @param _value The number of tokens to decrement the balance by (in the\n', '    ///        token&#39;s smallest unit).\n', '    /// @param _fee The fee amount to forward on to the RewardVault.\n', '    /// @param _feePayee The recipient of the fee.\n', '    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\n', '    external onlyRenExSettlementContract;\n', '}\n', '\n', '\n', '/// @notice A library for calculating and verifying order match details\n', 'library SettlementUtils {\n', '\n', '    struct OrderDetails {\n', '        uint64 settlementID;\n', '        uint64 tokens;\n', '        uint256 price;\n', '        uint256 volume;\n', '        uint256 minimumVolume;\n', '    }\n', '\n', '    /// @notice Calculates the ID of the order.\n', '    /// @param details Order details that are not required for settlement\n', '    ///        execution. They are combined as a single byte array.\n', '    /// @param order The order details required for settlement execution.\n', '    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                details,\n', '                order.settlementID,\n', '                order.tokens,\n', '                order.price,\n', '                order.volume,\n', '                order.minimumVolume\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice Verifies that two orders match when considering the tokens,\n', '    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\n', '    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\n', '    /// use this function.\n', '    /// @dev When verifying two orders for settlement, you should also:\n', '    ///   1) verify the orders have been confirmed together\n', '    ///   2) verify the orders&#39; traders are distinct\n', '    /// @param _buy The buy order details.\n', '    /// @param _sell The sell order details.\n', '    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\n', '\n', '        // Buy and sell tokens should match\n', '        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\n', '            return false;\n', '        }\n', '\n', '        // Buy price should be greater than sell price\n', '        if (_buy.price < _sell.price) {\n', '            return false;\n', '        }\n', '\n', '        // // Buy volume should be greater than sell minimum volume\n', '        if (_buy.volume < _sell.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Sell volume should be greater than buy minimum volume\n', '        if (_sell.volume < _buy.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Require that the orders were submitted to the same settlement layer\n', '        if (_buy.settlementID != _sell.settlementID) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Verifies that two token requirements can be matched and that the\n', '    /// tokens are formatted correctly.\n', '    /// @param _buyTokens The buy token details.\n', '    /// @param _sellToken The sell token details.\n', '    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\n', '        return ((\n', '                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\n', '                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\n', '                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\n', '        );\n', '    }\n', '}\n', '\n', '/// @notice RenExSettlement implements the Settlement interface. It implements\n', '/// the on-chain settlement for the RenEx settlement layer, and the fee payment\n', '/// for the RenExAtomic settlement layer.\n', 'contract RenExSettlement is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // This contract handles the settlements with ID 1 and 2.\n', '    uint32 constant public RENEX_SETTLEMENT_ID = 1;\n', '    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\n', '\n', '    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\n', '    // a numerator and denominator.\n', '    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\n', '    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\n', '\n', '    // Constants used in the price / volume inputs.\n', '    int16 constant private PRICE_OFFSET = 12;\n', '    int16 constant private VOLUME_OFFSET = 12;\n', '\n', '    // Constructor parameters, updatable by the owner\n', '    Orderbook public orderbookContract;\n', '    RenExTokens public renExTokensContract;\n', '    RenExBalances public renExBalancesContract;\n', '    address public slasherAddress;\n', '    uint256 public submissionGasPriceLimit;\n', '\n', '    enum OrderStatus {None, Submitted, Settled, Slashed}\n', '\n', '    struct TokenPair {\n', '        RenExTokens.TokenDetails priorityToken;\n', '        RenExTokens.TokenDetails secondaryToken;\n', '    }\n', '\n', '    // A uint256 tuple representing a value and an associated fee\n', '    struct ValueWithFees {\n', '        uint256 value;\n', '        uint256 fees;\n', '    }\n', '\n', '    // A uint256 tuple representing a fraction\n', '    struct Fraction {\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '    }\n', '\n', '    // We use left and right because the tokens do not always represent the\n', '    // priority and secondary tokens.\n', '    struct SettlementDetails {\n', '        uint256 leftVolume;\n', '        uint256 rightVolume;\n', '        uint256 leftTokenFee;\n', '        uint256 rightTokenFee;\n', '        address leftTokenAddress;\n', '        address rightTokenAddress;\n', '    }\n', '\n', '    // Events\n', '    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\n', '    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\n', '    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\n', '    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    // Order Storage\n', '    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\n', '    mapping(bytes32 => address) public orderSubmitter;\n', '    mapping(bytes32 => OrderStatus) public orderStatus;\n', '\n', '    // Match storage (match details are indexed by [buyID][sellID])\n', '    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\n', '\n', '    /// @notice Prevents a function from being called with a gas price higher\n', '    /// than the specified limit.\n', '    ///\n', '    /// @param _gasPriceLimit The gas price upper-limit in Wei.\n', '    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\n', '        require(tx.gasprice <= _gasPriceLimit, "gas price too high");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the slasher\n', '    /// address.\n', '    modifier onlySlasher() {\n', '        require(msg.sender == slasherAddress, "unauthorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _orderbookContract The address of the Orderbook contract.\n', '    /// @param _renExBalancesContract The address of the RenExBalances\n', '    ///        contract.\n', '    /// @param _renExTokensContract The address of the RenExTokens contract.\n', '    constructor(\n', '        string _VERSION,\n', '        Orderbook _orderbookContract,\n', '        RenExTokens _renExTokensContract,\n', '        RenExBalances _renExBalancesContract,\n', '        address _slasherAddress,\n', '        uint256 _submissionGasPriceLimit\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        orderbookContract = _orderbookContract;\n', '        renExTokensContract = _renExTokensContract;\n', '        renExBalancesContract = _renExBalancesContract;\n', '        slasherAddress = _slasherAddress;\n', '        submissionGasPriceLimit = _submissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the Orderbook address.\n', '    /// @param _newOrderbookContract The address of the new Orderbook contract.\n', '    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\n', '        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\n', '        orderbookContract = _newOrderbookContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the RenExTokens address.\n', '    /// @param _newRenExTokensContract The address of the new RenExTokens\n', '    ///       contract.\n', '    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\n', '        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\n', '        renExTokensContract = _newRenExTokensContract;\n', '    }\n', '    \n', '    /// @notice The owner of the contract can update the RenExBalances address.\n', '    /// @param _newRenExBalancesContract The address of the new RenExBalances\n', '    ///       contract.\n', '    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\n', '        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\n', '        renExBalancesContract = _newRenExBalancesContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the order submission gas\n', '    /// price limit.\n', '    /// @param _newSubmissionGasPriceLimit The new gas price limit.\n', '    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\n', '        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\n', '        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the slasher address.\n', '    /// @param _newSlasherAddress The new slasher address.\n', '    function updateSlasher(address _newSlasherAddress) external onlyOwner {\n', '        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\n', '        slasherAddress = _newSlasherAddress;\n', '    }\n', '\n', '    /// @notice Stores the details of an order.\n', '    ///\n', '    /// @param _prefix The miscellaneous details of the order required for\n', '    ///        calculating the order id.\n', '    /// @param _settlementID The settlement identifier.\n', '    /// @param _tokens The encoding of the token pair (buy token is encoded as\n', '    ///        the first 32 bytes and sell token is encoded as the last 32\n', '    ///        bytes).\n', '    /// @param _price The price of the order. Interpreted as the cost for 1\n', '    ///        standard unit of the non-priority token, in 1e12 (i.e.\n', '    ///        PRICE_OFFSET) units of the priority token).\n', '    /// @param _volume The volume of the order. Interpreted as the maximum\n', '    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\n', '    ///        token that can be traded by this order.\n', '    /// @param _minimumVolume The minimum volume the trader is willing to\n', '    ///        accept. Encoded the same as the volume.\n', '    function submitOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external withGasPriceLimit(submissionGasPriceLimit) {\n', '\n', '        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        });\n', '        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\n', '\n', '        require(orderStatus[orderID] == OrderStatus.None, "order already submitted");\n', '        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, "unconfirmed order");\n', '\n', '        orderSubmitter[orderID] = msg.sender;\n', '        orderStatus[orderID] = OrderStatus.Submitted;\n', '        orderDetails[orderID] = order;\n', '    }\n', '\n', '    /// @notice Settles two orders that are matched. `submitOrder` must have been\n', '    /// called for each order before this function is called.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    function settle(bytes32 _buyID, bytes32 _sellID) external {\n', '        require(orderStatus[_buyID] == OrderStatus.Submitted, "invalid buy status");\n', '        require(orderStatus[_sellID] == OrderStatus.Submitted, "invalid sell status");\n', '\n', '        // Check the settlement ID (only have to check for one, since\n', '        // `verifyMatchDetails` checks that they are the same)\n', '        require(\n', '            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\n', '            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\n', '            "invalid settlement id"\n', '        );\n', '\n', '        // Verify that the two order details are compatible.\n', '        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), "incompatible orders");\n', '\n', '        // Verify that the two orders have been confirmed to one another.\n', '        require(orderbookContract.orderMatch(_buyID) == _sellID, "unconfirmed orders");\n', '\n', '        // Retrieve token details.\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\n', '\n', '        // Require that the tokens have been registered.\n', '        require(tokens.priorityToken.registered, "unregistered priority token");\n', '        require(tokens.secondaryToken.registered, "unregistered secondary token");\n', '\n', '        address buyer = orderbookContract.orderTrader(_buyID);\n', '        address seller = orderbookContract.orderTrader(_sellID);\n', '\n', '        require(buyer != seller, "orders from same trader");\n', '\n', '        execute(_buyID, _sellID, buyer, seller, tokens);\n', '\n', '        /* solium-disable-next-line security/no-block-members */\n', '        matchTimestamp[_buyID][_sellID] = now;\n', '\n', '        // Store that the orders have been settled.\n', '        orderStatus[_buyID] = OrderStatus.Settled;\n', '        orderStatus[_sellID] = OrderStatus.Settled;\n', '    }\n', '\n', '    /// @notice Slashes the bond of a guilty trader. This is called when an\n', '    /// atomic swap is not executed successfully.\n', '    /// To open an atomic order, a trader must have a balance equivalent to\n', '    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\n', '    /// darknode fees when the order is matched. If the remaining amount is\n', '    /// is slashed, it is distributed as follows:\n', '    ///   1) 0.2% goes to the other trader, covering their fee\n', '    ///   2) 0.2% goes to the slasher address\n', '    /// Only one order in a match can be slashed.\n', '    ///\n', '    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\n', '    function slash(bytes32 _guiltyOrderID) external onlySlasher {\n', '        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, "slashing non-atomic trade");\n', '\n', '        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\n', '\n', '        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, "invalid order status");\n', '        require(orderStatus[innocentOrderID] == OrderStatus.Settled, "invalid order status");\n', '        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\n', '\n', '        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\n', '            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\n', '\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\n', '\n', '        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\n', '\n', '        // Transfer the fee amount to the other trader\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            orderbookContract.orderTrader(innocentOrderID),\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '\n', '        // Transfer the fee amount to the slasher\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            slasherAddress,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '    }\n', '\n', '    /// @notice Retrieves the settlement details of an order.\n', '    /// For atomic swaps, it returns the full volumes, not the settled fees.\n', '    ///\n', '    /// @param _orderID The order to lookup the details of. Can be the ID of a\n', '    ///        buy or a sell order.\n', '    /// @return [\n', '    ///     a boolean representing whether or not the order has been settled,\n', '    ///     a boolean representing whether or not the order is a buy\n', '    ///     the 32-byte order ID of the matched order\n', '    ///     the volume of the priority token,\n', '    ///     the volume of the secondary token,\n', '    ///     the fee paid in the priority token,\n', '    ///     the fee paid in the secondary token,\n', '    ///     the token code of the priority token,\n', '    ///     the token code of the secondary token\n', '    /// ]\n', '    function getMatchDetails(bytes32 _orderID)\n', '    external view returns (\n', '        bool settled,\n', '        bool orderIsBuy,\n', '        bytes32 matchedID,\n', '        uint256 priorityVolume,\n', '        uint256 secondaryVolume,\n', '        uint256 priorityFee,\n', '        uint256 secondaryFee,\n', '        uint32 priorityToken,\n', '        uint32 secondaryToken\n', '    ) {\n', '        matchedID = orderbookContract.orderMatch(_orderID);\n', '\n', '        orderIsBuy = isBuyOrder(_orderID);\n', '\n', '        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\n', '            (_orderID, matchedID) : (matchedID, _orderID);\n', '\n', '        SettlementDetails memory settlementDetails = calculateSettlementDetails(\n', '            buyID,\n', '            sellID,\n', '            getTokenDetails(orderDetails[buyID].tokens)\n', '        );\n', '\n', '        return (\n', '            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\n', '            orderIsBuy,\n', '            matchedID,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.leftTokenFee,\n', '            settlementDetails.rightTokenFee,\n', '            uint32(orderDetails[buyID].tokens >> 32),\n', '            uint32(orderDetails[buyID].tokens)\n', '        );\n', '    }\n', '\n', '    /// @notice Exposes the hashOrder function for computing a hash of an\n', '    /// order&#39;s details. An order hash is used as its ID. See `submitOrder`\n', '    /// for the parameter descriptions.\n', '    ///\n', '    /// @return The 32-byte hash of the order.\n', '    function hashOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external pure returns (bytes32) {\n', '        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        }));\n', '    }\n', '\n', '    /// @notice Called by `settle`, executes the settlement for a RenEx order\n', '    /// or distributes the fees for a RenExAtomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _buyer The address of the buy trader.\n', '    /// @param _seller The address of the sell trader.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    function execute(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        address _buyer,\n', '        address _seller,\n', '        TokenPair memory _tokens\n', '    ) private {\n', '        // Calculate the fees for atomic swaps, and the settlement details\n', '        // otherwise.\n', '        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\n', '            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\n', '            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\n', '\n', '        // Transfer priority token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _buyer,\n', '            _seller,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.leftTokenFee,\n', '            orderSubmitter[_buyID]\n', '        );\n', '\n', '        // Transfer secondary token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _seller,\n', '            _buyer,\n', '            settlementDetails.rightTokenAddress,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.rightTokenFee,\n', '            orderSubmitter[_sellID]\n', '        );\n', '    }\n', '\n', '    /// @notice Calculates the details required to execute two matched orders.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the settlement details.\n', '    function calculateSettlementDetails(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        uint256 priorityTokenVolume = joinFraction(\n', '            commonVolume.mul(midPrice.numerator),\n', '            midPrice.denominator,\n', '            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '        );\n', '        uint256 secondaryTokenVolume = joinFraction(\n', '            commonVolume,\n', '            1,\n', '            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '        );\n', '\n', '        // Calculate darknode fees\n', '        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '        return SettlementDetails({\n', '            leftVolume: priorityVwF.value,\n', '            rightVolume: secondaryVwF.value,\n', '            leftTokenFee: priorityVwF.fees,\n', '            rightTokenFee: secondaryVwF.fees,\n', '            leftTokenAddress: _tokens.priorityToken.addr,\n', '            rightTokenAddress: _tokens.secondaryToken.addr\n', '        });\n', '    }\n', '\n', '    /// @notice Calculates the fees to be transferred for an atomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the fee details.\n', '    function calculateAtomicFees(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        if (isEthereumBased(_tokens.secondaryToken.addr)) {\n', '            uint256 secondaryTokenVolume = joinFraction(\n', '                commonVolume,\n', '                1,\n', '                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: secondaryVwF.fees,\n', '                rightTokenFee: secondaryVwF.fees,\n', '                leftTokenAddress: _tokens.secondaryToken.addr,\n', '                rightTokenAddress: _tokens.secondaryToken.addr\n', '            });\n', '        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\n', '            uint256 priorityTokenVolume = joinFraction(\n', '                commonVolume.mul(midPrice.numerator),\n', '                midPrice.denominator,\n', '                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: priorityVwF.fees,\n', '                rightTokenFee: priorityVwF.fees,\n', '                leftTokenAddress: _tokens.priorityToken.addr,\n', '                rightTokenAddress: _tokens.priorityToken.addr\n', '            });\n', '        } else {\n', '            // Currently, at least one token must be Ethereum-based.\n', '            // This will be implemented in the future.\n', '            revert("non-eth atomic swaps are not supported");\n', '        }\n', '    }\n', '\n', '    /// @notice Order parity is set by the order tokens are listed. This returns\n', '    /// whether an order is a buy or a sell.\n', '    /// @return true if _orderID is a buy order.\n', '    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\n', '        uint64 tokens = orderDetails[_orderID].tokens;\n', '        uint32 firstToken = uint32(tokens >> 32);\n', '        uint32 secondaryToken = uint32(tokens);\n', '        return (firstToken < secondaryToken);\n', '    }\n', '\n', '    /// @return (value - fee, fee) where fee is 0.2% of value\n', '    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\n', '        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\n', '        return ValueWithFees(newValue, _value - newValue);\n', '    }\n', '\n', '    /// @notice Gets the order details of the priority and secondary token from\n', '    /// the RenExTokens contract and returns them as a single struct.\n', '    ///\n', '    /// @param _tokens The 64-bit combined token identifiers.\n', '    /// @return A TokenPair struct containing two TokenDetails structs.\n', '    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\n', '        (\n', '            address priorityAddress,\n', '            uint8 priorityDecimals,\n', '            bool priorityRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\n', '\n', '        (\n', '            address secondaryAddress,\n', '            uint8 secondaryDecimals,\n', '            bool secondaryRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens));\n', '\n', '        return TokenPair({\n', '            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\n', '            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\n', '        });\n', '    }\n', '\n', '    /// @return true if _tokenAddress is 0x0, representing a token that is not\n', '    /// on Ethereum\n', '    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\n', '        return (_tokenAddress != address(0x0));\n', '    }\n', '\n', '    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\n', '    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\n', '        if (_scale >= 0) {\n', '            // Check that (10**_scale) doesn&#39;t overflow\n', '            assert(_scale <= 77); // log10(2**256) = 77.06\n', '            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\n', '        } else {\n', '            /// @dev If _scale is less than -77, 10**-_scale would overflow.\n', '            // For now, -_scale > -24 (when a token has 0 decimals and\n', '            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\n', '            // will be increased to add to more than 77.\n', '            // assert((-_scale) <= 77); // log10(2**256) = 77.06\n', '            return (_numerator / _denominator) / 10 ** uint256(-_scale);\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    * @notice Renouncing to ownership will leave the contract without an owner.\n', '    * It will not be possible to call the functions with the `onlyOwner`\n', '    * modifier anymore.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @notice The Orderbook contract stores the state and priority of orders and\n', '/// allows the Darknodes to easily reach consensus. Eventually, this contract\n', '/// will only store a subset of order states, such as cancellation, to improve\n', '/// the throughput of orders.\n', 'contract Orderbook  {\n', '    /// @notice OrderState enumerates the possible states of an order. All\n', '    /// orders default to the Undefined state.\n', '    enum OrderState {Undefined, Open, Confirmed, Canceled}\n', '\n', '    /// @notice returns a list of matched orders to the given orderID.\n', '    function orderMatch(bytes32 _orderID) external view returns (bytes32);\n', '\n', '    /// @notice returns the trader of the given orderID.\n', '    /// Trader is the one who signs the message and does the actual trading.\n', '    function orderTrader(bytes32 _orderID) external view returns (address);\n', '\n', '    /// @notice returns status of the given orderID.\n', '    function orderState(bytes32 _orderID) external view returns (OrderState);\n', '\n', '    /// @notice returns the darknode address which confirms the given orderID.\n', '    function orderConfirmer(bytes32 _orderID) external view returns (address);\n', '}\n', '\n', '\n', '/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\n', 'contract RenExTokens is Ownable {\n', '    struct TokenDetails {\n', '        address addr;\n', '        uint8 decimals;\n', '        bool registered;\n', '    }\n', '\n', '    mapping(uint32 => TokenDetails) public tokens;\n', '\n', '    /// @notice Allows the owner to register and the details for a token.\n', '    /// Once details have been submitted, they cannot be overwritten.\n', '    /// To re-register the same token with different details (e.g. if the address\n', '    /// has changed), a different token identifier should be used and the\n', '    /// previous token identifier should be deregistered.\n', '    /// If a token is not Ethereum-based, the address will be set to 0x0.\n', '    ///\n', '    /// @param _tokenCode A unique 32-bit token identifier.\n', '    /// @param _tokenAddress The address of the token.\n', '    /// @param _tokenDecimals The decimals to use for the token.\n', '    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner;\n', '\n', '    /// @notice Sets a token as being deregistered. The details are still stored\n', '    /// to prevent the token from being re-registered with different details.\n', '    ///\n', '    /// @param _tokenCode The unique 32-bit token identifier.\n', '    function deregisterToken(uint32 _tokenCode) external onlyOwner;\n', '}\n', '\n', '\n', '/// @notice RenExBalances is responsible for holding RenEx trader funds.\n', 'contract RenExBalances {\n', '    address public settlementContract;\n', '\n', '    /// @notice Restricts a function to only being called by the RenExSettlement\n', '    /// contract.\n', '    modifier onlyRenExSettlementContract() {\n', '        require(msg.sender == address(settlementContract), "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice Transfer a token value from one trader to another, transferring\n', '    /// a fee to the RewardVault. Can only be called by the RenExSettlement\n', '    /// contract.\n', '    ///\n', '    /// @param _traderFrom The address of the trader to decrement the balance of.\n', '    /// @param _traderTo The address of the trader to increment the balance of.\n', "    /// @param _token The token's address.\n", '    /// @param _value The number of tokens to decrement the balance by (in the\n', "    ///        token's smallest unit).\n", '    /// @param _fee The fee amount to forward on to the RewardVault.\n', '    /// @param _feePayee The recipient of the fee.\n', '    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\n', '    external onlyRenExSettlementContract;\n', '}\n', '\n', '\n', '/// @notice A library for calculating and verifying order match details\n', 'library SettlementUtils {\n', '\n', '    struct OrderDetails {\n', '        uint64 settlementID;\n', '        uint64 tokens;\n', '        uint256 price;\n', '        uint256 volume;\n', '        uint256 minimumVolume;\n', '    }\n', '\n', '    /// @notice Calculates the ID of the order.\n', '    /// @param details Order details that are not required for settlement\n', '    ///        execution. They are combined as a single byte array.\n', '    /// @param order The order details required for settlement execution.\n', '    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                details,\n', '                order.settlementID,\n', '                order.tokens,\n', '                order.price,\n', '                order.volume,\n', '                order.minimumVolume\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice Verifies that two orders match when considering the tokens,\n', '    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\n', '    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\n', '    /// use this function.\n', '    /// @dev When verifying two orders for settlement, you should also:\n', '    ///   1) verify the orders have been confirmed together\n', "    ///   2) verify the orders' traders are distinct\n", '    /// @param _buy The buy order details.\n', '    /// @param _sell The sell order details.\n', '    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\n', '\n', '        // Buy and sell tokens should match\n', '        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\n', '            return false;\n', '        }\n', '\n', '        // Buy price should be greater than sell price\n', '        if (_buy.price < _sell.price) {\n', '            return false;\n', '        }\n', '\n', '        // // Buy volume should be greater than sell minimum volume\n', '        if (_buy.volume < _sell.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Sell volume should be greater than buy minimum volume\n', '        if (_sell.volume < _buy.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Require that the orders were submitted to the same settlement layer\n', '        if (_buy.settlementID != _sell.settlementID) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Verifies that two token requirements can be matched and that the\n', '    /// tokens are formatted correctly.\n', '    /// @param _buyTokens The buy token details.\n', '    /// @param _sellToken The sell token details.\n', '    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\n', '        return ((\n', '                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\n', '                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\n', '                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\n', '        );\n', '    }\n', '}\n', '\n', '/// @notice RenExSettlement implements the Settlement interface. It implements\n', '/// the on-chain settlement for the RenEx settlement layer, and the fee payment\n', '/// for the RenExAtomic settlement layer.\n', 'contract RenExSettlement is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // This contract handles the settlements with ID 1 and 2.\n', '    uint32 constant public RENEX_SETTLEMENT_ID = 1;\n', '    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\n', '\n', '    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\n', '    // a numerator and denominator.\n', '    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\n', '    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\n', '\n', '    // Constants used in the price / volume inputs.\n', '    int16 constant private PRICE_OFFSET = 12;\n', '    int16 constant private VOLUME_OFFSET = 12;\n', '\n', '    // Constructor parameters, updatable by the owner\n', '    Orderbook public orderbookContract;\n', '    RenExTokens public renExTokensContract;\n', '    RenExBalances public renExBalancesContract;\n', '    address public slasherAddress;\n', '    uint256 public submissionGasPriceLimit;\n', '\n', '    enum OrderStatus {None, Submitted, Settled, Slashed}\n', '\n', '    struct TokenPair {\n', '        RenExTokens.TokenDetails priorityToken;\n', '        RenExTokens.TokenDetails secondaryToken;\n', '    }\n', '\n', '    // A uint256 tuple representing a value and an associated fee\n', '    struct ValueWithFees {\n', '        uint256 value;\n', '        uint256 fees;\n', '    }\n', '\n', '    // A uint256 tuple representing a fraction\n', '    struct Fraction {\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '    }\n', '\n', '    // We use left and right because the tokens do not always represent the\n', '    // priority and secondary tokens.\n', '    struct SettlementDetails {\n', '        uint256 leftVolume;\n', '        uint256 rightVolume;\n', '        uint256 leftTokenFee;\n', '        uint256 rightTokenFee;\n', '        address leftTokenAddress;\n', '        address rightTokenAddress;\n', '    }\n', '\n', '    // Events\n', '    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\n', '    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\n', '    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\n', '    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    // Order Storage\n', '    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\n', '    mapping(bytes32 => address) public orderSubmitter;\n', '    mapping(bytes32 => OrderStatus) public orderStatus;\n', '\n', '    // Match storage (match details are indexed by [buyID][sellID])\n', '    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\n', '\n', '    /// @notice Prevents a function from being called with a gas price higher\n', '    /// than the specified limit.\n', '    ///\n', '    /// @param _gasPriceLimit The gas price upper-limit in Wei.\n', '    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\n', '        require(tx.gasprice <= _gasPriceLimit, "gas price too high");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the slasher\n', '    /// address.\n', '    modifier onlySlasher() {\n', '        require(msg.sender == slasherAddress, "unauthorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _orderbookContract The address of the Orderbook contract.\n', '    /// @param _renExBalancesContract The address of the RenExBalances\n', '    ///        contract.\n', '    /// @param _renExTokensContract The address of the RenExTokens contract.\n', '    constructor(\n', '        string _VERSION,\n', '        Orderbook _orderbookContract,\n', '        RenExTokens _renExTokensContract,\n', '        RenExBalances _renExBalancesContract,\n', '        address _slasherAddress,\n', '        uint256 _submissionGasPriceLimit\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        orderbookContract = _orderbookContract;\n', '        renExTokensContract = _renExTokensContract;\n', '        renExBalancesContract = _renExBalancesContract;\n', '        slasherAddress = _slasherAddress;\n', '        submissionGasPriceLimit = _submissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the Orderbook address.\n', '    /// @param _newOrderbookContract The address of the new Orderbook contract.\n', '    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\n', '        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\n', '        orderbookContract = _newOrderbookContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the RenExTokens address.\n', '    /// @param _newRenExTokensContract The address of the new RenExTokens\n', '    ///       contract.\n', '    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\n', '        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\n', '        renExTokensContract = _newRenExTokensContract;\n', '    }\n', '    \n', '    /// @notice The owner of the contract can update the RenExBalances address.\n', '    /// @param _newRenExBalancesContract The address of the new RenExBalances\n', '    ///       contract.\n', '    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\n', '        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\n', '        renExBalancesContract = _newRenExBalancesContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the order submission gas\n', '    /// price limit.\n', '    /// @param _newSubmissionGasPriceLimit The new gas price limit.\n', '    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\n', '        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\n', '        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the slasher address.\n', '    /// @param _newSlasherAddress The new slasher address.\n', '    function updateSlasher(address _newSlasherAddress) external onlyOwner {\n', '        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\n', '        slasherAddress = _newSlasherAddress;\n', '    }\n', '\n', '    /// @notice Stores the details of an order.\n', '    ///\n', '    /// @param _prefix The miscellaneous details of the order required for\n', '    ///        calculating the order id.\n', '    /// @param _settlementID The settlement identifier.\n', '    /// @param _tokens The encoding of the token pair (buy token is encoded as\n', '    ///        the first 32 bytes and sell token is encoded as the last 32\n', '    ///        bytes).\n', '    /// @param _price The price of the order. Interpreted as the cost for 1\n', '    ///        standard unit of the non-priority token, in 1e12 (i.e.\n', '    ///        PRICE_OFFSET) units of the priority token).\n', '    /// @param _volume The volume of the order. Interpreted as the maximum\n', '    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\n', '    ///        token that can be traded by this order.\n', '    /// @param _minimumVolume The minimum volume the trader is willing to\n', '    ///        accept. Encoded the same as the volume.\n', '    function submitOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external withGasPriceLimit(submissionGasPriceLimit) {\n', '\n', '        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        });\n', '        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\n', '\n', '        require(orderStatus[orderID] == OrderStatus.None, "order already submitted");\n', '        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, "unconfirmed order");\n', '\n', '        orderSubmitter[orderID] = msg.sender;\n', '        orderStatus[orderID] = OrderStatus.Submitted;\n', '        orderDetails[orderID] = order;\n', '    }\n', '\n', '    /// @notice Settles two orders that are matched. `submitOrder` must have been\n', '    /// called for each order before this function is called.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    function settle(bytes32 _buyID, bytes32 _sellID) external {\n', '        require(orderStatus[_buyID] == OrderStatus.Submitted, "invalid buy status");\n', '        require(orderStatus[_sellID] == OrderStatus.Submitted, "invalid sell status");\n', '\n', '        // Check the settlement ID (only have to check for one, since\n', '        // `verifyMatchDetails` checks that they are the same)\n', '        require(\n', '            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\n', '            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\n', '            "invalid settlement id"\n', '        );\n', '\n', '        // Verify that the two order details are compatible.\n', '        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), "incompatible orders");\n', '\n', '        // Verify that the two orders have been confirmed to one another.\n', '        require(orderbookContract.orderMatch(_buyID) == _sellID, "unconfirmed orders");\n', '\n', '        // Retrieve token details.\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\n', '\n', '        // Require that the tokens have been registered.\n', '        require(tokens.priorityToken.registered, "unregistered priority token");\n', '        require(tokens.secondaryToken.registered, "unregistered secondary token");\n', '\n', '        address buyer = orderbookContract.orderTrader(_buyID);\n', '        address seller = orderbookContract.orderTrader(_sellID);\n', '\n', '        require(buyer != seller, "orders from same trader");\n', '\n', '        execute(_buyID, _sellID, buyer, seller, tokens);\n', '\n', '        /* solium-disable-next-line security/no-block-members */\n', '        matchTimestamp[_buyID][_sellID] = now;\n', '\n', '        // Store that the orders have been settled.\n', '        orderStatus[_buyID] = OrderStatus.Settled;\n', '        orderStatus[_sellID] = OrderStatus.Settled;\n', '    }\n', '\n', '    /// @notice Slashes the bond of a guilty trader. This is called when an\n', '    /// atomic swap is not executed successfully.\n', '    /// To open an atomic order, a trader must have a balance equivalent to\n', '    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\n', '    /// darknode fees when the order is matched. If the remaining amount is\n', '    /// is slashed, it is distributed as follows:\n', '    ///   1) 0.2% goes to the other trader, covering their fee\n', '    ///   2) 0.2% goes to the slasher address\n', '    /// Only one order in a match can be slashed.\n', '    ///\n', '    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\n', '    function slash(bytes32 _guiltyOrderID) external onlySlasher {\n', '        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, "slashing non-atomic trade");\n', '\n', '        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\n', '\n', '        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, "invalid order status");\n', '        require(orderStatus[innocentOrderID] == OrderStatus.Settled, "invalid order status");\n', '        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\n', '\n', '        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\n', '            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\n', '\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\n', '\n', '        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\n', '\n', '        // Transfer the fee amount to the other trader\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            orderbookContract.orderTrader(innocentOrderID),\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '\n', '        // Transfer the fee amount to the slasher\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            slasherAddress,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '    }\n', '\n', '    /// @notice Retrieves the settlement details of an order.\n', '    /// For atomic swaps, it returns the full volumes, not the settled fees.\n', '    ///\n', '    /// @param _orderID The order to lookup the details of. Can be the ID of a\n', '    ///        buy or a sell order.\n', '    /// @return [\n', '    ///     a boolean representing whether or not the order has been settled,\n', '    ///     a boolean representing whether or not the order is a buy\n', '    ///     the 32-byte order ID of the matched order\n', '    ///     the volume of the priority token,\n', '    ///     the volume of the secondary token,\n', '    ///     the fee paid in the priority token,\n', '    ///     the fee paid in the secondary token,\n', '    ///     the token code of the priority token,\n', '    ///     the token code of the secondary token\n', '    /// ]\n', '    function getMatchDetails(bytes32 _orderID)\n', '    external view returns (\n', '        bool settled,\n', '        bool orderIsBuy,\n', '        bytes32 matchedID,\n', '        uint256 priorityVolume,\n', '        uint256 secondaryVolume,\n', '        uint256 priorityFee,\n', '        uint256 secondaryFee,\n', '        uint32 priorityToken,\n', '        uint32 secondaryToken\n', '    ) {\n', '        matchedID = orderbookContract.orderMatch(_orderID);\n', '\n', '        orderIsBuy = isBuyOrder(_orderID);\n', '\n', '        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\n', '            (_orderID, matchedID) : (matchedID, _orderID);\n', '\n', '        SettlementDetails memory settlementDetails = calculateSettlementDetails(\n', '            buyID,\n', '            sellID,\n', '            getTokenDetails(orderDetails[buyID].tokens)\n', '        );\n', '\n', '        return (\n', '            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\n', '            orderIsBuy,\n', '            matchedID,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.leftTokenFee,\n', '            settlementDetails.rightTokenFee,\n', '            uint32(orderDetails[buyID].tokens >> 32),\n', '            uint32(orderDetails[buyID].tokens)\n', '        );\n', '    }\n', '\n', '    /// @notice Exposes the hashOrder function for computing a hash of an\n', "    /// order's details. An order hash is used as its ID. See `submitOrder`\n", '    /// for the parameter descriptions.\n', '    ///\n', '    /// @return The 32-byte hash of the order.\n', '    function hashOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external pure returns (bytes32) {\n', '        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        }));\n', '    }\n', '\n', '    /// @notice Called by `settle`, executes the settlement for a RenEx order\n', '    /// or distributes the fees for a RenExAtomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _buyer The address of the buy trader.\n', '    /// @param _seller The address of the sell trader.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    function execute(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        address _buyer,\n', '        address _seller,\n', '        TokenPair memory _tokens\n', '    ) private {\n', '        // Calculate the fees for atomic swaps, and the settlement details\n', '        // otherwise.\n', '        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\n', '            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\n', '            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\n', '\n', '        // Transfer priority token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _buyer,\n', '            _seller,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.leftTokenFee,\n', '            orderSubmitter[_buyID]\n', '        );\n', '\n', '        // Transfer secondary token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _seller,\n', '            _buyer,\n', '            settlementDetails.rightTokenAddress,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.rightTokenFee,\n', '            orderSubmitter[_sellID]\n', '        );\n', '    }\n', '\n', '    /// @notice Calculates the details required to execute two matched orders.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the settlement details.\n', '    function calculateSettlementDetails(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        uint256 priorityTokenVolume = joinFraction(\n', '            commonVolume.mul(midPrice.numerator),\n', '            midPrice.denominator,\n', '            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '        );\n', '        uint256 secondaryTokenVolume = joinFraction(\n', '            commonVolume,\n', '            1,\n', '            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '        );\n', '\n', '        // Calculate darknode fees\n', '        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '        return SettlementDetails({\n', '            leftVolume: priorityVwF.value,\n', '            rightVolume: secondaryVwF.value,\n', '            leftTokenFee: priorityVwF.fees,\n', '            rightTokenFee: secondaryVwF.fees,\n', '            leftTokenAddress: _tokens.priorityToken.addr,\n', '            rightTokenAddress: _tokens.secondaryToken.addr\n', '        });\n', '    }\n', '\n', '    /// @notice Calculates the fees to be transferred for an atomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the fee details.\n', '    function calculateAtomicFees(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        if (isEthereumBased(_tokens.secondaryToken.addr)) {\n', '            uint256 secondaryTokenVolume = joinFraction(\n', '                commonVolume,\n', '                1,\n', '                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: secondaryVwF.fees,\n', '                rightTokenFee: secondaryVwF.fees,\n', '                leftTokenAddress: _tokens.secondaryToken.addr,\n', '                rightTokenAddress: _tokens.secondaryToken.addr\n', '            });\n', '        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\n', '            uint256 priorityTokenVolume = joinFraction(\n', '                commonVolume.mul(midPrice.numerator),\n', '                midPrice.denominator,\n', '                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: priorityVwF.fees,\n', '                rightTokenFee: priorityVwF.fees,\n', '                leftTokenAddress: _tokens.priorityToken.addr,\n', '                rightTokenAddress: _tokens.priorityToken.addr\n', '            });\n', '        } else {\n', '            // Currently, at least one token must be Ethereum-based.\n', '            // This will be implemented in the future.\n', '            revert("non-eth atomic swaps are not supported");\n', '        }\n', '    }\n', '\n', '    /// @notice Order parity is set by the order tokens are listed. This returns\n', '    /// whether an order is a buy or a sell.\n', '    /// @return true if _orderID is a buy order.\n', '    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\n', '        uint64 tokens = orderDetails[_orderID].tokens;\n', '        uint32 firstToken = uint32(tokens >> 32);\n', '        uint32 secondaryToken = uint32(tokens);\n', '        return (firstToken < secondaryToken);\n', '    }\n', '\n', '    /// @return (value - fee, fee) where fee is 0.2% of value\n', '    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\n', '        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\n', '        return ValueWithFees(newValue, _value - newValue);\n', '    }\n', '\n', '    /// @notice Gets the order details of the priority and secondary token from\n', '    /// the RenExTokens contract and returns them as a single struct.\n', '    ///\n', '    /// @param _tokens The 64-bit combined token identifiers.\n', '    /// @return A TokenPair struct containing two TokenDetails structs.\n', '    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\n', '        (\n', '            address priorityAddress,\n', '            uint8 priorityDecimals,\n', '            bool priorityRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\n', '\n', '        (\n', '            address secondaryAddress,\n', '            uint8 secondaryDecimals,\n', '            bool secondaryRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens));\n', '\n', '        return TokenPair({\n', '            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\n', '            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\n', '        });\n', '    }\n', '\n', '    /// @return true if _tokenAddress is 0x0, representing a token that is not\n', '    /// on Ethereum\n', '    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\n', '        return (_tokenAddress != address(0x0));\n', '    }\n', '\n', '    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\n', '    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\n', '        if (_scale >= 0) {\n', "            // Check that (10**_scale) doesn't overflow\n", '            assert(_scale <= 77); // log10(2**256) = 77.06\n', '            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\n', '        } else {\n', '            /// @dev If _scale is less than -77, 10**-_scale would overflow.\n', '            // For now, -_scale > -24 (when a token has 0 decimals and\n', '            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\n', '            // will be increased to add to more than 77.\n', '            // assert((-_scale) <= 77); // log10(2**256) = 77.06\n', '            return (_numerator / _denominator) / 10 ** uint256(-_scale);\n', '        }\n', '    }\n', '}']
