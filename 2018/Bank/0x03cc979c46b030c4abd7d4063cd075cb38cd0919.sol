['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20 {\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint a, uint b) internal pure returns (uint) {\n', '        if (a >= b)\n', '            return b;\n', '        return a;\n', '    }\n', '\n', '    function max(uint a, uint b) internal pure returns (uint) {\n', '        if (a >= b)\n', '            return a;\n', '        return b;\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src,\n', '        address dst,\n', '        bytes4 sig\n', '        ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Exchange is DSAuth {\n', '\n', '    using SafeMath for uint;\n', '\n', '    ERC20 public daiToken;\n', '    mapping(address => uint) public dai;\n', '    mapping(address => uint) public eth;\n', '\n', '    mapping(address => uint) public totalEth;\n', '    mapping(address => uint) public totalDai;\n', '\n', '    mapping(bytes32 => mapping(address => uint)) public callsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public putsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public callsSold;\n', '    mapping(bytes32 => mapping(address => uint)) public putsSold;\n', '\n', '    mapping(bytes32 => uint) public callsAssigned;\n', '    mapping(bytes32 => uint) public putsAssigned;\n', '    mapping(bytes32 => uint) public callsExercised;\n', '    mapping(bytes32 => uint) public putsExercised;\n', '\n', '    mapping(address => mapping(bytes32 => bool)) public cancelled;\n', '    mapping(address => mapping(bytes32 => uint)) public filled;\n', '\n', '    mapping(address => uint) public feeRebates;\n', '    mapping(bytes32 => bool) public claimedFeeRebate;\n', '\n', '    // fee values are actually in DAI, ether is just a keyword\n', '    uint public flatFee       = 7 ether;\n', '    uint public contractFee   = 1 ether;\n', '    uint public exerciseFee   = 20 ether;\n', '    uint public settlementFee = 20 ether;\n', '    uint public feesCollected = 0;\n', '    uint public feesWithdrawn = 0;\n', '\n', '    string precisionError = "Precision";\n', '\n', '    constructor(address daiAddress) public {\n', '        require(daiAddress != 0x0);\n', '        daiToken = ERC20(daiAddress);\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    event Deposit(address indexed account, uint amount);\n', '    event Withdraw(address indexed account, uint amount, address to);\n', '    event DepositDai(address indexed account, uint amount);\n', '    event WithdrawDai(address indexed account, uint amount, address to);\n', '\n', '    function deposit() public payable {\n', '        _addEth(msg.value, msg.sender);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function depositDai(uint amount) public {\n', '        require(daiToken.transferFrom(msg.sender, this, amount));\n', '        _addDai(amount, msg.sender);\n', '        emit DepositDai(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint amount, address to) public {\n', '        require(to != 0x0);\n', '        _subEth(amount, msg.sender);\n', '        to.transfer(amount);\n', '        emit Withdraw(msg.sender, amount, to);\n', '    }\n', '\n', '    function withdrawDai(uint amount, address to) public {\n', '        require(to != 0x0);\n', '        _subDai(amount, msg.sender);\n', '        daiToken.transfer(to, amount);\n', '        emit WithdrawDai(msg.sender, amount, to);\n', '    }\n', '\n', '    function depositDaiFor(uint amount, address account) public {\n', '        require(account != 0x0);\n', '        require(daiToken.transferFrom(msg.sender, this, amount));\n', '        _addDai(amount, account);\n', '        emit DepositDai(account, amount);\n', '    }\n', '\n', '    function _addEth(uint amount, address account) private {\n', '        eth[account] = eth[account].add(amount);\n', '        totalEth[account] = totalEth[account].add(amount);\n', '    }\n', '\n', '    function _subEth(uint amount, address account) private {\n', '        eth[account] = eth[account].sub(amount);\n', '        totalEth[account] = totalEth[account].sub(amount);\n', '    }\n', '\n', '    function _addDai(uint amount, address account) private {\n', '        dai[account] = dai[account].add(amount);\n', '        totalDai[account] = totalDai[account].add(amount);\n', '    }\n', '\n', '    function _subDai(uint amount, address account) private {\n', '        dai[account] = dai[account].sub(amount);\n', '        totalDai[account] = totalDai[account].sub(amount);\n', '    }\n', '\n', '    // ===== Admin functions ===== //\n', '\n', '    function setFeeSchedule(\n', '        uint _flatFee,\n', '        uint _contractFee,\n', '        uint _exerciseFee,\n', '        uint _settlementFee\n', '    ) public auth {\n', '        flatFee = _flatFee;\n', '        contractFee = _contractFee;\n', '        exerciseFee = _exerciseFee;\n', '        settlementFee = _settlementFee;\n', '\n', '        require(contractFee < 5 ether);\n', '        require(flatFee < 6.95 ether);\n', '        require(exerciseFee < 20 ether);\n', '        require(settlementFee < 20 ether);\n', '    }\n', '\n', '    function withdrawFees(address to) public auth {\n', '        require(to != 0x0);\n', '        uint amount = feesCollected.sub(feesWithdrawn);\n', '        feesWithdrawn = feesCollected;\n', '        require(daiToken.transfer(to, amount));\n', '    }\n', '\n', '    // ===== End Admin Functions ===== //\n', '\n', '    modifier hasFee(uint amount) {\n', '        _;\n', '        _collectFee(msg.sender, calculateFee(amount));\n', '    }\n', '\n', '    enum Action {\n', '        BuyCallToOpen,\n', '        BuyCallToClose,\n', '        SellCallToOpen,\n', '        SellCallToClose,\n', '        BuyPutToOpen,\n', '        BuyPutToClose,\n', '        SellPutToOpen,\n', '        SellPutToClose\n', '    }\n', '\n', '    event CancelOrder(address indexed account, bytes32 h);\n', '    function cancelOrder(bytes32 h) public {\n', '        cancelled[msg.sender][h] = true;\n', '        emit CancelOrder(msg.sender, h);\n', '    }\n', '\n', '    function callBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _buyCallToOpen(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        callsOwned[series][buyer] = callsOwned[series][buyer].add(amount);\n', '        emit BuyCallToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _buyCallToClose(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        eth[buyer] = eth[buyer].add(amount);\n', '        callsSold[series][buyer] = callsSold[series][buyer].sub(amount);\n', '        emit BuyCallToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellCallToOpen(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        eth[seller] = eth[seller].sub(amount);\n', '        callsSold[series][seller] = callsSold[series][seller].add(amount);\n', '        emit SellCallToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellCallToClose(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        callsOwned[series][seller] = callsOwned[series][seller].sub(amount);\n', '        emit SellCallToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExerciseCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exerciseCall(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        require(now < expiration, "Expired");\n', '        require(amount % 1 finney == 0, precisionError);\n', '        uint cost = amount.mul(strike).div(1 ether);\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(callsOwned[series][msg.sender] > 0);\n', '        callsOwned[series][msg.sender] = callsOwned[series][msg.sender].sub(amount);\n', '        callsExercised[series] = callsExercised[series].add(amount);\n', '\n', '        _collectFee(msg.sender, exerciseFee);\n', '        _subDai(cost, msg.sender);\n', '        _addEth(amount, msg.sender);\n', '        emit ExerciseCall(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettleCall(address indexed account, uint expiration, uint strike);\n', '    function settleCall(uint expiration, uint strike, address writer) public {\n', '        require(msg.sender == writer || isAuthorized(msg.sender, msg.sig), "Unauthorized");\n', '        require(now > expiration, "Expired");\n', '\n', '        bytes32 series = keccak256(expiration, strike);\n', '        require(callsSold[series][writer] > 0);\n', '\n', '        if (callsAssigned[series] < callsExercised[series]) {\n', '            uint maximum = callsSold[series][writer];\n', '            uint needed = callsExercised[series].sub(callsAssigned[series]);\n', '            uint assignment = needed.min(maximum);\n', '\n', '            totalEth[writer] = totalEth[writer].sub(assignment);\n', '            callsAssigned[series] = callsAssigned[series].add(assignment);\n', '            callsSold[series][writer] = callsSold[series][writer].sub(assignment);\n', '\n', '            uint value = strike.mul(assignment).div(1 ether);\n', '            _addDai(value, writer);\n', '            emit AssignCall(msg.sender, assignment, expiration, strike);\n', '        }\n', '\n', '        _collectFee(writer, settlementFee);\n', '        eth[writer] = eth[writer].add(callsSold[series][writer]);\n', '        callsSold[series][writer] = 0;\n', '        emit SettleCall(writer, expiration, strike);\n', '    }\n', '\n', '\n', '    // ========== PUT OPTIONS EXCHANGE ========== //\n', '\n', '    function putBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _buyPutToOpen(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        putsOwned[series][buyer] = putsOwned[series][buyer].add(amount);\n', '        emit BuyPutToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _buyPutToClose(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        dai[buyer] = dai[buyer].add(strike.mul(amount).div(1 ether));\n', '        _subDai(premium, buyer);\n', '        putsSold[series][buyer] = putsSold[series][buyer].sub(amount);\n', '        emit BuyPutToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellPutToOpen(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '        uint cost = strike.mul(amount).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        dai[seller] = dai[seller].sub(cost);\n', '        putsSold[series][seller] = putsSold[series][seller].add(amount);\n', '        emit SellPutToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellPutToClose(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        putsOwned[series][seller] = putsOwned[series][seller].sub(amount);\n', '        emit SellPutToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExercisePut(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exercisePut(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        require(now < expiration, "Expired");\n', '        require(amount % 1 finney == 0, precisionError);\n', '        uint yield = amount.mul(strike).div(1 ether);\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(putsOwned[series][msg.sender] > 0);\n', '        \n', '        putsOwned[series][msg.sender] = putsOwned[series][msg.sender].sub(amount);\n', '        putsExercised[series] = putsExercised[series].add(amount);\n', '\n', '        _subEth(amount, msg.sender);\n', '        _addDai(yield, msg.sender);\n', '        _collectFee(msg.sender, exerciseFee);\n', '        emit ExercisePut(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignPut(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettlePut(address indexed account, uint expiration, uint strike);\n', '    function settlePut(uint expiration, uint strike, address writer) public {\n', '        require(msg.sender == writer || isAuthorized(msg.sender, msg.sig), "Unauthorized");\n', '        require(now > expiration, "Expired");\n', '\n', '        bytes32 series = keccak256(expiration, strike);\n', '        require(putsSold[series][writer] > 0);\n', '\n', '        if (putsAssigned[series] < putsExercised[series]) {\n', '            uint maximum = putsSold[series][writer];\n', '            uint needed = putsExercised[series].sub(putsAssigned[series]);\n', '            uint assignment = maximum.min(needed);\n', '\n', '            totalDai[writer] = totalDai[writer].sub(assignment.mul(strike).div(1 ether));\n', '            putsSold[series][writer] = putsSold[series][writer].sub(assignment);\n', '            putsAssigned[series] = putsAssigned[series].add(assignment);\n', '\n', '            _addEth(assignment, writer);\n', '            emit AssignPut(writer, assignment, expiration, strike);\n', '        }\n', '\n', '        uint yield = putsSold[series][writer].mul(strike).div(1 ether);\n', '        _collectFee(writer, settlementFee);\n', '        dai[writer] = dai[writer].add(yield);\n', '        putsSold[series][writer] = 0;\n', '        emit SettlePut(writer, expiration, strike);\n', '    }\n', '\n', '    function calculateFee(uint amount) public view returns (uint) {\n', '        return amount.mul(contractFee).div(1 ether).add(flatFee);\n', '    }\n', '\n', '    function claimFeeRebate(uint amount, bytes32 nonce, bytes32 r, bytes32 s, uint8 v) public {\n', '        bytes32 h = keccak256(amount, nonce, msg.sender);\n', '        h = keccak256("\\x19Ethereum Signed Message:\\n32", h);\n', '        address signer = ecrecover(h, v, r, s);\n', '        require(amount <= 1000);\n', '        require(isAuthorized(signer, msg.sig));\n', '        require(claimedFeeRebate[nonce] == false);\n', '        feeRebates[msg.sender] = feeRebates[msg.sender].add(amount);\n', '        claimedFeeRebate[nonce] = true;\n', '    }\n', '\n', '    event TakeOrder(address indexed account, address maker, uint amount, bytes32 h);\n', '    function _validateOrder(uint amount, uint expiration, bytes32 h, address maker, uint price, uint validUntil, uint size, uint strike) private {\n', '        require(strike % 1 ether == 0, precisionError);\n', '        require(amount % 1 finney == 0, precisionError);\n', '        require(price % 1 finney == 0, precisionError);\n', '        require(expiration % 86400 == 0, "Expiration");\n', '\n', '        require(cancelled[maker][h] == false, "Cancelled");\n', '        require(amount <= size.sub(filled[maker][h]), "Filled");\n', '        require(now < validUntil, "OrderExpired");\n', '        require(now < expiration, "Expired");\n', '\n', '        filled[maker][h] = filled[maker][h].add(amount);\n', '        emit TakeOrder(msg.sender, maker, amount, h);\n', '    }\n', '\n', '    function _collectFee(address account, uint amount) private {\n', '        if (feeRebates[msg.sender] > 0) {\n', '            feeRebates[msg.sender] = feeRebates[msg.sender].sub(1);\n', '        } else {\n', '            _subDai(amount, account);\n', '            feesCollected = feesCollected.add(amount);\n', '        }\n', '    }\n', '\n', '    function _getMaker(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\n', '        return ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", h), v, r, s);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20 {\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint a, uint b) internal pure returns (uint) {\n', '        if (a >= b)\n', '            return b;\n', '        return a;\n', '    }\n', '\n', '    function max(uint a, uint b) internal pure returns (uint) {\n', '        if (a >= b)\n', '            return a;\n', '        return b;\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src,\n', '        address dst,\n', '        bytes4 sig\n', '        ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Exchange is DSAuth {\n', '\n', '    using SafeMath for uint;\n', '\n', '    ERC20 public daiToken;\n', '    mapping(address => uint) public dai;\n', '    mapping(address => uint) public eth;\n', '\n', '    mapping(address => uint) public totalEth;\n', '    mapping(address => uint) public totalDai;\n', '\n', '    mapping(bytes32 => mapping(address => uint)) public callsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public putsOwned;\n', '    mapping(bytes32 => mapping(address => uint)) public callsSold;\n', '    mapping(bytes32 => mapping(address => uint)) public putsSold;\n', '\n', '    mapping(bytes32 => uint) public callsAssigned;\n', '    mapping(bytes32 => uint) public putsAssigned;\n', '    mapping(bytes32 => uint) public callsExercised;\n', '    mapping(bytes32 => uint) public putsExercised;\n', '\n', '    mapping(address => mapping(bytes32 => bool)) public cancelled;\n', '    mapping(address => mapping(bytes32 => uint)) public filled;\n', '\n', '    mapping(address => uint) public feeRebates;\n', '    mapping(bytes32 => bool) public claimedFeeRebate;\n', '\n', '    // fee values are actually in DAI, ether is just a keyword\n', '    uint public flatFee       = 7 ether;\n', '    uint public contractFee   = 1 ether;\n', '    uint public exerciseFee   = 20 ether;\n', '    uint public settlementFee = 20 ether;\n', '    uint public feesCollected = 0;\n', '    uint public feesWithdrawn = 0;\n', '\n', '    string precisionError = "Precision";\n', '\n', '    constructor(address daiAddress) public {\n', '        require(daiAddress != 0x0);\n', '        daiToken = ERC20(daiAddress);\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    event Deposit(address indexed account, uint amount);\n', '    event Withdraw(address indexed account, uint amount, address to);\n', '    event DepositDai(address indexed account, uint amount);\n', '    event WithdrawDai(address indexed account, uint amount, address to);\n', '\n', '    function deposit() public payable {\n', '        _addEth(msg.value, msg.sender);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function depositDai(uint amount) public {\n', '        require(daiToken.transferFrom(msg.sender, this, amount));\n', '        _addDai(amount, msg.sender);\n', '        emit DepositDai(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint amount, address to) public {\n', '        require(to != 0x0);\n', '        _subEth(amount, msg.sender);\n', '        to.transfer(amount);\n', '        emit Withdraw(msg.sender, amount, to);\n', '    }\n', '\n', '    function withdrawDai(uint amount, address to) public {\n', '        require(to != 0x0);\n', '        _subDai(amount, msg.sender);\n', '        daiToken.transfer(to, amount);\n', '        emit WithdrawDai(msg.sender, amount, to);\n', '    }\n', '\n', '    function depositDaiFor(uint amount, address account) public {\n', '        require(account != 0x0);\n', '        require(daiToken.transferFrom(msg.sender, this, amount));\n', '        _addDai(amount, account);\n', '        emit DepositDai(account, amount);\n', '    }\n', '\n', '    function _addEth(uint amount, address account) private {\n', '        eth[account] = eth[account].add(amount);\n', '        totalEth[account] = totalEth[account].add(amount);\n', '    }\n', '\n', '    function _subEth(uint amount, address account) private {\n', '        eth[account] = eth[account].sub(amount);\n', '        totalEth[account] = totalEth[account].sub(amount);\n', '    }\n', '\n', '    function _addDai(uint amount, address account) private {\n', '        dai[account] = dai[account].add(amount);\n', '        totalDai[account] = totalDai[account].add(amount);\n', '    }\n', '\n', '    function _subDai(uint amount, address account) private {\n', '        dai[account] = dai[account].sub(amount);\n', '        totalDai[account] = totalDai[account].sub(amount);\n', '    }\n', '\n', '    // ===== Admin functions ===== //\n', '\n', '    function setFeeSchedule(\n', '        uint _flatFee,\n', '        uint _contractFee,\n', '        uint _exerciseFee,\n', '        uint _settlementFee\n', '    ) public auth {\n', '        flatFee = _flatFee;\n', '        contractFee = _contractFee;\n', '        exerciseFee = _exerciseFee;\n', '        settlementFee = _settlementFee;\n', '\n', '        require(contractFee < 5 ether);\n', '        require(flatFee < 6.95 ether);\n', '        require(exerciseFee < 20 ether);\n', '        require(settlementFee < 20 ether);\n', '    }\n', '\n', '    function withdrawFees(address to) public auth {\n', '        require(to != 0x0);\n', '        uint amount = feesCollected.sub(feesWithdrawn);\n', '        feesWithdrawn = feesCollected;\n', '        require(daiToken.transfer(to, amount));\n', '    }\n', '\n', '    // ===== End Admin Functions ===== //\n', '\n', '    modifier hasFee(uint amount) {\n', '        _;\n', '        _collectFee(msg.sender, calculateFee(amount));\n', '    }\n', '\n', '    enum Action {\n', '        BuyCallToOpen,\n', '        BuyCallToClose,\n', '        SellCallToOpen,\n', '        SellCallToClose,\n', '        BuyPutToOpen,\n', '        BuyPutToClose,\n', '        SellPutToOpen,\n', '        SellPutToClose\n', '    }\n', '\n', '    event CancelOrder(address indexed account, bytes32 h);\n', '    function cancelOrder(bytes32 h) public {\n', '        cancelled[msg.sender][h] = true;\n', '        emit CancelOrder(msg.sender, h);\n', '    }\n', '\n', '    function callBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function callStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyCallToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellCallToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyCallToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellCallToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _buyCallToOpen(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        callsOwned[series][buyer] = callsOwned[series][buyer].add(amount);\n', '        emit BuyCallToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _buyCallToClose(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        eth[buyer] = eth[buyer].add(amount);\n', '        callsSold[series][buyer] = callsSold[series][buyer].sub(amount);\n', '        emit BuyCallToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellCallToOpen(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        eth[seller] = eth[seller].sub(amount);\n', '        callsSold[series][seller] = callsSold[series][seller].add(amount);\n', '        emit SellCallToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellCallToClose(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        callsOwned[series][seller] = callsOwned[series][seller].sub(amount);\n', '        emit SellCallToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExerciseCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exerciseCall(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        require(now < expiration, "Expired");\n', '        require(amount % 1 finney == 0, precisionError);\n', '        uint cost = amount.mul(strike).div(1 ether);\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(callsOwned[series][msg.sender] > 0);\n', '        callsOwned[series][msg.sender] = callsOwned[series][msg.sender].sub(amount);\n', '        callsExercised[series] = callsExercised[series].add(amount);\n', '\n', '        _collectFee(msg.sender, exerciseFee);\n', '        _subDai(cost, msg.sender);\n', '        _addEth(amount, msg.sender);\n', '        emit ExerciseCall(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignCall(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettleCall(address indexed account, uint expiration, uint strike);\n', '    function settleCall(uint expiration, uint strike, address writer) public {\n', '        require(msg.sender == writer || isAuthorized(msg.sender, msg.sig), "Unauthorized");\n', '        require(now > expiration, "Expired");\n', '\n', '        bytes32 series = keccak256(expiration, strike);\n', '        require(callsSold[series][writer] > 0);\n', '\n', '        if (callsAssigned[series] < callsExercised[series]) {\n', '            uint maximum = callsSold[series][writer];\n', '            uint needed = callsExercised[series].sub(callsAssigned[series]);\n', '            uint assignment = needed.min(maximum);\n', '\n', '            totalEth[writer] = totalEth[writer].sub(assignment);\n', '            callsAssigned[series] = callsAssigned[series].add(assignment);\n', '            callsSold[series][writer] = callsSold[series][writer].sub(assignment);\n', '\n', '            uint value = strike.mul(assignment).div(1 ether);\n', '            _addDai(value, writer);\n', '            emit AssignCall(msg.sender, assignment, expiration, strike);\n', '        }\n', '\n', '        _collectFee(writer, settlementFee);\n', '        eth[writer] = eth[writer].add(callsSold[series][writer]);\n', '        callsSold[series][writer] = 0;\n', '        emit SettleCall(writer, expiration, strike);\n', '    }\n', '\n', '\n', '    // ========== PUT OPTIONS EXCHANGE ========== //\n', '\n', '    function putBtoWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtoWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithSto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putBtcWithStc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.SellPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _buyPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _sellPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStoWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToOpen(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBto(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToOpen, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToOpen(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    function putStcWithBtc(\n', '        uint    amount,\n', '        uint    expiration,\n', '        bytes32 nonce,\n', '        uint    price,\n', '        uint    size,\n', '        uint    strike,\n', '        uint    validUntil,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint8   v\n', '    ) public hasFee(amount) {\n', '        bytes32 h = keccak256(Action.BuyPutToClose, expiration, nonce, price, size, strike, validUntil, this);\n', '        address maker = _getMaker(h, v, r, s);\n', '\n', '        _validateOrder(amount, expiration, h, maker, price, validUntil, size, strike);\n', '        _sellPutToClose(amount, expiration, price, strike, msg.sender);\n', '        _buyPutToClose(amount, expiration, price, strike, maker);\n', '    }\n', '\n', '    event BuyPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToOpen(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event BuyPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '    event SellPutToClose(address indexed account, uint amount, uint expiration, uint price, uint strike);\n', '\n', '    function _buyPutToOpen(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _subDai(premium, buyer);\n', '        putsOwned[series][buyer] = putsOwned[series][buyer].add(amount);\n', '        emit BuyPutToOpen(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _buyPutToClose(uint amount, uint expiration, uint price, uint strike, address buyer) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        dai[buyer] = dai[buyer].add(strike.mul(amount).div(1 ether));\n', '        _subDai(premium, buyer);\n', '        putsSold[series][buyer] = putsSold[series][buyer].sub(amount);\n', '        emit BuyPutToClose(buyer, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellPutToOpen(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '        uint cost = strike.mul(amount).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        dai[seller] = dai[seller].sub(cost);\n', '        putsSold[series][seller] = putsSold[series][seller].add(amount);\n', '        emit SellPutToOpen(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    function _sellPutToClose(uint amount, uint expiration, uint price, uint strike, address seller) private {\n', '        bytes32 series = keccak256(expiration, strike);\n', '        uint premium = amount.mul(price).div(1 ether);\n', '\n', '        _addDai(premium, seller);\n', '        putsOwned[series][seller] = putsOwned[series][seller].sub(amount);\n', '        emit SellPutToClose(seller, amount, expiration, price, strike);\n', '    }\n', '\n', '    event ExercisePut(address indexed account, uint amount, uint expiration, uint strike);\n', '    function exercisePut(\n', '        uint amount,\n', '        uint expiration,\n', '        uint strike\n', '    ) public {\n', '        require(now < expiration, "Expired");\n', '        require(amount % 1 finney == 0, precisionError);\n', '        uint yield = amount.mul(strike).div(1 ether);\n', '        bytes32 series = keccak256(expiration, strike);\n', '\n', '        require(putsOwned[series][msg.sender] > 0);\n', '        \n', '        putsOwned[series][msg.sender] = putsOwned[series][msg.sender].sub(amount);\n', '        putsExercised[series] = putsExercised[series].add(amount);\n', '\n', '        _subEth(amount, msg.sender);\n', '        _addDai(yield, msg.sender);\n', '        _collectFee(msg.sender, exerciseFee);\n', '        emit ExercisePut(msg.sender, amount, expiration, strike);\n', '    }\n', '\n', '    event AssignPut(address indexed account, uint amount, uint expiration, uint strike);\n', '    event SettlePut(address indexed account, uint expiration, uint strike);\n', '    function settlePut(uint expiration, uint strike, address writer) public {\n', '        require(msg.sender == writer || isAuthorized(msg.sender, msg.sig), "Unauthorized");\n', '        require(now > expiration, "Expired");\n', '\n', '        bytes32 series = keccak256(expiration, strike);\n', '        require(putsSold[series][writer] > 0);\n', '\n', '        if (putsAssigned[series] < putsExercised[series]) {\n', '            uint maximum = putsSold[series][writer];\n', '            uint needed = putsExercised[series].sub(putsAssigned[series]);\n', '            uint assignment = maximum.min(needed);\n', '\n', '            totalDai[writer] = totalDai[writer].sub(assignment.mul(strike).div(1 ether));\n', '            putsSold[series][writer] = putsSold[series][writer].sub(assignment);\n', '            putsAssigned[series] = putsAssigned[series].add(assignment);\n', '\n', '            _addEth(assignment, writer);\n', '            emit AssignPut(writer, assignment, expiration, strike);\n', '        }\n', '\n', '        uint yield = putsSold[series][writer].mul(strike).div(1 ether);\n', '        _collectFee(writer, settlementFee);\n', '        dai[writer] = dai[writer].add(yield);\n', '        putsSold[series][writer] = 0;\n', '        emit SettlePut(writer, expiration, strike);\n', '    }\n', '\n', '    function calculateFee(uint amount) public view returns (uint) {\n', '        return amount.mul(contractFee).div(1 ether).add(flatFee);\n', '    }\n', '\n', '    function claimFeeRebate(uint amount, bytes32 nonce, bytes32 r, bytes32 s, uint8 v) public {\n', '        bytes32 h = keccak256(amount, nonce, msg.sender);\n', '        h = keccak256("\\x19Ethereum Signed Message:\\n32", h);\n', '        address signer = ecrecover(h, v, r, s);\n', '        require(amount <= 1000);\n', '        require(isAuthorized(signer, msg.sig));\n', '        require(claimedFeeRebate[nonce] == false);\n', '        feeRebates[msg.sender] = feeRebates[msg.sender].add(amount);\n', '        claimedFeeRebate[nonce] = true;\n', '    }\n', '\n', '    event TakeOrder(address indexed account, address maker, uint amount, bytes32 h);\n', '    function _validateOrder(uint amount, uint expiration, bytes32 h, address maker, uint price, uint validUntil, uint size, uint strike) private {\n', '        require(strike % 1 ether == 0, precisionError);\n', '        require(amount % 1 finney == 0, precisionError);\n', '        require(price % 1 finney == 0, precisionError);\n', '        require(expiration % 86400 == 0, "Expiration");\n', '\n', '        require(cancelled[maker][h] == false, "Cancelled");\n', '        require(amount <= size.sub(filled[maker][h]), "Filled");\n', '        require(now < validUntil, "OrderExpired");\n', '        require(now < expiration, "Expired");\n', '\n', '        filled[maker][h] = filled[maker][h].add(amount);\n', '        emit TakeOrder(msg.sender, maker, amount, h);\n', '    }\n', '\n', '    function _collectFee(address account, uint amount) private {\n', '        if (feeRebates[msg.sender] > 0) {\n', '            feeRebates[msg.sender] = feeRebates[msg.sender].sub(1);\n', '        } else {\n', '            _subDai(amount, account);\n', '            feesCollected = feesCollected.add(amount);\n', '        }\n', '    }\n', '\n', '    function _getMaker(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\n', '        return ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", h), v, r, s);\n', '    }\n', '}']
