['pragma solidity ^0.4.18;\n', '\n', 'contract SportCrypt {\n', '    address private owner;\n', '    mapping(address => bool) private admins;\n', '\n', '    function SportCrypt() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address newOwner) external onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '\n', '    function addAdmin(address addr) external onlyOwner {\n', '        admins[addr] = true;\n', '    }\n', '\n', '    function removeAdmin(address addr) external onlyOwner {\n', '        admins[addr] = false;\n', '    }\n', '\n', '\n', '    // Events\n', '\n', '    event LogBalanceChange(address indexed account, uint oldAmount, uint newAmount);\n', '    event LogDeposit(address indexed account);\n', '    event LogWithdraw(address indexed account);\n', '    event LogTrade(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint8 orderDirection, uint8 price, uint longAmount, int newLongPosition, uint shortAmount, int newShortPosition);\n', '    event LogTradeError(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint16 status);\n', '    event LogOrderCancel(address indexed account, uint indexed matchId, uint orderHash);\n', '    event LogFinalizeMatch(uint indexed matchId, uint8 finalPrice);\n', '    event LogClaim(address indexed account, uint indexed matchId, uint amount);\n', '\n', '\n', '    // Storage\n', '\n', '    struct Match {\n', '        mapping(address => int) positions;\n', '        uint64 firstTradeTimestamp;\n', '        bool finalized;\n', '        uint8 finalPrice;\n', '    }\n', '\n', '    mapping(address => uint) private balances;\n', '    mapping(uint => Match) private matches;\n', '    mapping(uint => uint) private filledAmounts;\n', '\n', '\n', '    // Memory\n', '\n', '    uint constant MAX_SANE_AMOUNT = 2**128;\n', '\n', '    enum Status {\n', '        OK,\n', '        MATCH_FINALIZED,\n', '        ORDER_EXPIRED,\n', '        ORDER_MALFORMED,\n', '        ORDER_BAD_SIG,\n', '        AMOUNT_MALFORMED,\n', '        SELF_TRADE,\n', '        ZERO_VALUE_TRADE\n', '    }\n', '\n', '    struct Order {\n', '        uint orderHash;\n', '        uint matchId;\n', '        uint amount;\n', '        uint expiry;\n', '        address addr;\n', '        uint8 price;\n', '        uint8 direction;\n', '    }\n', '\n', '    // [0]: match hash\n', '    // [1]: amount\n', '    // [2]: 5-byte expiry, 5-byte nonce, 1-byte price, 1-byte direction, 20-byte address\n', '\n', '    function parseOrder(uint[3] memory rawOrder) private constant returns(Order memory o) {\n', '        o.orderHash = uint(keccak256(this, rawOrder));\n', '\n', '        o.matchId = rawOrder[0];\n', '        o.amount = rawOrder[1];\n', '\n', '        uint packed = rawOrder[2];\n', '        o.expiry = packed >> (8*27);\n', '        o.addr = address(packed & 0x00ffffffffffffffffffffffffffffffffffffffff);\n', '        o.price = uint8((packed >> (8*21)) & 0xff);\n', '        o.direction = uint8((packed >> (8*20)) & 0xff);\n', '    }\n', '\n', '    function validateOrderParams(Order memory o) private pure returns(bool) {\n', '        if (o.amount > MAX_SANE_AMOUNT) return false;\n', '        if (o.price == 0 || o.price > 99) return false;\n', '        if (o.direction > 1) return false;\n', '        return true;\n', '    }\n', '\n', '    function validateOrderSig(Order memory o, bytes32 r, bytes32 s, uint8 v) private pure returns(bool) {\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", o.orderHash), v, r, s) != o.addr) return false;\n', '        return true;\n', '    }\n', '\n', '    struct Trade {\n', '        Status status;\n', '        address longAddr;\n', '        address shortAddr;\n', '        int newLongPosition;\n', '        int newShortPosition;\n', '        int longBalanceDelta;\n', '        int shortBalanceDelta;\n', '        uint shortAmount;\n', '        uint longAmount;\n', '    }\n', '\n', '\n', '    // User methods\n', '\n', '    function() external payable {\n', '        revert();\n', '    }\n', '\n', '    function deposit() external payable {\n', '        if (msg.value > 0) {\n', '            uint origAmount = balances[msg.sender];\n', '            uint newAmount = safeAdd(origAmount, msg.value);\n', '            balances[msg.sender] = newAmount;\n', '\n', '            LogDeposit(msg.sender);\n', '            LogBalanceChange(msg.sender, origAmount, newAmount);\n', '        }\n', '    }\n', '\n', '    function withdraw(uint amount) external {\n', '        uint origAmount = balances[msg.sender];\n', '        uint amountToWithdraw = minu256(origAmount, amount);\n', '\n', '        if (amountToWithdraw > 0) {\n', '            uint newAmount = origAmount - amountToWithdraw;\n', '            balances[msg.sender] = newAmount;\n', '\n', '            LogWithdraw(msg.sender);\n', '            LogBalanceChange(msg.sender, origAmount, newAmount);\n', '\n', '            msg.sender.transfer(amountToWithdraw);\n', '        }\n', '    }\n', '\n', '    function cancelOrder(uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\n', '        Order memory o = parseOrder(order);\n', '\n', "        // Don't bother validating order params.\n", '        require(validateOrderSig(o, r, s, v));\n', '        require(o.addr == msg.sender);\n', '\n', '        if (block.timestamp < o.expiry) {\n', '            filledAmounts[o.orderHash] = o.amount;\n', '            LogOrderCancel(msg.sender, o.matchId, o.orderHash);\n', '        }\n', '    }\n', '\n', '    function trade(uint amount, uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\n', '        Order memory o = parseOrder(order);\n', '\n', '        if (!validateOrderParams(o)) {\n', '            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_MALFORMED));\n', '            return;\n', '        }\n', '\n', '        if (!validateOrderSig(o, r, s, v)) {\n', '            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_BAD_SIG));\n', '            return;\n', '        }\n', '\n', '        Trade memory t = tradeCore(amount, o);\n', '\n', '        if (t.status != Status.OK) {\n', '            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(t.status));\n', '            return;\n', '        }\n', '\n', '        // Modify storage to reflect trade:\n', '\n', '        var m = matches[o.matchId];\n', '\n', '        if (m.firstTradeTimestamp == 0) {\n', '            assert(block.timestamp > 0);\n', '            m.firstTradeTimestamp = uint64(block.timestamp);\n', '        }\n', '\n', '        m.positions[t.longAddr] = t.newLongPosition;\n', '        m.positions[t.shortAddr] = t.newShortPosition;\n', '\n', '        adjustBalance(t.longAddr, t.longBalanceDelta);\n', '        adjustBalance(t.shortAddr, t.shortBalanceDelta);\n', '\n', '        filledAmounts[o.orderHash] += (o.direction == 0 ? t.shortAmount : t.longAmount);\n', '\n', '        LogTrade(msg.sender, o.addr, o.matchId, o.orderHash, o.direction, o.price, t.longAmount, t.newLongPosition, t.shortAmount, t.newShortPosition);\n', '    }\n', '\n', '    function claim(uint matchId, uint8 finalPrice, bytes32 r, bytes32 s, uint8 v) external {\n', '        var m = matches[matchId];\n', '\n', '        if (m.finalized) {\n', '            require(m.finalPrice == finalPrice);\n', '        } else {\n', '            uint messageHash = uint(keccak256(this, matchId, finalPrice));\n', '            address signer = ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", messageHash), v, r, s);\n', '            require(admins[signer]);\n', '            require(finalPrice <= 100);\n', '\n', '            m.finalized = true;\n', '            m.finalPrice = finalPrice;\n', '            LogFinalizeMatch(matchId, finalPrice);\n', '        }\n', '\n', '        // NOTE: final prices other than 0 and 100 may leave very small amounts of unrecoverable dust in the contract due to rounding.\n', '\n', '        int delta = 0;\n', '        int senderPosition = m.positions[msg.sender];\n', '\n', '        if (senderPosition > 0) {\n', '            delta = priceDivide(senderPosition, finalPrice);\n', '        } else if (senderPosition < 0) {\n', '            delta = priceDivide(-senderPosition, 100 - finalPrice);\n', '        } else {\n', '            return;\n', '        }\n', '\n', '        assert(delta >= 0);\n', '\n', '        m.positions[msg.sender] = 0;\n', '        adjustBalance(msg.sender, delta);\n', '\n', '        LogClaim(msg.sender, matchId, uint(delta));\n', '    }\n', '\n', '    function recoverFunds(uint matchId) external {\n', '        var m = matches[matchId];\n', '\n', '        if (m.finalized || m.firstTradeTimestamp == 0) {\n', '            return;\n', '        }\n', '\n', '        uint recoveryTimestamp = uint(m.firstTradeTimestamp) + ((matchId & 0xFF) * 7 * 86400);\n', '\n', '        if (uint(block.timestamp) > recoveryTimestamp) {\n', '            uint8 finalPrice = uint8((matchId & 0xFF00) >> 8);\n', '            require(finalPrice <= 100);\n', '\n', '            m.finalized = true;\n', '            m.finalPrice = finalPrice;\n', '            LogFinalizeMatch(matchId, finalPrice);\n', '        }\n', '    }\n', '\n', '\n', '    // Private utilities\n', '\n', '    function adjustBalance(address addr, int delta) private {\n', '        uint origAmount = balances[addr];\n', '        uint newAmount = delta >= 0 ? safeAdd(origAmount, uint(delta)) : safeSub(origAmount, uint(-delta));\n', '        balances[addr] = newAmount;\n', '\n', '        LogBalanceChange(addr, origAmount, newAmount);\n', '    }\n', '\n', '    function priceDivide(int amount, uint8 price) private pure returns(int) {\n', '        assert(amount >= 0);\n', '        return int(safeMul(uint(amount), price) / 100);\n', '    }\n', '\n', '    function computeEffectiveBalance(uint balance, int position, uint8 price, bool isLong) private pure returns(uint) {\n', '        uint effectiveBalance = balance;\n', '\n', '        if (isLong) {\n', '            if (position < 0) effectiveBalance += uint(priceDivide(-position, price));\n', '        } else {\n', '            if (position > 0) effectiveBalance += uint(priceDivide(position, 100 - price));\n', '        }\n', '\n', '        return effectiveBalance;\n', '    }\n', '\n', '    function computePriceWeightedAmounts(uint longAmount, uint shortAmount, uint price) private pure returns(uint, uint) {\n', '        uint totalLongAmount;\n', '        uint totalShortAmount;\n', '\n', '        totalLongAmount = longAmount + (safeMul(longAmount, 100 - price) / price);\n', '        totalShortAmount = shortAmount + (safeMul(shortAmount, price) / (100 - price));\n', '\n', '        if (totalLongAmount > totalShortAmount) {\n', '            return (totalShortAmount - shortAmount, shortAmount);\n', '        } else {\n', '            return (longAmount, totalLongAmount - longAmount);\n', '        }\n', '    }\n', '\n', '    function computeExposureDelta(int longBalanceDelta, int shortBalanceDelta, int oldLongPosition, int newLongPosition, int oldShortPosition, int newShortPosition) private pure returns(int) {\n', '        int positionDelta = 0;\n', '        if (newLongPosition > 0) positionDelta += newLongPosition - max256(0, oldLongPosition);\n', '        if (oldShortPosition > 0) positionDelta -= oldShortPosition - max256(0, newShortPosition);\n', '\n', '        return positionDelta + longBalanceDelta + shortBalanceDelta;\n', '    }\n', '\n', '    function tradeCore(uint amount, Order memory o) private constant returns(Trade t) {\n', '        var m = matches[o.matchId];\n', '\n', '        if (block.timestamp >= o.expiry) {\n', '            t.status = Status.ORDER_EXPIRED;\n', '            return;\n', '        }\n', '\n', '        if (m.finalized) {\n', '            t.status = Status.MATCH_FINALIZED;\n', '            return;\n', '        }\n', '\n', '        if (msg.sender == o.addr) {\n', '            t.status = Status.SELF_TRADE;\n', '            return;\n', '        }\n', '\n', '        if (amount > MAX_SANE_AMOUNT) {\n', '            t.status = Status.AMOUNT_MALFORMED;\n', '            return;\n', '        }\n', '\n', '        t.status = Status.OK;\n', '\n', '\n', '        uint longAmount;\n', '        uint shortAmount;\n', '\n', '        if (o.direction == 0) {\n', '            // maker short, taker long\n', '            t.longAddr = msg.sender;\n', '            longAmount = amount;\n', '\n', '            t.shortAddr = o.addr;\n', '            shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\n', '        } else {\n', '            // maker long, taker short \n', '            t.longAddr = o.addr;\n', '            longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\n', '\n', '            t.shortAddr = msg.sender;\n', '            shortAmount = amount;\n', '        }\n', '\n', '        int oldLongPosition = m.positions[t.longAddr];\n', '        int oldShortPosition = m.positions[t.shortAddr];\n', '\n', '        longAmount = minu256(longAmount, computeEffectiveBalance(balances[t.longAddr], oldLongPosition, o.price, true));\n', '        shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[t.shortAddr], oldShortPosition, o.price, false));\n', '\n', '        (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\n', '\n', '        if (longAmount == 0 || shortAmount == 0) {\n', '            t.status = Status.ZERO_VALUE_TRADE;\n', '            return;\n', '        }\n', '\n', '\n', '        int newLongPosition = oldLongPosition + (int(longAmount) + int(shortAmount));\n', '        int newShortPosition = oldShortPosition - (int(longAmount) + int(shortAmount));\n', '\n', '\n', '        t.longBalanceDelta = 0;\n', '        t.shortBalanceDelta = 0;\n', '\n', '        if (oldLongPosition < 0) t.longBalanceDelta += priceDivide(-oldLongPosition + min256(0, newLongPosition), 100 - o.price);\n', '        if (newLongPosition > 0) t.longBalanceDelta -= priceDivide(newLongPosition - max256(0, oldLongPosition), o.price);\n', '\n', '        if (oldShortPosition > 0) t.shortBalanceDelta += priceDivide(oldShortPosition - max256(0, newShortPosition), o.price);\n', '        if (newShortPosition < 0) t.shortBalanceDelta -= priceDivide(-newShortPosition + min256(0, oldShortPosition), 100 - o.price);\n', '\n', '        int exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\n', '\n', '        if (exposureDelta != 0) {\n', '            if (exposureDelta == 1) {\n', '                newLongPosition--;\n', '                newShortPosition++;\n', '            } else if (exposureDelta == -1) {\n', '                t.longBalanceDelta++; // one left-over wei: arbitrarily give it to long\n', '            } else {\n', '                assert(false);\n', '            }\n', '\n', '            exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\n', '            assert(exposureDelta == 0);\n', '        }\n', '\n', '\n', '        t.newLongPosition = newLongPosition;\n', '        t.newShortPosition = newShortPosition;\n', '        t.shortAmount = shortAmount;\n', '        t.longAmount = longAmount;\n', '    }\n', '\n', '\n', '    // External views\n', '\n', '    function getOwner() external view returns(address) {\n', '        return owner;\n', '    }\n', '\n', '    function isAdmin(address addr) external view returns(bool) {\n', '        return admins[addr];\n', '    }\n', '\n', '    function getBalance(address addr) external view returns(uint) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function getMatchInfo(uint matchId) external view returns(uint64, bool, uint8) {\n', '        var m = matches[matchId];\n', '        return (m.firstTradeTimestamp, m.finalized, m.finalPrice);\n', '    }\n', '\n', '    function getPosition(uint matchId, address addr) external view returns(int) {\n', '        return matches[matchId].positions[addr];\n', '    }\n', '\n', '    function getFilledAmount(uint orderHash) external view returns(uint) {\n', '        return filledAmounts[orderHash];\n', '    }\n', '\n', '    function checkMatchBatch(address myAddr, uint[16] matchIds) external view returns(int[16] myPosition, bool[16] finalized, uint8[16] finalPrice) {\n', '        for (uint i = 0; i < 16; i++) {\n', '            if (matchIds[i] == 0) break;\n', '\n', '            var m = matches[matchIds[i]];\n', '\n', '            myPosition[i] = m.positions[myAddr];\n', '            finalized[i] = m.finalized;\n', '            finalPrice[i] = m.finalPrice;\n', '        }\n', '    }\n', '\n', '    function checkOrderBatch(uint[48] input) external view returns(uint16[16] status, uint[16] amount) {\n', '        for (uint i = 0; i < 16; i++) {\n', '            uint[3] memory rawOrder;\n', '            rawOrder[0] = input[(i*3)];\n', '            rawOrder[1] = input[(i*3) + 1];\n', '            rawOrder[2] = input[(i*3) + 2];\n', '\n', '            if (rawOrder[0] == 0) break;\n', '\n', '            Order memory o = parseOrder(rawOrder);\n', '\n', '            if (!validateOrderParams(o)) {\n', '                status[i] = uint16(Status.ORDER_MALFORMED);\n', '                amount[i] = 0;\n', '                continue;\n', '            }\n', '\n', '            // Not validating order signatures or timestamps: should be done by clients\n', '\n', '            var m = matches[o.matchId];\n', '\n', '            if (m.finalized) {\n', '                status[i] = uint16(Status.MATCH_FINALIZED);\n', '                amount[i] = 0;\n', '                continue;\n', '            }\n', '\n', '            uint longAmount;\n', '            uint shortAmount;\n', '\n', '            if (o.direction == 0) {\n', '                shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\n', '                longAmount = safeMul(shortAmount, 100);\n', '                shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, false));\n', '                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\n', '                status[i] = uint16(Status.OK);\n', '                amount[i] = shortAmount;\n', '            } else {\n', '                longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\n', '                shortAmount = safeMul(longAmount, 100);\n', '                longAmount = minu256(longAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, true));\n', '                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\n', '                status[i] = uint16(Status.OK);\n', '                amount[i] = longAmount;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    // Math utilities\n', '\n', '    function safeMul(uint a, uint b) private pure returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) private pure returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) private pure returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function minu256(uint a, uint b) private pure returns(uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(int a, int b) private pure returns(int) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(int a, int b) private pure returns(int) {\n', '        return a < b ? a : b;\n', '    }\n', '}']