['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' *\n', ' *                                ...........       ...........\n', ' *                           .....                              t...\n', ' *                          TT..                                  ..T.\n', ' *                       TUx.                                        .TT\n', ' *                       .XtTT......                          ....TTtXXT\n', ' *                        UT..  ....                                 XU.\n', ' *                        Tt .                                      TUX.\n', ' *                        TXT..                  ..                .UU.\n', ' *                        .UU T.                 ....              TXT\n', ' *                         tX...                   T.. .           UX.\n', ' *                         TXT..      .             ......        .UU\n', ' *                         TUU..     TT.           ..    ..       TXx\n', ' *                         xtUT..     ....uUXUXXUT...    ..       UXT\n', ' *                          Utx .       TXUXXXXXUXU. .....       .UU\n', ' *                          tUt .       XXtTXUUXuUXU      .      TXx\n', ' *                          TXt..       XX .tXT. uXX   ....      UXT\n', ' *                          uUUT .      TX.     .XXX.   ..  . . .XUx\n', ' *                           Utx .T.  . .X...... XUXu      .... .XTx\n', ' *                           uxu ..xT. TXT        XUXt.   . .   TXT.\n', ' *                           Txt . TXXUXT .        UXXXt        tXt.\n', ' *                           uUx  XUXXXUXUXx      XUUUXUXT... . Uxx\n', ' *                            Xt  .XUXUXXXX.  .x.tUXUXXXXT.Tu.  .Tu\n', ' *                            tx.  .XxXXt.  .  x............x. ..TX.\n', ' *                            TT.....  .  .txt x   rm-rf/  .x.. .Tt\n', ' *                            xTT. ... . TUUU..x ...........x.. .Tt\n', ' *                             xT........ .UXTTTT.TTxTTTTTTut...Tx\n', ' *                             ttt..........xTTxTTTuxxuxTTTTTu. Tt\n', ' *                             uUt........  .................. .T\n', ' *                              Xxtt........     ....    . ....Tt\n', ' *                               xxuU... .     .       . . tttUu\n', ' *                                 UTuut                uuuUu..\n', ' *                                   T...................TT..\n', ' *\n', ' *\n', ' *\n', ' * @title CCCosmos SAT\n', ' *  \n', ' * The only official website: https://cccosmos.com\n', ' * \n', ' *     CCCosmos is a game Dapp that runs on Ethereum. The mode of smart contract makes it run in a decentralized way. \n', ' * Code logic prevents any others&#39; control and keep the game fun, fair, and feasible. Unlike most DApps that require a browser\n', ' * plug-in, the well-designed CCCosmos can easily help you win great bonuses via any decentralized Ethereum wallet \n', ' * on your phone.\n', ' *   \n', ' *                                        ///Game Description///\n', ' * # The first-time user can activate his/her Ethereum address by just paying an amount more than 0.01eth.\n', ' * \n', ' * # The contract will automatically calculate the user&#39;s SAT account according to the price, and may immediately \n', ' * receive up to seven-fold rewards.\n', ' * \n', ' * # Holding SAT brings users continuous earnings; if you are the last one to get SAT at the end of the game, you \n', ' * will win the huge sum in the final pot!\n', ' * \n', ' * # Final Prize\n', ' * As the game countdown ends, the last SAT buyer will win the Final Pot.\n', ' * \n', ' * # Early Birds\n', ' * Whenever a player buys SAT, the SAT price goes up; the early birds would get rich earnings.\n', ' * \n', ' * # Late Surprise\n', ' * SAT buyers will have the chance to win multiplied rewards in betting; later users may win more eths.\n', ' * \n', ' * # Be Dealers\n', ' * The top three users holding the most SATs are dealers who will continuously receive dealer funds for the day.\n', ' * \n', ' * # Happy Ending\n', ' * After the game is over, all users will divide up the whole prize pot to win bonuses, and then a new round of \n', ' * game starts.\n', ' * \n', ' *                                              ///Rules///\n', ' * 1. The countdown to the end is initially set to be 24 hours. Whenever a user buys a SAT, the remaining time will \n', ' * be extended by 30 seconds; but the total extension will not exceed 24 hours.\n', ' * \n', ' * 2. Any amount of eth a user transfers to the contract address, with 0.01 eth deducted for activation fee, can be \n', ' * used to buy SAT. The remaining sum of SAT can be checked in any Ethereum wallet.\n', ' * \n', ' * 3. The initial SAT price is 0.000088eth, and the price will increase by 0.000000002eth for every SAT purchased.\n', ' * \n', ' * 4. All eths the users spent on SAT are put into the prize pot, 50% of which enters the Share Pot, 20% the Final \n', ' * Pot, 25.5% the Lucky Pot, and the rest 4.5% the Dealer Pot.\n', ' * \n', ' * 5. When users transfer a certain amount of SAT to the contract address, the corresponding response function \n', ' * will be triggered and then the transferred SAT will be refunded in full.\n', ' * \n', ' *    # To get all the eth gains earned at your address by transferring back 0.08 SAT.\n', ' * \n', ' *    # To make an instant re-investment and buy SAT with all eth gains earned at your address by transferring \n', ' *      back 0.01 SAT.\n', ' * \n', ' *    # After the game is over, you can get all the eth gains earned at your address by transferring back any \n', ' *      amount of SAT.\n', ' * \n', ' *    # The average withdrawal rate is less than 7.5% and decreases as the total SAT issuance increases. When the \n', ' *      SAT price reaches 0.1eth, zero-fee is charged!\n', ' * \n', ' * 6. Users have a 50% chance to get instant rewards in different proportions, maximally seven-fold, after they buy \n', ' * SAT immediately.! (The maximum amount of the rewards cannot exceed 1/2 of the current lucky pot.)\n', ' * \n', ' *                             Probability of Winning Rewards\n', ' * \n', ' *                          Reward ratio           probability\n', ' *                               10%                   30%\n', ' *                               20%                   10%\n', ' *                               50%                   5%\n', ' *                               100%                  3%\n', ' *                               300%                  2%\n', ' *                               700%                  1%\n', ' * \n', ' * 7. Users can log into cccosmos.com to check the earnings and get other detailed information.\n', ' * \n', ' * 8. The top three Ethereum addresses with the most SAT purchase for the day will divide up the present Dealer \n', ' *    Fund!\n', ' * \n', ' * 9. One month after the game ends, the unclaimed eths will be automatically transferred to the CCCosmos \n', ' *    Developer Fund for subsequent development and services.\n', ' */\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Saturn\n', ' * @dev The Saturn token.\n', ' */\n', 'contract Saturn is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Player {\n', '        uint256 pid; // player ID, start with 1\n', '        uint256 ethTotal; // total buy amount in ETH\n', '        uint256 ethBalance; // the ETH balance which can be withdraw\n', '        uint256 ethWithdraw; // total eth which has already been withdrawn by player\n', '        uint256 ethShareWithdraw; // total shared pot which has already been withdrawn by player\n', '        uint256 tokenBalance; // token balance\n', '        uint256 tokenDay; // the day which player last buy\n', '        uint256 tokenDayBalance; // the token balance for last day\n', '    }\n', '\n', '    struct LuckyRecord {\n', '        address player; // player address\n', '        uint256 amount; // lucky reward amount\n', '        uint64 txId; // tx ID\n', '        uint64 time; // lucky reward time\n', '        // lucky reward level.\n', '        // reward amount: 1: 700%, 2: 300%, 3: 100%, 4: 50%, 5: 20%, 6: 10%\n', '        // reward chance: 1: 1%, 2: 2%, 3: 3%, 4: 5%, 5: 10%, 6: 30%\n', '        uint64 level;\n', '    }\n', '\n', '    // Keep lucky player which is pending for reward after next block\n', '    struct LuckyPending {\n', '        address player; // player address\n', '        uint256 amount; // player total eth for this tx\n', '        uint64 txId; // tx id\n', '        uint64 block; // current block number\n', '        uint64 level; // lucky level\n', '    }\n', '\n', '    struct InternalBuyEvent {\n', '        // flag1\n', '        // 0 - new player (bool)\n', '        // 1-20 - tx ID\n', '        // 21-31 - finish time\n', '        // 32-46 - dealer1 ID\n', '        // 47-61 - dealer2 ID\n', '        // 62-76 - dealer3 ID\n', '        uint256 flag1;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Buy(\n', '        address indexed _token, address indexed _player, uint256 _amount, uint256 _total,\n', '        uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,\n', '        uint256 _price, uint256 _flag1\n', '    );\n', '    event Withdraw(address indexed _token, address indexed _player, uint256 _amount);\n', '    event Win(address indexed _token, address indexed _winner, uint256 _winAmount);\n', '\n', '    string constant public name = "Saturn";\n', '    string constant public symbol = "SAT";\n', '    uint8 constant public decimals = 18;\n', '\n', '    uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney; // register fee per player\n', '    uint256 constant private BUY_AMOUNT_MIN = 1000000000; // buy token minimal ETH\n', '    uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000; // buy token maximal ETH\n', '    uint256 constant private TIME_DURATION_INCREASE = 30 seconds; // time increased by each token\n', '    uint256 constant private TIME_DURATION_MAX = 24 hours; // max duration for game\n', '    uint256 constant private ONE_TOKEN = 1000000000000000000; // one token which is 10^18\n', '\n', '    mapping(address => Player) public playerOf; // player address => player info\n', '    mapping(uint256 => address) public playerIdOf; // player id => player address\n', '    uint256 public playerCount; // total player\n', '\n', '    uint256 public totalSupply; // token total supply\n', '\n', '    uint256 public totalPot; // total eth which players bought\n', '    uint256 public sharePot; // shared pot for all players\n', '    uint256 public finalPot; // final win pot for winner (last player)\n', '    uint256 public luckyPot; // lucky pot based on random number.\n', '\n', '    uint64 public txCount; // total transaction\n', '    uint256 public finishTime; // game finish time. It will be set startTime+24 hours when activate the contract.\n', '    uint256 public startTime; // the game is activated when now>=startTime.\n', '\n', '    address public lastPlayer; // last player which by at least one key.\n', '    address public winner; // winner for final pot.\n', '    uint256 public winAmount; // win amount for winner, which will be final pot.\n', '\n', '    uint256 public price; // token price\n', '\n', '    address[3] public dealers; // top 3 token owners for daily. Dealers will be reset every midnight (00:00) UTC&#177;00:00\n', '    uint256 public dealerDay; // The midnight time in UTC&#177;00:00 which last player bought the token (without hour, minute, second)\n', '\n', '    LuckyPending[] public luckyPendings;\n', '    uint256 public luckyPendingIndex;\n', '    LuckyRecord[] public luckyRecords; // The lucky player history.\n', '\n', '    address public feeOwner; // fee owner. all fee will be send to this address.\n', '    uint256 public feeAmount; // current fee amount. new fee will be added to it.\n', '\n', '    // withdraw fee price levels.\n', '    uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];\n', '    // withdraw fee percent. if feePrices[i]<=current price<feePrices[i + 1], then the withdraw fee will be (feePercents[i]/1000)*withdrawAmount\n', '    uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];\n', '    // current withdraw fee index. it will be updated when player buy token\n', '    uint256 public feeIndex;\n', '\n', '    /**\n', '    * @dev Init the contract with fee owner. the game is not ready before activate function is called.\n', '    * Token total supply will be 0.\n', '    */\n', '    constructor(uint256 _startTime, address _feeOwner) public {\n', '        require(_startTime >= now && _feeOwner != address(0));\n', '        startTime = _startTime;\n', '        finishTime = _startTime + TIME_DURATION_MAX;\n', '        totalSupply = 0;\n', '        price = 88000000000000;\n', '        feeOwner = _feeOwner;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if game is not ready\n', '     */\n', '    modifier isActivated() {\n', '        require(now >= startTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if sender is not account (contract etc.).\n', '     * This is not 100% guarantee that the caller is account (ie after account abstraction is implemented), but it is good enough.\n', '     */\n', '    modifier isAccount() {\n', '        address _address = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_address)}\n', '        require(_codeLength == 0 && tx.origin == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Token balance for player\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return playerOf[_owner].tokenBalance;\n', '    }\n', '\n', '    /**\n', '     * @dev Get lucky pending size\n', '     */\n', '    function getLuckyPendingSize() public view returns (uint256) {\n', '        return luckyPendings.length;\n', '    }\n', '    /**\n', '     * @dev Get lucky record size\n', '     */\n', '    function getLuckyRecordSize() public view returns (uint256) {\n', '        return luckyRecords.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the game info\n', '     */\n', '    function getGameInfo() public view returns (\n', '        uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,\n', '        uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent\n', '    ) {\n', '        _balance = address(this).balance;\n', '        _totalPot = totalPot;\n', '        _sharePot = sharePot;\n', '        _finalPot = finalPot;\n', '        _luckyPot = luckyPot;\n', '        _rewardPot = _sharePot;\n', '        uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);\n', '        if (_totalPot > _withdraw) {\n', '            _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));\n', '        }\n', '        _price = price;\n', '        _totalSupply = totalSupply;\n', '        _now = now;\n', '        _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];\n', '        if (now < finishTime) {\n', '            _timeLeft = finishTime - now;\n', '        } else {\n', '            _timeLeft = 0;\n', '            _winner = winner != address(0) ? winner : lastPlayer;\n', '            _winAmount = winner != address(0) ? winAmount : finalPot;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the player info by address\n', '     */\n', '    function getPlayerInfo(address _playerAddress) public view returns (\n', '        uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,\n', '        uint256 _tokenBalance, uint256 _tokenDayBalance\n', '    ) {\n', '        Player storage _player = playerOf[_playerAddress];\n', '        if (_player.pid > 0) {\n', '            _pid = _player.pid;\n', '            _ethTotal = _player.ethTotal;\n', '            uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\n', '            _ethBalance = _player.ethBalance;\n', '            if (_sharePot > _player.ethShareWithdraw) {\n', '                _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));\n', '            }\n', '            _ethWithdraw = _player.ethWithdraw;\n', '            _tokenBalance = _player.tokenBalance;\n', '            uint256 _day = (now / 86400) * 86400;\n', '            if (_player.tokenDay == _day) {\n', '                _tokenDayBalance = _player.tokenDayBalance;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get dealer and lucky records\n', '     */\n', '    function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (\n', '        address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,\n', '        address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes\n', '    ) {\n', '        uint256 _day = (now / 86400) * 86400;\n', '        if (dealerDay == _day) {\n', '            for (uint256 _i = 0; _i < 3; ++_i) {\n', '                if (dealers[_i] != address(0)) {\n', '                    Player storage _player = playerOf[dealers[_i]];\n', '                    _dealerPlayers[_i] = dealers[_i];\n', '                    _dealerDayTokens[_i] = _player.tokenDayBalance;\n', '                    _dealerTotalTokens[_i] = _player.tokenBalance;\n', '                }\n', '            }\n', '        }\n', '        uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;\n', '        if (_luckyPlayers.length < _size) {\n', '            _size = _luckyPlayers.length;\n', '        }\n', '        for (_i = 0; _i < _size; ++_i) {\n', '            LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];\n', '            _luckyPlayers[_i] = _record.player;\n', '            _luckyAmounts[_i] = _record.amount;\n', '            _luckyLevels[_i] = _record.level;\n', '            _luckyTimes[_i] = _record.time;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw the balance and share pot.\n', '    *\n', '    * Override ERC20 transfer token function. This token is not allowed to transfer between players.\n', '    * So the _to address must be the contract address.\n', '    * 1. When game already finished: Player can send any amount of token to contract, and the contract will send the eth balance and share pot to player.\n', '    * 2. When game is not finished yet:\n', '    *    A. Withdraw. Player send 0.08 Token to contract, and the contract will send the eth balance and share pot to player.\n', '    *    B. ReBuy. Player send 0.01 Token to contract, then player&#39;s eth balance and share pot will be used to buy token.\n', '    *    C. Invalid. Other value is invalid.\n', '    * @param _to address The address which you want to transfer/sell to. MUST be contract address.\n', '    * @param _value uint256 the amount of tokens to be transferred/sold.\n', '    */\n', '    function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n', '        require(_to == address(this));\n', '        Player storage _player = playerOf[msg.sender];\n', '        require(_player.pid > 0);\n', '        if (now >= finishTime) {\n', '            if (winner == address(0)) {\n', '                // If the endGame is not called, then call it.\n', '                endGame();\n', '            }\n', '            // Player want to withdraw.\n', '            _value = 80000000000000000;\n', '        } else {\n', '            // Only withdraw or rebuy allowed.\n', '            require(_value == 80000000000000000 || _value == 10000000000000000);\n', '        }\n', '        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\n', '        uint256 _eth = 0;\n', '        // the total share pot need to sub amount which already be withdrawn by player.\n', '        if (_sharePot > _player.ethShareWithdraw) {\n', '            _eth = _sharePot.sub(_player.ethShareWithdraw);\n', '            _player.ethShareWithdraw = _sharePot;\n', '        }\n', '        // add the player&#39;s eth balance\n', '        _eth = _eth.add(_player.ethBalance);\n', '        _player.ethBalance = 0;\n', '        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n', '        if (_value == 80000000000000000) {\n', '            // Player want to withdraw\n', '            // Calculate fee based on price level.\n', '            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n', '            if (_fee > 0) {\n', '                feeAmount = feeAmount.add(_fee);\n', '                _eth = _eth.sub(_fee);\n', '            }\n', '            sendFeeIfAvailable();\n', '            msg.sender.transfer(_eth);\n', '            emit Withdraw(_to, msg.sender, _eth);\n', '            emit Transfer(msg.sender, _to, 0);\n', '        } else {\n', '            // Player want to rebuy token\n', '            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n', '                flag1: 0\n', '                });\n', '            buy(_player, _buyEvent, _eth);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Buy token using ETH\n', '    * Player sends ETH to this contract, then his token balance will be increased based on price.\n', '    * The total supply will also be increased.\n', '    * Player need 0.01 ETH register fee to register this address (first time buy).\n', '    * The buy amount need between 0.000000001ETH and 100000ETH\n', '    */\n', '    function() isActivated isAccount payable public {\n', '        uint256 _eth = msg.value;\n', '        require(now < finishTime);\n', '        InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n', '            flag1: 0\n', '            });\n', '        Player storage _player = playerOf[msg.sender];\n', '        if (_player.pid == 0) {\n', '            // Register the player, make sure the eth is enough.\n', '            require(_eth >= FEE_REGISTER_ACCOUNT);\n', '            // Reward player BUY_AMOUNT_MIN for register. So the final register fee will be FEE_REGISTER_ACCOUNT-BUY_AMOUNT_MIN\n', '            uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);\n', '            _eth = _eth.sub(_fee);\n', '            // The register fee will go to fee owner\n', '            feeAmount = feeAmount.add(_fee);\n', '            playerCount = playerCount.add(1);\n', '            Player memory _p = Player({\n', '                pid: playerCount,\n', '                ethTotal: 0,\n', '                ethBalance: 0,\n', '                ethWithdraw: 0,\n', '                ethShareWithdraw: 0,\n', '                tokenBalance: 0,\n', '                tokenDay: 0,\n', '                tokenDayBalance: 0\n', '                });\n', '            playerOf[msg.sender] = _p;\n', '            playerIdOf[_p.pid] = msg.sender;\n', '            _player = playerOf[msg.sender];\n', '            // The player is newly register first time.\n', '            _buyEvent.flag1 += 1;\n', '        }\n', '        buy(_player, _buyEvent, _eth);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy the token\n', '     */\n', '    function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\n', '        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\n', '        // Calculate the midnight\n', '        uint256 _day = (now / 86400) * 86400;\n', '        uint256 _backEth = 0;\n', '        uint256 _eth = _amount;\n', '        if (totalPot < 200000000000000000000) {\n', '            // If the totalPot<200ETH, we are allow to buy 5ETH each time.\n', '            if (_eth >= 5000000000000000000) {\n', '                // the other eth will add to player&#39;s ethBalance\n', '                _backEth = _eth.sub(5000000000000000000);\n', '                _eth = 5000000000000000000;\n', '            }\n', '        }\n', '        txCount = txCount + 1; // do not need use safe math\n', '        _buyEvent.flag1 += txCount * 10; // do not need use safe math\n', '        _player.ethTotal = _player.ethTotal.add(_eth);\n', '        totalPot = totalPot.add(_eth);\n', '        // Calculate the new total supply based on totalPot\n', '        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\n', '        // The player will get the token with totalSupply delta\n', '        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\n', '        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\n', '        // If the player buy token before today, then add the tokenDayBalance.\n', '        // otherwise reset tokenDayBalance\n', '        if (_player.tokenDay == _day) {\n', '            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\n', '        } else {\n', '            _player.tokenDay = _day;\n', '            _player.tokenDayBalance = _tokenAmount;\n', '        }\n', '        // Update the token price by new total supply\n', '        updatePrice(_newTotalSupply);\n', '        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\n', '        if (_backEth > 0) {\n', '            _player.ethBalance = _player.ethBalance.add(_backEth);\n', '        }\n', '        sendFeeIfAvailable();\n', '        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\n', '    }\n', '\n', '    /**\n', '     * @dev Handle the pot (share, final, lucky and dealer)\n', '     */\n', '    function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n', '        uint256 _sharePotDelta = _eth.div(2); // share pot: 50%\n', '        uint256 _finalPotDelta = _eth.div(5); // final pot: 20%;\n', '        uint256 _luckyPotDelta = _eth.mul(255).div(1000); // lucky pot: 25.5%;\n', '        uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta); // dealer pot: 4.5%\n', '        sharePot = sharePot.add(_sharePotDelta);\n', '        finalPot = finalPot.add(_finalPotDelta);\n', '        luckyPot = luckyPot.add(_luckyPotDelta);\n', '        totalSupply = _newTotalSupply;\n', '        handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);\n', '        handleLuckyPot(_eth, _player);\n', '        // The player need to buy at least one token to change the finish time and last player.\n', '        if (_tokenAmount >= ONE_TOKEN) {\n', '            updateFinishTime(_tokenAmount);\n', '            lastPlayer = msg.sender;\n', '        }\n', '        _buyEvent.flag1 += finishTime * 1000000000000000000000; // do not need use safe math\n', '    }\n', '\n', '    /**\n', '     * @dev Handle lucky pot. The player can lucky pot by random number. The maximum amount will be half of total lucky pot\n', '     * The lucky reward will be added to player&#39;s eth balance\n', '     */\n', '    function handleLuckyPot(uint256 _eth, Player storage _player) private {\n', '        uint256 _seed = uint256(keccak256(abi.encodePacked(\n', '                (block.timestamp).add\n', '                (block.difficulty).add\n', '                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n', '                (block.gaslimit).add\n', '                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n', '                (block.number)\n', '            )));\n', '        _seed = _seed - ((_seed / 1000) * 1000);\n', '        uint64 _level = 0;\n', '        if (_seed < 227) { // 22.7%\n', '            _level = 1;\n', '        } else if (_seed < 422) { // 19.5%\n', '            _level = 2;\n', '        } else if (_seed < 519) { // 9.7%\n', '            _level = 3;\n', '        } else if (_seed < 600) { // 8.1%\n', '            _level = 4;\n', '        } else if (_seed < 700) { // 10%\n', '            _level = 5;\n', '        } else {  // 30%\n', '            _level = 6;\n', '        }\n', '        if (_level >= 5) {\n', '            // if level is 5 and 6, we will reward immediately\n', '            handleLuckyReward(txCount, _level, _eth, _player);\n', '        } else {\n', '            // otherwise we will save it for next block to check if it is reward or not\n', '            LuckyPending memory _pending = LuckyPending({\n', '                player: msg.sender,\n', '                amount: _eth,\n', '                txId: txCount,\n', '                block: uint64(block.number + 1),\n', '                level: _level\n', '                });\n', '            luckyPendings.push(_pending);\n', '        }\n', '        // handle the pending lucky reward\n', '        handleLuckyPending(_level >= 5 ? 0 : 1);\n', '    }\n', '\n', '    function handleLuckyPending(uint256 _pendingSkipSize) private {\n', '        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n', '            LuckyPending storage _pending = luckyPendings[luckyPendingIndex];\n', '            if (_pending.block <= block.number) {\n', '                uint256 _seed = uint256(keccak256(abi.encodePacked(\n', '                        (block.timestamp).add\n', '                        (block.difficulty).add\n', '                        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n', '                        (block.gaslimit).add\n', '                        (block.number)\n', '                    )));\n', '                _seed = _seed - ((_seed / 1000) * 1000);\n', '                handleLucyPendingForOne(_pending, _seed);\n', '                if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n', '                    _pending = luckyPendings[luckyPendingIndex];\n', '                    if (_pending.block <= block.number) {\n', '                        handleLucyPendingForOne(_pending, _seed);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {\n', '        luckyPendingIndex = luckyPendingIndex.add(1);\n', '        bool _reward = false;\n', '        if (_pending.level == 4) {\n', '            _reward = _seed < 617;\n', '        } else if (_pending.level == 3) {\n', '            _reward = _seed < 309;\n', '        } else if (_pending.level == 2) {\n', '            _reward = _seed < 102;\n', '        } else if (_pending.level == 1) {\n', '            _reward = _seed < 44;\n', '        }\n', '        if (_reward) {\n', '            handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);\n', '        }\n', '    }\n', '\n', '    function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {\n', '        uint256 _amount;\n', '        if (_level == 1) {\n', '            _amount = _eth.mul(7); // 700%\n', '        } else if (_level == 2) {\n', '            _amount = _eth.mul(3); // 300%\n', '        } else if (_level == 3) {\n', '            _amount = _eth;        // 100%\n', '        } else if (_level == 4) {\n', '            _amount = _eth.div(2); // 50%\n', '        } else if (_level == 5) {\n', '            _amount = _eth.div(5); // 20%\n', '        } else if (_level == 6) {\n', '            _amount = _eth.div(10); // 10%\n', '        }\n', '        uint256 _maxPot = luckyPot.div(2);\n', '        if (_amount > _maxPot) {\n', '            _amount = _maxPot;\n', '        }\n', '        luckyPot = luckyPot.sub(_amount);\n', '        _player.ethBalance = _player.ethBalance.add(_amount);\n', '        LuckyRecord memory _record = LuckyRecord({\n', '            player: msg.sender,\n', '            amount: _amount,\n', '            txId: _txId,\n', '            level: _level,\n', '            time: uint64(now)\n', '            });\n', '        luckyRecords.push(_record);\n', '    }\n', '\n', '    /**\n', '     * @dev Handle dealer pot. The top 3 of total day token (daily) will get dealer reward.\n', '     * The dealer reward will be added to player&#39;s eth balance\n', '     */\n', '    function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n', '        uint256 _potUnit = _dealerPotDelta.div(dealers.length);\n', '        // If this is the first buy in today, then reset the dealers info.\n', '        if (dealerDay != _day || dealers[0] == address(0)) {\n', '            dealerDay = _day;\n', '            dealers[0] = msg.sender;\n', '            dealers[1] = address(0);\n', '            dealers[2] = address(0);\n', '            _player.ethBalance = _player.ethBalance.add(_potUnit);\n', '            feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));\n', '            _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000; // do not need safe math\n', '            return;\n', '        }\n', '        // Sort the dealers info by daily token balance.\n', '        for (uint256 _i = 0; _i < dealers.length; ++_i) {\n', '            if (dealers[_i] == address(0)) {\n', '                dealers[_i] = msg.sender;\n', '                break;\n', '            }\n', '            if (dealers[_i] == msg.sender) {\n', '                break;\n', '            }\n', '            Player storage _dealer = playerOf[dealers[_i]];\n', '            if (_dealer.tokenDayBalance < _player.tokenDayBalance) {\n', '                for (uint256 _j = dealers.length - 1; _j > _i; --_j) {\n', '                    if (dealers[_j - 1] != msg.sender) {\n', '                        dealers[_j] = dealers[_j - 1];\n', '                    }\n', '                }\n', '                dealers[_i] = msg.sender;\n', '                break;\n', '            }\n', '        }\n', '        // the all dealers share the dealer reward.\n', '        uint256 _fee = _dealerPotDelta;\n', '        for (_i = 0; _i < dealers.length; ++_i) {\n', '            if (dealers[_i] == address(0)) {\n', '                break;\n', '            }\n', '            _dealer = playerOf[dealers[_i]];\n', '            _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);\n', '            _fee = _fee.sub(_potUnit);\n', '            _buyEvent.flag1 += _dealer.pid *\n', '            (_i == 0 ? 100000000000000000000000000000000 :\n', '            (_i == 1 ? 100000000000000000000000000000000000000000000000 :\n', '            (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0))); // do not need safe math, only keep top 3 dealers ID\n', '        }\n', '        if (_fee > 0) {\n', '            feeAmount = feeAmount.add(_fee);\n', '        }\n', '    }\n', '\n', '    function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {\n', '        emit Transfer(address(this), msg.sender, _tokenAmount);\n', '        emit Buy(\n', '            address(this), msg.sender, _eth, _tokenAmount,\n', '            totalSupply, totalPot, sharePot, finalPot, luckyPot,\n', '            price, _buyEvent.flag1\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev End the game.\n', '     */\n', '    function endGame() private {\n', '        // The fee owner will get the lucky pot, because no player will allow to buy the token.\n', '        if (luckyPot > 0) {\n', '            feeAmount = feeAmount.add(luckyPot);\n', '            luckyPot = 0;\n', '        }\n', '        // Set the winner information if it is not set.\n', '        // The winner reward will go to winner eth balance.\n', '        if (winner == address(0) && lastPlayer != address(0)) {\n', '            winner = lastPlayer;\n', '            lastPlayer = address(0);\n', '            winAmount = finalPot;\n', '            finalPot = 0;\n', '            Player storage _player = playerOf[winner];\n', '            _player.ethBalance = _player.ethBalance.add(winAmount);\n', '            emit Win(address(this), winner, winAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update the finish time. each token will increase 30 seconds, up to 24 hours\n', '     */\n', '    function updateFinishTime(uint256 _tokenAmount) private {\n', '        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n', '        uint256 _finishTime = finishTime.add(_timeDelta);\n', '        uint256 _maxTime = now.add(TIME_DURATION_MAX);\n', '        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\n', '    }\n', '\n', '    function updatePrice(uint256 _newTotalSupply) private {\n', '        price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);\n', '        uint256 _idx = feeIndex + 1;\n', '        while (_idx < feePrices.length && price >= feePrices[_idx]) {\n', '            feeIndex = _idx;\n', '            ++_idx;\n', '        }\n', '    }\n', '\n', '    function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {\n', '        return _newTotalPot.mul(10000000000000000000000000000)\n', '        .add(193600000000000000000000000000000000000000000000)\n', '        .sqrt()\n', '        .sub(440000000000000000000000);\n', '    }\n', '\n', '    function sendFeeIfAvailable() private {\n', '        if (feeAmount > 1000000000000000000) {\n', '            feeOwner.transfer(feeAmount);\n', '            feeAmount = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Change the fee owner.\n', '    *\n', '    * @param _feeOwner The new fee owner.\n', '    */\n', '    function changeFeeOwner(address _feeOwner) onlyOwner public {\n', '        require(_feeOwner != feeOwner && _feeOwner != address(0));\n', '        feeOwner = _feeOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw the fee. The owner can withdraw the money after 30 days of game finish.\n', '    * This prevents the money is not locked in this contract.\n', '    * Player can contact the contract owner to get back money if the money is withdrawn.\n', '    * @param _amount The amount which will be withdrawn.\n', '    */\n', '    function withdrawFee(uint256 _amount) onlyOwner public {\n', '        require(now >= finishTime.add(30 days));\n', '        if (winner == address(0)) {\n', '            endGame();\n', '        }\n', '        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\n', '        feeOwner.transfer(_amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' *\n', ' *                                ...........       ...........\n', ' *                           .....                              t...\n', ' *                          TT..                                  ..T.\n', ' *                       TUx.                                        .TT\n', ' *                       .XtTT......                          ....TTtXXT\n', ' *                        UT..  ....                                 XU.\n', ' *                        Tt .                                      TUX.\n', ' *                        TXT..                  ..                .UU.\n', ' *                        .UU T.                 ....              TXT\n', ' *                         tX...                   T.. .           UX.\n', ' *                         TXT..      .             ......        .UU\n', ' *                         TUU..     TT.           ..    ..       TXx\n', ' *                         xtUT..     ....uUXUXXUT...    ..       UXT\n', ' *                          Utx .       TXUXXXXXUXU. .....       .UU\n', ' *                          tUt .       XXtTXUUXuUXU      .      TXx\n', ' *                          TXt..       XX .tXT. uXX   ....      UXT\n', ' *                          uUUT .      TX.     .XXX.   ..  . . .XUx\n', ' *                           Utx .T.  . .X...... XUXu      .... .XTx\n', ' *                           uxu ..xT. TXT        XUXt.   . .   TXT.\n', ' *                           Txt . TXXUXT .        UXXXt        tXt.\n', ' *                           uUx  XUXXXUXUXx      XUUUXUXT... . Uxx\n', ' *                            Xt  .XUXUXXXX.  .x.tUXUXXXXT.Tu.  .Tu\n', ' *                            tx.  .XxXXt.  .  x............x. ..TX.\n', ' *                            TT.....  .  .txt x   rm-rf/  .x.. .Tt\n', ' *                            xTT. ... . TUUU..x ...........x.. .Tt\n', ' *                             xT........ .UXTTTT.TTxTTTTTTut...Tx\n', ' *                             ttt..........xTTxTTTuxxuxTTTTTu. Tt\n', ' *                             uUt........  .................. .T\n', ' *                              Xxtt........     ....    . ....Tt\n', ' *                               xxuU... .     .       . . tttUu\n', ' *                                 UTuut                uuuUu..\n', ' *                                   T...................TT..\n', ' *\n', ' *\n', ' *\n', ' * @title CCCosmos SAT\n', ' *  \n', ' * The only official website: https://cccosmos.com\n', ' * \n', ' *     CCCosmos is a game Dapp that runs on Ethereum. The mode of smart contract makes it run in a decentralized way. \n', " * Code logic prevents any others' control and keep the game fun, fair, and feasible. Unlike most DApps that require a browser\n", ' * plug-in, the well-designed CCCosmos can easily help you win great bonuses via any decentralized Ethereum wallet \n', ' * on your phone.\n', ' *   \n', ' *                                        ///Game Description///\n', ' * # The first-time user can activate his/her Ethereum address by just paying an amount more than 0.01eth.\n', ' * \n', " * # The contract will automatically calculate the user's SAT account according to the price, and may immediately \n", ' * receive up to seven-fold rewards.\n', ' * \n', ' * # Holding SAT brings users continuous earnings; if you are the last one to get SAT at the end of the game, you \n', ' * will win the huge sum in the final pot!\n', ' * \n', ' * # Final Prize\n', ' * As the game countdown ends, the last SAT buyer will win the Final Pot.\n', ' * \n', ' * # Early Birds\n', ' * Whenever a player buys SAT, the SAT price goes up; the early birds would get rich earnings.\n', ' * \n', ' * # Late Surprise\n', ' * SAT buyers will have the chance to win multiplied rewards in betting; later users may win more eths.\n', ' * \n', ' * # Be Dealers\n', ' * The top three users holding the most SATs are dealers who will continuously receive dealer funds for the day.\n', ' * \n', ' * # Happy Ending\n', ' * After the game is over, all users will divide up the whole prize pot to win bonuses, and then a new round of \n', ' * game starts.\n', ' * \n', ' *                                              ///Rules///\n', ' * 1. The countdown to the end is initially set to be 24 hours. Whenever a user buys a SAT, the remaining time will \n', ' * be extended by 30 seconds; but the total extension will not exceed 24 hours.\n', ' * \n', ' * 2. Any amount of eth a user transfers to the contract address, with 0.01 eth deducted for activation fee, can be \n', ' * used to buy SAT. The remaining sum of SAT can be checked in any Ethereum wallet.\n', ' * \n', ' * 3. The initial SAT price is 0.000088eth, and the price will increase by 0.000000002eth for every SAT purchased.\n', ' * \n', ' * 4. All eths the users spent on SAT are put into the prize pot, 50% of which enters the Share Pot, 20% the Final \n', ' * Pot, 25.5% the Lucky Pot, and the rest 4.5% the Dealer Pot.\n', ' * \n', ' * 5. When users transfer a certain amount of SAT to the contract address, the corresponding response function \n', ' * will be triggered and then the transferred SAT will be refunded in full.\n', ' * \n', ' *    # To get all the eth gains earned at your address by transferring back 0.08 SAT.\n', ' * \n', ' *    # To make an instant re-investment and buy SAT with all eth gains earned at your address by transferring \n', ' *      back 0.01 SAT.\n', ' * \n', ' *    # After the game is over, you can get all the eth gains earned at your address by transferring back any \n', ' *      amount of SAT.\n', ' * \n', ' *    # The average withdrawal rate is less than 7.5% and decreases as the total SAT issuance increases. When the \n', ' *      SAT price reaches 0.1eth, zero-fee is charged!\n', ' * \n', ' * 6. Users have a 50% chance to get instant rewards in different proportions, maximally seven-fold, after they buy \n', ' * SAT immediately.! (The maximum amount of the rewards cannot exceed 1/2 of the current lucky pot.)\n', ' * \n', ' *                             Probability of Winning Rewards\n', ' * \n', ' *                          Reward ratio           probability\n', ' *                               10%                   30%\n', ' *                               20%                   10%\n', ' *                               50%                   5%\n', ' *                               100%                  3%\n', ' *                               300%                  2%\n', ' *                               700%                  1%\n', ' * \n', ' * 7. Users can log into cccosmos.com to check the earnings and get other detailed information.\n', ' * \n', ' * 8. The top three Ethereum addresses with the most SAT purchase for the day will divide up the present Dealer \n', ' *    Fund!\n', ' * \n', ' * 9. One month after the game ends, the unclaimed eths will be automatically transferred to the CCCosmos \n', ' *    Developer Fund for subsequent development and services.\n', ' */\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Saturn\n', ' * @dev The Saturn token.\n', ' */\n', 'contract Saturn is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Player {\n', '        uint256 pid; // player ID, start with 1\n', '        uint256 ethTotal; // total buy amount in ETH\n', '        uint256 ethBalance; // the ETH balance which can be withdraw\n', '        uint256 ethWithdraw; // total eth which has already been withdrawn by player\n', '        uint256 ethShareWithdraw; // total shared pot which has already been withdrawn by player\n', '        uint256 tokenBalance; // token balance\n', '        uint256 tokenDay; // the day which player last buy\n', '        uint256 tokenDayBalance; // the token balance for last day\n', '    }\n', '\n', '    struct LuckyRecord {\n', '        address player; // player address\n', '        uint256 amount; // lucky reward amount\n', '        uint64 txId; // tx ID\n', '        uint64 time; // lucky reward time\n', '        // lucky reward level.\n', '        // reward amount: 1: 700%, 2: 300%, 3: 100%, 4: 50%, 5: 20%, 6: 10%\n', '        // reward chance: 1: 1%, 2: 2%, 3: 3%, 4: 5%, 5: 10%, 6: 30%\n', '        uint64 level;\n', '    }\n', '\n', '    // Keep lucky player which is pending for reward after next block\n', '    struct LuckyPending {\n', '        address player; // player address\n', '        uint256 amount; // player total eth for this tx\n', '        uint64 txId; // tx id\n', '        uint64 block; // current block number\n', '        uint64 level; // lucky level\n', '    }\n', '\n', '    struct InternalBuyEvent {\n', '        // flag1\n', '        // 0 - new player (bool)\n', '        // 1-20 - tx ID\n', '        // 21-31 - finish time\n', '        // 32-46 - dealer1 ID\n', '        // 47-61 - dealer2 ID\n', '        // 62-76 - dealer3 ID\n', '        uint256 flag1;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Buy(\n', '        address indexed _token, address indexed _player, uint256 _amount, uint256 _total,\n', '        uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,\n', '        uint256 _price, uint256 _flag1\n', '    );\n', '    event Withdraw(address indexed _token, address indexed _player, uint256 _amount);\n', '    event Win(address indexed _token, address indexed _winner, uint256 _winAmount);\n', '\n', '    string constant public name = "Saturn";\n', '    string constant public symbol = "SAT";\n', '    uint8 constant public decimals = 18;\n', '\n', '    uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney; // register fee per player\n', '    uint256 constant private BUY_AMOUNT_MIN = 1000000000; // buy token minimal ETH\n', '    uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000; // buy token maximal ETH\n', '    uint256 constant private TIME_DURATION_INCREASE = 30 seconds; // time increased by each token\n', '    uint256 constant private TIME_DURATION_MAX = 24 hours; // max duration for game\n', '    uint256 constant private ONE_TOKEN = 1000000000000000000; // one token which is 10^18\n', '\n', '    mapping(address => Player) public playerOf; // player address => player info\n', '    mapping(uint256 => address) public playerIdOf; // player id => player address\n', '    uint256 public playerCount; // total player\n', '\n', '    uint256 public totalSupply; // token total supply\n', '\n', '    uint256 public totalPot; // total eth which players bought\n', '    uint256 public sharePot; // shared pot for all players\n', '    uint256 public finalPot; // final win pot for winner (last player)\n', '    uint256 public luckyPot; // lucky pot based on random number.\n', '\n', '    uint64 public txCount; // total transaction\n', '    uint256 public finishTime; // game finish time. It will be set startTime+24 hours when activate the contract.\n', '    uint256 public startTime; // the game is activated when now>=startTime.\n', '\n', '    address public lastPlayer; // last player which by at least one key.\n', '    address public winner; // winner for final pot.\n', '    uint256 public winAmount; // win amount for winner, which will be final pot.\n', '\n', '    uint256 public price; // token price\n', '\n', '    address[3] public dealers; // top 3 token owners for daily. Dealers will be reset every midnight (00:00) UTC00:00\n', '    uint256 public dealerDay; // The midnight time in UTC00:00 which last player bought the token (without hour, minute, second)\n', '\n', '    LuckyPending[] public luckyPendings;\n', '    uint256 public luckyPendingIndex;\n', '    LuckyRecord[] public luckyRecords; // The lucky player history.\n', '\n', '    address public feeOwner; // fee owner. all fee will be send to this address.\n', '    uint256 public feeAmount; // current fee amount. new fee will be added to it.\n', '\n', '    // withdraw fee price levels.\n', '    uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];\n', '    // withdraw fee percent. if feePrices[i]<=current price<feePrices[i + 1], then the withdraw fee will be (feePercents[i]/1000)*withdrawAmount\n', '    uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];\n', '    // current withdraw fee index. it will be updated when player buy token\n', '    uint256 public feeIndex;\n', '\n', '    /**\n', '    * @dev Init the contract with fee owner. the game is not ready before activate function is called.\n', '    * Token total supply will be 0.\n', '    */\n', '    constructor(uint256 _startTime, address _feeOwner) public {\n', '        require(_startTime >= now && _feeOwner != address(0));\n', '        startTime = _startTime;\n', '        finishTime = _startTime + TIME_DURATION_MAX;\n', '        totalSupply = 0;\n', '        price = 88000000000000;\n', '        feeOwner = _feeOwner;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if game is not ready\n', '     */\n', '    modifier isActivated() {\n', '        require(now >= startTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if sender is not account (contract etc.).\n', '     * This is not 100% guarantee that the caller is account (ie after account abstraction is implemented), but it is good enough.\n', '     */\n', '    modifier isAccount() {\n', '        address _address = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_address)}\n', '        require(_codeLength == 0 && tx.origin == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Token balance for player\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return playerOf[_owner].tokenBalance;\n', '    }\n', '\n', '    /**\n', '     * @dev Get lucky pending size\n', '     */\n', '    function getLuckyPendingSize() public view returns (uint256) {\n', '        return luckyPendings.length;\n', '    }\n', '    /**\n', '     * @dev Get lucky record size\n', '     */\n', '    function getLuckyRecordSize() public view returns (uint256) {\n', '        return luckyRecords.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the game info\n', '     */\n', '    function getGameInfo() public view returns (\n', '        uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,\n', '        uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent\n', '    ) {\n', '        _balance = address(this).balance;\n', '        _totalPot = totalPot;\n', '        _sharePot = sharePot;\n', '        _finalPot = finalPot;\n', '        _luckyPot = luckyPot;\n', '        _rewardPot = _sharePot;\n', '        uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);\n', '        if (_totalPot > _withdraw) {\n', '            _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));\n', '        }\n', '        _price = price;\n', '        _totalSupply = totalSupply;\n', '        _now = now;\n', '        _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];\n', '        if (now < finishTime) {\n', '            _timeLeft = finishTime - now;\n', '        } else {\n', '            _timeLeft = 0;\n', '            _winner = winner != address(0) ? winner : lastPlayer;\n', '            _winAmount = winner != address(0) ? winAmount : finalPot;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the player info by address\n', '     */\n', '    function getPlayerInfo(address _playerAddress) public view returns (\n', '        uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,\n', '        uint256 _tokenBalance, uint256 _tokenDayBalance\n', '    ) {\n', '        Player storage _player = playerOf[_playerAddress];\n', '        if (_player.pid > 0) {\n', '            _pid = _player.pid;\n', '            _ethTotal = _player.ethTotal;\n', '            uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\n', '            _ethBalance = _player.ethBalance;\n', '            if (_sharePot > _player.ethShareWithdraw) {\n', '                _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));\n', '            }\n', '            _ethWithdraw = _player.ethWithdraw;\n', '            _tokenBalance = _player.tokenBalance;\n', '            uint256 _day = (now / 86400) * 86400;\n', '            if (_player.tokenDay == _day) {\n', '                _tokenDayBalance = _player.tokenDayBalance;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get dealer and lucky records\n', '     */\n', '    function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (\n', '        address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,\n', '        address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes\n', '    ) {\n', '        uint256 _day = (now / 86400) * 86400;\n', '        if (dealerDay == _day) {\n', '            for (uint256 _i = 0; _i < 3; ++_i) {\n', '                if (dealers[_i] != address(0)) {\n', '                    Player storage _player = playerOf[dealers[_i]];\n', '                    _dealerPlayers[_i] = dealers[_i];\n', '                    _dealerDayTokens[_i] = _player.tokenDayBalance;\n', '                    _dealerTotalTokens[_i] = _player.tokenBalance;\n', '                }\n', '            }\n', '        }\n', '        uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;\n', '        if (_luckyPlayers.length < _size) {\n', '            _size = _luckyPlayers.length;\n', '        }\n', '        for (_i = 0; _i < _size; ++_i) {\n', '            LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];\n', '            _luckyPlayers[_i] = _record.player;\n', '            _luckyAmounts[_i] = _record.amount;\n', '            _luckyLevels[_i] = _record.level;\n', '            _luckyTimes[_i] = _record.time;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw the balance and share pot.\n', '    *\n', '    * Override ERC20 transfer token function. This token is not allowed to transfer between players.\n', '    * So the _to address must be the contract address.\n', '    * 1. When game already finished: Player can send any amount of token to contract, and the contract will send the eth balance and share pot to player.\n', '    * 2. When game is not finished yet:\n', '    *    A. Withdraw. Player send 0.08 Token to contract, and the contract will send the eth balance and share pot to player.\n', "    *    B. ReBuy. Player send 0.01 Token to contract, then player's eth balance and share pot will be used to buy token.\n", '    *    C. Invalid. Other value is invalid.\n', '    * @param _to address The address which you want to transfer/sell to. MUST be contract address.\n', '    * @param _value uint256 the amount of tokens to be transferred/sold.\n', '    */\n', '    function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n', '        require(_to == address(this));\n', '        Player storage _player = playerOf[msg.sender];\n', '        require(_player.pid > 0);\n', '        if (now >= finishTime) {\n', '            if (winner == address(0)) {\n', '                // If the endGame is not called, then call it.\n', '                endGame();\n', '            }\n', '            // Player want to withdraw.\n', '            _value = 80000000000000000;\n', '        } else {\n', '            // Only withdraw or rebuy allowed.\n', '            require(_value == 80000000000000000 || _value == 10000000000000000);\n', '        }\n', '        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\n', '        uint256 _eth = 0;\n', '        // the total share pot need to sub amount which already be withdrawn by player.\n', '        if (_sharePot > _player.ethShareWithdraw) {\n', '            _eth = _sharePot.sub(_player.ethShareWithdraw);\n', '            _player.ethShareWithdraw = _sharePot;\n', '        }\n', "        // add the player's eth balance\n", '        _eth = _eth.add(_player.ethBalance);\n', '        _player.ethBalance = 0;\n', '        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n', '        if (_value == 80000000000000000) {\n', '            // Player want to withdraw\n', '            // Calculate fee based on price level.\n', '            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n', '            if (_fee > 0) {\n', '                feeAmount = feeAmount.add(_fee);\n', '                _eth = _eth.sub(_fee);\n', '            }\n', '            sendFeeIfAvailable();\n', '            msg.sender.transfer(_eth);\n', '            emit Withdraw(_to, msg.sender, _eth);\n', '            emit Transfer(msg.sender, _to, 0);\n', '        } else {\n', '            // Player want to rebuy token\n', '            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n', '                flag1: 0\n', '                });\n', '            buy(_player, _buyEvent, _eth);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Buy token using ETH\n', '    * Player sends ETH to this contract, then his token balance will be increased based on price.\n', '    * The total supply will also be increased.\n', '    * Player need 0.01 ETH register fee to register this address (first time buy).\n', '    * The buy amount need between 0.000000001ETH and 100000ETH\n', '    */\n', '    function() isActivated isAccount payable public {\n', '        uint256 _eth = msg.value;\n', '        require(now < finishTime);\n', '        InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n', '            flag1: 0\n', '            });\n', '        Player storage _player = playerOf[msg.sender];\n', '        if (_player.pid == 0) {\n', '            // Register the player, make sure the eth is enough.\n', '            require(_eth >= FEE_REGISTER_ACCOUNT);\n', '            // Reward player BUY_AMOUNT_MIN for register. So the final register fee will be FEE_REGISTER_ACCOUNT-BUY_AMOUNT_MIN\n', '            uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);\n', '            _eth = _eth.sub(_fee);\n', '            // The register fee will go to fee owner\n', '            feeAmount = feeAmount.add(_fee);\n', '            playerCount = playerCount.add(1);\n', '            Player memory _p = Player({\n', '                pid: playerCount,\n', '                ethTotal: 0,\n', '                ethBalance: 0,\n', '                ethWithdraw: 0,\n', '                ethShareWithdraw: 0,\n', '                tokenBalance: 0,\n', '                tokenDay: 0,\n', '                tokenDayBalance: 0\n', '                });\n', '            playerOf[msg.sender] = _p;\n', '            playerIdOf[_p.pid] = msg.sender;\n', '            _player = playerOf[msg.sender];\n', '            // The player is newly register first time.\n', '            _buyEvent.flag1 += 1;\n', '        }\n', '        buy(_player, _buyEvent, _eth);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy the token\n', '     */\n', '    function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\n', '        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\n', '        // Calculate the midnight\n', '        uint256 _day = (now / 86400) * 86400;\n', '        uint256 _backEth = 0;\n', '        uint256 _eth = _amount;\n', '        if (totalPot < 200000000000000000000) {\n', '            // If the totalPot<200ETH, we are allow to buy 5ETH each time.\n', '            if (_eth >= 5000000000000000000) {\n', "                // the other eth will add to player's ethBalance\n", '                _backEth = _eth.sub(5000000000000000000);\n', '                _eth = 5000000000000000000;\n', '            }\n', '        }\n', '        txCount = txCount + 1; // do not need use safe math\n', '        _buyEvent.flag1 += txCount * 10; // do not need use safe math\n', '        _player.ethTotal = _player.ethTotal.add(_eth);\n', '        totalPot = totalPot.add(_eth);\n', '        // Calculate the new total supply based on totalPot\n', '        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\n', '        // The player will get the token with totalSupply delta\n', '        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\n', '        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\n', '        // If the player buy token before today, then add the tokenDayBalance.\n', '        // otherwise reset tokenDayBalance\n', '        if (_player.tokenDay == _day) {\n', '            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\n', '        } else {\n', '            _player.tokenDay = _day;\n', '            _player.tokenDayBalance = _tokenAmount;\n', '        }\n', '        // Update the token price by new total supply\n', '        updatePrice(_newTotalSupply);\n', '        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\n', '        if (_backEth > 0) {\n', '            _player.ethBalance = _player.ethBalance.add(_backEth);\n', '        }\n', '        sendFeeIfAvailable();\n', '        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\n', '    }\n', '\n', '    /**\n', '     * @dev Handle the pot (share, final, lucky and dealer)\n', '     */\n', '    function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n', '        uint256 _sharePotDelta = _eth.div(2); // share pot: 50%\n', '        uint256 _finalPotDelta = _eth.div(5); // final pot: 20%;\n', '        uint256 _luckyPotDelta = _eth.mul(255).div(1000); // lucky pot: 25.5%;\n', '        uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta); // dealer pot: 4.5%\n', '        sharePot = sharePot.add(_sharePotDelta);\n', '        finalPot = finalPot.add(_finalPotDelta);\n', '        luckyPot = luckyPot.add(_luckyPotDelta);\n', '        totalSupply = _newTotalSupply;\n', '        handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);\n', '        handleLuckyPot(_eth, _player);\n', '        // The player need to buy at least one token to change the finish time and last player.\n', '        if (_tokenAmount >= ONE_TOKEN) {\n', '            updateFinishTime(_tokenAmount);\n', '            lastPlayer = msg.sender;\n', '        }\n', '        _buyEvent.flag1 += finishTime * 1000000000000000000000; // do not need use safe math\n', '    }\n', '\n', '    /**\n', '     * @dev Handle lucky pot. The player can lucky pot by random number. The maximum amount will be half of total lucky pot\n', "     * The lucky reward will be added to player's eth balance\n", '     */\n', '    function handleLuckyPot(uint256 _eth, Player storage _player) private {\n', '        uint256 _seed = uint256(keccak256(abi.encodePacked(\n', '                (block.timestamp).add\n', '                (block.difficulty).add\n', '                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n', '                (block.gaslimit).add\n', '                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n', '                (block.number)\n', '            )));\n', '        _seed = _seed - ((_seed / 1000) * 1000);\n', '        uint64 _level = 0;\n', '        if (_seed < 227) { // 22.7%\n', '            _level = 1;\n', '        } else if (_seed < 422) { // 19.5%\n', '            _level = 2;\n', '        } else if (_seed < 519) { // 9.7%\n', '            _level = 3;\n', '        } else if (_seed < 600) { // 8.1%\n', '            _level = 4;\n', '        } else if (_seed < 700) { // 10%\n', '            _level = 5;\n', '        } else {  // 30%\n', '            _level = 6;\n', '        }\n', '        if (_level >= 5) {\n', '            // if level is 5 and 6, we will reward immediately\n', '            handleLuckyReward(txCount, _level, _eth, _player);\n', '        } else {\n', '            // otherwise we will save it for next block to check if it is reward or not\n', '            LuckyPending memory _pending = LuckyPending({\n', '                player: msg.sender,\n', '                amount: _eth,\n', '                txId: txCount,\n', '                block: uint64(block.number + 1),\n', '                level: _level\n', '                });\n', '            luckyPendings.push(_pending);\n', '        }\n', '        // handle the pending lucky reward\n', '        handleLuckyPending(_level >= 5 ? 0 : 1);\n', '    }\n', '\n', '    function handleLuckyPending(uint256 _pendingSkipSize) private {\n', '        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n', '            LuckyPending storage _pending = luckyPendings[luckyPendingIndex];\n', '            if (_pending.block <= block.number) {\n', '                uint256 _seed = uint256(keccak256(abi.encodePacked(\n', '                        (block.timestamp).add\n', '                        (block.difficulty).add\n', '                        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n', '                        (block.gaslimit).add\n', '                        (block.number)\n', '                    )));\n', '                _seed = _seed - ((_seed / 1000) * 1000);\n', '                handleLucyPendingForOne(_pending, _seed);\n', '                if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n', '                    _pending = luckyPendings[luckyPendingIndex];\n', '                    if (_pending.block <= block.number) {\n', '                        handleLucyPendingForOne(_pending, _seed);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {\n', '        luckyPendingIndex = luckyPendingIndex.add(1);\n', '        bool _reward = false;\n', '        if (_pending.level == 4) {\n', '            _reward = _seed < 617;\n', '        } else if (_pending.level == 3) {\n', '            _reward = _seed < 309;\n', '        } else if (_pending.level == 2) {\n', '            _reward = _seed < 102;\n', '        } else if (_pending.level == 1) {\n', '            _reward = _seed < 44;\n', '        }\n', '        if (_reward) {\n', '            handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);\n', '        }\n', '    }\n', '\n', '    function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {\n', '        uint256 _amount;\n', '        if (_level == 1) {\n', '            _amount = _eth.mul(7); // 700%\n', '        } else if (_level == 2) {\n', '            _amount = _eth.mul(3); // 300%\n', '        } else if (_level == 3) {\n', '            _amount = _eth;        // 100%\n', '        } else if (_level == 4) {\n', '            _amount = _eth.div(2); // 50%\n', '        } else if (_level == 5) {\n', '            _amount = _eth.div(5); // 20%\n', '        } else if (_level == 6) {\n', '            _amount = _eth.div(10); // 10%\n', '        }\n', '        uint256 _maxPot = luckyPot.div(2);\n', '        if (_amount > _maxPot) {\n', '            _amount = _maxPot;\n', '        }\n', '        luckyPot = luckyPot.sub(_amount);\n', '        _player.ethBalance = _player.ethBalance.add(_amount);\n', '        LuckyRecord memory _record = LuckyRecord({\n', '            player: msg.sender,\n', '            amount: _amount,\n', '            txId: _txId,\n', '            level: _level,\n', '            time: uint64(now)\n', '            });\n', '        luckyRecords.push(_record);\n', '    }\n', '\n', '    /**\n', '     * @dev Handle dealer pot. The top 3 of total day token (daily) will get dealer reward.\n', "     * The dealer reward will be added to player's eth balance\n", '     */\n', '    function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n', '        uint256 _potUnit = _dealerPotDelta.div(dealers.length);\n', '        // If this is the first buy in today, then reset the dealers info.\n', '        if (dealerDay != _day || dealers[0] == address(0)) {\n', '            dealerDay = _day;\n', '            dealers[0] = msg.sender;\n', '            dealers[1] = address(0);\n', '            dealers[2] = address(0);\n', '            _player.ethBalance = _player.ethBalance.add(_potUnit);\n', '            feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));\n', '            _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000; // do not need safe math\n', '            return;\n', '        }\n', '        // Sort the dealers info by daily token balance.\n', '        for (uint256 _i = 0; _i < dealers.length; ++_i) {\n', '            if (dealers[_i] == address(0)) {\n', '                dealers[_i] = msg.sender;\n', '                break;\n', '            }\n', '            if (dealers[_i] == msg.sender) {\n', '                break;\n', '            }\n', '            Player storage _dealer = playerOf[dealers[_i]];\n', '            if (_dealer.tokenDayBalance < _player.tokenDayBalance) {\n', '                for (uint256 _j = dealers.length - 1; _j > _i; --_j) {\n', '                    if (dealers[_j - 1] != msg.sender) {\n', '                        dealers[_j] = dealers[_j - 1];\n', '                    }\n', '                }\n', '                dealers[_i] = msg.sender;\n', '                break;\n', '            }\n', '        }\n', '        // the all dealers share the dealer reward.\n', '        uint256 _fee = _dealerPotDelta;\n', '        for (_i = 0; _i < dealers.length; ++_i) {\n', '            if (dealers[_i] == address(0)) {\n', '                break;\n', '            }\n', '            _dealer = playerOf[dealers[_i]];\n', '            _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);\n', '            _fee = _fee.sub(_potUnit);\n', '            _buyEvent.flag1 += _dealer.pid *\n', '            (_i == 0 ? 100000000000000000000000000000000 :\n', '            (_i == 1 ? 100000000000000000000000000000000000000000000000 :\n', '            (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0))); // do not need safe math, only keep top 3 dealers ID\n', '        }\n', '        if (_fee > 0) {\n', '            feeAmount = feeAmount.add(_fee);\n', '        }\n', '    }\n', '\n', '    function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {\n', '        emit Transfer(address(this), msg.sender, _tokenAmount);\n', '        emit Buy(\n', '            address(this), msg.sender, _eth, _tokenAmount,\n', '            totalSupply, totalPot, sharePot, finalPot, luckyPot,\n', '            price, _buyEvent.flag1\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev End the game.\n', '     */\n', '    function endGame() private {\n', '        // The fee owner will get the lucky pot, because no player will allow to buy the token.\n', '        if (luckyPot > 0) {\n', '            feeAmount = feeAmount.add(luckyPot);\n', '            luckyPot = 0;\n', '        }\n', '        // Set the winner information if it is not set.\n', '        // The winner reward will go to winner eth balance.\n', '        if (winner == address(0) && lastPlayer != address(0)) {\n', '            winner = lastPlayer;\n', '            lastPlayer = address(0);\n', '            winAmount = finalPot;\n', '            finalPot = 0;\n', '            Player storage _player = playerOf[winner];\n', '            _player.ethBalance = _player.ethBalance.add(winAmount);\n', '            emit Win(address(this), winner, winAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update the finish time. each token will increase 30 seconds, up to 24 hours\n', '     */\n', '    function updateFinishTime(uint256 _tokenAmount) private {\n', '        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n', '        uint256 _finishTime = finishTime.add(_timeDelta);\n', '        uint256 _maxTime = now.add(TIME_DURATION_MAX);\n', '        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\n', '    }\n', '\n', '    function updatePrice(uint256 _newTotalSupply) private {\n', '        price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);\n', '        uint256 _idx = feeIndex + 1;\n', '        while (_idx < feePrices.length && price >= feePrices[_idx]) {\n', '            feeIndex = _idx;\n', '            ++_idx;\n', '        }\n', '    }\n', '\n', '    function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {\n', '        return _newTotalPot.mul(10000000000000000000000000000)\n', '        .add(193600000000000000000000000000000000000000000000)\n', '        .sqrt()\n', '        .sub(440000000000000000000000);\n', '    }\n', '\n', '    function sendFeeIfAvailable() private {\n', '        if (feeAmount > 1000000000000000000) {\n', '            feeOwner.transfer(feeAmount);\n', '            feeAmount = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Change the fee owner.\n', '    *\n', '    * @param _feeOwner The new fee owner.\n', '    */\n', '    function changeFeeOwner(address _feeOwner) onlyOwner public {\n', '        require(_feeOwner != feeOwner && _feeOwner != address(0));\n', '        feeOwner = _feeOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw the fee. The owner can withdraw the money after 30 days of game finish.\n', '    * This prevents the money is not locked in this contract.\n', '    * Player can contact the contract owner to get back money if the money is withdrawn.\n', '    * @param _amount The amount which will be withdrawn.\n', '    */\n', '    function withdrawFee(uint256 _amount) onlyOwner public {\n', '        require(now >= finishTime.add(30 days));\n', '        if (winner == address(0)) {\n', '            endGame();\n', '        }\n', '        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\n', '        feeOwner.transfer(_amount);\n', '    }\n', '\n', '}']
