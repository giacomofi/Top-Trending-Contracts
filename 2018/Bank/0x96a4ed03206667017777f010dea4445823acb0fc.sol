['pragma solidity 0.4.25;\n', '\n', '/*===========================================================================================*\n', '*************************************** https://p4d.io ***************************************\n', '*============================================================================================*\n', '*   \n', '*                            ,-.----.           ,--,              \n', "*                            \\    /  \\        ,--.'|    ,---,     \n", "*                            |   :    \\    ,--,  | :  .'  .' `\\   \n", "*                            |   |  .\\ :,---.'|  : ',---.'     \\  \n", '*                            .   :  |: |;   : |  | ;|   |  .`\\  | \n', "*                            |   |   \\ :|   | : _' |:   : |  '  | \n", "*                            |   : .   /:   : |.'  ||   ' '  ;  : \n", "*                            ;   | |`-' |   ' '  ; :'   | ;  .  | \n", "*                            |   | ;    \\   \\  .'. ||   | :  |  ' \n", "*                            :   ' |     `---`:  | ''   : | /  ;  \n", "*                            :   : :          '  ; ||   | '` ,/   \n", "*                            |   | :          |  : ;;   :  .'     \n", "*                            `---'.|          '  ,/ |   ,.'       \n", "*                              `---`          '--'  '---'         \n", '*                _____ _            _   _              __  __ _      _       _     \n', '*               |_   _| |          | | | |            / _|/ _(_)    (_)     | |    \n', '*                 | | | |__   ___  | | | |_ __   ___ | |_| |_ _  ___ _  __ _| |    \n', "*                 | | | '_ \\ / _ \\ | | | | '_ \\ / _ \\|  _|  _| |/ __| |/ _` | |    \n", '*                 | | | | | |  __/ | |_| | | | | (_) | | | | | | (__| | (_| | |    \n', '*                 \\_/ |_| |_|\\___|  \\___/|_| |_|\\___/|_| |_| |_|\\___|_|\\__,_|_|    \n', '*                                                                                  \n', '*               ______ ___________   _____                           _             \n', '*               | ___ \\____ |  _  \\ |  ___|                         (_)            \n', '*               | |_/ /   / / | | | | |____  ___ __   __ _ _ __  ___ _  ___  _ __  \n', "*               |  __/    \\ \\ | | | |  __\\ \\/ / '_ \\ / _` | '_ \\/ __| |/ _ \\| '_ \\ \n", '*               | |   .___/ / |/ /  | |___>  <| |_) | (_| | | | \\__ \\ | (_) | | | |\n', '*               \\_|   \\____/|___/   \\____/_/\\_\\ .__/ \\__,_|_| |_|___/_|\\___/|_| |_|\n', '*                                             | |                                  \n', '*                                             |_| \n', '*                                                       _L/L\n', '*                                                     _LT/l_L_\n', '*                                                   _LLl/L_T_lL_\n', '*                               _T/L              _LT|L/_|__L_|_L_\n', '*                             _Ll/l_L_          _TL|_T/_L_|__T__|_l_\n', '*                           _TLl/T_l|_L_      _LL|_Tl/_|__l___L__L_|L_\n', "*                         _LT_L/L_|_L_l_L_  _'|_|_|T/_L_l__T _ l__|__|L_\n", '*                       _Tl_L|/_|__|_|__T _LlT_|_Ll/_l_ _|__[ ]__|__|_l_L_\n', '*                ..__ _LT_l_l/|__|__l_T _T_L|_|_|l/___|__ | _l__|_ |__|_T_L_  __\n', '*                   _       ___            _                  _       ___       \n', '*                  /_\\     / __\\___  _ __ | |_ _ __ __ _  ___| |_    / __\\_   _ \n', "*                 //_\\\\   / /  / _ \\| '_ \\| __| '__/ _` |/ __| __|  /__\\// | | |\n", '*                /  _  \\ / /__| (_) | | | | |_| | | (_| | (__| |_  / \\/  \\ |_| |\n', '*                \\_/ \\_/ \\____/\\___/|_| |_|\\__|_|  \\__,_|\\___|\\__| \\_____/\\__, |\n', '*                                   ╔═╗╔═╗╦      ╔╦╗╔═╗╦  ╦               |___/ \n', '*                                   ╚═╗║ ║║       ║║║╣ ╚╗╔╝\n', '*                                   ╚═╝╚═╝╩═╝────═╩╝╚═╝ ╚╝ \n', '*                                      0x736f6c5f646576\n', '*                                      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n', '* \n', '* -> What?\n', '* The original autonomous pyramid, improved (again!):\n', '*  [x] Developer optimized to include utility functions:\n', '*      -> approve(): allow others to transfer on your behalf\n', '*      -> approveAndCall(): callback for contracts that want to use approve()\n', '*      -> transferFrom(): use your approval allowance to transfer P4D on anothers behalf\n', '*      -> transferAndCall(): callback for contracts that want to use transfer()\n', '*  [x] Designed to be a bridge for P3D to make the token functional for use in external contracts\n', '*  [x] Masternodes are also used in P4D as well as when it buys P3D:\n', '*      -> If the referrer has more than 10,000 P4D tokens, they will get 1/3 of the 10% divs\n', '*      -> If the referrer also has more than 100 P3D tokens, they will be used as the ref\n', '*         on the buy order to P3D and receive 1/3 of the 10% P3D divs upon purchase\n', "*  [x] As this contract holds P3D, it will receive ETH dividends proportional to it's\n", '*      holdings, this ETH is then distributed to all P4D token holders proportionally\n', '*  [x] On top of the ETH divs from P3D, you will also receive P3D divs from buys and sells\n', '*      in the P4D exchange\n', "*  [x] There's a 10% div tax for buys, a 5% div tax on sells and a 0% tax on transfers\n", '*  [x] No auto-transfers for dividends or subdividends, they will all be stored until\n', '*      either withdraw() or reinvest() are called, this makes it easier for external\n', '*      contracts to calculate how much they received upon a withdraw/reinvest\n', '*  [x] Partial withdraws and reinvests for both dividends and subdividends\n', '*  [x] Global name registry for all external contracts to use:\n', '*      -> Names cost 0.01 ETH to register\n', '*      -> Names must be unique and not already owned\n', '*      -> You can set an active name out of all the ones you own\n', '*      -> You can change your name at any time but still be referred by an old name\n', '*      -> All ETH from registrations will be distributed to all P4D holders proportionally\n', '*\n', '*/\n', '\n', '\n', '// P3D interface\n', 'interface P3D {\n', '    function buy(address) external payable returns(uint256);\n', '    function transfer(address, uint256) external returns(bool);\n', '    function myTokens() external view returns(uint256);\n', '    function balanceOf(address) external view returns(uint256);\n', '    function myDividends(bool) external view returns(uint256);\n', '    function withdraw() external;\n', '    function calculateTokensReceived(uint256) external view returns(uint256);\n', '    function stakingRequirement() external view returns(uint256);\n', '}\n', '\n', '// ERC-677 style token transfer callback\n', 'interface usingP4D {\n', '    function tokenCallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '}\n', '\n', '// ERC-20 style approval callback\n', 'interface controllingP4D {\n', '    function approvalCallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '}\n', '\n', 'contract P4D {\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyBagholders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    // administrators can:\n', '    // -> change the name of the contract\n', '    // -> change the name of the token\n', '    // -> change the PoS difficulty (how many tokens it costs to hold a masternode, in case it gets crazy high later)\n', '    // -> allow a contract to accept P4D tokens\n', '    // they CANNOT:\n', '    // -> take funds\n', '    // -> disable withdrawals\n', '    // -> kill the contract\n', '    // -> change the price of tokens\n', '    modifier onlyAdministrator() {\n', '        require(administrators[msg.sender] || msg.sender == _dev);\n', '        _;\n', '    }\n', '\n', '    // ensures that the first tokens in the contract will be equally distributed\n', '    // meaning, no divine dump will be ever possible\n', '    // result: healthy longevity.\n', '    modifier purchaseFilter(address _sender, uint256 _amountETH) {\n', '\n', '        require(!isContract(_sender) || canAcceptTokens_[_sender]);\n', '        \n', '        if (now >= ACTIVATION_TIME) {\n', '            onlyAmbassadors = false;\n', '        }\n', '\n', '        // are we still in the vulnerable phase?\n', '        // if so, enact anti early whale protocol\n', '        if (onlyAmbassadors && ((totalAmbassadorQuotaSpent_ + _amountETH) <= ambassadorQuota_)) {\n', '            require(\n', '                // is the customer in the ambassador list?\n', '                ambassadors_[_sender] == true &&\n', '\n', '                // does the customer purchase exceed the max ambassador quota?\n', '                (ambassadorAccumulatedQuota_[_sender] + _amountETH) <= ambassadorMaxPurchase_\n', '            );\n', '\n', '            // updated the accumulated quota\n', '            ambassadorAccumulatedQuota_[_sender] = SafeMath.add(ambassadorAccumulatedQuota_[_sender], _amountETH);\n', '            totalAmbassadorQuotaSpent_ = SafeMath.add(totalAmbassadorQuotaSpent_, _amountETH);\n', '\n', '            // execute\n', '            _;\n', '        } else {\n', '            require(!onlyAmbassadors);\n', '            _;\n', '        }\n', '\n', '    }\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed _customerAddress,\n', '        uint256 _incomingP3D,\n', '        uint256 _tokensMinted,\n', '        address indexed _referredBy\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed _customerAddress,\n', '        uint256 _tokensBurned,\n', '        uint256 _P3D_received\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed _customerAddress,\n', '        uint256 _P3D_reinvested,\n', '        uint256 _tokensMinted\n', '    );\n', '\n', '    event onSubdivsReinvestment(\n', '        address indexed _customerAddress,\n', '        uint256 _ETH_reinvested,\n', '        uint256 _tokensMinted\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed _customerAddress,\n', '        uint256 _P3D_withdrawn\n', '    );\n', '\n', '    event onSubdivsWithdraw(\n', '        address indexed _customerAddress,\n', '        uint256 _ETH_withdrawn\n', '    );\n', '\n', '    event onNameRegistration(\n', '        address indexed _customerAddress,\n', '        string _registeredName\n', '    );\n', '\n', '    // ERC-20\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _tokens\n', '    );\n', '\n', '    event Approval(\n', '        address indexed _tokenOwner,\n', '        address indexed _spender,\n', '        uint256 _tokens\n', '    );\n', '\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "PoWH4D";\n', '    string public symbol = "P4D";\n', '    uint256 constant public decimals = 18;\n', '    uint256 constant internal buyDividendFee_ = 10; // 10% dividend tax on each buy\n', '    uint256 constant internal sellDividendFee_ = 5; // 5% dividend tax on each sell\n', '    uint256 internal tokenPriceInitial_; // set in the constructor\n', '    uint256 constant internal tokenPriceIncremental_ = 1e9; // 1/10th the incremental of P3D\n', '    uint256 constant internal magnitude = 2**64;\n', '    uint256 public stakingRequirement = 1e22; // 10,000 P4D\n', '    uint256 constant internal initialBuyLimitPerTx_ = 1 ether;\n', '    uint256 constant internal initialBuyLimitCap_ = 100 ether;\n', '    uint256 internal totalInputETH_ = 0;\n', '\n', '\n', '    // ambassador program\n', '    mapping(address => bool) internal ambassadors_;\n', '    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\n', '    uint256 constant internal ambassadorQuota_ = 12 ether;\n', '    uint256 internal totalAmbassadorQuotaSpent_ = 0;\n', '    address internal _dev;\n', '\n', '\n', '    uint256 public ACTIVATION_TIME;\n', '\n', '\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal dividendsStored_;\n', '    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 internal profitPerShare_;\n', '\n', '    // administrator list (see above on what they can do)\n', '    mapping(address => bool) public administrators;\n', '\n', '    // when this is set to true, only ambassadors can purchase tokens (this prevents a whale premine, it ensures a fairly distributed upper pyramid)\n', '    bool public onlyAmbassadors = true;\n', '\n', '    // contracts can interact with the exchange but only approved ones\n', '    mapping(address => bool) public canAcceptTokens_;\n', '\n', '    // ERC-20 standard\n', '    mapping(address => mapping (address => uint256)) public allowed;\n', '\n', '    // P3D contract reference\n', '    P3D internal _P3D;\n', '\n', '    // structure to handle the distribution of ETH divs paid out by the P3D contract\n', '    struct P3D_dividends {\n', '        uint256 balance;\n', '        uint256 lastDividendPoints;\n', '    }\n', '    mapping(address => P3D_dividends) internal divsMap_;\n', '    uint256 internal totalDividendPoints_;\n', '    uint256 internal lastContractBalance_;\n', '\n', '    // structure to handle the global unique name/vanity registration\n', '    struct NameRegistry {\n', '        uint256 activeIndex;\n', '        bytes32[] registeredNames;\n', '    }\n', '    mapping(address => NameRegistry) internal customerNameMap_;\n', '    mapping(bytes32 => address) internal globalNameMap_;\n', '    uint256 constant internal nameRegistrationFee = 0.01 ether;\n', '\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS --\n', '    */\n', '    constructor(uint256 _activationTime, address _P3D_address) public {\n', '\n', '        _dev = msg.sender;\n', '\n', '        ACTIVATION_TIME = _activationTime;\n', '\n', '        totalDividendPoints_ = 1; // non-zero value\n', '\n', '        _P3D = P3D(_P3D_address);\n', '\n', '        // virtualized purchase of the entire ambassador quota\n', '        // calculateTokensReceived() for this contract will return how many tokens can be bought starting at 1e9 P3D per P4D\n', '        // as the price increases by the incremental each time we can just multiply it out and scale it back to e18\n', '        //\n', "        // this is used as the initial P3D-P4D price as it makes it fairer on other investors that aren't ambassadors\n", '        uint256 _P4D_received;\n', '        (, _P4D_received) = calculateTokensReceived(ambassadorQuota_);\n', '        tokenPriceInitial_ = tokenPriceIncremental_ * _P4D_received / 1e18;\n', '\n', '        // admins\n', '        administrators[_dev] = true;\n', '        \n', '        // ambassadors\n', '        ambassadors_[_dev] = true;\n', '    }\n', '\n', '\n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\n', '     */\n', '    function buy(address _referredBy)\n', '        payable\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return purchaseInternal(msg.sender, msg.value, _referredBy);\n', '    }\n', '\n', '    /**\n', '     * Buy with a registered name as the referrer.\n', '     * If the name is unregistered, address(0x0) will be the ref\n', '     */\n', '    function buyWithNameRef(string memory _nameOfReferrer)\n', '        payable\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return purchaseInternal(msg.sender, msg.value, ownerOfName(_nameOfReferrer));\n', '    }\n', '\n', '    /**\n', '     * Fallback function to handle ethereum that was sent straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        if (msg.sender != address(_P3D)) {\n', '            purchaseInternal(msg.sender, msg.value, address(0x0));\n', '        }\n', '\n', '        // all other ETH is from the withdrawn dividends from\n', '        // the P3D contract, this is distributed out via the\n', '        // updateSubdivsFor() method\n', '        // no more computation can be done inside this function\n', '        // as when you call address.transfer(uint256), only\n', '        // 2,300 gas is forwarded to this function so no variables\n', '        // can be mutated with that limit\n', '        // address(this).balance will represent the total amount\n', '        // of ETH dividends from the P3D contract (minus the amount\n', "        // that's already been withdrawn)\n", '    }\n', '\n', '    /**\n', '     * Distribute any ETH sent to this method out to all token holders\n', '     */\n', '    function donate()\n', '        payable\n', '        public\n', '    {\n', '        // nothing happens here in order to save gas\n', '        // all of the ETH sent to this function will be distributed out\n', '        // via the updateSubdivsFor() method\n', '        // \n', '        // this method is designed for external contracts that have \n', '        // extra ETH that they want to evenly distribute to all\n', '        // P4D token holders\n', '    }\n', '\n', '    /**\n', '     * Allows a customer to pay for a global name on the P4D network\n', "     * There's a 0.01 ETH registration fee per name\n", '     * All ETH is distributed to P4D token holders via updateSubdivsFor()\n', '     */\n', '    function registerName(string memory _name)\n', '        payable\n', '        public\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        require(!onlyAmbassadors || ambassadors_[_customerAddress]);\n', '\n', '        require(bytes(_name).length > 0);\n', '        require(msg.value >= nameRegistrationFee);\n', '        uint256 excess = SafeMath.sub(msg.value, nameRegistrationFee);\n', '\n', '        bytes32 bytesName = stringToBytes32(_name);\n', '        require(globalNameMap_[bytesName] == address(0x0));\n', '\n', '        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\n', '        customerNamesInfo.registeredNames.push(bytesName);\n', '        customerNamesInfo.activeIndex = customerNamesInfo.registeredNames.length - 1;\n', '\n', '        globalNameMap_[bytesName] = _customerAddress;\n', '\n', '        if (excess > 0) {\n', '            _customerAddress.transfer(excess);\n', '        }\n', '\n', '        // fire event\n', '        emit onNameRegistration(_customerAddress, _name);\n', '\n', '        // similar to the fallback and donate functions, the ETH cost of\n', '        // the name registration fee (0.01 ETH) will be distributed out\n', '        // to all P4D tokens holders via the updateSubdivsFor() method\n', '    }\n', '\n', '    /**\n', "     * Change your active name to a name that you've already purchased\n", '     */\n', '    function changeActiveNameTo(string memory _name)\n', '        public\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        require(_customerAddress == ownerOfName(_name));\n', '\n', '        bytes32 bytesName = stringToBytes32(_name);\n', '        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\n', '\n', '        uint256 newActiveIndex = 0;\n', '        for (uint256 i = 0; i < customerNamesInfo.registeredNames.length; i++) {\n', '            if (bytesName == customerNamesInfo.registeredNames[i]) {\n', '                newActiveIndex = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        customerNamesInfo.activeIndex = newActiveIndex;\n', '    }\n', '\n', '    /**\n', '     * Similar to changeActiveNameTo() without the need to iterate through your name list\n', '     */\n', '    function changeActiveNameIndexTo(uint256 _newActiveIndex)\n', '        public\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\n', '\n', '        require(_newActiveIndex < customerNamesInfo.registeredNames.length);\n', '        customerNamesInfo.activeIndex = _newActiveIndex;\n', '    }\n', '\n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     * The argument is not used but it allows MetaMask to render\n', "     * 'Reinvest' in your transactions list once the function sig\n", '     * is registered to the contract at;\n', '     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\n', '     */\n', '    function reinvest(bool)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        withdrawInternal(_customerAddress);\n', '\n', '        uint256 reinvestableDividends = dividendsStored_[_customerAddress];\n', '        reinvestAmount(reinvestableDividends);\n', '    }\n', '\n', '    /**\n', "     * Converts a portion of caller's dividends to tokens.\n", '     */\n', '    function reinvestAmount(uint256 _amountOfP3D)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        withdrawInternal(_customerAddress);\n', '\n', '        if (_amountOfP3D > 0 && _amountOfP3D <= dividendsStored_[_customerAddress]) {\n', '            dividendsStored_[_customerAddress] = SafeMath.sub(dividendsStored_[_customerAddress], _amountOfP3D);\n', '\n', '            // dispatch a buy order with the virtualized "withdrawn dividends"\n', '            uint256 _tokens = purchaseTokens(_customerAddress, _amountOfP3D, address(0x0));\n', '\n', '            // fire event\n', '            emit onReinvestment(_customerAddress, _amountOfP3D, _tokens);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * Converts all of caller's subdividends to tokens.\n", '     * The argument is not used but it allows MetaMask to render\n', "     * 'Reinvest Subdivs' in your transactions list once the function sig\n", '     * is registered to the contract at;\n', '     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\n', '     */\n', '    function reinvestSubdivs(bool)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        updateSubdivsFor(_customerAddress);\n', '\n', '        uint256 reinvestableSubdividends = divsMap_[_customerAddress].balance;\n', '        reinvestSubdivsAmount(reinvestableSubdividends);\n', '    }\n', '\n', '    /**\n', "     * Converts a portion of caller's subdividends to tokens.\n", '     */\n', '    function reinvestSubdivsAmount(uint256 _amountOfETH)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        updateSubdivsFor(_customerAddress);\n', '\n', '        if (_amountOfETH > 0 && _amountOfETH <= divsMap_[_customerAddress].balance) {\n', '            divsMap_[_customerAddress].balance = SafeMath.sub(divsMap_[_customerAddress].balance, _amountOfETH);\n', '            lastContractBalance_ = SafeMath.sub(lastContractBalance_, _amountOfETH);\n', '\n', '            // purchase tokens with the ETH subdividends\n', '            uint256 _tokens = purchaseInternal(_customerAddress, _amountOfETH, address(0x0));\n', '\n', '            // fire event\n', '            emit onSubdivsReinvestment(_customerAddress, _amountOfETH, _tokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Alias of sell(), withdraw() and withdrawSubdivs().\n', '     * The argument is not used but it allows MetaMask to render\n', "     * 'Exit' in your transactions list once the function sig\n", '     * is registered to the contract at;\n', '     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\n', '     */\n', '    function exit(bool)\n', '        public\n', '    {\n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if(_tokens > 0) sell(_tokens);\n', '\n', '        // lambo delivery service\n', '        withdraw(true);\n', '        withdrawSubdivs(true);\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers dividend earnings.\n', '     * The argument is not used but it allows MetaMask to render\n', "     * 'Withdraw' in your transactions list once the function sig\n", '     * is registered to the contract at;\n', '     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\n', '     */\n', '    function withdraw(bool)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        withdrawInternal(_customerAddress);\n', '\n', '        uint256 withdrawableDividends = dividendsStored_[_customerAddress];\n', '        withdrawAmount(withdrawableDividends);\n', '    }\n', '\n', '    /**\n', '     * Withdraws a portion of the callers dividend earnings.\n', '     */\n', '    function withdrawAmount(uint256 _amountOfP3D)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        withdrawInternal(_customerAddress);\n', '\n', '        if (_amountOfP3D > 0 && _amountOfP3D <= dividendsStored_[_customerAddress]) {\n', '            dividendsStored_[_customerAddress] = SafeMath.sub(dividendsStored_[_customerAddress], _amountOfP3D);\n', '            \n', '            // lambo delivery service\n', '            require(_P3D.transfer(_customerAddress, _amountOfP3D));\n', '            // NOTE!\n', '            // P3D has a 10% transfer tax so even though this is sending your entire\n', '            // dividend count to you, you will only actually receive 90%.\n', '\n', '            // fire event\n', '            emit onWithdraw(_customerAddress, _amountOfP3D);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers subdividend earnings.\n', '     * The argument is not used but it allows MetaMask to render\n', "     * 'Withdraw Subdivs' in your transactions list once the function sig\n", '     * is registered to the contract at;\n', '     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\n', '     */\n', '    function withdrawSubdivs(bool)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        updateSubdivsFor(_customerAddress);\n', '\n', '        uint256 withdrawableSubdividends = divsMap_[_customerAddress].balance;\n', '        withdrawSubdivsAmount(withdrawableSubdividends);\n', '    }\n', '\n', '    /**\n', '     * Withdraws a portion of the callers subdividend earnings.\n', '     */\n', '    function withdrawSubdivsAmount(uint256 _amountOfETH)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        updateSubdivsFor(_customerAddress);\n', '\n', '        if (_amountOfETH > 0 && _amountOfETH <= divsMap_[_customerAddress].balance) {\n', '            divsMap_[_customerAddress].balance = SafeMath.sub(divsMap_[_customerAddress].balance, _amountOfETH);\n', '            lastContractBalance_ = SafeMath.sub(lastContractBalance_, _amountOfETH);\n', '\n', '            // transfer all withdrawable subdividends\n', '            _customerAddress.transfer(_amountOfETH);\n', '\n', '            // fire event\n', '            emit onSubdivsWithdraw(_customerAddress, _amountOfETH);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Liquifies tokens to P3D.\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        updateSubdivsFor(_customerAddress);\n', '\n', '        // russian hackers BTFO\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _P3D_amount = tokensToP3D_(_tokens);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_amount, sellDividendFee_), 100);\n', '        uint256 _taxedP3D = SafeMath.sub(_P3D_amount, _dividends);\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n', '\n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens + (_taxedP3D * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply_ > 0) {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '        }\n', '\n', '        // fire events\n', '        emit onTokenSell(_customerAddress, _tokens, _taxedP3D);\n', '        emit Transfer(_customerAddress, address(0x0), _tokens);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     * REMEMBER THIS IS 0% TRANSFER FEE\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyBagholders()\n', '        public\n', '        returns(bool)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return transferInternal(_customerAddress, _toAddress, _amountOfTokens);\n', '    }\n', '\n', '    /**\n', '     * Transfer token to a specified address and forward the data to recipient\n', '     * ERC-677 standard\n', '     * https://github.com/ethereum/EIPs/issues/677\n', '     * @param _to    Receiver address.\n', '     * @param _value Amount of tokens that will be transferred.\n', '     * @param _data  Transaction metadata.\n', '     */\n', '    function transferAndCall(address _to, uint256 _value, bytes _data)\n', '        external\n', '        returns(bool)\n', '    {\n', '        require(canAcceptTokens_[_to]); // approved contracts only\n', '        require(transfer(_to, _value)); // do a normal token transfer to the contract\n', '\n', '        if (isContract(_to)) {\n', '            usingP4D receiver = usingP4D(_to);\n', '            require(receiver.tokenCallback(msg.sender, _value, _data));\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * ERC-20 token standard for transferring tokens on anothers behalf\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _amountOfTokens)\n', '        public\n', '        returns(bool)\n', '    {\n', '        require(allowed[_from][msg.sender] >= _amountOfTokens);\n', '        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _amountOfTokens);\n', '\n', '        return transferInternal(_from, _to, _amountOfTokens);\n', '    }\n', '\n', '    /**\n', '     * ERC-20 token standard for allowing another address to transfer your tokens\n', '     * on your behalf up to a certain limit\n', '     */\n', '    function approve(address _spender, uint256 _tokens)\n', '        public\n', '        returns(bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _tokens;\n', '        emit Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * ERC-20 token standard for approving and calling an external\n', '     * contract with data\n', '     */\n', '    function approveAndCall(address _to, uint256 _value, bytes _data)\n', '        external\n', '        returns(bool)\n', '    {\n', '        require(approve(_to, _value)); // do a normal approval\n', '\n', '        if (isContract(_to)) {\n', '            controllingP4D receiver = controllingP4D(_to);\n', '            require(receiver.approvalCallback(msg.sender, _value, _data));\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    /**\n', '     * In case one of us dies, we need to replace ourselves.\n', '     */\n', '    function setAdministrator(address _identifier, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '\n', '    /**\n', '     * Add a new ambassador to the exchange\n', '     */\n', '    function setAmbassador(address _identifier, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        ambassadors_[_identifier] = _status;\n', '    }\n', '\n', '    /**\n', '     * Precautionary measures in case we need to adjust the masternode rate.\n', '     */\n', '    function setStakingRequirement(uint256 _amountOfTokens)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        stakingRequirement = _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Add a sub-contract, which can accept P4D tokens\n', '     */\n', '    function setCanAcceptTokens(address _address)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        require(isContract(_address));\n', '        canAcceptTokens_[_address] = true; // one way switch\n', '    }\n', '\n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setName(string _name)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '\n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setSymbol(string _symbol)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        symbol = _symbol;\n', '    }\n', '\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current P3D tokens stored in the contract\n', '     */\n', '    function totalBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return _P3D.myTokens();\n', '    }\n', '\n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     * If `_includeReferralBonus` is set to true, the referral bonus will be included in the calculations.\n', '     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     * But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends(bool _includeReferralBonus)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return (_includeReferralBonus ? dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress) : dividendsOf(_customerAddress));\n', '    }\n', '\n', '    /**\n', '     * Retrieve the subdividend owned by the caller.\n', '     */\n', '    function myStoredDividends()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return storedDividendsOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the subdividend owned by the caller.\n', '     */\n', '    function mySubdividends()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return subdividendsOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (uint256)((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the referred dividend balance of any single address.\n', '     */\n', '    function referralDividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return referralBalance_[_customerAddress];\n', '    }\n', '\n', '    /**\n', '     * Retrieve the stored dividend balance of any single address.\n', '     */\n', '    function storedDividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return dividendsStored_[_customerAddress] + dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the subdividend balance owing of any single address.\n', '     */\n', '    function subdividendsOwing(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (divsMap_[_customerAddress].lastDividendPoints == 0 ? 0 : (balanceOf(_customerAddress) * (totalDividendPoints_ - divsMap_[_customerAddress].lastDividendPoints)) / magnitude);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the subdividend balance of any single address.\n', '     */\n', '    function subdividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return SafeMath.add(divsMap_[_customerAddress].balance, subdividendsOwing(_customerAddress));\n', '    }\n', '\n', '    /**\n', '     * Retrieve the allowance of an owner and spender.\n', '     */\n', '    function allowance(address _tokenOwner, address _spender) \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return allowed[_tokenOwner][_spender];\n', '    }\n', '\n', '    /**\n', '     * Retrieve all name information about a customer\n', '     */\n', '    function namesOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256 activeIndex, string activeName, bytes32[] customerNames)\n', '    {\n', '        NameRegistry memory customerNamesInfo = customerNameMap_[_customerAddress];\n', '\n', '        uint256 length = customerNamesInfo.registeredNames.length;\n', '        customerNames = new bytes32[](length);\n', '\n', '        for (uint256 i = 0; i < length; i++) {\n', '            customerNames[i] = customerNamesInfo.registeredNames[i];\n', '        }\n', '\n', '        activeIndex = customerNamesInfo.activeIndex;\n', '        activeName = activeNameOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieves the address of the owner from the name\n', '     */\n', '    function ownerOfName(string memory _name)\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        if (bytes(_name).length > 0) {\n', '            bytes32 bytesName = stringToBytes32(_name);\n', '            return globalNameMap_[bytesName];\n', '        } else {\n', '            return address(0x0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Retrieves the active name of a customer\n', '     */\n', '    function activeNameOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns(string)\n', '    {\n', '        NameRegistry memory customerNamesInfo = customerNameMap_[_customerAddress];\n', '        if (customerNamesInfo.registeredNames.length > 0) {\n', '            bytes32 activeBytesName = customerNamesInfo.registeredNames[customerNamesInfo.activeIndex];\n', '            return bytes32ToString(activeBytesName);\n', '        } else {\n', '            return "";\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the buy price of 1 individual token.\n', '     */\n', '    function sellPrice()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _P3D_received = tokensToP3D_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, sellDividendFee_), 100);\n', '            uint256 _taxedP3D = SafeMath.sub(_P3D_received, _dividends);\n', '\n', '            return _taxedP3D;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the sell price of 1 individual token.\n', '     */\n', '    function buyPrice()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        // our calculation relies on the token supply, so we need supply. Doh.\n', '        if(tokenSupply_ == 0){\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _P3D_received = tokensToP3D_(1e18);\n', '            uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, buyDividendFee_), 100);\n', '            uint256 _taxedP3D =  SafeMath.add(_P3D_received, _dividends);\n', '            \n', '            return _taxedP3D;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 _amountOfETH)\n', '        public\n', '        view\n', '        returns(uint256 _P3D_received, uint256 _P4D_received)\n', '    {\n', '        uint256 P3D_received = _P3D.calculateTokensReceived(_amountOfETH);\n', '\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(P3D_received, buyDividendFee_), 100);\n', '        uint256 _taxedP3D = SafeMath.sub(P3D_received, _dividends);\n', '        uint256 _amountOfTokens = P3DtoTokens_(_taxedP3D);\n', '        \n', '        return (P3D_received, _amountOfTokens);\n', '    }\n', '\n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '     */\n', '    function calculateAmountReceived(uint256 _tokensToSell)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _P3D_received = tokensToP3D_(_tokensToSell);\n', '        uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, sellDividendFee_), 100);\n', '        uint256 _taxedP3D = SafeMath.sub(_P3D_received, _dividends);\n', '        \n', '        return _taxedP3D;\n', '    }\n', '\n', '    /**\n', '    * Utility method to expose the P3D address for any child contracts to use\n', '    */\n', '    function P3D_address()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        return address(_P3D);\n', '    }\n', '\n', '    /**\n', '    * Utility method to return all of the data needed for the front end in 1 call\n', '    */\n', '    function fetchAllDataForCustomer(address _customerAddress)\n', '        public\n', '        view\n', '        returns(uint256 _totalSupply, uint256 _totalBalance, uint256 _buyPrice, uint256 _sellPrice, uint256 _activationTime,\n', '                uint256 _customerTokens, uint256 _customerUnclaimedDividends, uint256 _customerStoredDividends, uint256 _customerSubdividends)\n', '    {\n', '        _totalSupply = totalSupply();\n', '        _totalBalance = totalBalance();\n', '        _buyPrice = buyPrice();\n', '        _sellPrice = sellPrice();\n', '        _activationTime = ACTIVATION_TIME;\n', '        _customerTokens = balanceOf(_customerAddress);\n', '        _customerUnclaimedDividends = dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress);\n', '        _customerStoredDividends = storedDividendsOf(_customerAddress);\n', '        _customerSubdividends = subdividendsOf(_customerAddress);\n', '    }\n', '\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '\n', '    // This function should always be called before a customers P4D balance changes.\n', "    // It's responsible for withdrawing any outstanding ETH dividends from the P3D exchange\n", '    // as well as distrubuting all of the additional ETH balance since the last update to\n', '    // all of the P4D token holders proportionally.\n', '    // After this it will move any owed subdividends into the customers withdrawable subdividend balance.\n', '    function updateSubdivsFor(address _customerAddress)\n', '        internal\n', '    {   \n', '        // withdraw the P3D dividends first\n', '        if (_P3D.myDividends(true) > 0) {\n', '            _P3D.withdraw();\n', '        }\n', '\n', '        // check if we have additional ETH in the contract since the last update\n', '        uint256 contractBalance = address(this).balance;\n', '        if (contractBalance > lastContractBalance_ && totalSupply() != 0) {\n', '            uint256 additionalDivsFromP3D = SafeMath.sub(contractBalance, lastContractBalance_);\n', '            totalDividendPoints_ = SafeMath.add(totalDividendPoints_, SafeMath.div(SafeMath.mul(additionalDivsFromP3D, magnitude), totalSupply()));\n', '            lastContractBalance_ = contractBalance;\n', '        }\n', '\n', '        // if this is the very first time this is called for a customer, set their starting point\n', '        if (divsMap_[_customerAddress].lastDividendPoints == 0) {\n', '            divsMap_[_customerAddress].lastDividendPoints = totalDividendPoints_;\n', '        }\n', '\n', '        // move any owing subdividends into the customers subdividend balance\n', '        uint256 owing = subdividendsOwing(_customerAddress);\n', '        if (owing > 0) {\n', '            divsMap_[_customerAddress].balance = SafeMath.add(divsMap_[_customerAddress].balance, owing);\n', '            divsMap_[_customerAddress].lastDividendPoints = totalDividendPoints_;\n', '        }\n', '    }\n', '\n', '    function withdrawInternal(address _customerAddress)\n', '        internal\n', '    {\n', '        // setup data\n', '        // dividendsOf() will return only divs, not the ref. bonus\n', '        uint256 _dividends = dividendsOf(_customerAddress); // get ref. bonus later in the code\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '        // add ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // store the divs\n', '        dividendsStored_[_customerAddress] = SafeMath.add(dividendsStored_[_customerAddress], _dividends);\n', '    }\n', '\n', '    function transferInternal(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\n', '        internal\n', '        returns(bool)\n', '    {\n', '        // make sure we have the requested tokens\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        updateSubdivsFor(_customerAddress);\n', '        updateSubdivsFor(_toAddress);\n', '\n', '        // withdraw and store all outstanding dividends first (if there is any)\n', '        if ((dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress)) > 0) withdrawInternal(_customerAddress);\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\n', '\n', '        // update dividend trackers\n', '        payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _amountOfTokens);\n', '\n', '        // fire event\n', '        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n', '\n', '        // ERC20\n', '        return true;\n', '    }\n', '\n', '    function purchaseInternal(address _sender, uint256 _incomingEthereum, address _referredBy)\n', '        purchaseFilter(_sender, _incomingEthereum)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 purchaseAmount = _incomingEthereum;\n', '        uint256 excess = 0;\n', '        if (totalInputETH_ <= initialBuyLimitCap_) { // check if the total input ETH is less than the cap\n', '            if (purchaseAmount > initialBuyLimitPerTx_) { // if so check if the transaction is over the initial buy limit per transaction\n', '                purchaseAmount = initialBuyLimitPerTx_;\n', '                excess = SafeMath.sub(_incomingEthereum, purchaseAmount);\n', '            }\n', '            totalInputETH_ = SafeMath.add(totalInputETH_, purchaseAmount);\n', '        }\n', '\n', '        // return the excess if there is any\n', '        if (excess > 0) {\n', '             _sender.transfer(excess);\n', '        }\n', '\n', '        // buy P3D tokens with the entire purchase amount\n', '        // even though _P3D.buy() returns uint256, it was never implemented properly inside the P3D contract\n', '        // so in order to find out how much P3D was purchased, you need to check the balance first then compare\n', '        // the balance after the purchase and the difference will be the amount purchased\n', '        uint256 tmpBalanceBefore = _P3D.myTokens();\n', '        _P3D.buy.value(purchaseAmount)(_referredBy);\n', '        uint256 purchasedP3D = SafeMath.sub(_P3D.myTokens(), tmpBalanceBefore);\n', '\n', '        return purchaseTokens(_sender, purchasedP3D, _referredBy);\n', '    }\n', '\n', '\n', '    function purchaseTokens(address _sender, uint256 _incomingP3D, address _referredBy)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        updateSubdivsFor(_sender);\n', '\n', '        // data setup\n', '        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingP3D, buyDividendFee_), 100);\n', '        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedP3D = SafeMath.sub(_incomingP3D, _undividedDividends);\n', '        uint256 _amountOfTokens = P3DtoTokens_(_taxedP3D);\n', '        uint256 _fee = _dividends * magnitude;\n', '\n', '        // no point in continuing execution if OP is a poorfag russian hacker\n', '        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n', '        // (or hackers)\n', '        // and yes we know that the safemath function automatically rules out the "greater then" equasion.\n', '        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_));\n', '\n', '        // is the user referred by a masternode?\n', '        if (\n', '            // is this a referred purchase?\n', '            _referredBy != address(0x0) &&\n', '\n', '            // no cheating!\n', '            _referredBy != _sender &&\n', '\n', '            // does the referrer have at least X whole tokens?\n', '            // i.e is the referrer a godly chad masternode\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '            _fee = _dividends * magnitude;\n', '        }\n', '\n', "        // we can't give people infinite P3D\n", '        if(tokenSupply_ > 0){\n', '\n', '            // add tokens to the pool\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n', '\n', '            // calculate the amount of tokens the customer receives over their purchase\n', '            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n', '\n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_sender] = SafeMath.add(tokenBalanceLedger_[_sender], _amountOfTokens);\n', '\n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n", "        // really I know you think you do but you don't\n", '        payoutsTo_[_sender] += (int256)((profitPerShare_ * _amountOfTokens) - _fee);\n', '\n', '        // fire events\n', '        emit onTokenPurchase(_sender, _incomingP3D, _amountOfTokens, _referredBy);\n', '        emit Transfer(address(0x0), _sender, _amountOfTokens);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate token price based on an amount of incoming P3D\n', "     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function P3DtoTokens_(uint256 _P3D_received)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '         (\n', '            (\n', '                // underflow attempts BTFO\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial**2)\n', '                            +\n', '                            (2 * (tokenPriceIncremental_ * 1e18)*(_P3D_received * 1e18))\n', '                            +\n', '                            (((tokenPriceIncremental_)**2) * (tokenSupply_**2))\n', '                            +\n', '                            (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            ) / (tokenPriceIncremental_)\n', '        ) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * Calculate token sell value.\n', "     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokensToP3D_(uint256 _P4D_tokens)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '\n', '        uint256 tokens_ = (_P4D_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _P3D_received =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n', '                        ) - tokenPriceIncremental_\n', '                    ) * (tokens_ - 1e18)\n', '                ), (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\n', '            )\n', '        / 1e18);\n', '\n', '        return _P3D_received;\n', '    }\n', '\n', '\n', '    // This is where all your gas goes, sorry\n', '    // Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Additional check that the address we are sending tokens to is a contract\n', '     * assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '     */\n', '    function isContract(address _addr)\n', '        internal\n', '        constant\n', '        returns(bool)\n', '    {\n', '        // retrieve the size of the code on target address, this needs assembly\n', '        uint length;\n', '        assembly { length := extcodesize(_addr) }\n', '        return length > 0;\n', '    }\n', '\n', '    /**\n', '     * Utility method to help store the registered names\n', '     */\n', '    function stringToBytes32(string memory _s)\n', '        internal\n', '        pure\n', '        returns(bytes32 result)\n', '    {\n', '        bytes memory tmpEmptyStringTest = bytes(_s);\n', '        if (tmpEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly { result := mload(add(_s, 32)) }\n', '    }\n', '\n', '    /**\n', '     * Utility method to help read the registered names\n', '     */\n', '    function bytes32ToString(bytes32 _b)\n', '        internal\n', '        pure\n', '        returns(string)\n', '    {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            byte char = byte(bytes32(uint(_b) * 2 ** (8 * i)));\n', '            if (char != 0) {\n', '                bytesString[charCount++] = char;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (i = 0; i < charCount; i++) {\n', '            bytesStringTrimmed[i] = bytesString[i];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '// \n', '// pragma solidity ^0.4.25;\n', '// \n', '// interface P4D {\n', '//     function buy(address) external payable returns(uint256);\n', '//     function sell(uint256) external;\n', '//     function transfer(address, uint256) external returns(bool);\n', '//     function myTokens() external view returns(uint256);\n', '//     function myStoredDividends() external view returns(uint256);\n', '//     function mySubdividends() external view returns(uint256);\n', '//     function reinvest(bool) external;\n', '//     function reinvestSubdivs(bool) external;\n', '//     function withdraw(bool) external;\n', '//     function withdrawSubdivs(bool) external;\n', '//     function exit(bool) external; // sell + withdraw + withdrawSubdivs\n', '//     function P3D_address() external view returns(address);\n', '// }\n', '// \n', '// contract usingP4D {\n', '// \n', '//     P4D public tokenContract;\n', '// \n', '//     constructor(address _P4D_address) public {\n', '//         tokenContract = P4D(_P4D_address);\n', '//     }\n', '// \n', '//     modifier onlyTokenContract {\n', '//         require(msg.sender == address(tokenContract));\n', '//         _;\n', '//     }\n', '// \n', '//     function tokenCallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '// }\n', '// \n', '// contract YourDapp is usingP4D {\n', '// \n', '//     constructor(address _P4D_address)\n', '//         public\n', '//         usingP4D(_P4D_address)\n', '//     {\n', '//         //...\n', '//     }\n', '// \n', '//     function tokenCallback(address _from, uint256 _value, bytes _data)\n', '//         external\n', '//         onlyTokenContract\n', '//         returns (bool)\n', '//     {\n', '//         //...\n', '//         return true;\n', '//     }\n', '//\n', '//     function()\n', '//         payable\n', '//         public\n', '//     {\n', '//         if (msg.sender != address(tokenContract)) {\n', '//             //...\n', '//         }\n', '//     }\n', '// }\n', '//\n', '/*===========================================================================================*\n', '*************************************** https://p4d.io ***************************************\n', '*===========================================================================================*/']