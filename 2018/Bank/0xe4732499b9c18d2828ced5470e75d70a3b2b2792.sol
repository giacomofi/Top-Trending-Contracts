['pragma solidity ^0.4.21;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract owned {\n', '    address public owner;\n', '    bool public ownershipTransferAllowed = false;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function allowTransferOwnership(bool flag ) public onlyOwner {\n', '      ownershipTransferAllowed = flag;\n', '    }\n', ' \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require( newOwner != 0x0 );                                             // not to 0x0\n', '        require( ownershipTransferAllowed );                                 \n', '        owner = newOwner;\n', '        ownershipTransferAllowed = false;\n', '    }\n', '}\n', '\n', 'contract ECR20HoneycombToken is owned {\n', '    // Public variables of the token\n', '    string public name = "Honeycomb";\n', '    string public symbol = "COMB";\n', '    uint8 public decimals = 18;\n', '    \n', '    // used for buyPrice\n', '    uint256 private tokenFactor = 10 ** uint256(decimals);\n', '    uint256 private initialBuyPrice = 3141592650000000000000;                   // PI Token per Finney\n', '    uint256 private buyConst1 = 10000 * tokenFactor;                            // Faktor for buy price calculation\n', '    uint256 private buyConst2 = 4;                                              // Faktor for buy price calculation\n', '    \n', '    uint256 public minimumPayout = 1000000000000000;\t\t\t\t\t\t\t// minimal payout initially to 0.001 ether\n', '       \n', '    uint256 public totalSupply;                                                 // total number of issued tokent\n', '\n', '\t// price token are sold/bought\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    constructor() public {\n', '        totalSupply = 1048576 * tokenFactor;                                    // token total created\n', '        balanceOf[msg.sender] = totalSupply;                                    // Give the creator all initial tokens\n', '        owner = msg.sender;\t\t\t                                            // assign ownership of contract to initial coin holder\n', '        emit Transfer(0, owner, totalSupply);                                   // notify event owner\n', '        _transfer(owner, this, totalSupply - (16384*tokenFactor));              // transfer token to contract\n', '        _setPrices(_newPrice(balanceOf[this]));                                 // set prices according to token left\n', '    }\n', '    /**\n', '     * Calculate new price based on a new token left\n', '     * \n', '     * @param tokenLeft new token left on contract after transaction\n', '    **/\n', '    function _newPrice(uint256 tokenLeft) internal view returns (uint256 newPrice) {\n', '        newPrice = initialBuyPrice \n', '            * ( tokenLeft * buyConst1 )\n', '            / ( totalSupply*buyConst1 + totalSupply*tokenLeft/buyConst2 - tokenLeft*tokenLeft/buyConst2 ); \n', '        return newPrice;\n', '    }\n', '\n', '    function _setPrices(uint256 newPrice) internal {\n', '        buyPrice = newPrice;\n', '        sellPrice = buyPrice * 141421356 / 100000000;                           // sellPrice is sqrt(2) higher\n', '    }\n', '\n', '\t/**\n', '\t * Called when token are bought by sending ether\n', '\t * \n', '\t * @return amount amount of token bought\n', '\t **/\n', '\tfunction buy() payable public returns (uint256 amountToken){\n', '        amountToken = msg.value * buyPrice / tokenFactor;                       // calculates the amount of token\n', '        uint256 newPrice = _newPrice(balanceOf[this] - amountToken);            // calc new price after transfer\n', '        require( (2*newPrice) > sellPrice);                                     // check whether new price is not lower than sqrt(2) of old one\n', '        _transfer(this, msg.sender, amountToken);                               // transfer token from contract to buyer\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '        return amountToken;\n', '    }\n', '\n', '    /**\n', '      Fallback function\n', '    **/\n', '\tfunction () payable public {\n', '\t    buy();\n', '    }\n', '\n', '    /**\n', '     * Sell token back to contract\n', '     * \n', '     * @param amountToken The amount of token in wei \n', '     * \n', '     * @return eth to receive in wei\n', '     **/\n', '    function sell(uint256 amountToken) public returns (uint256 revenue){\n', '        revenue = amountToken * tokenFactor / sellPrice;                        // calulate the revenue in Wei\n', '        require( revenue >= minimumPayout );\t\t\t\t\t\t\t\t\t// check whether selling get more ether than the minimum payout\n', '        uint256 newPrice = _newPrice(balanceOf[this] + amountToken);            // calc new price after transfer\n', '        require( newPrice < sellPrice );                                        // check whether new price is more than sell price\n', '        _transfer(msg.sender, this, amountToken);                               // transfer token back to contract\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '        msg.sender.transfer(revenue);                                           // send ether to seller\n', '        return revenue;\n', '    }\n', '\t\t\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        if ( _to  == address(this) )\n', '        {\n', '          sell(_value);                                                         // sending token to a contract means selling them\n', '        }\n', '        else\n', '        {\n', '          _transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\t/**\n', '     * set minimumPayout price\n', '     * \n', '     * @param amount minimumPayout amount in Wei\n', '     */\n', '\t\tfunction setMinimumPayout(uint256 amount) public onlyOwner {\n', '\t\tminimumPayout = amount;\n', '    }\n', '\t\t\n', '\t/**\n', '     * save ether to owner account\n', '     * \n', '     * @param amount amount in Wei\n', '     */\n', '\t\tfunction save(uint256 amount) public onlyOwner {\n', '        require( amount >= minimumPayout );\t\n', '        owner.transfer( amount);\n', '    }\n', '\t\t\n', '\t/**\n', '     * Give back token to contract bypassing selling from owner account\n', '     * \n', '     * @param amount amount of token in wei\n', '     */\n', '\t\tfunction restore(uint256 amount) public onlyOwner {\n', '        uint256 newPrice = _newPrice(balanceOf[this] + amount);                 // calc new price after transfer\n', '        _transfer(owner, this, amount );                                        // transfer token back to contract\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '    }\n', '\t\t\n', '\t/**\n', '     * Internal transfer, can be called only by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract owned {\n', '    address public owner;\n', '    bool public ownershipTransferAllowed = false;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function allowTransferOwnership(bool flag ) public onlyOwner {\n', '      ownershipTransferAllowed = flag;\n', '    }\n', ' \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require( newOwner != 0x0 );                                             // not to 0x0\n', '        require( ownershipTransferAllowed );                                 \n', '        owner = newOwner;\n', '        ownershipTransferAllowed = false;\n', '    }\n', '}\n', '\n', 'contract ECR20HoneycombToken is owned {\n', '    // Public variables of the token\n', '    string public name = "Honeycomb";\n', '    string public symbol = "COMB";\n', '    uint8 public decimals = 18;\n', '    \n', '    // used for buyPrice\n', '    uint256 private tokenFactor = 10 ** uint256(decimals);\n', '    uint256 private initialBuyPrice = 3141592650000000000000;                   // PI Token per Finney\n', '    uint256 private buyConst1 = 10000 * tokenFactor;                            // Faktor for buy price calculation\n', '    uint256 private buyConst2 = 4;                                              // Faktor for buy price calculation\n', '    \n', '    uint256 public minimumPayout = 1000000000000000;\t\t\t\t\t\t\t// minimal payout initially to 0.001 ether\n', '       \n', '    uint256 public totalSupply;                                                 // total number of issued tokent\n', '\n', '\t// price token are sold/bought\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    constructor() public {\n', '        totalSupply = 1048576 * tokenFactor;                                    // token total created\n', '        balanceOf[msg.sender] = totalSupply;                                    // Give the creator all initial tokens\n', '        owner = msg.sender;\t\t\t                                            // assign ownership of contract to initial coin holder\n', '        emit Transfer(0, owner, totalSupply);                                   // notify event owner\n', '        _transfer(owner, this, totalSupply - (16384*tokenFactor));              // transfer token to contract\n', '        _setPrices(_newPrice(balanceOf[this]));                                 // set prices according to token left\n', '    }\n', '    /**\n', '     * Calculate new price based on a new token left\n', '     * \n', '     * @param tokenLeft new token left on contract after transaction\n', '    **/\n', '    function _newPrice(uint256 tokenLeft) internal view returns (uint256 newPrice) {\n', '        newPrice = initialBuyPrice \n', '            * ( tokenLeft * buyConst1 )\n', '            / ( totalSupply*buyConst1 + totalSupply*tokenLeft/buyConst2 - tokenLeft*tokenLeft/buyConst2 ); \n', '        return newPrice;\n', '    }\n', '\n', '    function _setPrices(uint256 newPrice) internal {\n', '        buyPrice = newPrice;\n', '        sellPrice = buyPrice * 141421356 / 100000000;                           // sellPrice is sqrt(2) higher\n', '    }\n', '\n', '\t/**\n', '\t * Called when token are bought by sending ether\n', '\t * \n', '\t * @return amount amount of token bought\n', '\t **/\n', '\tfunction buy() payable public returns (uint256 amountToken){\n', '        amountToken = msg.value * buyPrice / tokenFactor;                       // calculates the amount of token\n', '        uint256 newPrice = _newPrice(balanceOf[this] - amountToken);            // calc new price after transfer\n', '        require( (2*newPrice) > sellPrice);                                     // check whether new price is not lower than sqrt(2) of old one\n', '        _transfer(this, msg.sender, amountToken);                               // transfer token from contract to buyer\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '        return amountToken;\n', '    }\n', '\n', '    /**\n', '      Fallback function\n', '    **/\n', '\tfunction () payable public {\n', '\t    buy();\n', '    }\n', '\n', '    /**\n', '     * Sell token back to contract\n', '     * \n', '     * @param amountToken The amount of token in wei \n', '     * \n', '     * @return eth to receive in wei\n', '     **/\n', '    function sell(uint256 amountToken) public returns (uint256 revenue){\n', '        revenue = amountToken * tokenFactor / sellPrice;                        // calulate the revenue in Wei\n', '        require( revenue >= minimumPayout );\t\t\t\t\t\t\t\t\t// check whether selling get more ether than the minimum payout\n', '        uint256 newPrice = _newPrice(balanceOf[this] + amountToken);            // calc new price after transfer\n', '        require( newPrice < sellPrice );                                        // check whether new price is more than sell price\n', '        _transfer(msg.sender, this, amountToken);                               // transfer token back to contract\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '        msg.sender.transfer(revenue);                                           // send ether to seller\n', '        return revenue;\n', '    }\n', '\t\t\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        if ( _to  == address(this) )\n', '        {\n', '          sell(_value);                                                         // sending token to a contract means selling them\n', '        }\n', '        else\n', '        {\n', '          _transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\t/**\n', '     * set minimumPayout price\n', '     * \n', '     * @param amount minimumPayout amount in Wei\n', '     */\n', '\t\tfunction setMinimumPayout(uint256 amount) public onlyOwner {\n', '\t\tminimumPayout = amount;\n', '    }\n', '\t\t\n', '\t/**\n', '     * save ether to owner account\n', '     * \n', '     * @param amount amount in Wei\n', '     */\n', '\t\tfunction save(uint256 amount) public onlyOwner {\n', '        require( amount >= minimumPayout );\t\n', '        owner.transfer( amount);\n', '    }\n', '\t\t\n', '\t/**\n', '     * Give back token to contract bypassing selling from owner account\n', '     * \n', '     * @param amount amount of token in wei\n', '     */\n', '\t\tfunction restore(uint256 amount) public onlyOwner {\n', '        uint256 newPrice = _newPrice(balanceOf[this] + amount);                 // calc new price after transfer\n', '        _transfer(owner, this, amount );                                        // transfer token back to contract\n', '        _setPrices( newPrice );                                                 // update prices after transfer\n', '    }\n', '\t\t\n', '\t/**\n', '     * Internal transfer, can be called only by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '}']
