['pragma solidity ^0.4.21;\n', '\n', '// Dev fee payout contract + dividend options \n', '// EtherGuy DApp fee will be stored here \n', '// Buying any token gives right to claim \n', '// UI: etherguy.surge.sh/dividend.html\n', '// Made by EtherGuy, <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8de8f9e5e8ffeaf8f4cde0ece4e1a3eee2e0">[email&#160;protected]</a> \n', '\n', '// IF THERE IS ANY BUG the data will be rerolled from here. See the discord https://discord.gg/R84hD6f if anything happens or mail me \n', '\n', '\n', 'contract Dividends{\n', '    // 10 million token supply \n', '    uint256 constant TokenSupply = 10000000;\n', '    \n', '    uint256 public TotalPaid = 0;\n', '    \n', '    uint16 public Tax = 1250; \n', '    \n', '    address dev;\n', '    \n', '    mapping (address => uint256) public MyTokens;\n', '    mapping (address => uint256) public DividendCollectSince;\n', '    \n', '    // TKNS / PRICE \n', '    mapping(address => uint256[2]) public SellOrder;\n', '    \n', '    // web \n', '    // returns tokens + price (in wei)\n', '    function GetSellOrderDetails(address who) public view returns (uint256, uint256){\n', '        return (SellOrder[who][0], SellOrder[who][1]);\n', '    }\n', '    \n', '    function ViewMyTokens(address who) public view returns (uint256){\n', '        return MyTokens[who];\n', '    }\n', '    \n', '    function ViewMyDivs(address who) public view returns (uint256){\n', '        uint256 tkns = MyTokens[who];\n', '        if (tkns==0){\n', '            return 0;\n', '        }\n', '        return (GetDividends(who, tkns));\n', '    }\n', '    \n', '    function Bal() public view returns (uint256){\n', '        return (address(this).balance);\n', '    }\n', '    \n', '    // >MINT IT\n', '    function Dividends() public {\n', '        dev = msg.sender;\n', '        // EG\n', '        MyTokens[msg.sender] = TokenSupply - 400000;\n', '        // HE\n', '        MyTokens[address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285)] = 200000;\n', '        // PG\n', '        MyTokens[address(0x26581d1983ced8955C170eB4d3222DCd3845a092)] = 200000;\n', '        //MyTokens[address(0x0)] = 400000;\n', '        PlaceSellOrder(1600000, (0.5 szabo)); // 1 token per 0.5 szabo / 500 gwei or 1000 tokens per 0.5 finney / 0.0005 ether or 1M tokens per 0.5 ETH \n', '    }\n', '    \n', '    function GetDividends(address who, uint256 TokenAmount) internal view  returns(uint256){\n', '        if (TokenAmount == 0){\n', '            return 0;\n', '        }\n', '        uint256 TotalContractIn = address(this).balance + TotalPaid;\n', '        // division rounds DOWN so we never pay too much\n', '        // no revert errors due to this. \n', '        \n', '        uint256 MyBalance = sub(TotalContractIn, DividendCollectSince[who]);\n', '        \n', '        return  ((MyBalance * TokenAmount) / (TokenSupply));\n', '    }\n', '    \n', '\n', '    event Sold(address Buyer, address Seller, uint256 price, uint256 tokens);\n', '    function Buy(address who) public payable {\n', '       // require(msg.value >= (1 szabo)); // normal amounts pls \n', '        // lookup order by addr \n', '        uint256[2] memory order = SellOrder[who];\n', '        uint256 amt_available = order[0];\n', '        uint256 price = order[1];\n', '        \n', '        uint256 excess = 0;\n', '        \n', '        // nothing to sell \n', '        if (amt_available == 0){\n', '            revert();\n', '        }\n', '        \n', '        uint256 max = amt_available * price; \n', '        uint256 currval = msg.value;\n', '        // more than max buy value \n', '        if (currval > max){\n', '            excess = (currval-max);\n', '            currval = max;\n', '        }\n', '        \n', '\n', '\n', '\n', '        uint256 take = currval / price;\n', '        \n', '        if (take == 0){\n', '            revert(); // very high price apparently \n', '        }\n', '        excess = excess + sub(currval, take * price); \n', '\n', '        \n', '        if (excess > 0){\n', '            msg.sender.transfer(excess);\n', '        }\n', '        \n', '        currval = sub(currval,excess);\n', '        \n', '        // pay fees \n', '\n', '        uint256 fee = (Tax * currval)/10000;\n', '        dev.transfer(fee);\n', '        who.transfer(currval-fee);\n', '        \n', '        // the person with these tokens will also receive dividend over this buy order (this.balance)\n', '        // however the excess is removed, see the excess transfer above \n', '     //   if (msg.value > (excess+currval+fee)){\n', '      //      msg.sender.transfer(msg.value-excess-currval-fee);\n', '     //   }\n', '        _withdraw(who, MyTokens[who]);\n', '        if (MyTokens[msg.sender] > 0){\n', '            \n', '            _withdraw(msg.sender, MyTokens[msg.sender]);\n', '        }\n', '        MyTokens[who] = MyTokens[who] - take; \n', '        SellOrder[who][0] = SellOrder[who][0]-take; \n', '        MyTokens[msg.sender] = MyTokens[msg.sender] + take;\n', '    //    MyPayouts[msg.sender] = MyPayouts[msg.sender] + GetDividends(msg.sender, take);\n', '        DividendCollectSince[msg.sender] = (address(this).balance) + TotalPaid;\n', '        \n', '        emit Sold(msg.sender, who, price, take);\n', '       // push((excess + currval)/(1 finney), (msg.value)/(1 finney));\n', '    }\n', '    \n', '    function Withdraw() public {\n', '        _withdraw(msg.sender, MyTokens[msg.sender]);\n', '    }\n', '    \n', '    function _withdraw(address who, uint256 amt) internal{\n', '        // withdraws from amt. \n', '        // (amt not used in current code, always same value)\n', '        if (MyTokens[who] < amt){\n', '            revert(); // ??? security check \n', '        }\n', '        \n', '        uint256 divs = GetDividends(who, amt);\n', '        \n', '        who.transfer(divs);\n', '        TotalPaid = TotalPaid + divs;\n', '        \n', '        DividendCollectSince[who] = TotalPaid + address(this).balance;\n', '    }\n', '    \n', '    event SellOrderPlaced(address who, uint256 amt, uint256 price);\n', '    function PlaceSellOrder(uint256 amt, uint256 price) public {\n', '        // replaces old order \n', '        if (amt > MyTokens[msg.sender]){\n', '            revert(); // ?? more sell than you got \n', '        }\n', '        SellOrder[msg.sender] = [amt,price];\n', '        emit SellOrderPlaced(msg.sender, amt, price);\n', '    }\n', '    \n', '    function ChangeTax(uint16 amt) public {\n', '        require (amt <= 2500);\n', '        require(msg.sender == dev);\n', '        Tax=amt;\n', '    }\n', '    \n', '    \n', '    // dump divs in contract \n', '    function() public payable {\n', '        \n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    } \n', '    \n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// Dev fee payout contract + dividend options \n', '// EtherGuy DApp fee will be stored here \n', '// Buying any token gives right to claim \n', '// UI: etherguy.surge.sh/dividend.html\n', '// Made by EtherGuy, etherguy@mail.com \n', '\n', '// IF THERE IS ANY BUG the data will be rerolled from here. See the discord https://discord.gg/R84hD6f if anything happens or mail me \n', '\n', '\n', 'contract Dividends{\n', '    // 10 million token supply \n', '    uint256 constant TokenSupply = 10000000;\n', '    \n', '    uint256 public TotalPaid = 0;\n', '    \n', '    uint16 public Tax = 1250; \n', '    \n', '    address dev;\n', '    \n', '    mapping (address => uint256) public MyTokens;\n', '    mapping (address => uint256) public DividendCollectSince;\n', '    \n', '    // TKNS / PRICE \n', '    mapping(address => uint256[2]) public SellOrder;\n', '    \n', '    // web \n', '    // returns tokens + price (in wei)\n', '    function GetSellOrderDetails(address who) public view returns (uint256, uint256){\n', '        return (SellOrder[who][0], SellOrder[who][1]);\n', '    }\n', '    \n', '    function ViewMyTokens(address who) public view returns (uint256){\n', '        return MyTokens[who];\n', '    }\n', '    \n', '    function ViewMyDivs(address who) public view returns (uint256){\n', '        uint256 tkns = MyTokens[who];\n', '        if (tkns==0){\n', '            return 0;\n', '        }\n', '        return (GetDividends(who, tkns));\n', '    }\n', '    \n', '    function Bal() public view returns (uint256){\n', '        return (address(this).balance);\n', '    }\n', '    \n', '    // >MINT IT\n', '    function Dividends() public {\n', '        dev = msg.sender;\n', '        // EG\n', '        MyTokens[msg.sender] = TokenSupply - 400000;\n', '        // HE\n', '        MyTokens[address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285)] = 200000;\n', '        // PG\n', '        MyTokens[address(0x26581d1983ced8955C170eB4d3222DCd3845a092)] = 200000;\n', '        //MyTokens[address(0x0)] = 400000;\n', '        PlaceSellOrder(1600000, (0.5 szabo)); // 1 token per 0.5 szabo / 500 gwei or 1000 tokens per 0.5 finney / 0.0005 ether or 1M tokens per 0.5 ETH \n', '    }\n', '    \n', '    function GetDividends(address who, uint256 TokenAmount) internal view  returns(uint256){\n', '        if (TokenAmount == 0){\n', '            return 0;\n', '        }\n', '        uint256 TotalContractIn = address(this).balance + TotalPaid;\n', '        // division rounds DOWN so we never pay too much\n', '        // no revert errors due to this. \n', '        \n', '        uint256 MyBalance = sub(TotalContractIn, DividendCollectSince[who]);\n', '        \n', '        return  ((MyBalance * TokenAmount) / (TokenSupply));\n', '    }\n', '    \n', '\n', '    event Sold(address Buyer, address Seller, uint256 price, uint256 tokens);\n', '    function Buy(address who) public payable {\n', '       // require(msg.value >= (1 szabo)); // normal amounts pls \n', '        // lookup order by addr \n', '        uint256[2] memory order = SellOrder[who];\n', '        uint256 amt_available = order[0];\n', '        uint256 price = order[1];\n', '        \n', '        uint256 excess = 0;\n', '        \n', '        // nothing to sell \n', '        if (amt_available == 0){\n', '            revert();\n', '        }\n', '        \n', '        uint256 max = amt_available * price; \n', '        uint256 currval = msg.value;\n', '        // more than max buy value \n', '        if (currval > max){\n', '            excess = (currval-max);\n', '            currval = max;\n', '        }\n', '        \n', '\n', '\n', '\n', '        uint256 take = currval / price;\n', '        \n', '        if (take == 0){\n', '            revert(); // very high price apparently \n', '        }\n', '        excess = excess + sub(currval, take * price); \n', '\n', '        \n', '        if (excess > 0){\n', '            msg.sender.transfer(excess);\n', '        }\n', '        \n', '        currval = sub(currval,excess);\n', '        \n', '        // pay fees \n', '\n', '        uint256 fee = (Tax * currval)/10000;\n', '        dev.transfer(fee);\n', '        who.transfer(currval-fee);\n', '        \n', '        // the person with these tokens will also receive dividend over this buy order (this.balance)\n', '        // however the excess is removed, see the excess transfer above \n', '     //   if (msg.value > (excess+currval+fee)){\n', '      //      msg.sender.transfer(msg.value-excess-currval-fee);\n', '     //   }\n', '        _withdraw(who, MyTokens[who]);\n', '        if (MyTokens[msg.sender] > 0){\n', '            \n', '            _withdraw(msg.sender, MyTokens[msg.sender]);\n', '        }\n', '        MyTokens[who] = MyTokens[who] - take; \n', '        SellOrder[who][0] = SellOrder[who][0]-take; \n', '        MyTokens[msg.sender] = MyTokens[msg.sender] + take;\n', '    //    MyPayouts[msg.sender] = MyPayouts[msg.sender] + GetDividends(msg.sender, take);\n', '        DividendCollectSince[msg.sender] = (address(this).balance) + TotalPaid;\n', '        \n', '        emit Sold(msg.sender, who, price, take);\n', '       // push((excess + currval)/(1 finney), (msg.value)/(1 finney));\n', '    }\n', '    \n', '    function Withdraw() public {\n', '        _withdraw(msg.sender, MyTokens[msg.sender]);\n', '    }\n', '    \n', '    function _withdraw(address who, uint256 amt) internal{\n', '        // withdraws from amt. \n', '        // (amt not used in current code, always same value)\n', '        if (MyTokens[who] < amt){\n', '            revert(); // ??? security check \n', '        }\n', '        \n', '        uint256 divs = GetDividends(who, amt);\n', '        \n', '        who.transfer(divs);\n', '        TotalPaid = TotalPaid + divs;\n', '        \n', '        DividendCollectSince[who] = TotalPaid + address(this).balance;\n', '    }\n', '    \n', '    event SellOrderPlaced(address who, uint256 amt, uint256 price);\n', '    function PlaceSellOrder(uint256 amt, uint256 price) public {\n', '        // replaces old order \n', '        if (amt > MyTokens[msg.sender]){\n', '            revert(); // ?? more sell than you got \n', '        }\n', '        SellOrder[msg.sender] = [amt,price];\n', '        emit SellOrderPlaced(msg.sender, amt, price);\n', '    }\n', '    \n', '    function ChangeTax(uint16 amt) public {\n', '        require (amt <= 2500);\n', '        require(msg.sender == dev);\n', '        Tax=amt;\n', '    }\n', '    \n', '    \n', '    // dump divs in contract \n', '    function() public payable {\n', '        \n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    } \n', '    \n', '}']
