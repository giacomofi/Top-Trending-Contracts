['pragma solidity ^0.4.25;\n', '// Original gameplay and contract by Spielley\n', '// Spielley is not liable for any bugs or exploits the contract may contain\n', '// This game is purely intended for fun purposes\n', '\n', '// Gameplay:\n', '// Send in 0.1 eth to get a soldier in the field and 1 bullet\n', '// Wait till you reach the waiting time needed to shoot\n', '// Each time someone is killed divs are given to the survivors\n', '// 2 ways to shoot: \n', '// semi random, available first (after 200 blocks)\n', '// Chose target                 (after 800 blocks)\n', '\n', '// there is only a 1 time self kill prevention when semi is used\n', '// if you send in multiple soldiers friendly kills are possible\n', '// => use target instead\n', '\n', '// Social gameplay: Chat with people and Coordinate your shots \n', '// if you want to risk not getting shot by semi bullets first\n', '\n', '// you keep your bullets when you send in new soldiers\n', '\n', '// if your soldier dies your address is added to the back of the refund line\n', '// to get back your initial eth\n', '\n', '// payout structure per 0.1 eth:\n', '// 0.005 eth buy P3D\n', '// 0.005 eth goes to the refund line\n', '// 0.001 eth goes dev cut shared across SPASM(Spielleys profit share aloocation module)\n', '// 0.001 eth goes to referal\n', '// 0.088 eth is given to survivors upon kill\n', '\n', '// P3D divs: \n', '// 1% to SPASM\n', '// 99% to refund line\n', '\n', '// SPASM: get a part of the dev fee payouts and funds Spielley to go fulltime dev\n', '// https://etherscan.io/address/0xfaae60f2ce6491886c9f7c9356bd92f688ca66a1#writeContract\n', '// => buyshares function , send in eth to get shares\n', '\n', '// P3D MN payouts for UI devs\n', '// payout per 0.1 eth sent in the sendInSoldier function\n', '\n', '// **to prevent exploit spot 0 can be targeted by chosing nextFormation number**\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n', '       \n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '// Snip3d contract\n', 'contract Snip3D is  Owned {\n', '    using SafeMath for uint;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint256)public  balances;// soldiers on field\n', '    mapping(address => uint256)public  bullets;// amount of bullets Owned\n', '    mapping(address => uint256)public  playerVault;// amount of bullets Owned\n', '    mapping(uint256 => address)public  formation;// the playing field\n', '    uint256 public nextFormation;// next spot in formation\n', '    mapping(address => uint256)public lastMove;//blocknumber lastMove\n', '    mapping(uint256 => address) public RefundWaitingLine;\n', '    uint256 public  NextInLine;//next person to be refunded\n', '    uint256 public  NextAtLineEnd;//next spot to add loser\n', '    uint256 public Refundpot;\n', '    uint256 public blocksBeforeSemiRandomShoot = 200;\n', '    uint256 public blocksBeforeTargetShoot = 800;\n', '    uint256 public NextInLineOld;\n', '    uint256 public lastToPayOld;\n', '    \n', '    // events\n', '    event death(address indexed player , uint256 indexed formation);\n', '    event semiShot(address indexed player);\n', '    event targetShot(address indexed player);\n', '    event newSoldiers(address indexed player , uint256 indexed amount, uint256 indexed formation);\n', '    //constructor\n', '    constructor()\n', '        public\n', '    {\n', '        NextInLineOld = old.NextInLine();\n', '        lastToPayOld = 2784;\n', '        \n', '    }\n', '    //mods\n', '    modifier isAlive()\n', '    {\n', '        require(balances[msg.sender] > 0);\n', '        _;\n', '    }\n', '    // divfunctions\n', '    // interface setup\n', 'HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', 'SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n', 'Snip3dInterface public old = Snip3dInterface(0x6D534b48835701312ebc904d4b37e54D4f7D039f);\n', '// view functions\n', 'function harvestabledivs()\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return (P3Dcontract_.myDividends(true))  ;\n', '    }\n', '    function nextonetogetpaid()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        \n', '        return (RefundWaitingLine[NextInLine]);\n', '    }\n', '    function playervanity(address theplayer)\n', '        public\n', '        view\n', '        returns( string )\n', '    {\n', '        return (Vanity[theplayer]);\n', '    }\n', '    function blocksTillSemiShoot(address theplayer)\n', '        public\n', '        view\n', '        returns( uint256 )\n', '    {\n', '        uint256 number;\n', '        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n', '        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n', '        return (number);\n', '    }\n', '    function blocksTillTargetShoot(address theplayer)\n', '        public\n', '        view\n', '        returns( uint256 )\n', '    {\n', '        uint256 number;\n', '        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n', '        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n', '        return (number);\n', '    }\n', 'function amountofp3d() external view returns(uint256){\n', '    return ( P3Dcontract_.balanceOf(address(this)))  ;\n', '}\n', '    //divsection\n', 'uint256 public pointMultiplier = 10e18;\n', 'struct Account {\n', '  uint balance;\n', '  uint lastDividendPoints;\n', '}\n', 'mapping(address=>Account) accounts;\n', 'mapping(address => string) public Vanity;\n', 'uint public ethtotalSupply;\n', 'uint public totalDividendPoints;\n', 'uint public unclaimedDividends;\n', '\n', 'function dividendsOwing(address account) public view returns(uint256) {\n', '  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n', '  return (balances[account] * newDividendPoints) / pointMultiplier;\n', '}\n', 'modifier updateAccount(address account) {\n', '  uint256 owing = dividendsOwing(account);\n', '  if(owing > 0) {\n', '    unclaimedDividends = unclaimedDividends.sub(owing);\n', '    \n', '    playerVault[account] = playerVault[account].add(owing);\n', '  }\n', '  accounts[account].lastDividendPoints = totalDividendPoints;\n', '  _;\n', '}\n', 'function () external payable{}\n', 'function fetchdivs(address toupdate) public updateAccount(toupdate){}\n', '// Gamefunctions\n', 'function sendInSoldier(address masternode, uint256 amount) public updateAccount(msg.sender)  payable{\n', '    uint256 value = msg.value;\n', '    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\n', '    address sender = msg.sender;\n', '    // add life\n', '    balances[sender]=  balances[sender].add(amount);\n', '    // update totalSupply\n', '    _totalSupply= _totalSupply.add(amount);\n', '    // add 2 bullet per soldier\n', '    bullets[sender] = bullets[sender].add(amount).add(amount);\n', '    // add to playing field\n', '    for(uint i=0; i< amount; i++)\n', '        {\n', '            uint256 spot = nextFormation.add(i);\n', '            formation[spot] = sender;\n', '        }\n', '    nextFormation += i;\n', '    // reset lastMove to prevent people from adding bullets and start shooting\n', '    lastMove[sender] = block.number;\n', '    // buy P3D\n', '    uint256 buyamount = amount.mul( 5 finney);\n', '    P3Dcontract_.buy.value(buyamount)(masternode);\n', '    // check excess of payed \n', '     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\n', '    // progress refundline\n', '    Refundpot += amount.mul(5 finney);\n', '    // send SPASM cut\n', '    uint256 spasmamount = amount.mul(2 finney);\n', '    SPASM_.disburse.value(spasmamount)();\n', '    emit newSoldiers(sender, amount, nextFormation);\n', '\n', '}\n', 'function sendInSoldierReferal(address masternode, address referal, uint256 amount) public updateAccount(msg.sender)  payable{\n', '    uint256 value = msg.value;\n', '    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\n', '    address sender = msg.sender;\n', '   // add life\n', '    balances[sender]=  balances[sender].add(amount);\n', '    // update totalSupply\n', '    _totalSupply= _totalSupply.add(amount);\n', '    // add 2 bullet per soldier\n', '    bullets[sender] = bullets[sender].add(amount).add(amount);\n', '    // add to playing field\n', '    for(uint i=0; i< amount; i++)\n', '        {\n', '            uint256 spot = nextFormation.add(i);\n', '            formation[spot] = sender;\n', '        }\n', '    nextFormation += i;\n', '    // reset lastMove to prevent people from adding bullets and start shooting\n', '    lastMove[sender] = block.number;\n', '    // buy P3D\n', '    uint256 buyamount = amount.mul( 5 finney);\n', '    P3Dcontract_.buy.value(buyamount)(masternode);\n', '    // check excess of payed \n', '     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\n', '    // progress refundline\n', '    Refundpot += amount.mul(5 finney);\n', '    // send SPASM cut\n', '    uint256 spasmamount = amount.mul(1 finney);\n', '    SPASM_.disburse.value(spasmamount)();\n', '    // send referal cut\n', '    playerVault[referal] = playerVault[referal].add(amount.mul(1 finney));\n', '    emit newSoldiers(sender, amount, nextFormation);\n', '\n', '}\n', 'function shootSemiRandom() public isAlive() {\n', '    address sender = msg.sender;\n', '    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n', '    require(bullets[sender] > 0);\n', '    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n', '    \n', '    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n', '    address killed = formation[shot];\n', '    // solo soldiers self kill prevention - shoots next in line instead\n', '    if(sender == killed)\n', '    {\n', '        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n', '        killed = formation[shot];\n', '    }\n', '    // update divs loser\n', '    fetchdivs(killed);\n', '    // remove life\n', '    balances[killed]--;\n', '    // update totalSupply\n', '    _totalSupply--;\n', '    // remove bullet \n', '    bullets[sender]--;\n', '    // remove from playing field\n', '    uint256 lastEntry = nextFormation.sub(1);\n', '    formation[shot] = formation[lastEntry];\n', '    nextFormation--;\n', '    // reset lastMove to prevent people from adding bullets and start shooting\n', '    lastMove[sender] = block.number;\n', '    \n', '    \n', '    // add loser to refundline\n', '    fetchdivsRefund(killed);\n', '    balancesRefund[killed] += 0.1 ether;\n', '   \n', '    // disburse eth to survivors\n', '    uint256 amount = 88 finney;\n', '    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n', '    unclaimedDividends = unclaimedDividends.add(amount);\n', '    emit semiShot(sender);\n', '    emit death(killed, shot);\n', '\n', '}\n', 'function shootTarget(uint256 target) public isAlive() {\n', '    address sender = msg.sender;\n', '    require(target <= nextFormation && target > 0);\n', '    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n', '    require(bullets[sender] > 0);\n', '    if(target == nextFormation){target = 0;}\n', '    address killed = formation[target];\n', '    \n', '    // update divs loser\n', '    fetchdivs(killed);\n', '    \n', '    // remove life\n', '    balances[killed]--;\n', '    // update totalSupply\n', '    _totalSupply--;\n', '    // remove bullet \n', '    bullets[sender]--;\n', '    // remove from playing field\n', '    uint256 lastEntry = nextFormation.sub(1);\n', '    formation[target] = formation[lastEntry];\n', '    nextFormation--;\n', '    // reset lastMove to prevent people from adding bullets and start shooting\n', '    lastMove[sender] = block.number;\n', '    \n', '    // add loser to refundline\n', '    fetchdivsRefund(killed);\n', '    balancesRefund[killed] += 0.1 ether;\n', '    // fetch contracts divs\n', '    \n', '    // disburse eth to survivors\n', '    uint256 amount = 88 finney;\n', '    \n', '    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n', '    unclaimedDividends = unclaimedDividends.add(amount);\n', '    emit targetShot(sender);\n', '    emit death(killed, target);\n', '}\n', 'function Payoutnextrefund ()public\n', '    {\n', '         \n', '        require(Refundpot > 0.00001 ether);\n', '        uint256 amount = Refundpot;\n', '    Refundpot = 0;\n', '    totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\n', '    unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\n', '    }\n', '\n', 'function disburse() public  payable {\n', '    uint256 amount = msg.value;\n', '    uint256 base = amount.div(100);\n', '    uint256 amt2 = amount.sub(base);\n', '  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n', ' unclaimedDividends = unclaimedDividends.add(amt2);\n', ' \n', '}\n', 'function vaultToWallet(address toPay) public {\n', '        require(playerVault[toPay] > 0);\n', '        uint256 value = playerVault[toPay];\n', '        playerVault[toPay] = 0;\n', '        toPay.transfer(value);\n', '    }\n', 'function changevanity(string van) public payable{\n', '    require(msg.value >= 1  finney);\n', '    Vanity[msg.sender] = van;\n', '    Refundpot += msg.value;\n', '}\n', 'function P3DDivstocontract() public{\n', '    uint256 divs = harvestabledivs();\n', '    require(divs > 0);\n', ' \n', 'P3Dcontract_.withdraw();\n', '    //1% to owner\n', '    uint256 base = divs.div(100);\n', '    uint256 amt2 = divs.sub(base);\n', '    SPASM_.disburse.value(base)();// to dev fee sharing contract\n', '   Refundpot = Refundpot.add(amt2);// add divs to refund line\n', '   \n', '}\n', '// 2nd div setup for refunds\n', '\n', '// legacystarting refunds from old contract\n', '    function legacyStart(uint256 amountProgress) onlyOwner public{\n', '        uint256 nextUp = NextInLineOld;\n', '        for(uint i=0; i< amountProgress; i++)\n', '        {\n', '        address torefund = old.RefundWaitingLine(nextUp + i);\n', '        i++;\n', '        balancesRefund[torefund] = balancesRefund[torefund].add(0.1 ether);\n', '        }\n', '        NextInLineOld += i;\n', '        _totalSupplyRefund = _totalSupplyRefund.add(i.mul(0.1 ether));\n', '    }\n', '\n', 'mapping(address => uint256) public balancesRefund;\n', 'uint256 public _totalSupplyRefund;\n', 'mapping(address=>Account) public accountsRefund;\n', 'uint public ethtotalSupplyRefund;\n', 'uint public totalDividendPointsRefund;\n', 'uint public unclaimedDividendsRefund;\n', '\n', 'function dividendsOwingRefund(address account) public view returns(uint256) {\n', '  uint256 newDividendPointsRefund = totalDividendPointsRefund.sub(accountsRefund[account].lastDividendPoints);\n', '  return (balancesRefund[account] * newDividendPointsRefund) / pointMultiplier;\n', '}\n', 'modifier updateAccountRefund(address account) {\n', '  uint256 owing = dividendsOwingRefund(account);\n', '  if(owing > balancesRefund[account]){balancesRefund[account] = owing;}\n', '  if(owing > 0 ) {\n', '    unclaimedDividendsRefund = unclaimedDividendsRefund.sub(owing);\n', '    \n', '    playerVault[account] = playerVault[account].add(owing);\n', '    balancesRefund[account] = balancesRefund[account].sub(owing);\n', '    _totalSupplyRefund = _totalSupplyRefund.sub(owing);\n', '  }\n', '  accountsRefund[account].lastDividendPoints = totalDividendPointsRefund;\n', '  _;\n', '}\n', '//function () external payable{}\n', 'function fetchdivsRefund(address toUpdate) public updateAccountRefund(toUpdate){}\n', '\n', 'function disburseRefund() public  payable {\n', '    uint256 amount = msg.value;\n', '    \n', '  totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\n', '  //ethtotalSupply = ethtotalSupply.add(amount);\n', ' unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\n', '}\n', '\n', '    //fetch P3D divs\n', '    function DivsToRefundpot ()public\n', '    {\n', '        //allocate p3d dividends to contract \n', '            uint256 dividends = P3Dcontract_.myDividends(true);\n', '            require(dividends > 0);\n', '            uint256 base = dividends.div(100);\n', '            P3Dcontract_.withdraw();\n', '            SPASM_.disburse.value(base.mul(5))();// to dev fee sharing contract SPASM\n', '            Refundpot = Refundpot.add(base.mul(95));\n', '    }\n', '    \n', '}\n', 'interface HourglassInterface  {\n', '    function() payable external;\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function reinvest() external;\n', '    function withdraw() external;\n', '    function exit() external;\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '    function dividendsOf(address _playerAddress) external view returns(uint256);\n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function stakingRequirement() external view returns(uint256);\n', '}\n', '\n', 'interface Snip3dInterface {\n', '    function RefundWaitingLine(uint256 index) external view returns(address);\n', '    function NextInLine() external view returns(uint256);\n', '    function NextAtLineEnd() external view returns(uint256);\n', '}\n', 'interface SPASMInterface  {\n', '    function() payable external;\n', '    function disburse() external  payable;\n', '}']