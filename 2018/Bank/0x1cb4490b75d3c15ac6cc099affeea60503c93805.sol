['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TheWhaleWins {\n', '    using SafeMath for uint256;\n', '\n', '    address contractOwner;\n', '    uint tokenStartPrice = 1 ether;\n', '    uint tokenStartPrice2 = 1.483239697419133 ether;\n', '    uint tokenPrice;\n', '    uint tokenPrice2;\n', '    address tokenOwner;\n', '    address tokenOwner2;\n', '    uint lastBuyBlock;\n', '    uint newRoundDelay = 2500;\n', '\n', '    address public richestPlayer;\n', '    uint public highestPrice;\n', '\n', '    uint public round;\n', '    uint public flips;\n', '    uint payoutRound;\n', '    uint public richestRoundId;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 price);\n', '    event NewRound(uint paidPrice, uint win, address winner);\n', '    event RichestBonus(uint win, address richestPlayer);\n', '\n', '\n', '    function TheWhaleWins() public {\n', '        contractOwner = msg.sender;\n', '        tokenOwner = address(0);\n', '        lastBuyBlock = block.number; \n', '        tokenPrice = tokenStartPrice;\n', '        tokenPrice2 = tokenStartPrice2;\n', '    }\n', '\n', '    function getRoundId() public view returns(uint) {\n', '        return round*1000000+flips;\n', '    }\n', '\n', '    function startPrice(uint price) public {\n', '      require(contractOwner == msg.sender);\n', '      tokenStartPrice = price;\n', '      tokenStartPrice2 = price * 1483239697419133 / 1000000000000000;\n', '    }\n', '\n', '    function changeNewRoundDelay(uint delay) public {\n', '        require(contractOwner == msg.sender);\n', '        newRoundDelay = delay;\n', '    }\n', '    function changeContractOwner(address newOwner) public {\n', '        require(contractOwner == msg.sender);\n', '        contractOwner = newOwner;\n', '    }\n', '    \n', '\n', '    function buyToken() public payable {\n', '        address currentOwner;\n', '        uint256 currentPrice;\n', '        uint256 paidTooMuch;\n', '        uint256 payment;\n', '\n', '        if (tokenPrice < tokenPrice2) {\n', '            currentOwner = tokenOwner;\n', '            currentPrice = tokenPrice;\n', '            require(tokenOwner2 != msg.sender);\n', '        } else {\n', '            currentOwner = tokenOwner2;\n', '            currentPrice = tokenPrice2;\n', '            require(tokenOwner != msg.sender);\n', '        }\n', '        require(msg.value >= currentPrice);\n', '\n', '        paidTooMuch = msg.value.sub(currentPrice);\n', '        payment = currentPrice.div(2);\n', '\n', '        if (tokenPrice < tokenPrice2) {\n', '            tokenPrice = currentPrice.mul(110).div(50);\n', '            tokenOwner = msg.sender;\n', '        } else {\n', '            tokenPrice2 = currentPrice.mul(110).div(50);\n', '            tokenOwner2 = msg.sender;\n', '        }\n', '        lastBuyBlock = block.number;\n', '        flips++;\n', '\n', '        Transfer(currentOwner, msg.sender, currentPrice);\n', '\n', '        if (currentOwner != address(0)) {\n', '            payoutRound = getRoundId()-3;\n', '            currentOwner.call.value(payment).gas(24000)();\n', '        }\n', '        if (paidTooMuch > 0)\n', '            msg.sender.transfer(paidTooMuch);\n', '    }\n', '\n', '    function getBlocksToNextRound() public view returns(uint) {\n', '        if (lastBuyBlock + newRoundDelay < block.number) {\n', '            return 0;\n', '        }\n', '        return lastBuyBlock + newRoundDelay + 1 - block.number;\n', '    }\n', '\n', '    function getPool() public view returns(uint balance) {\n', '        balance = this.balance;\n', '    }\n', '\n', '    function finishRound() public {\n', '        require(tokenPrice > tokenStartPrice);\n', '        require(lastBuyBlock + newRoundDelay < block.number);\n', '\n', '        lastBuyBlock = block.number;\n', '        address owner = tokenOwner;\n', '        uint price = tokenPrice;\n', '        if (tokenPrice2>tokenPrice) {\n', '            owner = tokenOwner2;\n', '            price = tokenPrice2;\n', '        }\n', '        uint lastPaidPrice = price.mul(50).div(110);\n', '        uint win = this.balance - lastPaidPrice;\n', '\n', '        if (highestPrice < lastPaidPrice) {\n', '            richestPlayer = owner;\n', '            highestPrice = lastPaidPrice;\n', '            richestRoundId = getRoundId()-1;\n', '        }\n', '\n', '        tokenPrice = tokenStartPrice;\n', '        tokenPrice2 = tokenStartPrice2;\n', '        tokenOwner = address(0);\n', '        tokenOwner2 = address(0);\n', '\n', '        payoutRound = getRoundId()-1;\n', '        flips = 0;\n', '        round++;\n', '        NewRound(lastPaidPrice, win / 2, owner);\n', '\n', '        contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20);\n', '        owner.call.value(lastPaidPrice + win / 2).gas(24000)();\n', '        if (richestPlayer!=address(0)) {\n', '            payoutRound = richestRoundId;\n', '            RichestBonus(win / 10, richestPlayer);\n', '            richestPlayer.call.value(win / 10).gas(24000)();\n', '        }\n', '    }\n', '\n', '    function getPayoutRoundId() public view returns(uint) {\n', '        return payoutRound;\n', '    }\n', '    function getPrice() public view returns(uint) {\n', '        if (tokenPrice2<tokenPrice)\n', '            return tokenPrice2;\n', '        return tokenPrice;\n', '    }\n', '\n', '    function getCurrentData() public view returns (uint price, uint nextPrice, uint pool, address winner, address looser, bool canFinish, uint nextPool, uint win, uint nextWin) {\n', '        winner = tokenOwner;\n', '        looser = tokenOwner2;\n', '        price = tokenPrice2;\n', '        nextPrice = tokenPrice;\n', '        if (tokenPrice2>tokenPrice) {\n', '            winner = tokenOwner2;\n', '            looser = tokenOwner;\n', '            price = tokenPrice;\n', '            nextPrice = tokenPrice2;\n', '        }\n', '        canFinish = (tokenPrice > tokenStartPrice) && (lastBuyBlock + newRoundDelay < block.number);\n', '        pool = getPool();\n', '        if (price == tokenStartPrice) {\n', '            nextPool = pool + price;\n', '            win = 0;\n', '        } else if (price == tokenStartPrice2) {\n', '            nextPool = pool + price;\n', '            win = (pool-nextPrice.mul(50).div(110))/2;\n', '        } else {\n', '            nextPool = pool + price / 2;\n', '            win = (pool-nextPrice.mul(50).div(110))/2;\n', '        }\n', '        nextWin = (nextPool-price)/2;\n', '    }\n', '}']