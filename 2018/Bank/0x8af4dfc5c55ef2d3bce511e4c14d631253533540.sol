['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a && c >= b);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract EtherDEX {\n', '    using SafeMath for uint;\n', '\n', '    address public admin; //the admin address\n', '    address public feeAccount; //the account that will receive fees\n', '    uint public feeMake; //percentage times (1 ether)\n', '    uint public feeTake; //percentage times (1 ether)\n', '    mapping(address => mapping(address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    mapping(address => mapping(bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '    mapping(address => mapping(bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '    address public previousContract;\n', '    address public nextContract;\n', '    bool public isContractDeprecated;\n', '    uint public contractVersion;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    event FundsMigrated(address user);\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    constructor(address admin_, address feeAccount_, uint feeMake_, uint feeTake_, address _previousContract) public {\n', '        admin = admin_;\n', '        feeAccount = feeAccount_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '        previousContract = _previousContract;\n', '        isContractDeprecated = false;\n', '\n', '        //count new contract version if it&#39;s not the first\n', '        if (previousContract != address(0)) {\n', '            contractVersion = EtherDEX(previousContract).contractVersion() + 1;\n', '        } else {\n', '            contractVersion = 1;\n', '        }\n', '    }\n', '\n', '    function() public payable {\n', '        revert("Cannot send ETH directly to the Contract");\n', '    }\n', '\n', '    function changeAdmin(address admin_) public onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) public onlyAdmin {\n', '        require(feeAccount_ != address(0));\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) public onlyAdmin {\n', '        if (feeMake_ > feeMake) revert("New fee cannot be higher than the old one");\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) public onlyAdmin {\n', '        if (feeTake_ > feeTake) revert("New fee cannot be higher than the old one");\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function deprecate(bool deprecated_, address nextContract_) public onlyAdmin {\n', '        isContractDeprecated = deprecated_;\n', '        nextContract = nextContract_;\n', '    }\n', '\n', '    function deposit() public payable {\n', '        tokens[0][msg.sender] = SafeMath.add(tokens[0][msg.sender], msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) public {\n', '        if (tokens[0][msg.sender] < amount) revert("Cannot withdraw more than you have");\n', '        tokens[0][msg.sender] = SafeMath.sub(tokens[0][msg.sender], amount);\n', '        msg.sender.transfer(amount);\n', '        //or .send() and check if https://ethereum.stackexchange.com/a/38642\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function depositToken(address token, uint amount) public {\n', '        //remember to call ERC20Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '        if (token == 0) revert("Cannot deposit ETH with depositToken method");\n', '        if (!ERC20(token).transferFrom(msg.sender, this, amount)) revert("You didn&#39;t call approve method on Token contract");\n', '        tokens[token][msg.sender] = SafeMath.add(tokens[token][msg.sender], amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) public {\n', '        if (token == 0) revert("Cannot withdraw ETH with withdrawToken method");\n', '        if (tokens[token][msg.sender] < amount) revert("Cannot withdraw more than you have");\n', '        tokens[token][msg.sender] = SafeMath.sub(tokens[token][msg.sender], amount);\n', '        if (!ERC20(token).transfer(msg.sender, amount)) revert("Error while transfering tokens");\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) public view returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        orders[msg.sender][hash] = true;\n', '        emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '        //amount is in amountGet terms\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!(\n', '        (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == user) &&\n', '        block.number <= expires &&\n', '        SafeMath.add(orderFills[user][hash], amount) <= amountGet\n', '        ))  revert("Validation error or order expired or not enough volume to trade");\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = SafeMath.add(orderFills[user][hash], amount);\n', '        emit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public view returns (bool) {\n', '        return (tokens[tokenGet][sender] >= amount && availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount);\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public view returns (uint) {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!((orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == user) && block.number <= expires)) return 0;\n', '        uint available1 = SafeMath.sub(amountGet, orderFills[user][hash]);\n', '        uint available2 = SafeMath.mul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1 < available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) public view returns (uint) {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!(orders[msg.sender][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == msg.sender)) revert("Validation error");\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '\n', '    function migrateFunds(address[] tokens_) public {\n', '        // Get the latest successor in the chain\n', '        require(nextContract != address(0));\n', '        EtherDEX newExchange = findNewExchangeContract();\n', '\n', '        // Ether\n', '        migrateEther(newExchange);\n', '\n', '        // Tokens\n', '        migrateTokens(newExchange, tokens_);\n', '\n', '        emit FundsMigrated(msg.sender);\n', '    }\n', '\n', '    function depositEtherForUser(address _user) public payable {\n', '        require(!isContractDeprecated);\n', '        require(_user != address(0));\n', '        require(msg.value > 0);\n', '        EtherDEX caller = EtherDEX(msg.sender);\n', '        require(caller.contractVersion() > 0); // Make sure it&#39;s an exchange account\n', '        tokens[0][_user] = tokens[0][_user].add(msg.value);\n', '    }\n', '\n', '    function depositTokenForUser(address _token, uint _amount, address _user) public {\n', '        require(!isContractDeprecated);\n', '        require(_token != address(0));\n', '        require(_user != address(0));\n', '        require(_amount > 0);\n', '        EtherDEX caller = EtherDEX(msg.sender);\n', '        require(caller.contractVersion() > 0); // Make sure it&#39;s an exchange account\n', '        if (!ERC20(_token).transferFrom(msg.sender, this, _amount)) {\n', '            revert();\n', '        }\n', '        tokens[_token][_user] = tokens[_token][_user].add(_amount);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = SafeMath.mul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = SafeMath.mul(amount, feeTake) / (1 ether);\n', '\n', '        tokens[tokenGet][msg.sender] = SafeMath.sub(tokens[tokenGet][msg.sender], SafeMath.add(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = SafeMath.add(tokens[tokenGet][user], SafeMath.sub(amount, feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = SafeMath.add(tokens[tokenGet][feeAccount], SafeMath.add(feeMakeXfer, feeTakeXfer));\n', '        tokens[tokenGive][user] = SafeMath.sub(tokens[tokenGive][user], SafeMath.mul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = SafeMath.add(tokens[tokenGive][msg.sender], SafeMath.mul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function findNewExchangeContract() private view returns (EtherDEX) {\n', '        EtherDEX newExchange = EtherDEX(nextContract);\n', '        for (uint16 n = 0; n < 20; n++) {// We will look past 20 contracts in the future\n', '            address nextContract_ = newExchange.nextContract();\n', '            if (nextContract_ == address(this)) {// Circular succession\n', '                revert();\n', '            }\n', '            if (nextContract_ == address(0)) {// We reached the newest, stop\n', '                break;\n', '            }\n', '            newExchange = EtherDEX(nextContract_);\n', '        }\n', '        return newExchange;\n', '    }\n', '\n', '    function migrateEther(EtherDEX newExchange) private {\n', '        uint etherAmount = tokens[0][msg.sender];\n', '        if (etherAmount > 0) {\n', '            tokens[0][msg.sender] = 0;\n', '            newExchange.depositEtherForUser.value(etherAmount)(msg.sender);\n', '        }\n', '    }\n', '\n', '    function migrateTokens(EtherDEX newExchange, address[] tokens_) private {\n', '        for (uint16 n = 0; n < tokens_.length; n++) {\n', '            address token = tokens_[n];\n', '            require(token != address(0));\n', '            // 0 = Ether, we handle it above\n', '            uint tokenAmount = tokens[token][msg.sender];\n', '            if (tokenAmount == 0) {\n', '                continue;\n', '            }\n', '            if (!ERC20(token).approve(newExchange, tokenAmount)) {\n', '                revert();\n', '            }\n', '            tokens[token][msg.sender] = 0;\n', '            newExchange.depositTokenForUser(token, tokenAmount, msg.sender);\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a && c >= b);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract EtherDEX {\n', '    using SafeMath for uint;\n', '\n', '    address public admin; //the admin address\n', '    address public feeAccount; //the account that will receive fees\n', '    uint public feeMake; //percentage times (1 ether)\n', '    uint public feeTake; //percentage times (1 ether)\n', '    mapping(address => mapping(address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    mapping(address => mapping(bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '    mapping(address => mapping(bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '    address public previousContract;\n', '    address public nextContract;\n', '    bool public isContractDeprecated;\n', '    uint public contractVersion;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    event FundsMigrated(address user);\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    constructor(address admin_, address feeAccount_, uint feeMake_, uint feeTake_, address _previousContract) public {\n', '        admin = admin_;\n', '        feeAccount = feeAccount_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '        previousContract = _previousContract;\n', '        isContractDeprecated = false;\n', '\n', "        //count new contract version if it's not the first\n", '        if (previousContract != address(0)) {\n', '            contractVersion = EtherDEX(previousContract).contractVersion() + 1;\n', '        } else {\n', '            contractVersion = 1;\n', '        }\n', '    }\n', '\n', '    function() public payable {\n', '        revert("Cannot send ETH directly to the Contract");\n', '    }\n', '\n', '    function changeAdmin(address admin_) public onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) public onlyAdmin {\n', '        require(feeAccount_ != address(0));\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) public onlyAdmin {\n', '        if (feeMake_ > feeMake) revert("New fee cannot be higher than the old one");\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) public onlyAdmin {\n', '        if (feeTake_ > feeTake) revert("New fee cannot be higher than the old one");\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function deprecate(bool deprecated_, address nextContract_) public onlyAdmin {\n', '        isContractDeprecated = deprecated_;\n', '        nextContract = nextContract_;\n', '    }\n', '\n', '    function deposit() public payable {\n', '        tokens[0][msg.sender] = SafeMath.add(tokens[0][msg.sender], msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) public {\n', '        if (tokens[0][msg.sender] < amount) revert("Cannot withdraw more than you have");\n', '        tokens[0][msg.sender] = SafeMath.sub(tokens[0][msg.sender], amount);\n', '        msg.sender.transfer(amount);\n', '        //or .send() and check if https://ethereum.stackexchange.com/a/38642\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function depositToken(address token, uint amount) public {\n', '        //remember to call ERC20Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '        if (token == 0) revert("Cannot deposit ETH with depositToken method");\n', '        if (!ERC20(token).transferFrom(msg.sender, this, amount)) revert("You didn\'t call approve method on Token contract");\n', '        tokens[token][msg.sender] = SafeMath.add(tokens[token][msg.sender], amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) public {\n', '        if (token == 0) revert("Cannot withdraw ETH with withdrawToken method");\n', '        if (tokens[token][msg.sender] < amount) revert("Cannot withdraw more than you have");\n', '        tokens[token][msg.sender] = SafeMath.sub(tokens[token][msg.sender], amount);\n', '        if (!ERC20(token).transfer(msg.sender, amount)) revert("Error while transfering tokens");\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) public view returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        orders[msg.sender][hash] = true;\n', '        emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '        //amount is in amountGet terms\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!(\n', '        (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == user) &&\n', '        block.number <= expires &&\n', '        SafeMath.add(orderFills[user][hash], amount) <= amountGet\n', '        ))  revert("Validation error or order expired or not enough volume to trade");\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = SafeMath.add(orderFills[user][hash], amount);\n', '        emit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public view returns (bool) {\n', '        return (tokens[tokenGet][sender] >= amount && availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount);\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public view returns (uint) {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!((orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == user) && block.number <= expires)) return 0;\n', '        uint available1 = SafeMath.sub(amountGet, orderFills[user][hash]);\n', '        uint available2 = SafeMath.mul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1 < available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) public view returns (uint) {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\n', '        if (!(orders[msg.sender][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) == msg.sender)) revert("Validation error");\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '\n', '    function migrateFunds(address[] tokens_) public {\n', '        // Get the latest successor in the chain\n', '        require(nextContract != address(0));\n', '        EtherDEX newExchange = findNewExchangeContract();\n', '\n', '        // Ether\n', '        migrateEther(newExchange);\n', '\n', '        // Tokens\n', '        migrateTokens(newExchange, tokens_);\n', '\n', '        emit FundsMigrated(msg.sender);\n', '    }\n', '\n', '    function depositEtherForUser(address _user) public payable {\n', '        require(!isContractDeprecated);\n', '        require(_user != address(0));\n', '        require(msg.value > 0);\n', '        EtherDEX caller = EtherDEX(msg.sender);\n', "        require(caller.contractVersion() > 0); // Make sure it's an exchange account\n", '        tokens[0][_user] = tokens[0][_user].add(msg.value);\n', '    }\n', '\n', '    function depositTokenForUser(address _token, uint _amount, address _user) public {\n', '        require(!isContractDeprecated);\n', '        require(_token != address(0));\n', '        require(_user != address(0));\n', '        require(_amount > 0);\n', '        EtherDEX caller = EtherDEX(msg.sender);\n', "        require(caller.contractVersion() > 0); // Make sure it's an exchange account\n", '        if (!ERC20(_token).transferFrom(msg.sender, this, _amount)) {\n', '            revert();\n', '        }\n', '        tokens[_token][_user] = tokens[_token][_user].add(_amount);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = SafeMath.mul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = SafeMath.mul(amount, feeTake) / (1 ether);\n', '\n', '        tokens[tokenGet][msg.sender] = SafeMath.sub(tokens[tokenGet][msg.sender], SafeMath.add(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = SafeMath.add(tokens[tokenGet][user], SafeMath.sub(amount, feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = SafeMath.add(tokens[tokenGet][feeAccount], SafeMath.add(feeMakeXfer, feeTakeXfer));\n', '        tokens[tokenGive][user] = SafeMath.sub(tokens[tokenGive][user], SafeMath.mul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = SafeMath.add(tokens[tokenGive][msg.sender], SafeMath.mul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function findNewExchangeContract() private view returns (EtherDEX) {\n', '        EtherDEX newExchange = EtherDEX(nextContract);\n', '        for (uint16 n = 0; n < 20; n++) {// We will look past 20 contracts in the future\n', '            address nextContract_ = newExchange.nextContract();\n', '            if (nextContract_ == address(this)) {// Circular succession\n', '                revert();\n', '            }\n', '            if (nextContract_ == address(0)) {// We reached the newest, stop\n', '                break;\n', '            }\n', '            newExchange = EtherDEX(nextContract_);\n', '        }\n', '        return newExchange;\n', '    }\n', '\n', '    function migrateEther(EtherDEX newExchange) private {\n', '        uint etherAmount = tokens[0][msg.sender];\n', '        if (etherAmount > 0) {\n', '            tokens[0][msg.sender] = 0;\n', '            newExchange.depositEtherForUser.value(etherAmount)(msg.sender);\n', '        }\n', '    }\n', '\n', '    function migrateTokens(EtherDEX newExchange, address[] tokens_) private {\n', '        for (uint16 n = 0; n < tokens_.length; n++) {\n', '            address token = tokens_[n];\n', '            require(token != address(0));\n', '            // 0 = Ether, we handle it above\n', '            uint tokenAmount = tokens[token][msg.sender];\n', '            if (tokenAmount == 0) {\n', '                continue;\n', '            }\n', '            if (!ERC20(token).approve(newExchange, tokenAmount)) {\n', '                revert();\n', '            }\n', '            tokens[token][msg.sender] = 0;\n', '            newExchange.depositTokenForUser(token, tokenAmount, msg.sender);\n', '        }\n', '    }\n', '}']
