['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title Doneth (Doneth)\n', ' * @dev Doneth is a contract that allows shared access to funds\n', ' * in the form of Ether and ERC20 tokens. It is especially relevant\n', ' * to donation based projects. The admins of the contract determine \n', ' * who is a member, and each member gets a number of shares. The \n', ' * number of shares each member has determines how much Ether/ERC20 \n', ' * the member can withdraw from the contract.\n', ' */\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running\n', ' * if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Doneth is Ownable {\n', '    using SafeMath for uint256;  \n', '\n', '    // Name of the contract\n', '    string public name;\n', '\n', '    // Sum of all shares allocated to members\n', '    uint256 public totalShares;\n', '\n', '    // Sum of all withdrawals done by members\n', '    uint256 public totalWithdrawn;\n', '\n', '    // Block number of when the contract was created\n', '    uint256 public genesisBlockNumber;\n', '\n', '    // Number of decimal places for floating point division\n', '    uint256 constant public PRECISION = 18;\n', '\n', '    // Variables for shared expense allocation\n', '    uint256 public sharedExpense;\n', '    uint256 public sharedExpenseWithdrawn;\n', '\n', '    // Used to keep track of members\n', '    mapping(address => Member) public members;\n', '    address[] public memberKeys;\n', '    struct Member {\n', '        bool exists;\n', '        bool admin;\n', '        uint256 shares;\n', '        uint256 withdrawn;\n', '        string memberName;\n', '        mapping(address => uint256) tokensWithdrawn;\n', '    }\n', '\n', '    // Used to keep track of ERC20 tokens used and how much withdrawn\n', '    mapping(address => Token) public tokens;\n', '    address[] public tokenKeys;\n', '    struct Token {\n', '        bool exists;\n', '        uint256 totalWithdrawn;\n', '    }\n', '\n', '    function Doneth(string _contractName, string _founderName) {\n', '        if (bytes(_contractName).length > 21) revert();\n', '        if (bytes(_founderName).length > 21) revert();\n', '        name = _contractName;\n', '        genesisBlockNumber = block.number;\n', '        addMember(msg.sender, 1, true, _founderName);\n', '    }\n', '\n', '    event Deposit(address from, uint value);\n', '    event Withdraw(address from, uint value, uint256 newTotalWithdrawn);\n', '    event TokenWithdraw(address from, uint value, address token, uint amount);\n', '    event AddShare(address who, uint256 addedShares, uint256 newTotalShares);\n', '    event RemoveShare(address who, uint256 removedShares, uint256 newTotalShares);\n', '    event ChangePrivilege(address who, bool oldValue, bool newValue);\n', '    event ChangeContractName(string oldValue, string newValue);\n', '    event ChangeMemberName(address who, string oldValue, string newValue);\n', '    event ChangeSharedExpense(uint256 contractBalance, uint256 oldValue, uint256 newValue);\n', '    event WithdrawSharedExpense(address from, address to, uint value, uint256 newSharedExpenseWithdrawn);\n', '\n', '    // Fallback function accepts Ether from donators\n', '    function () public payable {\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    modifier onlyAdmin() { \n', '        if (msg.sender != owner && !members[msg.sender].admin) revert();   \n', '        _;\n', '    }\n', '\n', '    modifier onlyExisting(address who) { \n', '        if (!members[who].exists) revert(); \n', '        _;\n', '    }\n', '\n', '    // Series of getter functions for contract data\n', '    function getMemberCount() public constant returns(uint) {\n', '        return memberKeys.length;\n', '    }\n', '    \n', '    function getMemberAtKey(uint key) public constant returns(address) {\n', '        return memberKeys[key];\n', '    }\n', '    \n', '    function getBalance() public constant returns(uint256 balance) {\n', '        return this.balance;\n', '    }\n', '    \n', '    function getContractInfo() public constant returns(string, address, uint256, uint256, uint256) {\n', '        return (string(name), owner, genesisBlockNumber, totalShares, totalWithdrawn);\n', '    }\n', '    \n', '    function returnMember(address _address) public constant onlyExisting(_address) returns(bool admin, uint256 shares, uint256 withdrawn, string memberName) {\n', '      Member memory m = members[_address];\n', '      return (m.admin, m.shares, m.withdrawn, m.memberName);\n', '    }\n', '\n', '    function checkERC20Balance(address token) public constant returns(uint256) {\n', '        uint256 balance = ERC20(token).balanceOf(address(this));\n', '        if (!tokens[token].exists && balance > 0) {\n', '            tokens[token].exists = true;\n', '        }\n', '        return balance;\n', '    }\n', '\n', '    // Function to add members to the contract \n', '    function addMember(address who, uint256 shares, bool admin, string memberName) public onlyAdmin() {\n', "        // Don't allow the same member to be added twice\n", '        if (members[who].exists) revert();\n', '        if (bytes(memberName).length > 21) revert();\n', '\n', '        Member memory newMember;\n', '        newMember.exists = true;\n', '        newMember.admin = admin;\n', '        newMember.memberName = memberName;\n', '\n', '        members[who] = newMember;\n', '        memberKeys.push(who);\n', '        addShare(who, shares);\n', '    }\n', '\n', '    function updateMember(address who, uint256 shares, bool isAdmin, string name) public onlyAdmin() {\n', '        if (sha3(members[who].memberName) != sha3(name)) changeMemberName(who, name);\n', '        if (members[who].admin != isAdmin) changeAdminPrivilege(who, isAdmin);\n', '        if (members[who].shares != shares) allocateShares(who, shares);\n', '    }\n', '\n', "    // Only owner, admin or member can change member's name\n", '    function changeMemberName(address who, string newName) public onlyExisting(who) {\n', '        if (msg.sender != who && msg.sender != owner && !members[msg.sender].admin) revert();\n', '        if (bytes(newName).length > 21) revert();\n', '        ChangeMemberName(who, members[who].memberName, newName);\n', '        members[who].memberName = newName;\n', '    }\n', '\n', '    function changeAdminPrivilege(address who, bool newValue) public onlyAdmin() {\n', '        ChangePrivilege(who, members[who].admin, newValue);\n', '        members[who].admin = newValue; \n', '    }\n', '\n', '    // Only admins and owners can change the contract name\n', '    function changeContractName(string newName) public onlyAdmin() {\n', '        if (bytes(newName).length > 21) revert();\n', '        ChangeContractName(name, newName);\n', '        name = newName;\n', '    }\n', '\n', '    // Shared expense allocation allows admins to withdraw an amount to be used for shared\n', '    // expenses. Shared expense allocation subtracts from the total balance of the contract. \n', '    // Only owner can change this amount.\n', '    function changeSharedExpenseAllocation(uint256 newAllocation) public onlyOwner() {\n', '        if (newAllocation < sharedExpenseWithdrawn) revert();\n', '        if (newAllocation.sub(sharedExpenseWithdrawn) > this.balance) revert();\n', '\n', '        ChangeSharedExpense(this.balance, sharedExpense, newAllocation);\n', '        sharedExpense = newAllocation;\n', '    }\n', '\n', '    // Set share amount explicitly by calculating difference then adding or removing accordingly\n', '    function allocateShares(address who, uint256 amount) public onlyAdmin() onlyExisting(who) {\n', '        uint256 currentShares = members[who].shares;\n', '        if (amount == currentShares) revert();\n', '        if (amount > currentShares) {\n', '            addShare(who, amount.sub(currentShares));\n', '        } else {\n', '            removeShare(who, currentShares.sub(amount));\n', '        }\n', '    }\n', '\n', '    // Increment the number of shares for a member\n', '    function addShare(address who, uint256 amount) public onlyAdmin() onlyExisting(who) {\n', '        totalShares = totalShares.add(amount);\n', '        members[who].shares = members[who].shares.add(amount);\n', '        AddShare(who, amount, members[who].shares);\n', '    }\n', '\n', '    // Decrement the number of shares for a member\n', '    function removeShare(address who, uint256 amount) public onlyAdmin() onlyExisting(who) {\n', '        totalShares = totalShares.sub(amount);\n', '        members[who].shares = members[who].shares.sub(amount);\n', '        RemoveShare(who, amount, members[who].shares);\n', '    }\n', '\n', '    // Function for a member to withdraw Ether from the contract proportional\n', '    // to the amount of shares they have. Calculates the totalWithdrawableAmount\n', "    // in Ether based on the member's share and the Ether balance of the contract,\n", '    // then subtracts the amount of Ether that the member has already previously\n', '    // withdrawn.\n', '    function withdraw(uint256 amount) public onlyExisting(msg.sender) {\n', '        uint256 newTotal = calculateTotalWithdrawableAmount(msg.sender);\n', '        if (amount > newTotal.sub(members[msg.sender].withdrawn)) revert();\n', '        \n', '        members[msg.sender].withdrawn = members[msg.sender].withdrawn.add(amount);\n', '        totalWithdrawn = totalWithdrawn.add(amount);\n', '        msg.sender.transfer(amount);\n', '        Withdraw(msg.sender, amount, totalWithdrawn);\n', '    }\n', '\n', '    // Withdrawal function for ERC20 tokens\n', '    function withdrawToken(uint256 amount, address token) public onlyExisting(msg.sender) {\n', '        uint256 newTotal = calculateTotalWithdrawableTokenAmount(msg.sender, token);\n', '        if (amount > newTotal.sub(members[msg.sender].tokensWithdrawn[token])) revert();\n', '\n', '        members[msg.sender].tokensWithdrawn[token] = members[msg.sender].tokensWithdrawn[token].add(amount);\n', '        tokens[token].totalWithdrawn = tokens[token].totalWithdrawn.add(amount);\n', '        ERC20(token).transfer(msg.sender, amount);\n', '        TokenWithdraw(msg.sender, amount, token, tokens[token].totalWithdrawn);\n', '    }\n', '\n', '    // Withdraw from shared expense allocation. Total withdrawable is calculated as \n', '    // sharedExpense minus sharedExpenseWithdrawn. Only Admin can withdraw from shared expense.\n', '    function withdrawSharedExpense(uint256 amount, address to) public onlyAdmin() {\n', '        if (amount > calculateTotalExpenseWithdrawableAmount()) revert();\n', '        \n', '        sharedExpenseWithdrawn = sharedExpenseWithdrawn.add(amount);\n', '        to.transfer(amount);\n', '        WithdrawSharedExpense(msg.sender, to, amount, sharedExpenseWithdrawn);\n', '    }\n', '\n', '    // Converts from shares to Eth.\n', '    // Ex: 2 shares, 4 total shares, 40 Eth balance\n', '    // 40 Eth / 4 total shares = 10 eth per share * 2 shares = 20 Eth to cash out\n', '    function calculateTotalWithdrawableAmount(address who) public constant onlyExisting(who) returns (uint256) {\n', '        // Total balance to calculate share from = \n', '        // contract balance + totalWithdrawn - sharedExpense + sharedExpenseWithdrawn\n', '        uint256 balanceSum = this.balance.add(totalWithdrawn);\n', '        balanceSum = balanceSum.sub(sharedExpense);\n', '        balanceSum = balanceSum.add(sharedExpenseWithdrawn);\n', '        \n', '        // Need to use parts-per notation to compute percentages for lack of floating point division\n', '        uint256 ethPerSharePPN = balanceSum.percent(totalShares, PRECISION); \n', '        uint256 ethPPN = ethPerSharePPN.mul(members[who].shares);\n', '        uint256 ethVal = ethPPN.div(10**PRECISION); \n', '        return ethVal;\n', '    }\n', '\n', '\n', '    function calculateTotalWithdrawableTokenAmount(address who, address token) public constant returns(uint256) {\n', '        uint256 balanceSum = checkERC20Balance(token).add(tokens[token].totalWithdrawn);\n', '\n', '        // Need to use parts-per notation to compute percentages for lack of floating point division\n', '        uint256 tokPerSharePPN = balanceSum.percent(totalShares, PRECISION); \n', '        uint256 tokPPN = tokPerSharePPN.mul(members[who].shares);\n', '        uint256 tokVal = tokPPN.div(10**PRECISION); \n', '        return tokVal;\n', '    }\n', '\n', '    function calculateTotalExpenseWithdrawableAmount() public constant returns(uint256) {\n', '        return sharedExpense.sub(sharedExpenseWithdrawn);\n', '    }\n', '\n', '    // Used for testing\n', '    function delegatePercent(uint256 a, uint256 b, uint256 c) public constant returns (uint256) {\n', '        return a.percent(b, c);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    // Using from SO: https://stackoverflow.com/questions/42738640/division-in-ethereum-solidity/42739843#42739843\n', '    // Adapted to use SafeMath and uint256.\n', '    function percent(uint256 numerator, uint256 denominator, uint256 precision) internal constant returns(uint256 quotient) {\n', '        // caution, check safe-to-multiply here\n', '        uint256 _numerator = mul(numerator, 10 ** (precision+1));\n', '        // with rounding of last digit\n', '        uint256 _quotient = (div(_numerator, denominator) + 5) / 10;\n', '        return (_quotient);\n', '    }\n', '}']