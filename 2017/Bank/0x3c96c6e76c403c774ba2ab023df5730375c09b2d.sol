['pragma solidity ^0.4.18;\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to,uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from,address _to,uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender,uint256 _value) returns (bool success) {}\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner,address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from,address indexed _to,uint256 _value);\n', '  event Approval(address indexed _owner,address indexed _spender,uint256 _value);\n', '\n', '  uint decimals;\n', '  string name;\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a,uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  function safeDiv(uint a,uint b) internal returns (uint) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a,uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a,uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', 'contract ShortOrder is SafeMath {\n', '\n', '  address admin;\n', '\n', '  struct Order {\n', '    uint coupon;\n', '    uint balance;\n', '    bool tokenDeposit;\n', '    mapping (address => uint) shortBalance;\n', '    mapping (address => uint) longBalance;\n', '  }\n', '\n', '  mapping (address => mapping (bytes32 => Order)) orderRecord;\n', '\n', '  event TokenFulfillment(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint amount);\n', '  event CouponDeposit(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint value);\n', '  event LongPlace(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint value);\n', '  event LongBought(address[2] sellerShort,uint[3] amountNonceExpiry,uint8 v,bytes32[3] hashRS,uint value);\n', '  event TokenLongExercised(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint couponAmount,uint amount);\n', '  event EthLongExercised(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint couponAmount,uint amount);\n', '  event DonationClaimed(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint coupon,uint balance);\n', '  event NonActivationWithdrawal(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint coupon);\n', '  event ActivationWithdrawal(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs,uint balance);\n', '\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  function ShortOrder() {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  function changeAdmin(address _admin) external onlyAdmin {\n', '    admin = _admin;\n', '  }\n', '\n', '  function tokenFulfillmentDeposit(address[2] tokenUser,uint amount,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == msg.sender &&\n', '      block.number > minMaxDMWCPNonce[2] &&\n', '      block.number <= minMaxDMWCPNonce[3] && \n', '      orderRecord[tokenUser[1]][orderHash].balance >= minMaxDMWCPNonce[0] &&\n', '      amount >= safeMul(orderRecord[msg.sender][orderHash].balance,minMaxDMWCPNonce[6]) &&\n', '      !orderRecord[msg.sender][orderHash].tokenDeposit\n', '    );\n', '    Token(tokenUser[0]).transferFrom(msg.sender,this,amount);\n', '    orderRecord[msg.sender][orderHash].shortBalance[tokenUser[0]] = safeAdd(orderRecord[msg.sender][orderHash].shortBalance[tokenUser[0]],amount);\n', '    orderRecord[msg.sender][orderHash].tokenDeposit = true;\n', '    TokenFulfillment(tokenUser,minMaxDMWCPNonce,v,rs,amount);\n', '  }\n', ' \n', '  function depositCoupon(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external payable {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == msg.sender &&\n', '      msg.value >= minMaxDMWCPNonce[5]\n', '    );\n', '    orderRecord[msg.sender][orderHash].coupon = safeAdd(orderRecord[msg.sender][orderHash].coupon,msg.value);\n', '    CouponDeposit(tokenUser,minMaxDMWCPNonce,v,rs,msg.value);\n', '  }\n', '\n', '  function placeLong(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external payable {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1] &&\n', '      block.number <= minMaxDMWCPNonce[2] &&\n', '      orderRecord[tokenUser[1]][orderHash].coupon >= minMaxDMWCPNonce[5]&&\n', '      orderRecord[tokenUser[1]][orderHash].balance <= minMaxDMWCPNonce[1]\n', '    );\n', '    orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender] = safeAdd(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender],msg.value);\n', '    orderRecord[tokenUser[1]][orderHash].balance = safeAdd(orderRecord[tokenUser[1]][orderHash].balance,msg.value);\n', '    LongPlace(tokenUser,minMaxDMWCPNonce,v,rs,msg.value);\n', '  }\n', '  \n', '  function buyLong(address[2] sellerShort,uint[3] amountNonceExpiry,uint8 v,bytes32[3] hashRS) external payable {\n', '    bytes32 longTransferHash = keccak256(sellerShort[0],amountNonceExpiry);\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",longTransferHash[0]),v,hashRS[1],hashRS[2]) == sellerShort[1] &&\n', '      msg.value >= amountNonceExpiry[0] \n', '    );\n', '    sellerShort[0].transfer(msg.value);\n', '    orderRecord[sellerShort[1]][hashRS[0]].longBalance[msg.sender] = orderRecord[sellerShort[1]][hashRS[0]].longBalance[sellerShort[0]];\n', '    orderRecord[sellerShort[1]][hashRS[0]].longBalance[sellerShort[0]] = uint(0);\n', '    LongBought(sellerShort,amountNonceExpiry,v,hashRS,msg.value);\n', '  }\n', '\n', '  function exerciseLong(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1] &&\n', '      block.number > minMaxDMWCPNonce[3] &&\n', '      block.number <= minMaxDMWCPNonce[4] &&\n', '      orderRecord[tokenUser[1]][orderHash].balance >= minMaxDMWCPNonce[0]\n', '    );\n', '    uint couponProportion = safeDiv(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender],orderRecord[tokenUser[1]][orderHash].balance);\n', '    uint couponAmount;\n', '    if(orderRecord[msg.sender][orderHash].tokenDeposit) {\n', '      couponAmount = safeMul(orderRecord[tokenUser[1]][orderHash].coupon,couponProportion);\n', '      uint amount = safeMul(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender],minMaxDMWCPNonce[6]);\n', '      msg.sender.transfer(couponAmount);\n', '      Token(tokenUser[0]).transfer(msg.sender,amount);\n', '      orderRecord[tokenUser[1]][orderHash].coupon = safeSub(orderRecord[tokenUser[1]][orderHash].coupon,couponAmount);\n', '      orderRecord[tokenUser[1]][orderHash].balance = safeSub(orderRecord[tokenUser[1]][orderHash].balance,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '      orderRecord[tokenUser[1]][orderHash].shortBalance[tokenUser[0]] = safeSub(orderRecord[tokenUser[1]][orderHash].shortBalance[tokenUser[0]],amount);\n', '      orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender] = uint(0);\n', '      TokenLongExercised(tokenUser,minMaxDMWCPNonce,v,rs,couponAmount,amount);\n', '    }\n', '    else {\n', '      couponAmount = safeMul(orderRecord[tokenUser[1]][orderHash].coupon,couponProportion);\n', '      msg.sender.transfer(safeAdd(couponAmount,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]));\n', '      orderRecord[tokenUser[1]][orderHash].coupon = safeSub(orderRecord[tokenUser[1]][orderHash].coupon,couponAmount);\n', '      orderRecord[tokenUser[1]][orderHash].balance = safeSub(orderRecord[tokenUser[1]][orderHash].balance,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '      orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender] = uint(0); \n', '      EthLongExercised(tokenUser,minMaxDMWCPNonce,v,rs,couponAmount,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '    }\n', '  }\n', '\n', '  function claimDonations(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external onlyAdmin {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1] &&\n', '      block.number > minMaxDMWCPNonce[4]\n', '    );\n', '    admin.transfer(safeAdd(orderRecord[tokenUser[1]][orderHash].coupon,orderRecord[tokenUser[1]][orderHash].balance));\n', '    Token(tokenUser[0]).transfer(admin,orderRecord[tokenUser[1]][orderHash].shortBalance[tokenUser[0]]);\n', '    orderRecord[tokenUser[1]][orderHash].balance = uint(0);\n', '    orderRecord[tokenUser[1]][orderHash].coupon = uint(0);\n', '    orderRecord[tokenUser[1]][orderHash].shortBalance[tokenUser[0]] = uint(0);\n', '    DonationClaimed(tokenUser,minMaxDMWCPNonce,v,rs,orderRecord[tokenUser[1]][orderHash].coupon,orderRecord[tokenUser[1]][orderHash].balance);\n', '  }\n', '\n', '  function nonActivationShortWithdrawal(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == msg.sender &&\n', '      block.number > minMaxDMWCPNonce[3] &&\n', '      block.number <= minMaxDMWCPNonce[4] &&\n', '      orderRecord[tokenUser[1]][orderHash].balance < minMaxDMWCPNonce[0]\n', '    );\n', '    msg.sender.transfer(orderRecord[msg.sender][orderHash].coupon);\n', '    orderRecord[msg.sender][orderHash].coupon = uint(0);\n', '    NonActivationWithdrawal(tokenUser,minMaxDMWCPNonce,v,rs,orderRecord[msg.sender][orderHash].coupon);\n', '  }\n', '\n', '  function nonActivationWithdrawal(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(\n', '      ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1] &&\n', '      block.number > minMaxDMWCPNonce[3] &&\n', '      block.number <= minMaxDMWCPNonce[4] &&\n', '      orderRecord[tokenUser[1]][orderHash].balance < minMaxDMWCPNonce[0]\n', '    );\n', '    msg.sender.transfer(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '    orderRecord[tokenUser[1]][orderHash].balance = safeSub(orderRecord[tokenUser[1]][orderHash].balance,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '    orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender] = uint(0);\n', '    ActivationWithdrawal(tokenUser,minMaxDMWCPNonce,v,rs,orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender]);\n', '  }\n', '\n', '  function returnBalance(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external constant returns (uint) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1]);\n', '    return orderRecord[tokenUser[1]][orderHash].balance;\n', '  }\n', '\n', '  function returnTokenBalance(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external constant returns (uint) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1]);\n', '    return orderRecord[tokenUser[1]][orderHash].shortBalance[tokenUser[1]];\n', '  }\n', '\n', '  function returnUserBalance(address _user,address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external constant returns (uint) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1]);\n', '    return orderRecord[tokenUser[1]][orderHash].longBalance[_user];\n', '  }\n', '\n', '  function returnCoupon(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external constant returns (uint) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1]);\n', '    return orderRecord[tokenUser[1]][orderHash].coupon;\n', '  }\n', '\n', '  function returnTokenDepositState(address[2] tokenUser,uint[8] minMaxDMWCPNonce,uint8 v,bytes32[2] rs) external constant returns (bool) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2], \n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6], \n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32",orderHash),v,rs[0],rs[1]) == tokenUser[1]);\n', '    return orderRecord[tokenUser[1]][orderHash].tokenDeposit;\n', '  }\n', ' \n', '  function returnHash(address[2] tokenUser,uint[8] minMaxDMWCPNonce) external pure returns (bytes32) {\n', '    bytes32 orderHash = keccak256 (\n', '        tokenUser[0],\n', '        tokenUser[1],\n', '        minMaxDMWCPNonce[0],\n', '        minMaxDMWCPNonce[1],\n', '        minMaxDMWCPNonce[2],\n', '        minMaxDMWCPNonce[3],\n', '        minMaxDMWCPNonce[4],\n', '        minMaxDMWCPNonce[5],\n', '        minMaxDMWCPNonce[6],\n', '        minMaxDMWCPNonce[7]\n', '      );\n', '    return keccak256("\\x19Ethereum Signed Message:\\n32",orderHash);\n', '  }\n', '\n', '  function returnAddress(bytes32 orderHash,uint8 v,bytes32[2] rs) external pure returns (address) {\n', '    return ecrecover(orderHash,v,rs[0],rs[1]);\n', '  }\n', '\n', '  function returnHashLong(address seller,uint[3] amountNonceExpiry)  external pure returns (bytes32) {\n', '    bytes32 orderHash =  keccak256(seller,amountNonceExpiry[0],amountNonceExpiry[1],amountNonceExpiry[2]);\n', '    return keccak256("\\x19Ethereum Signed Message:\\n32",orderHash);\n', '  }\n', '\n', '  function returnLongAddress(bytes32 orderHash,uint8 v,bytes32[2] rs) external pure returns (address) {\n', '    return ecrecover(orderHash,v,rs[0],rs[1]);\n', '  }\n', '\n', '}']