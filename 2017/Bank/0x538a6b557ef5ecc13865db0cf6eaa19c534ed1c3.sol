['pragma solidity ^0.4.16;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '   \n', 'contract Token is ERC20Interface {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    string public constant symbol = "LNC";\n', '    string public constant name = "Linker Coin";\n', '    uint8 public constant decimals = 18;\n', '    uint256 _totalSupply = 500000000000000000000000000;\n', '    \n', '    //AML & KYC\n', '    mapping (address => bool) public frozenAccount;\n', '    event FrozenFunds(address target, bool frozen);\n', '  \n', '    // Linker coin has  5*10^25 units, each unit has 10^18  minimum fractions which are called \n', '    // Owner of this contract\n', '    address public owner;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    // Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function IsFreezedAccount(address _addr) public constant returns (bool) {\n', '        return frozenAccount[_addr];\n', '    }\n', '\n', '    // Constructor\n', '    function Token() public {\n', '        owner = msg.sender;\n', '        balances[owner] = _totalSupply;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256 supply) {\n', '        supply = _totalSupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // Transfer the balance from owner's account to another account\n", '    function transfer(address _to, uint256 _value) public returns (bool success)\n', '    {\n', '        if (_to != 0x0  // Prevent transfer to 0x0 address.\n', '            && IsFreezedAccount(msg.sender) == false\n', '            && balances[msg.sender] >= _value \n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address _from,address _to, uint256 _value) public returns (bool success) {\n', '        if (_to != 0x0  // Prevent transfer to 0x0 address.\n', '            && IsFreezedAccount(_from) == false\n', '            && balances[_from] >= _value\n', '            && allowed[_from][msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            balances[_from] = balances[_from].sub(_value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function FreezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '}\n', ' \n', 'contract MyToken is Token {\n', '    \n', '    //LP Setup lp:liquidity provider\n', '    \n', '    uint8 public constant decimalOfPrice = 10;  // LNC/ETH\n', '    uint256 public constant multiplierOfPrice = 10000000000;\n', '    uint256 public constant multiplier = 1000000000000000000;\n', '    uint256 public lpAskPrice = 100000000000; //LP sell price\n', '    uint256 public lpBidPrice = 1; //LP buy price\n', '    uint256 public lpAskVolume = 0; //LP sell volume\n', '    uint256 public lpBidVolume = 0; //LP buy volume\n', '    uint256 public lpMaxVolume = 1000000000000000000000000; //the deafult maximum volume of the liquididty provider is 10000 LNC\n', '    \n', '    //LP Para\n', '    uint256 public edgePerPosition = 1; // (lpTargetPosition - lpPosition) / edgePerPosition = the penalty of missmatched position\n', '    uint256 public lpTargetPosition;\n', '    uint256 public lpFeeBp = 10; // lpFeeBp is basis point of fee collected by LP\n', '    \n', '    bool public isLpStart = false;\n', '    bool public isBurn = false;\n', '    \n', '    function MyToken() public {\n', '        balances[msg.sender] = _totalSupply;\n', '        lpTargetPosition = 200000000000000000000000000;\n', '    }\n', '    \n', '    event Burn(address indexed from, uint256 value);\n', '    function burn(uint256 _value) onlyOwner public returns (bool success) {\n', '        if (isBurn == true)\n', '        {\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            _totalSupply = _totalSupply.sub(_value);\n', '            Burn(msg.sender, _value);\n', '            return true;\n', '        }\n', '        else{\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    event SetBurnStart(bool _isBurnStart);\n', '    function setBurnStart(bool _isBurnStart) onlyOwner public {\n', '        isBurn = _isBurnStart;\n', '    }\n', '\n', '    //Owner will be Lp \n', '    event SetPrices(uint256 _lpBidPrice, uint256 _lpAskPrice, uint256 _lpBidVolume, uint256 _lpAskVolume);\n', '    function setPrices(uint256 _lpBidPrice, uint256 _lpAskPrice, uint256 _lpBidVolume, uint256 _lpAskVolume) onlyOwner public{\n', '        require(_lpBidPrice < _lpAskPrice);\n', '        require(_lpBidVolume <= lpMaxVolume);\n', '        require(_lpAskVolume <= lpMaxVolume);\n', '        lpBidPrice = _lpBidPrice;\n', '        lpAskPrice = _lpAskPrice;\n', '        lpBidVolume = _lpBidVolume;\n', '        lpAskVolume = _lpAskVolume;\n', '        SetPrices(_lpBidPrice, _lpAskPrice, _lpBidVolume, _lpAskVolume);\n', '    }\n', '    \n', '    event SetLpMaxVolume(uint256 _lpMaxVolume);\n', '    function setLpMaxVolume(uint256 _lpMaxVolume) onlyOwner public {\n', '        require(_lpMaxVolume < 1000000000000000000000000);\n', '        lpMaxVolume = _lpMaxVolume;\n', '        if (lpMaxVolume < lpBidVolume){\n', '            lpBidVolume = lpMaxVolume;\n', '        }\n', '        if (lpMaxVolume < lpAskVolume){\n', '            lpAskVolume = lpMaxVolume;\n', '        }\n', '        SetLpMaxVolume(_lpMaxVolume);\n', '    }\n', '    \n', '    event SetEdgePerPosition(uint256 _edgePerPosition);\n', '    function setEdgePerPosition(uint256 _edgePerPosition) onlyOwner public {\n', '        //require(_edgePerPosition < 100000000000000000000000000000);\n', '        edgePerPosition = _edgePerPosition;\n', '        SetEdgePerPosition(_edgePerPosition);\n', '    }\n', '    \n', '    event SetLPTargetPostion(uint256 _lpTargetPositionn);\n', '    function setLPTargetPostion(uint256 _lpTargetPosition) onlyOwner public {\n', '        require(_lpTargetPosition <totalSupply() );\n', '        lpTargetPosition = _lpTargetPosition;\n', '        SetLPTargetPostion(_lpTargetPosition);\n', '    }\n', '    \n', '    event SetLpFee(uint256 _lpFeeBp);\n', '    function setLpFee(uint256 _lpFeeBp) onlyOwner public {\n', '        require(_lpFeeBp <= 100);\n', '        lpFeeBp = _lpFeeBp;\n', '        SetLpFee(lpFeeBp);\n', '    }\n', '    \n', '    event SetLpIsStart(bool _isLpStart);\n', '    function setLpIsStart(bool _isLpStart) onlyOwner public {\n', '        isLpStart = _isLpStart;\n', '    }\n', '    \n', '    function getLpBidPrice()public constant returns (uint256)\n', '    { \n', '        uint256 lpPosition = balanceOf(owner);\n', '            \n', '        if (lpTargetPosition >= lpPosition)\n', '        {\n', '            return lpBidPrice;\n', '        }\n', '        else\n', '        {\n', '            return lpBidPrice.sub((((lpPosition.sub(lpTargetPosition)).div(multiplier)).mul(edgePerPosition)).div(multiplierOfPrice));\n', '        }\n', '    }\n', '    \n', '    function getLpAskPrice()public constant returns (uint256)\n', '    {\n', '        uint256 lpPosition = balanceOf(owner);\n', '            \n', '        if (lpTargetPosition <= lpPosition)\n', '        {\n', '            return lpAskPrice;\n', '        }\n', '        else\n', '        {\n', '            return lpAskPrice.add((((lpTargetPosition.sub(lpPosition)).div(multiplier)).mul(edgePerPosition)).div(multiplierOfPrice));\n', '        }\n', '    }\n', '    \n', '    function getLpIsWorking(int minSpeadBp) public constant returns (bool )\n', '    {\n', '        if (isLpStart == false)\n', '            return false;\n', '         \n', '        if (lpAskVolume == 0 || lpBidVolume == 0)\n', '        {\n', '            return false;\n', '        }\n', '        \n', '        int256 bidPrice = int256(getLpBidPrice());\n', '        int256 askPrice = int256(getLpAskPrice());\n', '        \n', '        if (askPrice - bidPrice > minSpeadBp * (bidPrice + askPrice) / 2 / 10000)\n', '        {\n', '            return false;\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function getAmountOfLinkerBuy(uint256 etherAmountOfSell) public constant returns (uint256)\n', '    {\n', '        return ((( multiplierOfPrice.mul(etherAmountOfSell) ).div(getLpAskPrice())).mul(uint256(10000).sub(lpFeeBp))).div(uint256(10000));\n', '    }\n', '    \n', '    function getAmountOfEtherSell(uint256 linkerAmountOfBuy) public constant returns (uint256)\n', '    {\n', '        return (((getLpBidPrice().mul(linkerAmountOfBuy)).div(multiplierOfPrice)).mul(uint256(10000).sub(lpFeeBp))).div(uint256(10000));\n', '    }\n', '    \n', '    function () public payable {\n', '    }\n', '    \n', '    function buy() public payable returns (uint256){\n', '        require (getLpIsWorking(500));                      // Check Whether Lp Bid and Ask spread is less than 5%\n', '        uint256 amount = getAmountOfLinkerBuy(msg.value);   // calculates the amount of buy from customer \n', '        require(balances[owner] >= amount);                  // checks if it has enough to sell\n', "        balances[msg.sender] = balances[msg.sender].add(amount);                     // adds the amount to buyer's balance\n", "        balances[owner] = balances[owner].sub(amount);                           // subtracts amount from seller's balance\n", '        lpAskVolume = lpAskVolume.sub(amount);\n', '        Transfer(owner, msg.sender, amount);                 // execute an event reflecting the chang               // ends function and returns\n', '        return amount;                                    \n', '    }\n', '    \n', '    function sell(uint256 amount)public returns (uint256) {    \n', '        require (getLpIsWorking(500));\n', '        require (balances[msg.sender] >= amount);           // checks if the sender has enough to sell\n', "        balances[owner] = balances[owner].add(amount);                           // adds the amount to owner's balance\n", "        balances[msg.sender] = balances[msg.sender].sub(amount);                     // subtracts the amount from seller's balance\n", '        lpBidVolume = lpBidVolume.sub(amount);\n', '        uint256 linkerSendAmount = getAmountOfEtherSell(amount);\n', '        \n', "        msg.sender.transfer(linkerSendAmount);         // sends ether to the seller: it's important to do this last to prevent recursion attacks\n", '        Transfer(msg.sender, this, linkerSendAmount);       // executes an event reflecting on the change\n', '        return linkerSendAmount;                                   // ends function and returns\n', '    }\n', '    \n', '    function transferEther(uint256 amount) onlyOwner public{\n', '        msg.sender.transfer(amount);\n', '        Transfer(msg.sender, this, amount);\n', '    }\n', '}']