['pragma solidity ^0.4.18;\n', '\n', 'contract Terrus {\n', '  event PlotSale(\n', '    uint indexed _x,\n', '    uint indexed _y,\n', '    address _from,\n', '    address indexed _to,\n', '    uint _price,\n', '    bool _gift\n', '  );\n', '\n', '  event PlotTerrainUpdate(\n', '    uint indexed _x,\n', '    uint indexed _y,\n', '    address indexed _by,\n', '    uint _price,\n', '    bytes32 _newTerrain\n', '  );\n', '\n', '  event Withdrawal(\n', '    address _recipient,\n', '    uint _amount\n', '  );\n', '\n', '  struct Plot {\n', '    bool owned;\n', '    address owner;\n', '    uint x;\n', '    uint y;\n', '    bytes32 terrain;\n', '    uint saleCount;\n', '  }\n', '  mapping(uint => mapping(uint => Plot)) plots;\n', '\n', '  address owner;\n', '\n', '  mapping(uint => mapping(uint => address)) authorisedSaleAddresses;\n', '  mapping(uint => mapping(uint => uint)) authorisedSalePrices;\n', '\n', '  // Constructor\n', '  function Terrus() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  // Modifiers\n', '  modifier ownerOnly() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier validNewTerrain(uint x, uint y, bytes32 newTerrain) {\n', '    // TODO\n', '    _;\n', '  }\n', '\n', '  modifier xyBounded(uint x, uint y) {\n', '    require(x < 1000);\n', '    require(y < 1000);\n', '    _;\n', '  }\n', '\n', '  // Public\n', '  function authoriseSale(uint x, uint y, address buyer, uint amount) public returns (bool) {\n', '    Plot memory plot = plots[x][y];\n', '    require(plot.owned);\n', '    require(plot.owner == msg.sender);\n', '    uint fee = getSaleFee();\n', '    require(amount >= fee);\n', '    authorisedSaleAddresses[x][y] = buyer;\n', '    authorisedSalePrices[x][y] = amount;\n', '    return true;\n', '  }\n', '\n', '  function buyPlot(uint x, uint y) xyBounded(x, y) public payable returns (bool) {\n', '    require(!plots[x][y].owned);\n', '    uint price = getPlotPrice();\n', '    require(price == msg.value);\n', '    address buyer = msg.sender;\n', '    plots[x][y] = Plot({\n', '      owned: true,\n', '      owner: buyer,\n', '      x: x,\n', '      y: y,\n', '      terrain: getInitialTerrain(x, y),\n', '      saleCount: 1\n', '    });\n', '    PlotSale(x, y, 0x0, buyer, price, false);\n', '    return true;\n', '  }\n', '\n', '  function completeSale(uint x, uint y) public payable returns (bool) {\n', '    address buyer = msg.sender;\n', '    require(authorisedSaleAddresses[x][y] != 0x0);\n', '    require(authorisedSaleAddresses[x][y] == buyer);\n', '    require(authorisedSalePrices[x][y] == msg.value);\n', '    uint price = msg.value;\n', '    uint fee = getSaleFee();\n', '    uint forSeller = price - fee;\n', '    Plot storage plot = plots[x][y];\n', '    address seller = plot.owner;\n', '    plot.owner = buyer;\n', '    plot.saleCount += 1;\n', '    authorisedSaleAddresses[x][y] = 0x0;\n', '    authorisedSalePrices[x][y] = 0;\n', '    seller.transfer(forSeller);\n', '    PlotSale(x, y, seller, buyer, price, false);\n', '    return true;\n', '  }\n', '\n', '  function deAuthoriseSale(uint x, uint y) public returns (bool) {\n', '    Plot storage plot = plots[x][y];\n', '    require(plot.owned);\n', '    require(plot.owner == msg.sender);\n', '    authorisedSaleAddresses[x][y] = 0x0;\n', '    authorisedSalePrices[x][y] = 0;\n', '    return true;\n', '  }\n', '\n', '  function getInitialTerrain(uint x, uint y) public pure returns (bytes32) {\n', '    return sha256(x, y);\n', '  }\n', '\n', '  function getOwner() public view returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  function getPlot(uint x, uint y) public xyBounded(x, y) view returns (bool owned, address plotOwner, uint plotX, uint plotY, bytes32 plotTerrain) {\n', '    Plot memory plot = plots[x][y];\n', '    bytes32 terrain = plot.owned ? plot.terrain : getInitialTerrain(x, y);\n', '    return (plot.owned, plot.owner, x, y, terrain);\n', '  }\n', '\n', '  function getPlotPrice() public pure returns (uint) {\n', '    return 0.01 ether;\n', '  }\n', '\n', '  function getSaleFee() public pure returns (uint) {\n', '    return 0.01 ether;\n', '  }\n', '\n', '  function getSetNewTerrainPrice(uint x, uint y, bytes32 newTerrain) public xyBounded(x, y) validNewTerrain(x, y, newTerrain) view returns (uint) {\n', '    Plot memory plot = plots[x][y];\n', '    bytes32 currentTerrain = plot.owned ? plot.terrain : getInitialTerrain(x, y);\n', '    uint changed = 0;\n', '    for (uint i = 0; i < 32; i++) {\n', '      if (newTerrain[i] != currentTerrain[i]) {\n', '        changed += 1;\n', '      }\n', '    }\n', '    uint price = changed * (0.01 ether);\n', '    require(price >= 0);\n', '    return price;\n', '  }\n', '\n', '  function giftPlot(uint x, uint y, address recipient) public ownerOnly xyBounded(x, y) returns (bool) {\n', '    require(!plots[x][y].owned);\n', '    plots[x][y] = Plot({\n', '      owned: true,\n', '      owner: recipient,\n', '      x: x,\n', '      y: y,\n', '      terrain: getInitialTerrain(x, y),\n', '      saleCount: 1\n', '    });\n', '    PlotSale(x, y, 0x0, recipient, 0, true);\n', '    return true;\n', '  }\n', '\n', '  function ping() public pure returns (bytes4) {\n', '    return "pong";\n', '  }\n', '\n', '  // TODO TEST\n', '  function setNewTerrain(uint x, uint y, bytes32 newTerrain) public xyBounded(x, y) validNewTerrain(x, y, newTerrain) payable returns (bool) {\n', '    Plot storage plot = plots[x][y];\n', '    require(plot.owned);\n', '    require(plot.owner == msg.sender);\n', '    uint setPrice = getSetNewTerrainPrice(x, y, newTerrain);\n', '    require(msg.value == setPrice);\n', '    plot.terrain = newTerrain;\n', '    PlotTerrainUpdate(x, y, msg.sender, msg.value, newTerrain);\n', '    return true;\n', '  }\n', '\n', '  function setOwner(address newOwner) public ownerOnly returns (bool) {\n', '    owner = newOwner;\n', '    return true;\n', '  }\n', '\n', '  function withdrawEther(uint amount) public ownerOnly returns (bool) {\n', '    require(this.balance >= amount);\n', '    address recipient = msg.sender;\n', '    recipient.transfer(amount);\n', '    Withdrawal(recipient, amount);\n', '    return true;\n', '  }\n', '}']