['pragma solidity ^0.4.18;\n', 'contract Token {\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '}\n', 'contract LocalEthereumEscrows {\n', '    // The address of the arbitrator\n', '    // In the first version, this is always localethereum staff.\n', '    address public arbitrator;\n', '    address public owner;\n', '    address public relayer;\n', '    uint32 public requestCancellationMinimumTime;\n', '    uint256 public feesAvailableForWithdraw;\n', '\n', '    uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; // Called when marking as paid or calling a dispute as the buyer\n', '    uint8 constant ACTION_BUYER_CANCEL = 0x02;\n', '    uint8 constant ACTION_SELLER_CANCEL = 0x03;\n', '    uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04;\n', '    uint8 constant ACTION_RELEASE = 0x05;\n', '    uint8 constant ACTION_DISPUTE = 0x06;\n', '\n', '    event Created(bytes32 _tradeHash);\n', '    event SellerCancelDisabled(bytes32 _tradeHash);\n', '    event SellerRequestedCancel(bytes32 _tradeHash);\n', '    event CancelledBySeller(bytes32 _tradeHash);\n', '    event CancelledByBuyer(bytes32 _tradeHash);\n', '    event Released(bytes32 _tradeHash);\n', '    event DisputeResolved(bytes32 _tradeHash);\n', '\n', '    struct Escrow {\n', '        // Set so we know the trade has already been created\n', '        bool exists;\n', '        // The timestamp in which the seller can cancel the trade if the buyer has not yet marked as paid. Set to 0 on marked paid or dispute\n', '        // 1 = unlimited cancel time\n', '        uint32 sellerCanCancelAfter;\n', '        // The total cost of gas spent by relaying parties. This amount will be\n', '        // refunded/paid to localethereum.com once the escrow is finished.\n', '        uint128 totalGasFeesSpentByRelayer;\n', '    }\n', '    // Mapping of active trades. Key is a hash of the trade data\n', '    mapping (bytes32 => Escrow) public escrows;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyArbitrator() {\n', '        require(msg.sender == arbitrator);\n', '        _;\n', '    }\n', '\n', '    function getRelayedSender(\n', '      bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com\n', '      uint8 _actionByte, // The desired action of the user, matching an ACTION_* constant\n', '      uint128 _maximumGasPrice, // The maximum gas price the user is willing to pay\n', '      uint8 _v, // Signature value\n', '      bytes32 _r, // Signature value\n', '      bytes32 _s // Signature value\n', '    ) view private returns (address) {\n', '        bytes32 _hash = keccak256(_tradeID, _actionByte, _maximumGasPrice);\n', '        if(tx.gasprice > _maximumGasPrice) return;\n', '        return ecrecover(_hash, _v, _r, _s);\n', '    }\n', '\n', '    function LocalEthereumEscrows() public {\n', '        /**\n', '         * Initialize the contract.\n', '         */\n', '        owner = msg.sender;\n', '        arbitrator = msg.sender;\n', '        relayer = msg.sender;\n', '        requestCancellationMinimumTime = 2 hours; // TODO\n', '    }\n', '\n', '    function getEscrowAndHash(\n', '      /**\n', '       * Hashes the values and returns the matching escrow object and trade hash.\n', '       * Returns an empty escrow struct and 0 _tradeHash if not found\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee\n', '    ) view private returns (Escrow, bytes32) {\n', '        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\n', '        return (escrows[_tradeHash], _tradeHash);\n', '    }\n', '\n', '    function createEscrow(\n', '      /**\n', '       * Create a new escrow and add it to `escrows`.\n', '       * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.\n', '       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).\n', '       */\n', '      bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com\n', '      address _seller, // The selling party of the trade\n', '      address _buyer, // The buying party of the trade\n', '      uint256 _value, // The ether amount being held in escrow\n', '      uint16 _fee, // The localethereum.com fee in 1/10000ths\n', '      uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the buyer has to mark as paid\n', '      uint32 _expiry, // Provided by localethereum.com. This transaction must be created before this time.\n', '      uint8 _v, // Signature value\n', '      bytes32 _r, // Signature value\n', '      bytes32 _s // Signature value\n', '    ) payable external {\n', '        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\n', '        require(!escrows[_tradeHash].exists); // Require that trade does not already exist\n', '        require(ecrecover(keccak256(_tradeHash, _paymentWindowInSeconds, _expiry), _v, _r, _s) == relayer); // Signature must have come from the relayer\n', '        require(block.timestamp < _expiry);\n', '        require(msg.value == _value && msg.value > 0); // Check sent eth against signed _value and make sure is not 0\n', '        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds;\n', '        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\n', '        Created(_tradeHash);\n', '    }\n', '\n', '    uint16 constant GAS_doRelease = 36100;\n', '    function doRelease(\n', '      /**\n', '       * Called by the seller to releases the funds for a successful trade.\n', '       * Deletes the trade from the `escrows` mapping.\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doRelease + _additionalGas) * uint128(tx.gasprice) : 0);\n', '        delete escrows[_tradeHash];\n', '        Released(_tradeHash);\n', '        transferMinusFees(_buyer, _value, _gasFees, _fee);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doDisableSellerCancel = 12100;\n', '    function doDisableSellerCancel(\n', '      /**\n', '       * Stops the seller from cancelling the trade.\n', '       * Can only be called the buyer.\n', '       * Used to mark the trade as paid, or if the buyer has a dispute.\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        if(_escrow.sellerCanCancelAfter == 0) return false;\n', '        escrows[_tradeHash].sellerCanCancelAfter = 0;\n', '        SellerCancelDisabled(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doBuyerCancel = 36100;\n', '    function doBuyerCancel(\n', '      /**\n', '       * Cancels the trade and returns the ether to the seller.\n', '       * Can only be called the buyer.\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doBuyerCancel + _additionalGas) * uint128(tx.gasprice) : 0);\n', '        delete escrows[_tradeHash];\n', '        CancelledByBuyer(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerCancel = 36100;\n', '    function doSellerCancel(\n', '      /**\n', '       * Cancels the trade and returns the ether to the seller.\n', '       * Can only be called the seller.\n', '       * Can only be called if the payment window was missed by the buyer\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) return false;\n', '        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);\n', '        delete escrows[_tradeHash];\n', '        CancelledBySeller(_tradeHash);\n', '        transferMinusFees(_seller, _value, _gasFees, 0);\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doSellerRequestCancel = 12100;\n', '    function doSellerRequestCancel(\n', '      /**\n', '       * Called by the seller if the buyer is unresponsive\n', '       * Can only be called on unlimited payment window trades (sellerCanCancelAfter == 1)\n', '       * Sets the payment window to `requestCancellationMinimumTime` from now, in which it can be cancelled.\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '        // Called on unlimited payment window trades wheret the buyer is not responding\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        if (!_escrow.exists) return false;\n', '        if(_escrow.sellerCanCancelAfter != 1) return false;\n', '        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) + requestCancellationMinimumTime;\n', '        SellerRequestedCancel(_tradeHash);\n', '        if (msg.sender == relayer) {\n', '          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    uint16 constant GAS_doResolveDispute = 36100;\n', '    function resolveDispute(\n', '      /**\n', '       * Called by the arbitrator to resolve a dispute\n', '       * Requires the signed ACTION_DISPUTE actionByte from either the buyer or the seller\n', '       */\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint8 _v,\n', '      bytes32 _r,\n', '      bytes32 _s,\n', '      uint8 _buyerPercent\n', '    ) external onlyArbitrator {\n', '        address _signature = ecrecover(keccak256(_tradeID, ACTION_DISPUTE), _v, _r, _s);\n', '        require(_signature == _buyer || _signature == _seller);\n', '\n', '        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\n', '        require(_escrow.exists);\n', '        require(_buyerPercent <= 100);\n', '\n', '        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + GAS_doResolveDispute;\n', '        require(_value - _totalFees <= _value); // Prevent underflow\n', '        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\n', '\n', '        delete escrows[_tradeHash];\n', '        DisputeResolved(_tradeHash);\n', '        _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\n', '        _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\n', '    }\n', '\n', '    function release(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool){\n', '      require(msg.sender == _seller);\n', '      return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '    function disableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\n', '      require(msg.sender == _buyer);\n', '      return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '    function buyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\n', '      require(msg.sender == _buyer);\n', '      return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '    function sellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\n', '      require(msg.sender == _seller);\n', '      return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '    function sellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\n', '      require(msg.sender == _seller);\n', '      return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\n', '    }\n', '\n', '    function relaySellerCannotCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\n', '      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANNOT_CANCEL, 0);\n', '    }\n', '    function relayBuyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\n', '      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_BUYER_CANCEL, 0);\n', '    }\n', '    function relayRelease(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\n', '      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_RELEASE, 0);\n', '    }\n', '    function relaySellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\n', '      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANCEL, 0);\n', '    }\n', '    function relaySellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\n', '      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_REQUEST_CANCEL, 0);\n', '    }\n', '\n', '    function relay(\n', '      bytes16 _tradeID,\n', '      address _seller,\n', '      address _buyer,\n', '      uint256 _value,\n', '      uint16 _fee,\n', '      uint128 _maximumGasPrice,\n', '      uint8 _v,\n', '      bytes32 _r,\n', '      bytes32 _s,\n', '      uint8 _actionByte,\n', '      uint128 _additionalGas\n', '    ) private returns (bool) {\n', '      address _relayedSender = getRelayedSender(_tradeID, _actionByte, _maximumGasPrice, _v, _r, _s);\n', '      if (_relayedSender == _buyer) {\n', '        if (_actionByte == ACTION_SELLER_CANNOT_CANCEL) {\n', '          return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '        } else if (_actionByte == ACTION_BUYER_CANCEL) {\n', '          return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '        }\n', '      } else if (_relayedSender == _seller) {\n', '        if (_actionByte == ACTION_RELEASE) {\n', '          return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '        } else if (_actionByte == ACTION_SELLER_CANCEL) {\n', '          return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '        } else if (_actionByte == ACTION_SELLER_REQUEST_CANCEL){\n', '          return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\n', '        }\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    uint16 constant GAS_batchRelayBaseCost = 28500;\n', '    function batchRelay(\n', '      /**\n', '       * Call multiple relay methods at once to save on gas.\n', '       */\n', '        bytes16[] _tradeID,\n', '        address[] _seller,\n', '        address[] _buyer,\n', '        uint256[] _value,\n', '        uint16[] _fee,\n', '        uint128[] _maximumGasPrice,\n', '        uint8[] _v,\n', '        bytes32[] _r,\n', '        bytes32[] _s,\n', '        uint8[] _actionByte\n', '    ) public returns (bool[]) {\n', '        bool[] memory _results = new bool[](_tradeID.length);\n', '        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\n', '        for (uint8 i=0; i<_tradeID.length; i++) {\n', '            _results[i] = relay(_tradeID[i], _seller[i], _buyer[i], _value[i], _fee[i], _maximumGasPrice[i], _v[i], _r[i], _s[i], _actionByte[i], _additionalGas);\n', '        }\n', '        return _results;\n', '    }\n', '\n', '    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\n', '        /** Increase `totalGasFeesSpentByRelayer` to be charged later on completion of the trade.\n', '         */\n', '        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\n', '    }\n', '\n', '    function transferMinusFees(address _to, uint256 _value, uint128 _totalGasFeesSpentByRelayer, uint16 _fee) private {\n', '        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\n', '        if(_value - _totalFees > _value) return; // Prevent underflow\n', '        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\n', '        _to.transfer(_value - _totalFees);\n', '    }\n', '\n', '    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\n', '      /**\n', '       * Withdraw fees collected by the contract. Only the owner can call this.\n', '       */\n', '        require(_amount <= feesAvailableForWithdraw); // Also prevents underflow\n', '        feesAvailableForWithdraw -= _amount;\n', '        _to.transfer(_amount);\n', '    }\n', '\n', '    function setArbitrator(address _newArbitrator) onlyOwner external {\n', '        /**\n', '         * Set the arbitrator to a new address. Only the owner can call this.\n', '         * @param address _newArbitrator\n', '         */\n', '        arbitrator = _newArbitrator;\n', '    }\n', '\n', '    function setOwner(address _newOwner) onlyOwner external {\n', '        /**\n', '         * Change the owner to a new address. Only the owner can call this.\n', '         * @param address _newOwner\n', '         */\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function setRelayer(address _newRelayer) onlyOwner external {\n', '        /**\n', '         * Change the relayer to a new address. Only the owner can call this.\n', '         * @param address _newRelayer\n', '         */\n', '        relayer = _newRelayer;\n', '    }\n', '\n', '    function setRequestCancellationMinimumTime(uint32 _newRequestCancellationMinimumTime) onlyOwner external {\n', '        /**\n', '         * Change the requestCancellationMinimumTime. Only the owner can call this.\n', '         * @param uint32 _newRequestCancellationMinimumTime\n', '         */\n', '        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\n', '    }\n', '\n', '    function transferToken(Token _tokenContract, address _transferTo, uint256 _value) onlyOwner external {\n', '        /**\n', '         * If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         * This function is way for us to withdraw them so we can get them back to their rightful owner\n', '         */\n', '         _tokenContract.transfer(_transferTo, _value);\n', '    }\n', '    function transferTokenFrom(Token _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {\n', '        /**\n', '         * If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         * This function is way for us to withdraw them so we can get them back to their rightful owner\n', '         */\n', '         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\n', '    }\n', '    function approveToken(Token _tokenContract, address _spender, uint256 _value) onlyOwner external {\n', '        /**\n', '         * If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         * This function is way for us to withdraw them so we can get them back to their rightful owner\n', '         */\n', '         _tokenContract.approve(_spender, _value);\n', '    }\n', '}']