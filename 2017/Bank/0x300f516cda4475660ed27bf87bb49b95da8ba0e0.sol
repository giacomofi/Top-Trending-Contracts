['pragma solidity ^0.4.11;\n', '\n', '// NB: this is the newer ERC20 returning bool, need different book contract for older style tokens\n', 'contract ERC20 {\n', '  function totalSupply() constant returns (uint);\n', '  function balanceOf(address _owner) constant returns (uint balance);\n', '  function transfer(address _to, uint _value) returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '  function approve(address _spender, uint _value) returns (bool success);\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// UbiTok.io on-chain continuous limit order book matching engine.\n', '// This variation is for a "nice" ERC20 token as base, ETH as quoted, and standard fees with reward token.\n', '// Copyright (c) Bonnag Limited. All Rights Reserved.\n', '// Version 1.1.0y - variant with totalsupply validation disabled\n', '// This contract allows minPriceExponent, baseMinInitialSize, and baseMinRemainingSize\n', '// to be set at init() time appropriately for the token decimals and likely value.\n', '// \n', '//\n', 'contract BookERC20EthV1p1y {\n', '\n', '  enum BookType {\n', '    ERC20EthV1\n', '  }\n', '\n', '  enum Direction {\n', '    Invalid,\n', '    Buy,\n', '    Sell\n', '  }\n', '\n', '  enum Status {\n', '    Unknown,\n', '    Rejected,\n', '    Open,\n', '    Done,\n', '    NeedsGas,\n', '    Sending, // not used by contract - web only\n', '    FailedSend, // not used by contract - web only\n', '    FailedTxn // not used by contract - web only\n', '  }\n', '\n', '  enum ReasonCode {\n', '    None,\n', '    InvalidPrice,\n', '    InvalidSize,\n', '    InvalidTerms,\n', '    InsufficientFunds,\n', '    WouldTake,\n', '    Unmatched,\n', '    TooManyMatches,\n', '    ClientCancel\n', '  }\n', '\n', '  enum Terms {\n', '    GTCNoGasTopup,\n', '    GTCWithGasTopup,\n', '    ImmediateOrCancel,\n', '    MakerOnly\n', '  }\n', '\n', '  struct Order {\n', '    // these are immutable once placed:\n', '\n', '    address client;\n', '    uint16 price;              // packed representation of side + price\n', '    uint sizeBase;\n', '    Terms terms;\n', '\n', '    // these are mutable until Done or Rejected:\n', '    \n', '    Status status;\n', '    ReasonCode reasonCode;\n', '    uint128 executedBase;      // gross amount executed in base currency (before fee deduction)\n', '    uint128 executedCntr;      // gross amount executed in counter currency (before fee deduction)\n', '    uint128 feesBaseOrCntr;    // base for buy, cntr for sell\n', '    uint128 feesRwrd;\n', '  }\n', '  \n', '  struct OrderChain {\n', '    uint128 firstOrderId;\n', '    uint128 lastOrderId;\n', '  }\n', '\n', '  struct OrderChainNode {\n', '    uint128 nextOrderId;\n', '    uint128 prevOrderId;\n', '  }\n', '  \n', '  // It should be possible to reconstruct the expected state of the contract given:\n', '  //  - ClientPaymentEvent log history\n', '  //  - ClientOrderEvent log history\n', '  //  - Calling getOrder for the other immutable order fields of orders referenced by ClientOrderEvent\n', '  \n', '  enum ClientPaymentEventType {\n', '    Deposit,\n', '    Withdraw,\n', '    TransferFrom,\n', '    Transfer\n', '  }\n', '\n', '  enum BalanceType {\n', '    Base,\n', '    Cntr,\n', '    Rwrd\n', '  }\n', '\n', '  event ClientPaymentEvent(\n', '    address indexed client,\n', '    ClientPaymentEventType clientPaymentEventType,\n', '    BalanceType balanceType,\n', '    int clientBalanceDelta\n', '  );\n', '\n', '  enum ClientOrderEventType {\n', '    Create,\n', '    Continue,\n', '    Cancel\n', '  }\n', '\n', '  event ClientOrderEvent(\n', '    address indexed client,\n', '    ClientOrderEventType clientOrderEventType,\n', '    uint128 orderId,\n', '    uint maxMatches\n', '  );\n', '\n', '  enum MarketOrderEventType {\n', '    // orderCount++, depth += depthBase\n', '    Add,\n', '    // orderCount--, depth -= depthBase\n', '    Remove,\n', '    // orderCount--, depth -= depthBase, traded += tradeBase\n', '    // (depth change and traded change differ when tiny remaining amount refunded)\n', '    CompleteFill,\n', '    // orderCount unchanged, depth -= depthBase, traded += tradeBase\n', '    PartialFill\n', '  }\n', '\n', '  // Technically not needed but these events can be used to maintain an order book or\n', '  // watch for fills. Note that the orderId and price are those of the maker.\n', '\n', '  event MarketOrderEvent(\n', '    uint256 indexed eventTimestamp,\n', '    uint128 indexed orderId,\n', '    MarketOrderEventType marketOrderEventType,\n', '    uint16 price,\n', '    uint depthBase,\n', '    uint tradeBase\n', '  );\n', '\n', '  // the base token (e.g. TEST)\n', '  \n', '  ERC20 baseToken;\n', '\n', '  // minimum order size (inclusive)\n', '  uint baseMinInitialSize; // set at init\n', '\n', '  // if following partial match, the remaning gets smaller than this, remove from book and refund:\n', '  // generally we make this 10% of baseMinInitialSize\n', '  uint baseMinRemainingSize; // set at init\n', '\n', '  // maximum order size (exclusive)\n', '  // chosen so that even multiplied by the max price (or divided by the min price),\n', '  // and then multiplied by ethRwrdRate, it still fits in 2^127, allowing us to save\n', '  // some gas by storing executed + fee fields as uint128.\n', '  // even with 18 decimals, this still allows order sizes up to 1,000,000,000.\n', "  // if we encounter a token with e.g. 36 decimals we'll have to revisit ...\n", '  uint constant baseMaxSize = 10 ** 30;\n', '\n', '  // the counter currency (ETH)\n', '  // (no address because it is ETH)\n', '\n', '  // avoid the book getting cluttered up with tiny amounts not worth the gas\n', '  uint constant cntrMinInitialSize = 10 finney;\n', '\n', '  // see comments for baseMaxSize\n', '  uint constant cntrMaxSize = 10 ** 30;\n', '\n', '  // the reward token that can be used to pay fees (UBI)\n', '\n', '  ERC20 rwrdToken; // set at init\n', '\n', '  // used to convert ETH amount to reward tokens when paying fee with reward tokens\n', '  uint constant ethRwrdRate = 1000;\n', '  \n', '  // funds that belong to clients (base, counter, and reward)\n', '\n', '  mapping (address => uint) balanceBaseForClient;\n', '  mapping (address => uint) balanceCntrForClient;\n', '  mapping (address => uint) balanceRwrdForClient;\n', '\n', '  // fee charged on liquidity taken, expressed as a divisor\n', '  // (e.g. 2000 means 1/2000, or 0.05%)\n', '\n', '  uint constant feeDivisor = 2000;\n', '  \n', '  // fees charged are given to:\n', '  \n', '  address feeCollector; // set at init\n', '\n', '  // all orders ever created\n', '  \n', '  mapping (uint128 => Order) orderForOrderId;\n', '\n', '  // Effectively a compact mapping from price to whether there are any open orders at that price.\n', '  // See "Price Calculation Constants" below as to why 85.\n', '\n', '  uint256[85] occupiedPriceBitmaps;\n', '\n', '  // These allow us to walk over the orders in the book at a given price level (and add more).\n', '\n', '  mapping (uint16 => OrderChain) orderChainForOccupiedPrice;\n', '  mapping (uint128 => OrderChainNode) orderChainNodeForOpenOrderId;\n', '\n', '  // These allow a client to (reasonably) efficiently find their own orders\n', '  // without relying on events (which even indexed are a bit expensive to search\n', '  // and cannot be accessed from smart contracts). See walkOrders.\n', '\n', '  mapping (address => uint128) mostRecentOrderIdForClient;\n', '  mapping (uint128 => uint128) clientPreviousOrderIdBeforeOrderId;\n', '\n', '  // Price Calculation Constants.\n', '  //\n', '  // We pack direction and price into a crafty decimal floating point representation\n', '  // for efficient indexing by price, the main thing we lose by doing so is precision -\n', '  // we only have 3 significant figures in our prices.\n', '  //\n', '  // An unpacked price consists of:\n', '  //\n', '  //   direction - invalid / buy / sell\n', '  //   mantissa  - ranges from 100 to 999 representing 0.100 to 0.999\n', '  //   exponent  - ranges from minimumPriceExponent to minimumPriceExponent + 11\n', '  //               (e.g. -5 to +6 for a typical pair where minPriceExponent = -5)\n', '  //\n', '  // The packed representation has 21601 different price values:\n', '  //\n', '  //      0  = invalid (can be used as marker value)\n', '  //      1  = buy at maximum price (0.999 * 10 ** 6)\n', '  //    ...  = other buy prices in descending order\n', '  //   5400  = buy at 1.00\n', '  //    ...  = other buy prices in descending order\n', '  //  10800  = buy at minimum price (0.100 * 10 ** -5)\n', '  //  10801  = sell at minimum price (0.100 * 10 ** -5)\n', '  //    ...  = other sell prices in descending order\n', '  //  16201  = sell at 1.00\n', '  //    ...  = other sell prices in descending order\n', '  //  21600  = sell at maximum price (0.999 * 10 ** 6)\n', '  //  21601+ = do not use\n', '  //\n', '  // If we want to map each packed price to a boolean value (which we do),\n', '  // we require 85 256-bit words. Or 42.5 for each side of the book.\n', '  \n', '  int8 minPriceExponent; // set at init\n', '\n', '  uint constant invalidPrice = 0;\n', '\n', '  // careful: max = largest unpacked value, not largest packed value\n', '  uint constant maxBuyPrice = 1; \n', '  uint constant minBuyPrice = 10800;\n', '  uint constant minSellPrice = 10801;\n', '  uint constant maxSellPrice = 21600;\n', '\n', '  // Constructor.\n', '  //\n', '  // Sets feeCollector to the creator. Creator needs to call init() to finish setup.\n', '  //\n', '  function BookERC20EthV1p1y() {\n', '    address creator = msg.sender;\n', '    feeCollector = creator;\n', '  }\n', '\n', '  // "Public" Management - set address of base and reward tokens.\n', '  //\n', '  // Can only be done once (normally immediately after creation) by the fee collector.\n', '  //\n', '  // Used instead of a constructor to make deployment easier.\n', '  //\n', '  // baseMinInitialSize is the minimum order size in token-wei;\n', '  // the minimum resting size will be one tenth of that.\n', '  //\n', '  // minPriceExponent controls the range of prices supported by the contract;\n', '  // the range will be 0.100*10**minPriceExponent to 0.999*10**(minPriceExponent + 11)\n', '  // but careful; this is in token-wei : wei, ignoring the number of decimals of the token\n', '  // e.g. -5 implies 1 token-wei worth between 0.100e-5 to 0.999e+6 wei\n', '  // which implies same token:eth exchange rate if token decimals are 18 like eth,\n', '  // but if token decimals are 8, that would imply 1 token worth 10 wei to 0.000999 ETH.\n', '  //\n', '  function init(ERC20 _baseToken, ERC20 _rwrdToken, uint _baseMinInitialSize, int8 _minPriceExponent) public {\n', '    require(msg.sender == feeCollector);\n', '    require(address(baseToken) == 0);\n', '    require(address(_baseToken) != 0);\n', '    require(address(rwrdToken) == 0);\n', '    require(address(_rwrdToken) != 0);\n', '    require(_baseMinInitialSize >= 10);\n', '    require(_baseMinInitialSize < baseMaxSize / 1000000);\n', '    require(_minPriceExponent >= -20 && _minPriceExponent <= 20);\n', '    if (_minPriceExponent < 2) {\n', '      require(_baseMinInitialSize >= 10 ** uint(3-int(minPriceExponent)));\n', '    }\n', '    baseMinInitialSize = _baseMinInitialSize;\n', '    // dust prevention. truncation ok, know >= 10\n', '    baseMinRemainingSize = _baseMinInitialSize / 10;\n', '    minPriceExponent = _minPriceExponent;\n', '    // attempt to catch bad tokens (disabled for YOLO)\n', '    //require(_baseToken.totalSupply() > 0);\n', '    baseToken = _baseToken;\n', '    require(_rwrdToken.totalSupply() > 0);\n', '    rwrdToken = _rwrdToken;\n', '  }\n', '\n', '  // "Public" Management - change fee collector\n', '  //\n', '  // The new fee collector only gets fees charged after this point.\n', '  //\n', '  function changeFeeCollector(address newFeeCollector) public {\n', '    address oldFeeCollector = feeCollector;\n', '    require(msg.sender == oldFeeCollector);\n', '    require(newFeeCollector != oldFeeCollector);\n', '    feeCollector = newFeeCollector;\n', '  }\n', '  \n', '  // Public Info View - what is being traded here, what are the limits?\n', '  //\n', '  function getBookInfo() public constant returns (\n', '      BookType _bookType, address _baseToken, address _rwrdToken,\n', '      uint _baseMinInitialSize, uint _cntrMinInitialSize, int8 _minPriceExponent,\n', '      uint _feeDivisor, address _feeCollector\n', '    ) {\n', '    return (\n', '      BookType.ERC20EthV1,\n', '      address(baseToken),\n', '      address(rwrdToken),\n', '      baseMinInitialSize, // can assume min resting size is one tenth of this\n', '      cntrMinInitialSize,\n', '      minPriceExponent,\n', '      feeDivisor,\n', '      feeCollector\n', '    );\n', '  }\n', '\n', '  // Public Funds View - get balances held by contract on behalf of the client,\n', '  // or balances approved for deposit but not yet claimed by the contract.\n', '  //\n', '  // Excludes funds in open orders.\n', '  //\n', '  // Helps a web ui get a consistent snapshot of balances.\n', '  //\n', "  // It would be nice to return the off-exchange ETH balance too but there's a\n", '  // bizarre bug in geth (and apparently as a result via MetaMask) that leads\n', '  // to unpredictable behaviour when looking up client balances in constant\n', '  // functions - see e.g. https://github.com/ethereum/solidity/issues/2325 .\n', '  //\n', '  function getClientBalances(address client) public constant returns (\n', '      uint bookBalanceBase,\n', '      uint bookBalanceCntr,\n', '      uint bookBalanceRwrd,\n', '      uint approvedBalanceBase,\n', '      uint approvedBalanceRwrd,\n', '      uint ownBalanceBase,\n', '      uint ownBalanceRwrd\n', '    ) {\n', '    bookBalanceBase = balanceBaseForClient[client];\n', '    bookBalanceCntr = balanceCntrForClient[client];\n', '    bookBalanceRwrd = balanceRwrdForClient[client];\n', '    approvedBalanceBase = baseToken.allowance(client, address(this));\n', '    approvedBalanceRwrd = rwrdToken.allowance(client, address(this));\n', '    ownBalanceBase = baseToken.balanceOf(client);\n', '    ownBalanceRwrd = rwrdToken.balanceOf(client);\n', '  }\n', '\n', '  // Public Funds Manipulation - deposit previously-approved base tokens.\n', '  //\n', '  function transferFromBase() public {\n', '    address client = msg.sender;\n', '    address book = address(this);\n', '    // we trust the ERC20 token contract not to do nasty things like call back into us -\n', '    // if we cannot trust the token then why are we allowing it to be traded?\n', '    uint amountBase = baseToken.allowance(client, book);\n', '    require(amountBase > 0);\n', "    // NB: needs change for older ERC20 tokens that don't return bool\n", '    require(baseToken.transferFrom(client, book, amountBase));\n', '    // belt and braces\n', '    assert(baseToken.allowance(client, book) == 0);\n', '    balanceBaseForClient[client] += amountBase;\n', '    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Base, int(amountBase));\n', '  }\n', '\n', '  // Public Funds Manipulation - withdraw base tokens (as a transfer).\n', '  //\n', '  function transferBase(uint amountBase) public {\n', '    address client = msg.sender;\n', '    require(amountBase > 0);\n', '    require(amountBase <= balanceBaseForClient[client]);\n', '    // overflow safe since we checked less than balance above\n', '    balanceBaseForClient[client] -= amountBase;\n', '    // we trust the ERC20 token contract not to do nasty things like call back into us -\n', '    // if we cannot trust the token then why are we allowing it to be traded?\n', "    // NB: needs change for older ERC20 tokens that don't return bool\n", '    require(baseToken.transfer(client, amountBase));\n', '    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase));\n', '  }\n', '\n', '  // Public Funds Manipulation - deposit counter currency (ETH).\n', '  //\n', '  function depositCntr() public payable {\n', '    address client = msg.sender;\n', '    uint amountCntr = msg.value;\n', '    require(amountCntr > 0);\n', '    // overflow safe - if someone owns pow(2,255) ETH we have bigger problems\n', '    balanceCntrForClient[client] += amountCntr;\n', '    ClientPaymentEvent(client, ClientPaymentEventType.Deposit, BalanceType.Cntr, int(amountCntr));\n', '  }\n', '\n', '  // Public Funds Manipulation - withdraw counter currency (ETH).\n', '  //\n', '  function withdrawCntr(uint amountCntr) public {\n', '    address client = msg.sender;\n', '    require(amountCntr > 0);\n', '    require(amountCntr <= balanceCntrForClient[client]);\n', '    // overflow safe - checked less than balance above\n', '    balanceCntrForClient[client] -= amountCntr;\n', '    // safe - not enough gas to do anything interesting in fallback, already adjusted balance\n', '    client.transfer(amountCntr);\n', '    ClientPaymentEvent(client, ClientPaymentEventType.Withdraw, BalanceType.Cntr, -int(amountCntr));\n', '  }\n', '\n', '  // Public Funds Manipulation - deposit previously-approved reward tokens.\n', '  //\n', '  function transferFromRwrd() public {\n', '    address client = msg.sender;\n', '    address book = address(this);\n', '    uint amountRwrd = rwrdToken.allowance(client, book);\n', '    require(amountRwrd > 0);\n', '    // we wrote the reward token so we know it supports ERC20 properly and is not evil\n', '    require(rwrdToken.transferFrom(client, book, amountRwrd));\n', '    // belt and braces\n', '    assert(rwrdToken.allowance(client, book) == 0);\n', '    balanceRwrdForClient[client] += amountRwrd;\n', '    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Rwrd, int(amountRwrd));\n', '  }\n', '\n', '  // Public Funds Manipulation - withdraw base tokens (as a transfer).\n', '  //\n', '  function transferRwrd(uint amountRwrd) public {\n', '    address client = msg.sender;\n', '    require(amountRwrd > 0);\n', '    require(amountRwrd <= balanceRwrdForClient[client]);\n', '    // overflow safe - checked less than balance above\n', '    balanceRwrdForClient[client] -= amountRwrd;\n', '    // we wrote the reward token so we know it supports ERC20 properly and is not evil\n', '    require(rwrdToken.transfer(client, amountRwrd));\n', '    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Rwrd, -int(amountRwrd));\n', '  }\n', '\n', '  // Public Order View - get full details of an order.\n', '  //\n', '  // If the orderId does not exist, status will be Unknown.\n', '  //\n', '  function getOrder(uint128 orderId) public constant returns (\n', '    address client, uint16 price, uint sizeBase, Terms terms,\n', '    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n', '    uint feesBaseOrCntr, uint feesRwrd) {\n', '    Order storage order = orderForOrderId[orderId];\n', '    return (order.client, order.price, order.sizeBase, order.terms,\n', '            order.status, order.reasonCode, order.executedBase, order.executedCntr,\n', '            order.feesBaseOrCntr, order.feesRwrd);\n', '  }\n', '\n', '  // Public Order View - get mutable details of an order.\n', '  //\n', '  // If the orderId does not exist, status will be Unknown.\n', '  //\n', '  function getOrderState(uint128 orderId) public constant returns (\n', '    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n', '    uint feesBaseOrCntr, uint feesRwrd) {\n', '    Order storage order = orderForOrderId[orderId];\n', '    return (order.status, order.reasonCode, order.executedBase, order.executedCntr,\n', '            order.feesBaseOrCntr, order.feesRwrd);\n', '  }\n', '  \n', '  // Public Order View - enumerate all recent orders + all open orders for one client.\n', '  //\n', '  // Not really designed for use from a smart contract transaction.\n', '  //\n', '  // Idea is:\n', '  //  - client ensures order ids are generated so that most-signficant part is time-based;\n', '  //  - client decides they want all orders after a certain point-in-time,\n', '  //    and chooses minClosedOrderIdCutoff accordingly;\n', '  //  - before that point-in-time they just get open and needs gas orders\n', '  //  - client calls walkClientOrders with maybeLastOrderIdReturned = 0 initially;\n', '  //  - then repeats with the orderId returned by walkClientOrders;\n', '  //  - (and stops if it returns a zero orderId);\n', '  //\n', '  // Note that client is only used when maybeLastOrderIdReturned = 0.\n', '  //\n', '  function walkClientOrders(\n', '      address client, uint128 maybeLastOrderIdReturned, uint128 minClosedOrderIdCutoff\n', '    ) public constant returns (\n', '      uint128 orderId, uint16 price, uint sizeBase, Terms terms,\n', '      Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n', '      uint feesBaseOrCntr, uint feesRwrd) {\n', '    if (maybeLastOrderIdReturned == 0) {\n', '      orderId = mostRecentOrderIdForClient[client];\n', '    } else {\n', '      orderId = clientPreviousOrderIdBeforeOrderId[maybeLastOrderIdReturned];\n', '    }\n', '    while (true) {\n', '      if (orderId == 0) return;\n', '      Order storage order = orderForOrderId[orderId];\n', '      if (orderId >= minClosedOrderIdCutoff) break;\n', '      if (order.status == Status.Open || order.status == Status.NeedsGas) break;\n', '      orderId = clientPreviousOrderIdBeforeOrderId[orderId];\n', '    }\n', '    return (orderId, order.price, order.sizeBase, order.terms,\n', '            order.status, order.reasonCode, order.executedBase, order.executedCntr,\n', '            order.feesBaseOrCntr, order.feesRwrd);\n', '  }\n', ' \n', '  // Internal Price Calculation - turn packed price into a friendlier unpacked price.\n', '  //\n', '  function unpackPrice(uint16 price) internal constant returns (\n', '      Direction direction, uint16 mantissa, int8 exponent\n', '    ) {\n', '    uint sidedPriceIndex = uint(price);\n', '    uint priceIndex;\n', '    if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) {\n', '      direction = Direction.Invalid;\n', '      mantissa = 0;\n', '      exponent = 0;\n', '      return;\n', '    } else if (sidedPriceIndex <= minBuyPrice) {\n', '      direction = Direction.Buy;\n', '      priceIndex = minBuyPrice - sidedPriceIndex;\n', '    } else {\n', '      direction = Direction.Sell;\n', '      priceIndex = sidedPriceIndex - minSellPrice;\n', '    }\n', '    uint zeroBasedMantissa = priceIndex % 900;\n', '    uint zeroBasedExponent = priceIndex / 900;\n', '    mantissa = uint16(zeroBasedMantissa + 100);\n', '    exponent = int8(zeroBasedExponent) + minPriceExponent;\n', '    return;\n', '  }\n', '  \n', '  // Internal Price Calculation - is a packed price on the buy side?\n', '  //\n', '  // Throws an error if price is invalid.\n', '  //\n', '  function isBuyPrice(uint16 price) internal constant returns (bool isBuy) {\n', '    // yes, this looks odd, but max here is highest _unpacked_ price\n', '    return price >= maxBuyPrice && price <= minBuyPrice;\n', '  }\n', '  \n', '  // Internal Price Calculation - turn a packed buy price into a packed sell price.\n', '  //\n', '  // Invalid price remains invalid.\n', '  //\n', '  function computeOppositePrice(uint16 price) internal constant returns (uint16 opposite) {\n', '    if (price < maxBuyPrice || price > maxSellPrice) {\n', '      return uint16(invalidPrice);\n', '    } else if (price <= minBuyPrice) {\n', '      return uint16(maxSellPrice - (price - maxBuyPrice));\n', '    } else {\n', '      return uint16(maxBuyPrice + (maxSellPrice - price));\n', '    }\n', '  }\n', '  \n', '  // Internal Price Calculation - compute amount in counter currency that would\n', '  // be obtained by selling baseAmount at the given unpacked price (if no fees).\n', '  //\n', '  // Notes:\n', '  //  - Does not validate price - caller must ensure valid.\n', '  //  - Could overflow producing very unexpected results if baseAmount very\n', '  //    large - caller must check this.\n', '  //  - This rounds the amount towards zero.\n', '  //  - May truncate to zero if baseAmount very small - potentially allowing\n', '  //    zero-cost buys or pointless sales - caller must check this.\n', '  //\n', '  function computeCntrAmountUsingUnpacked(\n', '      uint baseAmount, uint16 mantissa, int8 exponent\n', '    ) internal constant returns (uint cntrAmount) {\n', '    if (exponent < 0) {\n', '      return baseAmount * uint(mantissa) / 1000 / 10 ** uint(-exponent);\n', '    } else {\n', '      return baseAmount * uint(mantissa) / 1000 * 10 ** uint(exponent);\n', '    }\n', '  }\n', '\n', '  // Internal Price Calculation - compute amount in counter currency that would\n', '  // be obtained by selling baseAmount at the given packed price (if no fees).\n', '  //\n', '  // Notes:\n', '  //  - Does not validate price - caller must ensure valid.\n', '  //  - Direction of the packed price is ignored.\n', '  //  - Could overflow producing very unexpected results if baseAmount very\n', '  //    large - caller must check this.\n', '  //  - This rounds the amount towards zero (regardless of Buy or Sell).\n', '  //  - May truncate to zero if baseAmount very small - potentially allowing\n', '  //    zero-cost buys or pointless sales - caller must check this.\n', '  //\n', '  function computeCntrAmountUsingPacked(\n', '      uint baseAmount, uint16 price\n', '    ) internal constant returns (uint) {\n', '    var (, mantissa, exponent) = unpackPrice(price);\n', '    return computeCntrAmountUsingUnpacked(baseAmount, mantissa, exponent);\n', '  }\n', '\n', '  // Public Order Placement - create order and try to match it and/or add it to the book.\n', '  //\n', '  function createOrder(\n', '      uint128 orderId, uint16 price, uint sizeBase, Terms terms, uint maxMatches\n', '    ) public {\n', '    address client = msg.sender;\n', '    require(orderId != 0 && orderForOrderId[orderId].client == 0);\n', '    ClientOrderEvent(client, ClientOrderEventType.Create, orderId, maxMatches);\n', '    orderForOrderId[orderId] =\n', '      Order(client, price, sizeBase, terms, Status.Unknown, ReasonCode.None, 0, 0, 0, 0);\n', '    uint128 previousMostRecentOrderIdForClient = mostRecentOrderIdForClient[client];\n', '    mostRecentOrderIdForClient[client] = orderId;\n', '    clientPreviousOrderIdBeforeOrderId[orderId] = previousMostRecentOrderIdForClient;\n', '    Order storage order = orderForOrderId[orderId];\n', '    var (direction, mantissa, exponent) = unpackPrice(price);\n', '    if (direction == Direction.Invalid) {\n', '      order.status = Status.Rejected;\n', '      order.reasonCode = ReasonCode.InvalidPrice;\n', '      return;\n', '    }\n', '    if (sizeBase < baseMinInitialSize || sizeBase > baseMaxSize) {\n', '      order.status = Status.Rejected;\n', '      order.reasonCode = ReasonCode.InvalidSize;\n', '      return;\n', '    }\n', '    uint sizeCntr = computeCntrAmountUsingUnpacked(sizeBase, mantissa, exponent);\n', '    if (sizeCntr < cntrMinInitialSize || sizeCntr > cntrMaxSize) {\n', '      order.status = Status.Rejected;\n', '      order.reasonCode = ReasonCode.InvalidSize;\n', '      return;\n', '    }\n', '    if (terms == Terms.MakerOnly && maxMatches != 0) {\n', '      order.status = Status.Rejected;\n', '      order.reasonCode = ReasonCode.InvalidTerms;\n', '      return;\n', '    }\n', '    if (!debitFunds(client, direction, sizeBase, sizeCntr)) {\n', '      order.status = Status.Rejected;\n', '      order.reasonCode = ReasonCode.InsufficientFunds;\n', '      return;\n', '    }\n', '    processOrder(orderId, maxMatches);\n', '  }\n', '\n', '  // Public Order Placement - cancel order\n', '  //\n', '  function cancelOrder(uint128 orderId) public {\n', '    address client = msg.sender;\n', '    Order storage order = orderForOrderId[orderId];\n', '    require(order.client == client);\n', '    Status status = order.status;\n', '    if (status != Status.Open && status != Status.NeedsGas) {\n', '      return;\n', '    }\n', '    ClientOrderEvent(client, ClientOrderEventType.Cancel, orderId, 0);\n', '    if (status == Status.Open) {\n', '      removeOpenOrderFromBook(orderId);\n', '      MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Remove, order.price,\n', '        order.sizeBase - order.executedBase, 0);\n', '    }\n', '    refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.ClientCancel);\n', '  }\n', '\n', "  // Public Order Placement - continue placing an order in 'NeedsGas' state\n", '  //\n', '  function continueOrder(uint128 orderId, uint maxMatches) public {\n', '    address client = msg.sender;\n', '    Order storage order = orderForOrderId[orderId];\n', '    require(order.client == client);\n', '    if (order.status != Status.NeedsGas) {\n', '      return;\n', '    }\n', '    ClientOrderEvent(client, ClientOrderEventType.Continue, orderId, maxMatches);\n', '    order.status = Status.Unknown;\n', '    processOrder(orderId, maxMatches);\n', '  }\n', '\n', '  // Internal Order Placement - remove a still-open order from the book.\n', '  //\n', "  // Caller's job to update/refund the order + raise event, this just\n", '  // updates the order chain and bitmask.\n', '  //\n', '  // Too expensive to do on each resting order match - we only do this for an\n', '  // order being cancelled. See matchWithOccupiedPrice for similar logic.\n', '  //\n', '  function removeOpenOrderFromBook(uint128 orderId) internal {\n', '    Order storage order = orderForOrderId[orderId];\n', '    uint16 price = order.price;\n', '    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\n', '    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\n', '    uint128 nextOrderId = orderChainNode.nextOrderId;\n', '    uint128 prevOrderId = orderChainNode.prevOrderId;\n', '    if (nextOrderId != 0) {\n', '      OrderChainNode storage nextOrderChainNode = orderChainNodeForOpenOrderId[nextOrderId];\n', '      nextOrderChainNode.prevOrderId = prevOrderId;\n', '    } else {\n', '      orderChain.lastOrderId = prevOrderId;\n', '    }\n', '    if (prevOrderId != 0) {\n', '      OrderChainNode storage prevOrderChainNode = orderChainNodeForOpenOrderId[prevOrderId];\n', '      prevOrderChainNode.nextOrderId = nextOrderId;\n', '    } else {\n', '      orderChain.firstOrderId = nextOrderId;\n', '    }\n', '    if (nextOrderId == 0 && prevOrderId == 0) {\n', '      uint bmi = price / 256;  // index into array of bitmaps\n', '      uint bti = price % 256;  // bit position within bitmap\n', '      // we know was previously occupied so XOR clears\n', '      occupiedPriceBitmaps[bmi] ^= 2 ** bti;\n', '    }\n', '  }\n', '\n', '  // Internal Order Placement - credit funds received when taking liquidity from book\n', '  //\n', '  function creditExecutedFundsLessFees(uint128 orderId, uint originalExecutedBase, uint originalExecutedCntr) internal {\n', '    Order storage order = orderForOrderId[orderId];\n', '    uint liquidityTakenBase = order.executedBase - originalExecutedBase;\n', '    uint liquidityTakenCntr = order.executedCntr - originalExecutedCntr;\n', '    // Normally we deduct the fee from the currency bought (base for buy, cntr for sell),\n', '    // however we also accept reward tokens from the reward balance if it covers the fee,\n', '    // with the reward amount converted from the ETH amount (the counter currency here)\n', '    // at a fixed exchange rate.\n', '    // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\n', '    // Can truncate to zero, which is fine.\n', '    uint feesRwrd = liquidityTakenCntr / feeDivisor * ethRwrdRate;\n', '    uint feesBaseOrCntr;\n', '    address client = order.client;\n', '    uint availRwrd = balanceRwrdForClient[client];\n', '    if (feesRwrd <= availRwrd) {\n', '      balanceRwrdForClient[client] = availRwrd - feesRwrd;\n', '      balanceRwrdForClient[feeCollector] = feesRwrd;\n', '      // Need += rather than = because could have paid some fees earlier in NeedsGas situation.\n', '      // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\n', '      // Can truncate to zero, which is fine.\n', '      order.feesRwrd += uint128(feesRwrd);\n', '      if (isBuyPrice(order.price)) {\n', '        balanceBaseForClient[client] += liquidityTakenBase;\n', '      } else {\n', '        balanceCntrForClient[client] += liquidityTakenCntr;\n', '      }\n', '    } else if (isBuyPrice(order.price)) {\n', '      // See comments in branch above re: use of += and overflow safety.\n', '      feesBaseOrCntr = liquidityTakenBase / feeDivisor;\n', '      balanceBaseForClient[order.client] += (liquidityTakenBase - feesBaseOrCntr);\n', '      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\n', '      balanceBaseForClient[feeCollector] += feesBaseOrCntr;\n', '    } else {\n', '      // See comments in branch above re: use of += and overflow safety.\n', '      feesBaseOrCntr = liquidityTakenCntr / feeDivisor;\n', '      balanceCntrForClient[order.client] += (liquidityTakenCntr - feesBaseOrCntr);\n', '      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\n', '      balanceCntrForClient[feeCollector] += feesBaseOrCntr;\n', '    }\n', '  }\n', '\n', '  // Internal Order Placement - process a created and sanity checked order.\n', '  //\n', '  // Used both for new orders and for gas topup.\n', '  //\n', '  function processOrder(uint128 orderId, uint maxMatches) internal {\n', '    Order storage order = orderForOrderId[orderId];\n', '\n', '    uint ourOriginalExecutedBase = order.executedBase;\n', '    uint ourOriginalExecutedCntr = order.executedCntr;\n', '\n', '    var (ourDirection,) = unpackPrice(order.price);\n', '    uint theirPriceStart = (ourDirection == Direction.Buy) ? minSellPrice : maxBuyPrice;\n', '    uint theirPriceEnd = computeOppositePrice(order.price);\n', '   \n', '    MatchStopReason matchStopReason =\n', '      matchAgainstBook(orderId, theirPriceStart, theirPriceEnd, maxMatches);\n', '\n', '    creditExecutedFundsLessFees(orderId, ourOriginalExecutedBase, ourOriginalExecutedCntr);\n', '\n', '    if (order.terms == Terms.ImmediateOrCancel) {\n', '      if (matchStopReason == MatchStopReason.Satisfied) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.Unmatched);\n', '        return;\n', '      }\n', '    } else if (order.terms == Terms.MakerOnly) {\n', '      if (matchStopReason == MatchStopReason.MaxMatches) {\n', '        refundUnmatchedAndFinish(orderId, Status.Rejected, ReasonCode.WouldTake);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n', '        enterOrder(orderId);\n', '        return;\n', '      }\n', '    } else if (order.terms == Terms.GTCNoGasTopup) {\n', '      if (matchStopReason == MatchStopReason.Satisfied) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n', '        enterOrder(orderId);\n', '        return;\n', '      }\n', '    } else if (order.terms == Terms.GTCWithGasTopup) {\n', '      if (matchStopReason == MatchStopReason.Satisfied) {\n', '        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n', '        order.status = Status.NeedsGas;\n', '        return;\n', '      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n', '        enterOrder(orderId);\n', '        return;\n', '      }\n', '    }\n', '    assert(false); // should not be possible to reach here\n', '  }\n', ' \n', '  // Used internally to indicate why we stopped matching an order against the book.\n', '\n', '  enum MatchStopReason {\n', '    None,\n', '    MaxMatches,\n', '    Satisfied,\n', '    PriceExhausted,\n', '    BookExhausted\n', '  }\n', ' \n', '  // Internal Order Placement - Match the given order against the book.\n', '  //\n', '  // Resting orders matched will be updated, removed from book and funds credited to their owners.\n', '  //\n', '  // Only updates the executedBase and executedCntr of the given order - caller is responsible\n', '  // for crediting matched funds, charging fees, marking order as done / entering it into the book.\n', '  //\n', '  // matchStopReason returned will be one of MaxMatches, Satisfied or BookExhausted.\n', '  //\n', '  // Calling with maxMatches == 0 is ok - and expected when the order is a maker-only order.\n', '  //\n', '  function matchAgainstBook(\n', '      uint128 orderId, uint theirPriceStart, uint theirPriceEnd, uint maxMatches\n', '    ) internal returns (\n', '      MatchStopReason matchStopReason\n', '    ) {\n', '    Order storage order = orderForOrderId[orderId];\n', '    \n', '    uint bmi = theirPriceStart / 256;  // index into array of bitmaps\n', '    uint bti = theirPriceStart % 256;  // bit position within bitmap\n', '    uint bmiEnd = theirPriceEnd / 256; // last bitmap to search\n', '    uint btiEnd = theirPriceEnd % 256; // stop at this bit in the last bitmap\n', '\n', '    uint cbm = occupiedPriceBitmaps[bmi]; // original copy of current bitmap\n', '    uint dbm = cbm; // dirty version of current bitmap where we may have cleared bits\n', '    uint wbm = cbm >> bti; // working copy of current bitmap which we keep shifting\n', '    \n', '    // these loops are pretty ugly, and somewhat unpredicatable in terms of gas,\n', '    // ... but no-one else has come up with a better matching engine yet!\n', '\n', '    bool removedLastAtPrice;\n', '    matchStopReason = MatchStopReason.None;\n', '\n', '    while (bmi < bmiEnd) {\n', '      if (wbm == 0 || bti == 256) {\n', '        if (dbm != cbm) {\n', '          occupiedPriceBitmaps[bmi] = dbm;\n', '        }\n', '        bti = 0;\n', '        bmi++;\n', '        cbm = occupiedPriceBitmaps[bmi];\n', '        wbm = cbm;\n', '        dbm = cbm;\n', '      } else {\n', '        if ((wbm & 1) != 0) {\n', '          // careful - copy-and-pasted in loop below ...\n', '          (removedLastAtPrice, maxMatches, matchStopReason) =\n', '            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\n', '          if (removedLastAtPrice) {\n', '            dbm ^= 2 ** bti;\n', '          }\n', '          if (matchStopReason == MatchStopReason.PriceExhausted) {\n', '            matchStopReason = MatchStopReason.None;\n', '          } else if (matchStopReason != MatchStopReason.None) {\n', '            // we might still have changes in dbm to write back - see later\n', '            break;\n', '          }\n', '        }\n', '        bti += 1;\n', '        wbm /= 2;\n', '      }\n', '    }\n', '    if (matchStopReason == MatchStopReason.None) {\n', "      // we've reached the last bitmap we need to search,\n", "      // we'll stop at btiEnd not 256 this time.\n", '      while (bti <= btiEnd && wbm != 0) {\n', '        if ((wbm & 1) != 0) {\n', '          // careful - copy-and-pasted in loop above ...\n', '          (removedLastAtPrice, maxMatches, matchStopReason) =\n', '            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\n', '          if (removedLastAtPrice) {\n', '            dbm ^= 2 ** bti;\n', '          }\n', '          if (matchStopReason == MatchStopReason.PriceExhausted) {\n', '            matchStopReason = MatchStopReason.None;\n', '          } else if (matchStopReason != MatchStopReason.None) {\n', '            break;\n', '          }\n', '        }\n', '        bti += 1;\n', '        wbm /= 2;\n', '      }\n', '    }\n', '    // Careful - if we exited the first loop early, or we went into the second loop,\n', "    // (luckily can't both happen) then we haven't flushed the dirty bitmap back to\n", '    // storage - do that now if we need to.\n', '    if (dbm != cbm) {\n', '      occupiedPriceBitmaps[bmi] = dbm;\n', '    }\n', '    if (matchStopReason == MatchStopReason.None) {\n', '      matchStopReason = MatchStopReason.BookExhausted;\n', '    }\n', '  }\n', '\n', '  // Internal Order Placement.\n', '  //\n', '  // Match our order against up to maxMatches resting orders at the given price (which\n', '  // is known by the caller to have at least one resting order).\n', '  //\n', '  // The matches (partial or complete) of the resting orders are recorded, and their\n', '  // funds are credited.\n', '  //\n', '  // The order chain for the resting orders is updated, but the occupied price bitmap is NOT -\n', '  // the caller must clear the relevant bit if removedLastAtPrice = true is returned.\n', '  //\n', '  // Only updates the executedBase and executedCntr of our order - caller is responsible\n', '  // for e.g. crediting our matched funds, updating status.\n', '  //\n', '  // Calling with maxMatches == 0 is ok - and expected when the order is a maker-only order.\n', '  //\n', '  // Returns:\n', '  //   removedLastAtPrice:\n', '  //     true iff there are no longer any resting orders at this price - caller will need\n', '  //     to update the occupied price bitmap.\n', '  //\n', '  //   matchesLeft:\n', '  //     maxMatches passed in minus the number of matches made by this call\n', '  //\n', '  //   matchStopReason:\n', '  //     If our order is completely matched, matchStopReason will be Satisfied.\n', '  //     If our order is not completely matched, matchStopReason will be either:\n', '  //        MaxMatches (we are not allowed to match any more times)\n', '  //     or:\n', '  //        PriceExhausted (nothing left on the book at this exact price)\n', '  //\n', '  function matchWithOccupiedPrice(\n', '      Order storage ourOrder, uint16 theirPrice, uint maxMatches\n', '    ) internal returns (\n', '    bool removedLastAtPrice, uint matchesLeft, MatchStopReason matchStopReason) {\n', '    matchesLeft = maxMatches;\n', '    uint workingOurExecutedBase = ourOrder.executedBase;\n', '    uint workingOurExecutedCntr = ourOrder.executedCntr;\n', '    uint128 theirOrderId = orderChainForOccupiedPrice[theirPrice].firstOrderId;\n', '    matchStopReason = MatchStopReason.None;\n', '    while (true) {\n', '      if (matchesLeft == 0) {\n', '        matchStopReason = MatchStopReason.MaxMatches;\n', '        break;\n', '      }\n', '      uint matchBase;\n', '      uint matchCntr;\n', '      (theirOrderId, matchBase, matchCntr, matchStopReason) =\n', '        matchWithTheirs((ourOrder.sizeBase - workingOurExecutedBase), theirOrderId, theirPrice);\n', '      workingOurExecutedBase += matchBase;\n', '      workingOurExecutedCntr += matchCntr;\n', '      matchesLeft -= 1;\n', '      if (matchStopReason != MatchStopReason.None) {\n', '        break;\n', '      }\n', '    }\n', '    ourOrder.executedBase = uint128(workingOurExecutedBase);\n', '    ourOrder.executedCntr = uint128(workingOurExecutedCntr);\n', '    if (theirOrderId == 0) {\n', '      orderChainForOccupiedPrice[theirPrice].firstOrderId = 0;\n', '      orderChainForOccupiedPrice[theirPrice].lastOrderId = 0;\n', '      removedLastAtPrice = true;\n', '    } else {\n', '      // NB: in some cases (e.g. maxMatches == 0) this is a no-op.\n', '      orderChainForOccupiedPrice[theirPrice].firstOrderId = theirOrderId;\n', '      orderChainNodeForOpenOrderId[theirOrderId].prevOrderId = 0;\n', '      removedLastAtPrice = false;\n', '    }\n', '  }\n', '  \n', '  // Internal Order Placement.\n', '  //\n', '  // Match up to our remaining amount against a resting order in the book.\n', '  //\n', '  // The match (partial, complete or effectively-complete) of the resting order\n', '  // is recorded, and their funds are credited.\n', '  //\n', '  // Their order is NOT removed from the book by this call - the caller must do that\n', '  // if the nextTheirOrderId returned is not equal to the theirOrderId passed in.\n', '  //\n', '  // Returns:\n', '  //\n', '  //   nextTheirOrderId:\n', '  //     If we did not completely match their order, will be same as theirOrderId.\n', '  //     If we completely matched their order, will be orderId of next order at the\n', "  //     same price - or zero if this was the last order and we've now filled it.\n", '  //\n', '  //   matchStopReason:\n', '  //     If our order is completely matched, matchStopReason will be Satisfied.\n', '  //     If our order is not completely matched, matchStopReason will be either\n', '  //     PriceExhausted (if nothing left at this exact price) or None (if can continue).\n', '  // \n', '  function matchWithTheirs(\n', '    uint ourRemainingBase, uint128 theirOrderId, uint16 theirPrice) internal returns (\n', '    uint128 nextTheirOrderId, uint matchBase, uint matchCntr, MatchStopReason matchStopReason) {\n', '    Order storage theirOrder = orderForOrderId[theirOrderId];\n', '    uint theirRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\n', '    if (ourRemainingBase < theirRemainingBase) {\n', '      matchBase = ourRemainingBase;\n', '    } else {\n', '      matchBase = theirRemainingBase;\n', '    }\n', '    matchCntr = computeCntrAmountUsingPacked(matchBase, theirPrice);\n', '    // It may seem a bit odd to stop here if our remaining amount is very small -\n', '    // there could still be resting orders we can match it against. But the gas\n', '    // cost of matching each order is quite high - potentially high enough to\n', '    // wipe out the profit the taker hopes for from trading the tiny amount left.\n', '    if ((ourRemainingBase - matchBase) < baseMinRemainingSize) {\n', '      matchStopReason = MatchStopReason.Satisfied;\n', '    } else {\n', '      matchStopReason = MatchStopReason.None;\n', '    }\n', '    bool theirsDead = recordTheirMatch(theirOrder, theirOrderId, theirPrice, matchBase, matchCntr);\n', '    if (theirsDead) {\n', '      nextTheirOrderId = orderChainNodeForOpenOrderId[theirOrderId].nextOrderId;\n', '      if (matchStopReason == MatchStopReason.None && nextTheirOrderId == 0) {\n', '        matchStopReason = MatchStopReason.PriceExhausted;\n', '      }\n', '    } else {\n', '      nextTheirOrderId = theirOrderId;\n', '    }\n', '  }\n', '\n', '  // Internal Order Placement.\n', '  //\n', '  // Record match (partial or complete) of resting order, and credit them their funds.\n', '  //\n', '  // If their order is completely matched, the order is marked as done,\n', '  // and "theirsDead" is returned as true.\n', '  //\n', '  // The order is NOT removed from the book by this call - the caller\n', '  // must do that if theirsDead is true.\n', '  //\n', '  // No sanity checks are made - the caller must be sure the order is\n', "  // not already done and has sufficient remaining. (Yes, we'd like to\n", '  // check here too but we cannot afford the gas).\n', '  //\n', '  function recordTheirMatch(\n', '      Order storage theirOrder, uint128 theirOrderId, uint16 theirPrice, uint matchBase, uint matchCntr\n', '    ) internal returns (bool theirsDead) {\n', '    // they are a maker so no fees\n', '    // overflow safe - see comments about baseMaxSize\n', '    // executedBase cannot go > sizeBase due to logic in matchWithTheirs\n', '    theirOrder.executedBase += uint128(matchBase);\n', '    theirOrder.executedCntr += uint128(matchCntr);\n', '    if (isBuyPrice(theirPrice)) {\n', '      // they have bought base (using the counter they already paid when creating the order)\n', '      balanceBaseForClient[theirOrder.client] += matchBase;\n', '    } else {\n', '      // they have bought counter (using the base they already paid when creating the order)\n', '      balanceCntrForClient[theirOrder.client] += matchCntr;\n', '    }\n', '    uint stillRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\n', '    // avoid leaving tiny amounts in the book - refund remaining if too small\n', '    if (stillRemainingBase < baseMinRemainingSize) {\n', '      refundUnmatchedAndFinish(theirOrderId, Status.Done, ReasonCode.None);\n', '      // someone building an UI on top needs to know how much was match and how much was refund\n', '      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.CompleteFill,\n', '        theirPrice, matchBase + stillRemainingBase, matchBase);\n', '      return true;\n', '    } else {\n', '      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.PartialFill,\n', '        theirPrice, matchBase, matchBase);\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // Internal Order Placement.\n', '  //\n', '  // Refund any unmatched funds in an order (based on executed vs size) and move to a final state.\n', '  //\n', '  // The order is NOT removed from the book by this call and no event is raised.\n', '  //\n', '  // No sanity checks are made - the caller must be sure the order has not already been refunded.\n', '  //\n', '  function refundUnmatchedAndFinish(uint128 orderId, Status status, ReasonCode reasonCode) internal {\n', '    Order storage order = orderForOrderId[orderId];\n', '    uint16 price = order.price;\n', '    if (isBuyPrice(price)) {\n', '      uint sizeCntr = computeCntrAmountUsingPacked(order.sizeBase, price);\n', '      balanceCntrForClient[order.client] += sizeCntr - order.executedCntr;\n', '    } else {\n', '      balanceBaseForClient[order.client] += order.sizeBase - order.executedBase;\n', '    }\n', '    order.status = status;\n', '    order.reasonCode = reasonCode;\n', '  }\n', '\n', '  // Internal Order Placement.\n', '  //\n', '  // Enter a not completely matched order into the book, marking the order as open.\n', '  //\n', '  // This updates the occupied price bitmap and chain.\n', '  //\n', '  // No sanity checks are made - the caller must be sure the order\n', '  // has some unmatched amount and has been paid for!\n', '  //\n', '  function enterOrder(uint128 orderId) internal {\n', '    Order storage order = orderForOrderId[orderId];\n', '    uint16 price = order.price;\n', '    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\n', '    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\n', '    if (orderChain.firstOrderId == 0) {\n', '      orderChain.firstOrderId = orderId;\n', '      orderChain.lastOrderId = orderId;\n', '      orderChainNode.nextOrderId = 0;\n', '      orderChainNode.prevOrderId = 0;\n', '      uint bitmapIndex = price / 256;\n', '      uint bitIndex = price % 256;\n', '      occupiedPriceBitmaps[bitmapIndex] |= (2 ** bitIndex);\n', '    } else {\n', '      uint128 existingLastOrderId = orderChain.lastOrderId;\n', '      OrderChainNode storage existingLastOrderChainNode = orderChainNodeForOpenOrderId[existingLastOrderId];\n', '      orderChainNode.nextOrderId = 0;\n', '      orderChainNode.prevOrderId = existingLastOrderId;\n', '      existingLastOrderChainNode.nextOrderId = orderId;\n', '      orderChain.lastOrderId = orderId;\n', '    }\n', '    MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Add,\n', '      price, order.sizeBase - order.executedBase, 0);\n', '    order.status = Status.Open;\n', '  }\n', '\n', '  // Internal Order Placement.\n', '  //\n', '  // Charge the client for the cost of placing an order in the given direction.\n', '  //\n', '  // Return true if successful, false otherwise.\n', '  //\n', '  function debitFunds(\n', '      address client, Direction direction, uint sizeBase, uint sizeCntr\n', '    ) internal returns (bool success) {\n', '    if (direction == Direction.Buy) {\n', '      uint availableCntr = balanceCntrForClient[client];\n', '      if (availableCntr < sizeCntr) {\n', '        return false;\n', '      }\n', '      balanceCntrForClient[client] = availableCntr - sizeCntr;\n', '      return true;\n', '    } else if (direction == Direction.Sell) {\n', '      uint availableBase = balanceBaseForClient[client];\n', '      if (availableBase < sizeBase) {\n', '        return false;\n', '      }\n', '      balanceBaseForClient[client] = availableBase - sizeBase;\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // Public Book View\n', '  // \n', '  // Intended for public book depth enumeration from web3 (or similar).\n', '  //\n', '  // Not suitable for use from a smart contract transaction - gas usage\n', '  // could be very high if we have many orders at the same price.\n', '  //\n', '  // Start at the given inclusive price (and side) and walk down the book\n', '  // (getting less aggressive) until we find some open orders or reach the\n', '  // least aggressive price.\n', '  //\n', '  // Returns the price where we found the order(s), the depth at that price\n', '  // (zero if none found), order count there, and the current blockNumber.\n', '  //\n', "  // (The blockNumber is handy if you're taking a snapshot which you intend\n", '  //  to keep up-to-date with the market order events).\n', '  //\n', '  // To walk the book, the caller should start by calling walkBook with the\n', '  // most aggressive buy price (Buy @ 999000).\n', '  // If the price returned is the least aggressive buy price (Buy @ 0.000001),\n', '  // the side is complete.\n', '  // Otherwise, call walkBook again with the (packed) price returned + 1.\n', '  // Then repeat for the sell side, starting with Sell @ 0.000001 and stopping\n', '  // when Sell @ 999000 is returned.\n', '  //\n', '  function walkBook(uint16 fromPrice) public constant returns (\n', '      uint16 price, uint depthBase, uint orderCount, uint blockNumber\n', '    ) {\n', '    uint priceStart = fromPrice;\n', '    uint priceEnd = (isBuyPrice(fromPrice)) ? minBuyPrice : maxSellPrice;\n', '    \n', '    // See comments in matchAgainstBook re: how these crazy loops work.\n', '    \n', '    uint bmi = priceStart / 256;\n', '    uint bti = priceStart % 256;\n', '    uint bmiEnd = priceEnd / 256;\n', '    uint btiEnd = priceEnd % 256;\n', '\n', '    uint wbm = occupiedPriceBitmaps[bmi] >> bti;\n', '    \n', '    while (bmi < bmiEnd) {\n', '      if (wbm == 0 || bti == 256) {\n', '        bti = 0;\n', '        bmi++;\n', '        wbm = occupiedPriceBitmaps[bmi];\n', '      } else {\n', '        if ((wbm & 1) != 0) {\n', '          // careful - copy-pasted in below loop\n', '          price = uint16(bmi * 256 + bti);\n', '          (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\n', '          return (price, depthBase, orderCount, block.number);\n', '        }\n', '        bti += 1;\n', '        wbm /= 2;\n', '      }\n', '    }\n', "    // we've reached the last bitmap we need to search, stop at btiEnd not 256 this time.\n", '    while (bti <= btiEnd && wbm != 0) {\n', '      if ((wbm & 1) != 0) {\n', '        // careful - copy-pasted in above loop\n', '        price = uint16(bmi * 256 + bti);\n', '        (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\n', '        return (price, depthBase, orderCount, block.number);\n', '      }\n', '      bti += 1;\n', '      wbm /= 2;\n', '    }\n', '    return (uint16(priceEnd), 0, 0, block.number);\n', '  }\n', '\n', '  // Internal Book View.\n', '  //\n', '  // See walkBook - adds up open depth at a price starting from an\n', '  // order which is assumed to be open. Careful - unlimited gas use.\n', '  //\n', '  function sumDepth(uint128 orderId) internal constant returns (uint depth, uint orderCount) {\n', '    while (true) {\n', '      Order storage order = orderForOrderId[orderId];\n', '      depth += order.sizeBase - order.executedBase;\n', '      orderCount++;\n', '      orderId = orderChainNodeForOpenOrderId[orderId].nextOrderId;\n', '      if (orderId == 0) {\n', '        return (depth, orderCount);\n', '      }\n', '    }\n', '  }\n', '}']