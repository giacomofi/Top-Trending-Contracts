['pragma solidity ^0.4.13;\n', '\n', 'contract Privileges {\n', '    // A person who owns the contract\n', '    address public owner;\n', '    // A person who can update the CENT price\n', '    address public trusted;\n', '\n', '    function Privileges() public payable {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setTrusted(address addr) onlyOwner public {\n', '        trusted = addr;\n', '    }\n', '\n', '    function setNewOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTrusted {\n', '        require(msg.sender == trusted || msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y) internal pure returns (uint) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y) internal pure returns (uint) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y) internal pure returns (uint) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Presale {\n', '\n', '    uint numberOfPurchasers = 0;\n', '\n', '    mapping (uint => address) presaleAddresses;\n', '    mapping (address => uint) tokensToSend;\n', '\n', '    function Presale() public {\n', '        addPurchaser(0x41c8f018d10f500d231f723017389da5FF9F45F2, 191625 * ((1 ether / 1 wei) / 10));      \n', '    }\n', '\n', '    function addPurchaser(address addr, uint tokens) private {\n', '        presaleAddresses[numberOfPurchasers] = addr;\n', '        tokensToSend[addr] = tokens;\n', '        numberOfPurchasers++;\n', '    }\n', '\n', '}\n', '\n', 'contract Casper is SafeMath, Privileges, Presale {    \n', '\n', '    string public constant NAME = "Casper Pre-ICO Token";\n', '    string public constant SYMBOL = "CSPT";\n', '    uint public constant DECIMALS = 18;\n', '\n', '    uint public constant MIN_PRICE = 750; // 600USD per Ether\n', '    uint public constant MAX_PRICE = 1250; // 1000USD per Ether\n', '    uint public price = 1040;  // 832USD per Ehter\n', '    uint public totalSupply = 0;\n', '\n', '    // PreICO hard cap\n', '    uint public constant TOKEN_SUPPLY_LIMIT = 1300000 * (1 ether / 1 wei); // 1 300 000 CSPT\n', '\n', '    // PreICO timings\n', '    uint public beginTime;\n', '    uint public endTime;\n', '\n', '    uint public index = 0;\n', '\n', '    bool sendPresale = true;\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (uint => address) participants;\n', '\n', '\n', '    function Casper() Privileges() public {\n', '        beginTime = now;\n', '        endTime = now + 2 weeks;\n', '    }\n', '\n', '    function() payable public {\n', '        require (now < endTime);\n', '        require (totalSupply < TOKEN_SUPPLY_LIMIT);\n', '        uint newTokens = msg.value * price;\n', '        if (newTokens + totalSupply <= TOKEN_SUPPLY_LIMIT) {\n', '            balances[msg.sender] = safeAdd(balances[msg.sender], newTokens);\n', '            totalSupply = safeAdd(totalSupply, newTokens);    \n', '        } else {\n', '            uint tokens = safeSub(TOKEN_SUPPLY_LIMIT, totalSupply); \n', '            balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\n', '            totalSupply = TOKEN_SUPPLY_LIMIT;\n', '        }\n', '        addParicipant(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address addr) public constant returns (uint) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function setPrice(uint newPrice) onlyTrusted public {\n', '        require (newPrice > MIN_PRICE && newPrice < MAX_PRICE);\n', '        price = newPrice;\n', '    }\n', '\n', '    function sendPresaleTokens() onlyOwner public {\n', '        require(sendPresale);\n', '        for (uint i = 0; i < numberOfPurchasers; i++) {\n', '            address addr = presaleAddresses[i];\n', '            uint tokens = tokensToSend[addr];\n', '            balances[addr] = tokens;\n', '            totalSupply = safeAdd(totalSupply, tokens);  \n', '        }\n', '        index = safeAdd(index, numberOfPurchasers);\n', '        sendPresale = false;\n', '    }\n', '\n', '    function withdrawEther(uint eth) onlyOwner public {\n', '        owner.transfer(eth);\n', '    }\n', '\n', '    function addParicipant(address addr) private {\n', '        participants[index] = addr;\n', '        index++;\n', '    }\n', '\n', '}']