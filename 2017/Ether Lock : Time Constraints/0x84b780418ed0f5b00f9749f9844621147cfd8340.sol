['pragma solidity ^0.4.11;\n', '\n', '// @title ICO Simple Contract\n', '// @author Harsh Patel\n', '\n', 'contract SafeMath {\n', '\n', '    // @notice SafeMath multiply function\n', '    // @param a Variable 1\n', '    // @param b Variable 2\n', '    // @result { "" : "result of safe multiply"}\n', '    function mul(uint256 a, uint256 b) internal  returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    // @notice SafeMath divide function\n', '    // @param a Variable 1\n', '    // @param b Variable 2\n', '    // @result { "" : "result of safe multiply"}\n', '    function div(uint256 a, uint256 b) internal  returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    // @notice SafeMath substract function\n', '    // @param a Variable 1\n', '    // @param b Variable 2\n', '    function sub(uint256 a, uint256 b) internal   returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // @notice SafeMath addition function\n', '    // @param a Variable 1\n', '    // @param b Variable 2\n', '    function add(uint256 a, uint256 b) internal  returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    // @notice SafeMath Power function\n', '    // @param a Variable 1\n', '    // @param b Variable 2\n', '    function pow( uint256 a , uint8 b ) internal returns ( uint256 ){\n', '        uint256 c;\n', '        c = a ** b;\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '\n', '    bool public OwnerDefined = false;\n', '    address public owner;\n', '    event OwnerEvents(address _addr, uint8 action);\n', '\n', '    // @notice Initializes Owner Contract and set the first Owner\n', '    function owned()\n', '        internal\n', '    {\n', '        require(OwnerDefined == false);\n', '        owner = msg.sender;\n', '        OwnerDefined = true;\n', '        OwnerEvents(msg.sender,1);\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Token is owned, SafeMath{\n', '\n', '    // Token Definitions\n', '    bool public tokenState;\n', '    string public name = "DropDeck";\n', '    string public symbol = "DDD";\n', '    uint256 public decimals = 8;\n', '    uint256 public totalSupply = 380000000000000000;\n', '    address public ico;\n', '    bool public blockState = true;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => bool) public userBanned;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // @notice Initialize the Token Contract\n', '    // @param _name Name of Token\n', '    // @param _code Short Code of the Token\n', '    // @param _decimals Amount of Decimals for the Token\n', '    // @param _netSupply TotalSupply of Tokens\n', '    function init()\n', '        external\n', '    returns ( bool ){\n', '        require(tokenState == false);\n', '        owned;\n', '        tokenState = true;\n', '        balances[this] = totalSupply;\n', '        allowed[this][owner] = totalSupply;\n', '        return true;\n', '    }\n', '\n', '    // @notice Transfers the token\n', '    // @param _to Address of reciver\n', '    // @param _value Value to be transfered\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '    returns ( bool ) {\n', '        require(tokenState == true);\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '        require(blockState == false);\n', '        require(userBanned[msg.sender] == false);\n', '        balances[msg.sender] = sub(balances[msg.sender],_value);\n', '        balances[_to] = add(balances[_to],_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    // @notice Transfers the token on behalf of\n', '    // @param _from Address of sender\n', '    // @param _to Address of reciver\n', '    // @param _value Value to be transfered\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '    {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = sub(balances[_from],_value);\n', '        balances[_to] = add(balances[_to],_value);\n', '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_value);\n', '        Transfer(_from, _to, _value);\n', '\n', '    }\n', '\n', '    // @notice Transfers the token from owner during the ICO\n', '    // @param _to Address of reciver\n', '    // @param _value Value to be transfered\n', '    function transferICO(address _to, uint256 _value)\n', '        public\n', '    returns ( bool ) {\n', '        require(tokenState == true);\n', '        require(_to != address(0));\n', '        require(_value <= balances[this]);\n', '        require(ico == msg.sender);\n', '        balances[this] = sub(balances[this],_value);\n', '        balances[_to] = add(balances[_to],_value);\n', '        Transfer(this, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice Checks balance of Address\n', '    // @param _to Address of token holder\n', '    function balanceOf(address _owner)\n', '        external\n', '        constant\n', '    returns (uint256) {\n', '        require(tokenState == true);\n', '        return balances[_owner];\n', '    }\n', '\n', '    // @notice Approves allowance for token holder\n', '    // @param _spender Address of token holder\n', '    // @param _value Amount of Token Transfer to approve\n', '    function approve(address _spender, uint256 _value)\n', '        external\n', '    returns (bool success) {\n', '        require(tokenState == true);\n', '        require(_spender != address(0));\n', '        require(msg.sender == owner);\n', '        allowed[msg.sender][_spender] = mul(_value, 100000000);\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice Fetched Allowance for owner\n', '    // @param _spender Address of token holder\n', '    // @param _owner Amount of token owner\n', '    function allowance(address _owner, address _spender)\n', '        external\n', '        constant\n', '    returns (uint256 remaining) {\n', '        require(tokenState == true);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // @notice Allows enabling of blocking of transfer for all users\n', '    function blockTokens()\n', '        external\n', '    returns (bool) {\n', '        require(tokenState == true);\n', '        require(msg.sender == owner);\n', '        blockState = true;\n', '        return true;\n', '    }\n', '\n', '    // @notice Allows enabling of unblocking of transfer for all users\n', '    function unblockTokens()\n', '        external\n', '    returns (bool) {\n', '        require(tokenState == true);\n', '        require(msg.sender == owner);\n', '        blockState = false;\n', '        return true;\n', '    }\n', '\n', '    // @notice Bans an Address\n', '    function banAddress(address _addr)\n', '        external\n', '    returns (bool) {\n', '        require(tokenState == true);\n', '        require(msg.sender == owner);\n', '        userBanned[_addr] = true;\n', '        return true;\n', '    }\n', '\n', '    // @notice Un-Bans an Address\n', '    function unbanAddress(address _addr)\n', '        external\n', '    returns (bool) {\n', '        require(tokenState == true);\n', '        require(msg.sender == owner);\n', '        userBanned[_addr] = false;\n', '        return true;\n', '    }\n', '\n', '    function setICO(address _ico)\n', '        external\n', '    returns (bool) {\n', '        require(tokenState == true);\n', '        require(msg.sender == owner);\n', '        ico = _ico;\n', '        return true;\n', '    }\n', '\n', '    // @notice Transfers the ownership of owner\n', '    // @param newOwner Address of the new owner\n', '    function transferOwnership( address newOwner )\n', '        external\n', '    {\n', '        require(msg.sender == owner);\n', '        require(newOwner != address(0));\n', '\n', '        allowed[this][owner] =  0;\n', '        owner = newOwner;\n', '        allowed[this][owner] =  balances[this];\n', '        OwnerEvents(msg.sender,2);\n', '    }\n', '\n', '\n', '}\n', 'contract tokenContract is ERC20Token{\n', '\n', '}\n', '\n', 'contract DDDico is SafeMath {\n', '\n', '    tokenContract token;\n', '\n', '    bool public state;\n', '\n', '    address public wallet;\n', '    address public tokenAddress;\n', '    address public owner;\n', '\n', '    uint256 public weiRaised;\n', '    uint256 public hardCap;\n', '    uint256 public tokenSale;\n', '    uint256 public tokenLeft;\n', '    uint256 public applicableRate;\n', '    uint256 weiAmount;\n', '    uint256 tok;\n', '\n', '    uint256 public block0 = 4594600;\n', '    uint256 public block1 = 4594840;\n', '    uint256 public block2 = 4600600;\n', '    uint256 public block3 = 4640920;\n', '    uint256 public block4 = 4681240;\n', '    uint256 public block5 = 4721560;\n', '    uint256 public block6 = 4761880;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    // @notice Initializes a ICO Contract\n', '    // @param _hardCap Specifies hard cap for ICO in wei\n', '    // @param _wallet Address of the multiSig wallet\n', '    // @param _token Address of the Token Contract\n', '    function DDDico( address _wallet, address _token , uint256 _hardCap, uint256 _tokenSale ) {\n', '        require(_wallet != address(0));\n', '        state = true;\n', '        owner = msg.sender;\n', '        wallet = _wallet;\n', '        tokenAddress = _token;\n', '        token = tokenContract(tokenAddress);\n', '        hardCap = mul(_hardCap,pow(10,16));\n', '        tokenSale = mul(_tokenSale,pow(10,8));\n', '        tokenLeft = tokenSale;\n', '    }\n', '\n', '    // @notice Fallback function to invest in ICO\n', '    function () payable {\n', '        buyTokens();\n', '    }\n', '\n', '    // @notice Buy Token Function to purchase tokens in ICO\n', '    function buyTokens() public payable {\n', '        require(validPurchase());\n', '        weiAmount               = 0;\n', '        tok                     = 0;\n', '        weiAmount               = msg.value;\n', '        tok                     = div(mul(weiAmount,fetchRate()),pow(10,16));\n', '        weiRaised               = add(weiRaised,weiAmount);\n', '        tokenLeft               = sub(tokenLeft,tok);\n', '        token.transferICO(msg.sender,tok);\n', '        TokenPurchase(msg.sender, msg.sender, weiAmount, tok);\n', '        forwardFunds();\n', '    }\n', '\n', '    // @notice Function to forward incomming funds to multi-sig wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @notice Validates the purchase\n', '    function validPurchase() internal constant returns (bool) {\n', '        bool withinPeriod = block.number >= block0 && block.number <= block6;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        bool cap = weiRaised <= hardCap;\n', '        return withinPeriod && nonZeroPurchase && cap;\n', '    }\n', '\n', '    // @notice Calculates the rate based on slabs\n', '    function fetchRate() constant returns (uint256){\n', '        if( block0 <= block.number && block1 > block.number ){\n', '            applicableRate = 15000000000;\n', '            return applicableRate;\n', '        }\n', '        if ( block1 <= block.number && block2 > block.number ){\n', '            applicableRate = 14000000000;\n', '            return applicableRate;\n', '        }\n', '        if ( block2 <= block.number && block3 > block.number ){\n', '            applicableRate = 13000000000;\n', '            return applicableRate;\n', '        }\n', '        if ( block3 <= block.number && block4 > block.number ){\n', '            applicableRate = 12000000000;\n', '            return applicableRate;\n', '        }\n', '        if ( block4 <= block.number && block5 > block.number ){\n', '            applicableRate = 11000000000;\n', '            return applicableRate;\n', '        }\n', '        if ( block5 <= block.number && block6 > block.number ){\n', '            applicableRate = 10000000000;\n', '            return applicableRate;\n', '        }\n', '    }\n', '\n', '    // @notice Checks weather ICO has ended or not\n', '    function hasEnded() public constant returns (bool)\n', '    {\n', '        return block.number > block6;\n', '    }\n', '}']