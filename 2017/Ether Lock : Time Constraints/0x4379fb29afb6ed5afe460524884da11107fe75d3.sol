['pragma solidity ^0.4.18;\n', 'contract ERC20 {\n', '  function totalSupply() constant public returns (uint totalsupply);\n', '  function balanceOf(address _owner) constant public returns (uint balance);\n', '  function transfer(address _to, uint _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  function approve(address _spender, uint _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) constant public returns (uint remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', 'contract Owned {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '    if (msg.sender != owner) revert();\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', 'contract Tokenz is Owned {\n', '  address public token;\n', '  uint256 public inRate;\n', '  uint256 public outRate;\n', '  uint256 public minRate;\n', '  uint256 public minLot;\n', '  uint256 public leveRage;\n', '  event Received(address indexed user, uint256 ethers, uint256 tokens);\n', '  event Sent(address indexed user, uint256 ethers, uint256 tokens);\n', '  function Tokenz (\n', '    address _token,\n', '    uint256 _inRate,\n', '    uint256 _outRate,\n', '    uint256 _minRate,\n', '    uint256 _minLot,\n', '    uint256 _leveRage\n', '  ) public {\n', '  \ttoken=_token;\n', '  \tinRate=_inRate;\n', '  \toutRate=_outRate;\n', '  \tminRate=_minRate;\n', '  \tminLot=_minLot;\n', '  \tleveRage=_leveRage;\n', '  }\n', '  function WithdrawToken(address tokenAddress, uint256 tokens) onlyOwner public {\n', '    if (!ERC20(tokenAddress).transfer(owner, tokens)) revert();\n', '  }\n', '  function WithdrawEther(uint256 ethers) onlyOwner public {\n', '    if (this.balance<ethers) revert();\n', '    if (!owner.send(ethers)) revert();\n', '  }\n', '  function SetInRate (uint256 newrate) onlyOwner public {inRate=newrate;}\n', '  function SetOutRate (uint256 newrate) onlyOwner public {outRate=newrate;}\n', '  function ChangeToken (address newtoken) onlyOwner public {\n', '    if (newtoken==0x0) revert();\n', '    token=newtoken;\n', '  }\n', '  function SetLot (uint256 newlot) onlyOwner public {\n', '    if (newlot<=0) revert();\n', '    minLot=newlot;\n', '  }\n', '  function TokensIn(uint256 tokens) public {\n', '    if (inRate==0) revert();\n', '    uint256 maxtokens=this.balance/inRate;\n', '    if (tokens>maxtokens) tokens=maxtokens;\n', '    if (tokens==0) revert();\n', '    if (!ERC20(token).transferFrom(msg.sender, address(this), tokens)) revert();\n', '    uint256 sum = tokens*inRate;\n', '    if (!msg.sender.send(sum)) revert();\n', '    uint256 newrate = inRate-tokens*leveRage;\n', '    if (newrate>=minRate) {\n', '      inRate=newrate;\n', '      outRate=outRate-tokens*leveRage;\t\n', '    }\n', '    Received(msg.sender, sum, tokens);\n', '  }\n', '  function TokensOut() payable public {\n', '    if (outRate==0) revert();\n', '    uint256 tokens=msg.value/outRate;\n', '    if (tokens<minLot) revert();\n', '    uint256 total=ERC20(token).balanceOf(address(this));\n', '    if (total<=0) revert();\n', '    uint256 change=0;\n', '    uint256 maxeth=total*outRate;\n', '    if (msg.value>maxeth) change=msg.value-maxeth;\n', '    if (change>0) if (!msg.sender.send(change)) revert();\n', '    if (!ERC20(token).transfer(msg.sender, tokens)) revert();\n', '    outRate=outRate+tokens*leveRage;\n', '    inRate=inRate+tokens*leveRage;\n', '    Sent(msg.sender, msg.value, tokens);\n', '  }\n', '  function () payable public {TokensOut();}\n', '}']