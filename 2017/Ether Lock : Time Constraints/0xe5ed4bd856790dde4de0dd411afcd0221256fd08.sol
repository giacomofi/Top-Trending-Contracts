['pragma solidity ^0.4.10;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '//SkrillaToken interface containing functions used by the syndicate contract.\n', 'contract SkrillaTokenInterface {\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function buyTokens() payable public;\n', '\n', '    function getCurrentPrice(address _buyer) public constant returns (uint256);\n', '\n', '    function tokenSaleBalanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    function withdraw() public returns (bool);\n', '}\n', '\n', 'contract TokenSyndicate {\n', '    \n', '    SkrillaTokenInterface private tokenContract;\n', '    /*\n', '    * The address to call to purchase tokens.\n', '    */\n', '    address public tokenContractAddress;\n', '    uint256 public tokenExchangeRate;\n', ' \n', '    /**\n', '    * Timestamp after which a purchaser can get a refund of their investment. As long as the tokens have not been purchased.\n', '    */\n', '    uint256 public refundStart;\n', '    /**\n', '    * The owner can set refundEnabled to allow purchasers to refund their funds before refundStart.\n', '    */\n', '    bool public refundsEnabled;\n', '    bool public tokensPurchased;\n', '    /**\n', '    * Has the withdraw function been called on the token contract.\n', "    * This makes the syndicate's tokens available for distribution.\n", '    */\n', '    bool public syndicateTokensWithdrawn;\n', '\n', '    /**\n', '    * The amount of wei collected by the syndicate.\n', '    */\n', '    uint256 public totalPresale;\n', '    address public owner;\n', '\n', '    mapping(address => uint256) public presaleBalances;\n', '\n', '    event LogInvest(address indexed _to,  uint256 presale);\n', '    event LogRefund(address indexed _to, uint256 presale);\n', '    event LogTokenPurchase(uint256 eth, uint256 tokens);\n', '    event LogWithdrawTokens(address indexed _to, uint256 tokens);\n', '    \n', '    modifier onlyOwner() { \n', '        assert(msg.sender == owner);  _; \n', '    }\n', '\n', '    modifier onlyWhenTokensNotPurchased() { \n', '        assert(!tokensPurchased);  _; \n', '    }\n', '    modifier onlyWhenTokensPurchased() { \n', '        assert(tokensPurchased); _; \n', '    }\n', '    modifier onlyWhenSyndicateTokensWithdrawn() {\n', '        assert(syndicateTokensWithdrawn); _; \n', '    }\n', '    modifier whenRefundIsPermitted() {\n', '        require(now >= refundStart || refundsEnabled);\n', '        _;\n', '    }\n', '    modifier onlyWhenRefundsNotEnabled() {\n', '        require(!refundsEnabled);\n', '        _;\n', '    }\n', '    function TokenSyndicate(address _tokenContractAddress,\n', '                            address _owner,\n', '                            uint256 _refundStart) {\n', '        tokenContractAddress = _tokenContractAddress;\n', '        owner = _owner;\n', '\n', '        assert(tokenContractAddress != address(0));   // the token contract may not be at the zero address.\n', '        assert(owner != address(0));   // the token contract may not be at the zero address.\n', '\n', '        tokenContract = SkrillaTokenInterface(_tokenContractAddress);\n', '        refundStart = _refundStart;\n', '\n', '        totalPresale = 0;\n', '        \n', '        tokensPurchased = false;\n', '        syndicateTokensWithdrawn = false;\n', '        refundsEnabled = false;\n', '    }\n', '\n', '    // Fallback function can be used to invest in syndicate\n', '    function() external payable {\n', '        invest();\n', '    }\n', '    /*\n', '        Invest in this contract in order to have tokens purchased on your behalf when the buyTokens() contract\n', '        is called without a `throw`.\n', '    */\n', '    function invest() payable public onlyWhenTokensNotPurchased {\n', '        assert(msg.value > 0);\n', '\n', '        presaleBalances[msg.sender] = SafeMath.add(presaleBalances[msg.sender], msg.value);\n', '        totalPresale = SafeMath.add(totalPresale, msg.value);        \n', '        LogInvest(msg.sender, msg.value);       // create an event\n', '    }\n', '\n', '    /*\n', '        Get the presaleBalance (ETH) for an address.\n', '    */\n', '    function balanceOf(address _purchaser) external constant returns (uint256 presaleBalance) {\n', '        return presaleBalances[_purchaser];\n', '    }\n', '\n', '    /**\n', "    * An 'escape hatch' function to allow purchasers to get a refund of their eth before refundStart.\n", '    */\n', '    function enableRefunds() external onlyWhenTokensNotPurchased onlyOwner {\n', '        refundsEnabled = true;\n', '    }\n', '    /*\n', '       Attempt to purchase the tokens from the token contract.\n', '       This must be done before the sale ends\n', '\n', '    */\n', '    function buyTokens() external onlyWhenRefundsNotEnabled onlyWhenTokensNotPurchased onlyOwner {\n', '        require(this.balance >= totalPresale);\n', '\n', '        tokenContract.buyTokens.value(this.balance)();\n', '        //Get the exchange rate the contract will got for the purchase. Used to distribute tokens\n', '        //The number of token subunits per eth\n', '        tokenExchangeRate = tokenContract.getCurrentPrice(this);\n', '        \n', '        tokensPurchased = true;\n', '\n', '        LogTokenPurchase(totalPresale, tokenContract.tokenSaleBalanceOf(this));\n', '    }\n', '\n', '    /*\n', "        Call 'withdraw' on the skrilla contract as this contract. So that the tokens are available for distribution with the 'transfer' function.\n", '        This can only be called 14 days after sale close.\n', '    */\n', '    function withdrawSyndicateTokens() external onlyWhenTokensPurchased onlyOwner {\n', '        assert(tokenContract.withdraw());\n', '        syndicateTokensWithdrawn = true;\n', '    }\n', '\n', '    /*\n', '        Transfer an accounts token entitlement to itself.\n', '        This can only be called if the tokens have been purchased by the contract and have been withdrawn by the contract.\n', '    */\n', '\n', '    function withdrawTokens() external onlyWhenSyndicateTokensWithdrawn {\n', '        uint256 tokens = SafeMath.div(SafeMath.mul(presaleBalances[msg.sender], tokenExchangeRate), 1 ether);\n', '        assert(tokens > 0);\n', '\n', '        totalPresale = SafeMath.sub(totalPresale, presaleBalances[msg.sender]);\n', '        presaleBalances[msg.sender] = 0;\n', '\n', '        /*\n', '           Attempt to transfer tokens to msg.sender.\n', '           Note: we are relying on the token contract to return a success bool (true for success). If this\n', '           bool is not implemented as expected it may be possible for an account to withdraw more tokens than\n', '           it is entitled to.\n', '        */\n', '        assert(tokenContract.transfer( msg.sender, tokens));\n', '        LogWithdrawTokens(msg.sender, tokens);\n', '    }\n', '\n', '    /*\n', '        Refund an accounts investment.\n', '        This is only possible if tokens have not been purchased.\n', '    */\n', '    function refund() external whenRefundIsPermitted onlyWhenTokensNotPurchased {\n', '        uint256 totalValue = presaleBalances[msg.sender];\n', '        assert(totalValue > 0);\n', '\n', '        presaleBalances[msg.sender] = 0;\n', '        totalPresale = SafeMath.sub(totalPresale, totalValue);\n', '        \n', '        msg.sender.transfer(totalValue);\n', '        LogRefund(msg.sender, totalValue);\n', '    }\n', '}']