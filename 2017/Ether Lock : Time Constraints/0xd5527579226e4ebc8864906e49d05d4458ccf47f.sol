['pragma solidity ^0.4.11;\n', '\n', 'contract SafeMath {\n', '    //internals\n', '\n', '    function safeMul(uint a, uint b) internal returns(uint) {\n', '        uint c = a * b;\n', '        Assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns(uint) {\n', '        Assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns(uint) {\n', '        uint c = a + b;\n', '        Assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function Assert(bool assertion) internal {\n', '        if (!assertion) {\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', 'contract Kubera is SafeMath {\n', '    /* Public variables of the token */\n', "    string public standard = 'ERC20';\n", "    string public name = 'Kubera token';\n", "    string public symbol = 'KBR';\n", '    uint8 public decimals = 0;\n', '    uint256 public totalSupply;\n', '    address public owner;\n', '    uint public tokensSoldToInvestors = 0;\n', '    uint public maxGoalInICO = 2100000000;\n', '    /* From this time on tokens may be transfered (after ICO 23h59 10/11/2017)*/\n', '    uint256 public startTime = 1510325999;\n', '    /* Tells if tokens have been burned already */\n', '    bool burned;\n', '    bool hasICOStarted;\n', '    /* This wallet will hold tokens after ICO*/\n', '    address tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event TransferToReferral(address indexed referralAddress, uint256 value);\n', '    event Approval(address indexed Owner, address indexed spender, uint256 value);\n', '    event Burned(uint amount);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function Kubera() {\n', '        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;\n', '        // Give the owner all initial tokens\n', '        balanceOf[owner] = 2205000000;\n', '        // Update total supply\n', '        totalSupply      = 2205000000;\n', '    }\n', '\n', '    /* Send some of your tokens to a given address */\n', '    function transfer(address _to, uint256 _value) returns(bool success) {\n', '        //check if the crowdsale is already over\n', '        if (now < startTime) {\n', '            revert();\n', '        }\n', '\n', '        //prevent owner transfer all tokens immediately after ICO ended\n', '        if (msg.sender == owner && !burned) {\n', '            burn();\n', '            return;\n', '        }\n', '\n', '        // Subtract from the sender\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        // Notify anyone listening that this transfer took place\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /* Allow another contract or person to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns(bool success) {\n', '        if( now < startTime && hasICOStarted) { // during ICO only allow execute this function one time\n', '            revert();\n', '        }\n', '        hasICOStarted = true;\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* A contract or  person attempts to get the tokens of somebody else.\n', '    *  This is only allowed if the token holder approved. */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        if (now < startTime && _from != owner) revert(); //check if the crowdsale is already over\n', '        //prevent the owner of spending his share of tokens so that owner has to burn the token left after ICO\n', '        if (_from == owner && now >= startTime && !burned) {\n', '            burn();\n', '            return;\n', '        }\n', '        if (now < startTime){\n', '            if(_value < maxGoalInICO ) {\n', '                tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value);\n', '            } else {\n', '                _value = safeSub(_value, maxGoalInICO);\n', '            }\n', '        }\n', '        var _allowance = allowance[_from][msg.sender];\n', '        // Subtract from the sender\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        allowance[_from][msg.sender] = safeSub(_allowance, _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function burn(){\n', '        // if tokens have not been burned already and the ICO ended or Tokens have been sold out before ICO end.\n', '        if(!burned && ( now > startTime || tokensSoldToInvestors >= maxGoalInICO) ) {\n', '            // checked for overflow above\n', '            totalSupply = safeSub(totalSupply, balanceOf[owner]) + 900000000;\n', '            uint tokensLeft = balanceOf[owner];\n', '            balanceOf[owner] = 0;\n', '            balanceOf[tokensHolder] = 900000000;\n', '            startTime = now;\n', '            burned = true;\n', '            Burned(tokensLeft);\n', '        }\n', '    }\n', '\n', '}']