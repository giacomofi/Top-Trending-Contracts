['pragma solidity ^0.4.18;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract BurnableToken {\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function burn(uint256 _value) public;\n', '\n', '    ArnaCrowdsale public  crowdsale;\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool);\n', '\n', '    address public owner;\n', '\n', '    function setCrowdsale(ArnaCrowdsale _crowdsale) public;\n', '\n', '    function setTransferable(bool _transferable) public;\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    function transferOwnership(address newOwner) public;\n', '\n', '    bool public transferable;\n', '}\n', '\n', '\n', 'contract ArnaToken is BurnableToken {\n', '    string public constant name = "ArnaToken";\n', '    string public constant symbol = "ARNA";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n', '\n', '    function init() public;\n', '\n', '}\n', '\n', '//========================================\n', '\n', '\n', '\n', 'contract ArnaVault is Ownable {\n', '    using SafeMath for uint256;\n', '    ArnaToken token;\n', '\n', '    uint256 amount;\n', '\n', '    uint256 public withdrawn = 0;\n', '\n', '    uint startTime;\n', '\n', '    uint period;\n', '\n', '    uint256 percent;\n', '\n', '    address beneficiary;\n', '\n', '    function ArnaVault(ArnaToken _token, uint _period, uint256 _percent, address _beneficiary) public {\n', '        token = _token;\n', '        period = _period;\n', '        percent = _percent;\n', '        // 2500 -> 2.5%\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function tokensInVault() public constant returns (uint256){\n', '        return token.balanceOf(this);\n', '    }\n', '\n', '    function start() public onlyOwner {\n', '        assert(token.balanceOf(this) > 0);\n', '        amount = token.balanceOf(this);\n', '        startTime = block.timestamp;\n', '    }\n', '\n', '    function tokensAvailable() public constant returns (uint256){\n', '        return (((block.timestamp - startTime) / period + 1)\n', '        * amount * percent / 100000)\n', '        .sub(withdrawn);\n', '    }\n', '\n', '    function withdraw() public {\n', '        assert(msg.sender == beneficiary || msg.sender == owner);\n', '        assert(tokensAvailable() > 0);\n', '        token.transfer(beneficiary, tokensAvailable());\n', '        withdrawn = withdrawn.add(tokensAvailable());\n', '    }\n', '\n', '}\n', '\n', '\n', '//========================================\n', '\n', 'contract ArnaCrowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '    ArnaControl arnaControl;\n', '\n', '    ArnaToken public token;\n', '\n', '    uint256 public totalRise;\n', '\n', '\n', '    function ArnaCrowdsale(ArnaControl _arnaControl, ArnaToken _token) public {\n', '        arnaControl = _arnaControl;\n', '        token = _token;\n', '    }\n', '\n', '    function tokensToSale() public view returns (uint256){\n', '        return token.balanceOf(this);\n', '    }\n', '\n', '    function burnUnsold() public onlyOwner returns (uint256){\n', '        uint256 unsold = token.balanceOf(this);\n', '        token.burn(unsold);\n', '        return unsold;\n', '    }\n', '\n', '    function price() public constant returns (uint256) {\n', '        return arnaControl.getPrice();\n', '    }\n', '\n', '    function priceWithBonus() public constant returns (uint256) {\n', '        return arnaControl.getPriceWithBonus();\n', '    }\n', '\n', '    function() public payable {\n', '        uint256 amount = msg.value.mul(1 ether).div(priceWithBonus());\n', '        assert(token.balanceOf(this) > amount);\n', '        token.transfer(msg.sender, amount);\n', '        totalRise = totalRise.add(msg.value);\n', '    }\n', '\n', '    function sendTokens(address beneficiary, uint256 amount) public onlyOwner {\n', '        assert(token.balanceOf(this) > amount);\n', '        token.transfer(beneficiary, amount);\n', '        totalRise = totalRise.add(amount.mul(priceWithBonus()));\n', '    }\n', '\n', '    function withdraw() public onlyOwner returns (bool) {\n', '        return arnaControl.send(this.balance);\n', '    }\n', '\n', '}\n', '\n', '\n', '//========================================\n', '\n', 'contract ArnaControl is Ownable {\n', '    using SafeMath for uint256;\n', '    ArnaToken public token;\n', '\n', '    ArnaCrowdsale public  crowdsale;\n', '\n', '    ArnaVault public founders;\n', '\n', '    ArnaVault public team;\n', '\n', '    //    ArnaVault public partners;\n', '\n', '    bool public isStarted;\n', '\n', '    bool public isStoped;\n', '\n', '    uint256 constant TO_SALE = 500000000 * (10 ** 18);\n', '\n', '    uint256  price = 0.000266 ether;\n', '\n', '    uint256  priceWithBonus = 0.000266 ether; //  15% => 0.000231304 ether;\n', '\n', '    address public coldWallet;\n', '\n', '    function init(ArnaToken _arnaToken) public onlyOwner {\n', '        token = _arnaToken;\n', '        token.init();\n', '        coldWallet = msg.sender;\n', '    }\n', '\n', '    function SaleStop() public onlyOwner {\n', '        assert(isStarted);\n', '        assert(!isStoped);\n', '\n', '        setTransferable(true);\n', '\n', '        uint256 toBurn = crowdsale.burnUnsold();\n', '        token.burn(toBurn);\n', '\n', '        uint256 toFounders = thisContactsTokens().div(5);\n', '        // 100 / 500\n', '        uint256 toPartners = thisContactsTokens().div(2);\n', '        // 250 / 500\n', '        uint256 toTeam = thisContactsTokens().sub(toFounders).sub(toPartners);\n', '        // 150 / 500\n', '\n', '\n', '        founders = new ArnaVault(token, 360 days, 50000, address(0xC041CB562e4C398710dF38eAED539b943641f7b1));\n', '        token.transfer(founders, toFounders);\n', '        founders.start();\n', '\n', '        team = new ArnaVault(token, 180 days, 16667, address(0x2ABfE4e1809659ab60eB0053cC799b316afCc556));\n', '        token.transfer(team, toTeam);\n', '        team.start();\n', '\n', '        //        partners = new ArnaVault(token, 0, 100000,  0xd6496BBd13ae8C4Bdeea68799F678a1456B62f23);\n', '        //        token.transfer(partners, thisContactsTokens().div(2));\n', '        //        partners.start();\n', '\n', '        token.transfer(address(0xd6496BBd13ae8C4Bdeea68799F678a1456B62f23), toPartners);\n', '\n', '\n', '        isStarted = false;\n', '        isStoped = true;\n', '    }\n', '\n', '    function SaleStart() public onlyOwner {\n', '        assert(!isStarted);\n', '        assert(!isStoped);\n', '        crowdsale = new ArnaCrowdsale(this, token);\n', '        token.setCrowdsale(crowdsale);\n', '        token.transfer(crowdsale, TO_SALE);\n', '        isStarted = true;\n', '    }\n', '\n', '    function thisContactsTokens() public constant returns (uint256){\n', '        return token.balanceOf(this);\n', '    }\n', '\n', '    function getPrice() public constant returns (uint256){\n', '        return price;\n', '    }\n', '\n', '    // _newPrice : 266 => 0.000266\n', '    function setPrice(uint256 _newPrice) public onlyOwner {\n', '        assert(_newPrice > 0);\n', '        price = _newPrice * (10 ** 12);\n', '    }\n', '\n', '    function getPriceWithBonus() public constant returns (uint256){\n', '        return priceWithBonus;\n', '    }\n', '\n', '    // _newPrice : 266 => 0.000266\n', '    function setPriceWithBonus(uint256 _newPrice) public onlyOwner {\n', '        assert(_newPrice > 0);\n', '        assert(_newPrice * (10 ** 12) <= price);\n', '        priceWithBonus = _newPrice * (10 ** 12);\n', '    }\n', '\n', '\n', '    function() public payable {\n', '        // this for withdraw from ArnaCrowdsale\n', '    }\n', '\n', '    function setColdWallet(address _coldWallet) public onlyOwner {\n', '        coldWallet = _coldWallet;\n', '    }\n', '\n', '    function withdraw() public onlyOwner returns (bool) {\n', '        if (crowdsale.balance > 0)\n', '            crowdsale.withdraw();\n', '        return coldWallet.send(this.balance);\n', '    }\n', '\n', '    // amount : 12345000 => 12.345000 ARNA = 12345000000000000000;\n', '    function sendTokens(address beneficiary, uint256 amount) public onlyOwner {\n', '        crowdsale.sendTokens(beneficiary, amount * (10 ** 12));\n', '    }\n', '\n', '    function setTransferable(bool _transferable) public onlyOwner {\n', '        token.setTransferable(_transferable);\n', '    }\n', '\n', '    //refund if the softcap is not reached\n', '    function refund(address beneficiary, uint256 amount) public onlyOwner returns(bool){\n', '        if (crowdsale.balance > 0)\n', '            crowdsale.withdraw();\n', '        assert(crowdsale.balance + this.balance >= amount);\n', '        return beneficiary.send(amount);\n', '    }\n', '}']