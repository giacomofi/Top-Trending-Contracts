['/* Author: Victor Mezrin  victor@mezrin.com */\n', '\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMathInterface\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMathInterface {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256);\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256);\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256);\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath is SafeMathInterface {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CommonModifiersInterface\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool);\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the _targetAddress is a contract.\n', '   */\n', '  modifier onlyContractAddress(address _targetAddress) {\n', '    require(isContract(_targetAddress) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CommonModifiers\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiers is CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool) {\n', '    require (_targetAddress != address(0x0));\n', '\n', '    uint256 length;\n', '    assembly {\n', '      //retrieve the size of the code on target address, this needs assembly\n', '      length := extcodesize(_targetAddress)\n', '    }\n', '    return (length > 0);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AssetIDInterface\n', ' * @dev Interface of a contract that assigned to an asset (JNT, jUSD etc.)\n', ' * @dev Contracts for the same asset (like JNT, jUSD etc.) will have the same AssetID.\n', ' * @dev This will help to avoid misconfiguration of contracts\n', ' */\n', 'contract AssetIDInterface {\n', '  function getAssetID() public constant returns (string);\n', '  function getAssetIDHash() public constant returns (bytes32);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AssetID\n', ' * @dev Base contract implementing AssetIDInterface\n', ' */\n', 'contract AssetID is AssetIDInterface {\n', '\n', '  /* Storage */\n', '\n', '  string assetID;\n', '\n', '\n', '  /* Constructor */\n', '\n', '  function AssetID(string _assetID) public {\n', '    require(bytes(_assetID).length > 0);\n', '\n', '    assetID = _assetID;\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  function getAssetID() public constant returns (string) {\n', '    return assetID;\n', '  }\n', '\n', '  function getAssetIDHash() public constant returns (bytes32) {\n', '    return keccak256(assetID);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnableInterface\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableInterface {\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address);\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the current owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == getOwner());\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is OwnableInterface {\n', '\n', '  /* Storage */\n', '\n', '  address owner = address(0x0);\n', '  address proposedOwner = address(0x0);\n', '\n', '\n', '  /* Events */\n', '\n', '  event OwnerAssignedEvent(address indexed newowner);\n', '  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);\n', '\n', '\n', '  /**\n', '   * @dev The constructor sets the initial `owner` to the passed account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '\n', '    OwnerAssignedEvent(owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner requests transfer ownership to the new owner.\n', '   * @param _proposedOwner The address to transfer ownership to.\n', '   */\n', '  function createOwnershipOffer(address _proposedOwner) external onlyOwner {\n', '    require (proposedOwner == address(0x0));\n', '    require (_proposedOwner != address(0x0));\n', '    require (_proposedOwner != address(this));\n', '\n', '    proposedOwner = _proposedOwner;\n', '\n', '    OwnershipOfferCreatedEvent(owner, _proposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the new owner to accept an ownership offer to contract control.\n', '   */\n', '  //noinspection UnprotectedFunction\n', '  function acceptOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == proposedOwner);\n', '\n', '    address _oldOwner = owner;\n', '    owner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    OwnerAssignedEvent(owner);\n', '    OwnershipOfferAcceptedEvent(_oldOwner, owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner cancels transfer ownership to the new owner.\n', '   */\n', '  function cancelOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == owner || msg.sender == proposedOwner);\n', '\n', '    address _oldProposedOwner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    OwnershipOfferCancelledEvent(owner, _oldProposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "proposedOwner" contract variable\n', '   */\n', '  function getProposedOwner() public constant returns (address) {\n', '    return proposedOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ManageableInterface\n', ' * @dev Contract that allows to grant permissions to any address\n', ' * @dev In real life we are no able to perform all actions with just one Ethereum address\n', ' * @dev because risks are too high.\n', ' * @dev Instead owner delegates rights to manage an contract to the different addresses and\n', ' * @dev stay able to revoke permissions at any time.\n', ' */\n', 'contract ManageableInterface {\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);\n', '\n', '  /**\n', '   * @dev Modifier to use in derived contracts\n', '   */\n', '  modifier onlyAllowedManager(string _permissionName) {\n', '    require(isManagerAllowed(msg.sender, _permissionName) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Manageable is OwnableInterface,\n', '                       ManageableInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (address => bool) managerEnabled;  // hard switch for a manager - on/off\n', '  mapping (address => mapping (string => bool)) managerPermissions;  // detailed info about manager`s permissions\n', '\n', '\n', '  /* Events */\n', '\n', '  event ManagerEnabledEvent(address indexed manager);\n', '  event ManagerDisabledEvent(address indexed manager);\n', '  event ManagerPermissionGrantedEvent(address indexed manager, string permission);\n', '  event ManagerPermissionRevokedEvent(address indexed manager, string permission);\n', '\n', '\n', '  /* Configure contract */\n', '\n', '  /**\n', '   * @dev Function to add new manager\n', '   * @param _manager address New manager\n', '   */\n', '  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == false);\n', '\n', '    managerEnabled[_manager] = true;\n', '    ManagerEnabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to remove existing manager\n', '   * @param _manager address Existing manager\n', '   */\n', '  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == true);\n', '\n', '    managerEnabled[_manager] = false;\n', '    ManagerDisabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to grant new permission to the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Granted permission name\n', '   */\n', '  function grantManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == false);\n', '\n', '    managerPermissions[_manager][_permissionName] = true;\n', '    ManagerPermissionGrantedEvent(_manager, _permissionName);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to revoke permission of the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Revoked permission name\n', '   */\n', '  function revokeManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == true);\n', '\n', '    managerPermissions[_manager][_permissionName] = false;\n', '    ManagerPermissionRevokedEvent(_manager, _permissionName);\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev Function to check manager status\n', '   * @param _manager address Manager`s address\n', '   * @return True if manager is enabled\n', '   */\n', '  function isManagerEnabled(\n', '    address _manager\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    returns (bool)\n', '  {\n', '    return managerEnabled[_manager];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check permissions of a manager\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager has been granted needed permission\n', '   */\n', '  function isPermissionGranted(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return managerPermissions[_manager][_permissionName];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return (managerEnabled[_manager] && managerPermissions[_manager][_permissionName]);\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  /**\n', '   * @dev Modifier to check manager address\n', '   */\n', '  modifier onlyValidManagerAddress(address _manager) {\n', '    require(_manager != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidPermissionName(string _permissionName) {\n', '    require(bytes(_permissionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title PausableInterface\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', " * @dev Based on zeppelin's Pausable, but integrated with Manageable\n", ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract PausableInterface {\n', '\n', '  /**\n', '   * Events\n', '   */\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public;\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public;\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool);\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenContractNotPaused() {\n', '    require(getPaused() == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenContractPaused {\n', '    require(getPaused() == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', " * @dev Based on zeppelin's Pausable, but integrated with Manageable\n", ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract Pausable is ManageableInterface,\n', '                     PausableInterface {\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '\n', '  bool paused = true;\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', "  function pauseContract() public onlyAllowedManager('pause_contract') whenContractNotPaused {\n", '    paused = true;\n', '    PauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', "  function unpauseContract() public onlyAllowedManager('unpause_contract') whenContractPaused {\n", '    paused = false;\n', '    UnpauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool) {\n', '    return paused;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BytecodeExecutorInterface interface\n', ' * @dev Implementation of a contract that execute any bytecode on behalf of the contract\n', ' * @dev Last resort for the immutable and not-replaceable contract :)\n', ' */\n', 'contract BytecodeExecutorInterface {\n', '\n', '  /* Events */\n', '\n', '  event CallExecutedEvent(address indexed target,\n', '                          uint256 suppliedGas,\n', '                          uint256 ethValue,\n', '                          bytes32 transactionBytecodeHash);\n', '  event DelegatecallExecutedEvent(address indexed target,\n', '                                  uint256 suppliedGas,\n', '                                  bytes32 transactionBytecodeHash);\n', '\n', '\n', '  /* Functions */\n', '\n', '  function executeCall(address _target, uint256 _suppliedGas, uint256 _ethValue, bytes _transactionBytecode) external;\n', '  function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) external;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BytecodeExecutor\n', ' * @dev Implementation of a contract that execute any bytecode on behalf of the contract\n', ' * @dev Last resort for the immutable and not-replaceable contract :)\n', ' */\n', 'contract BytecodeExecutor is ManageableInterface,\n', '                             BytecodeExecutorInterface {\n', '\n', '  /* Storage */\n', '\n', '  bool underExecution = false;\n', '\n', '\n', '  /* BytecodeExecutorInterface */\n', '\n', '  function executeCall(\n', '    address _target,\n', '    uint256 _suppliedGas,\n', '    uint256 _ethValue,\n', '    bytes _transactionBytecode\n', '  )\n', '    external\n', "    onlyAllowedManager('execute_call')\n", '  {\n', '    require(underExecution == false);\n', '\n', '    underExecution = true; // Avoid recursive calling\n', '    _target.call.gas(_suppliedGas).value(_ethValue)(_transactionBytecode);\n', '    underExecution = false;\n', '\n', '    CallExecutedEvent(_target, _suppliedGas, _ethValue, keccak256(_transactionBytecode));\n', '  }\n', '\n', '  function executeDelegatecall(\n', '    address _target,\n', '    uint256 _suppliedGas,\n', '    bytes _transactionBytecode\n', '  )\n', '    external\n', "    onlyAllowedManager('execute_delegatecall')\n", '  {\n', '    require(underExecution == false);\n', '\n', '    underExecution = true; // Avoid recursive calling\n', '    _target.delegatecall.gas(_suppliedGas)(_transactionBytecode);\n', '    underExecution = false;\n', '\n', '    DelegatecallExecutedEvent(_target, _suppliedGas, keccak256(_transactionBytecode));\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract CrydrViewBaseInterface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrControllerChangedEvent(address indexed crydrcontroller);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setCrydrController(address _crydrController) external;\n', '  function getCrydrController() public constant returns (address);\n', '\n', '  function getCrydrViewStandardName() public constant returns (string);\n', '  function getCrydrViewStandardNameHash() public constant returns (bytes32);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrStorageBalanceInterface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR\n', ' */\n', 'contract CrydrStorageBalanceInterface {\n', '\n', '  /* Events */\n', '\n', '  event AccountBalanceIncreasedEvent(address indexed account, uint256 value);\n', '  event AccountBalanceDecreasedEvent(address indexed account, uint256 value);\n', '\n', '\n', '  /* Low-level change of balance. Implied that totalSupply kept in sync. */\n', '\n', '  function increaseBalance(address _account, uint256 _value) public;\n', '  function decreaseBalance(address _account, uint256 _value) public;\n', '  function getBalance(address _account) public constant returns (uint256);\n', '  function getTotalSupply() public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrStorageAllowanceInterface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR\n', ' */\n', 'contract CrydrStorageAllowanceInterface {\n', '\n', '  /* Events */\n', '\n', '  event AccountAllowanceIncreasedEvent(address indexed owner, address indexed spender, uint256 value);\n', '  event AccountAllowanceDecreasedEvent(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '  /* Low-level change of allowance */\n', '\n', '  function increaseAllowance(address _owner, address _spender, uint256 _value) public;\n', '  function decreaseAllowance(address _owner, address _spender, uint256 _value) public;\n', '  function getAllowance(address _owner, address _spender) public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrStorageERC20Interface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR and have optimization for ERC20 controllers\n', ' */\n', 'contract CrydrStorageERC20Interface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrTransferredEvent(address indexed from, address indexed to, uint256 value);\n', '  event CrydrTransferredFromEvent(address indexed spender, address indexed from, address indexed to, uint256 value);\n', '  event CrydrSpendingApprovedEvent(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '  /* ERC20 optimization. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(address _msgsender, address _to, uint256 _value) public;\n', '  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;\n', '  function approve(address _msgsender, address _spender, uint256 _value) public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrStorageBlocksInterface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR\n', ' */\n', 'contract CrydrStorageBlocksInterface {\n', '\n', '  /* Events */\n', '\n', '  event AccountBlockedEvent(address indexed account);\n', '  event AccountUnblockedEvent(address indexed account);\n', '  event AccountFundsBlockedEvent(address indexed account, uint256 value);\n', '  event AccountFundsUnblockedEvent(address indexed account, uint256 value);\n', '\n', '\n', '  /* Low-level change of blocks and getters */\n', '\n', '  function blockAccount(address _account) public;\n', '  function unblockAccount(address _account) public;\n', '  function getAccountBlocks(address _account) public constant returns (uint256);\n', '\n', '  function blockAccountFunds(address _account, uint256 _value) public;\n', '  function unblockAccountFunds(address _account, uint256 _value) public;\n', '  function getAccountBlockedFunds(address _account) public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20LoggableInterface\n', ' * @dev Contract is able to create Transfer/Approval events with the cal from controller\n', ' */\n', 'contract CrydrViewERC20LoggableInterface {\n', '\n', '  function emitTransferEvent(address _from, address _to, uint256 _value) external;\n', '  function emitApprovalEvent(address _owner, address _spender, uint256 _value) external;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20MintableInterface\n', ' * @dev Contract is able to create Mint/Burn events with the cal from controller\n', ' */\n', 'contract CrydrViewERC20MintableInterface {\n', '  event MintEvent(address indexed owner, uint256 value);\n', '  event BurnEvent(address indexed owner, uint256 value);\n', '\n', '  function emitMintEvent(address _owner, uint256 _value) external;\n', '  function emitBurnEvent(address _owner, uint256 _value) external;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBaseInterface interface\n', ' * @dev Interface of a contract that implement business-logic of an CryDR, mediates CryDR views and storage\n', ' */\n', 'contract CrydrControllerBaseInterface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrStorageChangedEvent(address indexed crydrstorage);\n', '  event CrydrViewAddedEvent(address indexed crydrview, string standardname);\n', '  event CrydrViewRemovedEvent(address indexed crydrview, string standardname);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setCrydrStorage(address _newStorage) external;\n', '  function getCrydrStorageAddress() public constant returns (address);\n', '\n', '  function setCrydrView(address _newCrydrView, string _viewApiStandardName) external;\n', '  function removeCrydrView(string _viewApiStandardName) external;\n', '  function getCrydrViewAddress(string _viewApiStandardName) public constant returns (address);\n', '\n', '  function isCrydrViewAddress(address _crydrViewAddress) public constant returns (bool);\n', '  function isCrydrViewRegistered(string _viewApiStandardName) public constant returns (bool);\n', '\n', '\n', '  /* Helpers */\n', '\n', '  modifier onlyValidCrydrViewStandardName(string _viewApiStandard) {\n', '    require(bytes(_viewApiStandard).length > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCrydrView() {\n', '    require(isCrydrViewAddress(msg.sender) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBase\n', ' * @dev Implementation of a contract with business-logic of an CryDR, mediates CryDR views and storage\n', ' */\n', 'contract CrydrControllerBase is CommonModifiersInterface,\n', '                                ManageableInterface,\n', '                                PausableInterface,\n', '                                CrydrControllerBaseInterface {\n', '\n', '  /* Storage */\n', '\n', '  address crydrStorage = address(0x0);\n', '  mapping (string => address) crydrViewsAddresses;\n', '  mapping (address => bool) isRegisteredView;\n', '\n', '\n', '  /* CrydrControllerBaseInterface */\n', '\n', '  function setCrydrStorage(\n', '    address _crydrStorage\n', '  )\n', '    external\n', '    onlyContractAddress(_crydrStorage)\n', "    onlyAllowedManager('set_crydr_storage')\n", '    whenContractPaused\n', '  {\n', '    require(_crydrStorage != address(this));\n', '    require(_crydrStorage != address(crydrStorage));\n', '\n', '    crydrStorage = _crydrStorage;\n', '    CrydrStorageChangedEvent(_crydrStorage);\n', '  }\n', '\n', '  function getCrydrStorageAddress() public constant returns (address) {\n', '    return address(crydrStorage);\n', '  }\n', '\n', '\n', '  function setCrydrView(\n', '    address _newCrydrView, string _viewApiStandardName\n', '  )\n', '    external\n', '    onlyContractAddress(_newCrydrView)\n', '    onlyValidCrydrViewStandardName(_viewApiStandardName)\n', "    onlyAllowedManager('set_crydr_view')\n", '    whenContractPaused\n', '  {\n', '    require(_newCrydrView != address(this));\n', '    require(crydrViewsAddresses[_viewApiStandardName] == address(0x0));\n', '\n', '    var crydrViewInstance = CrydrViewBaseInterface(_newCrydrView);\n', '    var standardNameHash = crydrViewInstance.getCrydrViewStandardNameHash();\n', '    require(standardNameHash == keccak256(_viewApiStandardName));\n', '\n', '    crydrViewsAddresses[_viewApiStandardName] = _newCrydrView;\n', '    isRegisteredView[_newCrydrView] = true;\n', '\n', '    CrydrViewAddedEvent(_newCrydrView, _viewApiStandardName);\n', '  }\n', '\n', '  function removeCrydrView(\n', '    string _viewApiStandardName\n', '  )\n', '    external\n', '    onlyValidCrydrViewStandardName(_viewApiStandardName)\n', "    onlyAllowedManager('remove_crydr_view')\n", '    whenContractPaused\n', '  {\n', '    require(crydrViewsAddresses[_viewApiStandardName] != address(0x0));\n', '\n', '    address removedView = crydrViewsAddresses[_viewApiStandardName];\n', '\n', '    // make changes to the storage\n', '    crydrViewsAddresses[_viewApiStandardName] == address(0x0);\n', '    isRegisteredView[removedView] = false;\n', '\n', '    CrydrViewRemovedEvent(removedView, _viewApiStandardName);\n', '  }\n', '\n', '  function getCrydrViewAddress(\n', '    string _viewApiStandardName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidCrydrViewStandardName(_viewApiStandardName)\n', '    returns (address)\n', '  {\n', '    require(crydrViewsAddresses[_viewApiStandardName] != address(0x0));\n', '\n', '    return crydrViewsAddresses[_viewApiStandardName];\n', '  }\n', '\n', '  function isCrydrViewAddress(\n', '    address _crydrViewAddress\n', '  )\n', '    public\n', '    constant\n', '    returns (bool)\n', '  {\n', '    require(_crydrViewAddress != address(0x0));\n', '\n', '    return isRegisteredView[_crydrViewAddress];\n', '  }\n', '\n', '  function isCrydrViewRegistered(\n', '    string _viewApiStandardName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidCrydrViewStandardName(_viewApiStandardName)\n', '    returns (bool)\n', '  {\n', '    return (crydrViewsAddresses[_viewApiStandardName] != address(0x0));\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBlockableInterface interface\n', ' * @dev Interface of a contract that allows block/unlock accounts\n', ' */\n', 'contract CrydrControllerBlockableInterface {\n', '\n', '  /* blocking/unlocking */\n', '\n', '  function blockAccount(address _account) public;\n', '  function unblockAccount(address _account) public;\n', '\n', '  function blockAccountFunds(address _account, uint256 _value) public;\n', '  function unblockAccountFunds(address _account, uint256 _value) public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBlockable interface\n', ' * @dev Implementation of a contract that allows blocking/unlocking accounts\n', ' */\n', 'contract CrydrControllerBlockable is ManageableInterface,\n', '                                     CrydrControllerBaseInterface,\n', '                                     CrydrControllerBlockableInterface {\n', '\n', '\n', '  /* blocking/unlocking */\n', '\n', '  function blockAccount(\n', '    address _account\n', '  )\n', '    public\n', "    onlyAllowedManager('block_account')\n", '  {\n', '    CrydrStorageBlocksInterface(getCrydrStorageAddress()).blockAccount(_account);\n', '  }\n', '\n', '  function unblockAccount(\n', '    address _account\n', '  )\n', '    public\n', "    onlyAllowedManager('unblock_account')\n", '  {\n', '    CrydrStorageBlocksInterface(getCrydrStorageAddress()).unblockAccount(_account);\n', '  }\n', '\n', '  function blockAccountFunds(\n', '    address _account,\n', '    uint256 _value\n', '  )\n', '    public\n', "    onlyAllowedManager('block_account_funds')\n", '  {\n', '    CrydrStorageBlocksInterface(getCrydrStorageAddress()).blockAccountFunds(_account, _value);\n', '  }\n', '\n', '  function unblockAccountFunds(\n', '    address _account,\n', '    uint256 _value\n', '  )\n', '    public\n', "    onlyAllowedManager('unblock_account_funds')\n", '  {\n', '    CrydrStorageBlocksInterface(getCrydrStorageAddress()).unblockAccountFunds(_account, _value);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerMintableInterface interface\n', ' * @dev Interface of a contract that allows minting/burning of tokens\n', ' */\n', 'contract CrydrControllerMintableInterface {\n', '\n', '  /* minting/burning */\n', '\n', '  function mint(address _account, uint256 _value) public;\n', '  function burn(address _account, uint256 _value) public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerMintable interface\n', ' * @dev Implementation of a contract that allows minting/burning of tokens\n', ' * @dev We do not use events Transfer(0x0, owner, amount) for minting as described in the EIP20\n', ' * @dev because that are not transfers\n', ' */\n', 'contract CrydrControllerMintable is ManageableInterface,\n', '                                    PausableInterface,\n', '                                    CrydrControllerBaseInterface,\n', '                                    CrydrControllerMintableInterface {\n', '\n', '  /* minting/burning */\n', '\n', '  function mint(\n', '    address _account, uint256 _value\n', '  )\n', '    public\n', '    whenContractNotPaused\n', "    onlyAllowedManager('mint_crydr')\n", '  {\n', '    // input parameters checked by the storage\n', '\n', '    CrydrStorageBalanceInterface(getCrydrStorageAddress()).increaseBalance(_account, _value);\n', '\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20MintableInterface(getCrydrViewAddress('erc20')).emitMintEvent(_account, _value);\n", '    }\n', '  }\n', '\n', '  function burn(\n', '    address _account, uint256 _value\n', '  )\n', '    public\n', '    whenContractNotPaused\n', "    onlyAllowedManager('burn_crydr')\n", '  {\n', '    // input parameters checked by the storage\n', '\n', '    CrydrStorageBalanceInterface(getCrydrStorageAddress()).decreaseBalance(_account, _value);\n', '\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20MintableInterface(getCrydrViewAddress('erc20')).emitBurnEvent(_account, _value);\n", '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerERC20Interface interface\n', ' * @dev Interface of a contract that implement business-logic of an ERC20 CryDR\n', ' */\n', 'contract CrydrControllerERC20Interface {\n', '\n', '  /* ERC20 support. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(address _msgsender, address _to, uint256 _value) public;\n', '  function getTotalSupply() public constant returns (uint256);\n', '  function getBalance(address _owner) public constant returns (uint256);\n', '\n', '  function approve(address _msgsender, address _spender, uint256 _value) public;\n', '  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;\n', '  function getAllowance(address _owner, address _spender) public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrControllerERC20Interface interface\n', ' * @dev Interface of a contract that implement business-logic of an ERC20 CryDR\n', ' */\n', 'contract CrydrControllerERC20 is PausableInterface,\n', '                                 CrydrControllerBaseInterface,\n', '                                 CrydrControllerERC20Interface {\n', '\n', '  /* ERC20 support. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(\n', '    address _msgsender,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    onlyCrydrView\n', '    whenContractNotPaused\n', '  {\n', '    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).transfer(_msgsender, _to, _value);\n', '\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_msgsender, _to, _value);\n", '    }\n', '  }\n', '\n', '  function getTotalSupply() public constant returns (uint256) {\n', '    return CrydrStorageBalanceInterface(address(getCrydrStorageAddress())).getTotalSupply();\n', '  }\n', '\n', '  function getBalance(address _owner) public constant returns (uint256) {\n', '    return CrydrStorageBalanceInterface(address(getCrydrStorageAddress())).getBalance(_owner);\n', '  }\n', '\n', '  function approve(\n', '    address _msgsender,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    onlyCrydrView\n', '    whenContractNotPaused\n', '  {\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    // We decided to enforce users to set 0 before set new value\n', '    var allowance = CrydrStorageAllowanceInterface(getCrydrStorageAddress()).getAllowance(_msgsender, _spender);\n', '    require((allowance > 0 && _value == 0) || (allowance == 0 && _value > 0));\n', '\n', '    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).approve(_msgsender, _spender, _value);\n', '\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitApprovalEvent(_msgsender, _spender, _value);\n", '    }\n', '  }\n', '\n', '  function transferFrom(\n', '    address _msgsender,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    onlyCrydrView\n', '    whenContractNotPaused\n', '  {\n', '    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).transferFrom(_msgsender, _from, _to, _value);\n', '\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_from, _to, _value);\n", '    }\n', '  }\n', '\n', '  function getAllowance(address _owner, address _spender) public constant returns (uint256 ) {\n', '    return CrydrStorageAllowanceInterface(address(getCrydrStorageAddress())).getAllowance(_owner, _spender);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTController interface\n', ' * @dev Contains helper methods of JNT controller that needed by other Jibrel contracts\n', ' */\n', 'contract JNTControllerInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTChargedEvent(address indexed payableservice, address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function chargeJNT(address _from, address _to, uint256 _value) public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTPayableService interface\n', ' * @dev Interface of a contract that charge JNT for actions\n', ' */\n', 'contract JNTPayableServiceInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTControllerChangedEvent(address jntcontroller);\n', '  event JNTBeneficiaryChangedEvent(address jntbeneficiary);\n', '  event JNTChargedEvent(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(address _jntController) external;\n', '  function getJntController() public constant returns (address);\n', '\n', '  function setJntBeneficiary(address _jntBeneficiary) external;\n', '  function getJntBeneficiary() public constant returns (address);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function chargeJNTForService(address _from, uint256 _value) internal;\n', '}\n', '\n', '\n', '\n', 'contract JNTPayableService is CommonModifiersInterface,\n', '                              ManageableInterface,\n', '                              PausableInterface,\n', '                              JNTPayableServiceInterface {\n', '\n', '  /* Storage */\n', '\n', '  JNTControllerInterface jntController;\n', '  address jntBeneficiary;\n', '\n', '\n', '  /* JNTPayableServiceInterface */\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(\n', '    address _jntController\n', '  )\n', '    external\n', '    onlyContractAddress(_jntController)\n', "    onlyAllowedManager('set_jnt_controller')\n", '    whenContractPaused\n', '  {\n', '    require(_jntController != address(jntController));\n', '\n', '    jntController = JNTControllerInterface(_jntController);\n', '    JNTControllerChangedEvent(_jntController);\n', '  }\n', '\n', '  function getJntController() public constant returns (address) {\n', '    return address(jntController);\n', '  }\n', '\n', '\n', '  function setJntBeneficiary(\n', '    address _jntBeneficiary\n', '  )\n', '    external\n', '    onlyValidJntBeneficiary(_jntBeneficiary)\n', "    onlyAllowedManager('set_jnt_beneficiary')\n", '    whenContractPaused\n', '  {\n', '    require(_jntBeneficiary != jntBeneficiary);\n', '    require(_jntBeneficiary != address(this));\n', '\n', '    jntBeneficiary = _jntBeneficiary;\n', '    JNTBeneficiaryChangedEvent(jntBeneficiary);\n', '  }\n', '\n', '  function getJntBeneficiary() public constant returns (address) {\n', '    return jntBeneficiary;\n', '  }\n', '\n', '\n', '  /* Actions */\n', '\n', '  function chargeJNTForService(address _from, uint256 _value) internal whenContractNotPaused {\n', '    require(_from != address(0x0));\n', '    require(_from != jntBeneficiary);\n', '    require(_value > 0);\n', '\n', '    jntController.chargeJNT(_from, jntBeneficiary, _value);\n', '    JNTChargedEvent(_from, jntBeneficiary, _value);\n', '  }\n', '\n', '\n', '  /* Pausable */\n', '\n', '  /**\n', '   * @dev Override method to ensure that contract properly configured before it is unpaused\n', '   */\n', '  function unpauseContract()\n', '    public\n', '    onlyContractAddress(jntController)\n', '    onlyValidJntBeneficiary(jntBeneficiary)\n', '  {\n', '    super.unpauseContract();\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  modifier onlyValidJntBeneficiary(address _jntBeneficiary) {\n', '    require(_jntBeneficiary != address(0x0));\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTPayableServiceERC20Fees interface\n', ' * @dev Interface of a CryDR controller that charge JNT for actions\n', ' * @dev Price for actions has a flat value and do not depend on amount of transferred CryDRs\n', ' */\n', 'contract JNTPayableServiceERC20FeesInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTPriceTransferChangedEvent(uint256 value);\n', '  event JNTPriceTransferFromChangedEvent(uint256 value);\n', '  event JNTPriceApproveChangedEvent(uint256 value);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntPrice(uint256 _jntPriceTransfer, uint256 _jntPriceTransferFrom, uint256 _jntPriceApprove) external;\n', '  function getJntPriceForTransfer() public constant returns (uint256);\n', '  function getJntPriceForTransferFrom() public constant returns (uint256);\n', '  function getJntPriceForApprove() public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract JNTPayableServiceERC20Fees is ManageableInterface,\n', '                                       PausableInterface,\n', '                                       JNTPayableServiceERC20FeesInterface {\n', '\n', '  /* Storage */\n', '\n', '  uint256 jntPriceTransfer;\n', '  uint256 jntPriceTransferFrom;\n', '  uint256 jntPriceApprove;\n', '\n', '\n', '  /* Constructor */\n', '\n', '  function JNTPayableServiceERC20Fees(\n', '    uint256 _jntPriceTransfer,\n', '    uint256 _jntPriceTransferFrom,\n', '    uint256 _jntPriceApprove\n', '  )\n', '    public\n', '  {\n', '    jntPriceTransfer = _jntPriceTransfer;\n', '    jntPriceTransferFrom = _jntPriceTransferFrom;\n', '    jntPriceApprove = _jntPriceApprove;\n', '  }\n', '\n', '\n', '  /* JNTPayableServiceERC20FeesInterface */\n', '\n', '  /* Configuration */\n', '\n', '  function setJntPrice(\n', '    uint256 _jntPriceTransfer, uint256 _jntPriceTransferFrom, uint256 _jntPriceApprove\n', '  )\n', '    external\n', "    onlyAllowedManager('set_jnt_price')\n", '    whenContractPaused\n', '  {\n', '    require(_jntPriceTransfer != jntPriceTransfer ||\n', '            _jntPriceTransferFrom != jntPriceTransferFrom ||\n', '            _jntPriceApprove != jntPriceApprove);\n', '\n', '    if (jntPriceTransfer != _jntPriceTransfer) {\n', '      jntPriceTransfer = _jntPriceTransfer;\n', '      JNTPriceTransferChangedEvent(_jntPriceTransfer);\n', '    }\n', '    if (jntPriceTransferFrom != _jntPriceTransferFrom) {\n', '      jntPriceTransferFrom = _jntPriceTransferFrom;\n', '      JNTPriceTransferFromChangedEvent(_jntPriceTransferFrom);\n', '    }\n', '    if (jntPriceApprove != _jntPriceApprove) {\n', '      jntPriceApprove = _jntPriceApprove;\n', '      JNTPriceApproveChangedEvent(_jntPriceApprove);\n', '    }\n', '  }\n', '\n', '  function getJntPriceForTransfer() public constant returns (uint256) {\n', '    return jntPriceTransfer;\n', '  }\n', '\n', '  function getJntPriceForTransferFrom() public constant returns (uint256) {\n', '    return jntPriceTransferFrom;\n', '  }\n', '\n', '  function getJntPriceForApprove() public constant returns (uint256) {\n', '    return jntPriceApprove;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract JCashCrydrController is CommonModifiers,\n', '                                 AssetID,\n', '                                 Ownable,\n', '                                 Manageable,\n', '                                 Pausable,\n', '                                 BytecodeExecutor,\n', '                                 CrydrControllerBase,\n', '                                 CrydrControllerBlockable,\n', '                                 CrydrControllerMintable,\n', '                                 CrydrControllerERC20,\n', '                                 JNTPayableService,\n', '                                 JNTPayableServiceERC20Fees {\n', '\n', '  /* Constructor */\n', '  // 10^18 - assumes that JNT has decimals==18, 1JNT per operation\n', '\n', '  function JCashCrydrController(string _assetID)\n', '    public\n', '    AssetID(_assetID)\n', '    JNTPayableServiceERC20Fees(10^18, 10^18, 10^18)\n', '  {}\n', '\n', '\n', '  /* CrydrControllerERC20 */\n', '\n', '  /* ERC20 support. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(\n', '    address _msgsender,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '  {\n', '    CrydrControllerERC20.transfer(_msgsender, _to, _value);\n', '    chargeJNTForService(_msgsender, getJntPriceForTransfer());\n', '  }\n', '\n', '  function approve(\n', '    address _msgsender,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '  {\n', '    CrydrControllerERC20.approve(_msgsender, _spender, _value);\n', '    chargeJNTForService(_msgsender, getJntPriceForApprove());\n', '  }\n', '\n', '  function transferFrom(\n', '    address _msgsender,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '  {\n', '    CrydrControllerERC20.transferFrom(_msgsender, _from, _to, _value);\n', '    chargeJNTForService(_msgsender, getJntPriceForTransferFrom());\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTController\n', ' * @dev Mediates views and storage of JNT, provides additional methods for Jibrel contracts\n', ' */\n', 'contract JNTController is CommonModifiers,\n', '                          AssetID,\n', '                          Ownable,\n', '                          Manageable,\n', '                          Pausable,\n', '                          BytecodeExecutor,\n', '                          CrydrControllerBase,\n', '                          CrydrControllerBlockable,\n', '                          CrydrControllerMintable,\n', '                          CrydrControllerERC20,\n', '                          JNTControllerInterface {\n', '\n', '  /* Constructor */\n', '\n', "  function JNTController() AssetID('JNT') public {}\n", '\n', '\n', '  /* JNTControllerInterface */\n', '\n', '  function chargeJNT(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', "    onlyAllowedManager('jnt_payable_service') {\n", '    CrydrStorageERC20Interface(address(crydrStorage)).transfer(_from, _to, _value);\n', '    JNTChargedEvent(msg.sender, _from, _to, _value);\n', '  }\n', '}']