['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '    \n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '    \n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '    \n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) \n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '    \n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '    \n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', ' }\n', ' \n', ' /**\n', ' * Date and Time utilities for ethereum contracts\n', ' */\n', ' contract DateTime {\n', '\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) internal pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) internal pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) internal pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) internal pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) internal pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) internal pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) internal pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '    function approve(address _spender, uint _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public constant returns (uint);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '} \n', ' \n', '\n', 'contract EdgeSmartToken is ERC20, SafeMath, DateTime {\n', '\n', '    uint256  public constant _decimals = 18;\n', '    uint256 public constant _totalSupply = (100000000 * 10**_decimals);\n', '    \n', "    string public constant symbol = 'EST';\n", "    string public constant name = 'Edge Smart Token';\n", '    \n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) approved;\n', '    address EdgeSmartTokenOwner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == EdgeSmartTokenOwner);\n', '        _;\n', '    }    \n', '    \n', '    function EdgeSmartToken() public {\n', '        EdgeSmartTokenOwner = msg.sender;\n', '        balances[EdgeSmartTokenOwner] = _totalSupply;\n', '    }\n', '   \n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != EdgeSmartTokenOwner);      \n', '        EdgeSmartTokenOwner = newOwner;\n', '    }    \n', '    \n', '\n', '    function decimals() public constant returns (uint256) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer self tokens to given address\n', '     * @param _to destination address\n', '     * @param _value amount of token values to send\n', '     * @notice `_value` tokens will be sended to `_to`\n', '     * @return `true` when transfer done\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(\n', '            balances[msg.sender] >= _value && _value > 0\n', '        );\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer with approvement mechainsm\n', '     * @param _from source address, `_value` tokens shold be approved for `sender`\n', '     * @param _to destination address\n', '     * @param _value amount of token values to send\n', '     * @notice from `_from` will be sended `_value` tokens to `_to`\n', '     * @return `true` when transfer is done\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(\n', '            approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0\n', '        );\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        approved[_from][msg.sender] = safeSub(approved[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Give to target address ability for self token manipulation without sending\n', '     * @param _spender target address (future requester)\n', '     * @param _value amount of token values for approving\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        approved[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Reset count of tokens approved for given address\n', '     * @param _spender target address (future requester)\n', '     */\n', '    function unapprove(address _spender) public { \n', '        approved[msg.sender][_spender] = 0; \n', '    }\n', '\n', '    /**\n', '     * @dev Take allowed tokens\n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '        return approved[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract EdgeICO is SafeMath, DateTime, EdgeSmartToken {\n', '    \n', '    address owner; \n', '    uint totalCollected = 0;\n', '    uint preSaleCollected = 0;\n', '    uint ICOCollected = 0;\n', '    uint256 public totalTokensCap = (50000000 * 10**_decimals); //50% of total supply\n', '    uint public preSaleTokensLimit = (10000000 * 10**_decimals); //10% of total supply\n', '    \n', '    uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); //5mio EST or 1000 ETH\n', '    uint public icoSaleHardCap = (25000000 * 10**_decimals);//25mio EST or 5000 ETH\n', '   \n', '    uint256 private preSaleTokenPrice = (10000 * 10**_decimals); //10k\n', '    uint256 private ICOTokenPrice = (5000 * 10**_decimals); //5k\n', '   \n', '    bool preSaleActive = false;\n', '    bool ICOActive = false;\n', '   \n', '    uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0);\n', '   \n', '    uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); \n', '    \n', '    //since ICO date and period are not defined precisely, lets put hard end date \n', '    uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); \n', '   \n', '    uint256 private tokensToBuy;\n', '    \n', '    address ICOEdgeWallet = 0xb3AF93036f8949E8A8Ba8D783bF0A63914a63859;\n', '\n', '    //constructor\n', '    function EdgeICO() {\n', '       owner = msg.sender;\n', '    }\n', '   \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function getTotalTokensSold() public constant returns (uint) {\n', '        return totalCollected;\n', '    }\n', '    \n', '    function getPreSaleTokensSold() public constant returns (uint) {\n', '        return preSaleCollected;\n', '    } \n', '    \n', '    function getIcoTokensSold() public constant returns (uint) {\n', '        return ICOCollected;\n', '    }    \n', '    \n', '    function setPreSaleStatus(bool status) onlyOwner public {\n', '        preSaleActive = status;\n', '    }\n', '    \n', '    function setICOStatus(bool status) onlyOwner public {\n', '        ICOActive = status;\n', '    }\n', '    \n', '    function setIcoEndDate(uint endDate) onlyOwner public {\n', '        ICO_end_date = endDate;\n', '    }    \n', '    \n', '    function () public payable {\n', '        createTokens(msg.sender);\n', '    }\n', '    \n', '    function createTokens(address recipient) public payable {\n', '        \n', '        require(now < ICO_hardcoded_expiry_date);\n', '        \n', '        \n', '        if (preSaleActive && (now < pre_ICO_end_date)) {\n', '            require(msg.value >= 1 * (1 ether)); //minimum 1 ETH\n', '            tokensToBuy = safeDiv(safeMul(msg.value * 1 ether, preSaleTokenPrice), 1000000000000000000 ether);  \n', '            require (preSaleCollected + tokensToBuy <= preSaleTokensLimit); //within preSale sell only 10mio \n', '            require (totalCollected + tokensToBuy <= totalTokensCap); //max sell 50mio\n', '            preSaleCollected = safeAdd(preSaleCollected, tokensToBuy);\n', '            totalCollected = safeAdd(totalCollected, tokensToBuy);\n', '            \n', '            balances[recipient] = safeAdd(balances[recipient], tokensToBuy);\n', '            balances[owner] = safeSub(balances[owner], tokensToBuy);\n', '            Transfer(owner, recipient, tokensToBuy);\n', '            // send and transfer are considered to be a safe way to move funds as they have a gas stipend of 2300\n', '            ICOEdgeWallet.transfer(msg.value);\n', '            \n', '        }\n', '        else\n', '        if (ICOActive && (now < ICO_end_date)) {\n', '            require(msg.value >= 0.1 * (1 ether)); //minimum 0.1 ETH\n', '            tokensToBuy = safeDiv(safeMul(msg.value * 1 ether, ICOTokenPrice), 1000000000000000000 ether);\n', '            require (totalCollected + tokensToBuy <= totalTokensCap); //max sell 50mio, 40mio + rest from preSale\n', '            ICOCollected = safeAdd(ICOCollected, tokensToBuy);\n', '            totalCollected = safeAdd(totalCollected, tokensToBuy);\n', '            \n', '            balances[recipient] = safeAdd(balances[recipient], tokensToBuy);\n', '            balances[owner] = safeSub(balances[owner], tokensToBuy);\n', '            Transfer(owner, recipient, tokensToBuy);\n', '            //Both send and transfer are considered to be a safe way to move funds as they have a gas stipend of 2300\n', '            ICOEdgeWallet.transfer(msg.value); \n', '            \n', '        }\n', '        else  {\n', '            //preSale and ICO finished\n', '            throw;\n', '        }\n', '    }\n', '}']