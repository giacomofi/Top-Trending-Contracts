['pragma solidity ^ 0.4.18;\n', '\n', 'contract ERC20 {\n', '  uint256 public totalsupply;\n', '  function totalSupply() public constant returns(uint256 _totalSupply);\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool ok);\n', '  function approve(address spender, uint256 value) public returns (bool ok);\n', '  function transfer(address to, uint256 value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) pure internal returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) pure internal returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) pure internal returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) pure internal returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ShipBloc is ERC20 {\n', '    \n', '    using SafeMath\n', '    for uint256;\n', '    \n', '    // string public constant name = "Abc Token";\n', '    string public constant name = "ShipBloc Token";\n', '\n', '    // string public constant symbol = "ABCT";\n', '    string public constant symbol = "SBLOC";\n', '\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public constant totalsupply = 82500000 * (10 ** 18);\n', '    uint256 public constant teamAllocated = 14025000 * (10 ** 18);\n', '    uint256 public constant maxPreSale1Token = 15000000 * (10 ** 18);\n', '    uint256 public constant maxPreSale2Token = 30000000 * (10 ** 18);\n', '    uint256 public totalUsedTokens = 0;\n', '      \n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    \n', '    address owner = 0xA7A58F56258F9a6540e4A8ebfde617F752A56094;\n', '    \n', '    event supply(uint256 bnumber);\n', '\n', '    event events(string _name);\n', '    \n', '    uint256 public no_of_tokens;\n', '    \n', '    uint preICO1Start;\n', '    uint preICO1End;\n', '    uint preICO2Start;\n', '    uint preICO2End;\n', '    uint ICOStart;\n', '    uint ICOEnd;\n', '    \n', '    enum Stages {\n', '        NOTSTARTED,\n', '        PREICO1,\n', '        PREICO2,\n', '        ICO,\n', '        ENDED\n', '    }\n', '    \n', '    mapping(uint => Stages) stage;\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '   \n', '    function ShipBloc(uint _preICO1Start,uint _preICO1End,uint _preICO2Start,uint _preICO2End,uint _ICOStart,uint _ICOEnd) public {\n', '        balances[owner] = teamAllocated;      \n', '        balances[address(this)] = SafeMath.sub(totalsupply,teamAllocated);\n', '        stage[0]=Stages.NOTSTARTED;\n', '        stage[1667]=Stages.PREICO1;\n', '        stage[1000]=Stages.PREICO2;\n', '        stage[715]=Stages.ICO;\n', '        stage[1]=Stages.ENDED;\n', '        preICO1Start=_preICO1Start;\n', '        preICO1End=_preICO1End;\n', '        preICO2Start=_preICO2Start;\n', '        preICO2End=_preICO2End;\n', '        ICOStart=_ICOStart;\n', '        ICOEnd=_ICOEnd;\n', '    }\n', '    \n', '    function () public payable {\n', '        require(msg.value != 0);\n', '        uint256 _price_tokn = checkStage();\n', '        if(stage[_price_tokn] != Stages.NOTSTARTED && stage[_price_tokn] != Stages.ENDED) {\n', '            no_of_tokens = SafeMath.mul(msg.value , _price_tokn); \n', '            if(balances[address(this)] >= no_of_tokens ) {\n', '                totalUsedTokens = SafeMath.add(totalUsedTokens,no_of_tokens);\n', '                balances[address(this)] =SafeMath.sub(balances[address(this)],no_of_tokens);\n', '                balances[msg.sender] = SafeMath.add(balances[msg.sender],no_of_tokens);\n', '                Transfer(address(this), msg.sender, no_of_tokens);\n', '                owner.transfer(this.balance);\n', '            } else {\n', '                revert();\n', '            }\n', '        } else {\n', '            revert();\n', '        }\n', '   }\n', '    \n', '    function totalSupply() public constant returns(uint256) {\n', '       return totalsupply;\n', '    }\n', '    \n', '     function balanceOf(address sender) public constant returns(uint256 balance) {\n', '        return balances[sender];\n', '    }\n', '\n', '    \n', '    function transfer(address _to, uint256 _amount) public returns(bool success) {\n', '        require(stage[checkStage()] == Stages.ENDED);\n', '        if (balances[msg.sender] >= _amount &&\n', '            _amount > 0 &&\n', '            balances[_to] + _amount > balances[_to]) {\n', '         \n', '            balances[msg.sender] = SafeMath.sub(balances[msg.sender],_amount);\n', '            balances[_to] = SafeMath.add(balances[_to],_amount);\n', '            Transfer(msg.sender, _to, _amount);\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function checkStage() internal view returns(uint) {\n', '        uint currentBlock = block.number;\n', '        if (currentBlock < preICO1Start){\n', '            return 0;    \n', '        } else if (currentBlock < preICO1End) {\n', '            require(maxPreSale1Token>totalUsedTokens);\n', '            return 1667;    \n', '        } else if (currentBlock < preICO2Start) {\n', '            return 0;    \n', '        } else if (currentBlock < preICO2End) {\n', '            require(maxPreSale2Token>totalUsedTokens);\n', '            return 1000;    \n', '        } else if (currentBlock < ICOStart) {\n', '            return 0;\n', '        } else if (currentBlock < ICOEnd) {\n', '            return 715;    \n', '        }\n', '        return 1;\n', '    }\n', '    \n', '    function getStageandPrice() public view returns(uint,uint){\n', '        return (checkStage(),uint(stage[checkStage()]));\n', '    }\n', '   \n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) public returns(bool success) {\n', '            require(stage[checkStage()] == Stages.ENDED);\n', '            require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);    \n', '                \n', '            balances[_from] = SafeMath.sub(balances[_from],_amount);\n', '            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _amount);\n', '            balances[_to] = SafeMath.add(balances[_to], _amount);\n', '            Transfer(_from, _to, _amount);\n', '            \n', '            return true;\n', '       \n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function drain() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function drainToken() external onlyOwner {\n', '        require(stage[checkStage()] == Stages.ENDED);\n', '        balances[owner] = SafeMath.add(balances[owner],balances[address(this)]);\n', '        Transfer(address(this), owner, balances[address(this)]);\n', '        balances[address(this)] = 0;\n', '    }\n', '\n', '}']