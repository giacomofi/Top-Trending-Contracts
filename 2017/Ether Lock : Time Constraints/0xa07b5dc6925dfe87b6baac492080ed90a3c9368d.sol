['pragma solidity ^0.4.18;\n', '/**\n', '* @title ERC20 interface\n', '* @dev see https://github.com/ethereum/EIPs/issues/20\n', '*/\n', 'contract ERC20 {\n', '        uint256 public totalSupply;\n', '        function balanceOf(address who) public view returns (uint256);\n', '        function transfer(address to, uint256 value) public returns (bool);\n', '        function allowance(address owner, address spender) public view returns (uint256);\n', '        function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '        function approve(address spender, uint256 value) public returns (bool);\n', '        event Transfer(address indexed from, address indexed to, uint256 value);\n', '        event Approval(address indexed owner, address indexed spender, uint256 value);\n', '        }\n', '\n', 'contract ESOFTCOIN is ERC20 {\n', '        string public constant name="ESOFTCOIN";\n', '        string public constant symbol="ESC";\n', '        uint256 public constant decimals=18;\n', '        uint public  totalSupply=20000000 * 10 ** uint256(decimals);\n', '\n', '        mapping(address => uint256) balances;\n', '        mapping (address => mapping (address => uint256)) public allowedToSpend;\n', '     \n', '\n', '        function ESOFTCOIN() public{\n', '                balances[msg.sender]=totalSupply;\n', '        }\n', '\n', '\n', '        /**\n', '        * @dev Gets the balance of the specified address.\n', '        * @param _owner The address to query the the balance of.\n', '        * @return An uint256 representing the amount owned by the passed address.\n', '        */\n', '        function balanceOf(address _owner) public view returns (uint256 balance) {\n', '                return balances[_owner];\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) public view returns (uint256){\n', '                return allowedToSpend[_owner][_spender];\n', '        }\n', '\n', '        function approve(address _spender, uint256 _value) public returns (bool){\n', '        allowedToSpend[msg.sender][_spender] = _value;\n', '                return true;\n', '        }\n', '\n', '\n', '\n', '        /**\n', '        * @dev transfer token for a specified address\n', '        * @param _to The address to transfer to.\n', '        * @param _value The amount to be transferred.\n', '        */\n', '        function transfer(address _to, uint256 _value) public returns (bool) {\n', '                require(_to != address(0));\n', '                require(_value <= balances[msg.sender]);\n', '\n', '                // SafeMath.sub will throw if there is not enough balance.\n', '                balances[msg.sender] -=_value;\n', '                balances[_to] +=_value;\n', '                Transfer(msg.sender, _to, _value);\n', '                return true;\n', '        }\n', '\n', '\n', '        /**\n', '        * @dev transfer token for a specified address\n', '        * @param _from The address to transfer to.\n', '        * @param _to The address to transfer to.\n', '        * @param _value The amount to be transferred.\n', '        */\n', '        function transferFrom(address _from,address _to, uint256 _value) public returns (bool) {\n', '                require(_to != address(0));\n', '                require(_value <= balances[msg.sender]);\n', '                require(_value <= allowedToSpend[_from][msg.sender]);     // Check allowance\n', '                allowedToSpend[_from][msg.sender] -= _value;\n', '                // SafeMath.sub will throw if there is not enough balance.\n', '                balances[msg.sender] -= _value;\n', '                balances[_to] += _value;\n', '                Transfer(msg.sender, _to, _value);\n', '                return true;\n', '        }\n', '\n', '\n', '\n', '\n', '\n', '}\n', '\n', 'contract ESOFTCOINCROWDSALE is ESOFTCOIN{\n', '        address internal _wallet;\n', '        address internal _owner;\n', '        address internal _gasnode;\n', '        \n', '        uint256 public _presaleStartTimestamp=1512345600;\n', '        uint256 public _presaleEndTimestamp=1512950340;\n', '        uint _tokenPresalesRate=900;\n', '        \n', '        uint256 public _batch1_icosaleStartTimestamp=1513123200;\n', '        uint256 public _batch1_icosaleEndTimestamp=1513468740;\n', '        uint256 public _batch1_rate=450;\n', '        \n', '        uint256 public _batch2_icosaleStartTimestamp=1513641600;\n', '        uint256 public _batch2_icosaleEndTimestamp=1514073540;\n', '        uint256 public _batch2_rate=375;\n', '        \n', '        uint256 public _batch3_icosaleStartTimestamp=1514332800;\n', '        uint256 public _batch3_icosaleEndTimestamp=1514937540;\n', '        uint256 public _batch3_rate=300;\n', '        \n', '        uint256 public _batch4_icosaleStartTimestamp=1515196800;\n', '        uint256 public _batch4_icosaleEndTimestamp=1515801540;\n', '        uint256 public _batch4_rate=225;\n', '\n', '\n', '        function  ESOFTCOINCROWDSALE(address _ethReceiver,address gasNode) public{\n', '                _wallet=_ethReceiver;\n', '                _owner=msg.sender;\n', '                _gasnode=gasNode;\n', '        }\n', '\n', '        function() payable public{\n', '                buyTokens();        \n', '        }\n', '\n', '        function getRate() view public returns(uint){\n', '                if(now>=_presaleStartTimestamp && now<= _presaleEndTimestamp ){\n', '                        return _tokenPresalesRate;\n', '                }\n', '                else if(now >=_batch1_icosaleStartTimestamp && now <=_batch1_icosaleEndTimestamp){\n', '                       return  _batch1_rate;\n', '                }\n', '                else if(now >=_batch2_icosaleStartTimestamp && now<=_batch2_icosaleEndTimestamp){\n', '                       return  _batch2_rate;\n', '                }\n', '                else if(now >=_batch3_icosaleStartTimestamp && now<=_batch3_icosaleEndTimestamp){\n', '                       return  _batch3_rate;\n', '                }\n', '                else if(now >=_batch4_icosaleStartTimestamp){\n', '                       return  _batch4_rate;\n', '                }\n', '        }\n', '\n', '       \n', '\n', '        function buyTokens() internal{\n', '                issueTokens(msg.sender,msg.value);\n', '                forwardFunds();\n', '        }\n', '\n', '\n', '        function _transfer(address _from, address _to, uint _value) public {\n', '                // Prevent transfer to 0x0 address. Use burn() instead\n', '                require(_to != 0x0);\n', '                // Check if the sender has enough\n', '                require(balances[_from] >= _value);\n', '                // Check for overflows\n', '                require(balances[_to] + _value > balances[_to]);\n', '                // Subtract from the sender\n', '                balances[_from] -= _value;\n', '                // Add the same to the recipient\n', '                balances[_to] += _value;\n', '                Transfer(_from, _to, _value);\n', '\n', '        }\n', '\n', '\n', '\n', '        function calculateTokens(uint256 _amount) public view returns (uint256 tokens){                \n', '                tokens = _amount*getRate();\n', '                return tokens;\n', '        }\n', '\n', '\n', '\n', '        function issueTokens(address _tokenBuyer, uint _valueofTokens) internal {\n', '                require(_tokenBuyer != 0x0);\n', '                require(_valueofTokens >0);\n', '                uint _amountofTokens=calculateTokens(_valueofTokens);\n', '              _transfer(_owner,_tokenBuyer,_amountofTokens);\n', '        }\n', '\n', '\n', '\n', '        function paygasfunds()internal{\n', '             _gasnode.transfer(this.balance);\n', '        }\n', '        \n', '\n', '        function forwardFunds()internal {\n', '                 require(msg.value>0);\n', '                _wallet.transfer((msg.value * 950)/1000);\n', '                paygasfunds();\n', '        }\n', '\n', '\n', '}']