['contract Disbursement {\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    address public receiver;\n', '    uint public disbursementPeriod;\n', '    uint public startDate;\n', '    uint public withdrawnTokens;\n', '    Token public token;\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier isOwner() {\n', '        if (msg.sender != owner)\n', '            // Only owner is allowed to proceed\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier isReceiver() {\n', '        if (msg.sender != receiver)\n', '            // Only receiver is allowed to proceed\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier isSetUp() {\n', '        if (address(token) == 0)\n', '            // Contract is not set up\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    /// @dev Constructor function sets contract owner\n', '    /// @param _receiver Receiver of vested tokens\n', '    /// @param _disbursementPeriod Vesting period in seconds\n', '    /// @param _startDate Start date of disbursement period (cliff)\n', '    function Disbursement(address _receiver, uint _disbursementPeriod, uint _startDate)\n', '        public\n', '    {\n', '        if (_receiver == 0 || _disbursementPeriod == 0)\n', '            // Arguments are null\n', '            revert();\n', '        owner = msg.sender;\n', '        receiver = _receiver;\n', '        disbursementPeriod = _disbursementPeriod;\n', '        startDate = _startDate;\n', '        if (startDate == 0)\n', '            startDate = now;\n', '    }\n', '\n', "    /// @dev Setup function sets external contracts' addresses\n", '    /// @param _token Token address\n', '    function setup(address _token)\n', '        public\n', '        isOwner\n', '    {\n', '        if (address(token) != 0 || address(_token) == 0)\n', '            // Setup was executed already or address is null\n', '            revert();\n', '        token = Token(_token);\n', '    }\n', '\n', '    /// @dev Transfers tokens to a given address\n', '    /// @param _to Address of token receiver\n', '    /// @param _value Number of tokens to transfer\n', '    function withdraw(address _to, uint256 _value)\n', '        public\n', '        isReceiver\n', '        isSetUp\n', '    {\n', '        uint maxTokens = calcMaxWithdraw();\n', '        if (_value > maxTokens)\n', '            revert();\n', '        withdrawnTokens += _value;\n', '        token.transfer(_to, _value);\n', '    }\n', '\n', '    /// @dev Calculates the maximum amount of vested tokens\n', '    /// @return Number of vested tokens to withdraw\n', '    function calcMaxWithdraw()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;\n', '        if (withdrawnTokens >= maxTokens || startDate > now)\n', '            return 0;\n', '        return maxTokens - withdrawnTokens;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']