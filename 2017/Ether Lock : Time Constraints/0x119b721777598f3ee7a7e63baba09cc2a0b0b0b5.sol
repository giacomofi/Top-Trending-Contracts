['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint a, uint b) internal constant returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal constant returns(uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal constant returns(uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal constant returns(uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '} // Functions of ERC20 standard\n', '\n', '\n', '\n', 'contract DatariusICO {\n', '    using SafeMath for uint;\n', '\n', '    uint public constant Tokens_For_Sale = 146000000*1e18; // Tokens for Sale without bonuses(HardCap)\n', '    uint public constant Total_Amount = 200000000*1e18; // Fixed total supply\n', '    uint public Sold = 0;\n', '\n', '    uint CONST_DEL = 1000;\n', '\n', '    uint public Tokens_Per_Dollar = 2179;\n', '    uint public Rate_Eth = 446; // Rate USD per ETH\n', '    uint public Token_Price = Tokens_Per_Dollar * Rate_Eth / CONST_DEL; // DAT per ETH\n', '\n', '    event LogStartPreICO();\n', '    event LogStartICO();\n', '    event LogPause();\n', '    event LogFinishPreICO();\n', '    event LogFinishICO(address ReserveFund);\n', '    event LogBuyForInvestor(address investor, uint datValue, string txHash);\n', '\n', '    DAT public dat = new DAT(this);\n', '\n', '    address public Company;\n', '    address public BountyFund;\n', '    address public SupportFund;\n', '    address public ReserveFund;\n', '    address public TeamFund;\n', '\n', '    address public Manager; // Manager controls contract\n', '    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\n', '    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\n', '    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\n', '    modifier managerOnly { require(msg.sender == Manager); _; }\n', '    modifier controllersOnly {\n', '      require((msg.sender == Controller_Address1) || (msg.sender == Controller_Address2) || (msg.sender == Controller_Address3));\n', '      _;\n', '    }\n', '\n', '    uint startTime = 0;\n', '    uint bountyAmount = 4000000*1e18;\n', '    uint supportAmount = 10000000*1e18;\n', '    uint reserveAmount = 24000000*1e18;\n', '    uint teamAmount = 16000000*1e18;\n', '\n', '    enum Status {\n', '                  Created,\n', '                  PreIcoStarted,\n', '                  PreIcoFinished,\n', '                  PreIcoPaused,\n', '                  IcoPaused,\n', '                  IcoStarted,\n', '                  IcoFinished\n', '                  }\n', '    Status status = Status.Created;\n', '\n', '    function DatariusICO(\n', '                          address _Company,\n', '                          address _BountyFund,\n', '                          address _SupportFund,\n', '                          address _ReserveFund,\n', '                          address _TeamFund,\n', '                          address _Manager,\n', '                          address _Controller_Address1,\n', '                          address _Controller_Address2,\n', '                          address _Controller_Address3\n', '                          ) public {\n', '       Company = _Company;\n', '       BountyFund = _BountyFund;\n', '       SupportFund = _SupportFund;\n', '       ReserveFund = _ReserveFund;\n', '       TeamFund = _TeamFund;\n', '       Manager = _Manager;\n', '       Controller_Address1 = _Controller_Address1;\n', '       Controller_Address2 = _Controller_Address2;\n', '       Controller_Address3 = _Controller_Address3;\n', '    }\n', '\n', '// function for changing rate of ETH and price of token\n', '\n', '\n', '    function setRate(uint _RateEth) external managerOnly {\n', '       Rate_Eth = _RateEth;\n', '       Token_Price = Tokens_Per_Dollar*Rate_Eth/CONST_DEL;\n', '    }\n', '\n', '\n', '//ICO status functions\n', '\n', '    function startPreIco() external managerOnly {\n', '       require(status == Status.Created || status == Status.PreIcoPaused);\n', '       if(status == Status.Created) {\n', '           dat.mint(BountyFund, bountyAmount);\n', '           dat.mint(SupportFund, supportAmount);\n', '           dat.mint(ReserveFund, reserveAmount);\n', '           dat.mint(TeamFund, teamAmount);\n', '       }\n', '       status = Status.PreIcoStarted;\n', '       LogStartPreICO();\n', '    }\n', '\n', '    function finishPreIco() external managerOnly { // Funds for minting of tokens\n', '       require(status == Status.PreIcoStarted || status == Status.PreIcoPaused);\n', '\n', '       status = Status.PreIcoFinished;\n', '       LogFinishPreICO();\n', '    }\n', '\n', '\n', '    function startIco() external managerOnly {\n', '       require(status == Status.PreIcoFinished || status == Status.IcoPaused);\n', '       if(status == Status.PreIcoFinished) {\n', '         startTime = now;\n', '       }\n', '       status = Status.IcoStarted;\n', '       LogStartICO();\n', '    }\n', '\n', '    function finishIco() external managerOnly { // Funds for minting of tokens\n', '\n', '       require(status == Status.IcoStarted || status == Status.IcoPaused);\n', '\n', '       uint alreadyMinted = dat.totalSupply(); //=PublicICO+PrivateOffer\n', '\n', '       dat.mint(ReserveFund, Total_Amount.sub(alreadyMinted)); //\n', '\n', '       dat.defrost();\n', '\n', '       status = Status.IcoFinished;\n', '       LogFinishICO(ReserveFund);\n', '    }\n', '\n', '    function pauseIco() external managerOnly {\n', '       require(status == Status.IcoStarted);\n', '       status = Status.IcoPaused;\n', '       LogPause();\n', '    }\n', '    function pausePreIco() external managerOnly {\n', '       require(status == Status.PreIcoStarted);\n', '       status = Status.PreIcoPaused;\n', '       LogPause();\n', '    }\n', '\n', '// function that buys tokens when investor sends ETH to address of ICO\n', '    function() external payable {\n', '\n', '       buy(msg.sender, msg.value * Token_Price);\n', '    }\n', '\n', '// function for buying tokens to investors who paid in other cryptos\n', '\n', '    function buyForInvestor(address _investor, uint _datValue, string _txHash) external controllersOnly {\n', '       buy(_investor, _datValue);\n', '       LogBuyForInvestor(_investor, _datValue, _txHash);\n', '    }\n', '\n', '// internal function for buying tokens\n', '\n', '    function buy(address _investor, uint _datValue) internal {\n', '       require((status == Status.PreIcoStarted) || (status == Status.IcoStarted));\n', '       require(_datValue > 0);\n', '\n', '       uint bonus = getBonus(_datValue);\n', '\n', '       uint total = _datValue.add(bonus);\n', '\n', '       require(Sold + total <= Tokens_For_Sale);\n', '       dat.mint(_investor, total);\n', '       Sold = Sold.add(_datValue);\n', '    }\n', '\n', '// function that calculates bonus\n', '    function getBonus(uint _value) public constant returns (uint) {\n', '       uint bonus = 0;\n', '       uint time = now;\n', '       if(status == Status.PreIcoStarted) {\n', '            bonus = _value.mul(35).div(100);\n', '            return bonus;\n', '       } else {\n', '            if(time <= startTime + 6 hours)\n', '            {\n', '\n', '                  bonus = _value.mul(30).div(100);\n', '                  return bonus;\n', '            }\n', '\n', '            if(time <= startTime + 12 hours)\n', '            {\n', '                  bonus = _value.mul(25).div(100);\n', '                  return bonus;\n', '            }\n', '\n', '            if(time <= startTime + 24 hours)\n', '            {\n', '\n', '                  bonus = _value.mul(20).div(100);\n', '                  return bonus;\n', '            }\n', '\n', '            if(time <= startTime + 48 hours)\n', '            {\n', '\n', '                  bonus = _value.mul(10).div(100);\n', '                  return bonus;\n', '            }\n', '       }\n', '       return bonus;\n', '    }\n', '\n', '//function to withdraw ETH from smart contract\n', '\n', '    function withdrawEther(uint256 _value) external managerOnly {\n', '       require((status == Status.PreIcoFinished) || (status == Status.IcoFinished));\n', '       Company.transfer(_value);\n', '    }\n', '\n', '}\n', '\n', 'contract DAT  is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "Datarius Token";\n', '    string public symbol = "DAT";\n', '    uint public decimals = 18;\n', '\n', '    address public ico;\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    bool public tokensAreFrozen = true;\n', '\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '\n', '    function DAT(address _ico) public {\n', '       ico = _ico;\n', '    }\n', '\n', '\n', '    function mint(address _holder, uint _value) external icoOnly {\n', '       require(_value > 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '\n', '    function defrost() external icoOnly {\n', '       tokensAreFrozen = false;\n', '    }\n', '\n', '    function burn(uint256 _value) {\n', '       require(!tokensAreFrozen);\n', '       balances[msg.sender] = balances[msg.sender].sub(_value);\n', '       totalSupply = totalSupply.sub(_value);\n', '       Burn(msg.sender, _value);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '         return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount) public returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '     }\n', '\n', '\n', '    function approve(address _spender, uint256 _amount) public returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']