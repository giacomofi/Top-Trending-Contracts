['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;}\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); \n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); \n', '        return c;}\n', ' function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;}\n', 'function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;}}\n', '//------------------------------------------------------------------------------------------------------------------//\n', '    contract ERC20 {\n', '     function totalSupply() constant returns (uint256 totalSupply);                                 //TotalSupply\n', '     function balanceOf(address _owner) constant returns (uint256 balance);                         //See Balance Of\n', '     function transfer(address _to, uint256 _value) returns (bool success);                         //Transfer\n', '     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);      //TransferFrom\n', '     function approve(address _spender, uint256 _value) returns (bool success);                     //Approve\n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining);     //Allowance\n', '     function Mine_Block() returns (bool);            //Mine Function\n', '     function Proof_of_Stake() returns (bool);\n', '     function Request_Airdrop() returns (bool);     //Airdrop Function\n', '     event Mine(address indexed _address, uint _reward);      \n', '     event MinePoS(address indexed _address, uint rewardPoS);\n', '     event MineAD (address indexed _address, uint rewardAD);\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '     event SponsoredLink(string newNote);}\n', '//------------------------------------------------------------------------------------------------------------------//     \n', '  contract EthereumWhite is ERC20 {                    //Name of the Contract\n', '     using SafeMath for uint256;                       //Use SafeMath\n', '     string public constant symbol = "EWHITE";         //Token Symbol\n', '     string public constant name = "Ethereum White";   //Token Name\n', '     uint8 public constant decimals = 8;               //Decimals\n', '     uint256 _totalSupply = 9000000 * (10**8);         //TotalSupply starts to 9 Million \n', '     uint256 public _maxtotalSupply = 90000000 * (10**8);  // MaxTotalSupply is 90 Million\n', '     uint clock;                                       //mining time\n', '     uint public clockairdrop;                         //airdroptime\n', '     uint clockowner;                                  //double check anti cheat\n', '     uint public clockpos;                             //Pos Time\n', '     uint public clockmint;\n', '     uint MultiReward;           \n', '     uint MultiRewardAD;                       \n', '     uint public Miners;                               // Maximum Miners requestes for actual block\n', '     uint public Airdrop;                              //Maximum Airdrop requestes for actual block\n', '     uint public PoS;\n', '     uint public TotalAirdropRequests;                 //Total Airdrops from the biginning \n', '     uint public TotalPoSRequests;                     //Total PoS from the biginning\n', '     uint public  rewardAD;                            //Show last rewad for Airdrop\n', '     uint public _reward;                              //Show last reward for miners\n', '     uint public _rewardPoS;                           //Show last reward for PoS\n', '     uint public MaxMinersXblock;                      //Show number of miners allowed each block\n', '     uint public MaxAirDropXblock;                     //Show number of Airdrops allowed each block\n', '     uint public MaxPoSXblock;                         //Show number of PoS allowed each block\n', '     uint public constant InitalPos = 10000 * (10**8); // Start Proof-of-stake\n', '     uint public gas;                                  // Fee Reimbursement\n', '     uint public BlockMined;                           //Total blocks Mined\n', '     uint public PoSPerCent;                           //PoSPerCent \n', '     uint public reqfee;\n', '     struct transferInStruct{\n', '     uint128 reward;\n', '     uint64 time;  }\n', '     address public owner;\n', '     mapping(address => uint256) balances;\n', '     mapping(address => mapping (address => uint256)) allowed;\n', '     mapping(address => transferInStruct[]) transferIns;\n', '//------------------------------------------------------------------------------------------------------------------//    \n', 'function InitialSettings() onlyOwner returns (bool success) {\n', '    MultiReward = 45;     \n', '    MultiRewardAD = 45;\n', '    PoSPerCent = 2000;\n', '    Miners = 0;         \n', '    Airdrop = 0;                        \n', '    PoS = 0;\n', '    MaxMinersXblock = 10;                   \n', '    MaxAirDropXblock=5;            \n', '    MaxPoSXblock=2;       \n', '    clock = 1509269936;                                 \n', '    clockairdrop = 1509269936;                         \n', '    clockowner = 1509269936;                           \n', '    clockpos = 1509269936;                             \n', '    clockmint = 1509269936;\n', '    reqfee = 1000000000;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     modifier onlyPayloadSize(uint size) { \n', '        require(msg.data.length >= size + 4);\n', '        _;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '    string public SponsoredLink = "Ethereum White";        \n', '    function setSponsor(string note_) public onlyOwner {\n', '      SponsoredLink = note_;\n', '      SponsoredLink(SponsoredLink); }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '    function ShowADV(){\n', '       SponsoredLink(SponsoredLink);}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     function EthereumWhite() {\n', '         owner = msg.sender;\n', '         balances[owner] = 9000000 * (10**8);\n', '         }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;  }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     function totalSupply() constant returns (uint256 totalSupply) {\n', '         totalSupply = _totalSupply;      }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];     }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function SetMaxMinersXblock(uint _MaxMinersXblock) onlyOwner {\n', '        MaxMinersXblock=  _MaxMinersXblock;   }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function SetMaxAirDropXblock(uint _MaxAirDropXblock) onlyOwner {\n', '        MaxAirDropXblock=  _MaxAirDropXblock;        }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function SetMaxPosXblock(uint _MaxPoSXblock) onlyOwner {\n', '         MaxPoSXblock=  _MaxPoSXblock;        }        \n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function SetRewardMultiAD(uint _MultiRewardAD) onlyOwner {\n', '         MultiRewardAD=  _MultiRewardAD;        }        \n', '//------------------------------------------------------------------------------------------------------------------//          \n', '      function SetRewardMulti(uint _MultiReward) onlyOwner {\n', '         MultiReward=  _MultiReward;        }        \n', ' //------------------------------------------------------------------------------------------------------------------// \n', '        function SetGasFeeReimbursed(uint _Gasfee) onlyOwner{\n', '         gas=  _Gasfee * 1 wei;}       \n', '//------------------------------------------------------------------------------------------------------------------// \n', '         function transfer(address _to, uint256 _amount)  onlyPayloadSize(2 * 32) returns (bool success){\n', '         if (balances[msg.sender] >= _amount \n', '            && _amount > 0\n', '             && balances[_to] + _amount > balances[_to]) {\n', '             if(_totalSupply> _maxtotalSupply){\n', '             gas = 0;\n', '             }\n', '                if (balances[msg.sender] >= reqfee){\n', '             balances[msg.sender] -= _amount - gas ;}\n', '             else{\n', '            balances[msg.sender] -= _amount;}\n', '             balances[_to] += _amount;\n', '             Transfer(msg.sender, _to, _amount);\n', '             _totalSupply = _totalSupply.add(tx.gasprice);\n', '             ShowADV();\n', '            return true;\n', '             } else { throw;}}\n', '\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n', '         if (balances[_from] >= _amount\n', '             && allowed[_from][msg.sender] >= _amount\n', '             && _amount > 0\n', '             && balances[_to] + _amount > balances[_to]) {\n', '             balances[_from] -= _amount;\n', '             allowed[_from][msg.sender] -= _amount;\n', '             balances[_to] += _amount;\n', '             Transfer(_from, _to, _amount);\n', '             ShowADV();\n', '             return true;\n', '         }   else {\n', '             throw;} }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '         modifier canMint() {\n', '         uint _now = now;\n', '        require(_totalSupply < _maxtotalSupply);\n', '        require ((_now.sub(clockmint)).div(90 seconds) >= 1);\n', '        _; }\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function Mine_Block() canMint returns (bool) {\n', '         if(clockmint < clockowner) {return false;}\n', '         if(Miners >= MaxMinersXblock){\n', '         clockmint = now; \n', '         Miners=0;\n', '         return true;}\n', '         if(balances[msg.sender] <= (100 * (10**8))){ return false;}\n', '         Miners++;\n', '         uint Calcrewardminers =1000000*_maxtotalSupply.div(((_totalSupply/9)*10)+(TotalAirdropRequests));\n', '         _reward = Calcrewardminers*MultiReward;  \n', '         uint reward = _reward;\n', '        _totalSupply = _totalSupply.add(reward);\n', '        balances[msg.sender] = balances[msg.sender].add(reward);\n', '        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\n', '        Mine(msg.sender, reward);\n', '        BlockMined++;\n', '        ShowADV();\n', '        return true;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        modifier canAirdrop() { \n', '         uint _now = now;\n', '        require(_totalSupply < _maxtotalSupply);\n', '        require ((_now.sub(clockairdrop)).div(60 seconds) >= 1);\n', '        _;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '         function Request_Airdrop() canAirdrop returns (bool) {\n', '         if(clockairdrop < clockowner){ return false;}\n', '         if(Airdrop >= MaxAirDropXblock){\n', '         clockairdrop = now; \n', '         Airdrop=0;\n', '        return true; }\n', '          if(balances[msg.sender] > (100 * (10**8))) return false;\n', '         Airdrop++;\n', '         uint Calcrewardairdrop =100000*_maxtotalSupply.div(((_totalSupply/9)*10)+TotalAirdropRequests);\n', '         uint _reward = Calcrewardairdrop*MultiRewardAD;\n', '         rewardAD = _reward;\n', '        _totalSupply = _totalSupply.add(rewardAD);\n', '        balances[msg.sender] = balances[msg.sender].add(rewardAD);\n', '        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\n', '        MineAD(msg.sender, rewardAD);\n', '        TotalAirdropRequests++;\n', '        ShowADV();\n', '        return true;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        modifier canPoS() {\n', '         uint _now = now;\n', '        require(_totalSupply < _maxtotalSupply);\n', '        require ((_now.sub(clockpos)).div(120 seconds) >= 1);\n', '         uint _nownetowk = now;\n', '        _;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '         function Proof_of_Stake() canPoS returns (bool) {\n', '         if(clockpos < clockowner){return false;}\n', '         if(PoS >= MaxPoSXblock){\n', '         clockpos = now; \n', '         PoS=0;\n', '         return true; }\n', '         PoS++;\n', '         if(balances[msg.sender] >= InitalPos){\n', '         uint ProofOfStake = balances[msg.sender].div(PoSPerCent);\n', '         _rewardPoS = ProofOfStake;                    // Proof-of-stake 0.005%\n', '         uint rewardPoS = _rewardPoS;\n', '        _totalSupply = _totalSupply.add(rewardPoS);\n', '        balances[msg.sender] = balances[msg.sender].add(rewardPoS);\n', '        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\n', '        MinePoS(msg.sender, rewardPoS);\n', '        TotalPoSRequests++;\n', '}else throw;\n', '        ShowADV();\n', '        return true;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '        function approve(address _spender, uint256 _amount) returns (bool success) {\n', '         allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '         return true;}\n', '//------------------------------------------------------------------------------------------------------------------// \n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '         return allowed[_owner][_spender];}}']