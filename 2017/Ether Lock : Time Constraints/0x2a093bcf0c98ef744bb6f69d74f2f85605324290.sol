['/*\n', '\tUtility functions for safe math operations.  See link below for more information:\n', '\thttps://ethereum.stackexchange.com/questions/15258/safemath-safe-add-function-assertions-against-overflows\n', '*/\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) pure internal returns (uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) pure internal returns (uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) pure internal returns (uint256) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owner {\n', '\t\n', '\t// Token Name\n', '\tstring public name = "FoodCoin";\n', '\t// Token Symbol\n', '\tstring public symbol = "FOOD";\n', '\t// Decimals\n', '\tuint256 public decimals = 8;\n', '\t// Version \n', '\tstring public version = "v1";\n', '\t\n', '\t// Emission Address\n', '\taddress public emissionAddress = address(0);\n', '\t// Withdraw address\n', '\taddress public withdrawAddress = address(0);\n', '\t\n', '\t// Owners Addresses\n', '\tmapping ( address => bool ) public ownerAddressMap;\n', '\t// Owner Address/Number\n', '\tmapping ( address => uint256 ) public ownerAddressNumberMap;\n', '\t// Owners List\n', '\tmapping ( uint256 => address ) public ownerListMap;\n', '\t// Amount of owners\n', '\tuint256 public ownerCountInt = 0;\n', '\n', '\t// Modifier - Owner\n', '\tmodifier isOwner {\n', '        require( ownerAddressMap[msg.sender]==true );\n', '        _;\n', '    }\n', '\t\n', '\t// Owner Creation/Activation\n', '\tfunction ownerOn( address _onOwnerAddress ) external isOwner returns (bool retrnVal) {\n', "\t\t// Check if it's a non-zero address\n", '\t\trequire( _onOwnerAddress != address(0) );\n', '\t\t// If the owner is already exist\n', '\t\tif ( ownerAddressNumberMap[ _onOwnerAddress ]>0 )\n', '\t\t{\n', '\t\t\t// If the owner is disablead, activate him again\n', '\t\t\tif ( !ownerAddressMap[ _onOwnerAddress ] )\n', '\t\t\t{\n', '\t\t\t\townerAddressMap[ _onOwnerAddress ] = true;\n', '\t\t\t\tretrnVal = true;\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tretrnVal = false;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// If the owner is not exist\n', '\t\telse\n', '\t\t{\n', '\t\t\townerAddressMap[ _onOwnerAddress ] = true;\n', '\t\t\townerAddressNumberMap[ _onOwnerAddress ] = ownerCountInt;\n', '\t\t\townerListMap[ ownerCountInt ] = _onOwnerAddress;\n', '\t\t\townerCountInt++;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Owner disabled\n', '\tfunction ownerOff( address _offOwnerAddress ) external isOwner returns (bool retrnVal) {\n', '\t\t// If owner exist and he is not 0 and active\n', '\t\t// 0 owner can`t be off\n', '\t\tif ( ownerAddressNumberMap[ _offOwnerAddress ]>0 && ownerAddressMap[ _offOwnerAddress ] )\n', '\t\t{\n', '\t\t\townerAddressMap[ _offOwnerAddress ] = false;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Token name changing function\n', '\tfunction contractNameUpdate( string _newName, bool updateConfirmation ) external isOwner returns (bool retrnVal) {\n', '\t\t\n', '\t\tif ( updateConfirmation )\n', '\t\t{\n', '\t\t\tname = _newName;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Token symbol changing function\n', '\tfunction contractSymbolUpdate( string _newSymbol, bool updateConfirmation ) external isOwner returns (bool retrnVal) {\n', '\n', '\t\tif ( updateConfirmation )\n', '\t\t{\n', '\t\t\tsymbol = _newSymbol;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Token decimals changing function\n', '\tfunction contractDecimalsUpdate( uint256 _newDecimals, bool updateConfirmation ) external isOwner returns (bool retrnVal) {\n', '\t\t\n', '\t\tif ( updateConfirmation && _newDecimals != decimals )\n', '\t\t{\n', '\t\t\tdecimals = _newDecimals;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// New token emission address setting up \n', '\tfunction emissionAddressUpdate( address _newEmissionAddress ) external isOwner {\n', '\t\temissionAddress = _newEmissionAddress;\n', '\t}\n', '\t\n', '\t// New token withdrawing address setting up\n', '\tfunction withdrawAddressUpdate( address _newWithdrawAddress ) external isOwner {\n', '\t\twithdrawAddress = _newWithdrawAddress;\n', '\t}\n', '\n', '\t// Constructor adds owner to undeletable list\n', '\tfunction Owner() public {\n', '\t\t// Owner creation\n', '\t\townerAddressMap[ msg.sender ] = true;\n', '\t\townerAddressNumberMap[ msg.sender ] = ownerCountInt;\n', '\t\townerListMap[ ownerCountInt ] = msg.sender;\n', '\t\townerCountInt++;\n', '\t}\n', '}\n', '\n', 'contract SpecialManager is Owner {\n', '\n', '\t// Special Managers Addresses\n', '\tmapping ( address => bool ) public specialManagerAddressMap;\n', '\t// Special Manager Address/Number Mapping\n', '\tmapping ( address => uint256 ) public specialManagerAddressNumberMap;\n', '\t// Special Managers List\n', '\tmapping ( uint256 => address ) public specialManagerListMap;\n', '\t// Special Manager Amount\n', '\tuint256 public specialManagerCountInt = 0;\n', '\t\n', '\t// Special Manager or Owner modifier\n', '\tmodifier isSpecialManagerOrOwner {\n', '        require( specialManagerAddressMap[msg.sender]==true || ownerAddressMap[msg.sender]==true );\n', '        _;\n', '    }\n', '\t\n', '\t// Special Manager creation/actination\n', '\tfunction specialManagerOn( address _onSpecialManagerAddress ) external isOwner returns (bool retrnVal) {\n', "\t\t// Check if it's a non-zero address\n", '\t\trequire( _onSpecialManagerAddress != address(0) );\n', '\t\t// If this special manager already exists\n', '\t\tif ( specialManagerAddressNumberMap[ _onSpecialManagerAddress ]>0 )\n', '\t\t{\n', '\t\t\t// If this special manager disabled, activate him again\n', '\t\t\tif ( !specialManagerAddressMap[ _onSpecialManagerAddress ] )\n', '\t\t\t{\n', '\t\t\t\tspecialManagerAddressMap[ _onSpecialManagerAddress ] = true;\n', '\t\t\t\tretrnVal = true;\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tretrnVal = false;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// If this special manager doesn`t exist\n', '\t\telse\n', '\t\t{\n', '\t\t\tspecialManagerAddressMap[ _onSpecialManagerAddress ] = true;\n', '\t\t\tspecialManagerAddressNumberMap[ _onSpecialManagerAddress ] = specialManagerCountInt;\n', '\t\t\tspecialManagerListMap[ specialManagerCountInt ] = _onSpecialManagerAddress;\n', '\t\t\tspecialManagerCountInt++;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Special manager disactivation\n', '\tfunction specialManagerOff( address _offSpecialManagerAddress ) external isOwner returns (bool retrnVal) {\n', '\t\t// If this special manager exists and he is non-zero and also active \n', '\t\t// 0-number manager can`t be disactivated\n', '\t\tif ( specialManagerAddressNumberMap[ _offSpecialManagerAddress ]>0 && specialManagerAddressMap[ _offSpecialManagerAddress ] )\n', '\t\t{\n', '\t\t\tspecialManagerAddressMap[ _offSpecialManagerAddress ] = false;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\n', '\n', '\t// Constructor adds owner to superowner list\n', '\tfunction SpecialManager() public {\n', '\t\t// owner creation\n', '\t\tspecialManagerAddressMap[ msg.sender ] = true;\n', '\t\tspecialManagerAddressNumberMap[ msg.sender ] = specialManagerCountInt;\n', '\t\tspecialManagerListMap[ specialManagerCountInt ] = msg.sender;\n', '\t\tspecialManagerCountInt++;\n', '\t}\n', '}\n', '\n', '\n', 'contract Manager is SpecialManager {\n', '\t\n', '\t// Managers addresses\n', '\tmapping ( address => bool ) public managerAddressMap;\n', '\t// Manager Address/Number Mapping\n', '\tmapping ( address => uint256 ) public managerAddressNumberMap;\n', '\t// Managers` List\n', '\tmapping ( uint256 => address ) public managerListMap;\n', '\t// Amount of managers\n', '\tuint256 public managerCountInt = 0;\n', '\t\n', '\t// Modifier - Manager Or Owner\n', '\tmodifier isManagerOrOwner {\n', '        require( managerAddressMap[msg.sender]==true || ownerAddressMap[msg.sender]==true );\n', '        _;\n', '    }\n', '\t\n', '\t// Owner Creation/Activation\n', '\tfunction managerOn( address _onManagerAddress ) external isOwner returns (bool retrnVal) {\n', "\t\t// Check if it's a non-zero address\n", '\t\trequire( _onManagerAddress != address(0) );\n', '\t\t// If this special manager exists\n', '\t\tif ( managerAddressNumberMap[ _onManagerAddress ]>0 )\n', '\t\t{\n', '\t\t\t// If this special manager disabled, activate him again\n', '\t\t\tif ( !managerAddressMap[ _onManagerAddress ] )\n', '\t\t\t{\n', '\t\t\t\tmanagerAddressMap[ _onManagerAddress ] = true;\n', '\t\t\t\tretrnVal = true;\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tretrnVal = false;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// If this special manager doesn`t exist\n', '\t\telse\n', '\t\t{\n', '\t\t\tmanagerAddressMap[ _onManagerAddress ] = true;\n', '\t\t\tmanagerAddressNumberMap[ _onManagerAddress ] = managerCountInt;\n', '\t\t\tmanagerListMap[ managerCountInt ] = _onManagerAddress;\n', '\t\t\tmanagerCountInt++;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Manager disactivation\n', '\tfunction managerOff( address _offManagerAddress ) external isOwner returns (bool retrnVal) {\n', "\t\t// if it's a non-zero manager and already exists and active\n", '\t\t// 0-number manager can`t be disactivated\n', '\t\tif ( managerAddressNumberMap[ _offManagerAddress ]>0 && managerAddressMap[ _offManagerAddress ] )\n', '\t\t{\n', '\t\t\tmanagerAddressMap[ _offManagerAddress ] = false;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\n', '\n', '\t// Constructor adds owner to manager list \n', '\tfunction Manager() public {\n', '\t\t// manager creation\n', '\t\tmanagerAddressMap[ msg.sender ] = true;\n', '\t\tmanagerAddressNumberMap[ msg.sender ] = managerCountInt;\n', '\t\tmanagerListMap[ managerCountInt ] = msg.sender;\n', '\t\tmanagerCountInt++;\n', '\t}\n', '}\n', '\n', '\n', 'contract Management is Manager {\n', '\t\n', '\t// Description\n', '\tstring public description = "";\n', '\t\n', '\t// Current tansaction status \n', '\t// TRUE - tansaction available\n', '\t// FALSE - tansaction not available\n', '\tbool public transactionsOn = false;\n', '\t// Special permissions to allow/prohibit transactions to move tokens for specific accounts\n', '\t// 0 - depends on transactionsOn\n', '\t// 1 - always "forbidden"\n', '\t// 2 - always "allowed"\n', '\tmapping ( address => uint256 ) public transactionsOnForHolder;\n', '\t\n', '\t\n', '\t// Displaying tokens in the balanceOf function for all tokens\n', '\t// TRUE - Displaying available\n', '\t// FALSE - Displaying hidden, shows 0. Checking the token balance available in function balanceOfReal\n', '\tbool public balanceOfOn = true;\n', '\t// Displaying the token balance in function balanceOfReal for definit holder\n', '\t// 0 - depends on transactionsOn\n', '\t// 1 - always "forbidden"\n', '\t// 2 - always "allowed"\n', '\tmapping ( address => uint256 ) public balanceOfOnForHolder;\n', '\t\n', '\t\n', '\t// Current emission status\n', '\t// TRUE - emission is available, managers may add tokens to contract\n', '\t// FALSE - emission isn`t available, managers may not add tokens to contract\n', '\tbool public emissionOn = true;\n', '\n', '\t// emission cap\n', '\tuint256 public tokenCreationCap = 0;\n', '\t\n', '\t// Addresses list for verification of acoounts owners\n', '\t// Addresses\n', '\tmapping ( address => bool ) public verificationAddressMap;\n', '\t// Verification Address/Number Mapping\n', '\tmapping ( address => uint256 ) public verificationAddressNumberMap;\n', '\t// Verification List Mapping\n', '\tmapping ( uint256 => address ) public verificationListMap;\n', '\t// Amount of verifications\n', '\tuint256 public verificationCountInt = 1;\n', '\t\n', '\t// Verification holding\n', '\t// Verification Holders Timestamp\n', '\tmapping (address => uint256) public verificationHoldersTimestampMap;\n', '\t// Verification Holders Value\n', '\tmapping (address => uint256) public verificationHoldersValueMap;\n', '\t// Verification Holders Verifier Address\n', '\tmapping (address => address) public verificationHoldersVerifierAddressMap;\n', '\t// Verification Address Holders List Count\n', '\tmapping (address => uint256) public verificationAddressHoldersListCountMap;\n', '\t// Verification Address Holders List Number\n', '\tmapping (address => mapping ( uint256 => address )) public verificationAddressHoldersListNumberMap;\n', '\t\n', '\t// Modifier - Transactions On\n', '\tmodifier isTransactionsOn( address addressFrom ) {\n', '\t\t\n', '\t\trequire( transactionsOnNowVal( addressFrom ) );\n', '\t\t_;\n', '    }\n', '\t\n', '\t// Modifier - Emission On\n', '\tmodifier isEmissionOn{\n', '        require( emissionOn );\n', '        _;\n', '    }\n', '\t\n', '\t// Function transactions On now validate for definit address \n', '\tfunction transactionsOnNowVal( address addressFrom ) public view returns( bool )\n', '\t{\n', '\t\treturn ( transactionsOnForHolder[ addressFrom ]==0 && transactionsOn ) || transactionsOnForHolder[ addressFrom ]==2 ;\n', '\t}\n', '\t\n', '\t// transaction allow/forbidden for definit token holder\n', '\tfunction transactionsOnForHolderUpdate( address _to, uint256 _newValue ) external isOwner\n', '\t{\n', '\t\tif ( transactionsOnForHolder[ _to ] != _newValue )\n', '\t\t{\n', '\t\t\ttransactionsOnForHolder[ _to ] = _newValue;\n', '\t\t}\n', '\t}\n', '\n', '\t// Function of changing allow/forbidden transfer status\n', '\tfunction transactionsStatusUpdate( bool _on ) external isOwner\n', '\t{\n', '\t\ttransactionsOn = _on;\n', '\t}\n', '\t\n', '\t// Function of changing emission status\n', '\tfunction emissionStatusUpdate( bool _on ) external isOwner\n', '\t{\n', '\t\temissionOn = _on;\n', '\t}\n', '\t\n', '\t// Emission cap setting up\n', '\tfunction tokenCreationCapUpdate( uint256 _newVal ) external isOwner\n', '\t{\n', '\t\ttokenCreationCap = _newVal;\n', '\t}\n', '\t\n', '\t// balanceOfOnForHolder; balanceOfOn\n', '\t\n', '\t// Function on/off token displaying in function balanceOf\n', '\tfunction balanceOfOnUpdate( bool _on ) external isOwner\n', '\t{\n', '\t\tbalanceOfOn = _on;\n', '\t}\n', '\t\n', '\t// Function on/off token displaying in function balanceOf for definit token holder\n', '\tfunction balanceOfOnForHolderUpdate( address _to, uint256 _newValue ) external isOwner\n', '\t{\n', '\t\tif ( balanceOfOnForHolder[ _to ] != _newValue )\n', '\t\t{\n', '\t\t\tbalanceOfOnForHolder[ _to ] = _newValue;\n', '\t\t}\n', '\t}\n', '\t\n', '\t\n', '\t// Function adding of new verification address\n', '\tfunction verificationAddressOn( address _onVerificationAddress ) external isOwner returns (bool retrnVal) {\n', "\t\t// Check if it's a non-zero address\n", '\t\trequire( _onVerificationAddress != address(0) );\n', '\t\t// If this address is already exists\n', '\t\tif ( verificationAddressNumberMap[ _onVerificationAddress ]>0 )\n', '\t\t{\n', '\t\t\t// If address off, activate it again\n', '\t\t\tif ( !verificationAddressMap[ _onVerificationAddress ] )\n', '\t\t\t{\n', '\t\t\t\tverificationAddressMap[ _onVerificationAddress ] = true;\n', '\t\t\t\tretrnVal = true;\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tretrnVal = false;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// If this address doesn`t exist\n', '\t\telse\n', '\t\t{\n', '\t\t\tverificationAddressMap[ _onVerificationAddress ] = true;\n', '\t\t\tverificationAddressNumberMap[ _onVerificationAddress ] = verificationCountInt;\n', '\t\t\tverificationListMap[ verificationCountInt ] = _onVerificationAddress;\n', '\t\t\tverificationCountInt++;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Function of disactivation of verification address\n', '\tfunction verificationOff( address _offVerificationAddress ) external isOwner returns (bool retrnVal) {\n', '\t\t// If this verification address exists and disabled\n', '\t\tif ( verificationAddressNumberMap[ _offVerificationAddress ]>0 && verificationAddressMap[ _offVerificationAddress ] )\n', '\t\t{\n', '\t\t\tverificationAddressMap[ _offVerificationAddress ] = false;\n', '\t\t\tretrnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tretrnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Event "Description updated"\n', '\tevent DescriptionPublished( string _description, address _initiator);\n', '\t\n', '\t// Description update\n', '\tfunction descriptionUpdate( string _newVal ) external isOwner\n', '\t{\n', '\t\tdescription = _newVal;\n', '\t\tDescriptionPublished( _newVal, msg.sender );\n', '\t}\n', '}\n', '\n', '// Token contract FoodCoin Ecosystem\n', 'contract FoodcoinEcosystem is SafeMath, Management {\n', '\t\n', '\t// Token total supply\n', '\tuint256 public totalSupply = 0;\n', '\t\n', '\t// Balance\n', '\tmapping ( address => uint256 ) balances;\n', '\t// Balances List Address\n', '\tmapping ( uint256 => address ) public balancesListAddressMap;\n', '\t// Balances List/Number Mapping\n', '\tmapping ( address => uint256 ) public balancesListNumberMap;\n', '\t// Balances Address Description\n', '\tmapping ( address => string ) public balancesAddressDescription;\n', '\t// Total amount of all balances\n', '\tuint256 balancesCountInt = 1;\n', '\t\n', '\t// Forwarding of address managing for definit amount of tokens\n', '\tmapping ( address => mapping ( address => uint256 ) ) allowed;\n', '\t\n', '\t\n', '\t// Standard ERC-20 events\n', '\t// Event - token transfer\n', '\tevent Transfer( address indexed from, address indexed to, uint value );\n', '\t// Event - Forwarding of address managing\n', '    event Approval( address indexed owner, address indexed spender, uint value );\n', '\t\n', '\t// Token transfer\n', '\tevent FoodTransferEvent( address from, address to, uint256 value, address initiator, uint256 newBalanceFrom, uint256 newBalanceTo );\n', '\t// Event - Emission\n', '\tevent FoodTokenEmissionEvent( address initiator, address to, uint256 value, bool result, uint256 newBalanceTo );\n', '\t// Event - Withdraw\n', '\tevent FoodWithdrawEvent( address initiator, address to, bool withdrawOk, uint256 withdraw, uint256 withdrawReal, uint256 newBalancesValue );\n', '\t\n', '\t\n', '\t// Balance View\n', '\tfunction balanceOf( address _owner ) external view returns ( uint256 )\n', '\t{\n', '\t\t// If allows to display balance for all or definit holder\n', '\t\tif ( ( balanceOfOnForHolder[ _owner ]==0 && balanceOfOn ) || balanceOfOnForHolder[ _owner ]==2 )\n', '\t\t{\n', '\t\t\treturn balances[ _owner ];\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\t// Real Balance View\n', '\tfunction balanceOfReal( address _owner ) external view returns ( uint256 )\n', '\t{\n', '\t\treturn balances[ _owner ];\n', '\t}\n', '\t// Check if a given user has been delegated rights to perform transfers on behalf of the account owner\n', '\tfunction allowance( address _owner, address _initiator ) external view returns ( uint256 remaining )\n', '\t{\n', '\t\treturn allowed[ _owner ][ _initiator ];\n', '\t}\n', '\t// Total balances quantity\n', '\tfunction balancesQuantity() external view returns ( uint256 )\n', '\t{\n', '\t\treturn balancesCountInt - 1;\n', '\t}\n', '\t\n', '\t// Function of token transaction. For the first transaction will be created the detailed information\n', '\tfunction _addClientAddress( address _balancesAddress, uint256 _amount ) internal\n', '\t{\n', '\t\t// check if this address is not on the list yet\n', '\t\tif ( balancesListNumberMap[ _balancesAddress ] == 0 )\n', '\t\t{\n', '\t\t\t// add it to the list\n', '\t\t\tbalancesListAddressMap[ balancesCountInt ] = _balancesAddress;\n', '\t\t\tbalancesListNumberMap[ _balancesAddress ] = balancesCountInt;\n', '\t\t\t// increment account counter\n', '\t\t\tbalancesCountInt++;\n', '\t\t}\n', '\t\t// add tokens to the account \n', '\t\tbalances[ _balancesAddress ] = safeAdd( balances[ _balancesAddress ], _amount );\n', '\t}\n', '\t// Internal function that performs the actual transfer (cannot be called externally)\n', '\tfunction _transfer( address _from, address _to, uint256 _value ) internal isTransactionsOn( _from ) returns ( bool success )\n', '\t{\n', '\t\t// If the amount to transfer is greater than 0, and sender has funds available\n', '\t\tif ( _value > 0 && balances[ _from ] >= _value )\n', '\t\t{\n', '\t\t\t// Subtract from sender account\n', '\t\t\tbalances[ _from ] -= _value;\n', "\t\t\t// Add to receiver's account\n", '\t\t\t_addClientAddress( _to, _value );\n', '\t\t\t// Perform the transfer\n', '\t\t\tTransfer( _from, _to, _value );\n', '\t\t\tFoodTransferEvent( _from, _to, _value, msg.sender, balances[ _from ], balances[ _to ] );\n', '\t\t\t// Successfully completed transfer\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\t// Return false if there are problems\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\t// Function token transfer\n', '\tfunction transfer(address _to, uint256 _value) external returns ( bool success )\n', '\t{\n', '\t\t// If it is transfer to verification address\n', '\t\tif ( verificationAddressNumberMap[ _to ]>0 )\n', '\t\t{\n', '\t\t\t_verification(msg.sender, _to, _value);\n', '\t\t}\n', '\t\t// Regular transfer\n', '\t\telse\n', '\t\t{\n', '\t\t\t// Call function transfer. \n', '\t\t\treturn _transfer( msg.sender, _to, _value );\n', '\t\t}\n', '\t}\n', '\t// Function of transferring tokens from a delegated account\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) external isTransactionsOn( _from ) returns ( bool success )\n', '\t{\n', '\t\t// Regular transfer. Not to verification address\n', '\t\trequire( verificationAddressNumberMap[ _to ]==0 );\n', "\t\t// Check if the transfer initiator has permissions to move funds from the sender's account\n", '\t\tif ( allowed[_from][msg.sender] >= _value )\n', '\t\t{\n', '\t\t\t// If yes - perform transfer \n', '\t\t\tif ( _transfer( _from, _to, _value ) )\n', '\t\t\t{\n', '\t\t\t\t// Decrease the total amount that initiator has permissions to access\n', '\t\t\t\tallowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender], _value);\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\treturn false;\n', '\t\t\t}\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\t// Function of delegating account management for a certain amount\n', '\tfunction approve( address _initiator, uint256 _value ) external isTransactionsOn( msg.sender ) returns ( bool success )\n', '\t{\n', '\t\t// Grant the rights for a certain amount of tokens only\n', '\t\tallowed[ msg.sender ][ _initiator ] = _value;\n', '\t\t// Initiate the Approval event\n', '\t\tApproval( msg.sender, _initiator, _value );\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t// The emission function (the manager or contract owner creates tokens and sends them to a specific account)\n', '\tfunction _emission (address _reciever, uint256 _amount) internal isManagerOrOwner isEmissionOn returns ( bool returnVal )\n', '\t{\n', '\t\t// if non-zero address\n', '\t\tif ( _reciever != address(0) )\n', '\t\t{\n', '\t\t\t// Calculate number of tokens after generation\n', '\t\t\tuint256 checkedSupply = safeAdd( totalSupply, _amount );\n', '\t\t\t// Emission amount\n', '\t\t\tuint256 amountTmp = _amount;\n', '\t\t\t// If emission cap settled additional emission is impossible\n', '\t\t\tif ( tokenCreationCap > 0 && tokenCreationCap < checkedSupply )\n', '\t\t\t{\n', '\t\t\t\tamountTmp = 0;\n', '\t\t\t}\n', '\t\t\t// if try to add more than 0 tokens\n', '\t\t\tif ( amountTmp > 0 )\n', '\t\t\t{\n', '\t\t\t\t// If no error, add generated tokens to a given address\n', '\t\t\t\t_addClientAddress( _reciever, amountTmp );\n', '\t\t\t\t// increase total supply of tokens\n', '\t\t\t\ttotalSupply = checkedSupply;\n', '\t\t\t\t// event "token transfer"\n', '\t\t\t\tTransfer( emissionAddress, _reciever, amountTmp );\n', '\t\t\t\t// event "emission successfull"\n', '\t\t\t\tFoodTokenEmissionEvent( msg.sender, _reciever, _amount, true, balances[ _reciever ] );\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\treturnVal = false;\n', '\t\t\t\t// event "emission failed"\n', '\t\t\t\tFoodTokenEmissionEvent( msg.sender, _reciever, _amount, false, balances[ _reciever ] );\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t// emission to definit 1 address\n', '\tfunction tokenEmission(address _reciever, uint256 _amount) external isManagerOrOwner isEmissionOn returns ( bool returnVal )\n', '\t{\n', "\t\t// Check if it's a non-zero address\n", '\t\trequire( _reciever != address(0) );\n', '\t\t// emission in process\n', '\t\treturnVal = _emission( _reciever, _amount );\n', '\t}\n', '\t// adding 5 addresses at once\n', '\tfunction tokenEmission5( address _reciever_0, uint256 _amount_0, address _reciever_1, uint256 _amount_1, address _reciever_2, uint256 _amount_2, address _reciever_3, uint256 _amount_3, address _reciever_4, uint256 _amount_4 ) external isManagerOrOwner isEmissionOn\n', '\t{\n', '\t\t_emission( _reciever_0, _amount_0 );\n', '\t\t_emission( _reciever_1, _amount_1 );\n', '\t\t_emission( _reciever_2, _amount_2 );\n', '\t\t_emission( _reciever_3, _amount_3 );\n', '\t\t_emission( _reciever_4, _amount_4 );\n', '\t}\n', '\t\n', '\t// Function Tokens withdraw\n', '\tfunction withdraw( address _to, uint256 _amount ) external isSpecialManagerOrOwner returns ( bool returnVal, uint256 withdrawValue, uint256 newBalancesValue )\n', '\t{\n', '\t\t// check if this is a valid account\n', '\t\tif ( balances[ _to ] > 0 )\n', '\t\t{\n', '\t\t\t// Withdraw amount\n', '\t\t\tuint256 amountTmp = _amount;\n', '\t\t\t// It is impossible to withdraw more than available on balance\n', '\t\t\tif ( balances[ _to ] < _amount )\n', '\t\t\t{\n', '\t\t\t\tamountTmp = balances[ _to ];\n', '\t\t\t}\n', '\t\t\t// Withdraw in process\n', '\t\t\tbalances[ _to ] = safeSubtract( balances[ _to ], amountTmp );\n', '\t\t\t// Changing of current tokens amount\n', '\t\t\ttotalSupply = safeSubtract( totalSupply, amountTmp );\n', '\t\t\t// Return reply\n', '\t\t\treturnVal = true;\n', '\t\t\twithdrawValue = amountTmp;\n', '\t\t\tnewBalancesValue = balances[ _to ];\n', '\t\t\tFoodWithdrawEvent( msg.sender, _to, true, _amount, amountTmp, balances[ _to ] );\n', '\t\t\t// Event "Token transfer"\n', '\t\t\tTransfer( _to, withdrawAddress, amountTmp );\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturnVal = false;\n', '\t\t\twithdrawValue = 0;\n', '\t\t\tnewBalancesValue = 0;\n', '\t\t\tFoodWithdrawEvent( msg.sender, _to, false, _amount, 0, balances[ _to ] );\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Balance description update\n', '\tfunction balancesAddressDescriptionUpdate( string _newDescription ) external returns ( bool returnVal )\n', '\t{\n', '\t\t// If this address or contrat`s owher exists\n', '\t\tif ( balancesListNumberMap[ msg.sender ] > 0 || ownerAddressMap[msg.sender]==true )\n', '\t\t{\n', '\t\t\tbalancesAddressDescription[ msg.sender ] = _newDescription;\n', '\t\t\treturnVal = true;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturnVal = false;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Recording of verification details\n', '\tfunction _verification( address _from, address _verificationAddress, uint256 _value) internal\n', '\t{\n', '\t\t// If verification address is active\n', '\t\trequire( verificationAddressMap[ _verificationAddress ] );\n', '\t\t\n', '\t\t// If it is updating of already verificated address\n', '\t\tif ( verificationHoldersVerifierAddressMap[ _from ] == _verificationAddress )\n', '\t\t{\n', '\t\t\t// Verification Address Holders List Count\n', '\t\t\tuint256 tmpNumberVerification = verificationAddressHoldersListCountMap[ _verificationAddress ];\n', '\t\t\tverificationAddressHoldersListCountMap[ _verificationAddress ]++;\n', '\t\t\t// Verification Address Holders List Number\n', '\t\t\tverificationAddressHoldersListNumberMap[ _verificationAddress ][ tmpNumberVerification ] = _from;\n', '\t\t}\n', '\t\t\n', '\t\t// Verification Holders Timestamp \n', '\t\tverificationHoldersTimestampMap[ _from ] = now;\n', '\t\t// Verification Value\n', '\t\tverificationHoldersValueMap[ _from ] = _value;\n', '\t\t// Verification Holders Verifier Address\n', '\t\tverificationHoldersVerifierAddressMap[ _from ] = _verificationAddress;\n', '\t}\n', '}']