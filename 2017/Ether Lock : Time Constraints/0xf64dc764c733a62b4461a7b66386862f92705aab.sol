['pragma solidity ^0.4.16;\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '}\n', 'pragma solidity ^0.4.16;\n', '\n', '\n', '//////////////////////////////////////////////////\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != owner && newOwner != address(0x0));\n', '        address oldOwner = owner;\n', '        owner = newOwner;\n', '        OwnerChanged(oldOwner, newOwner);\n', '    }\n', '}\n', '\n', '\n', 'contract CrowdSale is Ownable {\n', '\n', '    // ERC20 Token\n', '    ERC20 public token;\n', '\n', '    // address where receives funds\n', '    address public beneficiary;\n', '    // address where provides tokens\n', '    address public tokenHolder;\n', '\n', '    // how many token units per wei\n', '    uint public rate;\n', '\n', '    // amount of goal in wei\n', '    uint public amountGoal;\n', '\n', '    // amount of current raised money in wei\n', '    uint public amountRaised;\n', '\n', '    // amount of tokens issued\n', '    uint public amountTokenIssued;\n', '\n', '    // Important Time\n', '    uint public startTime;\n', '    uint public endTime;\n', '\n', '    // Stages Info\n', '    struct Stage {\n', '        uint duration;      // Duration in second of current stage\n', '        uint rate;          // 100 = 100%\n', '    }\n', '    Stage[] public icoStages;\n', '    Stage[] public lockStages;\n', '\n', '\n', '    // Purchaser Info\n', '    struct PurchaserInfo {\n', '        uint amountEtherSpent;\n', '        uint amountTokenTaken;\n', '        uint[] lockedToken;\n', '    }\n', '    mapping(address => PurchaserInfo) public purchasers;\n', '\n', '    address[] public purchaserList;\n', '\n', '\n', '    // ----- Events -----\n', '    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);\n', '    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);\n', '    event FundingWithdrawn(address beneficiaryAddress, uint value);\n', '    event UnlockToken(address purchaser, uint amountUnlockedTokens);\n', '\n', '\n', '    // ----- Modifiers -----\n', '    modifier afterEnded {\n', '        require(isEnded());\n', '        _;\n', '    }\n', '\n', '    modifier onlyOpenTime {\n', '        require(isStarted());\n', '        require(!isEnded());\n', '        _;\n', '    }\n', '\n', '\n', '    // ----- Functions -----\n', '    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {\n', '        require(beneficiaryAddr != address(0));\n', '        require(tokenHolderAddr != address(0));\n', '        require(tokenAddr != address(0));\n', '        require(tokenRate > 0);\n', '\n', '        beneficiary = beneficiaryAddr;\n', '        tokenHolder = tokenHolderAddr;\n', '        token = ERC20(tokenAddr);\n', '        rate = tokenRate;\n', '\n', '        _initStages();\n', '    }\n', '\n', '    function _initStages() internal;   //Need override\n', '\n', '    function getTokenAddress() public view returns(address) {\n', '        return token;\n', '    }\n', '\n', '    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {\n', '        if(stageIdx >= purchasers[_purchaser].lockedToken.length) {\n', '            return 0;\n', '        }\n', '        return purchasers[_purchaser].lockedToken[stageIdx];\n', '    }\n', '\n', '    function canTokenUnlocked(uint stageIndex) public view returns(bool) {\n', '        if(0 <= stageIndex && stageIndex < lockStages.length){\n', '            uint stageEndTime = endTime;\n', '            for(uint i = 0; i <= stageIndex; i++) {\n', '                stageEndTime += lockStages[i].duration;\n', '            }//for\n', '            return now > stageEndTime;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isStarted() public view returns(bool) {\n', '        return 0 < startTime && startTime <= now;\n', '    }\n', '\n', '    function isReachedGoal() public view returns(bool) {\n', '        return amountRaised >= amountGoal;\n', '    }\n', '\n', '    function isEnded() public view returns(bool) {\n', '        return now > endTime || isReachedGoal();\n', '    }\n', '\n', '    function getCurrentStage() public view returns(int) {\n', '        int stageIdx = -1;\n', '        uint stageEndTime = startTime;\n', '        for(uint i = 0; i < icoStages.length; i++) {\n', '            stageEndTime += icoStages[i].duration;\n', '            if (now <= stageEndTime) {\n', '                stageIdx = int(i);\n', '                break;\n', '            }\n', '        }\n', '        return stageIdx;\n', '    }\n', '\n', '    function getRemainingTimeInSecond() public view returns(uint) {\n', '        if(endTime == 0)\n', '            return 0;\n', '        return endTime - now;\n', '    }\n', '\n', '    function _addPurchaser(address purchaser) internal {\n', '        require(purchaser != address(0));\n', '\n', '//        for (uint i = 0; i < purchaserList.length; i++) {\n', '//            if (purchaser == purchaserList[i]){\n', '//                return;\n', '//            }\n', '//        }\n', '        purchaserList.push(purchaser);\n', '    }\n', '\n', '    function start(uint fundingGoalInEther) public onlyOwner {\n', '        require(!isStarted());\n', '        require(fundingGoalInEther > 0);\n', '        amountGoal = fundingGoalInEther * 1 ether;\n', '\n', '        startTime = now;\n', '\n', '        uint duration = 0;\n', '        for(uint i = 0; i < icoStages.length; i++){\n', '            duration += icoStages[i].duration;\n', '        }\n', '\n', '        endTime = startTime + duration;\n', '    }\n', '\n', '    function stop() public onlyOwner {\n', '        require(isStarted());\n', '        endTime = now;\n', '    }\n', '\n', '    function () payable public onlyOpenTime {\n', '        require(msg.value > 0);\n', '\n', '        uint amount = msg.value;\n', '        var (buyTokenCount, bonusTokenCount) = _getTokenCount(amount);\n', '\n', '        PurchaserInfo storage pi = purchasers[msg.sender];\n', '        pi.amountEtherSpent += amount;\n', '        pi.amountTokenTaken += buyTokenCount;\n', '\n', '        if (pi.lockedToken.length == 0) {\n', '            pi.lockedToken = new uint[](lockStages.length);\n', '        }\n', '\n', '        for(uint i = 0; i < lockStages.length; i++) {\n', '            Stage storage stage = lockStages[i];\n', '            pi.lockedToken[i] += stage.rate * bonusTokenCount / 100;\n', '        }\n', '\n', '\n', '        amountRaised += amount;\n', '        amountTokenIssued += buyTokenCount;\n', '\n', '        token.transferFrom(tokenHolder, msg.sender, buyTokenCount);\n', '        TokenPurchase(msg.sender, amount, buyTokenCount, bonusTokenCount);\n', '\n', '        _addPurchaser(msg.sender);\n', '\n', '        if(isReachedGoal()){\n', '            endTime = now;\n', '        }\n', '    }\n', '\n', '    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {\n', '        buyTokenCount = amountInWei * rate;\n', '\n', '        int stageIdx = getCurrentStage();\n', '        assert(stageIdx >= 0 && uint(stageIdx) < icoStages.length);\n', '        bonusTokenCount = buyTokenCount * icoStages[uint(stageIdx)].rate / 100;\n', '    }\n', '\n', '\n', '    function safeWithdrawal() public onlyOwner {\n', '        require(beneficiary != address(0));\n', '        beneficiary.transfer(amountRaised);\n', '        FundingWithdrawn(beneficiary, amountRaised);\n', '    }\n', '\n', '    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {\n', '        require(0 <= purchaserStartIdx && purchaserStartIdx < purchaserEndIdx && purchaserEndIdx <= purchaserList.length);\n', '        require(canTokenUnlocked(stageIndex));\n', '\n', '        for (uint j = purchaserStartIdx; j < purchaserEndIdx; j++) {\n', '            address purchaser = purchaserList[j];\n', '            if(purchaser != address(0)){\n', '                PurchaserInfo storage pi = purchasers[purchaser];\n', '                uint unlockedToken = pi.lockedToken[stageIndex];\n', '                if (unlockedToken > 0) {\n', '                    pi.lockedToken[stageIndex] = 0;\n', '                    pi.amountTokenTaken += unlockedToken;\n', '\n', '                    amountTokenIssued += unlockedToken;\n', '\n', '                    token.transferFrom(tokenHolder, purchaser, unlockedToken);\n', '                    UnlockToken(purchaser, unlockedToken);\n', '                }\n', '            }\n', '        }//for\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract FairGameCrowdSale is CrowdSale {\n', '    function FairGameCrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr)\n', '        CrowdSale(beneficiaryAddr, tokenHolderAddr, tokenAddr, 10000) public {\n', '\n', '    }\n', '\n', '    function _initStages() internal {\n', '        delete icoStages;\n', '\n', '        icoStages.push(Stage({rate: 20, duration: 1 days}));\n', '        icoStages.push(Stage({rate: 10, duration: 1 days}));\n', '        icoStages.push(Stage({rate: 0,  duration: 1 days}));\n', '\n', '\n', '        delete lockStages;\n', '\n', '        lockStages.push(Stage({rate: 33, duration: 30 days}));\n', '        lockStages.push(Stage({rate: 33, duration: 30 days}));\n', '        lockStages.push(Stage({rate: 34, duration: 30 days}));\n', '    }\n', '}']