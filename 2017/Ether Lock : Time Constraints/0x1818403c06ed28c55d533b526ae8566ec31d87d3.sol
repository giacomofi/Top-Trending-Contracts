['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title Ownable contract - base contract with an owner\n', ' */\n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    assert(_newOwner != address(0));      \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Accept transferOwnership.\n', '   */\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '\n', '  function sub(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x - y;\n', '    assert(z <= x);\n', '\t  return z;\n', '  }\n', '\n', '  function add(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x + y;\n', '\t  assert(z >= x);\n', '\t  return z;\n', '  }\n', '\t\n', '  function div(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x / y;\n', '    return z;\n', '  }\n', '\t\n', '  function mul(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x * y;\n', '    assert(x == 0 || z / x == y);\n', '    return z;\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x <= y ? x : y;\n', '    return z;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal constant returns (uint256) {\n', '    uint256 z = x >= y ? x : y;\n', '    return z;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '\tfunction totalSupply() public constant returns (uint);\n', '\tfunction balanceOf(address owner) public constant returns (uint);\n', '\tfunction allowance(address owner, address spender) public constant returns (uint);\n', '\tfunction transfer(address to, uint value) public returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint value) public returns (bool success);\n', '\tfunction approve(address spender, uint value) public returns (bool success);\n', '\tfunction mint(address to, uint value) public returns (bool success);\n', '\tevent Transfer(address indexed from, address indexed to, uint value);\n', '\tevent Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath, Ownable{\n', '\t\n', '  uint256 _totalSupply;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) approvals;\n', '  address public crowdsaleAgent;\n', '  bool public released = false;  \n', '  \n', '  /**\n', '   * @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   * @param numwords payload size  \n', '   */\n', '  modifier onlyPayloadSize(uint numwords) {\n', '    assert(msg.data.length == numwords * 32 + 4);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev The function can be called only by crowdsale agent.\n', '   */\n', '  modifier onlyCrowdsaleAgent() {\n', '    assert(msg.sender == crowdsaleAgent);\n', '    _;\n', '  }\n', '\n', '  /** Limit token mint after finishing crowdsale\n', '   * @dev Make sure we are not done yet.\n', '   */\n', '  modifier canMint() {\n', '    assert(!released);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Limit token transfer until the crowdsale is over.\n', '   */\n', '  modifier canTransfer() {\n', '    assert(released);\n', '    _;\n', '  } \n', '  \n', '  /** \n', '   * @dev Total Supply\n', '   * @return _totalSupply \n', '   */  \n', '  function totalSupply() public constant returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '  \n', '  /** \n', '   * @dev Tokens balance\n', '   * @param _owner holder address\n', '   * @return balance amount \n', '   */\n', '  function balanceOf(address _owner) public constant returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '  \n', '  /** \n', '   * @dev Token allowance\n', '   * @param _owner holder address\n', '   * @param _spender spender address\n', '   * @return remain amount\n', '   */   \n', '  function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '    return approvals[_owner][_spender];\n', '  }\n', '\n', '  /** \n', '   * @dev Tranfer tokens to address\n', '   * @param _to dest address\n', '   * @param _value tokens amount\n', '   * @return transfer result\n', '   */   \n', '  function transfer(address _to, uint _value) public canTransfer onlyPayloadSize(2) returns (bool success) {\n', '    assert(balances[msg.sender] >= _value);\n', '    balances[msg.sender] = sub(balances[msg.sender], _value);\n', '    balances[_to] = add(balances[_to], _value);\n', '    \n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  /**    \n', '   * @dev Tranfer tokens from one address to other\n', '   * @param _from source address\n', '   * @param _to dest address\n', '   * @param _value tokens amount\n', '   * @return transfer result\n', '   */    \n', '  function transferFrom(address _from, address _to, uint _value) public canTransfer onlyPayloadSize(3) returns (bool success) {\n', '    assert(balances[_from] >= _value);\n', '    assert(approvals[_from][msg.sender] >= _value);\n', '    approvals[_from][msg.sender] = sub(approvals[_from][msg.sender], _value);\n', '    balances[_from] = sub(balances[_from], _value);\n', '    balances[_to] = add(balances[_to], _value);\n', '    \n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  /** \n', '   * @dev Approve transfer\n', '   * @param _spender holder address\n', '   * @param _value tokens amount\n', '   * @return result  \n', '   */\n', '  function approve(address _spender, uint _value) public onlyPayloadSize(2) returns (bool success) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  approvals to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    assert((_value == 0) || (approvals[msg.sender][_spender] == 0));\n', '    approvals[msg.sender][_spender] = _value;\n', '    \n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  \n', '  /** \n', '   * @dev Create new tokens and allocate them to an address. Only callably by a crowdsale contract\n', '   * @param _to dest address\n', '   * @param _value tokens amount\n', '   * @return mint result\n', '   */ \n', '  function mint(address _to, uint _value) public onlyCrowdsaleAgent canMint onlyPayloadSize(2) returns (bool success) {\n', '    _totalSupply = add(_totalSupply, _value);\n', '    balances[_to] = add(balances[_to], _value);\n', '    \n', '    Transfer(0, _to, _value);\n', '    return true;\n', '\t\n', '  }\n', '  \n', '  /**\n', '   * @dev Set the contract that can call release and make the token transferable.\n', '   * @param _crowdsaleAgent crowdsale contract address\n', '   */\n', '  function setCrowdsaleAgent(address _crowdsaleAgent) public onlyOwner {\n', '    assert(!released);\n', '    crowdsaleAgent = _crowdsaleAgent;\n', '  }\n', '  \n', '  /**\n', '   * @dev One way function to release the tokens to the wild. Can be called only from the release agent that is the final ICO contract. \n', '   */\n', '  function releaseTokenTransfer() public onlyCrowdsaleAgent {\n', '    released = true;\n', '  }\n', '\n', '}\n', '\n', '/** \n', ' * @title DAOPlayMarket2.0 contract - standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' */\n', 'contract DAOPlayMarketToken is StandardToken {\n', '  \n', '  string public name;\n', '  string public symbol;\n', '  uint public decimals;\n', '  \n', '  /** Name and symbol were updated. */\n', '  event UpdatedTokenInformation(string newName, string newSymbol);\n', '\n', '  /**\n', '   * Construct the token.\n', '   *\n', '   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n', '   *\n', '   * @param _name Token name\n', '   * @param _symbol Token symbol - should be all caps\n', '   * @param _initialSupply How many tokens we start with\n', '   * @param _decimals Number of decimal places\n', "   * @param _addr Address for team's tokens\n", '   */\n', '   \n', '  function DAOPlayMarketToken(string _name, string _symbol, uint _initialSupply, uint _decimals, address _addr) public {\n', '    require(_addr != 0x0);\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '\t\n', '    _totalSupply = _initialSupply*10**_decimals;\n', '\n', '    // Creating initial tokens\n', '    balances[_addr] = _totalSupply;\n', '  }   \n', '  \n', '   /**\n', '   * Owner can update token information here.\n', '   *\n', '   * It is often useful to conceal the actual token association, until\n', '   * the token operations, like central issuance or reissuance have been completed.\n', '   *\n', '   * This function allows the token owner to rename the token after the operations\n', '   * have been completed and then point the audience to use the token contract.\n', '   */\n', '  function setTokenInformation(string _name, string _symbol) public onlyOwner {\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    UpdatedTokenInformation(name, symbol);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Haltable\n', ' * @dev Abstract contract that allows children to implement an\n', ' * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n', ' */\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    assert(!halted);\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    assert(halted);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   *@dev Called by the owner on emergency, triggers stopped state\n', '   */\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the owner on end of emergency, returns to normal state\n', '   */\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '}\n', '\n', '\n', '/** \n', ' * @title Killable DAOPlayMarketTokenCrowdsale contract\n', ' */\n', 'contract Killable is Ownable {\n', '  function kill() onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', '/** \n', ' * @title DAOPlayMarketTokenCrowdsale contract - contract for token sales.\n', ' */\n', 'contract DAOPlayMarketTokenCrowdsale is Haltable, SafeMath, Killable {\n', '  \n', '  /* The token we are selling */\n', '  DAOPlayMarketToken public token;\n', '\n', '  /* tokens will be transfered from this address */\n', '  address public multisigWallet;\n', '\n', '  /* the UNIX timestamp start date of the crowdsale */\n', '  uint public startsAt;\n', '  \n', '  /* the UNIX timestamp end date of the crowdsale */\n', '  uint public endsAt;\n', '  \n', '  /* the number of tokens already sold through this contract*/\n', '  uint public tokensSold = 0;\n', '  \n', '  /* How many wei of funding we have raised */\n', '  uint public weiRaised = 0;\n', '  \n', '  /* How many unique addresses that have invested */\n', '  uint public investorCount = 0;\n', '  \n', '  /* Has this crowdsale been finalized */\n', '  bool public finalized;\n', '  \n', '  /* Cap of tokens */\n', '  uint public CAP;\n', '  \n', '  /* How much ETH each address has invested to this crowdsale */\n', '  mapping (address => uint256) public investedAmountOf;\n', '  \n', '  /* How much tokens this crowdsale has credited for each investor address */\n', '  mapping (address => uint256) public tokenAmountOf;\n', '  \n', '  /* Contract address that can call invest other crypto */\n', '  address public cryptoAgent;\n', '  \n', "  /** How many tokens he charged for each investor's address in a particular period */\n", '  mapping (uint => mapping (address => uint256)) public tokenAmountOfPeriod;\n', '  \n', '  struct Stage {\n', '    // UNIX timestamp when the stage begins\n', '    uint start;\n', '    // UNIX timestamp when the stage is over\n', '    uint end;\n', '    // Number of period\n', '    uint period;\n', '    // Price#1 token in WEI\n', '    uint price1;\n', '    // Price#2 token in WEI\n', '    uint price2;\n', '    // Price#3 token in WEI\n', '    uint price3;\n', '    // Price#4 token in WEI\n', '    uint price4;\n', '    // Cap of period\n', '    uint cap;\n', '    // Token sold in period\n', '    uint tokenSold;\n', '  }\n', '  \n', '  /** Stages **/\n', '  Stage[] public stages;\n', '  uint public periodStage;\n', '  uint public stage;\n', '  \n', '  /** State machine\n', '   *\n', '   * - Preparing: All contract initialization calls and variables have not been set yet\n', '   * - Funding: Active crowdsale\n', '   * - Success: Minimum funding goal reached\n', '   * - Failure: Minimum funding goal not reached before ending time\n', '   * - Finalized: The finalized has been called and succesfully executed\n', '   */\n', '  enum State{Unknown, Preparing, Funding, Success, Failure, Finalized}\n', '  \n', '  // A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '  \n', '  // A new investment was made\n', '  event InvestedOtherCrypto(address investor, uint weiAmount, uint tokenAmount);\n', '\n', '  // Crowdsale end time has been changed\n', '  event EndsAtChanged(uint _endsAt);\n', '  \n', '  // New distributions were made\n', '  event DistributedTokens(address investor, uint tokenAmount);\n', '  \n', '  /** \n', '   * @dev Modified allowing execution only if the crowdsale is currently running\n', '   */\n', '  modifier inState(State state) {\n', '    require(getState() == state);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev The function can be called only by crowdsale agent.\n', '   */\n', '  modifier onlyCryptoAgent() {\n', '    assert(msg.sender == cryptoAgent);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Constructor\n', '   * @param _token DAOPlayMarketToken token address\n', '   * @param _multisigWallet team wallet\n', '   * @param _start token ICO start date\n', '   * @param _cap token ICO \n', '   * @param _price array of price \n', '   * @param _periodStage period of stage\n', '   * @param _capPeriod cap of period\n', '   */\n', '  function DAOPlayMarketTokenCrowdsale(address _token, address _multisigWallet, uint _start, uint _cap, uint[20] _price, uint _periodStage, uint _capPeriod) public {\n', '  \n', '    require(_multisigWallet != 0x0);\n', '    require(_start >= block.timestamp);\n', '    require(_cap > 0);\n', '    require(_periodStage > 0);\n', '    require(_capPeriod > 0);\n', '\t\n', '    token = DAOPlayMarketToken(_token);\n', '    multisigWallet = _multisigWallet;\n', '    startsAt = _start;\n', '    CAP = _cap*10**token.decimals();\n', '\t\n', '    periodStage = _periodStage*1 days;\n', '    uint capPeriod = _capPeriod*10**token.decimals();\n', '    uint j = 0;\n', '    for(uint i=0; i<_price.length; i=i+4) {\n', '      stages.push(Stage(startsAt+j*periodStage, startsAt+(j+1)*periodStage, j, _price[i], _price[i+1], _price[i+2], _price[i+3], capPeriod, 0));\n', '      j++;\n', '    }\n', '    endsAt = stages[stages.length-1].end;\n', '    stage = 0;\n', '  }\n', '  \n', '  /**\n', '   * Buy tokens from the contract\n', '   */\n', '  function() public payable {\n', '    investInternal(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Make an investment.\n', '   *\n', '   * Crowdsale must be running for one to invest.\n', '   * We must have not pressed the emergency brake.\n', '   *\n', '   * @param receiver The Ethereum address who receives the tokens\n', '   *\n', '   */\n', '  function investInternal(address receiver) private stopInEmergency {\n', '    require(msg.value > 0);\n', '\t\n', '    assert(getState() == State.Funding);\n', '\n', '    // Determine in what period we hit\n', '    stage = getStage();\n', '\t\n', '    uint weiAmount = msg.value;\n', '\n', '    // Account presale sales separately, so that they do not count against pricing tranches\n', '    uint tokenAmount = calculateToken(weiAmount, stage, token.decimals());\n', '\n', '    assert(tokenAmount > 0);\n', '\n', '\t// Check that we did not bust the cap in the period\n', '    assert(stages[stage].cap >= add(tokenAmount, stages[stage].tokenSold));\n', '\t\n', '    tokenAmountOfPeriod[stage][receiver]=add(tokenAmountOfPeriod[stage][receiver],tokenAmount);\n', '\t\n', '    stages[stage].tokenSold = add(stages[stage].tokenSold,tokenAmount);\n', '\t\n', '    if (stages[stage].cap == stages[stage].tokenSold){\n', '      updateStage(stage);\n', '      endsAt = stages[stages.length-1].end;\n', '    }\n', '\t\n', '\t// Check that we did not bust the cap\n', '    //assert(!isBreakingCap(tokenAmount, tokensSold));\n', '\t\n', '    if(investedAmountOf[receiver] == 0) {\n', '       // A new investor\n', '       investorCount++;\n', '    }\n', '\n', '    // Update investor\n', '    investedAmountOf[receiver] = add(investedAmountOf[receiver],weiAmount);\n', '    tokenAmountOf[receiver] = add(tokenAmountOf[receiver],tokenAmount);\n', '\n', '    // Update totals\n', '    weiRaised = add(weiRaised,weiAmount);\n', '    tokensSold = add(tokensSold,tokenAmount);\n', '\n', '    assignTokens(receiver, tokenAmount);\n', '\n', '    // send ether to the fund collection wallet\n', '    multisigWallet.transfer(weiAmount);\n', '\n', '    // Tell us invest was success\n', '    Invested(receiver, weiAmount, tokenAmount);\n', '\t\n', '  }\n', '  \n', '  /**\n', '   * Make an investment.\n', '   *\n', '   * Crowdsale must be running for one to invest.\n', '   * We must have not pressed the emergency brake.\n', '   *\n', '   * @param receiver The Ethereum address who receives the tokens\n', '   * @param _weiAmount amount in Eth\n', '   *\n', '   */\n', '  function investOtherCrypto(address receiver, uint _weiAmount) public onlyCryptoAgent stopInEmergency {\n', '    require(_weiAmount > 0);\n', '\t\n', '    assert(getState() == State.Funding);\n', '\n', '    // Determine in what period we hit\n', '    stage = getStage();\n', '\t\n', '    uint weiAmount = _weiAmount;\n', '\n', '    // Account presale sales separately, so that they do not count against pricing tranches\n', '    uint tokenAmount = calculateToken(weiAmount, stage, token.decimals());\n', '\n', '    assert(tokenAmount > 0);\n', '\n', '\t// Check that we did not bust the cap in the period\n', '    assert(stages[stage].cap >= add(tokenAmount, stages[stage].tokenSold));\n', '\t\n', '    tokenAmountOfPeriod[stage][receiver]=add(tokenAmountOfPeriod[stage][receiver],tokenAmount);\n', '\t\n', '    stages[stage].tokenSold = add(stages[stage].tokenSold,tokenAmount);\n', '\t\n', '    if (stages[stage].cap == stages[stage].tokenSold){\n', '      updateStage(stage);\n', '      endsAt = stages[stages.length-1].end;\n', '    }\n', '\t\n', '\t// Check that we did not bust the cap\n', '    //assert(!isBreakingCap(tokenAmount, tokensSold));\n', '\t\n', '    if(investedAmountOf[receiver] == 0) {\n', '       // A new investor\n', '       investorCount++;\n', '    }\n', '\n', '    // Update investor\n', '    investedAmountOf[receiver] = add(investedAmountOf[receiver],weiAmount);\n', '    tokenAmountOf[receiver] = add(tokenAmountOf[receiver],tokenAmount);\n', '\n', '    // Update totals\n', '    weiRaised = add(weiRaised,weiAmount);\n', '    tokensSold = add(tokensSold,tokenAmount);\n', '\n', '    assignTokens(receiver, tokenAmount);\n', '\t\n', '    // Tell us invest was success\n', '    InvestedOtherCrypto(receiver, weiAmount, tokenAmount);\n', '  }\n', '  \n', '  /**\n', '   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\n', '   */\n', '  function assignTokens(address receiver, uint tokenAmount) private {\n', '     token.mint(receiver, tokenAmount);\n', '  }\n', '   \n', '  /**\n', '   * Check if the current invested breaks our cap rules.\n', '   *\n', '   * Called from invest().\n', '   *\n', '   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\n', '   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\n', '   *\n', '   * @return true if taking this investment would break our cap rules\n', '   */\n', '  function isBreakingCap(uint tokenAmount, uint tokensSoldTotal) public constant returns (bool limitBroken){\n', '\tif(add(tokenAmount,tokensSoldTotal) <= CAP){\n', '\t  return false;\n', '\t}\n', '\treturn true;\n', '  }\n', '\n', '  /**\n', '   * @dev Distribution of remaining tokens.\n', '   */\n', '  function distributionOfTokens() public stopInEmergency {\n', '    require(block.timestamp >= endsAt);\n', '    require(!finalized);\n', '    uint amount;\n', '    for(uint i=0; i<stages.length; i++) {\n', '      if(tokenAmountOfPeriod[stages[i].period][msg.sender] != 0){\n', '        amount = add(amount,div(mul(sub(stages[i].cap,stages[i].tokenSold),tokenAmountOfPeriod[stages[i].period][msg.sender]),stages[i].tokenSold));\n', '        tokenAmountOfPeriod[stages[i].period][msg.sender] = 0;\n', '      }\n', '    }\n', '    assert(amount > 0);\n', '    assignTokens(msg.sender, amount);\n', '\t\n', '    // Tell us distributed was success\n', '    DistributedTokens(msg.sender, amount);\n', '  }\n', '  \n', '  /**\n', '   * @dev Finalize a succcesful crowdsale.\n', '   */\n', '  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '    require(block.timestamp >= (endsAt+periodStage));\n', '    require(!finalized);\n', '\t\n', '    finalizeCrowdsale();\n', '    finalized = true;\n', '  }\n', '  \n', '  /**\n', '   * @dev Finalize a succcesful crowdsale.\n', '   */\n', '  function finalizeCrowdsale() internal {\n', '    token.releaseTokenTransfer();\n', '  }\n', '  \n', '  /**\n', '   * @dev Check if the ICO goal was reached.\n', '   * @return true if the crowdsale has raised enough money to be a success\n', '   */\n', '  function isCrowdsaleFull() public constant returns (bool) {\n', '    if(tokensSold >= CAP || block.timestamp >= endsAt){\n', '      return true;  \n', '    }\n', '    return false;\n', '  }\n', '  \n', '  /** \n', '   * @dev Allow crowdsale owner to close early or extend the crowdsale.\n', '   * @param time timestamp\n', '   */\n', '  function setEndsAt(uint time) public onlyOwner {\n', '    require(!finalized);\n', '    require(time >= block.timestamp);\n', '    endsAt = time;\n', '    EndsAtChanged(endsAt);\n', '  }\n', '  \n', '   /**\n', '   * @dev Allow to change the team multisig address in the case of emergency.\n', '   */\n', '  function setMultisig(address addr) public onlyOwner {\n', '    require(addr != 0x0);\n', '    multisigWallet = addr;\n', '  }\n', '  \n', '  /**\n', '   * @dev Allow crowdsale owner to change the token address.\n', '   */\n', '  function setToken(address addr) public onlyOwner {\n', '    require(addr != 0x0);\n', '    token = DAOPlayMarketToken(addr);\n', '  }\n', '  \n', '  /** \n', '   * @dev Crowdfund state machine management.\n', '   * @return State current state\n', '   */\n', '  function getState() public constant returns (State) {\n', '    if (finalized) return State.Finalized;\n', '    else if (address(token) == 0 || address(multisigWallet) == 0 || block.timestamp < startsAt) return State.Preparing;\n', '    else if (block.timestamp <= endsAt && block.timestamp >= startsAt && !isCrowdsaleFull()) return State.Funding;\n', '    else if (isCrowdsaleFull()) return State.Success;\n', '    else return State.Failure;\n', '  }\n', '  \n', '  /** \n', '   * @dev Set base price for ICO.\n', '   */\n', '  function setBasePrice(uint[20] _price, uint _startDate, uint _periodStage, uint _cap, uint _decimals) public onlyOwner {\n', '    periodStage = _periodStage*1 days;\n', '    uint cap = _cap*10**_decimals;\n', '    uint j = 0;\n', '    delete stages;\n', '    for(uint i=0; i<_price.length; i=i+4) {\n', '      stages.push(Stage(_startDate+j*periodStage, _startDate+(j+1)*periodStage, j, _price[i], _price[i+1], _price[i+2], _price[i+3], cap, 0));\n', '      j++;\n', '    }\n', '    endsAt = stages[stages.length-1].end;\n', '    stage =0;\n', '  }\n', '  \n', '  /** \n', '   * @dev Updates the ICO steps if the cap is reached.\n', '   */\n', '  function updateStage(uint number) private {\n', '    require(number>=0);\n', '    uint time = block.timestamp;\n', '    uint j = 0;\n', '    stages[number].end = time;\n', '    for (uint i = number+1; i < stages.length; i++) {\n', '      stages[i].start = time+periodStage*j;\n', '      stages[i].end = time+periodStage*(j+1);\n', '      j++;\n', '    }\n', '  }\n', '  \n', '  /** \n', '   * @dev Gets the current stage.\n', '   * @return uint current stage\n', '   */\n', '  function getStage() private constant returns (uint){\n', '    for (uint i = 0; i < stages.length; i++) {\n', '      if (block.timestamp >= stages[i].start && block.timestamp < stages[i].end) {\n', '        return stages[i].period;\n', '      }\n', '    }\n', '    return stages[stages.length-1].period;\n', '  }\n', '  \n', '  /** \n', '   * @dev Gets the cap of amount.\n', '   * @return uint cap of amount\n', '   */\n', '  function getAmountCap(uint value) private constant returns (uint ) {\n', '    if(value <= 10*10**18){\n', '      return 0;\n', '    }else if (value <= 50*10**18){\n', '      return 1;\n', '    }else if (value <= 300*10**18){\n', '      return 2;\n', '    }else {\n', '      return 3;\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n', '   * @param value - The value of the transaction send in as wei\n', '   * @param _stage - The stage of ICO\n', '   * @param decimals - How many decimal places the token has\n', '   * @return Amount of tokens the investor receives\n', '   */\n', '   \n', '  function calculateToken(uint value, uint _stage, uint decimals) private constant returns (uint){\n', '    uint tokenAmount = 0;\n', '    uint saleAmountCap = getAmountCap(value); \n', '\t\n', '    if(saleAmountCap == 0){\n', '      tokenAmount = div(value*10**decimals,stages[_stage].price1);\n', '    }else if(saleAmountCap == 1){\n', '      tokenAmount = div(value*10**decimals,stages[_stage].price2);\n', '    }else if(saleAmountCap == 2){\n', '      tokenAmount = div(value*10**decimals,stages[_stage].price3);\n', '    }else{\n', '      tokenAmount = div(value*10**decimals,stages[_stage].price4);\n', '    }\n', '    return tokenAmount;\n', '  }\n', ' \n', '  /**\n', '   * @dev Set the contract that can call the invest other crypto function.\n', '   * @param _cryptoAgent crowdsale contract address\n', '   */\n', '  function setCryptoAgent(address _cryptoAgent) public onlyOwner {\n', '    require(!finalized);\n', '    cryptoAgent = _cryptoAgent;\n', '  }\n', '}']