['pragma solidity ^0.4.13;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// Token standard API\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf( address who ) public view returns (uint value);\n', '    function allowance( address owner, address spender ) public view returns (uint _allowance);\n', '\n', '    function transfer( address to, uint value) public returns (bool ok);\n', '    function transferFrom( address from, address to, uint value) public returns (bool ok);\n', '    function approve( address spender, uint value ) public returns (bool ok);\n', '\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract DSStop is DSNote, DSAuth {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require(!stopped);\n', '        _;\n', '    }\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract TokenTransferGuard {\n', '    function onTokenTransfer(address _from, address _to, uint _amount) public returns (bool);\n', '}\n', '\n', 'contract RewardSharedPool is DSStop {\n', '    using SafeMath for uint256;\n', '\n', '    uint public maxReward      = 1000000 ether;\n', '\n', '    uint public consumed   = 0;\n', '\n', '    mapping(address => bool) public consumers;\n', '\n', '    modifier onlyConsumer {\n', '        require(msg.sender == owner || consumers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function RewardSharedPool()\n', '    {\n', '    }\n', '\n', '    function consume(uint amount) onlyConsumer public returns (bool)\n', '    {\n', '        require(available(amount));\n', '\n', '        consumed = consumed.add(amount);\n', '\n', '        Consume(msg.sender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function available(uint amount) constant public returns (bool)\n', '    {\n', '        return consumed.add(amount) <= maxReward;\n', '    }\n', '\n', '    function changeMaxReward(uint _maxReward) auth public\n', '    {\n', '        maxReward = _maxReward;\n', '    }\n', '\n', '    function addConsumer(address consumer) public auth\n', '    {\n', '        consumers[consumer] = true;\n', '\n', '        ConsumerAddition(consumer);\n', '    }\n', '\n', '    function removeConsumer(address consumer) public auth\n', '    {\n', '        consumers[consumer] = false;\n', '\n', '        ConsumerRemoval(consumer);\n', '    }\n', '\n', '    event Consume(address indexed _sender, uint _value);\n', '    event ConsumerAddition(address indexed _consumer);\n', '    event ConsumerRemoval(address indexed _consumer);\n', '}\n', '\n', 'contract ATNLongTermHolding is DSStop, TokenTransferGuard {\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant DEPOSIT_WINDOW                 = 60 days;\n', '\n', '    // There are three kinds of options: 1. {105, 120 days}, 2. {110, 240 days}, 3. {115, 360 days}\n', '    uint public rate = 105;\n', '    uint public withdrawal_delay    = 120 days;\n', '\n', '    uint public agtAtnReceived      = 0;\n', '    uint public atnSent             = 0;\n', '\n', '    uint public depositStartTime    = 0;\n', '    uint public depositStopTime     = 0;\n', '\n', '    RewardSharedPool public pool;\n', '\n', '    struct Record {\n', '        uint agtAtnAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) public records;\n', '\n', '    ERC20 public AGT;\n', '    ERC20 public ATN;\n', '\n', '    uint public gasRequired;\n', '\n', '    function ATNLongTermHolding(address _agt, address _atn, address _poolAddress, uint _rate, uint _delayDays)\n', '    {\n', '        AGT = ERC20(_agt);\n', '        ATN = ERC20(_atn);\n', '\n', '        pool = RewardSharedPool(_poolAddress);\n', '\n', '        require(_rate > 100);\n', '\n', '        rate = _rate;\n', '        withdrawal_delay = _delayDays * 1 days;\n', '    }\n', '\n', '    function start() public auth {\n', '        require(depositStartTime == 0);\n', '\n', '        depositStartTime = now;\n', '        depositStopTime  = now + DEPOSIT_WINDOW;\n', '\n', '        Started(depositStartTime);\n', '    }\n', '\n', '    function changeDepositStopTimeFromNow(uint _daysFromNow) public auth {\n', '        depositStopTime = now + _daysFromNow * 1 days;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public\n', '    {\n', '        tokenFallback(_from, _value);\n', '    }\n', '\n', '    // TODO: To test the stoppable can work or not\n', '    function tokenFallback(address _from, uint256 _value) public stoppable\n', '    {\n', '        if (msg.sender == address(AGT) || msg.sender == address(ATN))\n', '        {\n', '            // the owner is not count in the statistics\n', '            // Only owner can use to deposit the ATN reward things.\n', '            if (_from == owner)\n', '            {\n', '                return;\n', '            }\n', '\n', '            require(now <= depositStopTime);\n', '\n', '            var record = records[_from];\n', '\n', '            record.agtAtnAmount += _value;\n', '            record.timestamp = now;\n', '            records[_from] = record;\n', '\n', '            agtAtnReceived += _value;\n', '\n', '            pool.consume( _value.mul(rate - 100 ).div(100) );\n', '\n', '            Deposit(depositId++, _from, _value);\n', '        }\n', '    }\n', '\n', '    function onTokenTransfer(address _from, address _to, uint _amount) public returns (bool)\n', '    {\n', '        if (_to == address(this) && _from != owner)\n', '        {\n', '            if (msg.gas < gasRequired) return false;\n', '            \n', '            if (stopped) return false;\n', '            if (now > depositStopTime) return false;\n', '\n', '            // each address can only deposit once.\n', '            if (records[_from].timestamp > 0 ) return false;\n', '\n', '            // can not over the limit of maximum reward amount\n', '            if ( !pool.available( _amount.mul(rate - 100 ).div(100) ) ) return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawATN() public stoppable {\n', '        require(msg.sender != owner);\n', '\n', '        Record record = records[msg.sender];\n', '\n', '        require(record.timestamp > 0);\n', '\n', '        require(now >= record.timestamp + withdrawal_delay);\n', '\n', '        withdrawFor(msg.sender);\n', '    }\n', '\n', '    function withdrawATN(address _addr) public stoppable {\n', '        require(_addr != owner);\n', '\n', '        Record record = records[_addr];\n', '\n', '        require(record.timestamp > 0);\n', '\n', '        require(now >= record.timestamp + withdrawal_delay);\n', '\n', '        withdrawFor(_addr);\n', '    }\n', '\n', '    function withdrawFor(address _addr) internal {\n', '        Record record = records[_addr];\n', '        \n', '        uint atnAmount = record.agtAtnAmount.mul(rate).div(100);\n', '\n', '        require(ATN.transfer(_addr, atnAmount));\n', '\n', '        atnSent += atnAmount;\n', '\n', '        delete records[_addr];\n', '\n', '        Withdrawal(\n', '                   withdrawId++,\n', '                   _addr,\n', '                   atnAmount\n', '                   );\n', '    }\n', '\n', '    function batchWithdraw(address[] _addrList) public stoppable {\n', '        for (uint i = 0; i < _addrList.length; i++) {\n', '            if (records[_addrList[i]].timestamp > 0 && now >= records[_addrList[i]].timestamp + withdrawal_delay)\n', '            {\n', '                withdrawFor(_addrList[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function changeGasRequired(uint _gasRequired) public auth {\n', '        gasRequired = _gasRequired;\n', '        ChangeGasRequired(_gasRequired);\n', '    }\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) public auth {\n', '        if (_token == 0x0) {\n', '            owner.transfer(this.balance);\n', '            return;\n', '        }\n', '        \n', '        ERC20 token = ERC20(_token);\n', '        \n', '        uint256 balance = token.balanceOf(this);\n', '        \n', '        token.transfer(owner, balance);\n', '        ClaimedTokens(_token, owner, balance);\n', '    }\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint agtAtnAmount);\n', '\n', '    /// Emitted for each sucuessful withdrawal.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _atnAmount);\n', '\n', '    event ChangeGasRequired(uint _gasRequired);\n', '}']