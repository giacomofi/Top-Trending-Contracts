['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ApproveAndCallReceiver {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', 'contract TokenFactoryInterface {\n', '\n', '    function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        string _tokenSymbol\n', '      ) public returns (ProofToken newToken);\n', '}\n', '\n', 'contract Controllable {\n', '  address public controller;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  function Controllable() public {\n', '    controller = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyController() {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newController The address to transfer ownership to.\n', '   */\n', '  function transferControl(address newController) public onlyController {\n', '    if (newController != address(0)) {\n', '      controller = newController;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract ProofToken is Controllable {\n', '\n', '  using SafeMath for uint256;\n', '  ProofTokenInterface public parentToken;\n', '  TokenFactoryInterface public tokenFactory;\n', '\n', '  string public name;\n', '  string public symbol;\n', '  string public version;\n', '  uint8 public decimals;\n', '\n', '  uint256 public parentSnapShotBlock;\n', '  uint256 public creationBlock;\n', '  bool public transfersEnabled;\n', '\n', '  bool public masterTransfersEnabled;\n', '  address public masterWallet = 0xD8271285C255Ce31b9b25E46ac63619322Af5934;\n', '\n', '\n', '  struct Checkpoint {\n', '    uint128 fromBlock;\n', '    uint128 value;\n', '  }\n', '\n', '  Checkpoint[] totalSupplyHistory;\n', '  mapping(address => Checkpoint[]) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  bool public mintingFinished = false;\n', '  bool public presaleBalancesLocked = false;\n', '\n', '  uint256 public constant TOTAL_PRESALE_TOKENS = 112386712924725508802400;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '  event NewCloneToken(address indexed cloneToken);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '\n', '\n', '  function ProofToken(\n', '    address _tokenFactory,\n', '    address _parentToken,\n', '    uint256 _parentSnapShotBlock,\n', '    string _tokenName,\n', '    string _tokenSymbol\n', '    ) public {\n', '      tokenFactory = TokenFactoryInterface(_tokenFactory);\n', '      parentToken = ProofTokenInterface(_parentToken);\n', '      parentSnapShotBlock = _parentSnapShotBlock;\n', '      name = _tokenName;\n', '      symbol = _tokenSymbol;\n', '      decimals = 18;\n', '      transfersEnabled = false;\n', '      masterTransfersEnabled = false;\n', '      creationBlock = block.number;\n', "      version = '0.1';\n", '  }\n', '\n', '  function() public payable {\n', '    revert();\n', '  }\n', '\n', '\n', '  /**\n', '  * Returns the total Proof token supply at the current block\n', '  * @return total supply {uint256}\n', '  */\n', '  function totalSupply() public constant returns (uint256) {\n', '    return totalSupplyAt(block.number);\n', '  }\n', '\n', '  /**\n', '  * Returns the total Proof token supply at the given block number\n', '  * @param _blockNumber {uint256}\n', '  * @return total supply {uint256}\n', '  */\n', '  function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {\n', '    // These next few lines are used when the totalSupply of the token is\n', '    //  requested before a check point was ever created for this token, it\n', '    //  requires that the `parentToken.totalSupplyAt` be queried at the\n', '    //  genesis block for this token as that contains totalSupply of this\n', '    //  token at this block number.\n', '    if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '        if (address(parentToken) != 0) {\n', '            return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '        } else {\n', '            return 0;\n', '        }\n', '\n', '    // This will return the expected totalSupply during normal situations\n', '    } else {\n', '        return getValueAt(totalSupplyHistory, _blockNumber);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * Returns the token holder balance at the current block\n', '  * @param _owner {address}\n', '  * @return balance {uint256}\n', '   */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balanceOfAt(_owner, block.number);\n', '  }\n', '\n', '  /**\n', '  * Returns the token holder balance the the given block number\n', '  * @param _owner {address}\n', '  * @param _blockNumber {uint256}\n', '  * @return balance {uint256}\n', '  */\n', '  function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {\n', '    // These next few lines are used when the balance of the token is\n', '    //  requested before a check point was ever created for this token, it\n', '    //  requires that the `parentToken.balanceOfAt` be queried at the\n', '    //  genesis block for that token as this contains initial balance of\n', '    //  this token\n', '    if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '        if (address(parentToken) != 0) {\n', '            return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '        } else {\n', '            // Has no parent\n', '            return 0;\n', '        }\n', '\n', '    // This will return the expected balance during normal situations\n', '    } else {\n', '        return getValueAt(balances[_owner], _blockNumber);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 transfer tokens function\n', '  * @param _to {address}\n', '  * @param _amount {uint}\n', '  * @return success {bool}\n', '  */\n', '  function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '    return doTransfer(msg.sender, _to, _amount);\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 transferFrom function\n', '  * @param _from {address}\n', '  * @param _to {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '    require(allowed[_from][msg.sender] >= _amount);\n', '    allowed[_from][msg.sender] -= _amount;\n', '    return doTransfer(_from, _to, _amount);\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 approve function\n', '  * @param _spender {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '    require(transfersEnabled);\n', '\n', '    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 approve function\n', '  * @param _spender {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n', '    approve(_spender, _amount);\n', '\n', '    ApproveAndCallReceiver(_spender).receiveApproval(\n', '        msg.sender,\n', '        _amount,\n', '        this,\n', '        _extraData\n', '    );\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * Standard ERC20 allowance function\n', '  * @param _owner {address}\n', '  * @param _spender {address}\n', '  * @return remaining {uint256}\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '  * Internal Transfer function - Updates the checkpoint ledger\n', '  * @param _from {address}\n', '  * @param _to {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\n', '\n', '    if (msg.sender != masterWallet) {\n', '      require(transfersEnabled);\n', '    } else {\n', '      require(masterTransfersEnabled);\n', '    }\n', '\n', '    require(_amount > 0);\n', '    require(parentSnapShotBlock < block.number);\n', '    require((_to != 0) && (_to != address(this)));\n', '\n', '    // If the amount being transfered is more than the balance of the\n', '    // account the transfer returns false\n', '    uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n', '    require(previousBalanceFrom >= _amount);\n', '\n', '    // First update the balance array with the new value for the address\n', '    //  sending the tokens\n', '    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '    // Then update the balance array with the new value for the address\n', '    //  receiving the tokens\n', '    uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n', '    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '    // An event to make the transfer easy to find on the blockchain\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * Token creation functions - can only be called by the tokensale controller during the tokensale period\n', '  * @param _owner {address}\n', '  * @param _amount {uint256}\n', '  * @return success {bool}\n', '  */\n', '  function mint(address _owner, uint256 _amount) public onlyController canMint returns (bool) {\n', '    uint256 curTotalSupply = totalSupply();\n', '    uint256 previousBalanceTo = balanceOf(_owner);\n', '\n', '    require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n', '    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '\n', '    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '    Transfer(0, _owner, _amount);\n', '    return true;\n', '  }\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Import presale balances before the start of the token sale. After importing\n', '   * balances, lockPresaleBalances() has to be called to prevent further modification\n', '   * of presale balances.\n', '   * @param _addresses {address[]} Array of presale addresses\n', '   * @param _balances {uint256[]} Array of balances corresponding to presale addresses.\n', '   * @return success {bool}\n', '   */\n', '  function importPresaleBalances(address[] _addresses, uint256[] _balances) public onlyController returns (bool) {\n', '    require(presaleBalancesLocked == false);\n', '\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      updateValueAtNow(balances[_addresses[i]], _balances[i]);\n', '      Transfer(0, _addresses[i], _balances[i]);\n', '    }\n', '\n', '    updateValueAtNow(totalSupplyHistory, TOTAL_PRESALE_TOKENS);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Lock presale balances after successful presale balance import\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function lockPresaleBalances() public onlyController returns (bool) {\n', '    presaleBalancesLocked = true;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Lock the minting of Proof Tokens - to be called after the presale\n', '   * @return {bool} success\n', '  */\n', '  function finishMinting() public onlyController returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Enable or block transfers - to be called in case of emergency\n', '   * @param _value {bool}\n', '  */\n', '  function enableTransfers(bool _value) public onlyController {\n', '    transfersEnabled = _value;\n', '  }\n', '\n', '  /**\n', '   * Enable or block transfers - to be called in case of emergency\n', '   * @param _value {bool}\n', '  */\n', '  function enableMasterTransfers(bool _value) public onlyController {\n', '    masterTransfersEnabled = _value;\n', '  }\n', '\n', '  /**\n', '   * Internal balance method - gets a certain checkpoint value a a certain _block\n', '   * @param _checkpoints {Checkpoint[]} List of checkpoints - supply history or balance history\n', '   * @return value {uint256} Value of _checkpoints at _block\n', '  */\n', '  function getValueAt(Checkpoint[] storage _checkpoints, uint256 _block) constant internal returns (uint256) {\n', '\n', '      if (_checkpoints.length == 0)\n', '        return 0;\n', '      // Shortcut for the actual value\n', '      if (_block >= _checkpoints[_checkpoints.length-1].fromBlock)\n', '        return _checkpoints[_checkpoints.length-1].value;\n', '      if (_block < _checkpoints[0].fromBlock)\n', '        return 0;\n', '\n', '      // Binary search of the value in the array\n', '      uint256 min = 0;\n', '      uint256 max = _checkpoints.length-1;\n', '      while (max > min) {\n', '          uint256 mid = (max + min + 1) / 2;\n', '          if (_checkpoints[mid].fromBlock<=_block) {\n', '              min = mid;\n', '          } else {\n', '              max = mid-1;\n', '          }\n', '      }\n', '      return _checkpoints[min].value;\n', '  }\n', '\n', '\n', '  /**\n', '  * Internal update method - updates the checkpoint ledger at the current block\n', '  * @param _checkpoints {Checkpoint[]}  List of checkpoints - supply history or balance history\n', '  * @return value {uint256} Value to add to the checkpoints ledger\n', '   */\n', '  function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\n', '      if ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\n', '              Checkpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\n', '              newCheckPoint.fromBlock = uint128(block.number);\n', '              newCheckPoint.value = uint128(_value);\n', '          } else {\n', '              Checkpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\n', '              oldCheckPoint.value = uint128(_value);\n', '          }\n', '  }\n', '\n', '\n', '  function min(uint256 a, uint256 b) internal constant returns (uint) {\n', '      return a < b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * Clones Proof Token at the given snapshot block\n', '  * @param _snapshotBlock {uint256}\n', '  * @param _name {string} - The cloned token name\n', '  * @param _symbol {string} - The cloned token symbol\n', '  * @return clonedTokenAddress {address}\n', '   */\n', '  function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\n', '\n', '      if (_snapshotBlock == 0) {\n', '        _snapshotBlock = block.number;\n', '      }\n', '\n', '      if (_snapshotBlock > block.number) {\n', '        _snapshotBlock = block.number;\n', '      }\n', '\n', '      ProofToken cloneToken = tokenFactory.createCloneToken(\n', '          this,\n', '          _snapshotBlock,\n', '          _name,\n', '          _symbol\n', '        );\n', '\n', '\n', '      cloneToken.transferControl(msg.sender);\n', '\n', '      // An event to make the token easy to find on the blockchain\n', '      NewCloneToken(address(cloneToken));\n', '      return address(cloneToken);\n', '    }\n', '\n', '}\n', '\n', 'contract ProofTokenInterface is Controllable {\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n', '  function transfer(address _to, uint256 _amount) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n', '  function approve(address _spender, uint256 _amount) public returns (bool success);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  function mint(address _owner, uint _amount) public returns (bool);\n', '  function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool);\n', '  function lockPresaleBalances() public returns (bool);\n', '  function finishMinting() public returns (bool);\n', '  function enableTransfers(bool _value) public;\n', '  function enableMasterTransfers(bool _value) public;\n', '  function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address);\n', '\n', '}\n', '\n', 'contract ControllerInterface {\n', '\n', '    function proxyPayment(address _owner) public payable returns(bool);\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '}']