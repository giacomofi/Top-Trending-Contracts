['contract Constants {\n', '\tuint256 public constant PRE_ICO_RISK_PERCENTAGE = 5;\n', '\tuint256 public constant TEAM_SHARE_PERCENTAGE = 16;\n', '\tuint256 public constant blocksByDay = 6150;\n', '\tuint256 public constant coinMultiplayer = (10**18);\n', '\t\n', '\tuint256 public constant PRICE_PREICO = 12500;\n', '\tuint256 public constant PRICE_ICO1 = 10000;\n', '\tuint256 public constant PRICE_ICO2 = 8000;\n', '\tuint256 public constant PRICE_ICO4 = 6250;\n', '\t\n', '\tuint256 public constant delayOfPreICO = blocksByDay*30;\n', '\tuint256 public constant delayOfICO1 = blocksByDay*50;\n', '\tuint256 public constant delayOfICO2 = blocksByDay*70;\n', '\tuint256 public constant delayOfICOEND = blocksByDay*90;\n', '   uint256 public constant minimumGoal = coinMultiplayer*(10**5)*1786 ;\n', '  uint256 public constant maxTokenSupplyPreICO = coinMultiplayer*(10**6)*357 ; \n', '  uint256 public constant maxTokenSupplyICO1 = coinMultiplayer*(10**6)*595 ; \n', '  uint256 public constant maxTokenSupplyICO2 = coinMultiplayer*(10**6)*833 ; \n', '  uint256 public constant maxTokenSupplyICOEND =coinMultiplayer*(10**6)*1000 ; \n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) constant public returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) constant public returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) constant public returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) constant public returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract DevTeamContractI{\n', '\tfunction recieveFunds() payable public;\n', '}\n', '\n', 'contract CABCoinI{\n', '  address public owner;\n', '  uint256 public totalSupply;\n', '  bool public mintingFinished = false;\n', '  modifier onlyOwner() {\n', '    if(msg.sender == owner){\n', '      _;\n', '    }\n', '    else{\n', '      revert();\n', '    }\n', '  }\n', '  \n', '  modifier canMint() {\n', '    if(!mintingFinished){\n', '      _;\n', '    }\n', '    else{\n', '      revert();\n', '    }\n', '  }\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool);\n', '  function getMaxTokenAvaliable() constant public  returns(uint256);\n', '  function finishMinting() onlyOwner public returns (bool);\n', '}\n', '\n', 'contract CABCoinICO is Constants{\n', '  using SafeMath for uint256;\n', '  mapping(address => bool) public preICOHolders ;\n', '  mapping(address => uint256) public ethGiven ;\n', '\taddress public tokenAddress = 0;\n', '\tDevTeamContractI public devTeam;\n', '\tuint256 public _startBlock ;\n', '\tCABCoinI public coin;\n', '\t\n', '\t\n', '\tevent AmountToLittle();\n', '\tevent SendAllFunds();\n', '\tevent Buy(address who,uint256 amount);\n', '\tevent Refund(address who,uint256 amount);\n', '\t\n', '  modifier canMint() {\n', '    if(coin.mintingFinished()==false){\n', '    \t_;\n', '    }\n', '    else{\n', '    \t\n', '    }\n', '  }\n', '  \n', '  bool private isRunned = false;\n', '  \n', '  modifier runOnce() {\n', '  \tif(isRunned){\n', '  \t\trevert();\n', '  \t}\n', '  \telse{\n', '  \t\tisRunned = true;\n', '  \t\t_;\n', '  \t}\n', '  }\n', '  \n', '\tuint256 public currBlock = 1;\n', '\t\n', '\tfunction GetTime() public constant returns(uint256) {\n', '\t  return block.number;\n', '\t}\n', '\t\n', '\tfunction getAllTimes() public constant returns(uint256,uint256,uint256){\n', '\t\tif(GetTime()<_startBlock){\n', '\t\t\treturn(_startBlock.sub(GetTime()),0,0);\n', '\t\t}\n', '\t\tif(GetTime()<=_startBlock.add(delayOfICOEND))\n', '\t\t{\n', '\t\t\tuint256 currentStageTime = 0;\n', '\t\t\tif(GetTime()<_startBlock.add(delayOfPreICO)){\n', '\t\t\t\tcurrentStageTime = _startBlock.add(delayOfPreICO) - GetTime();\n', '\t\t\t}\n', '\t\t\telse{\n', '\t\t\t\tif(GetTime()<_startBlock.add(delayOfICO1)){\n', '\t\t\t\t\tcurrentStageTime = _startBlock.add(delayOfICO1) - GetTime();\n', '\t\t\t\t}\n', '\t\t\t\telse{\n', '\t\t\t\t\tif(GetTime()<_startBlock.add(delayOfICO2)){\n', '\t\t\t\t\t\tcurrentStageTime = _startBlock.add(delayOfICO2) - GetTime();\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif(GetTime()>=_startBlock){\n', '\t\t\t\treturn(0,currentStageTime,_startBlock.add(delayOfICOEND)-GetTime());\n', '\t\t\t}\n', '\t\t}\n', '\t\telse{\n', '\t\t\treturn(0,0,0);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction CABCoinICO(uint256 sBlock) public {\n', '\t\tif(sBlock==0){\n', '\t    \t_startBlock = GetTime();\n', '\t\t}\n', '\t\telse{\n', '\t    \t_startBlock = sBlock;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction SetContracts(address coinAdr, address dev) runOnce() public{\n', '\t\t\n', '  \t\tif(tokenAddress == address(0)){\n', '  \t\t\ttokenAddress = coinAdr;\n', '\t\t    coin = CABCoinI(coinAdr);\n', '\t\t    devTeam =  DevTeamContractI(dev);\n', '  \t\t}\n', '\t}\n', '\t\n', '\tfunction getMaxEther() constant public  returns(uint256) {\n', '\t\tuint256 maxAv = coin.getMaxTokenAvaliable();\n', '\t\tuint256 price = getCabCoinsAmount();\n', '\t\tvar maxEth = maxAv.div(price);\n', '\t\treturn maxEth;\n', '\t}\n', '\t\n', '\tfunction isAfterICO()  public constant returns(bool) {\n', '\t  return (getCabCoinsAmount() == 0); \n', '\t}\n', '\t\n', '\tfunction getCabCoinsAmount()  public constant returns(uint256) {\n', '\t\tif(GetTime()<_startBlock){\n', '\t\t\treturn 0;\t\n', '\t\t}\n', '\t    if(GetTime()<_startBlock.add(delayOfPreICO)){\n', '\t    \tif(maxTokenSupplyPreICO>coin.totalSupply()){\n', '\t        \treturn PRICE_PREICO;\n', '\t    \t}\n', '\t    }\n', '\t    if(GetTime()<_startBlock.add(delayOfICO1) ){\n', '\t\t    if(maxTokenSupplyICO1>coin.totalSupply()){\n', '\t\t        return PRICE_ICO1;\n', '\t\t    }\t\n', '\t    } \n', '\t    if(GetTime()<_startBlock.add(delayOfICO2)){\n', '\t    \tif(maxTokenSupplyICO2>coin.totalSupply()){\n', '\t        \treturn PRICE_ICO2;\n', '\t    \t}\n', '\t    }\n', '\t    if(GetTime()<=_startBlock.add(delayOfICOEND)){\n', '\t    \tif(maxTokenSupplyICOEND>=coin.totalSupply()){\n', '\t        \treturn PRICE_ICO4;\n', '\t    \t}\n', '\t    }\n', '\t\treturn 0; \n', '\t}\n', '\t\n', '\tfunction() payable public{\n', '\t\t\n', '\t  if(isAfterICO() && coin.totalSupply()<minimumGoal){\n', '\t\tthis.refund.value(msg.value)(msg.sender);\n', '\t  }else{\n', '\t  \tif(msg.value==0){\n', '\t  \t\tsendAllFunds();\n', '\t  \t}else{\n', '\t  \t\t\n', '\t\t  \tif(isAfterICO() == false){\n', '\t\t\t\tthis.buy.value(msg.value)(msg.sender);\n', '\t\t  \t}else{\n', '\t  \t\t\trevert();\t\n', '\t\t  \t}\n', '\t  \t}\n', '\t  }\n', '\t}\n', '\t\n', '\tfunction buy(address owner) payable public{\n', '\t\t\n', '\t  bool isMintedDev ;\n', '\t  bool isMinted ;\n', '\t  Buy(owner,msg.value);\n', '\t  uint256 tokensAmountPerEth = getCabCoinsAmount();\n', '\t  \n', '\t\tif(GetTime()<_startBlock){\n', '\t\t\trevert();\n', '\t\t}\n', '\t\telse{\n', '\t\t\t\n', '\t\t\tif(tokensAmountPerEth==0){\n', '\t\t\t  coin.finishMinting();\n', '\t\t\t  msg.sender.transfer(msg.value);\n', '\t\t\t}\n', '\t\t\telse{\n', '\t\t\t\n', '\t\t\t\tuint256 tokensAvailable = coin.getMaxTokenAvaliable() ;\n', '\t\t  \t\tuint256 val = tokensAmountPerEth.mul(msg.value) ;\n', '\t\t  \t\t\n', '\t\t  \t\tuint256 valForTeam = val.mul(TEAM_SHARE_PERCENTAGE).div(100-TEAM_SHARE_PERCENTAGE);\n', '\t\t  \t\t\n', '\t\t  \t\tif(tokensAvailable<val+valForTeam){\n', '\t\t  \t\t\tAmountToLittle();\n', '\t\t  \t\t\tval = val.mul(tokensAvailable).div(val.add(valForTeam));\n', '\t\t  \t\t\tvalForTeam = val.mul(TEAM_SHARE_PERCENTAGE).div(100-TEAM_SHARE_PERCENTAGE);\n', '\t\t\t  \t\tisMintedDev =coin.mint(owner,val);\n', '\t\t\t  \t\tisMinted =  coin.mint(devTeam,valForTeam);\n', '\t\t\t  \t\t\n', '\t\t\t     \tethGiven[owner] = ethGiven[owner].add(msg.value);\n', '\t\t\t  \t\tif(isMintedDev==false){\n', '\t\t\t  \t\t  revert();\n', '\t\t\t  \t\t}\n', '\t\t\t  \t\tif(isMinted==false){\n', '\t\t\t  \t\t  revert();\n', '\t\t\t  \t\t}\n', '\t\t\t\t\tcoin.finishMinting();\n', '\t\t  \t\t}\n', '\t\t  \t\telse\n', '\t\t  \t\t{\n', '\t\t  \t\t\t\n', '\t\t\t  \t\tif(IsPreICO()){\n', '\t\t\t  \t\t  preICOHolders[owner] = true;\n', '\t\t\t  \t\t  devTeam.recieveFunds.value(msg.value.mul(PRE_ICO_RISK_PERCENTAGE).div(100))();\n', '\t\t\t  \t\t}\n', '\t\t\t  \t\n', '\t\t\t  \t\tisMintedDev =coin.mint(owner,val);\n', '\t\t\t  \t\tisMinted =  coin.mint(devTeam,valForTeam);\n', '\t\t\t  \t\t\n', '\t\t\t     \tethGiven[owner] = ethGiven[owner].add(msg.value);\n', '\t\t\t  \t\tif(isMintedDev==false){\n', '\t\t\t  \t\t  revert();\n', '\t\t\t  \t\t}\n', '\t\t\t  \t\tif(isMinted==false){\n', '\t\t\t  \t\t  revert();\n', '\t\t\t  \t\t}\n', '\t\t\t  \t\t\n', '\t\t  \t\t}\n', '\t\t\t\n', '\t\t\t}\n', '\t\t \n', '\t\t}\n', '\t\t\n', '\t}\n', '\t\n', '\tfunction IsPreICO() returns(bool){\n', '\t  if(GetTime()<_startBlock.add(delayOfPreICO)){\n', '\t    return true;\n', '\t  }\n', '\t  else{\n', '\t    return false;\n', '\t  }\n', '\t}\n', '\t\n', '\tfunction sendAllFunds() public {\n', '\t  SendAllFunds();\n', '\t  if(coin.totalSupply()>=minimumGoal){ // goal reached money Goes to devTeam\n', '\t    \n', '\t\tdevTeam.recieveFunds.value(this.balance)();\n', '\t  }\n', '\t  else\n', '\t  {\n', '\t    revert();\n', '\t  }\n', '\t}\n', '\t\n', '\t\n', '\tfunction refund(address sender) payable public {\n', '\t  Refund(sender,ethGiven[sender]);\n', '\t  if(isAfterICO() && coin.totalSupply()<minimumGoal){ // goal not reached\n', '\t    var sumToReturn = ethGiven[sender];\n', '\t     ethGiven[sender] =0;\n', '\t    if(preICOHolders[msg.sender]){\n', '\t    \tsumToReturn = sumToReturn.mul(100-PRE_ICO_RISK_PERCENTAGE).div(100);\n', '\t    }\n', '\t    sumToReturn = sumToReturn.add(msg.value);\n', '\t    if(sumToReturn>this.balance){\n', '\t    \tsender.transfer(this.balance);\n', '\t    }\n', '\t    else{\n', '\t    \tsender.transfer(sumToReturn.add(msg.value));\n', '\t    }\n', '\t  }\n', '\t  else\n', '\t  {\n', '\t  \tif(msg.value>0){\n', '\t  \t\tsender.transfer(msg.value);\n', '\t  \t}\n', '\t  }\n', '\t}\n', '}']