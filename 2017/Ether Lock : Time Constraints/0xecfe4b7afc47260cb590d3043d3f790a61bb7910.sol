['pragma solidity ^0.4.19;\n', '\n', 'contract ForeignToken {\n', '    function balanceOf(address _owner) constant returns (uint256);\n', '    function transfer(address _to, uint256 _value) returns (bool);\n', '}\n', '\n', 'interface Token { \n', '    function transfer(address _to, uint256 _value) returns (bool);\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract EbyteDistribution {\n', '    \n', '    mapping (address => uint256) balances;\n', '    mapping (address => bool) public blacklist;\n', '    Token public ebyteToken;\n', '    address public owner;\n', '    uint256 public rate = 100000000;\n', '    uint256 public percentage = 20;\n', '    uint256 public ethBalance = 10000000000;\n', '    uint256 public ebyteBalance = 100;\n', '    bool public contractLocked = true;\n', '    \n', '    event sendTokens(address indexed to, uint256 value);\n', '    event Locked();\n', '    event Unlocked();\n', '\n', '    function EbyteDistribution(address _tokenAddress, address _owner) {\n', '        ebyteToken = Token(_tokenAddress);\n', '        owner = _owner;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '        owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function setParameters(uint256 _Rate, uint256 _Percentage, uint256 _EthBalance, \n', '    uint256 _EbyteBalance) onlyOwner public {\n', '        rate = _Rate;\n', '        percentage = _Percentage;\n', '        ethBalance = _EthBalance;\n', '        ebyteBalance = _EbyteBalance;\n', '    }\n', '    \n', '    modifier onlyWhitelist() {\n', '        require(blacklist[msg.sender] == false);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    modifier isUnlocked() {\n', '        require(!contractLocked);\n', '        _;\n', '    }\n', '    \n', '    function enableWhitelist(address[] addresses) onlyOwner {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            blacklist[addresses[i]] = false;\n', '        }\n', '    }\n', '\n', '    function disableWhitelist(address[] addresses) onlyOwner {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            blacklist[addresses[i]] = true;\n', '        }\n', '    }\n', '    \n', '    function lockContract() onlyOwner public returns (bool) {\n', '        contractLocked = true;\n', '        Locked();\n', '        return true;\n', '    }\n', '    \n', '    function unlockContract() onlyOwner public returns (bool) {\n', '        contractLocked = false;\n', '        Unlocked();\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _holder) constant returns (uint256 balance) {\n', '        return balances[_holder];\n', '    }\n', '    \n', '    function getTokenBalance(address who) constant public returns (uint){\n', '        uint bal = ebyteToken.balanceOf(who);\n', '        return bal;\n', '    }\n', '    \n', '    function getEthBalance(address _addr) constant public returns(uint) {\n', '        return _addr.balance;\n', '    }\n', '    \n', '    function distributeEbyte(address[] addresses, uint256 value) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            sendTokens(addresses[i], value);\n', '            ebyteToken.transfer(addresses[i], value);\n', '        }\n', '    }\n', '\n', '    function distributeEbyteForETH(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if (getEthBalance(addresses[i]) < ethBalance) {\n', '                continue;\n', '            }\n', '            uint256 ethMulti = getEthBalance(addresses[i]) / 1000000000000000000;\n', '            uint256 toDistr = rate * ethMulti;\n', '            sendTokens(addresses[i], toDistr);\n', '            ebyteToken.transfer(addresses[i], toDistr);\n', '        }\n', '    }\n', '    \n', '    function distributeEbyteForEBYTE(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if (getTokenBalance(addresses[i]) < ebyteBalance) {\n', '                continue;\n', '            }\n', '            uint256 toDistr = (getTokenBalance(addresses[i]) / 100) * percentage;\n', '            sendTokens(addresses[i], toDistr);\n', '            ebyteToken.transfer(addresses[i], toDistr);\n', '        }\n', '    }\n', '    \n', '    function distribution(address[] addresses) onlyOwner public {\n', '\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            distributeEbyteForEBYTE(addresses);\n', '            distributeEbyteForETH(addresses);\n', '            break;\n', '        }\n', '    }\n', '  \n', '    function () payable onlyWhitelist isUnlocked public {\n', '        address investor = msg.sender;\n', '        uint256 toGiveT = (getTokenBalance(investor) / 100) * percentage;\n', '        uint256 ethMulti = getEthBalance(investor) / 1000000000;\n', '        uint256 toGiveE = (rate * ethMulti) / 1000000000;\n', '        sendTokens(investor, toGiveT);\n', '        ebyteToken.transfer(investor, toGiveT);\n', '        sendTokens(investor, toGiveE);\n', '        ebyteToken.transfer(investor, toGiveE);\n', '        blacklist[investor] = true;\n', '    }\n', '    \n', '    function tokensAvailable() constant returns (uint256) {\n', '        return ebyteToken.balanceOf(this);\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        uint256 etherBalance = this.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    \n', '    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n', '        ForeignToken token = ForeignToken(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(owner, amount);\n', '    }\n', '\n', '}']