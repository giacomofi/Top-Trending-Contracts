['//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev A standard interface for tokens.\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20 {\n', '  \n', '    /// @dev Returns the total token supply.\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @dev Returns the account balance of another account with address _owner.\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @dev Transfers _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Transfers _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Allows _spender to withdraw from your account multiple times, up to the _value amount\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '//File: node_modules/giveth-common-contracts/contracts/Owned.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '/// @title Owned\n', '/// @author Adrià Massanet <adria@codecontext.io>\n', '/// @notice The Owned contract has an owner address, and provides basic \n', '///  authorization control functions, this simplifies & the implementation of\n', '///  "user permissions"\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed by, address indexed to);\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event OwnershipRemoved();\n', '\n', '    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner.\n', '    function changeOwnership(address _newOwner) onlyOwner {\n', '        require(_newOwner != 0x0);\n', '\n', '        address oldOwner = owner;\n', '        owner = _newOwner;\n', '        newOwnerCandidate = 0x0;\n', '\n', '        OwnershipTransferred(oldOwner, owner);\n', '    }\n', '\n', '    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\n', '    ///  new owner\n', '    /// @param _newOwnerCandidate The address being proposed as the new owner\n', '    function proposeOwnership(address _newOwnerCandidate) onlyOwner {\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\n', '    ///  transfer of ownership\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwnerCandidate);\n', '\n', '        address oldOwner = owner;\n', '        owner = newOwnerCandidate;\n', '        newOwnerCandidate = 0x0;\n', '\n', '        OwnershipTransferred(oldOwner, owner);\n', '    }\n', '\n', '    /// @notice Decentralizes the contract, this operation cannot be undone \n', '    /// @param _dac `0xdac` has to be entered for this function to work\n', '    function removeOwnership(address _dac) onlyOwner {\n', '        require(_dac == 0xdac);\n', '        owner = 0x0;\n', '        newOwnerCandidate = 0x0;\n', '        OwnershipRemoved();     \n', '    }\n', '\n', '} \n', '\n', '//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\n', '/*\n', '    Copyright 2016, Jordi Baylina\n', '    Contributor: Adrià Massanet <adria@codecontext.io>\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '\n', '\n', '\n', '/// @dev `Escapable` is a base level contract built off of the `Owned`\n', '///  contract that creates an escape hatch function to send its ether to\n', '///  `escapeHatchDestination` when called by the `escapeHatchCaller` in the case that\n', '///  something unexpected happens\n', 'contract Escapable is Owned {\n', '    address public escapeHatchCaller;\n', '    address public escapeHatchDestination;\n', '    mapping (address=>bool) private escapeBlacklist;\n', '\n', '    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n', '    ///  `escapeHatchCaller`\n', '    /// @param _escapeHatchDestination The address of a safe location (usu a\n', '    ///  Multisig) to send the ether held in this contract\n', '    /// @param _escapeHatchCaller The address of a trusted account or contract to\n', '    ///  call `escapeHatch()` to send the ether in this contract to the\n', '    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot move\n', '    ///  funds out of `escapeHatchDestination`\n', '    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) {\n', '        escapeHatchCaller = _escapeHatchCaller;\n', '        escapeHatchDestination = _escapeHatchDestination;\n', '    }\n', '\n', '    modifier onlyEscapeHatchCallerOrOwner {\n', '        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    /// @notice The `blacklistEscapeTokens()` marks a token in a whitelist to be\n', '    ///   escaped. The proupose is to be done at construction time.\n', '    /// @param _token the be bloacklisted for escape\n', '    function blacklistEscapeToken(address _token) internal {\n', '        escapeBlacklist[_token] = true;\n', '        EscapeHatchBlackistedToken(_token);\n', '    }\n', '\n', '    function isTokenEscapable(address _token) constant public returns (bool) {\n', '        return !escapeBlacklist[_token];\n', '    }\n', '\n', '    /// @notice The `escapeHatch()` should only be called as a last resort if a\n', '    /// security issue is uncovered or something unexpected happened\n', '    /// @param _token to transfer, use 0x0 for ethers\n', '    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n', '        require(escapeBlacklist[_token]==false);\n', '\n', '        uint256 balance;\n', '\n', '        if (_token == 0x0) {\n', '            balance = this.balance;\n', '            escapeHatchDestination.transfer(balance);\n', '            EscapeHatchCalled(_token, balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        balance = token.balanceOf(this);\n', '        token.transfer(escapeHatchDestination, balance);\n', '        EscapeHatchCalled(_token, balance);\n', '    }\n', '\n', '    /// @notice Changes the address assigned to call `escapeHatch()`\n', '    /// @param _newEscapeHatchCaller The address of a trusted account or contract to\n', '    ///  call `escapeHatch()` to send the ether in this contract to the\n', '    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot\n', '    ///  move funds out of `escapeHatchDestination`\n', '    function changeHatchEscapeCaller(address _newEscapeHatchCaller) onlyEscapeHatchCallerOrOwner {\n', '        escapeHatchCaller = _newEscapeHatchCaller;\n', '    }\n', '\n', '    event EscapeHatchBlackistedToken(address token);\n', '    event EscapeHatchCalled(address token, uint amount);\n', '}\n', '\n', '//File: ./contracts/WithdrawContract.sol\n', 'pragma solidity ^0.4.18;\n', '/*\n', '    Copyright 2017, Jordi Baylina\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '/// @dev This declares a few functions from `MiniMeToken` so that the\n', '///  `WithdrawContract` can interface with the `MiniMeToken`\n', 'contract MiniMeToken {\n', '    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n', '    function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '}\n', '\n', '\n', '\n', '\n', '/// @dev This is the main contract, it is intended to distribute deposited funds\n', '///  from a TRUSTED `owner` to token holders of a MiniMe style ERC-20 Token;\n', '///  only deposits from the `owner` using the functions `newTokenPayment()` &\n', '///  `newEtherPayment()` will be distributed, any other funds sent to this\n', '///  contract can only be removed via the `escapeHatch()`\n', 'contract WithdrawContract is Escapable {\n', '\n', '    /// @dev Tracks the deposits made to this contract\n', '    struct Deposit {\n', '        uint block;    // Determines which token holders are able to collect\n', '        ERC20 token;   // The token address (0x0 if ether)\n', '        uint amount;   // The amount deposited in the smallest unit (wei if ETH)\n', '        bool canceled; // True if canceled by the `owner`\n', '    }\n', '\n', '    Deposit[] public deposits; // Array of deposits to this contract\n', '    MiniMeToken rewardToken;     // Token that is used for withdraws\n', '\n', '    mapping (address => uint) public nextDepositToPayout; // Tracks Payouts\n', '    mapping (address => mapping(uint => bool)) skipDeposits;\n', '\n', '/////////\n', '// Constructor\n', '/////////\n', '\n', '    /// @notice The Constructor creates the `WithdrawContract` on the blockchain\n', '    ///  the `owner` role is assigned to the address that deploys this contract\n', '    /// @param _rewardToken The address of the token that is used to determine the\n', '    ///  distribution of the deposits according to the balance held at the\n', "    ///  deposit's specified `block`\n", '    /// @param _escapeHatchCaller The address of a trusted account or contract\n', '    ///  to call `escapeHatch()` to send the specified token (or ether) held in\n', '    ///  this contract to the `escapeHatchDestination`\n', '    /// @param _escapeHatchDestination The address of a safe location (usu a\n', '    ///  Multisig) to send the ether and tokens held in this contract when the\n', '    ///  `escapeHatch()` is called\n', '    function WithdrawContract(\n', '        MiniMeToken _rewardToken,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination)\n', '        Escapable(_escapeHatchCaller, _escapeHatchDestination)\n', '        public\n', '    {\n', '        rewardToken = _rewardToken;\n', '    }\n', '\n', '    /// @dev When ether is sent to this contract `newEtherDeposit()` is called\n', '    function () payable public {\n', '        newEtherDeposit(0);\n', '    }\n', '/////////\n', '// Owner Functions\n', '/////////\n', '\n', '    /// @notice Adds an ether deposit to `deposits[]`; only the `owner` can\n', '    ///  deposit into this contract\n', '    /// @param _block The block height that determines the snapshot of token\n', '    ///  holders that will be able to withdraw their share of this deposit; this\n', '    ///  block must be set in the past, if 0 it defaults to one block before the\n', '    ///  transaction\n', '    /// @return _idDeposit The id number for the deposit\n', '    function newEtherDeposit(uint _block)\n', '        public onlyOwner payable\n', '        returns (uint _idDeposit)\n', '    {\n', '        require(msg.value>0);\n', '        require(_block < block.number);\n', '        _idDeposit = deposits.length ++;\n', '\n', '        // Record the deposit\n', '        Deposit storage d = deposits[_idDeposit];\n', '        d.block = _block == 0 ? block.number -1 : _block;\n', '        d.token = ERC20(0);\n', '        d.amount = msg.value;\n', '        NewDeposit(_idDeposit, ERC20(0), msg.value);\n', '    }\n', '\n', '    /// @notice Adds a token deposit to `deposits[]`; only the `owner` can\n', '    ///  call this function and it will only work if the account sending the\n', '    ///  tokens has called `approve()` so that this contract can call\n', '    ///  `transferFrom()` and take the tokens\n', '    /// @param _token The address for the ERC20 that is being deposited\n', '    /// @param _amount The quantity of tokens that is deposited into the\n', '    ///  contract in the smallest unit of tokens (if a token has its decimals\n', '    ///  set to 18 and 1 token is sent, the `_amount` would be 10^18)\n', '    /// @param _block The block height that determines the snapshot of token\n', '    ///  holders that will be able to withdraw their share of this deposit; this\n', '    ///  block must be set in the past, if 0 it defaults to one block before the\n', '    ///  transaction\n', '    /// @return _idDeposit The id number for the deposit\n', '    function newTokenDeposit(ERC20 _token, uint _amount, uint _block)\n', '        public onlyOwner\n', '        returns (uint _idDeposit)\n', '    {\n', '        require(_amount > 0);\n', '        require(_block < block.number);\n', '\n', '        // Must `approve()` this contract in a previous transaction\n', '        require( _token.transferFrom(msg.sender, address(this), _amount) );\n', '        _idDeposit = deposits.length ++;\n', '\n', '        // Record the deposit\n', '        Deposit storage d = deposits[_idDeposit];\n', '        d.block = _block == 0 ? block.number -1 : _block;\n', '        d.token = _token;\n', '        d.amount = _amount;\n', '        NewDeposit(_idDeposit, _token, _amount);\n', '    }\n', '\n', '    /// @notice This function is a failsafe function in case a token is\n', "    ///  deposited that has an issue that could prevent it's withdraw loop break\n", '    ///  (e.g. transfers are disabled), can only be called by the `owner`\n', '    /// @param _idDeposit The id number for the deposit being canceled\n', '    function cancelPaymentGlobally(uint _idDeposit) public onlyOwner {\n', '        require(_idDeposit < deposits.length);\n', '        deposits[_idDeposit].canceled = true;\n', '        CancelPaymentGlobally(_idDeposit);\n', '    }\n', '\n', '/////////\n', '// Public Functions\n', '/////////\n', '    /// @notice Sends all the tokens and ether to the token holder by looping\n', '    ///  through all the deposits, determining the appropriate amount by\n', '    ///  dividing the `totalSupply` by the number of tokens the token holder had\n', '    ///  at `deposit.block` for each deposit; this function may have to be\n', '    ///  called multiple times if their are many deposits\n', '    function withdraw() public {\n', '        uint acc = 0; // Accumulates the amount of tokens/ether to be sent\n', '        uint i = nextDepositToPayout[msg.sender]; // Iterates through the deposits\n', '        require(i<deposits.length);\n', '        ERC20 currentToken = deposits[i].token; // Sets the `currentToken` to ether\n', '\n', '        require(msg.gas>149000); // Throws if there is no gas to do at least a single transfer.\n', '        while (( i< deposits.length) && ( msg.gas > 148000)) {\n', '            Deposit storage d = deposits[i];\n', '\n', "            // Make sure `deposit[i]` shouldn't be skipped\n", '            if ((!d.canceled)&&(!isDepositSkiped(msg.sender, i))) {\n', '\n', '                // The current diposti is different of the accumulated until now,\n', '                // so we return the accumulated tokens until now and resset the\n', '                // accumulator.\n', '                if (currentToken != d.token) {\n', '                    nextDepositToPayout[msg.sender] = i;\n', '                    require(doPayment(i-1, msg.sender, currentToken, acc));\n', '                    assert(nextDepositToPayout[msg.sender] == i);\n', '                    currentToken = d.token;\n', '                    acc =0;\n', '                }\n', '\n', '                // Accumulate the amount to send for the `currentToken`\n', '                acc +=  d.amount *\n', '                        rewardToken.balanceOfAt(msg.sender, d.block) /\n', '                            rewardToken.totalSupplyAt(d.block);\n', '            }\n', '\n', '            i++; // Next deposit :-D\n', '        }\n', '        // Return the accumulated tokens.\n', '        nextDepositToPayout[msg.sender] = i;\n', '        require(doPayment(i-1, msg.sender, currentToken, acc));\n', '        assert(nextDepositToPayout[msg.sender] == i);\n', '    }\n', '\n', '    /// @notice This function is a failsafe function in case a token holder\n', '    ///  wants to skip a payment, can only be applied to one deposit at a time\n', '    ///  and only affects the payment for the `msg.sender` calling the function;\n', '    ///  can be undone by calling again with `skip == false`\n', '    /// @param _idDeposit The id number for the deposit being canceled\n', '    /// @param _skip True if the caller wants to skip the payment for `idDeposit`\n', '    function skipPayment(uint _idDeposit, bool _skip) public {\n', '        require(_idDeposit < deposits.length);\n', '        skipDeposits[msg.sender][_idDeposit] = _skip;\n', '        SkipPayment(_idDeposit, _skip);\n', '    }\n', '\n', '/////////\n', '// Constant Functions\n', '/////////\n', '\n', '    /// @notice Calculates the amount of a given token (or ether) the holder can\n', '    ///  receive\n', '    /// @param _token The address of the token being queried, 0x0 = ether\n', '    /// @param _holder The address being checked\n', '    /// @return The amount of `token` able to be collected in the smallest\n', '    ///  unit of the `token` (wei for ether)\n', '    function getPendingReward(ERC20 _token, address _holder) public constant returns(uint) {\n', '        uint acc =0;\n', '        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\n', '            Deposit storage d = deposits[i];\n', '            if ((d.token == _token)&&(!d.canceled) && (!isDepositSkiped(_holder, i))) {\n', '                acc +=  d.amount *\n', '                    rewardToken.balanceOfAt(_holder, d.block) /\n', '                        rewardToken.totalSupplyAt(d.block);\n', '            }\n', '        }\n', '        return acc;\n', '    }\n', '\n', '    /// @notice A check to see if a specific address has anything to collect\n', '    /// @param _holder The address being checked for available deposits\n', '    /// @return True if there are payments to be collected\n', '    function canWithdraw(address _holder) public constant returns (bool) {\n', '        if (nextDepositToPayout[_holder] == deposits.length) return false;\n', '        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\n', '            Deposit storage d = deposits[i];\n', '            if ((!d.canceled) && (!isDepositSkiped(_holder, i))) {\n', '                uint amount =  d.amount *\n', '                    rewardToken.balanceOfAt(_holder, d.block) /\n', '                        rewardToken.totalSupplyAt(d.block);\n', '                if (amount>0) return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice Checks how many deposits have been made\n', '    /// @return The number of deposits\n', '    function nDeposits() public constant returns (uint) {\n', '        return deposits.length;\n', '    }\n', '\n', '    /// @notice Checks to see if a specific deposit has been skipped\n', '    /// @param _holder The address being checked for available deposits\n', '    /// @param _idDeposit The id number for the deposit being canceled\n', '    /// @return True if the specified deposit has been skipped\n', '    function isDepositSkiped(address _holder, uint _idDeposit) public constant returns(bool) {\n', '        return skipDeposits[_holder][_idDeposit];\n', '    }\n', '\n', '/////////\n', '// Internal Functions\n', '/////////\n', '\n', '    /// @notice Transfers `amount` of `token` to `dest`, only used internally,\n', '    ///  and does not throw, will always return `true` or `false`\n', '    /// @param _token The address for the ERC20 that is being transferred\n', '    /// @param _dest The destination address of the transfer\n', '    /// @param _amount The quantity of tokens that is being transferred\n', '    ///  denominated in the smallest unit of tokens (if a token has its decimals\n', '    ///  set to 18 and 1 token is being transferred the `amount` would be 10^18)\n', '    /// @return True if the payment succeeded\n', '    function doPayment(uint _idDeposit,  address _dest, ERC20 _token, uint _amount) internal returns (bool) {\n', '        if (_amount == 0) return true;\n', '        if (address(_token) == 0) {\n', "            if (!_dest.send(_amount)) return false;   // If we can't send, we continue...\n", '        } else {\n', '            if (!_token.transfer(_dest, _amount)) return false;\n', '        }\n', '        Withdraw(_idDeposit, _dest, _token, _amount);\n', '        return true;\n', '    }\n', '\n', '    function getBalance(ERC20 _token, address _holder) internal constant returns (uint) {\n', '        if (address(_token) == 0) {\n', '            return _holder.balance;\n', '        } else {\n', '            return _token.balanceOf(_holder);\n', '        }\n', '    }\n', '\n', '/////////\n', '// Events\n', '/////////\n', '\n', '    event Withdraw(uint indexed lastIdPayment, address indexed holder, ERC20 indexed tokenContract, uint amount);\n', '    event NewDeposit(uint indexed idDeposit, ERC20 indexed tokenContract, uint amount);\n', '    event CancelPaymentGlobally(uint indexed idDeposit);\n', '    event SkipPayment(uint indexed idDeposit, bool skip);\n', '}']