['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/zeppelin-solidity-1.4/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/zeppelin-solidity-1.4/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/BRDLockup.sol\n', '\n', '/**\n', ' * Contract BRDLockup keeps track of a vesting schedule for pre-sold tokens.\n', ' * Pre-sold tokens are rewarded up to `numIntervals` times separated by an\n', ' * `interval` of time. An equal amount of tokens (`allocation` divided by `numIntervals`)\n', ' * is marked for reward each `interval`.\n', ' *\n', ' * The owner of the contract will call processInterval() which will\n', ' * update the allocation state. The owner of the contract should then\n', ' * read the allocation data and reward the beneficiaries.\n', ' */\n', 'contract BRDLockup is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // Allocation stores info about how many tokens to reward a beneficiary account\n', '  struct Allocation {\n', '    address beneficiary;      // account to receive rewards\n', '    uint256 allocation;       // total allocated tokens\n', '    uint256 remainingBalance; // remaining balance after the current interval\n', '    uint256 currentInterval;  // the current interval for the given reward\n', '    uint256 currentReward;    // amount to be rewarded during the current interval\n', '  }\n', '\n', '  // the allocation state\n', '  Allocation[] public allocations;\n', '\n', '  // the date at which allocations begin unlocking\n', '  uint256 public unlockDate;\n', '\n', '  // the current unlock interval\n', '  uint256 public currentInterval;\n', '\n', '  // the interval at which allocations will be rewarded\n', '  uint256 public intervalDuration;\n', '\n', '  // the number of total reward intervals, zero indexed\n', '  uint256 public numIntervals;\n', '\n', '  event Lock(address indexed _to, uint256 _amount);\n', '\n', '  event Unlock(address indexed _to, uint256 _amount);\n', '\n', '  // constructor\n', '  // @param _crowdsaleEndDate - the date the crowdsale ends\n', '  function BRDLockup(uint256 _crowdsaleEndDate, uint256 _numIntervals, uint256 _intervalDuration)  public {\n', '    unlockDate = _crowdsaleEndDate;\n', '    numIntervals = _numIntervals;\n', '    intervalDuration = _intervalDuration;\n', '    currentInterval = 0;\n', '  }\n', '\n', '  // update the allocation storage remaining balances\n', '  function processInterval() onlyOwner public returns (bool _shouldProcessRewards) {\n', '    // ensure the time interval is correct\n', '    bool _correctInterval = now >= unlockDate && now.sub(unlockDate) > currentInterval.mul(intervalDuration);\n', '    bool _validInterval = currentInterval < numIntervals;\n', '    if (!_correctInterval || !_validInterval)\n', '      return false;\n', '\n', '    // advance the current interval\n', '    currentInterval = currentInterval.add(1);\n', '\n', '    // number of iterations to read all allocations\n', '    uint _allocationsIndex = allocations.length;\n', '\n', '    // loop through every allocation\n', '    for (uint _i = 0; _i < _allocationsIndex; _i++) {\n', '      // the current reward for the allocation at index `i`\n', '      uint256 _amountToReward;\n', '\n', '      // if we are at the last interval, the reward amount is the entire remaining balance\n', '      if (currentInterval == numIntervals) {\n', '        _amountToReward = allocations[_i].remainingBalance;\n', '      } else {\n', '        // otherwise the reward amount is the total allocation divided by the number of intervals\n', '        _amountToReward = allocations[_i].allocation.div(numIntervals);\n', '      }\n', '      // update the allocation storage\n', '      allocations[_i].currentReward = _amountToReward;\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  // the total number of allocations\n', '  function numAllocations() constant public returns (uint) {\n', '    return allocations.length;\n', '  }\n', '\n', '  // the amount allocated for beneficiary at `_index`\n', '  function allocationAmount(uint _index) constant public returns (uint256) {\n', '    return allocations[_index].allocation;\n', '  }\n', '\n', '  // reward the beneficiary at `_index`\n', '  function unlock(uint _index) onlyOwner public returns (bool _shouldReward, address _beneficiary, uint256 _rewardAmount) {\n', '    // ensure the beneficiary is not rewarded twice during the same interval\n', '    if (allocations[_index].currentInterval < currentInterval) {\n', '      // record the currentInterval so the above check is useful\n', '      allocations[_index].currentInterval = currentInterval;\n', '      // subtract the reward from their remaining balance\n', '      allocations[_index].remainingBalance = allocations[_index].remainingBalance.sub(allocations[_index].currentReward);\n', '      // emit event\n', '      Unlock(allocations[_index].beneficiary, allocations[_index].currentReward);\n', '      // return value\n', '      _shouldReward = true;\n', '    } else {\n', '      // return value\n', '      _shouldReward = false;\n', '    }\n', '\n', '    // return values\n', '    _rewardAmount = allocations[_index].currentReward;\n', '    _beneficiary = allocations[_index].beneficiary;\n', '  }\n', '\n', '  // add a new allocation to the lockup\n', '  function pushAllocation(address _beneficiary, uint256 _numTokens) onlyOwner public {\n', '    require(now < unlockDate);\n', '    allocations.push(\n', '      Allocation(\n', '        _beneficiary,\n', '        _numTokens,\n', '        _numTokens,\n', '        0,\n', '        0\n', '      )\n', '    );\n', '    Lock(_beneficiary, _numTokens);\n', '  }\n', '}']