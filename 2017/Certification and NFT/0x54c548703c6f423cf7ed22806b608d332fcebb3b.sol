['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract AbstractStarbaseToken {\n', '    function isFundraiser(address fundraiserAddress) public returns (bool);\n', '    function company() public returns (address);\n', '    function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool);\n', '    function allocateToMarketingSupporter(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract AbstractStarbaseCrowdsale {\n', '    function startDate() constant returns (uint256) {}\n', '    function endedAt() constant returns (uint256) {}\n', '    function isEnded() constant returns (bool);\n', '    function totalRaisedAmountInCny() constant returns (uint256);\n', '    function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256);\n', '    function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256);\n', '}\n', '\n', '/// @title EarlyPurchase contract - Keep track of purchased amount by Early Purchasers\n', '/// @author Starbase PTE. LTD. - <info@starbase.co>\n', 'contract StarbaseEarlyPurchase {\n', '    /*\n', '     *  Constants\n', '     */\n', "    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';    // Chinese Yuan\n", "    string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http://www.xe.com/currencytables/';\n", '    uint256 public constant PURCHASE_AMOUNT_CAP = 9000000;\n', '\n', '    /*\n', '     *  Types\n', '     */\n', '    struct EarlyPurchase {\n', '        address purchaser;\n', '        uint256 amount;        // CNY based amount\n', '        uint256 purchasedAt;   // timestamp\n', '    }\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractStarbaseCrowdsale public starbaseCrowdsale;\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    EarlyPurchase[] public earlyPurchases;\n', '    uint256 public earlyPurchaseClosedAt;\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier noEther() {\n', '        require(msg.value == 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBeforeCrowdsale() {\n', '        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEarlyPurchaseTerm() {\n', '        assert(earlyPurchaseClosedAt <= 0);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Contract functions\n', '     */\n', '\n', '    /**\n', "     * @dev Returns early purchased amount by purchaser's address\n", '     * @param purchaser Purchaser address\n', '     */\n', '    function purchasedAmountBy(address purchaser)\n', '        external\n', '        constant\n', '        noEther\n', '        returns (uint256 amount)\n', '    {\n', '        for (uint256 i; i < earlyPurchases.length; i++) {\n', '            if (earlyPurchases[i].purchaser == purchaser) {\n', '                amount += earlyPurchases[i].amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount of raised funds by Early Purchasers\n', '     */\n', '    function totalAmountOfEarlyPurchases()\n', '        constant\n', '        noEther\n', '        public\n', '        returns (uint256 totalAmount)\n', '    {\n', '        for (uint256 i; i < earlyPurchases.length; i++) {\n', '            totalAmount += earlyPurchases[i].amount;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns number of early purchases\n', '     */\n', '    function numberOfEarlyPurchases()\n', '        external\n', '        constant\n', '        noEther\n', '        returns (uint256)\n', '    {\n', '        return earlyPurchases.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Append an early purchase log\n', '     * @param purchaser Purchaser address\n', '     * @param amount Purchase amount\n', '     * @param purchasedAt Timestamp of purchased date\n', '     */\n', '    function appendEarlyPurchase(address purchaser, uint256 amount, uint256 purchasedAt)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        onlyBeforeCrowdsale\n', '        onlyEarlyPurchaseTerm\n', '        returns (bool)\n', '    {\n', '        if (amount == 0 ||\n', '            totalAmountOfEarlyPurchases() + amount > PURCHASE_AMOUNT_CAP)\n', '        {\n', '            return false;\n', '        }\n', '\n', '        assert(purchasedAt != 0 || purchasedAt <= now);\n', '\n', '        earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Close early purchase term\n', '     */\n', '    function closeEarlyPurchase()\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        earlyPurchaseClosedAt = now;\n', '    }\n', '\n', '    /**\n', "     * @dev Setup function sets external contract's address\n", '     * @param starbaseCrowdsaleAddress Token address\n', '     */\n', '    function setup(address starbaseCrowdsaleAddress)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        if (address(starbaseCrowdsale) == 0) {\n', '            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Contract constructor function\n', '     */\n', '    function StarbaseEarlyPurchase() noEther {\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '/// @title EarlyPurchaseAmendment contract - Amend early purchase records of the original contract\n', '/// @author Starbase PTE. LTD. - <support@starbase.co>\n', 'contract StarbaseEarlyPurchaseAmendment {\n', '    /*\n', '     *  Events\n', '     */\n', '    event EarlyPurchaseInvalidated(uint256 epIdx);\n', '    event EarlyPurchaseAmended(uint256 epIdx);\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractStarbaseCrowdsale public starbaseCrowdsale;\n', '    StarbaseEarlyPurchase public starbaseEarlyPurchase;\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    uint256[] public invalidEarlyPurchaseIndexes;\n', '    uint256[] public amendedEarlyPurchaseIndexes;\n', '    mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases;\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier noEther() {\n', '        require(msg.value == 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBeforeCrowdsale() {\n', '        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEarlyPurchasesLoaded() {\n', '        assert(address(starbaseEarlyPurchase) != address(0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Functions below are compatible with starbaseEarlyPurchase contract\n', '     */\n', '\n', '    /**\n', '     * @dev Returns an early purchase record\n', '     * @param earlyPurchaseIndex Index number of an early purchase\n', '     */\n', '    function earlyPurchases(uint256 earlyPurchaseIndex)\n', '        external\n', '        constant\n', '        onlyEarlyPurchasesLoaded\n', '        returns (address purchaser, uint256 amount, uint256 purchasedAt)\n', '    {\n', '        return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);\n', '    }\n', '\n', '    /**\n', "     * @dev Returns early purchased amount by purchaser's address\n", '     * @param purchaser Purchaser address\n', '     */\n', '    function purchasedAmountBy(address purchaser)\n', '        external\n', '        constant\n', '        noEther\n', '        returns (uint256 amount)\n', '    {\n', '        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =\n', '            normalizedEarlyPurchases();\n', '        for (uint256 i; i < normalizedEP.length; i++) {\n', '            if (normalizedEP[i].purchaser == purchaser) {\n', '                amount += normalizedEP[i].amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount of raised funds by Early Purchasers\n', '     */\n', '    function totalAmountOfEarlyPurchases()\n', '        constant\n', '        noEther\n', '        public\n', '        returns (uint256 totalAmount)\n', '    {\n', '        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =\n', '            normalizedEarlyPurchases();\n', '        for (uint256 i; i < normalizedEP.length; i++) {\n', '            totalAmount += normalizedEP[i].amount;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns number of early purchases\n', '     */\n', '    function numberOfEarlyPurchases()\n', '        external\n', '        constant\n', '        noEther\n', '        returns (uint256)\n', '    {\n', '        return normalizedEarlyPurchases().length;\n', '    }\n', '\n', '    /**\n', "     * @dev Sets up function sets external contract's address\n", '     * @param starbaseCrowdsaleAddress Token address\n', '     */\n', '    function setup(address starbaseCrowdsaleAddress)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        if (address(starbaseCrowdsale) == 0) {\n', '            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /*\n', '     *  Contract functions unique to StarbaseEarlyPurchaseAmendment\n', '     */\n', '\n', '     /**\n', '      * @dev Invalidate early purchase\n', '      * @param earlyPurchaseIndex Index number of the purchase\n', '      */\n', '    function invalidateEarlyPurchase(uint256 earlyPurchaseIndex)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        onlyEarlyPurchasesLoaded\n', '        onlyBeforeCrowdsale\n', '        returns (bool)\n', '    {\n', '        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\n', '\n', '        for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) {\n', '            assert(invalidEarlyPurchaseIndexes[i] != earlyPurchaseIndex);\n', '        }\n', '\n', '        invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex);\n', '        EarlyPurchaseInvalidated(earlyPurchaseIndex);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether early purchase is invalid\n', '     * @param earlyPurchaseIndex Index number of the purchase\n', '     */\n', '    function isInvalidEarlyPurchase(uint256 earlyPurchaseIndex)\n', '        constant\n', '        noEther\n', '        public\n', '        returns (bool)\n', '    {\n', '        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\n', '\n', '\n', '        for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) {\n', '            if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Amends a given early purchase with data\n', '     * @param earlyPurchaseIndex Index number of the purchase\n', "     * @param purchaser Purchaser's address\n", '     * @param amount Value of purchase\n', '     * @param purchasedAt Purchase timestamp\n', '     */\n', '    function amendEarlyPurchase(uint256 earlyPurchaseIndex, address purchaser, uint256 amount, uint256 purchasedAt)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        onlyEarlyPurchasesLoaded\n', '        onlyBeforeCrowdsale\n', '        returns (bool)\n', '    {\n', '        assert(purchasedAt != 0 || purchasedAt <= now);\n', '\n', '        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex);\n', '\n', '        assert(!isInvalidEarlyPurchase(earlyPurchaseIndex)); // Invalid early purchase cannot be amended\n', '\n', '        if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) {\n', '            amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex);\n', '        }\n', '\n', '        amendedEarlyPurchases[earlyPurchaseIndex] =\n', '            StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);\n', '        EarlyPurchaseAmended(earlyPurchaseIndex);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether early purchase is amended\n', '     * @param earlyPurchaseIndex Index number of the purchase\n', '     */\n', '    function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex)\n', '        constant\n', '        noEther\n', '        returns (bool)\n', '    {\n', '        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\n', '\n', '        for (uint256 i; i < amendedEarlyPurchaseIndexes.length; i++) {\n', '            if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Loads early purchases data to StarbaseEarlyPurchaseAmendment contract\n', '     * @param starbaseEarlyPurchaseAddress Address from starbase early purchase\n', '     */\n', '    function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress)\n', '        external\n', '        noEther\n', '        onlyOwner\n', '        onlyBeforeCrowdsale\n', '        returns (bool)\n', '    {\n', '        assert(starbaseEarlyPurchaseAddress != 0 ||\n', '            address(starbaseEarlyPurchase) == 0);\n', '\n', '        starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress);\n', '        assert(starbaseEarlyPurchase.earlyPurchaseClosedAt() != 0); // the early purchase must be closed\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Contract constructor function. It sets owner\n', '     */\n', '    function StarbaseEarlyPurchaseAmendment() noEther {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Internal functions\n', '     */\n', '\n', '    /**\n', '     * @dev Normalizes early purchases data\n', '     */\n', '    function normalizedEarlyPurchases()\n', '        constant\n', '        internal\n', '        returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP)\n', '    {\n', '        uint256 rawEPCount = numberOfRawEarlyPurchases();\n', '        normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[](\n', '            rawEPCount - invalidEarlyPurchaseIndexes.length);\n', '\n', '        uint256 normalizedIdx;\n', '        for (uint256 i; i < rawEPCount; i++) {\n', '            if (isInvalidEarlyPurchase(i)) {\n', '                continue;   // invalid early purchase should be ignored\n', '            }\n', '\n', '            StarbaseEarlyPurchase.EarlyPurchase memory ep;\n', '            if (isAmendedEarlyPurchase(i)) {\n', '                ep = amendedEarlyPurchases[i];  // amended early purchase should take a priority\n', '            } else {\n', '                ep = getEarlyPurchase(i);\n', '            }\n', '\n', '            normalizedEP[normalizedIdx] = ep;\n', '            normalizedIdx++;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches early purchases data\n', '     */\n', '    function getEarlyPurchase(uint256 earlyPurchaseIndex)\n', '        internal\n', '        constant\n', '        onlyEarlyPurchasesLoaded\n', '        returns (StarbaseEarlyPurchase.EarlyPurchase)\n', '    {\n', '        var (purchaser, amount, purchasedAt) =\n', '            starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);\n', '        return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns raw number of early purchases\n', '     */\n', '    function numberOfRawEarlyPurchases()\n', '        internal\n', '        constant\n', '        onlyEarlyPurchasesLoaded\n', '        returns (uint256)\n', '    {\n', '        return starbaseEarlyPurchase.numberOfEarlyPurchases();\n', '    }\n', '}\n', '\n', '\n', 'contract Certifier {\n', '\tevent Confirmed(address indexed who);\n', '\tevent Revoked(address indexed who);\n', '\tfunction certified(address) public constant returns (bool);\n', '\tfunction get(address, string) public constant returns (bytes32);\n', '\tfunction getAddress(address, string) public constant returns (address);\n', '\tfunction getUint(address, string) public constant returns (uint);\n', '}\n', '\n', '/**\n', ' * @title Crowdsale contract - Starbase crowdsale to create STAR.\n', ' * @author Starbase PTE. LTD. - <info@starbase.co>\n', ' */\n', 'contract StarbaseCrowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '    /*\n', '     *  Events\n', '     */\n', '    event CrowdsaleEnded(uint256 endedAt);\n', '    event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate);\n', '    event CnyEthRateUpdated(uint256 cnyEthRate);\n', '    event CnyBtcRateUpdated(uint256 cnyBtcRate);\n', '    event QualifiedPartnerAddress(address qualifiedPartner);\n', '\n', '    /**\n', '     *  External contracts\n', '     */\n', '    AbstractStarbaseToken public starbaseToken;\n', '    StarbaseEarlyPurchaseAmendment public starbaseEpAmendment;\n', '    Certifier public picopsCertifier;\n', '\n', '    /**\n', '     *  Constants\n', '     */\n', '    uint256 constant public crowdsaleTokenAmount = 125000000e18;\n', '    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;\n', '    uint256 constant public MIN_INVESTMENT = 1; // min is 1 Wei\n', '    uint256 constant public MAX_CAP = 67000000; // in CNY. approximately 10M USD. (includes raised amount from both EP and CS)\n', "    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';  // Chinese Yuan\n", '\n', '    /**\n', '     * Types\n', '     */\n', '    struct CrowdsalePurchase {\n', '        address purchaser;\n', '        uint256 amount;        // CNY based amount with bonus\n', '        uint256 rawAmount;     // CNY based amount no bonus\n', '        uint256 purchasedAt;   // timestamp\n', '    }\n', '\n', '    struct QualifiedPartners {\n', '        uint256 amountCap;\n', '        uint256 amountRaised;\n', '        bool    bonaFide;\n', '        uint256 commissionFeePercentage; // example 5 will calculate the percentage as 5%\n', '    }\n', '\n', '    /*\n', '     *  Enums\n', '     */\n', '    enum BonusMilestones {\n', '        First,\n', '        Second,\n', '        Third,\n', '        Fourth,\n', '        Fifth\n', '    }\n', '\n', '    // Initialize bonusMilestones\n', '    BonusMilestones public bonusMilestones = BonusMilestones.First;\n', '\n', '    /**\n', '     *  Storage\n', '     */\n', '    uint public numOfDeliveredCrowdsalePurchases;  // index to keep the number of crowdsale purchases have already been processed by `withdrawPurchasedTokens`\n', '    uint public numOfDeliveredEarlyPurchases;  // index to keep the number of early purchases have already been processed by `withdrawPurchasedTokens`\n', '    uint256 public numOfLoadedEarlyPurchases; // index to keep the number of early purchases that have already been loaded by `loadEarlyPurchases`\n', '\n', '    // early purchase\n', '    address[] public earlyPurchasers;\n', "    mapping (address => uint256) public earlyPurchasedAmountBy; // early purchased amount in CNY per purchasers' address\n", '    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract\n', '    uint256 public totalAmountOfEarlyPurchases; // including 20% bonus\n', '\n', '    // crowdsale\n', '    bool public presalePurchasesLoaded = false; // returns whether all presale purchases are loaded into this contract\n', '    uint256 public maxCrowdsaleCap;     // = 67M CNY - (total raised amount from EP)\n', '    uint256 public totalAmountOfCrowdsalePurchases; // in CNY, including bonuses\n', '    uint256 public totalAmountOfCrowdsalePurchasesWithoutBonus; // in CNY\n', '    mapping (address => QualifiedPartners) public qualifiedPartners;\n', '    uint256 public purchaseStartBlock;  // crowdsale purchases can be accepted from this block number\n', '    uint256 public startDate;\n', '    uint256 public endedAt;\n', '    CrowdsalePurchase[] public crowdsalePurchases;\n', "    mapping (address => uint256) public crowdsalePurchaseAmountBy; // crowdsale purchase amount in CNY per purchasers' address\n", "    uint256 public cnyBtcRate; // this rate won't be used from a smart contract function but external system\n", '    uint256 public cnyEthRate;\n', '\n', '    // bonus milestones\n', '    uint256 public firstBonusEnds;\n', '    uint256 public secondBonusEnds;\n', '    uint256 public thirdBonusEnds;\n', '    uint256 public fourthBonusEnds;\n', '\n', '    // after the crowdsale\n', '    mapping (address => uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser\n', '    mapping (address => uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser\n', '\n', '    /**\n', '     *  Modifiers\n', '     */\n', '    modifier minInvestment() {\n', '        // User has to send at least the ether value of one token.\n', '        assert(msg.value >= MIN_INVESTMENT);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotStarted() {\n', '        assert(startDate == 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenEnded() {\n', '        assert(isEnded());\n', '        _;\n', '    }\n', '\n', '    modifier hasBalance() {\n', '        assert(this.balance > 0);\n', '        _;\n', '    }\n', '    modifier rateIsSet(uint256 _rate) {\n', '        assert(_rate != 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotEnded() {\n', '        assert(!isEnded());\n', '        _;\n', '    }\n', '\n', '    modifier tokensNotDelivered() {\n', '        assert(numOfDeliveredCrowdsalePurchases == 0);\n', '        assert(numOfDeliveredEarlyPurchases == 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFundraiser() {\n', '        assert(address(starbaseToken) != 0);\n', '        assert(starbaseToken.isFundraiser(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyQualifiedPartner() {\n', '        assert(qualifiedPartners[msg.sender].bonaFide);\n', '        _;\n', '    }\n', '\n', '    modifier onlyQualifiedPartnerORPicopsCertified() {\n', '        assert(qualifiedPartners[msg.sender].bonaFide || picopsCertifier.certified(msg.sender));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Contract functions\n', '     */\n', '    /**\n', '     * @dev Contract constructor function sets owner address and\n', '     *      address of StarbaseEarlyPurchaseAmendment contract.\n', '     * @param starbaseEpAddr The address that holds the early purchasers Star tokens\n', '     * @param picopsCertifierAddr The address of the PICOPS certifier.\n', '     *                            See also https://picops.parity.io/#/details\n', '     */\n', '    function StarbaseCrowdsale(address starbaseEpAddr, address picopsCertifierAddr) {\n', '        require(starbaseEpAddr != 0 && picopsCertifierAddr != 0);\n', '        owner = msg.sender;\n', '        starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr);\n', '        picopsCertifier = Certifier(picopsCertifierAddr);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback accepts payment for Star tokens with Eth\n', '     */\n', '    function() payable {\n', '        redirectToPurchase();\n', '    }\n', '\n', '    /**\n', '     * External functions\n', '     */\n', '\n', '    /**\n', "     * @dev Setup function sets external contracts' addresses and set the max crowdsale cap\n", '     * @param starbaseTokenAddress Token address.\n', '     * @param _purchaseStartBlock Block number to start crowdsale\n', '     */\n', '    function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock)\n', '        external\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(starbaseTokenAddress != address(0));\n', '        require(address(starbaseToken) == 0);\n', '        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);\n', '        purchaseStartBlock = _purchaseStartBlock;\n', '\n', '        // set the max cap of this crowdsale\n', '        maxCrowdsaleCap = MAX_CAP.sub(totalAmountOfEarlyPurchasesWithoutBonus());\n', '\n', '        assert(maxCrowdsaleCap > 0);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev Transfers raised funds to company's wallet address at any given time.\n", '     */\n', '    function withdrawForCompany()\n', '        external\n', '        onlyFundraiser\n', '        hasBalance\n', '    {\n', '        address company = starbaseToken.company();\n', '        require(company != address(0));\n', '        company.transfer(this.balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Update start block Number for the crowdsale\n', '     */\n', '    function updatePurchaseStartBlock(uint256 _purchaseStartBlock)\n', '        external\n', '        whenNotStarted\n', '        onlyFundraiser\n', '        returns (bool)\n', '    {\n', '        purchaseStartBlock = _purchaseStartBlock;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the CNY/ETH rate to record purchases in CNY\n', '     */\n', '    function updateCnyEthRate(uint256 rate)\n', '        external\n', '        onlyFundraiser\n', '        returns (bool)\n', '    {\n', '        cnyEthRate = rate;\n', '        CnyEthRateUpdated(cnyEthRate);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the CNY/BTC rate to record purchases in CNY\n', '     */\n', '    function updateCnyBtcRate(uint256 rate)\n', '        external\n', '        onlyFundraiser\n', '        returns (bool)\n', '    {\n', '        cnyBtcRate = rate;\n', '        CnyBtcRateUpdated(cnyBtcRate);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow for the possibility for contract owner to start crowdsale\n', '     */\n', '    function ownerStartsCrowdsale(uint256 timestamp)\n', '        external\n', '        whenNotStarted\n', '        onlyOwner\n', '    {\n', '        assert(block.number >= purchaseStartBlock);   // this should be after the crowdsale start block\n', '        startCrowdsale(timestamp);\n', '    }\n', '\n', '    /**\n', '     * @dev Ends crowdsale\n', '     *      This may be executed by an owner if the raised funds did not reach the map cap\n', '     * @param timestamp Timestamp at the crowdsale ended\n', '     */\n', '    function endCrowdsale(uint256 timestamp)\n', '        external\n', '        onlyOwner\n', '    {\n', '        assert(timestamp > 0 && timestamp <= now);\n', '        assert(block.number >= purchaseStartBlock && endedAt == 0);   // cannot end before it starts and overwriting time is not permitted\n', '        endedAt = timestamp;\n', '        CrowdsaleEnded(endedAt);\n', '    }\n', '\n', '    /**\n', '     * @dev Ends crowdsale\n', '     *      This may be executed by purchaseWithEth when the raised funds reach the map cap\n', '     */\n', '    function endCrowdsale() internal {\n', '        assert(block.number >= purchaseStartBlock && endedAt == 0);\n', '        endedAt = now;\n', '        CrowdsaleEnded(endedAt);\n', '    }\n', '\n', '    /**\n', '     * @dev Deliver tokens to purchasers according to their purchase amount in CNY\n', '     */\n', '    function withdrawPurchasedTokens()\n', '        external\n', '        whenEnded\n', '        returns (bool)\n', '    {\n', '        assert(earlyPurchasesLoaded);\n', '        assert(address(starbaseToken) != 0);\n', '\n', '        /*\n', '         * “Value” refers to the contribution of the User:\n', '         *  {crowdsale_purchaser_token_amount} =\n', '         *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.\n', '         *\n', '         * Example: If a User contributes during the Contribution Period 100 CNY (including applicable\n', '         * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY\n', '         * and total amount raised during the Contribution Period is 30’000’000, then he will get\n', '         * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.\n', '        */\n', '\n', '        if (crowdsalePurchaseAmountBy[msg.sender] > 0) {\n', '            uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender];\n', '            crowdsalePurchaseAmountBy[msg.sender] = 0;\n', '\n', '            uint256 tokenCount =\n', '                SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) /\n', '                totalRaisedAmountInCny();\n', '\n', '            numOfPurchasedTokensOnCsBy[msg.sender] =\n', '                SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount);\n', '            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount));\n', '            numOfDeliveredCrowdsalePurchases++;\n', '        }\n', '\n', '        /*\n', '         * “Value” refers to the contribution of the User:\n', '         * {earlypurchaser_token_amount} =\n', '         * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})\n', '         *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).\n', '         *\n', '         * Example: If an Early Purchaser contributes 100 CNY (including Bonus of 20%) and the\n', '         * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised\n', '         * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =\n', '         * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /\n', '         * 30’000’000 CNY + 6’000’000 CNY\n', '         */\n', '\n', '        if (earlyPurchasedAmountBy[msg.sender] > 0) {  // skip if is not an early purchaser\n', '            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender];\n', '            earlyPurchasedAmountBy[msg.sender] = 0;\n', '\n', '            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases;\n', '\n', '            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny();\n', '\n', '            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);\n', '\n', '            numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount);\n', '            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount));\n', '            numOfDeliveredEarlyPurchases++;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Load early purchases from the contract keeps track of them\n', '     */\n', '    function loadEarlyPurchases() external onlyOwner returns (bool) {\n', '        if (earlyPurchasesLoaded) {\n', '            return false;    // all EPs have already been loaded\n', '        }\n', '\n', '        uint256 numOfOrigEp = starbaseEpAmendment\n', '            .starbaseEarlyPurchase()\n', '            .numberOfEarlyPurchases();\n', '\n', '        for (uint256 i = numOfLoadedEarlyPurchases; i < numOfOrigEp && msg.gas > 200000; i++) {\n', '            if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) {\n', '                numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);\n', '                continue;\n', '            }\n', '            var (purchaser, amount,) =\n', '                starbaseEpAmendment.isAmendedEarlyPurchase(i)\n', '                ? starbaseEpAmendment.amendedEarlyPurchases(i)\n', '                : starbaseEpAmendment.earlyPurchases(i);\n', '            if (amount > 0) {\n', '                if (earlyPurchasedAmountBy[purchaser] == 0) {\n', '                    earlyPurchasers.push(purchaser);\n', '                }\n', '                // each early purchaser receives 20% bonus\n', '                uint256 bonus = SafeMath.mul(amount, 20) / 100;\n', '                uint256 amountWithBonus = SafeMath.add(amount, bonus);\n', '\n', '                earlyPurchasedAmountBy[purchaser] = SafeMath.add(earlyPurchasedAmountBy[purchaser], amountWithBonus);\n', '                totalAmountOfEarlyPurchases = totalAmountOfEarlyPurchases.add(amountWithBonus);\n', '            }\n', '\n', '            numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);\n', '        }\n', '\n', '        assert(numOfLoadedEarlyPurchases <= numOfOrigEp);\n', '        if (numOfLoadedEarlyPurchases == numOfOrigEp) {\n', '            earlyPurchasesLoaded = true;    // enable the flag\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Load presale purchases from the contract keeps track of them\n', '     * @param starbaseCrowdsalePresale Starbase presale contract address\n', '     */\n', '    function loadPresalePurchases(address starbaseCrowdsalePresale)\n', '        external\n', '        onlyOwner\n', '        whenNotEnded\n', '    {\n', '        require(starbaseCrowdsalePresale != 0);\n', '        require(!presalePurchasesLoaded);\n', '        StarbaseCrowdsale presale = StarbaseCrowdsale(starbaseCrowdsalePresale);\n', '        for (uint i; i < presale.numOfPurchases(); i++) {\n', '            var (purchaser, amount, rawAmount, purchasedAt) =\n', '                presale.crowdsalePurchases(i);  // presale purchase\n', '            crowdsalePurchases.push(CrowdsalePurchase(purchaser, amount, rawAmount, purchasedAt));\n', '\n', '            // Increase the sums\n', '            crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);\n', '            totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);\n', '            totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);\n', '        }\n', '        presalePurchasesLoaded = true;\n', '    }\n', '\n', '    /**\n', '      * @dev Set qualified crowdsale partner i.e. Bitcoin Suisse address\n', '      * @param _qualifiedPartner Address of the qualified partner that can purchase during crowdsale\n', '      * @param _amountCap Ether value which partner is able to contribute\n', '      * @param _commissionFeePercentage Integer that represents the fee to pay qualified partner 5 is 5%\n', '      */\n', '    function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage)\n', '        external\n', '        onlyOwner\n', '    {\n', '        assert(!qualifiedPartners[_qualifiedPartner].bonaFide);\n', '        qualifiedPartners[_qualifiedPartner].bonaFide = true;\n', '        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;\n', '        qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage;\n', '        QualifiedPartnerAddress(_qualifiedPartner);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove address from qualified partners list.\n', '     * @param _qualifiedPartner Address to be removed from the list.\n', '     */\n', '    function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner {\n', '        assert(qualifiedPartners[_qualifiedPartner].bonaFide);\n', '        qualifiedPartners[_qualifiedPartner].bonaFide = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Update whitelisted address amount allowed to raise during the presale.\n', '     * @param _qualifiedPartner Qualified Partner address to be updated.\n', '     * @param _amountCap Amount that the address is able to raise during the presale.\n', '     */\n', '    function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner {\n', '        assert(qualifiedPartners[_qualifiedPartner].bonaFide);\n', '        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;\n', '    }\n', '\n', '    /**\n', '     * Public functions\n', '     */\n', '\n', '    /**\n', '     * @dev Returns boolean for whether crowdsale has ended\n', '     */\n', '    function isEnded() constant public returns (bool) {\n', '        return (endedAt > 0 && endedAt <= now);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns number of purchases to date.\n', '     */\n', '    function numOfPurchases() constant public returns (uint256) {\n', '        return crowdsalePurchases.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total raised amount in CNY (includes EP) and bonuses\n', '     */\n', '    function totalRaisedAmountInCny() constant public returns (uint256) {\n', '        return totalAmountOfEarlyPurchases.add(totalAmountOfCrowdsalePurchases);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount of early purchases in CNY and bonuses\n', '     */\n', '    function totalAmountOfEarlyPurchasesWithBonus() constant public returns(uint256) {\n', '       return starbaseEpAmendment.totalAmountOfEarlyPurchases().mul(120).div(100);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount of early purchases in CNY\n', '     */\n', '    function totalAmountOfEarlyPurchasesWithoutBonus() constant public returns(uint256) {\n', '       return starbaseEpAmendment.totalAmountOfEarlyPurchases();\n', '    }\n', '\n', '    /**\n', '     * @dev Allows qualified crowdsale partner to purchase Star Tokens\n', '     */\n', '    function purchaseAsQualifiedPartner()\n', '        payable\n', '        public\n', '        rateIsSet(cnyEthRate)\n', '        onlyQualifiedPartner\n', '        returns (bool)\n', '    {\n', '        require(msg.value > 0);\n', '        qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised);\n', '\n', '        assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap);\n', '\n', '        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;\n', '        recordPurchase(msg.sender, rawAmount, now);\n', '\n', '        if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) {\n', '            sendQualifiedPartnerCommissionFee(msg.sender, msg.value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows user to purchase STAR tokens with Ether\n', '     */\n', '    function purchaseWithEth()\n', '        payable\n', '        public\n', '        minInvestment\n', '        whenNotEnded\n', '        rateIsSet(cnyEthRate)\n', '        onlyQualifiedPartnerORPicopsCertified\n', '        returns (bool)\n', '    {\n', '        require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock);\n', '\n', '        if (startDate == 0) {\n', '            startCrowdsale(block.timestamp);\n', '        }\n', '\n', '        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;\n', '        recordPurchase(msg.sender, rawAmount, now);\n', '\n', '        if (totalAmountOfCrowdsalePurchasesWithoutBonus >= maxCrowdsaleCap) {\n', '            endCrowdsale(); // ends this crowdsale automatically\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Internal functions\n', '     */\n', '\n', '    /**\n', '     * @dev Initializes Starbase crowdsale\n', '     */\n', '    function startCrowdsale(uint256 timestamp) internal {\n', '        startDate = timestamp;\n', '        uint256 presaleAmount = totalAmountOfCrowdsalePurchasesWithoutBonus;\n', '        if (maxCrowdsaleCap > presaleAmount) {\n', '            uint256 mainSaleCap = maxCrowdsaleCap.sub(presaleAmount);\n', '            uint256 twentyPercentOfCrowdsalePurchase = mainSaleCap.mul(20).div(100);\n', '\n', '            // set token bonus milestones in cny total crowdsale purchase\n', '            firstBonusEnds =  twentyPercentOfCrowdsalePurchase;\n', '            secondBonusEnds = firstBonusEnds.add(twentyPercentOfCrowdsalePurchase);\n', '            thirdBonusEnds =  secondBonusEnds.add(twentyPercentOfCrowdsalePurchase);\n', '            fourthBonusEnds = thirdBonusEnds.add(twentyPercentOfCrowdsalePurchase);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Abstract record of a purchase to Tokens\n', '     * @param purchaser Address of the buyer\n', '     * @param rawAmount Amount in CNY as per the CNY/ETH rate used\n', '     * @param timestamp Timestamp at the purchase made\n', '     */\n', '    function recordPurchase(\n', '        address purchaser,\n', '        uint256 rawAmount,\n', '        uint256 timestamp\n', '    )\n', '        internal\n', '        returns(uint256 amount)\n', '    {\n', '        amount = rawAmount; // amount to check reach of max cap. it does not care for bonus tokens here\n', '\n', '        // presale transfers which occurs before the crowdsale ignores the crowdsale hard cap\n', '        if (block.number >= purchaseStartBlock) {\n', '            require(totalAmountOfCrowdsalePurchasesWithoutBonus < maxCrowdsaleCap);   // check if the amount has already reached the cap\n', '\n', '            uint256 crowdsaleTotalAmountAfterPurchase =\n', '                SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus, amount);\n', '\n', '            // check whether purchase goes over the cap and send the difference back to the purchaser.\n', '            if (crowdsaleTotalAmountAfterPurchase > maxCrowdsaleCap) {\n', '              uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, maxCrowdsaleCap);\n', '              uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate;\n', '              purchaser.transfer(ethValueToReturn);\n', '              amount = SafeMath.sub(amount, difference);\n', '              rawAmount = amount;\n', '            }\n', '        }\n', '\n', '        amount = getBonusAmountCalculation(amount); // at this point amount bonus is calculated\n', '\n', '        CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp);\n', '        crowdsalePurchases.push(purchase);\n', '        StarbasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate);\n', '        crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);\n', '        totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);\n', '        totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);\n', '        return amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates amount with bonus for bonus milestones\n', '     */\n', '    function calculateBonus\n', '        (\n', '            BonusMilestones nextMilestone,\n', '            uint256 amount,\n', '            uint256 bonusRange,\n', '            uint256 bonusTier,\n', '            uint256 results\n', '        )\n', '        internal\n', '        returns (uint256 result, uint256 newAmount)\n', '    {\n', '        uint256 bonusCalc;\n', '\n', '        if (amount <= bonusRange) {\n', '            bonusCalc = amount.mul(bonusTier).div(100);\n', '\n', '            if (amount.add(totalAmountOfCrowdsalePurchasesWithoutBonus) >= bonusRange)\n', '                bonusMilestones = nextMilestone;\n', '\n', '            result = results.add(amount).add(bonusCalc);\n', '            newAmount = 0;\n', '\n', '        } else {\n', '            bonusCalc = bonusRange.mul(bonusTier).div(100);\n', '            bonusMilestones = nextMilestone;\n', '            result = results.add(bonusRange).add(bonusCalc);\n', '            newAmount = amount.sub(bonusRange);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Fetchs Bonus tier percentage per bonus milestones\n', '     */\n', '    function getBonusAmountCalculation(uint256 amount) internal returns (uint256) {\n', '        if (block.number < purchaseStartBlock) {\n', '            uint256 bonusFromAmount = amount.mul(30).div(100); // presale has 30% bonus\n', '            return amount.add(bonusFromAmount);\n', '        }\n', '\n', '        // range of each bonus milestones\n', '        uint256 firstBonusRange = firstBonusEnds;\n', '        uint256 secondBonusRange = secondBonusEnds.sub(firstBonusEnds);\n', '        uint256 thirdBonusRange = thirdBonusEnds.sub(secondBonusEnds);\n', '        uint256 fourthBonusRange = fourthBonusEnds.sub(thirdBonusEnds);\n', '        uint256 result;\n', '\n', '        if (bonusMilestones == BonusMilestones.First)\n', '            (result, amount) = calculateBonus(BonusMilestones.Second, amount, firstBonusRange, 20, result);\n', '\n', '        if (bonusMilestones == BonusMilestones.Second)\n', '            (result, amount) = calculateBonus(BonusMilestones.Third, amount, secondBonusRange, 15, result);\n', '\n', '        if (bonusMilestones == BonusMilestones.Third)\n', '            (result, amount) = calculateBonus(BonusMilestones.Fourth, amount, thirdBonusRange, 10, result);\n', '\n', '        if (bonusMilestones == BonusMilestones.Fourth)\n', '            (result, amount) = calculateBonus(BonusMilestones.Fifth, amount, fourthBonusRange, 5, result);\n', '\n', '        return result.add(amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Fetchs Bonus tier percentage per bonus milestones\n', '     * @dev qualifiedPartner Address of partners that participated in pre sale\n', '     * @dev amountSent Value sent by qualified partner\n', '     */\n', '    function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal {\n', '        //calculate the commission fee to send to qualified partner\n', '        uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100;\n', '\n', '        // send commission fee amount\n', '        qualifiedPartner.transfer(commissionFeePercentageCalculationAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev redirectToPurchase Redirect to adequate purchase function within the smart contract\n', '     */\n', '    function redirectToPurchase() internal {\n', '        if (block.number < purchaseStartBlock) {\n', '            purchaseAsQualifiedPartner();\n', '        } else {\n', '            purchaseWithEth();\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Starbase Crowdsale Contract Withdrawal contract - Provides an function\n', '          to withdraw STAR token according to crowdsale results\n', ' * @author Starbase PTE. LTD. - <info@starbase.co>\n', ' */\n', 'contract StarbaseCrowdsaleContractW is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '     *  Events\n', '     */\n', '    event TokenWithdrawn(address purchaser, uint256 tokenCount);\n', '    event CrowdsalePurchaseBonusLog(\n', '        uint256 purchaseIdx, uint256 rawAmount, uint256 bonus);\n', '\n', '    /**\n', '     *  External contracts\n', '     */\n', '    AbstractStarbaseToken public starbaseToken;\n', '    StarbaseCrowdsale public starbaseCrowdsale;\n', '    StarbaseEarlyPurchaseAmendment public starbaseEpAmendment;\n', '\n', '    /**\n', '     *  Constants\n', '     */\n', '    uint256 constant public crowdsaleTokenAmount = 125000000e18;\n', '    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;\n', '\n', '    /**\n', '     *  Storage\n', '     */\n', '\n', '    // early purchase\n', '    address[] public earlyPurchasers;\n', "    mapping (address => uint256) public earlyPurchasedAmountBy; // early purchased amount in CNY per purchasers' address\n", '    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract\n', '    uint256 public totalAmountOfEarlyPurchases; // including bonus\n', '    uint public numOfDeliveredEarlyPurchases;  // index to keep the number of early purchases have already been processed by `withdrawPurchasedTokens`\n', '    uint256 public numOfLoadedEarlyPurchases; // index to keep the number of early purchases that have already been loaded by `loadEarlyPurchases`\n', '\n', '    // crowdsale\n', '    uint256 public totalAmountOfCrowdsalePurchases; // in CNY, including bonuses\n', '    uint256 public totalAmountOfCrowdsalePurchasesWithoutBonus; // in CNY\n', '    uint256 public startDate;\n', '    uint256 public endedAt;\n', "    mapping (address => uint256) public crowdsalePurchaseAmountBy; // crowdsale purchase amount in CNY per purchasers' address\n", '    uint public numOfDeliveredCrowdsalePurchases;  // index to keep the number of crowdsale purchases have already been processed by `withdrawPurchasedTokens`\n', '\n', '    // crowdsale contract withdrawal\n', '    bool public crowdsalePurchasesLoaded = false;   // returns whether all crowdsale purchases are loaded into this contract\n', '    uint256 public numOfLoadedCrowdsalePurchases; // index to keep the number of crowdsale purchases that have already been loaded by `loadCrowdsalePurchases`\n', '    uint256 public totalAmountOfPresalePurchasesWithoutBonus;  // in CNY\n', '\n', '    // after the crowdsale\n', '    mapping (address => bool) public tokenWithdrawn;    // returns whether purchased tokens were withdrawn by a purchaser\n', '    mapping (address => uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser\n', '    mapping (address => uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser\n', '\n', '    /**\n', '     *  Modifiers\n', '     */\n', '    modifier whenEnded() {\n', '        assert(isEnded());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Contract functions\n', '     */\n', '\n', '    /**\n', '     * @dev Reject all incoming Ether transfers\n', '     */\n', '    function () { revert(); }\n', '\n', '    /**\n', '     * External functions\n', '     */\n', '\n', '    /**\n', "     * @dev Setup function sets external contracts' address\n", '     * @param starbaseTokenAddress Token address.\n', '     * @param StarbaseCrowdsaleAddress Token address.\n', '     */\n', '    function setup(address starbaseTokenAddress, address StarbaseCrowdsaleAddress)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(starbaseTokenAddress != address(0) && StarbaseCrowdsaleAddress != address(0));\n', '        require(address(starbaseToken) == 0 && address(starbaseCrowdsale) == 0);\n', '\n', '        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);\n', '        starbaseCrowdsale = StarbaseCrowdsale(StarbaseCrowdsaleAddress);\n', '        starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseCrowdsale.starbaseEpAmendment());\n', '\n', '        require(starbaseCrowdsale.startDate() > 0);\n', '        startDate = starbaseCrowdsale.startDate();\n', '\n', '        require(starbaseCrowdsale.endedAt() > 0);\n', '        endedAt = starbaseCrowdsale.endedAt();\n', '    }\n', '\n', '    /**\n', '     * @dev Load crowdsale purchases from the contract keeps track of them\n', '     * @param numOfPresalePurchases Number of presale purchase\n', '     */\n', '    function loadCrowdsalePurchases(uint256 numOfPresalePurchases)\n', '        external\n', '        onlyOwner\n', '        whenEnded\n', '    {\n', '        require(!crowdsalePurchasesLoaded);\n', '\n', '        uint256 numOfPurchases = starbaseCrowdsale.numOfPurchases();\n', '\n', '        for (uint256 i = numOfLoadedCrowdsalePurchases; i < numOfPurchases && msg.gas > 200000; i++) {\n', '            var (purchaser, amount, rawAmount,) =\n', '                starbaseCrowdsale.crowdsalePurchases(i);\n', '\n', '            uint256 bonus;\n', '            if (i < numOfPresalePurchases) {\n', '                bonus = rawAmount * 30 / 100;   // presale: 30% bonus\n', '                totalAmountOfPresalePurchasesWithoutBonus =\n', '                    totalAmountOfPresalePurchasesWithoutBonus.add(rawAmount);\n', '            } else {\n', '                bonus = calculateBonus(rawAmount); // mainsale: 20% ~ 0% bonus\n', '            }\n', '\n', '            // Update amount with bonus\n', '            CrowdsalePurchaseBonusLog(i, rawAmount, bonus);\n', '            amount = rawAmount + bonus;\n', '\n', '            // Increase the sums\n', '            crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);\n', '            totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);\n', '            totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);\n', '\n', '            numOfLoadedCrowdsalePurchases++;    // Increase the index\n', '        }\n', '\n', '        assert(numOfLoadedCrowdsalePurchases <= numOfPurchases);\n', '        if (numOfLoadedCrowdsalePurchases == numOfPurchases) {\n', '            crowdsalePurchasesLoaded = true;    // enable the flag\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Add early purchases\n', '     */\n', '    function addEarlyPurchases() external onlyOwner returns (bool) {\n', '        if (earlyPurchasesLoaded) {\n', '            return false;    // all EPs have already been loaded\n', '        }\n', '\n', '        uint256 numOfOrigEp = starbaseEpAmendment\n', '            .starbaseEarlyPurchase()\n', '            .numberOfEarlyPurchases();\n', '\n', '        for (uint256 i = numOfLoadedEarlyPurchases; i < numOfOrigEp && msg.gas > 200000; i++) {\n', '            if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) {\n', '                numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);\n', '                continue;\n', '            }\n', '            var (purchaser, amount,) =\n', '                starbaseEpAmendment.isAmendedEarlyPurchase(i)\n', '                ? starbaseEpAmendment.amendedEarlyPurchases(i)\n', '                : starbaseEpAmendment.earlyPurchases(i);\n', '            if (amount > 0) {\n', '                if (earlyPurchasedAmountBy[purchaser] == 0) {\n', '                    earlyPurchasers.push(purchaser);\n', '                }\n', '                // each early purchaser receives 10% bonus\n', '                uint256 bonus = SafeMath.mul(amount, 10) / 100;\n', '                uint256 amountWithBonus = SafeMath.add(amount, bonus);\n', '\n', '                earlyPurchasedAmountBy[purchaser] = SafeMath.add(earlyPurchasedAmountBy[purchaser], amountWithBonus);\n', '                totalAmountOfEarlyPurchases = totalAmountOfEarlyPurchases.add(amountWithBonus);\n', '            }\n', '\n', '            numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);\n', '        }\n', '\n', '        assert(numOfLoadedEarlyPurchases <= numOfOrigEp);\n', '        if (numOfLoadedEarlyPurchases == numOfOrigEp) {\n', '            earlyPurchasesLoaded = true;    // enable the flag\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Deliver tokens to purchasers according to their purchase amount in CNY\n', '     */\n', '    function withdrawPurchasedTokens()\n', '        external\n', '        whenEnded\n', '    {\n', '        require(crowdsalePurchasesLoaded);\n', '        assert(earlyPurchasesLoaded);\n', '        assert(address(starbaseToken) != 0);\n', '\n', '        // prevent double withdrawal\n', '        require(!tokenWithdrawn[msg.sender]);\n', '        tokenWithdrawn[msg.sender] = true;\n', '\n', '        /*\n', '         * “Value” refers to the contribution of the User:\n', '         *  {crowdsale_purchaser_token_amount} =\n', '         *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.\n', '         *\n', '         * Example: If a User contributes during the Contribution Period 100 CNY (including applicable\n', '         * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY\n', '         * and total amount raised during the Contribution Period is 30’000’000, then he will get\n', '         * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.\n', '        */\n', '\n', '        if (crowdsalePurchaseAmountBy[msg.sender] > 0) {\n', '            uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender];\n', '            uint256 tokenCount =\n', '                SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) /\n', '                totalRaisedAmountInCny();\n', '\n', '            numOfPurchasedTokensOnCsBy[msg.sender] =\n', '                SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount);\n', '            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount));\n', '            numOfDeliveredCrowdsalePurchases++;\n', '            TokenWithdrawn(msg.sender, tokenCount);\n', '        }\n', '\n', '        /*\n', '         * “Value” refers to the contribution of the User:\n', '         * {earlypurchaser_token_amount} =\n', '         * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})\n', '         *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).\n', '         *\n', '         * Example: If an Early Purchaser contributes 100 CNY (including Bonus) and the\n', '         * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised\n', '         * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =\n', '         * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /\n', '         * 30’000’000 CNY + 6’000’000 CNY\n', '         */\n', '\n', '        if (earlyPurchasedAmountBy[msg.sender] > 0) {  // skip if is not an early purchaser\n', '            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender];\n', '            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases;\n', '            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny();\n', '            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);\n', '\n', '            numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount);\n', '            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount));\n', '            numOfDeliveredEarlyPurchases++;\n', '            TokenWithdrawn(msg.sender, epTokenCount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Public functions\n', '     */\n', '\n', '    /**\n', '     * @dev Returns boolean for whether crowdsale has ended\n', '     */\n', '    function isEnded() constant public returns (bool) {\n', '        return (starbaseCrowdsale != address(0) && endedAt > 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total raised amount in CNY (includes EP) and bonuses\n', '     */\n', '    function totalRaisedAmountInCny() constant public returns (uint256) {\n', '        return totalAmountOfEarlyPurchases.add(totalAmountOfCrowdsalePurchases);\n', '    }\n', '\n', '    /**\n', '     * Internal functions\n', '     */\n', '\n', '    /**\n', '     * @dev Calculates bonus of a purchase\n', '     */\n', '    function calculateBonus(uint256 rawAmount)\n', '        internal\n', '        returns (uint256 bonus)\n', '    {\n', '        uint256 purchasedAmount =\n', '            totalAmountOfCrowdsalePurchasesWithoutBonus\n', '                .sub(totalAmountOfPresalePurchasesWithoutBonus);\n', '        uint256 e1 = starbaseCrowdsale.firstBonusEnds();\n', '        uint256 e2 = starbaseCrowdsale.secondBonusEnds();\n', '        uint256 e3 = starbaseCrowdsale.thirdBonusEnds();\n', '        uint256 e4 = starbaseCrowdsale.fourthBonusEnds();\n', '        return calculateBonusInRange(purchasedAmount, rawAmount, 0, e1, 20)\n', '            .add(calculateBonusInRange(purchasedAmount, rawAmount, e1, e2, 15))\n', '            .add(calculateBonusInRange(purchasedAmount, rawAmount, e2, e3, 10))\n', '            .add(calculateBonusInRange(purchasedAmount, rawAmount, e3, e4, 5));\n', '    }\n', '\n', '    function calculateBonusInRange(\n', '        uint256 purchasedAmount,\n', '        uint256 rawAmount,\n', '        uint256 bonusBegin,\n', '        uint256 bonusEnd,\n', '        uint256 bonusTier\n', '    )\n', '        public\n', '        constant\n', '        returns (uint256 bonus)\n', '    {\n', '        uint256 sum = purchasedAmount + rawAmount;\n', '        if (purchasedAmount > bonusEnd || sum < bonusBegin) {\n', '            return 0;   // out of this range\n', '        }\n', '\n', '        uint256 min = purchasedAmount <= bonusBegin ? bonusBegin : purchasedAmount;\n', '        uint256 max = bonusEnd <= sum ? bonusEnd : sum;\n', '        return max.sub(min) * bonusTier / 100;\n', '    }\n', '}']