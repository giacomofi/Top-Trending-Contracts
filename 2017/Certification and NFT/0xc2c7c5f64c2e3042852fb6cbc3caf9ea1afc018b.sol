['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// GazeCoin Crowdsale Contract\n', '//\n', '// Deployed to : {TBA}\n', '//\n', '// Note: Calculations are based on GZE having 18 decimal places\n', '//\n', '// Enjoy.\n', '//\n', '// (c) BokkyPooBah / Bok Consulting Pty Ltd for GazeCoin 2017. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', "// BokkyPooBah's Token Teleportation Service Interface v1.00\n", '//\n', '// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', 'contract BTTSTokenInterface is ERC20Interface {\n', '    uint public constant bttsVersion = 100;\n', '\n', '    bytes public constant signingPrefix = "\\x19Ethereum Signed Message:\\n32";\n', '    bytes4 public constant signedTransferSig = "\\x75\\x32\\xea\\xac";\n', '    bytes4 public constant signedApproveSig = "\\xe9\\xaf\\xa7\\xa1";\n', '    bytes4 public constant signedTransferFromSig = "\\x34\\x4b\\xcc\\x7d";\n', '    bytes4 public constant signedApproveAndCallSig = "\\xf1\\x6f\\x9b\\x53";\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event MinterUpdated(address from, address to);\n', '    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\n', '    event MintingDisabled();\n', '    event TransfersEnabled();\n', '    event AccountUnlocked(address indexed tokenOwner);\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // signed{X} functions\n', '    // ------------------------------------------------------------------------\n', '    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n', '\n', '    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash);\n', '    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n', '    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n', '\n', '    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\n', '    function unlockAccount(address tokenOwner) public;\n', '    function disableMinting() public;\n', '    function enableTransfers() public;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // signed{X}Check return status\n', '    // ------------------------------------------------------------------------\n', '    enum CheckResult {\n', '        Success,                           // 0 Success\n', '        NotTransferable,                   // 1 Tokens not transferable yet\n', '        AccountLocked,                     // 2 Account locked\n', '        SignerMismatch,                    // 3 Mismatch in signing account\n', '        AlreadyExecuted,                   // 4 Transfer already executed\n', '        InsufficientApprovedTokens,        // 5 Insufficient approved tokens\n', '        InsufficientApprovedTokensForFees, // 6 Insufficient approved tokens for fees\n', '        InsufficientTokens,                // 7 Insufficient tokens\n', '        InsufficientTokensForFees,         // 8 Insufficient tokens for fees\n', '        OverflowError                      // 9 Overflow error\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Bonus list interface\n', '// ----------------------------------------------------------------------------\n', 'contract BonusListInterface {\n', '    mapping(address => uint) public bonusList;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// GazeCoin Crowdsale Contract\n', '// ----------------------------------------------------------------------------\n', 'contract GazeCoinCrowdsale is SafeMath, Owned {\n', '\n', '    BTTSTokenInterface public bttsToken;\n', '    uint8 public constant TOKEN_DECIMALS = 18;\n', '\n', '    address public wallet = 0x8cD8baa410E9172b949f2c4433D3b5905F8606fF;\n', '    address public teamWallet = 0xb4eC550893D31763C02EBDa44Dff90b7b5a62656;\n', '    uint public constant TEAM_PERCENT_GZE = 30;\n', '\n', '    BonusListInterface public bonusList;\n', '    uint public constant TIER1_BONUS = 50;\n', '    uint public constant TIER2_BONUS = 20;\n', '    uint public constant TIER3_BONUS = 15;\n', '\n', '    // Start 10 Dec 2017 11:00 EST => 10 Dec 2017 16:00 UTC => 11 Dec 2017 03:00 AEST\n', '    // new Date(1512921600 * 1000).toUTCString() => "Sun, 10 Dec 2017 16:00:00 UTC"\n', '    uint public constant START_DATE = 1512921600;\n', '    // End 21 Dec 2017 11:00 EST => 21 Dec 2017 16:00 UTC => 21 Dec 2017 03:00 AEST\n', '    // new Date(1513872000 * 1000).toUTCString() => "Thu, 21 Dec 2017 16:00:00 UTC"\n', '    uint public endDate = 1513872000;\n', '\n', '    // ETH/USD 9 Dec 2017 11:00 EST => 9 Dec 2017 16:00 UTC => 10 Dec 2017 03:00 AEST => 489.44 from CMC\n', '    uint public usdPerKEther = 489440;\n', '    uint public constant USD_CENT_PER_GZE = 35;\n', '    uint public constant CAP_USD = 35000000;\n', '    uint public constant MIN_CONTRIBUTION_ETH = 0.01 ether;\n', '\n', '    uint public contributedEth;\n', '    uint public contributedUsd;\n', '    uint public generatedGze;\n', '\n', '    //  AUD 10,000 = ~ USD 7,500\n', '    uint public lockedAccountThresholdUsd = 7500;\n', '    mapping(address => uint) public accountEthAmount;\n', '\n', '    bool public precommitmentAdjusted;\n', '    bool public finalised;\n', '\n', '    event BTTSTokenUpdated(address indexed oldBTTSToken, address indexed newBTTSToken);\n', '    event WalletUpdated(address indexed oldWallet, address indexed newWallet);\n', '    event TeamWalletUpdated(address indexed oldTeamWallet, address indexed newTeamWallet);\n', '    event BonusListUpdated(address indexed oldBonusList, address indexed newBonusList);\n', '    event EndDateUpdated(uint oldEndDate, uint newEndDate);\n', '    event UsdPerKEtherUpdated(uint oldUsdPerKEther, uint newUsdPerKEther);\n', '    event LockedAccountThresholdUsdUpdated(uint oldEthLockedThreshold, uint newEthLockedThreshold);\n', '    event Contributed(address indexed addr, uint ethAmount, uint ethRefund, uint accountEthAmount, uint usdAmount, uint gzeAmount, uint contributedEth, uint contributedUsd, uint generatedGze, bool lockAccount);\n', '\n', '    function GazeCoinCrowdsale() public {\n', '    }\n', '    function setBTTSToken(address _bttsToken) public onlyOwner {\n', '        require(now <= START_DATE);\n', '        BTTSTokenUpdated(address(bttsToken), _bttsToken);\n', '        bttsToken = BTTSTokenInterface(_bttsToken);\n', '    }\n', '    function setWallet(address _wallet) public onlyOwner {\n', '        WalletUpdated(wallet, _wallet);\n', '        wallet = _wallet;\n', '    }\n', '    function setTeamWallet(address _teamWallet) public onlyOwner {\n', '        TeamWalletUpdated(teamWallet, _teamWallet);\n', '        teamWallet = _teamWallet;\n', '    }\n', '    function setBonusList(address _bonusList) public onlyOwner {\n', '        require(now <= START_DATE);\n', '        BonusListUpdated(address(bonusList), _bonusList);\n', '        bonusList = BonusListInterface(_bonusList);\n', '    }\n', '    function setEndDate(uint _endDate) public onlyOwner {\n', '        require(_endDate >= now);\n', '        EndDateUpdated(endDate, _endDate);\n', '        endDate = _endDate;\n', '    }\n', '    function setUsdPerKEther(uint _usdPerKEther) public onlyOwner {\n', '        require(now <= START_DATE);\n', '        UsdPerKEtherUpdated(usdPerKEther, _usdPerKEther);\n', '        usdPerKEther = _usdPerKEther;\n', '    }\n', '    function setLockedAccountThresholdUsd(uint _lockedAccountThresholdUsd) public onlyOwner {\n', '        require(now <= START_DATE);\n', '        LockedAccountThresholdUsdUpdated(lockedAccountThresholdUsd, _lockedAccountThresholdUsd);\n', '        lockedAccountThresholdUsd = _lockedAccountThresholdUsd;\n', '    }\n', '\n', '    function capEth() public view returns (uint) {\n', '        return CAP_USD * 10**uint(3 + 18) / usdPerKEther;\n', '    }\n', '    function gzeFromEth(uint ethAmount, uint bonusPercent) public view returns (uint) {\n', '        return usdPerKEther * ethAmount * (100 + bonusPercent) / 10**uint(3 + 2 - 2) / USD_CENT_PER_GZE;\n', '    }\n', '    function gzePerEth() public view returns (uint) {\n', '        return gzeFromEth(10**18, 0);\n', '    }\n', '    function lockedAccountThresholdEth() public view returns (uint) {\n', '        return lockedAccountThresholdUsd * 10**uint(3 + 18) / usdPerKEther;\n', '    }\n', '    function getBonusPercent(address addr) public view returns (uint bonusPercent) {\n', '        uint tier = bonusList.bonusList(addr);\n', '        if (tier == 1) {\n', '            bonusPercent = TIER1_BONUS;\n', '        } else if (tier == 2) {\n', '            bonusPercent = TIER2_BONUS;\n', '        } else if (tier == 3) {\n', '            bonusPercent = TIER3_BONUS;\n', '        } else {\n', '            bonusPercent = 0;\n', '        }\n', '    }\n', '    function () public payable {\n', '        require((now >= START_DATE && now <= endDate) || (msg.sender == owner && msg.value == MIN_CONTRIBUTION_ETH));\n', '        require(contributedEth < capEth());\n', '        require(msg.value >= MIN_CONTRIBUTION_ETH);\n', '        uint bonusPercent = getBonusPercent(msg.sender);\n', '        uint ethAmount = msg.value;\n', '        uint ethRefund = 0;\n', '        if (safeAdd(contributedEth, ethAmount) > capEth()) {\n', '            ethAmount = safeSub(capEth(), contributedEth);\n', '            ethRefund = safeSub(msg.value, ethAmount);\n', '        }\n', '        uint usdAmount = safeDiv(safeMul(ethAmount, usdPerKEther), 10**uint(3 + 18));\n', '        uint gzeAmount = gzeFromEth(ethAmount, bonusPercent);\n', '        generatedGze = safeAdd(generatedGze, gzeAmount);\n', '        contributedEth = safeAdd(contributedEth, ethAmount);\n', '        contributedUsd = safeAdd(contributedUsd, usdAmount);\n', '        accountEthAmount[msg.sender] = safeAdd(accountEthAmount[msg.sender], ethAmount);\n', '        bool lockAccount = accountEthAmount[msg.sender] > lockedAccountThresholdEth();\n', '        bttsToken.mint(msg.sender, gzeAmount, lockAccount);\n', '        if (ethAmount > 0) {\n', '            wallet.transfer(ethAmount);\n', '        }\n', '        Contributed(msg.sender, ethAmount, ethRefund, accountEthAmount[msg.sender], usdAmount, gzeAmount, contributedEth, contributedUsd, generatedGze, lockAccount);\n', '        if (ethRefund > 0) {\n', '            msg.sender.transfer(ethRefund);\n', '        }\n', '    }\n', '\n', '    function addPrecommitment(address tokenOwner, uint ethAmount, uint bonusPercent) public onlyOwner {\n', '        require(!finalised);\n', '        uint usdAmount = safeDiv(safeMul(ethAmount, usdPerKEther), 10**uint(3 + 18));\n', '        uint gzeAmount = gzeFromEth(ethAmount, bonusPercent);\n', '        uint ethRefund = 0;\n', '        generatedGze = safeAdd(generatedGze, gzeAmount);\n', '        contributedEth = safeAdd(contributedEth, ethAmount);\n', '        contributedUsd = safeAdd(contributedUsd, usdAmount);\n', '        accountEthAmount[tokenOwner] = safeAdd(accountEthAmount[tokenOwner], ethAmount);\n', '        bool lockAccount = accountEthAmount[tokenOwner] > lockedAccountThresholdEth();\n', '        bttsToken.mint(tokenOwner, gzeAmount, lockAccount);\n', '        Contributed(tokenOwner, ethAmount, ethRefund, accountEthAmount[tokenOwner], usdAmount, gzeAmount, contributedEth, contributedUsd, generatedGze, lockAccount);\n', '    }\n', '    function addPrecommitmentAdjustment(address tokenOwner, uint gzeAmount) public onlyOwner {\n', '        require(now > endDate || contributedEth >= capEth());\n', '        require(!finalised);\n', '        uint ethAmount = 0;\n', '        uint usdAmount = 0;\n', '        uint ethRefund = 0;\n', '        generatedGze = safeAdd(generatedGze, gzeAmount);\n', '        bool lockAccount = accountEthAmount[tokenOwner] > lockedAccountThresholdEth();\n', '        bttsToken.mint(tokenOwner, gzeAmount, lockAccount);\n', '        precommitmentAdjusted = true;\n', '        Contributed(tokenOwner, ethAmount, ethRefund, accountEthAmount[tokenOwner], usdAmount, gzeAmount, contributedEth, contributedUsd, generatedGze, lockAccount);\n', '    }\n', '    function roundUp(uint a) public pure returns (uint) {\n', '        uint multiple = 10**uint(TOKEN_DECIMALS);\n', '        uint remainder = a % multiple;\n', '        if (remainder > 0) {\n', '            return safeSub(safeAdd(a, multiple), remainder);\n', '        }\n', '    }\n', '    function finalise() public onlyOwner {\n', '        require(!finalised);\n', '        require(precommitmentAdjusted);\n', '        require(now > endDate || contributedEth >= capEth());\n', '        uint total = safeDiv(safeMul(generatedGze, 100), safeSub(100, TEAM_PERCENT_GZE));\n', '        uint amountTeam = safeDiv(safeMul(total, TEAM_PERCENT_GZE), 100);\n', '        generatedGze = safeAdd(generatedGze, amountTeam);\n', '        uint rounded = roundUp(generatedGze);\n', '        if (rounded > generatedGze) {\n', '            uint dust = safeSub(rounded, generatedGze);\n', '            generatedGze = safeAdd(generatedGze, dust);\n', '            amountTeam = safeAdd(amountTeam, dust);\n', '        }\n', '        bttsToken.mint(teamWallet, amountTeam, false);\n', '        bttsToken.disableMinting();\n', '        finalised = true;\n', '    }\n', '}']