['// (C) 2017 TokenMarket Ltd. (https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt) Commit: d9e308ff22556a8f40909b1f89ec0f759d1337e0\n', '/**\n', ' * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n', ' *\n', ' * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n', ' */\n', '\n', '\n', '/**\n', ' * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n', ' *\n', ' * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n', ' */\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', ' * Haltable\n', ' *\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n', ' *\n', ' *\n', ' * Originally envisioned in FirstBlood ICO contract.\n', ' */\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) throw;\n', '    _;\n', '  }\n', '\n', '  modifier stopNonOwnersInEmergency {\n', '    if (halted && msg.sender != owner) throw;\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) throw;\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * Forward Ethereum payments to another wallet and track them with an event.\n', ' *\n', ' * Allows to identify customers who made Ethereum payment for a central token issuance.\n', ' * Furthermore allow making a payment on behalf of another address.\n', ' *\n', ' * Allow pausing to signal the end of the crowdsale.\n', ' */\n', 'contract PaymentForwarder is Haltable {\n', '\n', '  /** Who will get all ETH in the end */\n', '  address public teamMultisig;\n', '\n', '  /** Total incoming money */\n', '  uint public totalTransferred;\n', '\n', '  /** How many distinct customers we have that have made a payment */\n', '  uint public customerCount;\n', '\n', '  /** Total incoming money per centrally tracked customer id */\n', '  mapping(uint128 => uint) public paymentsByCustomer;\n', '\n', '  /** Total incoming money per benefactor address */\n', '  mapping(address => uint) public paymentsByBenefactor;\n', '\n', '  /** A customer has made a payment. Benefactor is the address where the tokens will be ultimately issued.*/\n', '  event PaymentForwarded(address source, uint amount, uint128 customerId, address benefactor);\n', '\n', '  function PaymentForwarder(address _owner, address _teamMultisig) {\n', '    teamMultisig = _teamMultisig;\n', '    owner = _owner;\n', '  }\n', '\n', '  /**\n', '   * Pay on a behalf of an address.\n', '   *\n', '   * @param customerId Identifier in the central database, UUID v4\n', '   *\n', '   */\n', '  function pay(uint128 customerId, address benefactor) public stopInEmergency payable {\n', '\n', '    uint weiAmount = msg.value;\n', '\n', '    PaymentForwarded(msg.sender, weiAmount, customerId, benefactor);\n', '\n', '    // We trust Ethereum amounts cannot overflow uint256\n', '    totalTransferred += weiAmount;\n', '\n', '    if(paymentsByCustomer[customerId] == 0) {\n', '      customerCount++;\n', '    }\n', '\n', '    paymentsByCustomer[customerId] += weiAmount;\n', '\n', '    // We track benefactor addresses for extra safety;\n', '    // In the case of central ETH issuance tracking has problems we can\n', '    // construct ETH contributions solely based on blockchain data\n', '    paymentsByBenefactor[benefactor] += weiAmount;\n', '\n', '    // May run out of gas\n', '    if(!teamMultisig.send(weiAmount)) throw;\n', '  }\n', '\n', '  /**\n', '   * Pay on a behalf of the sender.\n', '   *\n', '   * @param customerId Identifier in the central database, UUID v4\n', '   *\n', '   */\n', '  function payForMyself(uint128 customerId) public payable {\n', '    pay(customerId, msg.sender);\n', '  }\n', '\n', '}']