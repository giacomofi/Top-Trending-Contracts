['pragma solidity ^0.4.15;\n', '\n', '/**\n', '  * Math operations with safety checks\n', '  */\n', 'library SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '  * ERC20 interface\n', '  * see https://github.com/ethereum/EIPs/issues/20\n', '  */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '    function approve(address spender, uint value) returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/**\n', '  * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', '  *\n', '  * Based on code by FirstBlood:\n', '  * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', '  */\n', 'contract StandardToken is ERC20\n', '{\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    // Interface marker\n', '    bool public constant isToken = true;\n', '\n', '    /**\n', '      * Fix for the ERC20 short address attack\n', '      *\n', '      * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '      */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value)\n', '        onlyPayloadSize(2 * 32)\n', '        returns (bool success)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].safeSub(_value);\n', '        balances[_to] = balances[_to].safeAdd(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value)\n', '        returns (bool success)\n', '    {\n', '        uint _allowance = allowed[from][msg.sender];\n', '\n', '        // Check is not needed because _allowance.safeSub(value) will throw if this condition is not met\n', '        // if (value > _allowance) throw;\n', '\n', '        balances[to] = balances[to].safeAdd(value);\n', '        balances[from] = balances[from].safeSub(value);\n', '        allowed[from][msg.sender] = _allowance.safeSub(value);\n', '\n', '        Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address account)\n', '        constant\n', '        returns (uint balance)\n', '    {\n', '        return balances[account];\n', '    }\n', '\n', '    function approve(address spender, uint value)\n', '        returns (bool success)\n', '    {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((value != 0) && (allowed[msg.sender][spender] != 0)) throw;\n', '\n', '        allowed[msg.sender][spender] = value;\n', '\n', '        Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address account, address spender)\n', '        constant\n', '        returns (uint remaining)\n', '    {\n', '        return allowed[account][spender];\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', '  * Upgrade target interface inspired by Lunyr.\n', '  *\n', '  * Upgrade agent transfers tokens to a new contract.\n', '  * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n', '  */\n', 'contract UpgradeTarget\n', '{\n', '    uint public originalSupply;\n', '\n', '    /** Interface marker */\n', '    function isUpgradeTarget() public constant returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function upgradeFrom(address _from, uint256 _value) public;\n', '}\n', '\n', '\n', '/**\n', '  * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n', '  *\n', '  * First envisioned by Golem and Lunyr projects.\n', '  */\n', 'contract UpgradeableToken is StandardToken\n', '{\n', '    /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n', '    address public upgradeMaster;\n', '\n', '    /** The next contract where the tokens will be migrated. */\n', '    UpgradeTarget public upgradeTarget;\n', '\n', '    /** How many tokens we have upgraded by now. */\n', '    uint256 public totalUpgraded;\n', '\n', '    /**\n', '      * Upgrade states.\n', '      *\n', '      * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n', "      * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n", '      * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\n', '      * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n', '      *\n', '      */\n', '    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n', '\n', '    /**\n', '      * Somebody has upgraded some of his tokens.\n', '      */\n', '    event LogUpgrade(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '      * New upgrade agent available.\n', '      */\n', '    event LogSetUpgradeTarget(address agent);\n', '\n', '    /**\n', '      * Do not allow construction without upgrade master set.\n', '      */\n', '    function UpgradeableToken(address _upgradeMaster) {\n', '        upgradeMaster = _upgradeMaster;\n', '    }\n', '\n', '    /**\n', '      * Allow the token holder to upgrade some of their tokens to a new contract.\n', '      */\n', '    function upgrade(uint256 value) public {\n', '        UpgradeState state = getUpgradeState();\n', '        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n', '\n', '        // Validate input value.\n', '        require(value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].safeSub(value);\n', '\n', '        // Take tokens out from circulation\n', '        totalSupply   = totalSupply.safeSub(value);\n', '        totalUpgraded = totalUpgraded.safeAdd(value);\n', '\n', '        // Upgrade agent reissues the tokens\n', '        upgradeTarget.upgradeFrom(msg.sender, value);\n', '        LogUpgrade(msg.sender, upgradeTarget, value);\n', '    }\n', '\n', '    /**\n', '      * Set an upgrade targget that handles the process of letting users opt-in to the new token contract.\n', '      */\n', '    function setUpgradeTarget(address target) external {\n', '        require(canUpgrade());\n', '        require(target != 0x0);\n', '        require(msg.sender == upgradeMaster); // Only a master can designate the next target\n', '        require(getUpgradeState() != UpgradeState.Upgrading); // Upgrade has already begun\n', '\n', '        upgradeTarget = UpgradeTarget(target);\n', '\n', '        require(upgradeTarget.isUpgradeTarget()); // Bad interface\n', '        require(upgradeTarget.originalSupply() == totalSupply); // Make sure that token supplies match in source and target\n', '\n', '        LogSetUpgradeTarget(upgradeTarget);\n', '    }\n', '\n', '    /**\n', '      * Get the state of the token upgrade.\n', '      */\n', '    function getUpgradeState() public constant returns (UpgradeState) {\n', '        if (!canUpgrade()) return UpgradeState.NotAllowed;\n', '        else if (address(upgradeTarget) == 0x00) return UpgradeState.WaitingForAgent;\n', '        else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n', '        else return UpgradeState.Upgrading;\n', '    }\n', '\n', '    /**\n', '      * Change the upgrade master.\n', '      *\n', '      * This allows us to set a new owner for the upgrade mechanism.\n', '      */\n', '    function setUpgradeMaster(address master) public {\n', '        require(master != 0x0);\n', '        require(msg.sender == upgradeMaster);\n', '\n', '        upgradeMaster = master;\n', '    }\n', '\n', '    /**\n', '      * Child contract can enable to provide the condition when the upgrade can begun.\n', '      */\n', '    function canUpgrade() public constant returns (bool) {\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract MintableToken is StandardToken\n', '{\n', '    address public mintMaster;\n', '\n', '    event LogMintTokens(address recipient, uint amount, uint newBalance, uint totalSupply);\n', '    event LogUnmintTokens(address hodler, uint amount, uint newBalance, uint totalSupply);\n', '    event LogSetMintMaster(address oldMintMaster, address newMintMaster);\n', '\n', '    function MintableToken(address _mintMaster) {\n', '        mintMaster = _mintMaster;\n', '    }\n', '\n', '    function setMintMaster(address newMintMaster)\n', '        returns (bool ok)\n', '    {\n', '        require(msg.sender == mintMaster);\n', '\n', '        address oldMintMaster = mintMaster;\n', '        mintMaster = newMintMaster;\n', '\n', '        LogSetMintMaster(oldMintMaster, mintMaster);\n', '        return true;\n', '    }\n', '\n', '    function mintTokens(address recipient, uint amount)\n', '        returns (bool ok)\n', '    {\n', '        require(msg.sender == mintMaster);\n', '        require(amount > 0);\n', '\n', '        balances[recipient] = balances[recipient].safeAdd(amount);\n', '        totalSupply = totalSupply.safeAdd(amount);\n', '\n', '        LogMintTokens(recipient, amount, balances[recipient], totalSupply);\n', '        Transfer(address(0), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function unmintTokens(address hodler, uint amount)\n', '        returns (bool ok)\n', '    {\n', '        require(msg.sender == mintMaster);\n', '        require(amount > 0);\n', '        require(balances[hodler] >= amount);\n', '\n', '        balances[hodler] = balances[hodler].safeSub(amount);\n', '        totalSupply = totalSupply.safeSub(amount);\n', '\n', '        LogUnmintTokens(hodler, amount, balances[hodler], totalSupply);\n', '        Transfer(hodler, address(0), amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract SigToken is UpgradeableToken, MintableToken\n', '{\n', '    string public name = "Signals";\n', '    string public symbol = "SIG";\n', '    uint8 public decimals = 18;\n', '\n', '    address public crowdsaleContract;\n', '    bool public crowdsaleCompleted;\n', '\n', '    function SigToken()\n', '        UpgradeableToken(msg.sender)\n', '        MintableToken(msg.sender)\n', '    {\n', '        crowdsaleContract = msg.sender;\n', '        totalSupply = 0; // we mint during the crowdsale, so totalSupply must start at 0\n', '    }\n', '\n', '    function transfer(address _to, uint _value)\n', '        returns (bool success)\n', '    {\n', '        require(crowdsaleCompleted);\n', '        return StandardToken.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value)\n', '        returns (bool success)\n', '    {\n', '        require(crowdsaleCompleted);\n', '        return StandardToken.transferFrom(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value)\n', '        returns (bool success)\n', '    {\n', '        require(crowdsaleCompleted);\n', '        return StandardToken.approve(spender, value);\n', '    }\n', '\n', '    // This is called to unlock tokens once the crowdsale (and subsequent audit + legal process) are\n', "    // completed.  We don't want people buying tokens during the sale and then immediately starting\n", '    // to trade them.  See Crowdsale::finalizeCrowdsale().\n', '    function setCrowdsaleCompleted() {\n', '        require(msg.sender == crowdsaleContract);\n', '        require(crowdsaleCompleted == false);\n', '\n', '        crowdsaleCompleted = true;\n', '    }\n', '\n', '    /**\n', '     * ERC20 approveAndCall extension\n', '     *\n', '     * Approves and then calls the receiving contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(crowdsaleCompleted);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));\n', '        return true;\n', '    }\n', '}']