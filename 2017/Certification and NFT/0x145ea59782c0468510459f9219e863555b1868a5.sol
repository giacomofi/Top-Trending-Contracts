['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum State { Active, Refunding, Closed }\n', '\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  function RefundVault(address _wallet) {\n', '    require(_wallet != 0x0);\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    Closed();\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    RefundsEnabled();\n', '  }\n', '\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    Refunded(investor, depositedValue);\n', '  }\n', '}\n', '\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  MintableToken public token;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '\n', '  // how many token units a buyer gets per wei\n', '  uint256 public rate;\n', '\n', '  // amount of raised money in wei\n', '  uint256 public weiRaised;\n', '\n', '  /**\n', '   * event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\n', '  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\n', '    require(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_rate > 0);\n', '    require(_wallet != 0x0);\n', '\n', '    token = createTokenContract();\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '  }\n', '\n', '  // creates the token to be sold.\n', '  // override this method to have crowdsale of a specific mintable token.\n', '  function createTokenContract() internal returns (MintableToken) {\n', '    return new MintableToken();\n', '  }\n', '\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    require(beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = weiAmount.mul(rate);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '\n', '    token.mint(beneficiary, tokens);\n', '    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '    forwardFunds();\n', '  }\n', '\n', '  // send ether to the fund collection wallet\n', '  // override to create custom fund forwarding mechanisms\n', '  function forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '  // @return true if the transaction can buy tokens\n', '  function validPurchase() internal constant returns (bool) {\n', '    bool withinPeriod = now >= startTime && now <= endTime;\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    return withinPeriod && nonZeroPurchase;\n', '  }\n', '\n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > endTime;\n', '  }\n', '\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract CappedCrowdsale is Crowdsale {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public cap;\n', '\n', '  function CappedCrowdsale(uint256 _cap) {\n', '    require(_cap > 0);\n', '    cap = _cap;\n', '  }\n', '\n', '  // overriding Crowdsale#validPurchase to add extra cap logic\n', '  // @return true if investors can buy at the moment\n', '  function validPurchase() internal constant returns (bool) {\n', '    bool withinCap = weiRaised.add(msg.value) <= cap;\n', '    return super.validPurchase() && withinCap;\n', '  }\n', '\n', '  // overriding Crowdsale#hasEnded to add cap logic\n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    bool capReached = weiRaised >= cap;\n', '    return super.hasEnded() || capReached;\n', '  }\n', '\n', '}\n', '\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  bool public isFinalized = false;\n', '\n', '  event Finalized();\n', '\n', '  /**\n', '   * @dev Must be called after crowdsale ends, to do some extra finalization\n', "   * work. Calls the contract's finalization function.\n", '   */\n', '  function finalize() onlyOwner public {\n', '    require(!isFinalized);\n', '    require(hasEnded());\n', '\n', '    finalization();\n', '    Finalized();\n', '\n', '    isFinalized = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Can be overridden to add finalization logic. The overriding function\n', '   * should call super.finalization() to ensure the chain of finalization is\n', '   * executed entirely.\n', '   */\n', '  function finalization() internal {\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract RefundableCrowdsale is FinalizableCrowdsale {\n', '  using SafeMath for uint256;\n', '\n', '  // minimum amount of funds to be raised in weis\n', '  uint256 public goal;\n', '\n', '  // refund vault used to hold funds while crowdsale is running\n', '  RefundVault public vault;\n', '\n', '  function RefundableCrowdsale(uint256 _goal) {\n', '    require(_goal > 0);\n', '    vault = new RefundVault(wallet);\n', '    goal = _goal;\n', '  }\n', '\n', "  // We're overriding the fund forwarding from Crowdsale.\n", '  // In addition to sending the funds, we want to call\n', '  // the RefundVault deposit function\n', '  function forwardFunds() internal {\n', '    vault.deposit.value(msg.value)(msg.sender);\n', '  }\n', '\n', '  // if crowdsale is unsuccessful, investors can claim refunds here\n', '  function claimRefund() public {\n', '    require(isFinalized);\n', '    require(!goalReached());\n', '\n', '    vault.refund(msg.sender);\n', '  }\n', '\n', '  // vault finalization task, called when owner calls finalize()\n', '  function finalization() internal {\n', '    if (goalReached()) {\n', '      vault.close();\n', '    } else {\n', '      vault.enableRefunds();\n', '    }\n', '\n', '    super.finalization();\n', '  }\n', '\n', '  function goalReached() public constant returns (bool) {\n', '    return weiRaised >= goal;\n', '  }\n', '\n', '}\n', '\n', 'contract ZakemFansCrowdsale is Pausable, RefundableCrowdsale, CappedCrowdsale {\n', '        /**\n', '           Address of the wallet of the founders.\n', '           In this wallet, part of the facilitating tokens will be stored, and they will be locked for 24 months.\n', '         */\n', '        address public foundersWallet;\n', '\n', '        /**\n', '           Address of the wallet used to pay out bounties.\n', '           In this wallet, part of the facilitating tokens will be stored.\n', '         */\n', '        address public bountiesWallet;\n', '\n', '        /**\n', '           Keeps track of how many tokens have been raised so far.\n', '           Used to know when `goal` and `cap` have been reached.\n', '         */\n', '        uint256 public purchasedTokensRaised;\n', '\n', '        /**\n', '           The amount of tokens that were sold in the Presale before the Crowdsale.\n', '           Given during construction of this contract.\n', '         */\n', '        uint256 public purchasedTokensRaisedDuringPresale;\n', '\n', '        /**\n', '           Helper property to ensure that 1/12 of `cap` does not need to be re-calculated every time.\n', '         */\n', '        uint256 oneTwelfthOfCap;\n', '\n', '        /**\n', '           @dev Constructor of the ZakemFansCrowdsale contract\n', '\n', '           @param _startTime time (Solidity UNIX timestamp) from when it is allowed to buy FINC.\n', '           @param _endTime time (Solidity UNIX timestamp) until which it is allowed to buy FINC. (Should be larger than startTime)\n', '           @param _rate Number of tokens created per ether. (Since Ether and ZakemCoin use the same number of decimal places, this can be read as direct conversion rate of Ether -> ZakemCoin.)\n', '           @param _wallet The wallet of ZakemFans itself, to which some of the facilitating tokens will be sent.\n', '           @param _bountiesWallet The wallet used to pay out bounties, to which some of the facilitating tokens will be sent.\n', '           @param _foundersWallet The wallet used for the founders, to which some of the facilitating tokens will be sent.\n', '           @param _goal The minimum goal (in 1 * 10^(-18) tokens) that the Crowdsale needs to reach.\n', '           @param _cap The maximum cap (in 1 * 10^(-18) tokens) that the Crowdsale can reach.\n', '           @param _token The address where the ZakemCoin contract was deployed prior to creating this contract.\n', '           @param _purchasedTokensRaisedDuringPresale The amount (in 1 * 18^18 tokens) that was purchased during the presale.\n', '         */\n', '        function ZakemFansCrowdsale (\n', '                uint256 _startTime,\n', '                uint256 _endTime,\n', '                uint256 _rate,\n', '                address _wallet,\n', '                address _bountiesWallet,\n', '                address _foundersWallet,\n', '                uint256 _goal,\n', '                uint256 _cap,\n', '                address _token,\n', '                uint256 _purchasedTokensRaisedDuringPresale\n', '                )\n', '                Crowdsale(_startTime, _endTime, _rate, _wallet)\n', '                RefundableCrowdsale(_goal)\n', '                CappedCrowdsale(_cap)\n', '        {\n', '                require(_goal < _cap);\n', '\n', '                bountiesWallet = _bountiesWallet;\n', '                foundersWallet = _foundersWallet;\n', '                token = ZakemCoin(_token);\n', '                weiRaised = 0;\n', '\n', '                purchasedTokensRaisedDuringPresale = _purchasedTokensRaisedDuringPresale;\n', '                purchasedTokensRaised = purchasedTokensRaisedDuringPresale;\n', '\n', '                oneTwelfthOfCap = _cap / 12;\n', '        }\n', '\n', '        /*\n', '          Overrides Crowdsale.createTokenContract,\n', '          because the ZakemFansCrowdsale uses an already-deployed\n', '          token, so there is no need to internally deploy a contract.\n', '        */\n', '        function createTokenContract() internal returns (MintableToken) {\n', '                return MintableToken(0x0);\n', '        }\n', '\n', '        /*\n', '         * Overrides version of Crowdsale.buyTokens because:\n', '         * - The Wei->FFC rate depends on how many tokens have already been sold (see `currentBonusRate()`).\n', '         * - Also mint tokens sent to ZakemFans and the Founders at the same time.\n', '         */\n', '        function buyTokens(address beneficiary) public payable whenNotPaused {\n', '                require(beneficiary != 0x0);\n', '\n', '                uint256 weiAmount = msg.value;\n', '\n', '                // calculate token amount to be created\n', '                uint256 purchasedTokens = weiAmount.div(rate);\n', '                require(validPurchase(purchasedTokens));\n', '                purchasedTokens = purchasedTokens.mul(currentBonusRate()).div(100);\n', '                require(purchasedTokens != 0);\n', '\n', '                // update state\n', '                weiRaised = weiRaised.add(weiAmount);\n', '                purchasedTokensRaised = purchasedTokensRaised.add(purchasedTokens);\n', '\n', '                // Mint tokens for beneficiary\n', '                token.mint(beneficiary, purchasedTokens);\n', '                TokenPurchase(msg.sender, beneficiary, weiAmount, purchasedTokens);\n', '\n', '                mintTokensForFacilitators(purchasedTokens);\n', '\n', '                forwardFunds();\n', '        }\n', '\n', '        /* Overrides RefundableCrowdsale#goalReached\n', '           since we count the goal in purchased tokens, instead of in Wei.\n', '           @return true if crowdsale has reached more funds than the minimum goal.\n', '        */\n', '        function goalReached() public constant returns (bool) {\n', '                return purchasedTokensRaised >= goal;\n', '        }\n', '\n', '        /**\n', '           Overrides CappedCrowdsale#hasEnded to add cap logic in tokens\n', '           @return true if crowdsale event has ended\n', '        */\n', '        function hasEnded() public constant returns (bool) {\n', '                bool capReached = purchasedTokensRaised >= cap;\n', '                return Crowdsale.hasEnded() || capReached;\n', '        }\n', '\n', '        /**\n', '           replaces CappedCrowdsale#validPurchase to add extra cap logic in tokens\n', '           @param purchasedTokens Amount of tokens that were purchased (in the smallest, 1 * 10^(-18) denomination)\n', '           @return true if investors are allowed to purchase tokens at the moment.\n', '        */\n', '        function validPurchase(uint256 purchasedTokens) internal constant returns (bool) {\n', '                /* bool withinCap = purchasedTokensRaised.add(purchasedTokens) <= cap; */\n', '                /* return Crowdsale.validPurchase() && withinCap; */\n', '                bool withinCap = purchasedTokensRaised.add(purchasedTokens) <= cap;\n', '                return Crowdsale.validPurchase() && withinCap;\n', '        }\n', '\n', '        /**\n', '           @dev Mints the tokens for the facilitating parties.\n', '\n', '           @dev In total, (20/13) * `purchasedTokens` tokens are created.\n', '           @dev 13/13th of these are for the Beneficiary.\n', '           @dev 7/13th of these are minted for the Facilitators as follows:\n', '           @dev   1/13th -> Founders\n', '           @dev   2/13th -> Bounties\n', '           @dev   4/13th -> ZakemFans\n', '\n', '           @dev Note that all result rational amounts are floored since the EVM only works with integer arithmetic.\n', '        */\n', '        function mintTokensForFacilitators(uint256 purchasedTokens) internal {\n', '                // Mint tokens for ZakemFans and Founders\n', '                uint256 fintechfans_tokens = purchasedTokens.mul(4).div(13);\n', '                uint256 bounties_tokens = purchasedTokens.mul(2).div(13);\n', '                uint256 founders_tokens = purchasedTokens.mul(1).div(13);\n', '                token.mint(wallet, fintechfans_tokens);\n', '                token.mint(bountiesWallet, bounties_tokens);\n', '                token.mint(foundersWallet, founders_tokens);/* TODO Locked vault? */\n', '        }\n', '\n', '        /**\n', '           @dev returns the current bonus rate. This is a call that can be done at any time.\n', '\n', '           @return a fixed-size number that is the total percentage of tokens that will be created. (100 * the bonus ratio)\n', '\n', '           @dev When < 2 million tokens purchased, this will be 125%, which is equivalent to a 20% discount\n', '           @dev When < 4 million tokens purchased, 118%, which is equivalent to a 15% discount.\n', '           @dev When < 6 million tokens purchased, 111%, which is equivalent to a 10% discount.\n', '           @dev When < 9 million tokens purchased, 105%, which is equivalent to a 5% discount.\n', '           @dev Otherwise, there is no bonus and the function returns 100%.\n', '        */\n', '        function currentBonusRate() public constant returns (uint) {\n', '                if(purchasedTokensRaised < (2 * oneTwelfthOfCap)) return 125/*.25*/; // 20% discount\n', '                if(purchasedTokensRaised < (4 * oneTwelfthOfCap)) return 118/*.1764705882352942*/; // 15% discount\n', '                if(purchasedTokensRaised < (6 * oneTwelfthOfCap)) return 111/*.1111111111111112*/; // 10% discount\n', '                if(purchasedTokensRaised < (9 * oneTwelfthOfCap)) return 105/*.0526315789473684*/; // 5% discount\n', '                return 100;\n', '        }\n', '}\n', '\n', 'contract TheZakemFansCrowdsale is ZakemFansCrowdsale {\n', '    function TheZakemFansCrowdsale()\n', '        ZakemFansCrowdsale(\n', '            1511380200, // _startTime time (Solidity UNIX timestamp) from when it is allowed to buy FINC.\n', '            1511384400, // _endTime time (Solidity UNIX timestamp) until which it is allowed to buy FINC. (Should be larger than startTime)\n', '            2, // _rate Number of tokens created per ether. (Since Ether and ZakemCoin use the same number of decimal places, this can be read as direct conversion rate of Ether -> ZakemCoin.)\n', '            0xd5D29f18B8C2C7157B6BF38111C9318b9604BdED, // _wallet The wallet of ZakemFans itself, to which some of the facilitating tokens will be sent.\n', '            0x6B1964119841f3f5363D7EA08120642FE487410E, // _bountiesWallet The wallet used to pay out bounties, to which some of the facilitating tokens will be sent.\n', '            0x9a123fDd708eD0931Fb4938C5b2E2462B6D23390, // _foundersWallet The wallet used for the founders, to which some of the facilitating tokens will be sent.\n', '            1e16, // _goal The minimum goal (in 1 * 10^(-18) tokens) that the Crowdsale needs to reach.\n', '            12e16, // _cap The maximum cap (in 1 * 10^(-18) tokens) that the Crowdsale can reach.\n', '            0xaaC5b7048114d70b759E9EA17AFA4Ff969931a4a, // _token The address where the ZakemCoin contract was deployed prior to creating this contract.\n', '            0  // _purchasedTokensRaisedDuringPresale The amount (in 1 * 18^18 tokens) that was purchased during the presale.\n', '            )\n', '    {\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(0x0, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract BurnableToken is StandardToken {\n', '\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', 'contract ApprovedBurnableToken is BurnableToken {\n', '\n', '        /**\n', '           Sent when `burner` burns some `value` of `owners` tokens.\n', '        */\n', '        event BurnFrom(address indexed owner, // The address whose tokens were burned.\n', '                       address indexed burner, // The address that executed the `burnFrom` call\n', '                       uint256 value           // The amount of tokens that were burned.\n', '                );\n', '\n', '        /**\n', '           @dev Burns a specific amount of tokens of another account that `msg.sender`\n', '           was approved to burn tokens for using `approveBurn` earlier.\n', '           @param _owner The address to burn tokens from.\n', '           @param _value The amount of token to be burned.\n', '        */\n', '        function burnFrom(address _owner, uint256 _value) public {\n', '                require(_value > 0);\n', '                require(_value <= balances[_owner]);\n', '                require(_value <= allowed[_owner][msg.sender]);\n', '                // no need to require value <= totalSupply, since that would imply the\n', "                // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '                address burner = msg.sender;\n', '                balances[_owner] = balances[_owner].sub(_value);\n', '                allowed[_owner][burner] = allowed[_owner][burner].sub(_value);\n', '                totalSupply = totalSupply.sub(_value);\n', '\n', '                BurnFrom(_owner, burner, _value);\n', '                Burn(_owner, _value);\n', '        }\n', '}\n', '\n', 'contract UnlockedAfterMintingToken is MintableToken {\n', '\n', '    /**\n', '       Ensures certain calls can only be made when minting is finished.\n', '\n', '       The calls that are restricted are any calls that allow direct or indirect transferral of funds.\n', '     */\n', '    modifier whenMintingFinished() {\n', '        require(mintingFinished);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public whenMintingFinished returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '      @dev Transfer tokens from one address to another\n', '      @param _from address The address which you want to send tokens from\n', '      @param _to address The address which you want to transfer to\n', '      @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenMintingFinished returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '      @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '      @dev NOTE: This call is considered deprecated, and only included for proper compliance with ERC20.\n', '      @dev Rather than use this call, use `increaseApproval` and `decreaseApproval` instead, whenever possible.\n', '      @dev The reason for this, is that using `approve` directly when your allowance is nonzero results in an exploitable situation:\n', '      @dev https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\n', '      @param _spender The address which will spend the funds.\n', '      @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public whenMintingFinished returns (bool) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    /**\n', '      @dev approve should only be called when allowed[_spender] == 0. To alter the\n', '      @dev allowed value it is better to use this function, because it is safer.\n', '      @dev (And making `approve` safe manually would require making two calls made in separate blocks.)\n', '\n', '      This method was adapted from the one in use by the MonolithDAO Token.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public whenMintingFinished returns (bool success) {\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    /**\n', '       @dev approve should only be called when allowed[_spender] == 0. To alter the\n', '       @dev allowed value it is better to use this function, because it is safer.\n', '       @dev (And making `approve` safe manually would require making two calls made in separate blocks.)\n', '\n', '       This method was adapted from the one in use by the MonolithDAO Token.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenMintingFinished returns (bool success) {\n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '\n', '    // TODO Prevent burning?\n', '}\n', '\n', 'contract ZakemCoin is UnlockedAfterMintingToken, ApprovedBurnableToken {\n', '        /**\n', '           @dev We do not expect this to change ever after deployment,\n', '           @dev but it is a way to identify different versions of the ZakemCoin during development.\n', '        */\n', '        uint8 public constant contractVersion = 1;\n', '\n', '        /**\n', '           @dev The name of the ZakemCoin, specified as indicated in ERC20.\n', '         */\n', '        string public constant name = "ZakemCoin";\n', '\n', '        /**\n', '           @dev The abbreviation FINC, specified as indicated in ERC20.\n', '        */\n', '        string public constant symbol = "FINC";\n', '\n', '        /**\n', '           @dev The smallest denomination of the ZakemCoin is 1 * 10^(-18) FINC. `decimals` is specified as indicated in ERC20.\n', '        */\n', '        uint8 public constant decimals = 18;\n', '\n', '        // TODO extractToken function to allow people to retrieve token-funds sent here by mistake?\n', '\n', '        // TODO ERC223-interface\n', '}']