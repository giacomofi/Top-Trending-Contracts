['pragma solidity ^0.4.15;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        if (a != 0 && c / a != b) revert();\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        if (b > a) revert();\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) revert();\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault.\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract IRBPreRefundVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State {Active, Refunding, Closed}\n', '    State public state;\n', '\n', '    mapping (address => uint256) public deposited;\n', '\n', '    uint256 public totalDeposited;\n', '\n', '    address public constant wallet = 0x26dB9eF39Bbfe437f5b384c3913E807e5633E7cE;\n', '\n', '    address preCrowdsaleContractAddress;\n', '\n', '    event Closed();\n', '\n', '    event RefundsEnabled();\n', '\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    event Withdrawal(address indexed receiver, uint256 weiAmount);\n', '\n', '    function IRBPreRefundVault() {\n', '        state = State.Active;\n', '    }\n', '\n', '    modifier onlyCrowdsaleContract() {\n', '        require(msg.sender == preCrowdsaleContractAddress);\n', '        _;\n', '    }\n', '\n', '    function setPreCrowdsaleAddress(address _preCrowdsaleAddress) external onlyOwner {\n', '        require(_preCrowdsaleAddress != address(0));\n', '        preCrowdsaleContractAddress = _preCrowdsaleAddress;\n', '    }\n', '\n', '    function deposit(address investor) onlyCrowdsaleContract external payable {\n', '        require(state == State.Active);\n', '        uint256 amount = msg.value;\n', '        deposited[investor] = deposited[investor].add(amount);\n', '        totalDeposited = totalDeposited.add(amount);\n', '    }\n', '\n', '    function close() onlyCrowdsaleContract external {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        totalDeposited = 0;\n', '        Closed();\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '    function enableRefunds() onlyCrowdsaleContract external {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        RefundsEnabled();\n', '    }\n', '\n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        Refunded(investor, depositedValue);\n', '    }\n', '\n', '    /**\n', "     * @dev withdraw method that can be used by crowdsale contract's owner\n", '     *      for the withdrawal funds to the owner\n', '     */\n', '    function withdraw(uint value) onlyCrowdsaleContract external returns (bool success) {\n', '        require(state == State.Active);\n', '        require(totalDeposited >= value);\n', '        totalDeposited = totalDeposited.sub(value);\n', '        wallet.transfer(value);\n', '        Withdrawal(wallet, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev killer method that can be used by owner to\n', '     *      kill the contract and send funds to owner\n', '     */\n', '    function kill() onlyOwner {\n', '        require(state == State.Closed);\n', '        selfdestruct(owner);\n', '    }\n', '}']