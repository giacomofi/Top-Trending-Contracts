['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract AbstractPaymentEscrow is Ownable {\n', '\n', '    address public wallet;\n', '\n', '    mapping (uint => uint) public deposits;\n', '\n', '    event Payment(address indexed _customer, uint indexed _projectId, uint value);\n', '    event Withdraw(address indexed _wallet, uint value);\n', '\n', '    function withdrawFunds() public;\n', '\n', '    /**\n', '     * @dev Change the wallet\n', '     * @param _wallet address of the wallet where fees will be transfered when spent\n', '     */\n', '    function changeWallet(address _wallet)\n', '        public\n', '        onlyOwner()\n', '    {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', "     * @dev Get the amount deposited for the provided project, returns 0 if there's no deposit for that project or the amount in wei\n", '     * @param _projectId The id of the project\n', "     * @return 0 if there's either no deposit for _projectId, otherwise returns the deposited amount in wei\n", '     */\n', '    function getDeposit(uint _projectId)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return deposits[_projectId];\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract TokitRegistry is Ownable {\n', '\n', '    struct ProjectContracts {\n', '        address token;\n', '        address fund;\n', '        address campaign;\n', '    }\n', '\n', '    // registrar => true/false\n', '    mapping (address => bool) public registrars;\n', '\n', '    // customer => project_id => token/campaign\n', '    mapping (address => mapping(uint => ProjectContracts)) public registry;\n', '    // project_id => token/campaign\n', '    mapping (uint => ProjectContracts) public project_registry;\n', '\n', '    event RegisteredToken(address indexed _projectOwner, uint indexed _projectId, address _token, address _fund);\n', '    event RegisteredCampaign(address indexed _projectOwner, uint indexed _projectId, address _campaign);\n', '\n', '    modifier onlyRegistrars() {\n', '        require(registrars[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function TokitRegistry(address _owner) {\n', '        setRegistrar(_owner, true);\n', '        transferOwnership(_owner);\n', '    }\n', '\n', '    function register(address _customer, uint _projectId, address _token, address _fund)\n', '        onlyRegistrars()\n', '    {\n', '        registry[_customer][_projectId].token = _token;\n', '        registry[_customer][_projectId].fund = _fund;\n', '\n', '        project_registry[_projectId].token = _token;\n', '        project_registry[_projectId].fund = _fund;\n', '\n', '        RegisteredToken(_customer, _projectId, _token, _fund);\n', '    }\n', '\n', '    function register(address _customer, uint _projectId, address _campaign)\n', '        onlyRegistrars()\n', '    {\n', '        registry[_customer][_projectId].campaign = _campaign;\n', '\n', '        project_registry[_projectId].campaign = _campaign;\n', '\n', '        RegisteredCampaign(_customer, _projectId, _campaign);\n', '    }\n', '\n', '    function lookup(address _customer, uint _projectId)\n', '        constant\n', '        returns (address token, address fund, address campaign)\n', '    {\n', '        return (\n', '            registry[_customer][_projectId].token,\n', '            registry[_customer][_projectId].fund,\n', '            registry[_customer][_projectId].campaign\n', '        );\n', '    }\n', '\n', '    function lookupByProject(uint _projectId)\n', '        constant\n', '        returns (address token, address fund, address campaign)\n', '    {\n', '        return (\n', '            project_registry[_projectId].token,\n', '            project_registry[_projectId].fund,\n', '            project_registry[_projectId].campaign\n', '        );\n', '    }\n', '\n', '    function setRegistrar(address _registrar, bool enabled)\n', '        onlyOwner()\n', '    {\n', '        registrars[_registrar] = enabled;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Fund contract - Implements reward distribution.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', '/// @author Milad Mostavi - <milad.mostavi@consensys.net>\n', 'contract SingularDTVFund {\n', '    string public version = "0.1.0";\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractSingularDTVToken public singularDTVToken;\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    uint public totalReward;\n', '\n', "    // User's address => Reward at time of withdraw\n", '    mapping (address => uint) public rewardAtTimeOfWithdraw;\n', '\n', "    // User's address => Reward which can be withdrawn\n", '    mapping (address => uint) public owed;\n', '\n', '    modifier onlyOwner() {\n', '        // Only guard is allowed to do this action.\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Contract functions\n', '     */\n', '    /// @dev Deposits reward. Returns success.\n', '    function depositReward()\n', '        public\n', '        payable\n', '        returns (bool)\n', '    {\n', '        totalReward += msg.value;\n', '        return true;\n', '    }\n', '\n', '    /// @dev Withdraws reward for user. Returns reward.\n', "    /// @param forAddress user's address.\n", '    function calcReward(address forAddress) private returns (uint) {\n', '        return singularDTVToken.balanceOf(forAddress) * (totalReward - rewardAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();\n', '    }\n', '\n', '    /// @dev Withdraws reward for user. Returns reward.\n', '    function withdrawReward()\n', '        public\n', '        returns (uint)\n', '    {\n', '        uint value = calcReward(msg.sender) + owed[msg.sender];\n', '        rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n', '        owed[msg.sender] = 0;\n', '        if (value > 0 && !msg.sender.send(value)) {\n', '            revert();\n', '        }\n', '        return value;\n', '    }\n', '\n', '    /// @dev Credits reward to owed balance.\n', "    /// @param forAddress user's address.\n", '    function softWithdrawRewardFor(address forAddress)\n', '        external\n', '        returns (uint)\n', '    {\n', '        uint value = calcReward(forAddress);\n', '        rewardAtTimeOfWithdraw[forAddress] = totalReward;\n', '        owed[forAddress] += value;\n', '        return value;\n', '    }\n', '\n', '    /// @dev Setup function sets external token address.\n', '    /// @param singularDTVTokenAddress Token address.\n', '    function setup(address singularDTVTokenAddress)\n', '        external\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        if (address(singularDTVToken) == 0) {\n', '            singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Contract constructor function sets guard address.\n', '    function SingularDTVFund() {\n', '        // Set owner address\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Fallback function acts as depositReward()\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        if (msg.value == 0) {\n', '            withdrawReward();\n', '        } else {\n', '            depositReward();\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        require(_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));\n', '        return true;\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '\n', '\n', 'contract AbstractSingularDTVFund {\n', '    function softWithdrawRewardFor(address forAddress) returns (uint);\n', '}\n', '\n', '/// @title Token contract - Implements token issuance.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', '/// @author Milad Mostavi - <milad.mostavi@consensys.net>\n', 'contract SingularDTVToken is StandardToken {\n', '    string public version = "0.1.0";\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractSingularDTVFund public singularDTVFund;\n', '\n', '    /*\n', '     *  Token meta data\n', '     */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 18;\n', '\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param to Address of token receiver.\n', '    /// @param value Number of tokens to transfer.\n', '    function transfer(address to, uint256 value)\n', '        returns (bool)\n', '    {\n', '        // Both parties withdraw their reward first\n', '        singularDTVFund.softWithdrawRewardFor(msg.sender);\n', '        singularDTVFund.softWithdrawRewardFor(to);\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param from Address from where tokens are withdrawn.\n', '    /// @param to Address to where tokens are sent.\n', '    /// @param value Number of tokens to transfer.\n', '    function transferFrom(address from, address to, uint256 value)\n', '        returns (bool)\n', '    {\n', '        // Both parties withdraw their reward first\n', '        singularDTVFund.softWithdrawRewardFor(from);\n', '        singularDTVFund.softWithdrawRewardFor(to);\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    function SingularDTVToken(address sDTVFundAddr, address _wallet, string _name, string _symbol, uint _totalSupply) {\n', '        if(sDTVFundAddr == 0 || _wallet == 0) {\n', '            // Fund and Wallet addresses should not be null.\n', '            revert();\n', '        }\n', '\n', '        balances[_wallet] = _totalSupply;\n', '        totalSupply = _totalSupply;\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '\n', '        singularDTVFund = AbstractSingularDTVFund(sDTVFundAddr);\n', '\n', '        Transfer(this, _wallet, _totalSupply);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AbstractSingularDTVToken is Token {\n', '\n', '}\n', '\n', '\n', '/// @title Token Creation contract - Implements token creation functionality.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', '/// @author Razvan Pop - <razvan.pop@consensys.net>\n', '/// @author Milad Mostavi - <milad.mostavi@consensys.net>\n', 'contract SingularDTVLaunch {\n', '    string public version = "0.1.0";\n', '\n', '    event Contributed(address indexed contributor, uint contribution, uint tokens);\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractSingularDTVToken public singularDTVToken;\n', '    address public workshop;\n', '    address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n', '    uint public SingularDTVWorkshopFee;\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    uint public CAP; // in wei scale of tokens\n', '    uint public DURATION; // in seconds\n', '    uint public TOKEN_TARGET; // Goal threshold in wei scale of tokens\n', '\n', '    /*\n', '     *  Enums\n', '     */\n', '    enum Stages {\n', '        Deployed,\n', '        GoingAndGoalNotReached,\n', '        EndedAndGoalNotReached,\n', '        GoingAndGoalReached,\n', '        EndedAndGoalReached\n', '    }\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    uint public startDate;\n', '    uint public fundBalance;\n', '    uint public valuePerToken; //in wei\n', '    uint public tokensSent;\n', '\n', '    // participant address => value in Wei\n', '    mapping (address => uint) public contributions;\n', '\n', '    // participant address => token amount in wei scale\n', '    mapping (address => uint) public sentTokens;\n', '\n', '    // Initialize stage\n', '    Stages public stage = Stages.Deployed;\n', '\n', '    modifier onlyOwner() {\n', '        // Only owner is allowed to do this action.\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier atStage(Stages _stage) {\n', '        if (stage != _stage) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier atStageOR(Stages _stage1, Stages _stage2) {\n', '        if (stage != _stage1 && stage != _stage2) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier timedTransitions() {\n', '        uint timeElapsed = now - startDate;\n', '\n', '        if (timeElapsed >= DURATION) {\n', '            if (stage == Stages.GoingAndGoalNotReached) {\n', '                stage = Stages.EndedAndGoalNotReached;\n', '            } else if (stage == Stages.GoingAndGoalReached) {\n', '                stage = Stages.EndedAndGoalReached;\n', '            }\n', '        }\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Contract functions\n', '     */\n', '    /// dev Validates invariants.\n', '    function checkInvariants() constant internal {\n', '        if (fundBalance > this.balance) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Can be triggered if an invariant fails.\n', '    function emergencyCall()\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (fundBalance > this.balance) {\n', '            if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n', '                revert();\n', '            }\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Allows user to create tokens if token creation is still going and cap not reached. Returns token count.\n', '    function fund()\n', '        public\n', '        timedTransitions\n', '        atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n', '        payable\n', '        returns (uint)\n', '    {\n', '        uint tokenCount = (msg.value * (10**18)) / valuePerToken; // Token count in wei is rounded down. Sent ETH should be multiples of valuePerToken.\n', '        require(tokenCount > 0);\n', '        if (tokensSent + tokenCount > CAP) {\n', '            // User wants to create more tokens than available. Set tokens to possible maximum.\n', '            tokenCount = CAP - tokensSent;\n', '        }\n', '        tokensSent += tokenCount;\n', '\n', '        uint contribution = (tokenCount * valuePerToken) / (10**18); // Ether spent by user.\n', '        // Send change back to user.\n', '        if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n', '            revert();\n', '        }\n', "        // Update fund and user's balance and total supply of tokens.\n", '        fundBalance += contribution;\n', '        contributions[msg.sender] += contribution;\n', '        sentTokens[msg.sender] += tokenCount;\n', '        if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n', '            // Tokens could not be issued.\n', '            revert();\n', '        }\n', '        // Update stage\n', '        if (stage == Stages.GoingAndGoalNotReached) {\n', '            if (tokensSent >= TOKEN_TARGET) {\n', '                stage = Stages.GoingAndGoalReached;\n', '            }\n', '        }\n', '        // not an else clause for the edge case that the CAP and TOKEN_TARGET are reached in one call\n', '        if (stage == Stages.GoingAndGoalReached) {\n', '            if (tokensSent == CAP) {\n', '                stage = Stages.EndedAndGoalReached;\n', '            }\n', '        }\n', '        checkInvariants();\n', '\n', '        Contributed(msg.sender, contribution, tokenCount);\n', '\n', '        return tokenCount;\n', '    }\n', '\n', '    /// @dev Allows user to withdraw ETH if token creation period ended and target was not reached. Returns contribution.\n', '    function withdrawContribution()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalNotReached)\n', '        returns (uint)\n', '    {\n', '        // We get back the tokens from the contributor before giving back his contribution\n', '        uint tokensReceived = sentTokens[msg.sender];\n', '        sentTokens[msg.sender] = 0;\n', '        if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n', '            revert();\n', '        }\n', '\n', "        // Update fund's and user's balance and total supply of tokens.\n", '        uint contribution = contributions[msg.sender];\n', '        contributions[msg.sender] = 0;\n', '        fundBalance -= contribution;\n', '        // Send ETH back to user.\n', '        if (contribution > 0) {\n', '            msg.sender.transfer(contribution);\n', '        }\n', '        checkInvariants();\n', '        return contribution;\n', '    }\n', '\n', '    /// @dev Withdraws ETH to workshop address. Returns success.\n', '    function withdrawForWorkshop()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalReached)\n', '        returns (bool)\n', '    {\n', '        uint value = fundBalance;\n', '        fundBalance = 0;\n', '\n', '        require(value > 0);\n', '\n', '        uint networkFee = value * SingularDTVWorkshopFee / 100;\n', '        workshop.transfer(value - networkFee);\n', '        SingularDTVWorkshop.transfer(networkFee);\n', '\n', '        uint remainingTokens = CAP - tokensSent;\n', '        if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n', '            revert();\n', '        }\n', '\n', '        checkInvariants();\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows owner to get back unsent tokens in case of launch failure (EndedAndGoalNotReached).\n', '    function withdrawUnsentTokensForOwner()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalNotReached)\n', '        returns (uint)\n', '    {\n', '        uint remainingTokens = CAP - tokensSent;\n', '        if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n', '            revert();\n', '        }\n', '\n', '        checkInvariants();\n', '        return remainingTokens;\n', '    }\n', '\n', '    /// @dev Sets token value in Wei.\n', '    /// @param valueInWei New value.\n', '    function changeValuePerToken(uint valueInWei)\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.Deployed)\n', '        returns (bool)\n', '    {\n', '        valuePerToken = valueInWei;\n', '        return true;\n', '    }\n', '\n', '    // updateStage allows calls to receive correct stage. It can be used for transactions but is not part of the regular token creation routine.\n', '    // It is not marked as constant because timedTransitions modifier is altering state and constant is not yet enforced by solc.\n', '    /// @dev returns correct stage, even if a function with timedTransitions modifier has not yet been called successfully.\n', '    function updateStage()\n', '        public\n', '        timedTransitions\n', '        returns (Stages)\n', '    {\n', '        return stage;\n', '    }\n', '\n', '    function start()\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.Deployed)\n', '        returns (uint)\n', '    {\n', '        if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n', '            revert();\n', '        }\n', '\n', '        startDate = now;\n', '        stage = Stages.GoingAndGoalNotReached;\n', '\n', '        checkInvariants();\n', '        return startDate;\n', '    }\n', '\n', '    /// @dev Contract constructor function sets owner and start date.\n', '    function SingularDTVLaunch(\n', '        address singularDTVTokenAddress,\n', '        address _workshop,\n', '        address _owner,\n', '        uint _total,\n', '        uint _unit_price,\n', '        uint _duration,\n', '        uint _threshold,\n', '        uint _singulardtvwoskhop_fee\n', '        ) {\n', '        singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n', '        workshop = _workshop;\n', '        owner = _owner;\n', '        CAP = _total; // Total number of tokens (wei scale)\n', '        valuePerToken = _unit_price; // wei per token\n', '        DURATION = _duration; // in seconds\n', '        TOKEN_TARGET = _threshold; // Goal threshold\n', '        SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n', '    }\n', '\n', '    /// @dev Fallback function acts as fund() when stage GoingAndGoalNotReached\n', '    /// or GoingAndGoalReached. And act as withdrawFunding() when EndedAndGoalNotReached.\n', '    /// otherwise throw.\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n', '            fund();\n', '        else if (stage == Stages.EndedAndGoalNotReached)\n', '            withdrawContribution();\n', '        else\n', '            revert();\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokitDeployer is Ownable {\n', '\n', '    TokitRegistry public registry;\n', '\n', '    // payment_type => payment_contract\n', '    mapping (uint8 => AbstractPaymentEscrow) public paymentContracts;\n', '\n', '    event DeployedToken(address indexed _customer, uint indexed _projectId, address _token, address _fund);\n', '    event DeployedCampaign(address indexed _customer, uint indexed _projectId, address _campaign);\n', '\n', '\n', '    function TokitDeployer(address _owner, address _registry) {\n', '        transferOwnership(_owner);\n', '        registry = TokitRegistry(_registry);\n', '    }\n', '\n', '    function deployToken(\n', '        address _customer, uint _projectId, uint8 _payedWith, uint _amountNeeded,\n', '        // SingularDTVToken\n', '        address _wallet, string _name, string _symbol, uint _totalSupply\n', '    )\n', '        onlyOwner()\n', '    {\n', '        // payed for\n', '        require(AbstractPaymentEscrow(paymentContracts[_payedWith]).getDeposit(_projectId) >= _amountNeeded);\n', '\n', '        var (t,,) = registry.lookup(_customer, _projectId);\n', '        // not deployed yet\n', '        require(t == address(0));\n', '\n', '\n', '        SingularDTVFund fund = new SingularDTVFund();\n', '        SingularDTVToken token = new SingularDTVToken(fund, _wallet, _name, _symbol, _totalSupply);\n', '        fund.setup(token);\n', '\n', '        registry.register(_customer, _projectId, token, fund);\n', '\n', '        DeployedToken(_customer, _projectId, token, fund);\n', '    }\n', '\n', '    function deployCampaign(\n', '        address _customer, uint _projectId,\n', '        // SingularDTVLaunch\n', '        address _workshop, uint _total, uint _unitPrice, uint _duration, uint _threshold, uint _networkFee\n', '    )\n', '        onlyOwner()\n', '    {\n', '        var (t,f,c) = registry.lookup(_customer, _projectId);\n', '        // not deployed yet\n', '        require(c == address(0));\n', '\n', '        // payed for, token & fund deployed\n', '        require(t != address(0) && f != address(0));\n', '\n', '        SingularDTVLaunch campaign = new SingularDTVLaunch(t, _workshop, _customer, _total, _unitPrice, _duration, _threshold, _networkFee);\n', '\n', '        registry.register(_customer, _projectId, campaign);\n', '\n', '        DeployedCampaign(_customer, _projectId, campaign);\n', '    }\n', '\n', '    function setRegistryContract(address _registry)\n', '        onlyOwner()\n', '    {\n', '        registry = TokitRegistry(_registry);\n', '    }\n', '\n', '    function setPaymentContract(uint8 _paymentType, address _paymentContract)\n', '        onlyOwner()\n', '    {\n', '        paymentContracts[_paymentType] = AbstractPaymentEscrow(_paymentContract);\n', '    }\n', '\n', '    function deletePaymentContract(uint8 _paymentType)\n', '        onlyOwner()\n', '    {\n', '        delete paymentContracts[_paymentType];\n', '    }\n', '}']