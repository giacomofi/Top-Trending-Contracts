['pragma solidity ^0.4.11;\n', 'contract simplelottery {\n', '    enum State { Started, Locked }\n', '    State public state = State.Started;\n', '    struct Guess{\n', '      address addr;\n', '      //uint    guess;\n', '    }\n', '    uint arraysize=1000;\n', '    uint constant maxguess=1000000;\n', '    uint bettingprice = 1 ether;\n', '    Guess[1000] guesses;\n', '    uint    numguesses = 0;\n', "    bytes32 curhash = '';\n", '    uint _gameindex = 1;\n', '    uint _starttime = 0;\n', '    modifier inState(State _state) {\n', '      require(state == _state);\n', '      _;\n', '    }\n', '    address developer = 0x0;\n', '    address _winner   = 0x0;\n', '    event SentPrizeToWinner(address winner, uint money, uint gameindex, uint lotterynumber, uint starttime, uint finishtime);\n', '    event SentDeveloperFee(uint amount, uint balance);\n', '    \n', '    function simplelottery() \n', '    {\n', '      if(developer==address(0)){\n', '        developer = msg.sender;\n', '        state = State.Started;\n', '        _starttime = block.timestamp;\n', '      }\n', '    }\n', '    \n', '    function setBettingCondition(uint _contenders, uint _bettingprice)\n', '    {\n', '      if(msg.sender != developer)\n', '        return;\n', '      arraysize  = _contenders;\n', '      if(arraysize>1000)\n', '        arraysize = 1000;\n', '      bettingprice = _bettingprice;\n', '    }\n', '    \n', '    function findWinner(uint value)\n', '    {\n', '      uint i = value % numguesses;\n', '      _winner = guesses[i].addr;\n', '    }\n', '    \n', '      function getMaxContenders() constant returns(uint){\n', '      return arraysize;\n', '    }\n', '\n', '    function getBettingPrice() constant returns(uint){\n', '      return bettingprice;\n', '    }\n', '\n', '    function getDeveloperAddress() constant returns(address)\n', '    {\n', '      return developer;\n', '    }\n', '    \n', '    function getDeveloperFee() constant returns(uint)\n', '    {\n', '      uint developerfee = this.balance/100;\n', '      return developerfee;\n', '    }\n', '    \n', '    function getBalance() constant returns(uint)\n', '    {\n', '       return this.balance;\n', '    }\n', '    \n', '    function getLotteryMoney() constant returns(uint)\n', '    {\n', '      uint developerfee = getDeveloperFee();\n', '      uint prize = (this.balance - developerfee);\n', '      return prize;\n', '    }\n', '\n', '    function getBettingStatus()\n', '      constant\n', '      returns (uint, uint, uint, uint, uint, uint, uint)\n', '    {\n', '      return ((uint)(state), _gameindex, _starttime, numguesses, getLotteryMoney(), this.balance, bettingprice);\n', '    }\n', '\n', '\n', '\n', '    function finish()\n', '    {\n', '      if(msg.sender != developer)\n', '        return;\n', '      _finish();\n', '    }\n', '    \n', '    function _finish() private\n', '    {\n', '      state = State.Locked;\n', '      uint block_timestamp = block.timestamp;\n', '      uint lotterynumber = (uint(curhash)+block_timestamp)%(maxguess+1);\n', '      findWinner(lotterynumber);\n', '      uint prize = getLotteryMoney();\n', '      uint numwinners = 1;\n', '      uint remain = this.balance - (prize*numwinners);\n', '\n', '      _winner.transfer(prize);\n', '      SentPrizeToWinner(_winner, prize, _gameindex, lotterynumber, _starttime, block_timestamp);\n', '\n', '      // give delveoper the money left behind\n', '      developer.transfer(remain); \n', '      SentDeveloperFee(remain, this.balance);\n', '      numguesses = 0;\n', '      _gameindex++;\n', '      state = State.Started;\n', '      _starttime = block.timestamp;\n', '    }\n', '    \n', '    function () payable\n', '    {\n', '        _addguess();\n', '    }\n', '\n', '    function addguess() \n', '      inState(State.Started)\n', '      payable\n', '    {\n', '      _addguess();\n', '    }\n', '    \n', '    function _addguess() private\n', '      inState(State.Started)\n', '    {\n', '      require(msg.value >= bettingprice);\n', '      curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);\n', '      if((uint)(numguesses+1)<=arraysize) {\n', '        guesses[numguesses++].addr = msg.sender;\n', '        if((uint)(numguesses)>=arraysize){\n', '          _finish();\n', '        }\n', '      }\n', '    }\n', '}']