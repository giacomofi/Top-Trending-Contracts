['pragma solidity ^0.4.15;\n', '\n', 'contract Controllable {\n', '  address public controller;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  function Controllable() public {\n', '    controller = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyController() {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newController The address to transfer ownership to.\n', '   */\n', '  function transferControl(address newController) public onlyController {\n', '    if (newController != address(0)) {\n', '      controller = newController;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  function Pausable() public {}\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract TokenSale is Pausable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  ProofTokenInterface public proofToken;\n', '  uint256 public totalWeiRaised;\n', '  uint256 public tokensMinted;\n', '  uint256 public totalSupply;\n', '  uint256 public contributors;\n', '  uint256 public decimalsMultiplier;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public remainingTokens;\n', '  uint256 public allocatedTokens;\n', '\n', '  bool public finalized;\n', '\n', '  bool public proofTokensAllocated;\n', '  address public proofMultiSig = 0x99892Ac6DA1b3851167Cb959fE945926bca89f09;\n', '\n', '  uint256 public constant BASE_PRICE_IN_WEI = 88000000000000000;\n', '  uint256 public constant PUBLIC_TOKENS = 1181031 * (10 ** 18);\n', '  uint256 public constant TOTAL_PRESALE_TOKENS = 112386712924725508802400;\n', '  uint256 public constant TOKENS_ALLOCATED_TO_PROOF = 1181031 * (10 ** 18);\n', '\n', '\n', '\n', '  uint256 public tokenCap = PUBLIC_TOKENS - TOTAL_PRESALE_TOKENS;\n', '  uint256 public cap = tokenCap / (10 ** 18);\n', '  uint256 public weiCap = cap * BASE_PRICE_IN_WEI;\n', '\n', '  uint256 public firstDiscountPrice = (BASE_PRICE_IN_WEI * 85) / 100;\n', '  uint256 public secondDiscountPrice = (BASE_PRICE_IN_WEI * 90) / 100;\n', '  uint256 public thirdDiscountPrice = (BASE_PRICE_IN_WEI * 95) / 100;\n', '\n', '  uint256 public firstDiscountCap = (weiCap * 5) / 100;\n', '  uint256 public secondDiscountCap = (weiCap * 10) / 100;\n', '  uint256 public thirdDiscountCap = (weiCap * 20) / 100;\n', '\n', '  bool public started = false;\n', '\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  event NewClonedToken(address indexed _cloneToken);\n', '  event OnTransfer(address _from, address _to, uint _amount);\n', '  event OnApprove(address _owner, address _spender, uint _amount);\n', '  event LogInt(string _name, uint256 _value);\n', '  event Finalized();\n', '\n', '  function TokenSale(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n', '    require(_tokenAddress != 0x0);\n', '    require(_startTime > 0);\n', '    require(_endTime > _startTime);\n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    proofToken = ProofTokenInterface(_tokenAddress);\n', '\n', '    decimalsMultiplier = (10 ** 18);\n', '  }\n', '\n', '\n', '  /**\n', '   * High level token purchase function\n', '   */\n', '  function() public payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Low level token purchase function\n', '   * @param _beneficiary will receive the tokens.\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n', '    require(_beneficiary != 0x0);\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '    uint256 priceInWei = getPriceInWei();\n', '    totalWeiRaised = totalWeiRaised.add(weiAmount);\n', '\n', '    uint256 tokens = weiAmount.mul(decimalsMultiplier).div(priceInWei);\n', '    tokensMinted = tokensMinted.add(tokens);\n', '    require(tokensMinted < tokenCap);\n', '\n', '    contributors = contributors.add(1);\n', '\n', '    proofToken.mint(_beneficiary, tokens);\n', '    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    forwardFunds();\n', '  }\n', '\n', '\n', '  /**\n', '   * Get the price in wei for current premium\n', '   * @return price {uint256}\n', '   */\n', '  function getPriceInWei() constant public returns (uint256) {\n', '\n', '    uint256 price;\n', '\n', '    if (totalWeiRaised < firstDiscountCap) {\n', '      price = firstDiscountPrice;\n', '    } else if (totalWeiRaised < secondDiscountCap) {\n', '      price = secondDiscountPrice;\n', '    } else if (totalWeiRaised < thirdDiscountCap) {\n', '      price = thirdDiscountPrice;\n', '    } else {\n', '      price = BASE_PRICE_IN_WEI;\n', '    }\n', '\n', '    return price;\n', '  }\n', '\n', '  /**\n', '  * Forwards funds to the tokensale wallet\n', '  */\n', '  function forwardFunds() internal {\n', '    proofMultiSig.transfer(msg.value);\n', '  }\n', '\n', '\n', '  /**\n', '  * Validates the purchase (period, minimum amount, within cap)\n', '  * @return {bool} valid\n', '  */\n', '  function validPurchase() internal constant returns (bool) {\n', '    uint256 current = now;\n', '    bool presaleStarted = (current >= startTime || started);\n', '    bool presaleNotEnded = current <= endTime;\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    return nonZeroPurchase && presaleStarted && presaleNotEnded;\n', '  }\n', '\n', '  /**\n', '  * Returns the total Proof token supply\n', '  * @return totalSupply {uint256} Proof Token Total Supply\n', '  */\n', '  function totalSupply() public constant returns (uint256) {\n', '    return proofToken.totalSupply();\n', '  }\n', '\n', '  /**\n', '  * Returns token holder Proof Token balance\n', '  * @param _owner {address} Token holder address\n', '  * @return balance {uint256} Corresponding token holder balance\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256) {\n', '    return proofToken.balanceOf(_owner);\n', '  }\n', '\n', '  /**\n', '  * Change the Proof Token controller\n', '  * @param _newController {address} New Proof Token controller\n', '  */\n', '  function changeController(address _newController) public {\n', '    require(isContract(_newController));\n', '    proofToken.transferControl(_newController);\n', '  }\n', '\n', '\n', '  function enableTransfers() public {\n', '    if (now < endTime) {\n', '      require(msg.sender == owner);\n', '    }\n', '    proofToken.enableTransfers(true);\n', '  }\n', '\n', '  function lockTransfers() public onlyOwner {\n', '    require(now < endTime);\n', '    proofToken.enableTransfers(false);\n', '  }\n', '\n', '  function enableMasterTransfers() public onlyOwner {\n', '    proofToken.enableMasterTransfers(true);\n', '  }\n', '\n', '  function lockMasterTransfers() public onlyOwner {\n', '    proofToken.enableMasterTransfers(false);\n', '  }\n', '\n', '  function forceStart() public onlyOwner {\n', '    started = true;\n', '  }\n', '\n', '  function allocateProofTokens() public onlyOwner whenNotFinalized {\n', '    proofToken.mint(proofMultiSig, TOKENS_ALLOCATED_TO_PROOF);\n', '    proofTokensAllocated = true;\n', '  }\n', '\n', '  function finalize() public onlyOwner {\n', '    require(paused);\n', '    require(proofTokensAllocated);\n', '\n', '    proofToken.finishMinting();\n', '    proofToken.enableTransfers(true);\n', '    Finalized();\n', '\n', '    finalized = true;\n', '  }\n', '\n', '\n', '  function isContract(address _addr) constant internal returns(bool) {\n', '    uint size;\n', '    if (_addr == 0)\n', '      return false;\n', '    assembly {\n', '        size := extcodesize(_addr)\n', '    }\n', '    return size>0;\n', '  }\n', '\n', '  modifier whenNotFinalized() {\n', '    require(!finalized);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract ProofTokenInterface is Controllable {\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n', '  function transfer(address _to, uint256 _amount) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n', '  function approve(address _spender, uint256 _amount) public returns (bool success);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  function mint(address _owner, uint _amount) public returns (bool);\n', '  function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool);\n', '  function lockPresaleBalances() public returns (bool);\n', '  function finishMinting() public returns (bool);\n', '  function enableTransfers(bool _value) public;\n', '  function enableMasterTransfers(bool _value) public;\n', '  function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address);\n', '\n', '}']