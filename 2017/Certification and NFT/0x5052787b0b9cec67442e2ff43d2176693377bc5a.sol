['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * Pulsar token contract.\n', ' * Date: 2017-11-14.\n', ' */\n', '\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;   // The owner of the contract\n', '\n', '  event OwnershipTransferred ( address indexed prev_owner, address indexed new_owner );\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership (address new_owner) onlyOwner public {\n', '    require(new_owner != address(0));\n', '    OwnershipTransferred(owner, new_owner);\n', '    owner = new_owner;\n', '  }\n', '\n', '\n', '} // Ownable\n', '\n', '\n', '/******************************************/\n', '/*       PULSAR TOKEN STARTS HERE         */\n', '/******************************************/\n', '\n', 'contract PulsarToken is Ownable {\n', '\n', '  /******** Public constants ********/\n', '\n', '  // Token decimal scale is the same as Ether to Wei scale = 10^18 (18 decimal digits)\n', '  uint public constant TOKEN_SCALE = 1 ether / 1 wei; // (10 ** 18)\n', '\n', '  // Total amount of tokens\n', '  uint public constant TOTAL_SUPPLY = 34540000 * TOKEN_SCALE;\n', '\n', '  // 2017-11-13 08:13:00 UTC = 00:13:00 PST\n', '  uint public constant ICO_START_TIME = 1510560780;\n', '\n', '  // Minimum accepted contribution is 0.1 Ether\n', '  uint public constant MIN_ACCEPTED_VALUE = 100000000000000000 wei; // 0.1 ether\n', '\n', '  // Minimum buyback amount of tokens\n', '  uint public constant MIN_BUYBACK_VALUE = 1 * TOKEN_SCALE;\n', '\n', '  // Public identifiers of the token\n', '  string public constant NAME = "Pulsar";       // token name\n', '  string public constant SYMBOL = "PVC";        // token symbol\n', '\n', '\n', '  /**\n', '   * Contract state machine.                           _____________\n', '   *                                                  ↓             |\n', '   * Deployed -> ICOStarted -> ICOStopped -> BuybackEnabled -> BuybackPaused -> Destroyed.\n', '   */\n', '  enum ContractState { Deployed, ICOStarted, ICOStopped, BuybackEnabled, BuybackPaused, Destroyed }\n', '\n', '  // Current state of the contract\n', '  ContractState private contractState = ContractState.Deployed;\n', '\n', '  // Contract state change event\n', '  event State ( ContractState state );\n', '\n', '  // This generates a public event on the blockchain that will notify clients\n', '  event Transfer ( address indexed from, address indexed to, uint value );\n', '\n', '\n', '  /******** Public variables *********/\n', '\n', '  // This creates an array with all balances\n', '  mapping (address => uint) public balanceOf;\n', '\n', '  // Reserved bounty tokens\n', '  uint public bountyTokens = 40000 * TOKEN_SCALE;\n', '\n', '  // Selling price of tokens in Wei\n', '  uint public sellingPrice = 0;\n', '\n', '  // Buyback price of tokens in Wei\n', '  uint public buybackPrice = 0;\n', '\n', '  // Amount of Ether the contract ever received\n', '  uint public etherAccumulator = 0;\n', '\n', '  // ICO start time\n', '  uint public icoStartTime = ICO_START_TIME;\n', '\n', '  // Trusted (authorized) sender of tokens\n', '  address public trustedSender = address(0);\n', '\n', '\n', '  /******** Private variables ********/\n', '\n', '  uint8[4] private bonuses = [ uint8(15), uint8(10), uint8(5), uint8(3) ];  // these are percents\n', '  uint[4]  private staging = [ 1 weeks,   2 weeks,   3 weeks,  4 weeks ];   // timeframe when the bonuses are effective\n', '\n', '\n', '  /**\n', '   * The constructor initializes the contract.\n', '   */\n', '  function PulsarToken() public\n', '  {\n', '    // intentionally left empty\n', '  }\n', '\n', '\n', '  /******** Helper functions ********/\n', '\n', '  /* Calculate current bonus percent. */\n', '  function calcBonusPercent() public view returns (uint8) {\n', '    uint8 _bonus = 0;\n', '    uint _elapsed = now - icoStartTime;\n', '\n', '    for (uint8 i = 0; i < staging.length; i++) {\n', '      if (_elapsed <= staging[i]) {\n', '          _bonus = bonuses[i];\n', '          break;\n', '      }\n', '    }\n', '    return _bonus;\n', '  }\n', '\n', '  /* Add bonus to the amount, for example 200 + 15% bonus = 230. */\n', '  function calcAmountWithBonus(uint token_value, uint8 bonus) public view returns (uint) {\n', '    return  (token_value * (100 + bonus)) / 100;\n', '  }\n', '\n', '  /* Convert amount in Wei to tokens. */\n', '  function calcEthersToTokens(uint ether_value, uint8 bonus) public view returns (uint) {\n', '    return calcAmountWithBonus(TOKEN_SCALE * ether_value/sellingPrice, bonus);\n', '  }\n', '\n', '  /* Convert amount in tokens to Wei. */\n', '  function calcTokensToEthers(uint token_value) public view returns (uint) {\n', '      return (buybackPrice * token_value) / TOKEN_SCALE;\n', '  }\n', '\n', '  /**\n', '   * Internal transfer of tokens, only can be called from within this contract.\n', '   *\n', '   * @param _from   Source address\n', '   * @param _to     Destination address\n', '   * @param _value  Amount of tokens (do not forget to multiply by scale 10^18)\n', '   */\n', '  function _transfer(address _from, address _to, uint _value) internal\n', '  {\n', '    require(_to != address(0x0));                       // prevent transfer to 0x0 address\n', '    require(_value > 0);                                // check if the value is greater than zero\n', '    require(balanceOf[_from] >= _value);                // check if the sender has enough tokens\n', '    require(balanceOf[_to] + _value > balanceOf[_to]);  // check for overflows\n', '\n', '    balanceOf[_from]  -= _value;                        // subtract from the sender\n', '    balanceOf[_to]    += _value;                        // add the same to the recipient\n', '\n', '    Transfer(_from, _to, _value);                       // fire the event\n', '  }\n', '\n', '\n', '  /************************* Public interface ********************************/\n', '\n', '  /**\n', '   * View current state of the contract.\n', '   *\n', '   * Returns: Current state of the contract as uint8, starting from 0.\n', '   */\n', '  function getContractState() public view returns (uint8) {\n', '    return uint8(contractState);\n', '  }\n', '\n', '  /**\n', '   * View current token balance of the contract.\n', '   *\n', '   * Returns: Current amount of tokens in the contract.\n', '   */\n', '  function getContractTokenBalance() public view returns (uint) {\n', '    return balanceOf[this];\n', '  }\n', '\n', '  /**\n', '   * View current token balance of the given address.\n', '   *\n', '   * Returns: Current amount of tokens hold by the address\n', '   *\n', '   * @param holder_address Holder of tokens\n', '   */\n', '  function getTokenBalance(address holder_address) public view returns (uint) {\n', '    require(holder_address != address(0));\n', '    return balanceOf[holder_address];\n', '  }\n', '\n', '  /**\n', '   * View total amount of currently distributed tokens.\n', '   *\n', '   * Returns: Total amount of distributed tokens.\n', '   */\n', '  function getDistributedTokens() public view returns (uint) {\n', '      return TOTAL_SUPPLY - balanceOf[this];\n', '  }\n', '\n', '  /**\n', '   * View current Ether balance of the contract.\n', '   *\n', "   * Returns: Current amount of Wei at the contract's address.\n", '   */\n', '  function getContractEtherBalance() public view returns (uint) {\n', '    return this.balance;\n', '  }\n', '\n', '  /**\n', '   * View current Ether balance of the given address.\n', '   *\n', '   * Returns: Current amount of Wei at the given address.\n', '   */\n', '  function getEtherBalance(address holder_address) public view returns (uint) {\n', '    require(holder_address != address(0));\n', '    return holder_address.balance;\n', '  }\n', '\n', '\n', '  /**\n', '   * Buy tokens for Ether.\n', '   * State must be only ICOStarted.\n', '   */\n', '  function invest() public payable\n', '  {\n', '    require(contractState == ContractState.ICOStarted);   // check state\n', '    require(now >= icoStartTime);                         // check time\n', '    require(msg.value >= MIN_ACCEPTED_VALUE);             // check amount of contribution\n', '\n', '    uint8 _bonus  = calcBonusPercent();\n', '    uint  _tokens = calcEthersToTokens(msg.value, _bonus);\n', '\n', '    require(balanceOf[this] >= _tokens);                  // check amount of tokens\n', '\n', '    _transfer(this, msg.sender, _tokens);                 // tranfer tokens to the investor\n', '\n', '    etherAccumulator += msg.value;      // finally update the counter of received Ether\n', '  }\n', '\n', '\n', '  // Default fallback function handles sending Ether to the contract.\n', '  function () public payable {\n', '    invest();\n', '  }\n', '\n', '  /**\n', '   * Token holders withdraw Ether in exchange of their tokens.\n', '   * \n', '   * @param token_value Amount of tokens being returned (do not forget to multiply by scale 10^18)\n', '   */\n', '  function buyback(uint token_value) public\n', '  {\n', '    require(contractState == ContractState.BuybackEnabled);   // check current state\n', '    require(buybackPrice > 0);                                // buyback price must be set\n', '    require(token_value >= MIN_BUYBACK_VALUE);                // minimum allowed amount of tokens\n', "    require(msg.sender != owner);                             // the owner can't buyback\n", '\n', '    uint _ethers = calcTokensToEthers(token_value);\n', '\n', '    // Check if the contract has enough ether to buyback the tokens\n', '    require(this.balance >= _ethers);\n', '\n', '    // Transfer the tokens back to the contract\n', '    _transfer(msg.sender, this, token_value);\n', '\n', "    // Send ether to the seller. It's important to do this last to avoid recursion attacks.\n", '    msg.sender.transfer(_ethers);\n', '  }\n', '\n', "  /************************** Owner's interface *****************************/\n", '\n', '  /**\n', '   * Set ICO start time\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param start_time New start time as number of seconds from Unix Epoch\n', '   */\n', '  function setICOStartTime(uint start_time) onlyOwner external {\n', '    icoStartTime = start_time;\n', '  }\n', '\n', '  /**\n', '   * Set token selling price in Wei.\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param selling_price New selling price in Wei\n', '   */\n', '  function setSellingPrice(uint selling_price) onlyOwner public {\n', '    require(selling_price != 0);\n', '    sellingPrice = selling_price;\n', '  }\n', '\n', '  /**\n', '   * Start selling tokens.\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param selling_price New selling price in Wei\n', '   */\n', '  function startICO(uint selling_price) onlyOwner external {\n', '    require(contractState == ContractState.Deployed);\n', '    setSellingPrice(selling_price);\n', '\n', '    balanceOf[this] = TOTAL_SUPPLY;\n', '\n', '    contractState = ContractState.ICOStarted;\n', '    State(contractState);\n', '  }\n', '\n', '  /**\n', '   * Stop selling tokens.\n', '   * Restricted to the owner.\n', '   */\n', '  function stopICO() onlyOwner external {\n', '    require(contractState == ContractState.ICOStarted);\n', '\n', '    contractState = ContractState.ICOStopped;\n', '    State(contractState);\n', '  }\n', '\n', '  /**\n', '   * Transfer Ether from the contract to the owner.\n', '   * Restricted to the owner.\n', '   *\n', '   * @param ether_value Amount in Wei\n', '   */\n', '  function transferEthersToOwner(uint ether_value) onlyOwner external {\n', '    require(this.balance >= ether_value);\n', '    msg.sender.transfer(ether_value);\n', '  }\n', '\n', '  /**\n', '   * Set the trusted sender of tokens.\n', '   * Pass (0) to remove the truster sender.\n', '   * Restricted to the owner.\n', '   *\n', '   * @param trusted_address New trusted sender\n', '   */\n', '  function setTrustedSender(address trusted_address) onlyOwner external {\n', '    trustedSender = trusted_address;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens to an address.\n', '   * Restricted to the owner or to the trusted address.\n', '   *\n', '   * @param recipient_address Recipient address\n', '   * @param token_value Amount of tokens (do not forget to multiply by scale 10^18)\n', '   */\n', '  function transferTokens(address recipient_address, uint token_value) external {\n', '    require( (msg.sender == owner) || (msg.sender == trustedSender) );  // Restricted to the owner or to trustedSender\n', '    require(contractState == ContractState.ICOStarted);                 // check state\n', '    require(now >= icoStartTime);                                       // check time\n', '\n', '    _transfer(this, recipient_address, token_value);\n', '  }\n', '\n', '  /**\n', '   * Grant bounty tokens to an address.\n', '   * Restricted to the owner.\n', '   * State must be ICOStarted or ICOStopped.\n', '   *\n', '   * @param recipient_address Recipient address\n', '   * @param token_value Amount of tokens (do not forget to multiply by scale 10^18)\n', '   */\n', '  function grantBounty(address recipient_address, uint token_value) onlyOwner external {\n', '    require((contractState == ContractState.ICOStarted) || (contractState == ContractState.ICOStopped));  // check the state\n', '    require(bountyTokens >= token_value);  // check remaining amount of bounty tokens\n', '    require(now >= icoStartTime);     // check time\n', '\n', '    _transfer(this, recipient_address, token_value);\n', '    bountyTokens -= token_value;\n', '  }\n', '\n', '  /**\n', '   * Refund investment by transferring all tokens back to the contract and sending Ether to the investor.\n', '   *\n', '   * This function is a necessary measure, because maximum 99 accredited US investors are allowed \n', '   * under exemptions from registration with the U.S. Securities and Exchange Commission \n', '   * pursuant to Regulation D, Section 506(c) of the Securities Act of 1933, as amended (the “Securities Act”).\n', '   * \n', '   * We will select 99 accredited US investors and refund investments to all other US accredited investors to comply with this regulation.\n', '   *\n', '   * Investors from other countries (non-US investors) will not be affected.\n', '   *\n', '   * State must be ICOStopped or BuybackPaused.\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param investor_address The address of the investor\n', '   * @param ether_value The amount in Wei\n', '   */\n', '  function refundInvestment(address investor_address, uint ether_value) onlyOwner external {\n', '    require((contractState == ContractState.ICOStopped) || (contractState == ContractState.BuybackPaused));   // check the state\n', '\n', '    require(investor_address != owner);                   // do not refund to the owner\n', '    require(investor_address != address(this));           // do not refund to the contract\n', "    require(balanceOf[investor_address] > 0);             // investor's token balance must be greater than zero\n", '    require(this.balance >= ether_value);                 // the contract must have enough ether\n', '\n', '    // Transfer the tokens back to the contract\n', '    _transfer(investor_address, this, balanceOf[investor_address]);\n', '\n', "    // Send ether to the investor. It's important to do this last to avoid recursion attacks.\n", '    investor_address.transfer(ether_value);\n', '  }\n', '\n', '  /**\n', '   * Set token buyback price in Wei.\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param buyback_price New buyback price in Wei\n', '   */\n', '  function setBuybackPrice(uint buyback_price) onlyOwner public {\n', '    require(buyback_price > 0);\n', '    buybackPrice = buyback_price;\n', '  }\n', '\n', '  /**\n', '   * Enable buyback.\n', '   * State must be ICOStopped or BuybackPaused.\n', '   * Buyback can be paused with pauseBuyback().\n', '   *\n', '   * Restricted to the owner.\n', '   *\n', '   * @param buyback_price New buyback price in Wei\n', '   */\n', '  function enableBuyback(uint buyback_price) onlyOwner external {\n', '    require((contractState == ContractState.ICOStopped) || (contractState == ContractState.BuybackPaused));\n', '    setBuybackPrice(buyback_price);\n', '\n', '    contractState = ContractState.BuybackEnabled;\n', '    State(contractState);\n', '  }\n', '\n', '  /**\n', '   * Pause buyback.\n', '   * State must be BuybackEnabled.\n', '   * Buyback can be re-enabled with enableBuyback().\n', '   *\n', '   * Restricted to the owner.\n', '   */\n', '  function pauseBuyback() onlyOwner external {\n', '      require(contractState == ContractState.BuybackEnabled);\n', '\n', '      contractState = ContractState.BuybackPaused;\n', '      State(contractState);\n', '  }\n', '\n', '  /**\n', '   * Destroy the contract and send all Ether to the owner.\n', '   * The contract must be in the BuybackPaused state.\n', '   *\n', '   * Restricted to the owner.\n', '   */\n', '  function destroyContract() onlyOwner external {\n', '      require(contractState == ContractState.BuybackPaused);\n', '\n', '      contractState = ContractState.Destroyed;\n', '      State(contractState);\n', '\n', '      selfdestruct(owner);  // send all money to the owner and destroy the contract!\n', '  }\n', '\n', '} /* ------------------------ end of contract ---------------------- */']