['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract ERC20 {\n', '\t//Sets events and functions for ERC20 token\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '\t\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\tfunction approve(address _spender, uint _value) returns (bool success);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '}\n', '\n', '\n', 'contract Owned {\n', '\t//Public variable\n', '    address public owner;\n', '\n', '\t//Sets contract creator as the owner\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\t\n', '\t//Sets onlyOwner modifier for specified functions\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\t//Allows for transfer of contract ownership\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }  \n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '  \n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '}\n', '\n', '\n', 'contract BaseToken is ERC20, Owned {\n', '    //Applies SafeMath library to uint256 operations \n', '    using SafeMath for uint256;\n', '\n', '\t//Public variables\n', '\tstring public name; \n', '\tstring public symbol; \n', '\tuint256 public decimals;  \n', '    uint256 public initialTokens; \n', '\tuint256 public totalSupply; \n', '\tstring public version;\n', '\n', '\t//Creates arrays for balances\n', '    mapping (address => uint256) balance;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\t//Constructor\n', '\tfunction BaseToken(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 initialAmount, string tokenVersion) {\n', '\t\tname = tokenName; \n', '\t\tsymbol = tokenSymbol; \n', '\t\tdecimals = decimalUnits; \n', '        initialTokens = initialAmount; \n', '\t\tversion = tokenVersion;\n', '\t}\n', '\t\n', '\t//Provides the remaining balance of approved tokens from function approve \n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '\t//Allows for a certain amount of tokens to be spent on behalf of the account owner\n', '    function approve(address _spender, uint256 _value) returns (bool success) { \n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\t//Returns the account balance \n', '    function balanceOf(address _owner) constant returns (uint256 remainingBalance) {\n', '        return balance[_owner];\n', '    }\n', '\n', "\t//Sends tokens from sender's account\n", '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if ((balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\n', '            balance[msg.sender] -= _value;\n', '            balance[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { \n', '\t\t\treturn false; \n', '\t\t}\n', '    }\n', '\t\n', '\t//Transfers tokens from an approved account \n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\n', '            balance[_to] += _value;\n', '            balance[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { \n', '\t\t\treturn false; \n', '\t\t}\n', '    }\n', '    \n', '}\n', '\n', 'contract AsspaceToken is Owned, BaseToken {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public amountRaised; \n', '    uint256 public deadline; \n', '    uint256 public price;        \n', '    uint256 public maxPreIcoAmount = 8000000;  \n', '\tbool preIco = true;\n', '    \n', '\tfunction AsspaceToken() \n', '\t\tBaseToken("ASSPACE Token", "ASP", 0, 100000000000, "1.0") {\n', '            balance[msg.sender] = initialTokens;    \n', '            setPrice(2500000);\n', '            deadline = now - 1 days;\n', '    }\n', '\n', '    function () payable {\n', '        require((now < deadline) && \n', '                 (msg.value.div(1 finney) >= 100) &&\n', '                ((preIco && amountRaised.add(msg.value.div(1 finney)) <= maxPreIcoAmount) || !preIco)); \n', '\n', '        address recipient = msg.sender; \n', '        amountRaised = amountRaised.add(msg.value.div(1 finney)); \n', '        uint256 tokens = msg.value.mul(getPrice()).div(1 ether);\n', '        totalSupply = totalSupply.add(tokens);\n', '        balance[recipient] = balance[recipient].add(tokens);\n', '\t\tbalance[owner] = balance[owner].sub(tokens);\n', '\t\t\n', '        require(owner.send(msg.value)); \n', '\t\t\n', '        Transfer(0, recipient, tokens);\n', '    }   \n', '\n', '    function setPrice(uint256 newPriceper) onlyOwner {\n', '        require(newPriceper > 0); \n', '        \n', '        price = newPriceper; \n', '    }\n', '\t\n', '\tfunction getPrice() constant returns (uint256) {\n', '\t\treturn price;\n', '\t}\n', '\t\t\n', '    function startSale(uint256 lengthOfSale, bool isPreIco) onlyOwner {\n', '        require(lengthOfSale > 0); \n', '        \n', '        preIco = isPreIco;\n', '        deadline = now + lengthOfSale * 1 days; \n', '    }\n', '\n', '    function stopSale() onlyOwner {\n', '        deadline = now;\n', '    }\n', '    \n', '}']