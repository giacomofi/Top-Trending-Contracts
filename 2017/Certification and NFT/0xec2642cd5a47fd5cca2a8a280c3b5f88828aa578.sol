['pragma solidity 0.4.15;\n', '\n', '\n', '// This contract is meant as a "singleton" forwarding contract.\n', '// Eventually, it will be able to forward any transaction to\n', '// Any contract that is built to accept it.\n', 'contract TxRelay {\n', '\n', '    // Note: This is a local nonce.\n', '    // Different from the nonce defined w/in protocol.\n', '    mapping(address => uint) nonce;\n', '\n', '    // This mapping specifies a whitelist of allowed senders for transactions.\n', '    // There can be one whitelist per ethereum account, which is the owner of that\n', '    // whitelist. Users can specify which whitelist they want to use when signing\n', '    // a transaction. They can use their own whitelist, a whitelist belonging\n', '    // to another account, or skip using a whitelist by specifying the zero address.\n', '    mapping(address => mapping(address => bool)) public whitelist;\n', '\n', '    /*\n', '     * @dev Relays meta transactions\n', '     * @param sigV, sigR, sigS ECDSA signature on some data to be forwarded\n', '     * @param destination Location the meta-tx should be forwarded to\n', '     * @param data The bytes necessary to call the function in the destination contract.\n', '     * Note: The first encoded argument in data must be address of the signer. This means\n', '     * that all functions called from this relay must take an address as the first parameter.\n', '     */\n', '    function relayMetaTx(\n', '        uint8 sigV,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        address destination,\n', '        bytes data,\n', '        address listOwner\n', '    ) public {\n', '\n', '        // only allow senders from the whitelist specified by the user,\n', '        // 0x0 means no whitelist.\n', '        require(listOwner == 0x0 || whitelist[listOwner][msg.sender]);\n', '\n', '        address claimedSender = getAddress(data);\n', '        // use EIP 191\n', '        // 0x19 :: version :: relay :: whitelistOwner :: nonce :: destination :: data\n', '        bytes32 h = keccak256(byte(0x19), byte(0), this, listOwner, nonce[claimedSender], destination, data);\n', '        address addressFromSig = ecrecover(h, sigV, sigR, sigS);\n', '\n', '        require(claimedSender == addressFromSig);\n', '\n', '        nonce[claimedSender]++; //if we are going to do tx, update nonce\n', '\n', '        require(destination.call(data));\n', '    }\n', '\n', '    /*\n', '     * @dev Gets an address encoded as the first argument in transaction data\n', '     * @param b The byte array that should have an address as first argument\n', '     * @returns a The address retrieved from the array\n', '     (Optimization based on work by tjade273)\n', '     */\n', '    function getAddress(bytes b) public constant returns (address a) {\n', '        if (b.length < 36) return address(0);\n', '        assembly {\n', '            let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n', '            a := and(mask, mload(add(b, 36)))\n', '            // 36 is the offset of the first parameter of the data, if encoded properly.\n', '            // 32 bytes for the length of the bytes array, and 4 bytes for the function signature.\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the local nonce of an account.\n', '     * @param add The address to return the nonce for.\n', '     * @return The specific-to-this-contract nonce of the address provided\n', '     */\n', '    function getNonce(address add) public constant returns (uint) {\n', '        return nonce[add];\n', '    }\n', '\n', '    /*\n', '     * @dev Adds a number of addresses to a specific whitelist. Only\n', '     * the owner of a whitelist can add to it.\n', '     * @param sendersToUpdate the addresses to add to the whitelist\n', '     */\n', '    function addToWhitelist(address[] sendersToUpdate) public {\n', '        updateWhitelist(sendersToUpdate, true);\n', '    }\n', '\n', '    /*\n', '     * @dev Removes a number of addresses from a specific whitelist. Only\n', '     * the owner of a whitelist can remove from it.\n', '     * @param sendersToUpdate the addresses to add to the whitelist\n', '     */\n', '    function removeFromWhitelist(address[] sendersToUpdate) public {\n', '        updateWhitelist(sendersToUpdate, false);\n', '    }\n', '\n', '    /*\n', '     * @dev Internal logic to update a whitelist\n', '     * @param sendersToUpdate the addresses to add to the whitelist\n', '     * @param newStatus whether to add or remove addresses\n', '     */\n', '    function updateWhitelist(address[] sendersToUpdate, bool newStatus) private {\n', '        for (uint i = 0; i < sendersToUpdate.length; i++) {\n', '            whitelist[msg.sender][sendersToUpdate[i]] = newStatus;\n', '        }\n', '    }\n', '}']