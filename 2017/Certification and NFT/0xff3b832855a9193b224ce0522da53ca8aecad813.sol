['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {  //was constant\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/************************************************************************************************\n', ' * \n', ' *************************************************************************************************/\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 { \n', '    function transfer(address receiver, uint amount) public ;\n', '    function transferFrom(address sender, address receiver, uint amount) public returns(bool success); // do token.approve on the ICO contract\n', '    function balanceOf(address _owner) constant public returns (uint256 balance);\n', '}\n', '\n', '/************************************************************************************************\n', ' * \n', ' *************************************************************************************************/\n', '\n', 'contract ASTRICOPreSale is Ownable {\n', '  ERC20 public token;  // using the ASTRCoin token - will set an address\n', '\n', '  // start and end of the sale - 4 weeks\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // where funds are collected \n', '\n', '  address public wallet;  // beneficiary\n', '  address public ownerAddress;  // deploy owner\n', '\n', '  // amount of raised money in wei\n', '  uint256 public weiRaised;\n', '  \n', '  uint8 internal decimals             = 4; // 4 decimal places should be enough in general\n', '  uint256 internal decimalsConversion = 10 ** uint256(decimals);\n', '  uint256 internal ALLOC_CROWDSALE    = 10000000 * decimalsConversion; // (10 ** uint256(decimals)); // 10 mill in ICO\n', '  // we have already sold some\n', '  // \n', '  // 90MIL      90000000\n', '  // 10MIL      10000000\n', '  // 90MIL 4DCP 900000000000\n', '  // 10MIL 4dCP 100000000000\n', '\n', '  uint internal BASIC_RATE        = 75 * decimalsConversion; // based on the price of ether at 330 USD\n', '  uint internal PRICE_STAGE_PS    = 431 * decimalsConversion; \n', '  uint internal STAGE_PS_TIME_END = 60 minutes; // THIS IS TO BE SET PROPERLY\n', '  uint internal PRICE_VARIABLE    = 0 * decimalsConversion;\n', '  uint256 public astrSold         = 0;\n', '\n', '  bool public halted;\n', '  bool public crowdsaleClosed;\n', '\n', '  // simple event to track purchases\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  modifier isNotHalted() {     require(!halted);    _;  }\n', '  modifier afterDeadline() { if (now >= endTime) _; }\n', '\n', '  /**\n', '    * Constructor for ASTRICOPreSale\n', '    * param _token  ASTRCoin   0x567354a9F8367ff25F6967C947239fe75649e64e\n', '    * param _startTime start time for public sale\n', '    * param _ethWallet all incoming eth transfered here. Use multisig wallet 0xeA173bf22d7fF1ad9695652432b8759A331d668b\n', '    *\n', '    *     *\n', '\n', '0x80E7a4d750aDe616Da896C49049B7EdE9e04C191\n', '\n', '\n', '1510911600\n', '2017-11-17 17:40:00\n', '\n', '1511758800\n', '2017-11-27 13:00:00\n', '\n', '    *\n', '    * 90000000000\n', '  */\n', '    function ASTRICOPreSale() public  {\n', '\n', '    crowdsaleClosed = false;\n', '    halted          = false;\n', '    startTime       = 1510911600; //1510563716; //_startTime;  make it +20 minutes for it to work\n', '    endTime         = 1511758800; //_startTime + STAGE_FOUR_TIME_END; set start and end the same :/\n', '    wallet          = ERC20(0x3baDA155408AB1C9898FDF28e545b51f2f9a65CC); // This wallet needs to give permission for the ICO to transfer Tokens  Ropsten 0xeA173bf22d7fF1ad9695652432b8759A331d668b\n', '    ownerAddress    = ERC20(0x3EFAe2e152F62F5cc12cc0794b816d22d416a721);  // This is bad in theory but does fix the 2300 gas problem Ropsten 0xeA173bf22d7fF1ad9695652432b8759A331d668b\n', '    token           = ERC20(0x80E7a4d750aDe616Da896C49049B7EdE9e04C191); // Ropsten we have pregenerated thiss\n', '  }\n', '\n', '        // fallback function can be used to buy tokens\n', '  function () public payable {\n', '    require(msg.sender                 != 0x0);\n', '    require(validPurchase());\n', '    require(!halted); // useful to test if we have paused it\n', '    uint256 weiAmount                  = msg.value; // money sent in wei\n', '    uint256 tokens                     = SafeMath.div(SafeMath.mul(weiAmount, getCurrentRate()), 1 ether);\n', '    require(ALLOC_CROWDSALE - astrSold >= tokens);\n', '    weiRaised                          += weiAmount;\n', '    astrSold                           += tokens;\n', '    token.transferFrom(ownerAddress, msg.sender, tokens);\n', '    wallet.transfer(msg.value); // transfer straight away PRESALE wallet\n', '  }\n', '\n', '\n', '  function validPurchase() internal constant returns (bool) {\n', '    bool withinPeriod = now >= startTime && now <= endTime;\n', '    bool nonZeroPurchase = (msg.value != 0);\n', '    bool astrAvailable = (ALLOC_CROWDSALE - astrSold) > 0; \n', '    return withinPeriod && nonZeroPurchase && astrAvailable && ! crowdsaleClosed;\n', '  }\n', '\n', '  function getCurrentRate() internal constant returns (uint256) {  \n', '    if( PRICE_VARIABLE > 0 ) {\n', '      return PRICE_VARIABLE; // we can manually set prices if we want\n', '    }\n', '    return PRICE_STAGE_PS;\n', '  }\n', '\n', '\n', '  // this closes it when we want to close - rather than waiting \n', '  function setNewRate(uint256 _coinsPerEther) onlyOwner public {\n', '    if( _coinsPerEther > 0 ) {\n', '        PRICE_VARIABLE = _coinsPerEther * decimalsConversion;\n', '    }\n', '  }\n', '    // this closes it when we want to close - rather than waiting \n', '  function setFixedRate() onlyOwner public {\n', '     PRICE_VARIABLE = 0 * decimalsConversion;\n', '  }\n', '\n', '\n', '  // this closes it when we want to close - rather than waiting - this is BAD\n', '  function closeSaleAnyway() onlyOwner public {\n', '      // wallet.transfer(weiRaised);\n', '      crowdsaleClosed = true;\n', '    }\n', '\n', '    // this closes it when we want to close - rather than waiting \n', '  function safeCloseSale()  onlyOwner afterDeadline public {\n', '    // wallet.transfer(weiRaised);\n', '    crowdsaleClosed = true;\n', '  }\n', '\n', '  function pause() onlyOwner public {\n', '    halted = true;\n', '  }\n', '\n', '\n', '  function unpause() onlyOwner public {\n', '    halted = false;\n', '  }\n', '}']