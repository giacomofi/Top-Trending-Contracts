['pragma solidity 0.4.15;\n', '\n', '/// @title provides subject to role checking logic\n', 'contract IAccessPolicy {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', "    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\n", '    /// @dev checks if subject belongs to requested role for particular object\n', '    /// @param subject address to be checked against role, typically msg.sender\n', '    /// @param role identifier of required role\n', '    /// @param object contract instance context for role checking, typically contract requesting the check\n', '    /// @param verb additional data, in current AccessControll implementation msg.sig\n', '    /// @return if subject belongs to a role\n', '    function allowed(\n', '        address subject,\n', '        bytes32 role,\n', '        address object,\n', '        bytes4 verb\n', '    )\n', '        public\n', '        returns (bool);\n', '}\n', '\n', '/// @title enables access control in implementing contract\n', '/// @dev see AccessControlled for implementation\n', 'contract IAccessControlled {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    /// @dev must log on access policy change\n', '    event LogAccessPolicyChanged(\n', '        address controller,\n', '        IAccessPolicy oldPolicy,\n', '        IAccessPolicy newPolicy\n', '    );\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @dev allows to change access control mechanism for this contract\n', '    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\n', '    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\n', '    ///     then interfaces could be used for example to control access semantics\n', '    /// @param newPolicy new access policy to controll this contract\n', '    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\n', '    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\n', '        public;\n', '\n', '    function accessPolicy()\n', '        public\n', '        constant\n', '        returns (IAccessPolicy);\n', '\n', '}\n', '\n', 'contract StandardRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', "    // @notice Soldity somehow doesn't evaluate this compile time\n", '    // @dev role which has rights to change permissions and set new policy in contract, keccak256("AccessController")\n', '    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\n', '}\n', '\n', '/// @title Granular code execution permissions\n', '/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\n', "///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\n", '///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\n', '/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\n', '///     by msg.sender with ROLE_ACCESS_CONTROLLER role\n', 'contract AccessControlled is IAccessControlled, StandardRoles {\n', '\n', '    ////////////////////////\n', '    // Mutable state\n', '    ////////////////////////\n', '\n', '    IAccessPolicy private _accessPolicy;\n', '\n', '    ////////////////////////\n', '    // Modifiers\n', '    ////////////////////////\n', '\n', "    /// @dev limits function execution only to senders assigned to required 'role'\n", '    modifier only(bytes32 role) {\n', '        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\n', '        _;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    function AccessControlled(IAccessPolicy policy) internal {\n', '        require(address(policy) != 0x0);\n', '        _accessPolicy = policy;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements IAccessControlled\n', '    //\n', '\n', '    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\n', '        public\n', '        only(ROLE_ACCESS_CONTROLLER)\n', '    {\n', '        // ROLE_ACCESS_CONTROLLER must be present\n', '        // under the new policy. This provides some\n', '        // protection against locking yourself out.\n', '        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\n', '\n', '        // We can now safely set the new policy without foot shooting.\n', '        IAccessPolicy oldPolicy = _accessPolicy;\n', '        _accessPolicy = newPolicy;\n', '\n', '        // Log event\n', '        LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\n', '    }\n', '\n', '    function accessPolicy()\n', '        public\n', '        constant\n', '        returns (IAccessPolicy)\n', '    {\n', '        return _accessPolicy;\n', '    }\n', '}\n', '\n', 'contract AccessRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', '    // NOTE: All roles are set to the keccak256 hash of the\n', '    // CamelCased role name, i.e.\n', '    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256("LockedAccountAdmin")\n', '\n', '    // may setup LockedAccount, change disbursal mechanism and set migration\n', '    bytes32 internal constant ROLE_LOCKED_ACCOUNT_ADMIN = 0x4675da546d2d92c5b86c4f726a9e61010dce91cccc2491ce6019e78b09d2572e;\n', '\n', '    // may setup whitelists and abort whitelisting contract with curve rollback\n', '    bytes32 internal constant ROLE_WHITELIST_ADMIN = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;\n', '\n', '    // May issue (generate) Neumarks\n', '    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\n', '\n', '    // May burn Neumarks it owns\n', '    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\n', '\n', '    // May create new snapshots on Neumark\n', '    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\n', '\n', '    // May enable/disable transfers on Neumark\n', '    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\n', '\n', '    // may reclaim tokens/ether from contracts supporting IReclaimable interface\n', '    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\n', '\n', '    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256("PlatformOperatorRepresentative")\n', '    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\n', '\n', '    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256("EurtDepositManager")\n', '    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\n', '}\n', '\n', 'contract IBasicToken {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount);\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @dev This function makes it easy to get the total number of tokens\n', '    /// @return The total number of tokens\n', '    function totalSupply()\n', '        public\n', '        constant\n', '        returns (uint256);\n', '\n', "    /// @param owner The address that's balance is being requested\n", '    /// @return The balance of `owner` at the current block\n', '    function balanceOf(address owner)\n', '        public\n', '        constant\n', '        returns (uint256 balance);\n', '\n', '    /// @notice Send `amount` tokens to `to` from `msg.sender`\n', '    /// @param to The address of the recipient\n', '    /// @param amount The amount of tokens to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 amount)\n', '        public\n', '        returns (bool success);\n', '\n', '}\n', '\n', '/// @title allows deriving contract to recover any token or ether that it has balance of\n', '/// @notice note that this opens your contracts to claims from various people saying they lost tokens and they want them back\n', '///     be ready to handle such claims\n', '/// @dev use with care!\n', "///     1. ROLE_RECLAIMER is allowed to claim tokens, it's not returning tokens to original owner\n", '///     2. in derived contract that holds any token by design you must override `reclaim` and block such possibility.\n', '///         see LockedAccount as an example\n', 'contract Reclaimable is AccessControlled, AccessRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', '    IBasicToken constant internal RECLAIM_ETHER = IBasicToken(0x0);\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function reclaim(IBasicToken token)\n', '        public\n', '        only(ROLE_RECLAIMER)\n', '    {\n', '        address reclaimer = msg.sender;\n', '        if(token == RECLAIM_ETHER) {\n', '            reclaimer.transfer(this.balance);\n', '        } else {\n', '            uint256 balance = token.balanceOf(this);\n', '            require(token.transfer(reclaimer, balance));\n', '        }\n', '    }\n', '}\n', '\n', 'contract IEthereumForkArbiter {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    event LogForkAnnounced(\n', '        string name,\n', '        string url,\n', '        uint256 blockNumber\n', '    );\n', '\n', '    event LogForkSigned(\n', '        uint256 blockNumber,\n', '        bytes32 blockHash\n', '    );\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function nextForkName()\n', '        public\n', '        constant\n', '        returns (string);\n', '\n', '    function nextForkUrl()\n', '        public\n', '        constant\n', '        returns (string);\n', '\n', '    function nextForkBlockNumber()\n', '        public\n', '        constant\n', '        returns (uint256);\n', '\n', '    function lastSignedBlockNumber()\n', '        public\n', '        constant\n', '        returns (uint256);\n', '\n', '    function lastSignedBlockHash()\n', '        public\n', '        constant\n', '        returns (bytes32);\n', '\n', '    function lastSignedTimestamp()\n', '        public\n', '        constant\n', '        returns (uint256);\n', '\n', '}\n', '\n', 'contract EthereumForkArbiter is\n', '    IEthereumForkArbiter,\n', '    AccessControlled,\n', '    AccessRoles,\n', '    Reclaimable\n', '{\n', '    ////////////////////////\n', '    // Mutable state\n', '    ////////////////////////\n', '\n', '    string private _nextForkName;\n', '\n', '    string private _nextForkUrl;\n', '\n', '    uint256 private _nextForkBlockNumber;\n', '\n', '    uint256 private _lastSignedBlockNumber;\n', '\n', '    bytes32 private _lastSignedBlockHash;\n', '\n', '    uint256 private _lastSignedTimestamp;\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    function EthereumForkArbiter(IAccessPolicy accessPolicy)\n', '        AccessControlled(accessPolicy)\n', '        Reclaimable()\n', '        public\n', '    {\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @notice Announce that a particular future Ethereum fork will the one taken by the contract. The contract on the other branch should be considered invalid. Once the fork has happened, it will additionally be confirmed by signing a block on the fork. Notice that forks may happen unannounced.\n', '    function announceFork(\n', '        string name,\n', '        string url,\n', '        uint256 blockNumber\n', '    )\n', '        public\n', '        only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE)\n', '    {\n', '        require(blockNumber == 0 || blockNumber > block.number);\n', '\n', '        // Store announcement\n', '        _nextForkName = name;\n', '        _nextForkUrl = url;\n', '        _nextForkBlockNumber = blockNumber;\n', '\n', '        // Log\n', '        LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);\n', '    }\n', '\n', '    /// @notice Declare that the current fork (as identified by a blockhash) is the valid fork. The valid fork is always the one with the most recent signature.\n', '    function signFork(uint256 number, bytes32 hash)\n', '        public\n', '        only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE)\n', '    {\n', '        require(block.blockhash(number) == hash);\n', '\n', '        // Reset announcement\n', '        delete _nextForkName;\n', '        delete _nextForkUrl;\n', '        delete _nextForkBlockNumber;\n', '\n', '        // Store signature\n', '        _lastSignedBlockNumber = number;\n', '        _lastSignedBlockHash = hash;\n', '        _lastSignedTimestamp = block.timestamp;\n', '\n', '        // Log\n', '        LogForkSigned(_lastSignedBlockNumber, _lastSignedBlockHash);\n', '    }\n', '\n', '    function nextForkName()\n', '        public\n', '        constant\n', '        returns (string)\n', '    {\n', '        return _nextForkName;\n', '    }\n', '\n', '    function nextForkUrl()\n', '        public\n', '        constant\n', '        returns (string)\n', '    {\n', '        return _nextForkUrl;\n', '    }\n', '\n', '    function nextForkBlockNumber()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return _nextForkBlockNumber;\n', '    }\n', '\n', '    function lastSignedBlockNumber()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return _lastSignedBlockNumber;\n', '    }\n', '\n', '    function lastSignedBlockHash()\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return _lastSignedBlockHash;\n', '    }\n', '\n', '    function lastSignedTimestamp()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return _lastSignedTimestamp;\n', '    }\n', '}']