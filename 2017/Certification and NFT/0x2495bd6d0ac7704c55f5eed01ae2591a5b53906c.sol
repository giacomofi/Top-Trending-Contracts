['/*\n', '\n', '  Copyright 2017 Cofound.it.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.13;\n', '\n', 'contract ReentrancyHandlingContract {\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract PriorityPassInterface {\n', '    function getAccountLimit(address _accountAddress) public constant returns (uint);\n', '    function getAccountActivity(address _accountAddress) public constant returns (bool);\n', '}\n', 'contract ERC20TokenInterface {\n', '  function totalSupply() public constant returns (uint256 _totalSupply);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned {\n', '\n', '  struct ContributorData {\n', '    uint contributionAmount;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint public nextContributorIndex;\n', '  mapping(uint => address) public contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsaleEnded }\n', '\n', '  uint public presaleStartTime;\n', '  uint public presaleUnlimitedStartTime;\n', '  uint public crowdsaleEndedTime;\n', '\n', '  event PresaleStarted(uint blocktime);\n', '  event PresaleUnlimitedStarted(uint blocktime);\n', '  event CrowdsaleEnded(uint blocktime);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blocktime);\n', '  event MaxCapReached(uint blocktime);\n', '  event ContributionMade(address indexed contributor, uint amount);\n', '\n', '  PriorityPassInterface priorityPassContract = PriorityPassInterface(0x0);\n', '\n', '  uint public minCap;\n', '  uint public maxP1Cap;\n', '  uint public maxCap;\n', '  uint public ethRaised;\n', '\n', '  address public multisigAddress;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  // @payable\n', '  //\n', '  function() noReentrancy payable public {\n', '    require(msg.value != 0);                                                    // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);                            // Check if crowdsale has ended\n', '\n', '    bool stateChanged = checkCrowdsaleState();                                  // Check blocks time and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.priorityPass) {\n', '      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\n', '      } else {\n', '        refundTransaction(stateChanged);                                        // Set state and return funds or throw\n', '      }\n', '    } else if (crowdsaleState == state.openedPriorityPass) {\n', '      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\n', '      } else {\n', '        refundTransaction(stateChanged);                                        // Set state and return funds or throw\n', '      }\n', '    } else {\n', '      refundTransaction(stateChanged);                                          // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // @internal checks crowdsale state and emits events it\n', '  // @returns boolean\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool) {\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {        // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      MaxCapReached(block.timestamp);                                           // Close the crowdsale\n', '      CrowdsaleEnded(block.timestamp);                                          // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.timestamp > presaleStartTime && block.timestamp <= presaleUnlimitedStartTime) { // Check if we are in presale phase\n', '      if (crowdsaleState != state.priorityPass) {                               // Check if state needs to be changed\n', '        crowdsaleState = state.priorityPass;                                    // Set new state\n', '        PresaleStarted(block.timestamp);                                        // Raise event\n', '        return true;\n', '      }\n', '    } else if (block.timestamp > presaleUnlimitedStartTime && block.timestamp <= crowdsaleEndedTime) {  // Check if we are in presale unlimited phase\n', '      if (crowdsaleState != state.openedPriorityPass) {                         // Check if state needs to be changed\n', '        crowdsaleState = state.openedPriorityPass;                              // Set new state\n', '        PresaleUnlimitedStarted(block.timestamp);                               // Raise event\n', '        return true;\n', '      }\n', '    } else {\n', '      if (crowdsaleState != state.crowdsaleEnded && block.timestamp > crowdsaleEndedTime) {// Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                  // Set new state\n', '        CrowdsaleEnded(block.timestamp);                                        // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // @internal determines if return eth or throw according to changing state\n', '  // @param _stateChanged boolean message about state change\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal {\n', '    if (_stateChanged) {\n', '      msg.sender.transfer(msg.value);\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  // Getter to calculate how much user can contribute\n', '  // @param _contributor address of the contributor\n', '  //\n', '  function calculateMaxContribution(address _contributor) constant public returns (uint maxContribution) {\n', '    uint maxContrib;\n', '\n', '    if (crowdsaleState == state.priorityPass) {                                 // Check if we are in priority pass\n', '      maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount;\n', '\n', '\t    if (maxContrib > (maxP1Cap - ethRaised)) {                                // Check if max contribution is more that max cap\n', '        maxContrib = maxP1Cap - ethRaised;                                      // Alter max cap\n', '      }\n', '\n', '    } else {\n', '      maxContrib = maxCap - ethRaised;                                          // Alter max cap\n', '    }\n', '    return maxContrib;\n', '  }\n', '\n', '  //\n', '  // Return if there is overflow of contributed eth\n', '  // @internal processes transactions\n', '  // @param _contributor address of an contributor\n', '  // @param _amount contributed amount\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal {\n', '    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '\n', '\t  if (maxContribution < _amount) {                                            // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxContribution;                                     // Set that user contributes his maximum alowed contribution\n', '      returnAmount = _amount - maxContribution;                                 // Calculate how much he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount >= minCap && minCap > ethRaised) {\n', '      MinCapReached(block.timestamp);\n', '    } \n', '\n', '    if (contributorList[_contributor].contributionAmount == 0) {                // Check if contributor has already contributed\n', '      contributorList[_contributor].contributionAmount = contributionAmount;    // Set their contribution\n', '      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '      nextContributorIndex++;\n', '    } else {\n', '      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n', '    }\n', '    ethRaised += contributionAmount;                                            // Add to eth raised\n', '\n', '    ContributionMade(msg.sender, contributionAmount);                           // Raise event about contribution\n', '\n', '\t  if (returnAmount != 0) {\n', '      _contributor.transfer(returnAmount);                                      // Return overflow of ether\n', '    } \n', '  }\n', '\n', '  //\n', '  // Recovers ERC20 tokens other than eth that are send to this address\n', '  // @owner refunds the erc20 tokens\n', '  // @param _tokenAddress address of the erc20 token\n', '  // @param _to address to where tokens should be send to\n', '  // @param _amount amount of tokens to refund\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  // @owner sets contributions to withdraw\n', '  //\n', '  function withdrawEth() onlyOwner public {\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    pendingEthWithdrawal = this.balance;\n', '  }\n', '\n', '\n', '  uint public pendingEthWithdrawal;\n', '  //\n', '  // pulls the funds that were set to send with calling of\n', '  // withdrawEth when minimum cap is reached\n', '  // @multisig pulls the contributions to self\n', '  //\n', '  function pullBalance() public {\n', '    require(msg.sender == multisigAddress);\n', '    require(pendingEthWithdrawal > 0);\n', '\n', '    multisigAddress.transfer(pendingEthWithdrawal);\n', '    pendingEthWithdrawal = 0;\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  // @owner returns contributions\n', '  // @param _numberOfReturns number of returns to do in one transaction\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);        // Check if crowdsale has failed\n', '\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];   // Get next unclaimed participant\n', '\n', '      if (currentParticipantAddress == 0x0) {\n', '         return;                                                                // Check if all the participants were compensated\n', '      }\n', '\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                  // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                // Set that he has claimed\n', '\n', '        if (!currentParticipantAddress.send(contribution)) {                    // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);             // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                              // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue with refund owner can withdraw eth at the end for manual recovery\n', '  // @owner withdraws remaining funds\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '    require(this.balance != 0);                                                 // Check if there are any eth to claim\n', '    require(block.timestamp > crowdsaleEndedTime);                              // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);                 // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                                     // Withdraw to multisig for manual processing\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  // @owner sets an address where funds will go\n', '  // @param _newAddress\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner public {\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Setter for the whitelist contract\n', '  // @owner sets address of whitelist contract\n', '  // @param address\n', '  //\n', '  function setPriorityPassContract(address _newAddress) onlyOwner public {\n', '    priorityPassContract = PriorityPassInterface(_newAddress);\n', '  }\n', '\n', '  //\n', '  // Getter for the whitelist contract\n', '  // @returns white list contract address\n', '  //\n', '  function priorityPassContractAddress() constant public returns (address) {\n', '    return address(priorityPassContract);\n', '  }\n', '\n', '  //\n', '  // Before crowdsale starts owner can calibrate time of crowdsale stages\n', '  // @owner sends new times for the sale\n', '  // @param _presaleStartTime timestamp for sale limited start\n', '  // @param _presaleUnlimitedStartTime timestamp for sale unlimited\n', '  // @param _crowdsaleEndedTime timestamp for ending sale\n', '  //\n', '  function setCrowdsaleTimes(uint _presaleStartTime, uint _presaleUnlimitedStartTime, uint _crowdsaleEndedTime) onlyOwner public {\n', '    require(crowdsaleState == state.pendingStart);                              // Check if crowdsale has started\n', '    require(_presaleStartTime != 0);                                            // Check if any value is 0\n', '    require(_presaleStartTime < _presaleUnlimitedStartTime);                    // Check if presaleUnlimitedStartTime is set properly\n', '    require(_presaleUnlimitedStartTime != 0);                                   // Check if any value is 0\n', '    require(_presaleUnlimitedStartTime < _crowdsaleEndedTime);                  // Check if crowdsaleEndedTime is set properly\n', '    require(_crowdsaleEndedTime != 0);                                          // Check if any value is 0\n', '    presaleStartTime = _presaleStartTime;\n', '    presaleUnlimitedStartTime = _presaleUnlimitedStartTime;\n', '    crowdsaleEndedTime = _crowdsaleEndedTime;\n', '  }\n', '}\n', '\n', 'contract LegacySeedCrowdsale is SeedCrowdsaleContract {\n', '  \n', '  function LegacySeedCrowdsale() {\n', '\n', '    presaleStartTime = 1512032400;\n', '    presaleUnlimitedStartTime = 1512063000;\n', '    crowdsaleEndedTime = 1512140400;\n', '\n', '    minCap = 356 ether;\n', '    maxP1Cap = 748 ether;\n', '    maxCap = 831 ether;\n', '  }\n', '}']