['pragma solidity ^0.4.15;\n', '/* @file\n', ' * @title Coin\n', ' * @version 1.2.0\n', '*/\n', 'contract Coin {\n', '  string public constant symbol = "BTRC";\n', '  string public constant name = "BiTUBER";\n', '  uint8 public constant decimals = 18;\n', '  uint256 public _totalSupply = 0;\n', '  uint256 public price = 100;\n', '  bool private workingState = false;\n', '  bool private transferAllowed = false;\n', '  bool private generationState = true;\n', '  address public owner;\n', '  address private cur_coin;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  mapping (address => uint256) private etherClients;\n', '  event FundsGot(address indexed _sender, uint256 _value);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '  event TokenGenerationEnabled();\n', '  event TokenGenerationDisabled();\n', '  event ContractEnabled();\n', '  event ContractDisabled();\n', '  event TransferEnabled();\n', '  event TransferDisabled();\n', '  event CurrentCoin(address coin);\n', '  event Refund(address client, uint256 amount, uint256 tokens);\n', '  event TokensSent(address client, uint256 amount);\n', '  event PaymentGot(bool result);\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  modifier ownerAndCoin {\n', '    require((msg.sender == owner)||(msg.sender == cur_coin));\n', '    _;\n', '  }\n', '  modifier workingFlag {\n', '    require(workingState == true);\n', '    _;\n', '  }\n', '  modifier transferFlag {\n', '    require(transferAllowed == true);\n', '    _;\n', '  }\n', '\n', '  function Coin() public payable {\n', '    owner = msg.sender;\n', '    enableContract();\n', '  }\n', '  function refund(address _client, uint256 _amount, uint256 _tokens) public workingFlag ownerAndCoin {\n', '    balances[_client] -= _tokens;\n', '    balances[address(this)] += _tokens;\n', '    _client.transfer(_amount);\n', '    Refund(_client, _amount, _tokens);\n', '  }\n', '  function kill() public onlyOwner {\n', '    require(workingState == false);\n', '    selfdestruct(owner);\n', '  }\n', '  function setCurrentCoin(address current) public onlyOwner workingFlag {\n', '    cur_coin = current;\n', '    CurrentCoin(cur_coin);\n', '  }\n', '\n', '  //work controller functions\n', '  function enableContract() public onlyOwner {\n', '    workingState = true;\n', '    ContractEnabled();\n', '  }\n', '  function disableContract() public onlyOwner {\n', '    workingState = false;\n', '    ContractDisabled();\n', '  }\n', '  function contractState() public view returns (string state) {\n', '    if (workingState) {\n', '      state = "Working";\n', '    }\n', '    else {\n', '      state = "Stopped";\n', '    }\n', '  }\n', '  function enableGeneration() public onlyOwner {\n', '    generationState = true;\n', '    TokenGenerationEnabled();\n', '  }\n', '  function disableGeneration() public onlyOwner {\n', '    generationState = false;\n', '    TokenGenerationDisabled();\n', '  }\n', '  function tokenGenerationState() public view returns (string state) {\n', '    if (generationState) {\n', '      state = "Working";\n', '    }\n', '    else {\n', '      state = "Stopped";\n', '    }\n', '  }\n', '  //transfer controller functions\n', '  function enableTransfer() public onlyOwner {\n', '    transferAllowed = true;\n', '    TransferEnabled();\n', '  }\n', '  function disableTransfer() public onlyOwner {\n', '    transferAllowed = false;\n', '    TransferDisabled();\n', '  }\n', '  function transferState() public view returns (string state) {\n', '    if (transferAllowed) {\n', '      state = "Working";\n', '    }\n', '    else {\n', '      state = "Stopped";\n', '    }\n', '  }\n', '  //token controller functions\n', '  function generateTokens(address _client, uint256 _amount) public ownerAndCoin workingFlag {\n', '    if (_client == address(this))\n', '    {\n', '      balances[address(this)] += _amount;\n', '\t\t  _totalSupply += _amount;\n', '    }\n', '    else\n', '    {\n', '      if (balances[address(this)] >= _amount)\n', '      {\n', '        transferFrom(address(this), _client, _amount);\n', '      }\n', '      else\n', '      {\n', '        uint256 de = _amount - balances[address(this)];\n', '        transferFrom(address(this), _client, balances[address(this)]);\n', '        _totalSupply += de;\n', '        balances[_client] += de;\n', '      }\n', '    }\n', '    TokensSent(_client, _amount);\n', '  }\n', '  function setPrice(uint256 _price) public onlyOwner {\n', '    price = _price;\n', '  }\n', '  function getPrice() public view returns (uint256 _price) {\n', '    _price = price;\n', '  }\n', '  //send ether function (working)\n', '  function () public workingFlag payable {\n', '    bool ret = false;\n', '    if (generationState) {\n', '       ret = cur_coin.call(bytes4(keccak256("pay(address,uint256,uint256)")), msg.sender, msg.value, price);\n', '    }\n', '    PaymentGot(ret);\n', '  }\n', '  function totalSupply() public constant workingFlag returns (uint256 totalsupply) {\n', '    totalsupply = _totalSupply;\n', '  }\n', '  //ERC20 Interface\n', '  function balanceOf(address _owner) public constant workingFlag returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '  function transfer(address _to, uint256 _value) public workingFlag returns (bool success) {\n', '    if (balances[msg.sender] >= _value\n', '      && _value > 0\n', '      && balances[_to] + _value > balances[_to])\n', '      {\n', '        if ((msg.sender == address(this))||(_to == address(this))) {\n', '          balances[msg.sender] -= _value;\n', '          balances[_to] += _value;\n', '          Transfer(msg.sender, _to, _value);\n', '          return true;\n', '        }\n', '        else {\n', '          if (transferAllowed == true) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '          }\n', '          else {\n', '            return false;\n', '          }\n', '        }\n', '      }\n', '      else {\n', '        return false;\n', '      }\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 _value) public workingFlag returns (bool success) {\n', '    if ((msg.sender == cur_coin)||(msg.sender == owner)) {\n', '      allowed[_from][_to] = _value;\n', '    }\n', '    if (balances[_from] >= _value\n', '      && allowed[_from][_to] >= _value\n', '      && _value > 0\n', '      && balances[_to] + _value > balances[_to])\n', '      {\n', '        if ((_from == address(this))||(_to == address(this))) {\n', '          balances[_from] -= _value;\n', '          allowed[_from][_to] -= _value;\n', '          balances[_to] += _value;\n', '          Transfer(_from, _to, _value);\n', '          return true;\n', '        }\n', '        else {\n', '          if (transferAllowed == true) {\n', '            balances[_from] -= _value;\n', '            allowed[_from][_to] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '          }\n', '          else {\n', '            return false;\n', '          }\n', '        }\n', '      }\n', '      else {\n', '        return false;\n', '      }\n', '  }\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}']