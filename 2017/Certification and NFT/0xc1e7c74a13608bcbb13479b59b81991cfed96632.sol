['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    // ------------------------------------------------------------------------\n', '    // Add a number to another number, checking for overflows\n', '    // ------------------------------------------------------------------------\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Subtract a number from another number, checking for underflows\n', '    // ------------------------------------------------------------------------\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\t\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) public returns (bool success) ;\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n', '}\n', '\n', 'contract ALCCrowdsale2 is Owned{\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\t\n', '\tstruct ContributorData{\n', '\t\tbool isActive;\n', '\t\tbool isTokenDistributed;\n', '\t\tuint contributionAmount;\t// ETH contribution\n', '\t\tuint tokensAmount;\t\t\t// Exchanged ALC amount\n', '\t}\n', '\t\n', '\tmapping(address => ContributorData) public contributorList;\n', '\tmapping(uint => address) contributorIndexes;\n', '\tuint nextContributorIndex;\n', '\tuint contributorCount;\n', '    \n', '    address public beneficiary;\n', '    uint public fundingLimit;\n', '    uint public amountRaised;\n', '\tuint public remainAmount;\n', '    uint public deadline;\n', '    uint public exchangeTokenRate;\n', '    token public tokenReward;\n', '\tuint256 public tokenBalance;\n', '    bool public crowdsaleClosed = false;\n', '    bool public isALCDistributed = false;\n', '    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Tranche 1 crowdsale start date and end date\n', '    // Start - 23h00\n', '    // Tier1  - 23h05\n', '    // Tier2  - 23h10\n', '    // Tier3  - 23h15\n', '    // End - 23h20\n', '    // ------------------------------------------------------------------------\n', '    uint public constant START_TIME = 1511614800;\n', '    uint public constant SECOND_TIER_SALE_START_TIME = 1511615100;\n', '    uint public constant THIRD_TIER_SALE_START_TIME = 1511615400;\n', '    uint public constant FOURTH_TIER_SALE_START_TIME = 1511615700;\n', '    uint public constant END_TIME = 1511616000;\n', '\t\n', '\t\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // crowdsale exchange rate\n', '    // ------------------------------------------------------------------------\n', '    uint public START_RATE = 15000;\n', '    uint public SECOND_TIER_RATE = 14000;\n', '    uint public THIRD_TIER_RATE = 12500;\n', '    uint public FOURTH_RATE = 10000;\n', '    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Funding Goal\n', '    //    - HARD CAP : 33000 ETH\n', '    // ------------------------------------------------------------------------\n', '    uint public constant FUNDING_ETH_HARD_CAP = 150000000000000000; //0.15ETH\n', '    \n', '    // IQT token decimals\n', '    uint8 public constant ALC_DECIMALS = 8;\n', '    uint public constant ALC_DECIMALSFACTOR = 10**uint(ALC_DECIMALS);\n', '    \n', '    address public constant ALC_FOUNDATION_ADDRESS = 0x55BeA1A0335A8Ea56572b8E66f17196290Ca6467;\n', '    address public constant ALC_CONTRACT_ADDRESS = 0xB15EF419bA0Dd1f5748c7c60e17Fe88e6e794950;\n', '\n', '    event GoalReached(address raisingAddress, uint amountRaised);\n', '\tevent LimitReached(address raisingAddress, uint amountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\tevent WithdrawFailed(address raisingAddress, uint amount, bool isContribution);\n', '\tevent FundReturn(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    function ALCCrowdsale2(\n', '    ) public {\n', '        beneficiary = ALC_FOUNDATION_ADDRESS;\n', '        fundingLimit = FUNDING_ETH_HARD_CAP;  // Funding limit 0.01ETH\n', '\t    deadline = END_TIME;  // 2017-11-25 12:00:00 UTC\n', '        exchangeTokenRate = FOURTH_RATE * ALC_DECIMALSFACTOR;\n', '        tokenReward = token(ALC_CONTRACT_ADDRESS);\n', '\t\tcontributorCount = 0;\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () public payable {\n', '\t\t\n', '        require(!crowdsaleClosed);\n', '        require(now >= START_TIME && now < END_TIME);\n', '        \n', '\t\tprocessTransaction(msg.sender, msg.value);\n', '    }\n', '\t\n', '\t/**\n', '\t * Process transaction\n', '\t */\n', '\tfunction processTransaction(address _contributor, uint _amount) internal{\t\n', '\t\tuint contributionEthAmount = _amount;\n', '\t\t\t\n', '        amountRaised += contributionEthAmount;                    // add newly received ETH\n', '\t\tremainAmount += contributionEthAmount;\n', '        \n', '\t\t// calcualte exchanged token based on exchange rate\n', '        if (now >= START_TIME && now < SECOND_TIER_SALE_START_TIME){\n', '\t\t\texchangeTokenRate = START_RATE * ALC_DECIMALSFACTOR;\n', '        }\n', '        if (now >= SECOND_TIER_SALE_START_TIME && now < THIRD_TIER_SALE_START_TIME){\n', '            exchangeTokenRate = SECOND_TIER_RATE * ALC_DECIMALSFACTOR;\n', '        }\n', '        if (now >= THIRD_TIER_SALE_START_TIME && now < FOURTH_TIER_SALE_START_TIME){\n', '            exchangeTokenRate = THIRD_TIER_RATE * ALC_DECIMALSFACTOR;\n', '        }\n', '        if (now >= FOURTH_TIER_SALE_START_TIME && now < END_TIME){\n', '            exchangeTokenRate = FOURTH_RATE * ALC_DECIMALSFACTOR;\n', '        }\n', '        uint amountIqtToken = _amount * exchangeTokenRate / 1 ether;\n', '\t\t\n', '\t\tif (contributorList[_contributor].isActive == false){                  // Check if contributor has already contributed\n', '\t\t\tcontributorList[_contributor].isActive = true;                            // Set his activity to true\n', '\t\t\tcontributorList[_contributor].contributionAmount = contributionEthAmount;    // Set his contribution\n', '\t\t\tcontributorList[_contributor].tokensAmount = amountIqtToken;\n', '\t\t\tcontributorList[_contributor].isTokenDistributed = false;\n', '\t\t\tcontributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '\t\t\tnextContributorIndex++;\n', '\t\t\tcontributorCount++;\n', '\t\t}\n', '\t\telse{\n', '\t\t\tcontributorList[_contributor].contributionAmount += contributionEthAmount;   // Add contribution amount to existing contributor\n', '\t\t\tcontributorList[_contributor].tokensAmount += amountIqtToken;             // log token amount`\n', '\t\t}\n', '\t\t\n', '        FundTransfer(msg.sender, contributionEthAmount, true);\n', '\t\t\n', '\t\tif (amountRaised >= fundingLimit){\n', '\t\t\t// close crowdsale because the crowdsale limit is reached\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\t\t\n', '\t\t\n', '\t}\n', '\n', '    modifier afterDeadline() { if (now >= deadline) _; }\t\n', '\tmodifier afterCrowdsaleClosed() { if (crowdsaleClosed == true || now >= deadline) _; }\n', '\t\n', '\t\n', '\t/**\n', '     * close Crowdsale\n', '     *\n', '     */\n', '\tfunction closeCrowdSale() public {\n', '\t\trequire(beneficiary == msg.sender);\n', '\t\tif ( beneficiary == msg.sender) {\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\n', '\t}\n', '\t\n', '    /**\n', '     * Check token balance\n', '     *\n', '     */\n', '\tfunction checkTokenBalance() public {\n', '\t\tif ( beneficiary == msg.sender) {\n', '\t\t\t//check current token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '    /**\n', '     * Withdraw the all funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. \n', '     */\n', '    function safeWithdrawalAll() public {\n', '        if ( beneficiary == msg.sender) {\n', '            if (beneficiary.send(amountRaised)) {\n', '                FundTransfer(beneficiary, amountRaised, false);\n', '\t\t\t\tremainAmount = remainAmount - amountRaised;\n', '            } else {\n', '\t\t\t\tWithdrawFailed(beneficiary, amountRaised, false);\n', '\t\t\t\t//If we fail to send the funds to beneficiary\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. \n', '     */\n', '    function safeWithdrawalAmount(uint256 withdrawAmount) public {\n', '        if (beneficiary == msg.sender) {\n', '            if (beneficiary.send(withdrawAmount)) {\n', '                FundTransfer(beneficiary, withdrawAmount, false);\n', '\t\t\t\tremainAmount = remainAmount - withdrawAmount;\n', '            } else {\n', '\t\t\t\tWithdrawFailed(beneficiary, withdrawAmount, false);\n', '\t\t\t\t//If we fail to send the funds to beneficiary\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * Withdraw ALC \n', '     * \n', '\t * If there are some remaining ALC in the contract \n', '\t * after all token are distributed the contributor,\n', '\t * the beneficiary can withdraw the ALC in the contract\n', '     *\n', '     */\n', '    function withdrawALC(uint256 tokenAmount) public afterCrowdsaleClosed {\n', '\t\trequire(beneficiary == msg.sender);\n', '        if (isALCDistributed && beneficiary == msg.sender) {\n', '            tokenReward.transfer(beneficiary, tokenAmount);\n', '\t\t\t// update token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '        }\n', '    }\n', '\t\n', '\n', '\t/**\n', '     * Distribute token\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * distribute token to contributor. \n', '     */\n', '\tfunction distributeALCToken() public {\n', '\t\tif (beneficiary == msg.sender) {  // only ALC_FOUNDATION_ADDRESS can distribute the ALC\n', '\t\t\taddress currentParticipantAddress;\n', '\t\t\tfor (uint index = 0; index < contributorCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\t\tuint amountAlcToken = contributorList[currentParticipantAddress].tokensAmount;\n', '\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountAlcToken);\n', '\t\t\t\t\tif (isSuccess){\n', '\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t// check if all ALC are distributed\n', '\t\t\tcheckIfAllALCDistributed();\n', '\t\t\t// get latest token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '     * Distribute token by batch\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * distribute token to contributor. \n', '     */\n', '\tfunction distributeALCTokenBatch(uint batchUserCount) public {\n', '\t\tif (beneficiary == msg.sender) {  // only ALC_FOUNDATION_ADDRESS can distribute the ALC\n', '\t\t\taddress currentParticipantAddress;\n', '\t\t\tuint transferedUserCount = 0;\n', '\t\t\tfor (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\t\tuint amountAlcToken = contributorList[currentParticipantAddress].tokensAmount;\n', '\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountAlcToken);\n', '\t\t\t\t\ttransferedUserCount = transferedUserCount + 1;\n', '\t\t\t\t\tif (isSuccess){\n', '\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t// check if all ALC are distributed\n', '\t\t\tcheckIfAllALCDistributed();\n', '\t\t\t// get latest token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', "\t * Check if all contributor's token are successfully distributed\n", '\t */\n', '\tfunction checkIfAllALCDistributed() public {\n', '\t    address currentParticipantAddress;\n', '\t\tisALCDistributed = true;\n', '\t\tfor (uint index = 0; index < contributorCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\tisALCDistributed = false;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '}']