['pragma solidity ^0.4.18;\n', '\n', 'contract useContractWeb {\n', '\n', '  ContractWeb internal web = ContractWeb(0x0);\n', '\n', '}\n', '\n', 'contract Owned {\n', '\n', '  address public owner = msg.sender;\n', '\n', '  function transferOwner(address _newOwner) onlyOwner public returns (bool) {\n', '    owner = _newOwner;\n', '    return true;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract CheckPayloadSize {\n', '\n', '  modifier onlyPayloadSize(uint256 _size) {\n', '    require(msg.data.length >= _size + 4);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract CanTransferTokens is CheckPayloadSize, Owned {\n', '\n', '  function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) {\n', '    Token tkn = Token(_token);\n', '    return tkn.transfer(_to, _value);\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '  function add(uint256 x, uint256 y) pure internal returns (uint256) {\n', '    require(x <= x + y);\n', '    return x + y;\n', '  }\n', '\n', '  function sub(uint256 x, uint256 y) pure internal returns (uint256) {\n', '    require(x >= y);\n', '    return x - y;\n', '  }\n', '\n', '}\n', '\n', 'contract CheckIfContract {\n', '\n', '  function isContract(address _addr) view internal returns (bool) {\n', '    uint256 length;\n', '    if (_addr == address(0x0)) return false;\n', '    assembly {\n', '      length := extcodesize(_addr)\n', '    }\n', '    if(length > 0) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '}\n', '\n', 'contract ContractReceiver {\n', '\n', '  TKN internal fallback;\n', '\n', '  struct TKN {\n', '    address sender;\n', '    uint256 value;\n', '    bytes data;\n', '    bytes4 sig;\n', '  }\n', '\n', '  function getFallback() view public returns (TKN) {\n', '    return fallback;\n', '  }\n', '\n', '\n', '  function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\n', '    TKN memory tkn;\n', '    tkn.sender = _from;\n', '    tkn.value = _value;\n', '    tkn.data = _data;\n', '    uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '    tkn.sig = bytes4(u);\n', '    fallback = tkn;\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Token1st {\n', '\n', '  address public currentTradingSystem;\n', '  address public currentExchangeSystem;\n', '\n', '  mapping(address => uint) public balanceOf;\n', '  mapping(address => mapping (address => uint)) public allowance;\n', '  mapping(address => mapping (address => uint)) public tradingBalanceOf;\n', '  mapping(address => mapping (address => uint)) public exchangeBalanceOf;\n', '\n', '  /* @notice get balance of a specific address */\n', '  function getBalanceOf(address _address) view public returns (uint amount){\n', '    return balanceOf[_address];\n', '  }\n', '\n', '  event Transfer (address _to, address _from, uint _decimalAmount);\n', '\n', '  /* A contract or user attempts to get the coins */\n', '  function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    require(balanceOf[_from]\n', '      - tradingBalanceOf[_from][currentTradingSystem]\n', '      - exchangeBalanceOf[_from][currentExchangeSystem] >= _value);                 // Check if the sender has enough\n', '    require(balanceOf[_to] + (_value) >= balanceOf[_to]);  // Check for overflows\n', '    require(_value <= allowance[_from][msg.sender]);   // Check allowance\n', '    balanceOf[_from] -= _value;                          // Subtract from the sender\n', '    balanceOf[_to] += _value;                            // Add the same to the recipient\n', '    allowance[_from][msg.sender] -= _value;\n', '    Transfer(_to, _from, _value);\n', '    return true;\n', '  }\n', '\n', '    /* Allow another contract or user to spend some tokens in your behalf */\n', '  function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) {\n', '    allowance[msg.sender][_spender] = _value;\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract ContractWeb is CanTransferTokens, CheckIfContract {\n', '\n', '      //contract name | contract info\n', '  mapping(string => contractInfo) internal contracts;\n', '\n', '  event ContractAdded(string _name, address _referredTo);\n', '  event ContractEdited(string _name, address _referredTo);\n', '  event ContractMadePermanent(string _name);\n', '\n', '  struct contractInfo {\n', '    address contractAddress;\n', '    bool isPermanent;\n', '  }\n', '\n', '  function getContractAddress(string _name) view public returns (address) {\n', '    return contracts[_name].contractAddress;\n', '  }\n', '\n', '  function isContractPermanent(string _name) view public returns (bool) {\n', '    return contracts[_name].isPermanent;\n', '  }\n', '\n', '  function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n', '    require(isContract(_address));\n', '    require(this != _address);\n', '    require(contracts[_name].contractAddress != _address);\n', '    require(contracts[_name].isPermanent == false);\n', '    address oldAddress = contracts[_name].contractAddress;\n', '    contracts[_name].contractAddress = _address;\n', '    if(oldAddress == address(0x0)) {\n', '      ContractAdded(_name, _address);\n', '    } else {\n', '      ContractEdited(_name, _address);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function makeContractPermanent(string _name) onlyOwner public returns (bool) {\n', '    require(contracts[_name].contractAddress != address(0x0));\n', '    require(contracts[_name].isPermanent == false);\n', '    contracts[_name].isPermanent = true;\n', '    ContractMadePermanent(_name);\n', '    return true;\n', '  }\n', '\n', '  function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) {\n', '    setContract("Token1st", _Tokens1st);\n', '    setContract("Balances", _Balancecs);\n', '    setContract("Token", _Token);\n', '    setContract("Conversion", _Conversion);\n', '    setContract("Distribution", _Distribution);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Balances is CanTransferTokens, SafeMath, useContractWeb {\n', '\n', '  mapping(address => uint256) internal _balances;\n', '\n', '  function get(address _account) view public returns (uint256) {\n', '    return _balances[_account];\n', '  }\n', '\n', '  function tokenContract() view public returns (address) {\n', '    return web.getContractAddress("Token");\n', '  }\n', '\n', '  function Balances() public {\n', '    _balances[msg.sender] = 190 * 1000000 * 1000000000000000000;\n', '  }\n', '\n', '  modifier onlyToken {\n', '    require(msg.sender == tokenContract());\n', '    _;\n', '  }\n', '\n', '  function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) {\n', '  _balances[_from] = sub(_balances[_from], _value);\n', '  _balances[_to] = add(_balances[_to], _value);\n', '  return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb {\n', '\n', '  string public symbol = "SHC";\n', '  string public name = "ShineCoin";\n', '  uint8 public decimals = 18;\n', '  uint256 public totalSupply = 190 * 1000000 * 1000000000000000000;\n', '\n', '  mapping (address => mapping (address => uint256)) internal _allowance;\n', '\n', '    // ERC20 Events\n', '  event Approval(address indexed from, address indexed to, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // ERC223 Event\n', '  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n', '\n', '  function balanceOf(address _account) view public returns (uint256) {\n', '    return Balances(balancesContract()).get(_account);\n', '  }\n', '\n', '  function allowance(address _from, address _to) view public returns (uint256 remaining) {\n', '    return _allowance[_from][_to];\n', '  }\n', '\n', '  function balancesContract() view public returns (address) {\n', '    return web.getContractAddress("Balances");\n', '  }\n', '\n', '  function Token() public {\n', '    bytes memory empty;\n', '    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000);\n', '    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty);\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {\n', '    if(isContract(_to)) {\n', '      require(Balances(balancesContract()).get(msg.sender) >= _value);\n', '      Balances(balancesContract()).transfer(msg.sender, _to, _value);\n', '      ContractReceiver receiver = ContractReceiver(_to);\n', '      require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '      Transfer(msg.sender, _to, _value);\n', '      Transfer(msg.sender, _to, _value, _data);\n', '      return true;\n', '    } else {\n', '      return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '    if(isContract(_to)) {\n', '      return transferToContract(_to, _value, _data);\n', '    }\n', '    else {\n', '      return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '    bytes memory empty;\n', '    if(isContract(_to)) {\n', '      return transferToContract(_to, _value, empty);\n', '    }\n', '    else {\n', '      return transferToAddress(_to, _value, empty);\n', '    }\n', '  }\n', '\n', '  function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '    require(Balances(balancesContract()).get(msg.sender) >= _value);\n', '    Balances(balancesContract()).transfer(msg.sender, _to, _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '    require(Balances(balancesContract()).get(msg.sender) >= _value);\n', '    Balances(balancesContract()).transfer(msg.sender, _to, _value);\n', '    ContractReceiver receiver = ContractReceiver(_to);\n', '    receiver.tokenFallback(msg.sender, _value, _data);\n', '    Transfer(msg.sender, _to, _value);\n', '    Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) {\n', '    bytes memory empty;\n', '    require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value);\n', '    _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value);\n', '    if(msg.sender != _to && isContract(_to)) {\n', '      Balances(balancesContract()).transfer(_from, _to, _value);\n', '      ContractReceiver receiver = ContractReceiver(_to);\n', '      receiver.tokenFallback(_from, _value, empty);\n', '    } else {\n', '      Balances(balancesContract()).transfer(_from, _to, _value);\n', '    }\n', '    Transfer(_from, _to, _value);\n', '    Transfer(_from, _to, _value, empty);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\n', '    _allowance[msg.sender][_to] = add(_allowance[msg.sender][_to], _value);\n', '    Approval(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Conversion is CanTransferTokens, useContractWeb {\n', '\n', '  function token1stContract() view public returns (address) {\n', '    return web.getContractAddress("Token1st");\n', '  }\n', '\n', '  function tokenContract() view public returns (address) {\n', '    return web.getContractAddress("Token");\n', '  }\n', '\n', '  function deposit() onlyOwner public returns (bool) {\n', '    require(Token(tokenContract()).allowance(owner, this) > 0);\n', '    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\n', '  }\n', '\n', '  function convert() public returns (bool) {\n', '    uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender);\n', '    require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance);\n', '    Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance);\n', '    return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000);\n', '  }\n', '\n', '}\n', '\n', 'contract Distribution is CanTransferTokens, SafeMath, useContractWeb {\n', '\n', '  uint256 public liveSince;\n', '  uint256 public withdrawn;\n', '\n', '  function withdrawnReadable() view public returns (uint256) {\n', '    return withdrawn / 1000000000000000000;\n', '  }\n', '\n', '  function secondsLive() view public returns (uint256) {\n', '    if(liveSince != 0) {\n', '      return now - liveSince;\n', '    }\n', '  }\n', '\n', '  function allowedSince() view public returns (uint256) {\n', '    return secondsLive() * 380265185769276972;\n', '  }\n', '\n', '  function allowedSinceReadable() view public returns (uint256) {\n', '    return secondsLive() * 380265185769276972 / 1000000000000000000;\n', '  }\n', '\n', '  function stillAllowed() view public returns (uint256) {\n', '    return allowedSince() - withdrawn;\n', '  }\n', '\n', '  function stillAllowedReadable() view public returns (uint256) {\n', '    uint256 _1 = allowedSince() - withdrawn;\n', '    return _1 / 1000000000000000000;\n', '  }\n', '\n', '  function tokenContract() view public returns (address) {\n', '    return web.getContractAddress("Token");\n', '  }\n', '\n', '  function makeLive() onlyOwner public returns (bool) {\n', '    require(liveSince == 0);\n', '    liveSince = now;\n', '    return true;\n', '  }\n', '\n', '  function deposit() onlyOwner public returns (bool) {\n', '    require(Token(tokenContract()).allowance(owner, this) > 0);\n', '    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n', '    require(stillAllowed() >= _value && _value > 0 && liveSince != 0);\n', '    withdrawn = add(withdrawn, _value);\n', '    return Token(tokenContract()).transfer(_to, _value);\n', '  }\n', '\n', '  function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n', '    require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0);\n', '    withdrawn = add(withdrawn, _value * 1000000000000000000);\n', '    return Token(tokenContract()).transfer(_to, _value * 1000000000000000000);\n', '  }\n', '\n', '}']