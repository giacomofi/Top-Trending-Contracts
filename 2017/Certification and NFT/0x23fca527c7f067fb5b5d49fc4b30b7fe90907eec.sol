['pragma solidity ^0.4.15;\n', '\n', '\n', '// ERC20 token interface is implemented only partially.\n', '\n', 'contract PresaleToken {\n', '\n', '    /// NAC Broker Presale Token\n', '    /// @dev Constructor\n', '    /// @param _tokenManager Token manager address.\n', '    function PresaleToken(address _tokenManager, address _escrow) public {\n', '        tokenManager = _tokenManager;\n', '        escrow = _escrow;\n', '        // send ~ 60tr NAC private sales\n', '        balanceOf[escrow] += 60329080000000000000000000; // 60 329 080 tr Nac\n', '        totalSupply += 60329080000000000000000000;\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Constants\n', '    /*/\n', '\n', '    string public name = "NAC Presales Token";\n', '    string public  symbol = "NAC";\n', '    uint   public decimals = 18;\n', '\n', '    uint public constant PRICE = 3450; // 3450 NAC per Ether\n', '\n', '    //  price\n', '    // Cup is 150000 ETH\n', '    // 1 eth = 3450 presale tokens\n', '\n', '    uint public constant TOKEN_SUPPLY_LIMIT = PRICE * 150000 * (1 ether / 1 wei);\n', '\n', '    /*/\n', '     *  Token state\n', '    /*/\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '    uint public totalSupply = 0; // amount of tokens already sold\n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManager;\n', '\n', "    // Gathered funds can be withdrawn only to escrow's address.\n", '    address public escrow;\n', '\n', '    // Crowdsale manager has exclusive priveleges to burn presale tokens.\n', '    address public crowdsaleManager;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => bool) public isSaler;\n', '\n', '    modifier onlyTokenManager() { \n', '        require(msg.sender == tokenManager); \n', '        _; \n', '    }\n', '    modifier onlyCrowdsaleManager() {\n', '        require(msg.sender == crowdsaleManager); \n', '        _; \n', '    }\n', '\n', '    modifier onlyEscrow() {\n', '        require(msg.sender == escrow);\n', '        _;\n', '    }\n', '\n', '    /*/\n', '     *  Events\n', '    /*/\n', '\n', '    event LogBuy(address indexed owner, uint value);\n', '    event LogBurn(address indexed owner, uint value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /*/\n', '     *  Public functions\n', '    /*/\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(balanceOf[_from] > _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(balanceOf[msg.sender] - _value < balanceOf[msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', "    // Transfer the balance from owner's account to another account\n", '    // only escrow can send token (to send token private sale)\n', '    function transfer(address _to, uint256 _value) public\n', '        onlyEscrow\n', '    {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /*\n', '    *        >=3000 ETH: 1ETH = 6000 NAC\n', '    *        >=300 ETH: 1ETH = 4800 NAC\n', '    *        <300 ETH: 1ETH = 3450 NAC\n', '    */\n', '    function getBonus(uint value) internal returns (uint bonus) {\n', '        require(value != 0);\n', '        if (value >= (3000 * 10**18)) {\n', '            return value * 2550;\n', '        } else if (value >= (300 * 10**18)) {\n', '            return value * 1350;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '\n', '    function() payable public {\n', '        buy(msg.sender);\n', '    }\n', '    \n', '    function buy(address _buyer) payable public {\n', '        // Available only if presale is running.\n', '        require(currentPhase == Phase.Running);\n', '        require(msg.value != 0);\n', '        uint newTokens = msg.value * PRICE + getBonus(msg.value);\n', '        require (totalSupply + newTokens < TOKEN_SUPPLY_LIMIT);\n', '        balanceOf[_buyer] += newTokens;\n', '        totalSupply += newTokens;\n', '        LogBuy(_buyer, newTokens);\n', '    }\n', '    \n', '    function buyTokens(address _saler) payable public {\n', '        // Available only if presale is running.\n', '        require(isSaler[_saler] == true);\n', '        require(currentPhase == Phase.Running);\n', '\n', '        require(msg.value != 0);\n', '        uint newTokens = msg.value * PRICE + getBonus(msg.value);\n', '        uint tokenForSaler = newTokens / 20;\n', '        \n', '        require(totalSupply + newTokens + tokenForSaler <= TOKEN_SUPPLY_LIMIT);\n', '        \n', '        balanceOf[_saler] += tokenForSaler;\n', '        balanceOf[msg.sender] += newTokens;\n', '\n', '        totalSupply += newTokens;\n', '        totalSupply += tokenForSaler;\n', '        \n', '        LogBuy(msg.sender, newTokens);\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function burnTokens(address _owner) public\n', '        onlyCrowdsaleManager\n', '    {\n', '        // Available only during migration phase\n', '        require(currentPhase == Phase.Migrating);\n', '\n', '        uint tokens = balanceOf[_owner];\n', '        require(tokens != 0);\n', '        balanceOf[_owner] = 0;\n', '        totalSupply -= tokens;\n', '        LogBurn(_owner, tokens);\n', '\n', '        // Automatically switch phase when migration is done.\n', '        if (totalSupply == 0) {\n', '            currentPhase = Phase.Migrated;\n', '            LogPhaseSwitch(Phase.Migrated);\n', '        }\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Administrative functions\n', '    /*/\n', '    function setPresalePhase(Phase _nextPhase) public\n', '        onlyTokenManager\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '                // switch to migration phase only if crowdsale manager is set\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '                // switch to migrated only if everyting is migrated\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        require(canSwitchPhase);\n', '        currentPhase = _nextPhase;\n', '        LogPhaseSwitch(_nextPhase);\n', '    }\n', '\n', '\n', '    function withdrawEther() public\n', '        onlyTokenManager\n', '    {\n', '        require(escrow != 0x0);\n', '        // Available at any phase.\n', '        if (this.balance > 0) {\n', '            escrow.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '\n', '    function setCrowdsaleManager(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', "        // You can't change crowdsale contract when migration is in progress.\n", '        require(currentPhase != Phase.Migrating);\n', '        crowdsaleManager = _mgr;\n', '    }\n', '\n', '    function addSaler(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', '        require(currentPhase != Phase.Migrating);\n', '        isSaler[_mgr] = true;\n', '    }\n', '\n', '    function removeSaler(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', '        require(currentPhase != Phase.Migrating);\n', '        isSaler[_mgr] = false;\n', '    }\n', '}']