['pragma solidity ^0.4.17;\n', '\n', '//\n', '// Swarm Voting MVP\n', '// Single use contract to manage liquidity vote shortly after Swarm TS\n', '// Author: Max Kaye\n', '//\n', '//\n', '// Architecture:\n', '// * Ballot authority declares public key with which to encrypt ballots\n', '// * Users submit encrypted ballots as blobs\n', '// * These ballots are tracked by the ETH address of the sender\n', '// * Following the conclusion of the ballot, the secret key is provided\n', '//   by the ballot authority, and all users may transparently and\n', '//   independently validate the results\n', '//\n', '// Notes:\n', '// * Since ballots are encrypted the only validation we can do is length\n', '//\n', '\n', '\n', 'contract SwarmVotingMVP {\n', '    //// ** Storage Variables\n', '\n', '    // Std owner pattern\n', '    address public owner;\n', '\n', '    // test mode - operations like changing start/end times\n', '    bool public testMode = false;\n', '\n', '    // Maps to store ballots, along with corresponding log of voters.\n', '    // Should only be modified through `addBallotAndVoter` internal function\n', '    mapping(uint256 => bytes32) public encryptedBallots;\n', '    mapping(uint256 => bytes32) public associatedPubkeys;\n', '    mapping(uint256 => address) public associatedAddresses;\n', '    uint256 public nVotesCast = 0;\n', '\n', '    // Use a map for voters to look up their ballot\n', '    mapping(address => uint256) public voterToBallotID;\n', '\n', '    // Public key with which to encrypt ballots - curve25519\n', '    bytes32 public ballotEncryptionPubkey;\n', '\n', '    // Private key to be set after ballot conclusion - curve25519\n', '    bytes32 public ballotEncryptionSeckey;\n', '    bool seckeyRevealed = false;\n', '\n', '    // Timestamps for start and end of ballot (UTC)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // Banned addresses - necessary to ban Swarm Fund from voting in their own ballot\n', '    mapping(address => bool) public bannedAddresses;\n', '    // TODO: Is this the right address?\n', '    address public swarmFundAddress = 0x8Bf7b2D536D286B9c5Ad9d99F608e9E214DE63f0;\n', '\n', '\n', '    //// ** Events\n', '    event CreatedBallot(address creator, uint256 start, uint256 end, bytes32 encPubkey);\n', '    event FailedVote(address voter, string reason);\n', '    event SuccessfulVote(address voter, bytes32 ballot, bytes32 pubkey);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event Error(string error);\n', '\n', '\n', '    //// ** Modifiers\n', '\n', '    modifier notBanned {\n', '        if (!bannedAddresses[msg.sender]) {  // ensure banned addresses cannot vote\n', '            _;\n', '        } else {\n', '            Error("Banned address");\n', '        }\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender == owner) {  // fail if msg.sender is not the owner\n', '            _;\n', '        } else {\n', '            Error("Not owner");\n', '        }\n', '    }\n', '\n', '    modifier ballotOpen {\n', '        if (block.timestamp > startTime && block.timestamp < endTime) {\n', '            _;\n', '        } else {\n', '            Error("Ballot not open");\n', '        }\n', '    }\n', '\n', '    modifier onlyTesting {\n', '        if (testMode) {\n', '            _;\n', '        } else {\n', '            Error("Testing disabled");\n', '        }\n', '    }\n', '\n', '    //// ** Functions\n', '\n', '    // Constructor function - init core params on deploy\n', '    function SwarmVotingMVP(uint256 _startTime, uint256 _endTime, bytes32 _encPK, bool enableTesting) public {\n', '        owner = msg.sender;\n', '\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        ballotEncryptionPubkey = _encPK;\n', '\n', '        bannedAddresses[swarmFundAddress] = true;\n', '\n', '        if (enableTesting) {\n', '            testMode = true;\n', '            TestingEnabled();\n', '        }\n', '    }\n', '\n', '    // Ballot submission\n', '    function submitBallot(bytes32 encryptedBallot, bytes32 senderPubkey) notBanned ballotOpen public {\n', '        addBallotAndVoter(encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    // Internal function to ensure atomicity of voter log\n', '    function addBallotAndVoter(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\n', '        uint256 ballotNumber = nVotesCast;\n', '        encryptedBallots[ballotNumber] = encryptedBallot;\n', '        associatedPubkeys[ballotNumber] = senderPubkey;\n', '        associatedAddresses[ballotNumber] = msg.sender;\n', '        voterToBallotID[msg.sender] = ballotNumber;\n', '        nVotesCast += 1;\n', '        SuccessfulVote(msg.sender, encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(bytes32 _secKey) onlyOwner public {\n', '        require(block.timestamp > endTime);\n', '\n', '        ballotEncryptionSeckey = _secKey;\n', '        seckeyRevealed = true;  // this flag allows the contract to be locked\n', '        SeckeyRevealed(_secKey);\n', '    }\n', '\n', '    // Helpers\n', '    function getEncPubkey() public constant returns (bytes32) {\n', '        return ballotEncryptionPubkey;\n', '    }\n', '\n', '    function getEncSeckey() public constant returns (bytes32) {\n', '        return ballotEncryptionSeckey;\n', '    }\n', '\n', '    function getBallotOptions() public pure returns (uint8[2][4]) {\n', '        // NOTE: storing a 4x2 array in storage nearly doubled the gas cost\n', '        // of deployment - compromise is to create a constant function\n', '        return [\n', '            [8, 42],\n', '            [42, 8],\n', '            [16, 42],\n', '            [4, 84]\n', '        ];\n', '    }\n', '    \n', '    // ballot params - allows the frontend to do some checking\n', '    function getBallotOptNumber() public pure returns (uint256) {\n', '        return 4;\n', '    }\n', '\n', '    // Test functions\n', '    function setEndTime(uint256 newEndTime) onlyTesting onlyOwner public {\n', '        endTime = newEndTime;\n', '    }\n', '\n', '    function banAddress(address _addr) onlyTesting onlyOwner public {\n', '        bannedAddresses[_addr] = true;\n', '    }\n', '}']