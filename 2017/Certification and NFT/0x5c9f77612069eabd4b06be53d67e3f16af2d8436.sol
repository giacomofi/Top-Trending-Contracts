['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title IWingsAdapter\n', ' * \n', ' * WINGS DAO Price Discovery & Promotion Pre-Beta https://www.wings.ai\n', ' *\n', ' * #created 04/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract IWingsAdapter {\n', '\n', '\n', '    /**\n', '     * Get the total raised amount of Ether\n', '     *\n', '     * Can only increase, meaning if you withdraw ETH from the wallet, it should be not modified (you can use two fields \n', '     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\n', '     *\n', '     * @return Total raised Ether amount\n', '     */\n', '    function totalCollected() constant returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * @title Token retrieve interface\n', ' *\n', ' * Allows tokens to be retrieved from a contract\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract ITokenRetreiver {\n', '\n', '    /**\n', '     * Extracts tokens from the contract\n', '     *\n', '     * @param _tokenContract The address of ERC20 compatible token\n', '     */\n', '    function retreiveTokens(address _tokenContract);\n', '}\n', '\n', '\n', 'contract Owned {\n', '\n', '    // The address of the account that is the current owner \n', '    address internal owner;\n', '\n', '\n', '    /**\n', '     * The publisher is the inital owner\n', '     */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * Access is restricted to the current owner\n', '     */\n', '    modifier only_owner() {\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 compatible token interface\n', ' *\n', ' * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', ' * - Short address attack fix\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract IToken { \n', '\n', '    /** \n', '     * Get the total supply of tokens\n', '     * \n', '     * @return The total supply\n', '     */\n', '    function totalSupply() constant returns (uint);\n', '\n', '\n', '    /** \n', '     * Get balance of `_owner` \n', '     * \n', '     * @param _owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint);\n', '\n', '\n', '    /** \n', '     * Send `_value` token to `_to` from `msg.sender`\n', '     * \n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint _value) returns (bool);\n', '\n', '\n', '    /** \n', '     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     * \n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '\n', '\n', '    /** \n', '     * `msg.sender` approves `_spender` to spend `_value` tokens\n', '     * \n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of tokens to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint _value) returns (bool);\n', '\n', '\n', '    /** \n', '     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\n', '     * \n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * @title ManagedToken interface\n', ' *\n', ' * Adds the following functionallity to the basic ERC20 token\n', ' * - Locking\n', ' * - Issuing\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract IManagedToken is IToken { \n', '\n', '    /** \n', '     * Returns true if the token is locked\n', '     * \n', '     * @return Whether the token is locked\n', '     */\n', '    function isLocked() constant returns (bool);\n', '\n', '\n', '    /**\n', '     * Unlocks the token so that the transferring of value is enabled \n', '     *\n', '     * @return Whether the unlocking was successful or not\n', '     */\n', '    function unlock() returns (bool);\n', '\n', '\n', '    /**\n', '     * Issues `_value` new tokens to `_to`\n', '     *\n', '     * @param _to The address to which the tokens will be issued\n', '     * @param _value The amount of new tokens to issue\n', '     * @return Whether the tokens where sucessfully issued or not\n', '     */\n', '    function issue(address _to, uint _value) returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title ICrowdsale\n', ' *\n', ' * Base crowdsale interface to manage the sale of \n', ' * an ERC20 token\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract ICrowdsale {\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the presale phase\n', '     *\n', '     * @return True if in presale phase\n', '     */\n', '    function isInPresalePhase() constant returns (bool);\n', '\n', '\n', '    /**\n', '     * Returns true if `_beneficiary` has a balance allocated\n', '     *\n', '     * @param _beneficiary The account that the balance is allocated for\n', '     * @param _releaseDate The date after which the balance can be withdrawn\n', '     * @return True if there is a balance that belongs to `_beneficiary`\n', '     */\n', '    function hasBalance(address _beneficiary, uint _releaseDate) constant returns (bool);\n', '\n', '\n', '    /** \n', '     * Get the allocated token balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated token balance will be retrieved\n', '     * @return The allocated token balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint);\n', '\n', '\n', '    /** \n', '     * Get the allocated eth balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated eth balance will be retrieved\n', '     * @return The allocated eth balance\n', '     */\n', '    function ethBalanceOf(address _owner) constant returns (uint);\n', '\n', '\n', '    /** \n', '     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\n', '     * \n', '     * @param _owner The address from which the refundable balance will be retrieved\n', '     * @return The invested refundable balance\n', '     */\n', '    function refundableEthBalanceOf(address _owner) constant returns (uint);\n', '\n', '\n', '    /**\n', '     * Returns the rate and bonus release date\n', '     *\n', '     * @param _phase The phase to use while determining the rate\n', '     * @param _volume The amount wei used to determine what volume multiplier to use\n', '     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\n', '     */\n', '    function getRate(uint _phase, uint _volume) constant returns (uint);\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in tokens using \n', '     * the `_rate`\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @param _rate rate to use for the conversion\n', '     * @return Amount in tokens\n', '     */\n', '    function toTokens(uint _wei, uint _rate) constant returns (uint);\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     */\n', '    function withdrawTokens();\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     */\n', '    function withdrawEther();\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     */\n', '    function refund();\n', '\n', '\n', '    /**\n', '     * Receive Eth and issue tokens to the sender\n', '     */\n', '    function () payable;\n', '}\n', '\n', '\n', '/**\n', ' * @title Crowdsale\n', ' *\n', ' * Abstract base crowdsale contract that manages the sale of \n', ' * an ERC20 token\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract Crowdsale is ICrowdsale, Owned {\n', '\n', '    enum Stages {\n', '        Deploying,\n', '        Deployed,\n', '        InProgress,\n', '        Ended\n', '    }\n', '\n', '    struct Balance {\n', '        uint eth;\n', '        uint tokens;\n', '        uint index;\n', '    }\n', '\n', '    struct Percentage {\n', '        uint eth;\n', '        uint tokens;\n', '        bool overwriteReleaseDate;\n', '        uint fixedReleaseDate;\n', '        uint index; \n', '    }\n', '\n', '    struct Payout {\n', '        uint percentage;\n', '        uint vestingPeriod;\n', '    }\n', '\n', '    struct Phase {\n', '        uint rate;\n', '        uint end;\n', '        uint bonusReleaseDate;\n', '        bool useVolumeMultiplier;\n', '    }\n', '\n', '    struct VolumeMultiplier {\n', '        uint rateMultiplier;\n', '        uint bonusReleaseDateMultiplier;\n', '    }\n', '\n', '    // Crowdsale details\n', '    uint public baseRate;\n', '    uint public minAmount; \n', '    uint public maxAmount; \n', '    uint public minAcceptedAmount;\n', '    uint public minAmountPresale; \n', '    uint public maxAmountPresale;\n', '    uint public minAcceptedAmountPresale;\n', '\n', '    // Company address\n', '    address public beneficiary; \n', '\n', '    // Denominators\n', '    uint internal percentageDenominator;\n', '    uint internal tokenDenominator;\n', '\n', '    // Crowdsale state\n', '    uint public start;\n', '    uint public presaleEnd;\n', '    uint public crowdsaleEnd;\n', '    uint public raised;\n', '    uint public allocatedEth;\n', '    uint public allocatedTokens;\n', '    Stages public stage = Stages.Deploying;\n', '\n', '    // Token contract\n', '    IManagedToken public token;\n', '\n', '    // Invested balances\n', '    mapping (address => uint) private balances;\n', '\n', '    // Alocated balances\n', '    mapping (address => mapping(uint => Balance)) private allocated;\n', '    mapping(address => uint[]) private allocatedIndex;\n', '\n', '    // Stakeholders\n', '    mapping (address => Percentage) private stakeholderPercentages;\n', '    address[] private stakeholderPercentagesIndex;\n', '    Payout[] private stakeholdersPayouts;\n', '\n', '    // Crowdsale phases\n', '    Phase[] private phases;\n', '\n', '    // Volume multipliers\n', '    mapping (uint => VolumeMultiplier) private volumeMultipliers;\n', '    uint[] private volumeMultiplierThresholds;\n', '\n', '\n', '    /**\n', '     * Throw if at stage other than current stage\n', '     * \n', '     * @param _stage expected stage to test for\n', '     */\n', '    modifier at_stage(Stages _stage) {\n', '        require(stage == _stage);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Only after crowdsaleEnd plus `_time`\n', '     * \n', '     * @param _time Time to pass\n', '     */\n', '    modifier only_after(uint _time) {\n', '        require(now > crowdsaleEnd + _time);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Only after crowdsale\n', '     */\n', '    modifier only_after_crowdsale() {\n', '        require(now > crowdsaleEnd);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Throw if sender is not beneficiary\n', '     */\n', '    modifier only_beneficiary() {\n', '        require(beneficiary == msg.sender);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allows the implementing contract to validate a \n', '     * contributing account\n', '     *\n', '     * @param _contributor Address that is being validated\n', '     * @return Wheter the contributor is accepted or not\n', '     */\n', '    function isAcceptedContributor(address _contributor) internal constant returns (bool);\n', '\n', '\n', '    /**\n', '     * Setup the crowdsale\n', '     *\n', '     * @param _start The timestamp of the start date\n', '     * @param _token The token that is sold\n', '     * @param _tokenDenominator The token amount of decimals that the token uses\n', '     * @param _percentageDenominator The percision of percentages\n', '     * @param _minAmount The min cap for the ICO\n', '     * @param _maxAmount The max cap for the ICO\n', '     * @param _minAcceptedAmount The lowest accepted amount during the ICO phase\n', '     * @param _minAmountPresale The min cap for the presale\n', '     * @param _maxAmountPresale The max cap for the presale\n', '     * @param _minAcceptedAmountPresale The lowest accepted amount during the presale phase\n', '     */\n', '    function Crowdsale(uint _start, address _token, uint _tokenDenominator, uint _percentageDenominator, uint _minAmount, uint _maxAmount, uint _minAcceptedAmount, uint _minAmountPresale, uint _maxAmountPresale, uint _minAcceptedAmountPresale) {\n', '        token = IManagedToken(_token);\n', '        tokenDenominator = _tokenDenominator;\n', '        percentageDenominator = _percentageDenominator;\n', '        start = _start;\n', '        minAmount = _minAmount;\n', '        maxAmount = _maxAmount;\n', '        minAcceptedAmount = _minAcceptedAmount;\n', '        minAmountPresale = _minAmountPresale;\n', '        maxAmountPresale = _maxAmountPresale;\n', '        minAcceptedAmountPresale = _minAcceptedAmountPresale;\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup rates and phases\n', '     *\n', '     * @param _baseRate The rate without bonus\n', '     * @param _phaseRates The rates for each phase\n', '     * @param _phasePeriods The periods that each phase lasts (first phase is the presale phase)\n', '     * @param _phaseBonusLockupPeriods The lockup period that each phase lasts\n', '     * @param _phaseUsesVolumeMultiplier Wheter or not volume bonusses are used in the respective phase\n', '     */\n', '    function setupPhases(uint _baseRate, uint[] _phaseRates, uint[] _phasePeriods, uint[] _phaseBonusLockupPeriods, bool[] _phaseUsesVolumeMultiplier) public only_owner at_stage(Stages.Deploying) {\n', '        baseRate = _baseRate;\n', '        presaleEnd = start + _phasePeriods[0]; // First phase is expected to be the presale phase\n', '        crowdsaleEnd = start; // Plus the sum of the rate phases\n', '\n', '        for (uint i = 0; i < _phaseRates.length; i++) {\n', '            crowdsaleEnd += _phasePeriods[i];\n', '            phases.push(Phase(_phaseRates[i], crowdsaleEnd, 0, _phaseUsesVolumeMultiplier[i]));\n', '        }\n', '\n', '        for (uint ii = 0; ii < _phaseRates.length; ii++) {\n', '            if (_phaseBonusLockupPeriods[ii] > 0) {\n', '                phases[ii].bonusReleaseDate = crowdsaleEnd + _phaseBonusLockupPeriods[ii];\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup stakeholders\n', '     *\n', '     * @param _stakeholders The addresses of the stakeholders (first stakeholder is the beneficiary)\n', '     * @param _stakeholderEthPercentages The eth percentages of the stakeholders\n', '     * @param _stakeholderTokenPercentages The token percentages of the stakeholders\n', '     * @param _stakeholderTokenPayoutOverwriteReleaseDates Wheter the vesting period is overwritten for the respective stakeholder\n', '     * @param _stakeholderTokenPayoutFixedReleaseDates The vesting period after which the whole percentage of the tokens is released to the respective stakeholder\n', '     * @param _stakeholderTokenPayoutPercentages The percentage of the tokens that is released at the respective date\n', '     * @param _stakeholderTokenPayoutVestingPeriods The vesting period after which the respective percentage of the tokens is released\n', '     */\n', '    function setupStakeholders(address[] _stakeholders, uint[] _stakeholderEthPercentages, uint[] _stakeholderTokenPercentages, bool[] _stakeholderTokenPayoutOverwriteReleaseDates, uint[] _stakeholderTokenPayoutFixedReleaseDates, uint[] _stakeholderTokenPayoutPercentages, uint[] _stakeholderTokenPayoutVestingPeriods) public only_owner at_stage(Stages.Deploying) {\n', '        beneficiary = _stakeholders[0]; // First stakeholder is expected to be the beneficiary\n', '        for (uint i = 0; i < _stakeholders.length; i++) {\n', '            stakeholderPercentagesIndex.push(_stakeholders[i]);\n', '            stakeholderPercentages[_stakeholders[i]] = Percentage(\n', '                _stakeholderEthPercentages[i], \n', '                _stakeholderTokenPercentages[i], \n', '                _stakeholderTokenPayoutOverwriteReleaseDates[i],\n', '                _stakeholderTokenPayoutFixedReleaseDates[i], i);\n', '        }\n', '\n', '        // Percentages add up to 100\n', '        for (uint ii = 0; ii < _stakeholderTokenPayoutPercentages.length; ii++) {\n', '            stakeholdersPayouts.push(Payout(_stakeholderTokenPayoutPercentages[ii], _stakeholderTokenPayoutVestingPeriods[ii]));\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '     * Setup volume multipliers\n', '     *\n', '     * @param _volumeMultiplierRates The rates will be multiplied by this value (denominated by 4)\n', '     * @param _volumeMultiplierLockupPeriods The lockup periods will be multiplied by this value (denominated by 4)\n', '     * @param _volumeMultiplierThresholds The volume thresholds for each respective multiplier\n', '     */\n', '    function setupVolumeMultipliers(uint[] _volumeMultiplierRates, uint[] _volumeMultiplierLockupPeriods, uint[] _volumeMultiplierThresholds) public only_owner at_stage(Stages.Deploying) {\n', '        require(phases.length > 0);\n', '        volumeMultiplierThresholds = _volumeMultiplierThresholds;\n', '        for (uint i = 0; i < volumeMultiplierThresholds.length; i++) {\n', '            volumeMultipliers[volumeMultiplierThresholds[i]] = VolumeMultiplier(_volumeMultiplierRates[i], _volumeMultiplierLockupPeriods[i]);\n', '        }\n', '    }\n', '    \n', '\n', '    /**\n', '     * After calling the deploy function the crowdsale\n', '     * rules become immutable \n', '     */\n', '    function deploy() public only_owner at_stage(Stages.Deploying) {\n', '        require(phases.length > 0);\n', '        require(stakeholderPercentagesIndex.length > 0);\n', '        stage = Stages.Deployed;\n', '    }\n', '\n', '\n', '    /**\n', '     * Prove that beneficiary is able to sign transactions \n', '     * and start the crowdsale\n', '     */\n', '    function confirmBeneficiary() public only_beneficiary at_stage(Stages.Deployed) {\n', '        stage = Stages.InProgress;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the presale phase\n', '     *\n', '     * @return True if in presale phase\n', '     */\n', '    function isInPresalePhase() public constant returns (bool) {\n', '        return stage == Stages.InProgress && now >= start && now <= presaleEnd;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if `_beneficiary` has a balance allocated\n', '     *\n', '     * @param _beneficiary The account that the balance is allocated for\n', '     * @param _releaseDate The date after which the balance can be withdrawn\n', '     * @return True if there is a balance that belongs to `_beneficiary`\n', '     */\n', '    function hasBalance(address _beneficiary, uint _releaseDate) public constant returns (bool) {\n', '        return allocatedIndex[_beneficiary].length > 0 && _releaseDate == allocatedIndex[_beneficiary][allocated[_beneficiary][_releaseDate].index];\n', '    }\n', '\n', '\n', '    /** \n', '     * Get the allocated token balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated token balance will be retrieved\n', '     * @return The allocated token balance\n', '     */\n', '    function balanceOf(address _owner) public constant returns (uint) {\n', '        uint sum = 0;\n', '        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\n', '            sum += allocated[_owner][allocatedIndex[_owner][i]].tokens;\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get the allocated eth balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated eth balance will be retrieved\n', '     * @return The allocated eth balance\n', '     */\n', '    function ethBalanceOf(address _owner) public constant returns (uint) {\n', '        uint sum = 0;\n', '        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\n', '            sum += allocated[_owner][allocatedIndex[_owner][i]].eth;\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\n', '     * \n', '     * @param _owner The address from which the refundable balance will be retrieved\n', '     * @return The invested refundable balance\n', '     */\n', '    function refundableEthBalanceOf(address _owner) public constant returns (uint) {\n', '        return now > crowdsaleEnd && raised < minAmount ? balances[_owner] : 0;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns the current phase based on the current time\n', '     *\n', '     * @return The index of the current phase\n', '     */\n', '    function getCurrentPhase() public constant returns (uint found) {\n', '        for (uint i = 0; i < phases.length; i++) {\n', '            if (now <= phases[i].end) {\n', '                return i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return phases.length; // Does not exist\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns the rate and bonus release date\n', '     *\n', '     * @param _phase The phase to use while determining the rate\n', '     * @param _volume The amount wei used to determin what volume multiplier to use\n', '     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\n', '     */\n', '    function getRate(uint _phase, uint _volume) public constant returns (uint) {\n', '        uint rate = 0;\n', '        if (stage == Stages.InProgress && now >= start) {\n', '            Phase storage phase = phases[_phase];\n', '            rate = phase.rate;\n', '\n', '            // Find volume multiplier\n', '            if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\n', '                for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\n', '                    if (_volume >= volumeMultiplierThresholds[i - 1]) {\n', '                        VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\n', '                        rate += phase.rate * multiplier.rateMultiplier / percentageDenominator;\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        \n', '        return rate;\n', '    }\n', '\n', '\n', '    /**\n', '     * Get distribution data based on the current phase and \n', '     * the volume in wei that is being distributed\n', '     * \n', '     * @param _phase The current crowdsale phase\n', '     * @param _volume The amount wei used to determine what volume multiplier to use\n', '     * @return Volumes and corresponding release dates\n', '     */\n', '    function getDistributionData(uint _phase, uint _volume) internal constant returns (uint[], uint[]) {\n', '        Phase storage phase = phases[_phase];\n', '        uint remainingVolume = _volume;\n', '\n', '        bool usingMultiplier = false;\n', '        uint[] memory volumes = new uint[](1);\n', '        uint[] memory releaseDates = new uint[](1);\n', '\n', '        // Find volume multipliers\n', '        if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\n', '            uint phaseReleasePeriod = phase.bonusReleaseDate - crowdsaleEnd;\n', '            for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\n', '                if (_volume >= volumeMultiplierThresholds[i - 1]) {\n', '                    if (!usingMultiplier) {\n', '                        volumes = new uint[](i + 1);\n', '                        releaseDates = new uint[](i + 1);\n', '                        usingMultiplier = true;\n', '                    }\n', '\n', '                    VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\n', '                    uint releaseDate = phase.bonusReleaseDate + phaseReleasePeriod * multiplier.bonusReleaseDateMultiplier / percentageDenominator;\n', '                    uint volume = remainingVolume - volumeMultiplierThresholds[i - 1];\n', '\n', '                    // Store increment\n', '                    volumes[i] = volume;\n', '                    releaseDates[i] = releaseDate;\n', '\n', '                    remainingVolume -= volume;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Store increment\n', '        volumes[0] = remainingVolume;\n', '        releaseDates[0] = phase.bonusReleaseDate;\n', '\n', '        return (volumes, releaseDates);\n', '    }\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in tokens using \n', '     * the `_rate`\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @param _rate rate to use for the conversion\n', '     * @return Amount in tokens\n', '     */\n', '    function toTokens(uint _wei, uint _rate) public constant returns (uint) {\n', '        return _wei * _rate * tokenDenominator / 1 ether;\n', '    }\n', '\n', '\n', '    /**\n', '     * Function to end the crowdsale by setting \n', '     * the stage to Ended\n', '     */\n', '    function endCrowdsale() public at_stage(Stages.InProgress) {\n', '        require(now > crowdsaleEnd || raised >= maxAmount);\n', '        require(raised >= minAmount);\n', '        stage = Stages.Ended;\n', '\n', '        // Unlock token\n', '        if (!token.unlock()) {\n', '            revert();\n', '        }\n', '\n', '        // Allocate tokens (no allocation can be done after this period)\n', '        uint totalTokenSupply = token.totalSupply() + allocatedTokens;\n', '        for (uint i = 0; i < stakeholdersPayouts.length; i++) {\n', '            Payout storage p = stakeholdersPayouts[i];\n', '            _allocateStakeholdersTokens(totalTokenSupply * p.percentage / percentageDenominator, now + p.vestingPeriod);\n', '        }\n', '\n', '        // Allocate remaining ETH\n', '        _allocateStakeholdersEth(this.balance - allocatedEth, 0);\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     */\n', '    function withdrawTokens() public {\n', '        uint tokensToSend = 0;\n', '        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\n', '            uint releaseDate = allocatedIndex[msg.sender][i];\n', '            if (releaseDate <= now) {\n', '                Balance storage b = allocated[msg.sender][releaseDate];\n', '                tokensToSend += b.tokens;\n', '                b.tokens = 0;\n', '            }\n', '        }\n', '\n', '        if (tokensToSend > 0) {\n', '            allocatedTokens -= tokensToSend;\n', '            if (!token.issue(msg.sender, tokensToSend)) {\n', '                revert();\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     */\n', '    function withdrawEther() public {\n', '        uint ethToSend = 0;\n', '        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\n', '            uint releaseDate = allocatedIndex[msg.sender][i];\n', '            if (releaseDate <= now) {\n', '                Balance storage b = allocated[msg.sender][releaseDate];\n', '                ethToSend += b.eth;\n', '                b.eth = 0;\n', '            }\n', '        }\n', '\n', '        if (ethToSend > 0) {\n', '            allocatedEth -= ethToSend;\n', '            if (!msg.sender.send(ethToSend)) {\n', '                revert();\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     */\n', '    function refund() public only_after_crowdsale at_stage(Stages.InProgress) {\n', '        require(raised < minAmount);\n', '\n', '        uint receivedAmount = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '\n', '        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {\n', '            balances[msg.sender] = receivedAmount;\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Failsafe and clean-up mechanism\n', '     */\n', '    function destroy() public only_beneficiary only_after(2 years) {\n', '        selfdestruct(beneficiary);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive Eth and issue tokens to the sender\n', '     */\n', '    function contribute() public payable {\n', '        _handleTransaction(msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive Eth and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () payable {\n', '        require(msg.sender == tx.origin);\n', '        _handleTransaction(msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /**\n', '     * Handle incoming transactions\n', '     * \n', '     * @param _sender Transaction sender\n', '     * @param _received \n', '     */\n', '    function _handleTransaction(address _sender, uint _received) private at_stage(Stages.InProgress) {\n', '\n', '        // Crowdsale is active\n', '        require(now >= start && now <= crowdsaleEnd);\n', '\n', '        // Whitelist check\n', '        require(isAcceptedContributor(_sender));\n', '\n', '        // When in presale phase\n', '        bool presalePhase = isInPresalePhase();\n', '        require(!presalePhase || _received >= minAcceptedAmountPresale);\n', '        require(!presalePhase || raised < maxAmountPresale);\n', '\n', '        // When in ico phase\n', '        require(presalePhase || _received >= minAcceptedAmount);\n', '        require(presalePhase || raised >= minAmountPresale);\n', '        require(presalePhase || raised < maxAmount);\n', '\n', '        uint acceptedAmount;\n', '        if (presalePhase && raised + _received > maxAmountPresale) {\n', '            acceptedAmount = maxAmountPresale - raised;\n', '        } else if (raised + _received > maxAmount) {\n', '            acceptedAmount = maxAmount - raised;\n', '        } else {\n', '            acceptedAmount = _received;\n', '        }\n', '\n', '        raised += acceptedAmount;\n', '        \n', '        if (presalePhase) {\n', '            // During the presale phase - Non refundable\n', '            _allocateStakeholdersEth(acceptedAmount, 0); \n', '        } else {\n', '            // During the ICO phase - 100% refundable\n', '            balances[_sender] += acceptedAmount; \n', '        }\n', '\n', '        // Distribute tokens\n', '        uint tokensToIssue = 0;\n', '        uint phase = getCurrentPhase();\n', '        var rate = getRate(phase, acceptedAmount);\n', '        var (volumes, releaseDates) = getDistributionData(phase, acceptedAmount);\n', '        \n', '        // Allocate tokens\n', '        for (uint i = 0; i < volumes.length; i++) {\n', '            var tokensAtCurrentRate = toTokens(volumes[i], rate);\n', '            if (rate > baseRate && releaseDates[i] > now) {\n', '                uint bonusTokens = tokensAtCurrentRate / rate * (rate - baseRate);\n', '                _allocateTokens(_sender, bonusTokens, releaseDates[i]);\n', '\n', '                tokensToIssue += tokensAtCurrentRate - bonusTokens;\n', '            } else {\n', '                tokensToIssue += tokensAtCurrentRate;\n', '            }\n', '        }\n', '\n', '        // Issue tokens\n', '        if (tokensToIssue > 0 && !token.issue(_sender, tokensToIssue)) {\n', '            revert();\n', '        }\n', '\n', '        // Refund due to max cap hit\n', '        if (_received - acceptedAmount > 0 && !_sender.send(_received - acceptedAmount)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate ETH\n', '     *\n', '     * @param _beneficiary The account to alocate the eth for\n', '     * @param _amount The amount of ETH to allocate\n', '     * @param _releaseDate The date after which the eth can be withdrawn\n', '     */    \n', '    function _allocateEth(address _beneficiary, uint _amount, uint _releaseDate) private {\n', '        if (hasBalance(_beneficiary, _releaseDate)) {\n', '            allocated[_beneficiary][_releaseDate].eth += _amount;\n', '        } else {\n', '            allocated[_beneficiary][_releaseDate] = Balance(\n', '                _amount, 0, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\n', '        }\n', '\n', '        allocatedEth += _amount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate Tokens\n', '     *\n', '     * @param _beneficiary The account to allocate the tokens for\n', '     * @param _amount The amount of tokens to allocate\n', '     * @param _releaseDate The date after which the tokens can be withdrawn\n', '     */    \n', '    function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) private {\n', '        if (hasBalance(_beneficiary, _releaseDate)) {\n', '            allocated[_beneficiary][_releaseDate].tokens += _amount;\n', '        } else {\n', '            allocated[_beneficiary][_releaseDate] = Balance(\n', '                0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\n', '        }\n', '\n', '        allocatedTokens += _amount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate ETH for stakeholders\n', '     *\n', '     * @param _amount The amount of ETH to allocate\n', '     * @param _releaseDate The date after which the eth can be withdrawn\n', '     */    \n', '    function _allocateStakeholdersEth(uint _amount, uint _releaseDate) private {\n', '        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\n', '            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\n', '            if (p.eth > 0) {\n', '                _allocateEth(stakeholderPercentagesIndex[i], _amount * p.eth / percentageDenominator, _releaseDate);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate Tokens for stakeholders\n', '     *\n', '     * @param _amount The amount of tokens created\n', '     * @param _releaseDate The date after which the tokens can be withdrawn (unless overwitten)\n', '     */    \n', '    function _allocateStakeholdersTokens(uint _amount, uint _releaseDate) private {\n', '        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\n', '            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\n', '            if (p.tokens > 0) {\n', '                _allocateTokens(\n', '                    stakeholderPercentagesIndex[i], \n', '                    _amount * p.tokens / percentageDenominator, \n', '                    p.overwriteReleaseDate ? p.fixedReleaseDate : _releaseDate);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title NUCrowdsale\n', ' *\n', ' * Network Units (NU) is a decentralised worldwide collaboration of computing power\n', ' *\n', ' * By allowing gamers and service providers to participate in our unique mining \n', ' * process, we will create an ultra-fast, blockchain controlled multiplayer infrastructure \n', ' * rentable by developers\n', ' *\n', ' * Visit https://networkunits.io/\n', ' *\n', ' * #created 22/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract NUCrowdsale is Crowdsale, ITokenRetreiver, IWingsAdapter {\n', '\n', '\n', '    /**\n', '     * Setup the crowdsale\n', '     *\n', '     * @param _start The timestamp of the start date\n', '     * @param _token The token that is sold\n', '     * @param _tokenDenominator The token amount of decimals that the token uses\n', '     * @param _percentageDenominator The precision of percentages\n', '     * @param _minAmount The min cap for the ICO\n', '     * @param _maxAmount The max cap for the ICO\n', '     * @param _minAcceptedAmount The lowest accepted amount during the ICO phase\n', '     * @param _minAmountPresale The min cap for the presale\n', '     * @param _maxAmountPresale The max cap for the presale\n', '     * @param _minAcceptedAmountPresale The lowest accepted amount during the presale phase\n', '     */\n', '    function NUCrowdsale(uint _start, address _token, uint _tokenDenominator, uint _percentageDenominator, uint _minAmount, uint _maxAmount, uint _minAcceptedAmount, uint _minAmountPresale, uint _maxAmountPresale, uint _minAcceptedAmountPresale) \n', '        Crowdsale(_start, _token, _tokenDenominator, _percentageDenominator, _minAmount, _maxAmount, _minAcceptedAmount, _minAmountPresale, _maxAmountPresale, _minAcceptedAmountPresale) {\n', '    }\n', '\n', '\n', '    /**\n', '     * Wings integration - Get the total raised amount of Ether\n', '     *\n', '     * Can only increased, means if you withdraw ETH from the wallet, should be not modified (you can use two fields \n', '     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\n', '     *\n', '     * @return Total raised Ether amount\n', '     */\n', '    function totalCollected() public constant returns (uint) {\n', '        return raised;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allows the implementing contract to validate a \n', '     * contributing account\n', '     *\n', '     * @param _contributor Address that is being validated\n', '     * @return Wheter the contributor is accepted or not\n', '     */\n', '    function isAcceptedContributor(address _contributor) internal constant returns (bool) {\n', '        return _contributor != address(0x0);\n', '    }\n', '\n', '\n', '    /**\n', '     * Failsafe mechanism\n', '     * \n', '     * Allows beneficary to retreive tokens from the contract\n', '     *\n', '     * @param _tokenContract The address of ERC20 compatible token\n', '     */\n', '    function retreiveTokens(address _tokenContract) public only_beneficiary {\n', '        IToken tokenInstance = IToken(_tokenContract);\n', '\n', '        // Retreive tokens from our token contract\n', '        ITokenRetreiver(token).retreiveTokens(_tokenContract);\n', '\n', '        // Retreive tokens from crowdsale contract\n', '        uint tokenBalance = tokenInstance.balanceOf(this);\n', '        if (tokenBalance > 0) {\n', '            tokenInstance.transfer(beneficiary, tokenBalance);\n', '        }\n', '    }\n', '}']