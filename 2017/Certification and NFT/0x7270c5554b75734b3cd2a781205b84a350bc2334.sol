['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/Core/Manageable.sol\n', '\n', 'contract Manageable {\n', '  address public manager;\n', '\n', '\n', '  /**\n', '   * @dev Create a new instance of the Manageable contract.\n', '   * @param _manager address\n', '   */\n', '  function Manageable(address _manager) public {\n', '    require(_manager != 0x0);\n', '    manager = _manager;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if the msg.sender is the manager.\n', '   */\n', '  modifier onlyManager() { \n', '    require (msg.sender == manager && manager != 0x0);\n', '    _; \n', '  }\n', '}\n', '\n', '// File: contracts/Core/Activatable.sol\n', '\n', 'contract Activatable is Manageable {\n', '  event ActivatedContract(uint256 activatedAt);\n', '  event DeactivatedContract(uint256 deactivatedAt);\n', '\n', '  bool public active;\n', '  \n', '  /**\n', '   * @dev Check if the contract is active. \n', '   */\n', '  modifier isActive() {\n', '    require(active);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Check if the contract is not active. \n', '   */\n', '  modifier isNotActive() {\n', '    require(!active);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Activate the contract.\n', '   */\n', '  function activate() public onlyManager isNotActive {\n', '    // Set the flag to true.\n', '    active = true;\n', '\n', '    // Trigger event.\n', '    ActivatedContract(now);\n', '  }\n', '\n', '  /**\n', '   * @dev Deactiate the contract.\n', '   */\n', '  function deactivate() public onlyManager isActive {\n', '    // Set the flag to false.\n', '    active = false;\n', '\n', '    // Trigger event.\n', '    DeactivatedContract(now);\n', '  }\n', '}\n', '\n', '// File: contracts/Core/Versionable.sol\n', '\n', 'contract Versionable is Activatable {\n', '  string public name;\n', '  string public version;\n', '  uint256 public identifier;\n', '  uint256 public createdAt;\n', '\n', '  /**\n', '   * @dev Create a new intance of a Versionable contract. Sets the\n', '   *      createdAt unix timestamp to current block timestamp.\n', '   */\n', '  function Versionable (string _name, string _version, uint256 _identifier) public {\n', '    require (bytes(_name).length != 0x0 && bytes(_version).length != 0x0 && _identifier > 0);\n', '\n', '    // Set variables.\n', '    name = _name;\n', '    version = _version;\n', '    identifier = _identifier;\n', '    createdAt = now;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Management/ContractManagementSystem.sol\n', '\n', 'contract ContractManagementSystem is Ownable {\n', '  event UpgradedContract (uint256 contractIdentifier, address indexed oldContractAddress, address indexed newContractAddress);\n', '  event RollbackedContract (uint256 contractIdentifier, address indexed fromContractAddress, address indexed toContractAddress);\n', '\n', '  mapping (uint256 => mapping (address => bool)) public managedContracts;\n', '  mapping (uint256 => address) public activeContracts;\n', '  mapping (uint256 => bool) migrationLocks;\n', '\n', '  /**\n', '   * @dev Ensure no locks are in place for the given contract identifier.\n', '   * @param contractIdentifier uint256\n', '   */\n', '  modifier onlyWithoutLock(uint256 contractIdentifier) {\n', '    require(!migrationLocks[contractIdentifier]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev    Get the address of the active contract for the given identifier.\n', '   * @param  contractIdentifier uint256\n', '   * @return address\n', '   */\n', '  function getActiveContractAddress(uint256 contractIdentifier)\n', '    public\n', '    constant\n', '    onlyWithoutLock(contractIdentifier)\n', '    returns (address activeContract)\n', '  {\n', '    // Validate the function arguments.\n', '    require(contractIdentifier != 0x0);\n', '    \n', '    // Get the active contract for the given identifier.\n', '    activeContract = activeContracts[contractIdentifier];\n', '\n', '    // Ensure the address is set and the contract is active.\n', '    require(activeContract != 0x0 && Activatable(activeContract).active());\n', '  }\n', '\n', '  /**\n', '   * @dev    Check if the contract for the given address is managed.\n', '   * @param  contractIdentifier uint256\n', '   * @param  contractAddress    address\n', '   * @return bool\n', '   */\n', '  function existsManagedContract(uint256 contractIdentifier, address contractAddress)\n', '    public\n', '    constant\n', '    returns (bool)\n', '  {\n', '    // Validate the function arguments.\n', '    require(contractIdentifier != 0x0 && contractAddress != 0x0);\n', '\n', '    return managedContracts[contractIdentifier][contractAddress];\n', '  }\n', '\n', '  /**\n', '   * @dev    Upgrade the contract for the given contract identifier to a newer version.\n', '   * @dev    investigate potential race condition\n', '   * @param  contractIdentifier uint256\n', '   * @param  newContractAddress address\n', '   */\n', '  function upgradeContract(uint256 contractIdentifier, address newContractAddress)\n', '    public\n', '    onlyOwner\n', '    onlyWithoutLock(contractIdentifier)\n', '  {\n', '    // Validate the function arguments.\n', '    require(contractIdentifier != 0x0 && newContractAddress != 0x0);\n', '    \n', '    // Lock the contractIdentifier.\n', '    migrationLocks[contractIdentifier] = true;\n', '\n', '    // New contract should not be active.\n', '    require(!Activatable(newContractAddress).active());\n', '\n', '    // New contract should match the given contractIdentifier.\n', '    require(contractIdentifier == Versionable(newContractAddress).identifier());\n', '\n', '    // Ensure the new contract is not already managed.\n', '    require (!existsManagedContract(contractIdentifier, newContractAddress));\n', '\n', '    // Get the old contract address.\n', '    address oldContractAddress = activeContracts[contractIdentifier];\n', '\n', '    // Ensure the old contract is not deactivated already.\n', '    if (oldContractAddress != 0x0) {\n', '      require(Activatable(oldContractAddress).active());\n', '    }\n', '\n', '    // Swap the states.\n', '    swapContractsStates(contractIdentifier, newContractAddress, oldContractAddress);\n', '\n', '    // Add it to the managed ones.\n', '    managedContracts[contractIdentifier][newContractAddress] = true;\n', '\n', '    // Unlock the contractIdentifier.\n', '    migrationLocks[contractIdentifier] = false;\n', '    \n', '    // Trigger event.\n', '    UpgradedContract(contractIdentifier, oldContractAddress, newContractAddress);\n', '  }\n', '\n', '  /**\n', '   * @dev Rollback the contract for the given contract identifier to the provided version.\n', '   * @dev investigate potential race condition\n', '   * @param  contractIdentifier uint256\n', '   * @param  toContractAddress  address\n', '   */\n', '  function rollbackContract(uint256 contractIdentifier, address toContractAddress)\n', '    public\n', '    onlyOwner\n', '    onlyWithoutLock(contractIdentifier)\n', '  {\n', '    // Validate the function arguments.\n', '    require(contractIdentifier != 0x0 && toContractAddress != 0x0);\n', '\n', '    // Lock the contractIdentifier.\n', '    migrationLocks[contractIdentifier] = true;\n', '\n', '    // To contract should match the given contractIdentifier.\n', '    require(contractIdentifier == Versionable(toContractAddress).identifier());\n', '\n', '    // Rollback "to" contract should be managed and inactive.\n', '    require (!Activatable(toContractAddress).active() && existsManagedContract(contractIdentifier, toContractAddress));\n', '\n', '    // Get the rollback "from" contract for given identifier. Will fail if there is no active contract.\n', '    address fromContractAddress = activeContracts[contractIdentifier];\n', '\n', '    // Swap the states.\n', '    swapContractsStates(contractIdentifier, toContractAddress, fromContractAddress);\n', '\n', '    // Unlock the contractIdentifier.\n', '    migrationLocks[contractIdentifier] = false;\n', '\n', '    // Trigger event.\n', '    RollbackedContract(contractIdentifier, fromContractAddress, toContractAddress);\n', '  }\n', '  \n', '  /**\n', '   * @dev Swap the given contracts states as defined:\n', '   *        - newContractAddress will be activated\n', '   *        - oldContractAddress will be deactived\n', '   * @param  contractIdentifier uint256\n', '   * @param  newContractAddress address\n', '   * @param  oldContractAddress address\n', '   */\n', '  function swapContractsStates(uint256 contractIdentifier, address newContractAddress, address oldContractAddress) internal {\n', '    // Deactivate the old contract.\n', '    if (oldContractAddress != 0x0) {\n', '      Activatable(oldContractAddress).deactivate();\n', '    }\n', '\n', '    // Activate the new contract.\n', '    Activatable(newContractAddress).activate();\n', '\n', '     // Set the new contract as the active one for the given identifier.\n', '    activeContracts[contractIdentifier] = newContractAddress;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/Token/SwissCryptoExchangeToken.sol\n', '\n', '/**\n', ' * @title SwissCryptoExchange Standard ERC20 compatible token\n', ' *\n', ' * @dev Implementation of the SwissCryptoExchange company shares.\n', ' * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol\n', ' */\n', 'contract SwissCryptoExchangeToken is ERC20Basic, Versionable {\n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  string public constant symbol = "SCX";\n', '  uint8 public constant decimals = 0;\n', '\n', '  uint256 internal constant COMPANY_CONTRACT_ID = 101;\n', '\n', '  /**\n', '   * Create a new instance of the SwissCryptoExchangeToken contract.\n', '   * @param initialShareholderAddress address \n', '   * @param initialAmount             uint256 \n', '   */\n', '  function SwissCryptoExchangeToken (address initialShareholderAddress, uint256 initialAmount, address _manager)\n', '    public\n', '    Manageable (_manager)\n', '    Versionable ("SwissCryptoExchangeToken", "1.0.0", 1)\n', '  {\n', '    require(initialAmount > 0);\n', '    require(initialShareholderAddress != 0x0);\n', '\n', '    balances[initialShareholderAddress] = initialAmount;\n', '    totalSupply = initialAmount;\n', '  }\n', '\n', '  /**\n', '   * @dev Esnure the msg.sender is the company contract.\n', '   */\n', '  modifier onlyCompany() {\n', '    require (msg.sender == ContractManagementSystem(manager).getActiveContractAddress(COMPANY_CONTRACT_ID));\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public isActive onlyCompany returns (bool) {\n', '    require(_to != 0x0);\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another.\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public isActive onlyCompany returns (bool) {\n', '    require(_to != 0x0);\n', '    require(_value <= balances[_from]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(uint256 _amount) isActive onlyCompany public returns (bool) {\n', '    // The receiver of the minted tokens will be the company contract.\n', '    address _companyAddress = ContractManagementSystem(manager).getActiveContractAddress(COMPANY_CONTRACT_ID);\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_companyAddress] = balances[_companyAddress].add(_amount);\n', '    Mint(_companyAddress, _amount);\n', '    Transfer(0x0, _companyAddress, _amount);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/Company/BaseCompany.sol\n', '\n', 'contract BaseCompany is Versionable {\n', '  using SafeMath for uint256;\n', '  \n', '  uint256 internal constant TOKEN_CONTRACT_ID = 1;\n', '\n', '  /**\n', '   * @dev Create a new instance of the company contract.\n', '   * @param _name       string\n', '   * @param _version    string\n', '   * @param _identifier uint256\n', '   * @param _manager    address\n', '   */\n', '  function BaseCompany(string _name, string _version, uint256 _identifier, address _manager) public Versionable (_name, _version, _identifier) Manageable(_manager) {}\n', '\n', '  /**\n', '   * @dev Get the amount of shares that a shareholder owns in percentage\n', '   *      relative to the total number of shares.\n', '   * @param  shareholder address\n', '   * @return uint256\n', '   */\n', '  function getSharesPercentage(address shareholder) public constant returns (uint256) {\n', '    uint256 totalSharesAmount = token().totalSupply();\n', '    uint256 ownedShares = token().balanceOf(shareholder);\n', '    return ownedShares.mul(100).div(totalSharesAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the latest token contract address.\n', '   * @return address\n', '   */\n', '  function tokenAddress() public constant returns (address) {\n', '    return ContractManagementSystem(manager).getActiveContractAddress(TOKEN_CONTRACT_ID);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the latest reference to the token.\n', '   * @return SwissCryptoExchangeToken\n', '   */\n', '  function token() public constant returns (SwissCryptoExchangeToken) {\n', '    return SwissCryptoExchangeToken(tokenAddress());\n', '  }\n', '\n', '  /**\n', '   * @dev Check if the provided address is a company shareholder.\n', '   * @param _addr address\n', '   * @return bool\n', '   */\n', '  function isShareholder(address _addr) public constant returns (bool) {\n', '    return token().balanceOf(_addr) > 0 && _addr != address(this);\n', '  }\n', '    \n', '  /**\n', '   * @dev Check if the given address is a majority company shareholder.\n', '   * @param _addr address\n', '   * @return bool\n', '   */\n', '  function isMajorityShareholder(address _addr) public constant returns (bool) {\n', '    return (getSharesPercentage(_addr) > 50);\n', '  }\n', '}\n', '\n', '// File: contracts/Company/SwissCryptoExchangeCompany.sol\n', '\n', 'contract SwissCryptoExchangeCompany is BaseCompany {\n', '  event ProcessedInvestment(address indexed investor, uint256 weiAmount, uint256 shares);\n', '  event SaleCompleted(address indexed beneficiary, uint256 weiAmount, uint256 shares);\n', '  event SaleEnded(uint256 endedAt);\n', '  event SaleAborted(uint256 abortedAt);\n', '\n', '  using SafeMath for uint256;\n', '\n', '  Sale public currentSale;\n', '\n', '  // Definition of a sale.\n', '  struct Sale {\n', '    address creator;\n', '    address beneficiary;\n', '    address investor;\n', '    address shareholder;\n', '    uint256 rate;\n', '    uint256 weiRaised;\n', '    uint256 sharesSold;\n', '    uint256 sharesCap;\n', '    bool ended;\n', '    bool exists;\n', '  }\n', '  \n', '  /**\n', '   * @dev Create a new instance of the company contract.\n', '   * @param _manager address\n', '   */\n', '  function SwissCryptoExchangeCompany(address _manager) public BaseCompany("SwissCryptoExchangeCompany", "1.0.1", 101, _manager) {}\n', '\n', '  /**\n', '   * @dev Ensure the msg.sender is an shareholder of the company.\n', '   */\n', '  modifier onlyShareholder() {\n', '    require(isShareholder(msg.sender));\n', '    _; \n', '  }\n', '  \n', '  /**\n', '   * @dev Ensure the msg.sender is has over 50% of the company shares.\n', '   */\n', '  modifier onlyMajority() {\n', '    require(isMajorityShareholder(msg.sender));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Ensure the msg.sender is thesale creator.\n', '   */\n', '  modifier onlySaleCreator() {\n', '    require(msg.sender == currentSale.creator);\n', '    _; \n', '  }\n', '  \n', '  /**\n', '   * @dev Ensure there is no sale in progress.\n', '   */\n', '  modifier onlyWhenNotSelling() { \n', '    require(!currentSale.exists);\n', '    _; \n', '  }\n', '  \n', '  /**\n', '   * @dev Ensure there is a sale in progress.\n', '   */\n', '  modifier onlyWhenSelling() { \n', '    require(currentSale.exists);\n', '    _; \n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev Handle an incoming ether transfer.\n', '   */\n', '  function ()\n', '    public\n', '    payable\n', '    isActive\n', '    onlyWhenSelling\n', '  {\n', '    // Validate the purchase.\n', '    require(msg.sender == currentSale.investor && msg.value > 0);\n', '\n', '    // Forward the call to the Sale contract.\n', '    processPayment();\n', '  }\n', '\n', '  /**\n', '   * @dev Initialize a new sale.\n', '   * @param rate         uint256\n', '   * @param sharesCap    uint256\n', '   * @param beneficiary  address \n', '   * @param investor     address \n', '   */\n', '  function initializeNewSale(\n', '    uint256 rate,\n', '    uint256 sharesCap,\n', '    address beneficiary,\n', '    address investor\n', '  )\n', '    public\n', '    isActive\n', '    onlyMajority\n', '    onlyWhenNotSelling\n', '  {\n', '    // Validate the parameters.\n', '    require(rate > 0);\n', '    require(sharesCap > 0);\n', '    require(beneficiary != 0x0);\n', '    require(investor != 0x0);\n', '    require(token().balanceOf(msg.sender) >= sharesCap);\n', '\n', '    // Set sale properties.\n', '    currentSale.creator = msg.sender;\n', '    currentSale.rate = rate;\n', '    currentSale.sharesCap = sharesCap;\n', '    currentSale.beneficiary = beneficiary;\n', '    currentSale.investor = investor;\n', '    currentSale.shareholder = msg.sender;\n', '    currentSale.weiRaised = 0;\n', '    currentSale.sharesSold = 0;\n', '    currentSale.ended = false;\n', '    currentSale.exists = true;\n', '\n', '    // Transfer the funds to the company.\n', '    require(token().transferFrom(msg.sender, address(this), sharesCap));\n', '\n', '    // Enforce that one shareholder will remain majority.\n', '    require(isMajorityShareholder(msg.sender));\n', '  }\n', '\n', '  /**\n', '   * @dev Process the payment from the investor.\n', '   */\n', '  function processPayment()\n', '    private\n', '  {\n', '    address investor = currentSale.investor;\n', '    uint256 excessWei = 0;\n', '    uint256 sharesSold = currentSale.sharesSold;\n', '    uint256 sharesCap = currentSale.sharesCap;\n', '    uint256 rate = currentSale.rate;\n', '    uint256 weiAmount = msg.value;\n', '    uint256 shares = weiAmount.mul(rate).div(1 ether);\n', '\n', '    // If the after this investment the cap will be reached\n', '    // the sale will end and the excess wei will be sent\n', '    // back to the investor. \n', '    if (sharesSold.add(shares) > sharesCap) {\n', '      excessWei = sharesSold.add(shares).sub(sharesCap).mul(1 ether).div(rate);\n', '      weiAmount = weiAmount.sub(excessWei);\n', '      shares = sharesCap.sub(sharesSold);\n', '    } else {\n', '      //we care of investors money\n', '      excessWei = weiAmount.sub(shares.mul(1 ether).div(rate));\n', '      weiAmount = weiAmount.sub(excessWei);\n', '    }\n', '\n', '    // update shares\n', '    currentSale.sharesSold = sharesSold.add(shares);\n', '\n', '    // update weiRaised.\n', '    currentSale.weiRaised = currentSale.weiRaised.add(weiAmount);\n', '\n', '    //close sale\n', '    if(currentSale.sharesSold == sharesCap) {\n', '      currentSale.ended = true;\n', '      SaleEnded(now);\n', '    }\n', '\n', '    // Send tokens to the investor.\n', '    require(token().transfer(investor, shares));\n', '\n', '    // Send excess back to the investor.\n', '    if (excessWei > 0) {\n', '      investor.transfer(excessWei);\n', '    }\n', '\n', '    // Trigger event.\n', '    ProcessedInvestment(investor, weiAmount, shares);\n', '  }\n', '\n', '  /**\n', '   * @dev Finalize the in progress sale.\n', '   */\n', '  function finalizeSale()\n', '    public\n', '    isActive\n', '    onlySaleCreator\n', '    onlyWhenSelling\n', '  {\n', '    require(currentSale.ended);\n', '    require(currentSale.sharesSold == currentSale.sharesCap);\n', '\n', '    // Send wei to the beneficiary.\n', '    currentSale.beneficiary.transfer(currentSale.weiRaised); \n', '\n', '    // Trigger event.\n', '    SaleCompleted(currentSale.beneficiary, currentSale.weiRaised, currentSale.sharesSold);\n', '    \n', '    // Reset sale.\n', '    currentSale.exists = false;\n', '  }\n', '\n', '  /**\n', '   * @dev Abort the current sale.\n', '   */\n', '  function abortSale()\n', '    public\n', '    isActive\n', '    onlySaleCreator\n', '    onlyWhenSelling\n', '  {\n', '    require(!currentSale.ended);\n', '\n', '    address investor = currentSale.investor;\n', '    address shareholder = currentSale.shareholder;\n', '    address company = address(this);\n', '\n', '    // Send wei back to the investor.\n', '    investor.transfer(currentSale.weiRaised);\n', '\n', '    // Send tokens back from the investor to company.\n', '    require(token().transferFrom(investor, company, currentSale.sharesSold));\n', '\n', '    // Send tokens back from the company to the shareholder.\n', '    require(token().transferFrom(company, shareholder, currentSale.sharesCap));\n', '\n', '    // Trigger event.\n', '    SaleAborted(now);\n', '\n', '    // Reset sale state.\n', '    currentSale.exists = false;\n', '  }\n', '}']