['/**\n', ' *  Crowdsale for Fast Invest Tokens.\n', ' *  Raised Ether will be stored safely at the wallet.\n', ' *\n', ' *  Based on OpenZeppelin framework.\n', ' *  https://openzeppelin.org\n', ' *\n', ' *  Author: Paulius Tumosa\n', ' **/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * Safe Math library from OpenZeppelin framework\n', ' * https://openzeppelin.org\n', ' *\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract token {\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * @title FastInvestTokenCrowdsale\n', ' *\n', ' * Crowdsale have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract FastInvestTokenCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '\n', '    // The token being sold\n', '    token public tokenReward;\n', '\n', '    // Tokens will be transfered from this address\n', '    address internal tokenOwner;\n', '\n', '    // Address where funds are collected\n', '    address internal wallet;\n', '\n', '    // Start and end timestamps where investments are allowed\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // Amount of tokens sold\n', '    uint256 public tokensSold = 0;\n', '\n', '    // Amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '\n', '    // Funding goal and soft cap\n', '    uint256 constant public SOFT_CAP        = 38850000000000000000000000;\n', '    uint256 constant public FUNDING_GOAL    = 388500000000000000000000000;\n', '\n', '    // Tokens per ETH rates before and after the soft cap is reached\n', '    uint256 constant public RATE = 1000;\n', '    uint256 constant public RATE_SOFT = 1200;\n', '\n', '    // The balances in ETH of all investors\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     *\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function FastInvestTokenCrowdsale(address _tokenAddress, address _wallet, uint256 _start, uint256 _end) public {\n', '        require(_tokenAddress != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        owner = msg.sender;\n', '        tokenOwner = msg.sender;\n', '        wallet = _wallet;\n', '\n', '        tokenReward = token(_tokenAddress);\n', '\n', '        require(_start < _end);\n', '        startTime = _start;\n', '        endTime = _end;\n', '\n', '    }\n', '\n', '    // Fallback function can be used to buy tokens\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // Low level token purchase function\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != 0x0);\n', '        require(validPurchase());\n', '\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens = 0;\n', '\n', '        // Calculate token amount\n', '        if (tokensSold < SOFT_CAP) {\n', '            tokens = weiAmount.mul(RATE_SOFT);\n', '\n', '            if (tokensSold.add(tokens) > SOFT_CAP) {\n', '                uint256 softTokens = SOFT_CAP.sub(tokensSold);\n', '                uint256 amountLeft = weiAmount.sub(softTokens.div(RATE_SOFT));\n', '\n', '                tokens = softTokens.add(amountLeft.mul(RATE));\n', '            }\n', '\n', '        } else  {\n', '            tokens = weiAmount.mul(RATE);\n', '        }\n', '\n', '        require(tokens > 0);\n', '        require(tokensSold.add(tokens) <= FUNDING_GOAL);\n', '\n', '        forwardFunds();\n', '        assert(tokenReward.transferFrom(tokenOwner, beneficiary, tokens));\n', '\n', '        balanceOf[beneficiary] = balanceOf[beneficiary].add(weiAmount);\n', '\n', '        // Update totals\n', '        weiRaised  = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokens);\n', '\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '    }\n', '\n', '    // Send ether to the fund collection wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        bool hasTokens = tokensSold < FUNDING_GOAL;\n', '\n', '        return withinPeriod && nonZeroPurchase && hasTokens;\n', '    }\n', '\n', '    function setStart(uint256 _start) public onlyOwner {\n', '        startTime = _start;\n', '    }\n', '\n', '    function setEnd(uint256 _end) public onlyOwner {\n', '        require(startTime < _end);\n', '        endTime = _end;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '}']