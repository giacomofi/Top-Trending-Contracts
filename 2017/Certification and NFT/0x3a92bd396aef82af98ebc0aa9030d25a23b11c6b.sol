['pragma solidity ^0.4.18;\n', '\n', '\n', '/// @title Abstract ERC20 token interface\n', 'contract AbstractToken {\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function transfer(address to, uint256 value) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '    function approve(address spender, uint256 value) public returns (bool success);\n', '    function allowance(address owner, address spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Issuance(address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract Owned {\n', '\n', '    address public owner = msg.sender;\n', '    address public potentialOwner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPotentialOwner {\n', '        require(msg.sender == potentialOwner);\n', '        _;\n', '    }\n', '\n', '    event NewOwner(address old, address current);\n', '    event NewPotentialOwner(address old, address potential);\n', '\n', '    function setOwner(address _new)\n', '        public\n', '        onlyOwner\n', '    {\n', '        NewPotentialOwner(owner, _new);\n', '        potentialOwner = _new;\n', '    }\n', '\n', '    function confirmOwnership()\n', '        public\n', '        onlyPotentialOwner\n', '    {\n', '        NewOwner(owner, potentialOwner);\n', '        owner = potentialOwner;\n', '        potentialOwner = 0;\n', '    }\n', '}\n', '\n', '\n', '/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', 'contract StandardToken is AbstractToken, Owned {\n', '\n', '    /*\n', '     *  Data structures\n', '     */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    /*\n', '     *  Read and write storage functions\n', '     */\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read storage functions\n', '     */\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '/// @title SafeMath contract - Math operations with safety checks.\n', '/// @author OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'contract SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a ** b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/// @title Token contract - Implements Standard ERC20 with additional features.\n', '/// @author Zerion - <inbox@zerion.io>\n', 'contract Token is StandardToken, SafeMath {\n', '\n', '    // Time of the contract creation\n', '    uint public creationTime;\n', '\n', '    function Token() public {\n', '        creationTime = now;\n', '    }\n', '\n', '\n', '    /// @dev Owner can transfer out any accidentally sent ERC20 tokens\n', '    function transferERC20Token(address tokenAddress)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint balance = AbstractToken(tokenAddress).balanceOf(this);\n', '        return AbstractToken(tokenAddress).transfer(owner, balance);\n', '    }\n', '\n', '    /// @dev Multiplies the given number by 10^(decimals)\n', '    function withDecimals(uint number, uint decimals)\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        return mul(number, pow(10, decimals));\n', '    }\n', '}\n', '\n', '\n', '/// @title Token contract - Implements Standard ERC20 Token for Tokenbox project.\n', '/// @author Zerion - <inbox@zerion.io>\n', 'contract TokenboxToken is Token {\n', '\n', '    /*\n', '     * Token meta data\n', '     */\n', '    string constant public name = "Tokenbox";\n', ' \n', '    string constant public symbol = "TBX";\n', '    uint8 constant public decimals = 18;\n', '\n', '    // Address where Foundation tokens are allocated\n', '    address constant public foundationReserve = address(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '\n', '    // Address where all tokens for the ICO stage are initially allocated\n', '    address constant public icoAllocation = address(0x1111111111111111111111111111111111111111);\n', '\n', '    // Address where all tokens for the PreICO are initially allocated\n', '    address constant public preIcoAllocation = address(0x2222222222222222222222222222222222222222);\n', '\n', '    // Vesting date to withdraw 15% of total sold tokens, 11/28/2018 @ 12:00pm (UTC)\n', '    uint256 constant public vestingDateEnd = 1543406400;\n', '\n', '    // Total USD collected (10^-12)\n', '    uint256 public totalPicoUSD = 0;\n', '    uint8 constant public usdDecimals = 12;\n', '\n', '    // Foundation multisignature wallet, all Ether is collected there\n', '    address public multisig;\n', '\n', '    bool public migrationCompleted = false;\n', '\n', '    // Events\n', '    event InvestmentInETH(address investor, uint256 tokenPriceInWei, uint256 investedInWei, uint256 investedInPicoUsd, uint256 tokensNumber, uint256 originalTransactionHash);\n', '    event InvestmentInBTC(address investor, uint256 tokenPriceInSatoshi, uint256 investedInSatoshi, uint256 investedInPicoUsd, uint256 tokensNumber, string btcAddress);\n', '    event InvestmentInUSD(address investor, uint256 tokenPriceInPicoUsd, uint256 investedInPicoUsd, uint256 tokensNumber);\n', '    event PresaleInvestment(address investor, uint256 investedInPicoUsd, uint256 tokensNumber);\n', '\n', '    /// @dev Contract constructor, sets totalSupply\n', '    function TokenboxToken(address _multisig, uint256 _preIcoTokens)\n', '        public\n', '    {\n', '        // Overall, 31,000,000 TBX tokens are distributed\n', '        totalSupply = withDecimals(31000000, decimals);\n', '\n', '        uint preIcoTokens = withDecimals(_preIcoTokens, decimals);\n', '\n', '        // PreICO tokens are allocated to the special address and will be distributed manually\n', '        balances[preIcoAllocation] = preIcoTokens;\n', '\n', '        // foundationReserve balance will be allocated after the end of the crowdsale\n', '        balances[foundationReserve] = 0;\n', '\n', '        // The rest of the tokens is available for sale (75% of totalSupply)\n', '        balances[icoAllocation] = div(mul(totalSupply, 75), 100) - preIcoTokens;\n', '\n', '        multisig = _multisig;\n', '    }\n', '\n', '    modifier migrationIsActive {\n', '        require(!migrationCompleted);\n', '        _;\n', '    }\n', '\n', '    modifier migrationIsCompleted {\n', '        require(migrationCompleted);\n', '        _;\n', '    }\n', '\n', '    /// @dev Settle an investment made in ETH and distribute tokens\n', '    function ethInvestment(address investor, uint256 tokenPriceInPicoUsd, uint256 investedInWei, uint256 originalTransactionHash, uint256 usdToWei)\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '    {\n', '        uint tokenPriceInWei = div(mul(tokenPriceInPicoUsd, usdToWei), pow(10, usdDecimals));\n', '\n', '        // Number of tokens to distribute\n', '        uint256 tokensNumber = div(withDecimals(investedInWei, decimals), tokenPriceInWei);\n', '\n', '        // Check if there is enough tokens left\n', '        require(balances[icoAllocation] >= tokensNumber);\n', '\n', '        uint256 investedInPicoUsd = div(withDecimals(investedInWei, usdDecimals), usdToWei);\n', '\n', '        usdInvestment(investor, investedInPicoUsd, tokensNumber);\n', '        InvestmentInETH(investor, tokenPriceInWei, investedInWei, investedInPicoUsd, tokensNumber, originalTransactionHash);\n', '    }\n', '\n', '    /// @dev Settle an investment in BTC and distribute tokens.\n', '    function btcInvestment(address investor, uint256 tokenPriceInPicoUsd, uint256 investedInSatoshi, string btcAddress, uint256 usdToSatoshi)\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '    {\n', '        uint tokenPriceInSatoshi = div(mul(tokenPriceInPicoUsd, usdToSatoshi), pow(10, usdDecimals));\n', '\n', '        // Number of tokens to distribute\n', '        uint256 tokensNumber = div(withDecimals(investedInSatoshi, decimals), tokenPriceInSatoshi);\n', '\n', '        // Check if there is enough tokens left\n', '        require(balances[icoAllocation] >= tokensNumber);\n', '\n', '        uint256 investedInPicoUsd = div(withDecimals(investedInSatoshi, usdDecimals), usdToSatoshi);\n', '\n', '        usdInvestment(investor, investedInPicoUsd, tokensNumber);\n', '        InvestmentInBTC(investor, tokenPriceInSatoshi, investedInSatoshi, investedInPicoUsd, tokensNumber, btcAddress);\n', '    }\n', '\n', '    // @dev Wire investment\n', '    function wireInvestment(address investor, uint256 tokenPriceInUsdCents, uint256 investedInUsdCents)\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '     {\n', '\n', '       uint256 tokensNumber = div(withDecimals(investedInUsdCents, decimals), tokenPriceInUsdCents);\n', '\n', '       // Check if there is enough tokens left\n', '       require(balances[icoAllocation] >= tokensNumber);\n', '\n', '       // We subtract 2 because the value is in cents.\n', '       uint256 investedInPicoUsd = withDecimals(investedInUsdCents, usdDecimals - 2);\n', '       uint256 tokenPriceInPicoUsd = withDecimals(tokenPriceInUsdCents, usdDecimals - 2);\n', '\n', '       usdInvestment(investor, investedInPicoUsd, tokensNumber);\n', '\n', '       InvestmentInUSD(investor, tokenPriceInPicoUsd, investedInPicoUsd, tokensNumber);\n', '    }\n', '\n', '    // @dev Invest in USD\n', '    function usdInvestment(address investor, uint256 investedInPicoUsd, uint256 tokensNumber)\n', '        private\n', '    {\n', '      totalPicoUSD = add(totalPicoUSD, investedInPicoUsd);\n', '\n', '      // Allocate tokens to an investor\n', '      balances[icoAllocation] -= tokensNumber;\n', '      balances[investor] += tokensNumber;\n', '      Transfer(icoAllocation, investor, tokensNumber);\n', '    }\n', '\n', '    // @dev Repeat a transaction from the old contract during the migration\n', '    function migrateTransfer(address _from, address _to, uint256 amount, uint256 originalTransactionHash)\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '    {   \n', '        require(balances[_from] >= amount);\n', '        balances[_from] -= amount;\n', '        balances[_to] += amount;\n', '        Transfer(_from, _to, amount);\n', '    }\n', '\n', '    // @dev Presale tokens distribution\n', '    function preIcoInvestment(address investor, uint256 investedInUsdCents, uint256 tokensNumber)\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '    {\n', '      uint256 tokensNumberWithDecimals = withDecimals(tokensNumber, decimals);\n', '\n', '      // Check if there is enough tokens left\n', '      require(balances[preIcoAllocation] >= tokensNumberWithDecimals);\n', '\n', '      // Allocate tokens to an investor\n', '      balances[preIcoAllocation] -= tokensNumberWithDecimals;\n', '      balances[investor] += tokensNumberWithDecimals;\n', '      Transfer(preIcoAllocation, investor, tokensNumberWithDecimals);\n', '\n', '      uint256 investedInPicoUsd = withDecimals(investedInUsdCents, usdDecimals - 2);\n', '\n', '      // Add investment to totalPicoUSD collected\n', '      totalPicoUSD = add(totalPicoUSD, investedInPicoUsd);\n', '\n', '      PresaleInvestment(investor, investedInPicoUsd, tokensNumberWithDecimals);\n', '    }\n', '\n', '\n', '    /// @dev Allow token withdrawals from Foundation reserve\n', '    function allowToWithdrawFromReserve()\n', '        public\n', '        migrationIsCompleted\n', '        onlyOwner\n', '    {\n', '        require(now >= vestingDateEnd);\n', '\n', '        // Allow the owner to withdraw tokens from the Foundation reserve\n', '        allowed[foundationReserve][msg.sender] = balanceOf(foundationReserve);\n', '    }\n', '\n', '\n', '    // @dev Withdraws tokens from Foundation reserve\n', '    function withdrawFromReserve(uint amount)\n', '        public\n', '        migrationIsCompleted\n', '        onlyOwner\n', '    {\n', '        require(now >= vestingDateEnd);\n', '\n', '        // Withdraw tokens from Foundation reserve to multisig address\n', '        require(transferFrom(foundationReserve, multisig, amount));\n', '    }\n', '\n', '    /// @dev Changes multisig address\n', '    function changeMultisig(address _multisig)\n', '        public\n', '        onlyOwner\n', '    {\n', '        multisig = _multisig;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        migrationIsCompleted\n', '        returns (bool success) \n', '    {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        migrationIsCompleted\n', '        returns (bool success)\n', '    {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /// @dev Burns the rest of the tokens after the crowdsale end and\n', '    /// send 10% tokens of totalSupply to team address\n', '    function finaliseICO()\n', '        public\n', '        migrationIsActive\n', '        onlyOwner\n', '    {\n', '        // Total number of tokents sold during the ICO + preICO\n', '        uint256 tokensSold = sub(div(mul(totalSupply, 75), 100), balanceOf(icoAllocation));\n', '\n', '        // 0.75 * totalSupply = tokensSold\n', '        totalSupply = div(mul(tokensSold, 100), 75);\n', '\n', '        // Send 5% bounty + 7.5% of total supply to team address\n', '        balances[multisig] = div(mul(totalSupply, 125), 1000);\n', '        Transfer(icoAllocation, multisig, balanceOf(multisig));\n', '\n', '        // Lock 12.5% of total supply to team address for one year\n', '        balances[foundationReserve] = div(mul(totalSupply, 125), 1000);\n', '        Transfer(icoAllocation, foundationReserve, balanceOf(foundationReserve));\n', '\n', '        // Burn the rest of tokens\n', '        Transfer(icoAllocation, 0x0000000000000000000000000000000000000000, balanceOf(icoAllocation));\n', '        balances[icoAllocation] = 0;\n', '\n', '        migrationCompleted = true;\n', '    }\n', '\n', '    function totalUSD()\n', '      public view\n', '      returns (uint)\n', '    {\n', '       return div(totalPicoUSD, pow(10, usdDecimals));\n', '    }\n', '}']