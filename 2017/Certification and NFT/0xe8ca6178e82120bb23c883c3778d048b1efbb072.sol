['pragma solidity ^0.4.11;\n', '\n', 'contract token {\n', '    function transferFrom(address, address, uint) returns(bool){}\n', '    function burn() {}\n', '}\n', '\n', 'contract SafeMath {\n', '    //internals\n', '\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        Assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        Assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        Assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function Assert(bool assertion) internal {\n', '        if (!assertion) {\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract Crowdsale is SafeMath {\n', "    /*Owner's address*/\n", '    address public owner;\n', "    /* tokens will be transferred from BAP's address */\n", '    address public initialTokensHolder = 0xB27590b9d328bA0396271303e24db44132531411;\n', '    /* if the funding goal is not reached, investors may withdraw their funds */\n', '    uint public fundingGoal =  260000000;\n', '    /* the maximum amount of tokens to be sold */\n', '    uint public maxGoal     = 2100000000;\n', '    /* how much has been raised by crowdale (in ETH) */\n', '    uint public amountRaised;\n', '    /* the start date of the crowdsale 12:00 am 31/11/2017 */\n', '    uint public start = 1508929200;\n', '    /* the start date of the crowdsale 11:59 pm 10/11/2017*/\n', '    uint public end =   1508936400;\n', "    /*token's price  1ETH = 15000 KRB*/\n", '    uint public tokenPrice = 15000;\n', '    /* the number of tokens already sold */\n', '    uint public tokensSold;\n', '    /* the address of the token contract */\n', '    token public tokenReward;\n', '    /* the balances (in ETH) of all investors */\n', '    mapping(address => uint256) public balanceOf;\n', '    /*this mapping tracking allowed specific investor to invest and their referral */\n', '    mapping(address => address) public permittedInvestors;\n', '    /* indicated if the funding goal has been reached. */\n', '    bool public fundingGoalReached = false;\n', '    /* indicates if the crowdsale has been closed already */\n', '    bool public crowdsaleClosed = false;\n', '    /* this wallet will store all the fund made by ICO after ICO success*/\n', '    address beneficiary = 0x12bF8E198A6474FC65cEe0e1C6f1C7f23324C8D5;\n', '    /* notifying transfers and the success of the crowdsale*/\n', '    event GoalReached(address TokensHolderAddr, uint amountETHRaised);\n', '    event FundTransfer(address backer, uint amount, uint amountRaisedInICO, uint amountTokenSold, uint tokensHaveSold);\n', '    event TransferToReferrer(address indexed backer, address indexed referrerAddress, uint commission, uint amountReferralHasInvested, uint tokensReferralHasBought);\n', '    event AllowSuccess(address indexed investorAddr, address referralAddr);\n', '    event Withdraw(address indexed recieve, uint amount);\n', '\n', '    function changeTime(uint _start, uint _end){\n', '        start = _start;\n', '        end   = _end;\n', '    }\n', '\n', '    function changeMaxMin(uint _min, uint _max){\n', '        fundingGoal = _min;\n', '        maxGoal     = _max;\n', '    }\n', '\n', '    /*  initialization, set the token address */\n', '    function Crowdsale() {\n', '        tokenReward = token(0x1960edc283c1c7b9fba34da4cc1aa665eec0587e);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /* invest by sending ether to the contract. */\n', '    function () payable {\n', '        invest();\n', '    }\n', '\n', '    function invest() payable {\n', '        if(permittedInvestors[msg.sender] == 0x0) {\n', '            revert();\n', '        }\n', '        uint amount = msg.value;\n', '        uint numTokens = safeMul(amount, tokenPrice) / 1000000000000000000; // 1 ETH\n', '        if (now < start || now > end || safeAdd(tokensSold, numTokens) > maxGoal) {\n', '            revert();\n', '        }\n', '        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], amount);\n', '        amountRaised = safeAdd(amountRaised, amount);\n', '        tokensSold += numTokens;\n', '        if (!tokenReward.transferFrom(initialTokensHolder, msg.sender, numTokens)) {\n', '            revert();\n', '        }\n', '        if(permittedInvestors[msg.sender] != initialTokensHolder) {\n', '            uint commission = safeMul(numTokens, 5) / 100;\n', '            if(commission != 0){\n', '                /* we plus maxGoal for referrer in value param to distinguish between tokens for investors and tokens for referrer.\n', '                This value will be subtracted in token contract */\n', '                if (!tokenReward.transferFrom(initialTokensHolder, permittedInvestors[msg.sender], safeAdd(commission, maxGoal))) {\n', '                    revert();\n', '                }\n', '                TransferToReferrer(msg.sender, permittedInvestors[msg.sender], commission, amount, numTokens);\n', '            }\n', '        }\n', '\n', '        FundTransfer(msg.sender, amount, amountRaised, tokensSold, numTokens);\n', '    }\n', '\n', '    modifier afterDeadline() {\n', '        if (now < end) {\n', '            revert();\n', '        }\n', '        _;\n', '\n', '    }\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    /* checks if the goal or time limit has been reached and ends the campaign */\n', '    function checkGoalReached() {\n', '        if((tokensSold >= fundingGoal && now >= end) || (tokensSold >= maxGoal)) {\n', '            fundingGoalReached = true;\n', '            crowdsaleClosed = true;\n', '            tokenReward.burn();\n', '            sendToBeneficiary();\n', '            GoalReached(initialTokensHolder, amountRaised);\n', '        }\n', '        if(now >= end) {\n', '            crowdsaleClosed = true;\n', '        }\n', '    }\n', '\n', '    function allowInvest(address investorAddress, address referralAddress) onlyOwner external {\n', '        require(permittedInvestors[investorAddress] == 0x0);\n', '        if(referralAddress != 0x0 && permittedInvestors[referralAddress] == 0x0) revert();\n', '        permittedInvestors[investorAddress] = referralAddress == 0x0 ? initialTokensHolder : referralAddress;\n', '        AllowSuccess(investorAddress, referralAddress);\n', '    }\n', '\n', '    /* send money to beneficiary */\n', '    function sendToBeneficiary() internal {\n', '        beneficiary.transfer(this.balance);\n', '    }\n', '\n', '\n', '    /*if the ICO is fail, investors will call this function to get their money back */\n', '    function safeWithdrawal() afterDeadline {\n', '        require(this.balance != 0);\n', '        if(!crowdsaleClosed) revert();\n', '        uint amount = balanceOf[msg.sender];\n', '        if(address(this).balance >= amount) {\n', '            balanceOf[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                msg.sender.transfer(amount);\n', '                Withdraw(msg.sender, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        selfdestruct(beneficiary);\n', '    }\n', '}']