['pragma solidity 0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Telcoin {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    string public constant name = "Telcoin";\n', '    string public constant symbol = "TEL";\n', '    uint8 public constant decimals = 2;\n', '\n', '    /// The ERC20 total fixed supply of tokens.\n', '    uint256 public constant totalSupply = 100000000000 * (10 ** uint256(decimals));\n', '\n', '    /// Account balances.\n', '    mapping(address => uint256) balances;\n', '\n', '    /// The transfer allowances.\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    /// The initial distributor is responsible for allocating the supply\n', '    /// into the various pools described in the whitepaper. This can be\n', '    /// verified later from the event log.\n', '    function Telcoin(address _distributor) public {\n', '        balances[_distributor] = totalSupply;\n', '        Transfer(0x0, _distributor, totalSupply);\n', '    }\n', '\n', '    /// ERC20 balanceOf().\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// ERC20 transfer().\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// ERC20 transferFrom().\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// ERC20 approve(). Comes with the standard caveat that an approval\n', '    /// meant to limit spending may actually allow more to be spent due to\n', '    /// unfortunate ordering of transactions. For safety, this method\n', '    /// should only be called if the current allowance is 0. Alternatively,\n', '    /// non-ERC20 increaseApproval() and decreaseApproval() can be used.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// ERC20 allowance().\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// Not officially ERC20. Allows an allowance to be increased safely.\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /// Not officially ERC20. Allows an allowance to be decreased safely.\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract TelcoinSaleToken {\n', '    using SafeMath for uint256;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '    event Redeem(address indexed beneficiary, uint256 sacrificedValue, uint256 grantedValue);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /// The owner of the contract.\n', '    address public owner;\n', '\n', '    /// The total number of minted tokens, excluding destroyed tokens.\n', '    uint256 public totalSupply;\n', '\n', '    /// The token balance and released amount of each address.\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) redeemed;\n', '\n', '    /// Whether the token is still mintable.\n', '    bool public mintingFinished = false;\n', '\n', '    /// Redeemable telcoin.\n', '    Telcoin telcoin;\n', '    uint256 public totalRedeemed;\n', '\n', '    /// Vesting period.\n', '    uint256 vestingStart;\n', '    uint256 vestingDuration;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function TelcoinSaleToken(\n', '        Telcoin _telcoin,\n', '        uint256 _vestingStart,\n', '        uint256 _vestingDuration\n', '    )\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        telcoin = _telcoin;\n', '        vestingStart = _vestingStart;\n', '        vestingDuration = _vestingDuration;\n', '    }\n', '\n', '    function finishMinting() onlyOwner public returns (bool) {\n', '        require(!mintingFinished);\n', '\n', '        mintingFinished = true;\n', '        MintFinished();\n', '\n', '        return true;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '        require(_to != 0x0);\n', '        require(!mintingFinished);\n', '        require(_amount > 0);\n', '\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function redeemMany(address[] _beneficiaries) public {\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '            redeem(_beneficiaries[i]);\n', '        }\n', '    }\n', '\n', '    function redeem(address _beneficiary) public returns (uint256) {\n', '        require(mintingFinished);\n', '        require(_beneficiary != 0x0);\n', '\n', '        uint256 balance = redeemableBalance(_beneficiary);\n', '        if (balance == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 totalDistributable = telcoin.balanceOf(this).add(totalRedeemed);\n', '\n', '        // Avoid loss of precision by multiplying and later dividing by\n', '        // a large value.\n', '        uint256 amount = balance.mul(10 ** 18).div(totalSupply).mul(totalDistributable).div(10 ** 18);\n', '\n', '        balances[_beneficiary] = balances[_beneficiary].sub(balance);\n', '        redeemed[_beneficiary] = redeemed[_beneficiary].add(balance);\n', '        balances[telcoin] = balances[telcoin].add(balance);\n', '        totalRedeemed = totalRedeemed.add(amount);\n', '\n', '        Transfer(_beneficiary, telcoin, balance);\n', '        Redeem(_beneficiary, balance, amount);\n', '\n', '        telcoin.transfer(_beneficiary, amount);\n', '\n', '        return amount;\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public {\n', '        require(_to != address(0));\n', '        OwnershipTransferred(owner, _to);\n', '        owner = _to;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function redeemableBalance(address _beneficiary) public constant returns (uint256) {\n', '        return vestedBalance(_beneficiary).sub(redeemed[_beneficiary]);\n', '    }\n', '\n', '    function vestedBalance(address _beneficiary) public constant returns (uint256) {\n', '        uint256 currentBalance = balances[_beneficiary];\n', '        uint256 totalBalance = currentBalance.add(redeemed[_beneficiary]);\n', '\n', '        if (now < vestingStart) {\n', '            return 0;\n', '        }\n', '\n', '        if (now >= vestingStart.add(vestingDuration)) {\n', '            return totalBalance;\n', '        }\n', '\n', '        return totalBalance.mul(now.sub(vestingStart)).div(vestingDuration);\n', '    }\n', '}\n', '\n', '\n', 'contract TelcoinSale {\n', '    using SafeMath for uint256;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event WalletChanged(address indexed previousWallet, address indexed newWallet);\n', '    event TokenPurchase(\n', '        address indexed purchaser,\n', '        address indexed beneficiary,\n', '        uint256 value,\n', '        uint256 amount,\n', '        uint256 bonusAmount\n', '    );\n', '    event TokenAltPurchase(\n', '        address indexed purchaser,\n', '        address indexed beneficiary,\n', '        uint256 value,\n', '        uint256 amount,\n', '        uint256 bonusAmount,\n', '        string symbol,\n', '        string transactionId\n', '    );\n', '    event Pause();\n', '    event Unpause();\n', '    event Withdrawal(address indexed wallet, uint256 weiAmount);\n', '    event Extended(uint256 until);\n', '    event Finalized();\n', '    event Refunding();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '    event Whitelisted(\n', '        address indexed participant,\n', '        uint256 minWeiAmount,\n', '        uint256 maxWeiAmount,\n', '        uint32 bonusRate\n', '    );\n', '    event CapFlexed(uint32 flex);\n', '\n', '    /// The owner of the contract.\n', '    address public owner;\n', '\n', "    /// The temporary token we're selling. Sale tokens can be converted\n", '    /// immediately upon successful completion of the sale. Bonus tokens\n', '    /// are on a separate vesting schedule.\n', '    TelcoinSaleToken public saleToken;\n', '    TelcoinSaleToken public bonusToken;\n', '\n', "    /// The token we'll convert to after the sale ends.\n", '    Telcoin public telcoin;\n', '\n', '    /// The minimum and maximum goals to reach. If the soft cap is not reached\n', '    /// by the end of the sale, the contract will enter refund mode. If the\n', '    /// hard cap is reached, the contract can be finished early.\n', '    ///\n', '    /// Due to our actual soft cap being tied to USD and the assumption that\n', '    /// the value of Ether will continue to increase during the ICO, we\n', '    /// implement a fixed minimum softcap that accounts for a 2.5x value\n', '    /// increase. The capFlex is a scale factor that allows us to scale the\n', '    /// caps above the fixed minimum values. Initially the scale factor will\n', '    /// be set so that our effective soft cap is ~10M USD.\n', '    uint256 public softCap;\n', '    uint256 public hardCap;\n', '    uint32 public capFlex;\n', '\n', '    /// The sale period.\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    uint256 public timeExtension;\n', '\n', '    /// The numnber of tokens to mint per wei.\n', '    uint256 public rate;\n', '\n', "    /// The total number of wei raised. Note that the contract's balance may\n", '    /// differ from this value if someone has decided to forcefully send us\n', '    /// ether.\n', '    uint256 public weiRaised;\n', '\n', "    /// The wallet that will receive the contract's balance once the sale\n", '    /// finishes and the soft cap is reached.\n', '    address public wallet;\n', '\n', '    /// The list of addresses that are allowed to participate in the sale,\n', '    /// up to what amount, and any special rate they may have, provided\n', '    /// that they do in fact participate with at least the minimum value\n', '    /// they agreed to.\n', '    mapping(address => uint256) public whitelistedMin;\n', '    mapping(address => uint256) public whitelistedMax;\n', '    mapping(address => uint32) public bonusRates;\n', '\n', '    /// The amount of wei and wei equivalents invested by each investor.\n', '    mapping(address => uint256) public deposited;\n', '    mapping(address => uint256) public altDeposited;\n', '\n', '    /// An enumerable list of investors.\n', '    address[] public investors;\n', '\n', '    /// Whether the sale is paused.\n', '    bool public paused = false;\n', '\n', '    /// Whether the sale has finished, and when.\n', '    bool public finished = false;\n', '    uint256 public finishedAt;\n', '\n', "    /// Whether we're accepting refunds.\n", '    bool public refunding = false;\n', '\n', '    /// The total number of wei refunded.\n', '    uint256 public weiRefunded;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier saleOpen() {\n', '        require(!finished);\n', '        require(!paused);\n', '        require(now >= startTime);\n', '        require(now <= endTime + timeExtension);\n', '        _;\n', '    }\n', '\n', '    function TelcoinSale(\n', '        uint256 _softCap,\n', '        uint256 _hardCap,\n', '        uint32 _capFlex,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        Telcoin _telcoin,\n', '        uint256 _bonusVestingStart,\n', '        uint256 _bonusVestingDuration\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        require(msg.value > 0);\n', '        require(_softCap > 0);\n', '        require(_hardCap >= _softCap);\n', '        require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != 0x0);\n', '\n', '        owner = msg.sender;\n', '        softCap = _softCap;\n', '        hardCap = _hardCap;\n', '        capFlex = _capFlex;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '        telcoin = _telcoin;\n', '\n', '        saleToken = new TelcoinSaleToken(telcoin, 0, 0);\n', '        bonusToken = new TelcoinSaleToken(\n', '            telcoin,\n', '            _bonusVestingStart,\n', '            _bonusVestingDuration\n', '        );\n', '\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) saleOpen public payable {\n', '        require(_beneficiary != address(0));\n', '\n', '        uint256 weiAmount = msg.value;\n', '        require(weiAmount > 0);\n', '        require(weiRaised.add(weiAmount) <= hardCap);\n', '\n', '        uint256 totalPrior = totalDeposited(_beneficiary);\n', '        uint256 totalAfter = totalPrior.add(weiAmount);\n', '        require(totalAfter <= whitelistedMax[_beneficiary]);\n', '\n', '        uint256 saleTokens;\n', '        uint256 bonusTokens;\n', '\n', '        (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, weiAmount);\n', '\n', '        uint256 newDeposited = deposited[_beneficiary].add(weiAmount);\n', '        deposited[_beneficiary] = newDeposited;\n', '        investors.push(_beneficiary);\n', '\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        saleToken.mint(_beneficiary, saleTokens);\n', '        if (bonusTokens > 0) {\n', '            bonusToken.mint(_beneficiary, bonusTokens);\n', '        }\n', '\n', '        TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            saleTokens,\n', '            bonusTokens\n', '        );\n', '    }\n', '\n', '    function changeWallet(address _wallet) onlyOwner public payable {\n', '        require(_wallet != 0x0);\n', '        require(msg.value > 0);\n', '\n', '        WalletChanged(wallet, _wallet);\n', '        wallet = _wallet;\n', '\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function extendTime(uint256 _timeExtension) onlyOwner public {\n', '        require(!finished);\n', '        require(now < endTime + timeExtension);\n', '        require(_timeExtension > 0);\n', '\n', '        timeExtension = timeExtension.add(_timeExtension);\n', '        require(timeExtension <= 7 days);\n', '\n', '        Extended(endTime.add(timeExtension));\n', '    }\n', '\n', '    function finish() onlyOwner public {\n', '        require(!finished);\n', '        require(hardCapReached() || now > endTime + timeExtension);\n', '\n', '        finished = true;\n', '        finishedAt = now;\n', '        saleToken.finishMinting();\n', '        bonusToken.finishMinting();\n', '\n', '        uint256 distributableCoins = telcoin.balanceOf(this);\n', '\n', '        if (softCapReached()) {\n', '            uint256 saleTokens = saleToken.totalSupply();\n', '            uint256 bonusTokens = bonusToken.totalSupply();\n', '            uint256 totalTokens = saleTokens.add(bonusTokens);\n', '\n', '            // Avoid loss of precision by multiplying and later dividing by\n', '            // a large value.\n', '            uint256 bonusPortion = bonusTokens.mul(10 ** 18).div(totalTokens).mul(distributableCoins).div(10 ** 18);\n', '            uint256 salePortion = distributableCoins.sub(bonusPortion);\n', '\n', '            saleToken.transferOwnership(owner);\n', '            bonusToken.transferOwnership(owner);\n', '\n', '            telcoin.transfer(saleToken, salePortion);\n', '            telcoin.transfer(bonusToken, bonusPortion);\n', '\n', '            withdraw();\n', '        } else {\n', '            refunding = true;\n', '            telcoin.transfer(wallet, distributableCoins);\n', '            Refunding();\n', '        }\n', '\n', '        Finalized();\n', '    }\n', '\n', '    function pause() onlyOwner public {\n', '        require(!paused);\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    function refundMany(address[] _investors) public {\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            refund(_investors[i]);\n', '        }\n', '    }\n', '\n', '    function refund(address _investor) public {\n', '        require(finished);\n', '        require(refunding);\n', '        require(deposited[_investor] > 0);\n', '\n', '        uint256 weiAmount = deposited[_investor];\n', '        deposited[_investor] = 0;\n', '        weiRefunded = weiRefunded.add(weiAmount);\n', '        Refunded(_investor, weiAmount);\n', '\n', '        _investor.transfer(weiAmount);\n', '    }\n', '\n', '    function registerAltPurchase(\n', '        address _beneficiary,\n', '        string _symbol,\n', '        string _transactionId,\n', '        uint256 _weiAmount\n', '    )\n', '        saleOpen\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(_beneficiary != address(0));\n', '        require(totalDeposited(_beneficiary).add(_weiAmount) <= whitelistedMax[_beneficiary]);\n', '\n', '        uint256 saleTokens;\n', '        uint256 bonusTokens;\n', '\n', '        (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, _weiAmount);\n', '\n', '        uint256 newAltDeposited = altDeposited[_beneficiary].add(_weiAmount);\n', '        altDeposited[_beneficiary] = newAltDeposited;\n', '        investors.push(_beneficiary);\n', '\n', '        weiRaised = weiRaised.add(_weiAmount);\n', '\n', '        saleToken.mint(_beneficiary, saleTokens);\n', '        if (bonusTokens > 0) {\n', '            bonusToken.mint(_beneficiary, bonusTokens);\n', '        }\n', '\n', '        TokenAltPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            _weiAmount,\n', '            saleTokens,\n', '            bonusTokens,\n', '            _symbol,\n', '            _transactionId\n', '        );\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public {\n', '        require(_to != address(0));\n', '        OwnershipTransferred(owner, _to);\n', '        owner = _to;\n', '    }\n', '\n', '    function unpause() onlyOwner public {\n', '        require(paused);\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '\n', '    function updateCapFlex(uint32 _capFlex) onlyOwner public {\n', '        require(!finished);\n', '        capFlex = _capFlex;\n', '        CapFlexed(capFlex);\n', '    }\n', '\n', '    function whitelistMany(\n', '        address[] _participants,\n', '        uint256 _minWeiAmount,\n', '        uint256 _maxWeiAmount,\n', '        uint32 _bonusRate\n', '    )\n', '        onlyOwner\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < _participants.length; i++) {\n', '            whitelist(\n', '                _participants[i],\n', '                _minWeiAmount,\n', '                _maxWeiAmount,\n', '                _bonusRate\n', '            );\n', '        }\n', '    }\n', '\n', '    function whitelist(\n', '        address _participant,\n', '        uint256 _minWeiAmount,\n', '        uint256 _maxWeiAmount,\n', '        uint32 _bonusRate\n', '    )\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(_participant != 0x0);\n', '        require(_bonusRate <= 400);\n', '\n', '        whitelistedMin[_participant] = _minWeiAmount;\n', '        whitelistedMax[_participant] = _maxWeiAmount;\n', '        bonusRates[_participant] = _bonusRate;\n', '        Whitelisted(\n', '            _participant,\n', '            _minWeiAmount,\n', '            _maxWeiAmount,\n', '            _bonusRate\n', '        );\n', '    }\n', '\n', '    function withdraw() onlyOwner public {\n', '        require(softCapReached() || (finished && now > finishedAt + 14 days));\n', '\n', '        uint256 weiAmount = this.balance;\n', '\n', '        if (weiAmount > 0) {\n', '            wallet.transfer(weiAmount);\n', '            Withdrawal(wallet, weiAmount);\n', '        }\n', '    }\n', '\n', '    function hardCapReached() public constant returns (bool) {\n', '        return weiRaised >= hardCap.mul(1000 + capFlex).div(1000);\n', '    }\n', '\n', '    function tokensForPurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '        public\n', '        constant\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 baseTokens = _weiAmount.mul(rate);\n', '        uint256 totalPrior = totalDeposited(_beneficiary);\n', '        uint256 totalAfter = totalPrior.add(_weiAmount);\n', '\n', '        // Has the beneficiary passed the assigned minimum purchase level?\n', '        if (totalAfter < whitelistedMin[_beneficiary]) {\n', '            return (baseTokens, 0);\n', '        }\n', '\n', '        uint32 bonusRate = bonusRates[_beneficiary];\n', '        uint256 baseBonus = baseTokens.mul(1000 + bonusRate).div(1000).sub(baseTokens);\n', '\n', '        // Do we pass the minimum purchase level with this purchase?\n', '        if (totalPrior < whitelistedMin[_beneficiary]) {\n', '            uint256 balancePrior = totalPrior.mul(rate);\n', '            uint256 accumulatedBonus = balancePrior.mul(1000 + bonusRate).div(1000).sub(balancePrior);\n', '            return (baseTokens, accumulatedBonus.add(baseBonus));\n', '        }\n', '\n', '        return (baseTokens, baseBonus);\n', '    }\n', '\n', '    function totalDeposited(address _investor) public constant returns (uint256) {\n', '        return deposited[_investor].add(altDeposited[_investor]);\n', '    }\n', '\n', '    function softCapReached() public constant returns (bool) {\n', '        return weiRaised >= softCap.mul(1000 + capFlex).div(1000);\n', '    }\n', '}']