['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '    \n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', ' \n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', ' \n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', ' \n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', ' \n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', ' \n', '}\n', '\n', 'contract SingleTokenCoin {\n', '  function totalSupply() constant returns(uint256);\n', '  function finishMinting();\n', '  function moveUnsold(address _addr);\n', '  function setFreeze(address _addr);\n', '  function removeFreeze(address _addr);\n', '  function transfer(address _to, uint256 _value);\n', '  function newTransferManualTokensnewTransfer(address _from, address _to, uint256 _value) returns (bool);\n', '  function transferTokens(address _to, uint256 _amount, uint256 freezeTime, uint256 _type);\n', '  function transferTokens(address _from, address _to, uint256 _amount, uint256 freezeTime, uint256 _type);\n', '  function withdrowTokens(address _address, uint256 _tokens);\n', '  function setTotalSupply(address _addr);\n', '  function tokenTransferOwnership(address _address);\n', '  function getOwnerToken() constant returns(address);\n', '}\n', '\n', 'contract WrapperOraclize {\n', '  function update(string datasource, string arg) payable;\n', '  function getWrapperData() constant returns(bytes32);\n', '  function() external payable;\n', '}\n', '\n', 'contract Crowdsale is Ownable {\n', '\n', '  //string public ETHUSD;\n', '\n', '  using SafeMath for uint256;\n', '\n', '  //SingleTokenCoin public token = SingleTokenCoin(0xf579F37FE3129c4C897d2a9561f9D8DbEa3A0943);\n', '    SingleTokenCoin public token;\n', '\n', '  //Address from testnet\n', '  //WrapperOraclize private wrapper = WrapperOraclize(0x676b33cdcc3fa7b994ca6d16cd3c9dfe3c64ec52);\n', '\n', '  //Address from mainnet\n', '  WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F);\n', '\n', '  uint256 private angel_sale_start;\n', '  uint256 private angel_sale_finish;\n', '\n', '  uint256 private pre_sale_start;\n', '  uint256 private pre_sale_finish;\n', '\n', '  uint256 private public_sale_start;\n', '  uint256 private public_sale_finish;\n', '\n', '  bool private isAngel;\n', '  bool private isPreSale;\n', '  bool private isPublic;\n', '\n', '  uint256 private angel_rate;\n', '  uint256 private public_rate;\n', '\n', '  uint256 private decimals;\n', '\n', '  uint256 private totalETH;\n', '\n', '  address public coreTeamAddr;\n', '  address public itDevAddr;\n', '  address public futDevAddr;\n', '  address public commFoundAddr;\n', '  address public socWarefareAddr;\n', '  address public marketingAddr;\n', '\n', '  address public unsoldAddr;\n', '  address public collectAddr;  \n', '  \n', '  bool public mintingFinished = false;\n', '\n', '  //Storage for Founding Buyers Token\n', '  mapping(address => uint256) private founding_buyers_token;  // 0\n', '\n', '  //Storage for Angel Buyers ETH\n', '  mapping(address => uint256) private angel_buyers_eth;       // 2\n', '\n', '  //Storage for Angel Buyers Token\n', '  mapping(address => uint256) private angel_buyers_token;     // 2\n', '\n', '  //Storage for Angel Buyers ETH\n', '  mapping(address => uint256) private pre_sale_buyers_eth;    // 1\n', '\n', '  //Storage for Angel Buyers Token\n', '  mapping(address => uint256) private pre_sale_buyers_token;  // 1\n', '\n', '  //Storage for Angel Buyers Token\n', '  mapping(address => uint256) private pe_buyers_token;        // 3\n', '\n', '  //Storage for Angel Buyers ETH\n', '  mapping(address => uint256) private public_buyers_eth;      // 4\n', '\n', '  //Storage for Angel Buyers Token\n', '  mapping(address => uint256) private public_buyers_token;    // 4\n', '\n', '  address[] private founding_investors; // 0\n', '  address[] private pre_sale_investors; // 1\n', '  address[] private angel_investors;    // 2\n', '  address[] private pe_investors;       // 3\n', '  address[] private public_investors;   // 4\n', '\n', '  uint256 private soldTokens;\n', '  \n', '  uint256 private maxcup;\n', '\n', '  uint256 private totalAmount; \n', '  uint256 private foundingAmount; \n', '  uint256 private angelAmount;  \n', '  uint256 private preSaleAmount;\n', '  uint256 private PEInvestorAmount;\n', '  uint256 private publicSaleAmount;\n', '\n', '  uint256 private coreTeamAmount;\n', '  uint256 private coreTeamAuto;\n', '  uint256 private coreTeamManual;\n', '  uint256 private itDevAmount;  \n', '  uint256 private futDevAmount; \n', '  uint256 private commFoundAmount;\n', '  uint256 private socWarefareAmount;\n', '  uint256 private marketingAmount;\n', '\n', '  uint256 private angel_sale_sold;\n', '  uint256 private pre_sale_sold;\n', '  uint256 private public_sale_sold;\n', '  uint256 private founding_sold;\n', '  uint256 private peInvestors_sold;\n', '\n', '  uint256 private angel_sale_totalETH;\n', '  uint256 private pre_sale_totalETH;\n', '  uint256 private public_sale_totalETH;\n', '\n', '  uint256 private firstPhaseAmount;\n', '  uint256 private secondPhaseAmount; \n', '  uint256 private thirdPhaseAmount;  \n', '  uint256 private fourPhaseAmount;\n', '\n', '  uint256 private firstPhaseDiscount;\n', '  uint256 private secondPhaseDiscount;\n', '  uint256 private thirdPhaseDiscount;\n', '  uint256 private fourPhaseDiscount;\n', '\n', '  uint256 private currentPhase;\n', '\n', '  bool private moveTokens;\n', '\n', '  bool withdrowTokensComplete = false;  \n', '\n', '  function Crowdsale(address token_addr) {\n', '\n', '    token = SingleTokenCoin(token_addr);\n', '\n', '    //set calculate rate from USD\n', '    public_rate = 3546099290780141; // ~ 1 USD\n', '\n', '    angel_rate = 20;\n', '\n', '    decimals = 35460992907801; // 18 decimals\n', '\n', '    //now\n', '    angel_sale_start = now - 3 days;\n', '    //06.12.2017 08:30 AM\n', '    angel_sale_finish = 1510488000;\n', '\n', '    //07.12.2017 08:30 AM\n', '    pre_sale_start = 1510491600;\n', '    //06 .01.2018 08:30 AM\n', '    pre_sale_finish = 1512561600;\n', '\n', '    //07.01.2018 08:30 AM\n', '    //public_sale_start = 1512565200;\n', '    public_sale_start = 1512565200;\n', '    //10.01.2018 08:30 AM\n', '    public_sale_finish = public_sale_start + 14 days;\n', '\n', '    moveTokens = false;\n', '    \n', '    isAngel = true;\n', '    isPreSale = false;\n', '    isPublic = false;\n', '\n', '    currentPhase = 1;\n', '\n', '    founding_sold = 0;\n', '    peInvestors_sold = 0;\n', '    angel_sale_sold = 0;\n', '    pre_sale_sold = 0;\n', '    public_sale_sold = 0;\n', '\n', '    angel_sale_totalETH = 0;\n', '    pre_sale_totalETH = 0;\n', '    public_sale_totalETH = 0;\n', '\n', '    firstPhaseAmount = 18750000E18;     // 18 750 000;  // with 18 decimals\n', '    secondPhaseAmount = 37500000E18;    // 37 500 000;  // with 18 decimals\n', '    thirdPhaseAmount = 56250000E18;     // 56 250 000;  // with 18 decimals-\n', '    fourPhaseAmount = 75000000E18;      // 75 000 000;  // with 18 decimals\n', '\n', '    firstPhaseDiscount = 30;\n', '    secondPhaseDiscount = 40;\n', '    thirdPhaseDiscount = 50;\n', '    fourPhaseDiscount = 60;\n', '\n', '    totalAmount = 500000000E18;         // 500 000 000;  // with 18 decimals\n', '    foundingAmount = 10000000E18;       //  10 000 000;  // with 18 decimals\n', '    angelAmount = 25000000E18;          //  25 000 000;  // with 18 decimals\n', '    preSaleAmount = 75000000E18;        //  75 000 000;  // with 18 decimals\n', '    PEInvestorAmount = 50000000E18;     //  50 000 000;  // with 18 decimals\n', '    publicSaleAmount = 100000000E18;    // 100 000 000;  // with 18 decimals\n', '\n', '    coreTeamAmount = 100000000E18;      // 100 000 000;  // with 18 decimals\n', '    coreTeamAuto = 60000000E18;         //  60 000 000;  // with 18 decimals\n', '    coreTeamManual = 40000000E18;       //  40 000 000;  // with 18 decimals\n', '    itDevAmount = 50000000E18;          //  50 000 000;  // with 18 decimals\n', '    futDevAmount = 50000000E18;         //  50 000 000;  // with 18 decimals\n', '    commFoundAmount = 15000000E18;      //  15 000 000;  // with 18 decimals\n', '    socWarefareAmount = 10000000E18;    //  10 000 000;  // with 18 decimals\n', '    marketingAmount = 15000000E18;      //  15 000 000;  // with 18 decimals\n', '\n', '    mintingFinished = false;\n', '\n', '    coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f;\n', '    itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7;\n', '    futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3;\n', '    commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A;\n', '    socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9;\n', '    marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A;\n', '\n', '    unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1;\n', '    collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D;\n', '\n', '  }\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  function setFreeze(address _addr) public onlyOwner {\n', '    token.setFreeze(_addr);\n', '  }\n', '\n', '  function removeFreeze(address _addr) public onlyOwner {\n', '    token.removeFreeze(_addr);\n', '  }\n', '\n', '  function moveUnsold() public onlyOwner {\n', '    angelAmount = 0;\n', '    preSaleAmount = 0;\n', '    publicSaleAmount = 0;\n', '\n', '    angel_sale_sold = 0;\n', '    pre_sale_sold = 0;\n', '    public_sale_sold = 0;\n', '    token.moveUnsold(unsoldAddr);\n', '  }\n', '\n', '  function newTransferManualTokensnewTransfer(address _from, address _to, uint256 _value) onlyOwner returns (bool) {\n', '    return token.newTransferManualTokensnewTransfer(_from, _to, _value);\n', '  }\n', '\n', '  function() external payable {\n', '    mint();    \n', '  }\n', '\n', '  function bytesToUInt(bytes32 v) private constant returns (uint ret) {\n', '    if (v == 0x0) {\n', '        revert();\n', '    }\n', '\n', '    uint digit;\n', '\n', '    for (uint i = 0; i < 32; i++) {\n', '      digit = uint((uint(v) / (2 ** (8 * (31 - i)))) & 0xff);\n', '      if (digit == 0 || digit == 46) {\n', '          break;\n', '      }\n', '      else if (digit < 48 || digit > 57) {\n', '          revert();\n', '      }\n', '      ret *= 10;\n', '      ret += (digit - 48);\n', '    }\n', '    return ret;\n', '  }\n', '\n', '  function calculateRate() public constant returns(uint256) {\n', '    bytes32 result = getWrapperData();\n', '    uint256 usd = bytesToUInt(result);\n', '\n', '    uint256 price = 1 ether / usd; //price for 1 BMC //4545454545454546;\n', '\n', '    return price;\n', '  }\n', '\n', '  function calculatePrice(uint256 _usd, uint256 _pre_sale_sold) private constant returns(uint256) {\n', '    \n', '    if (currentPhase == 1 && pre_sale_sold + _pre_sale_sold <= firstPhaseAmount) {\n', '      return _usd.mul(firstPhaseDiscount).div(100);\n', '    }\n', '\n', '    if (currentPhase == 2 && pre_sale_sold + _pre_sale_sold > firstPhaseAmount && pre_sale_sold + _pre_sale_sold <= secondPhaseAmount) {\n', '      return _usd.mul(secondPhaseDiscount).div(100);\n', '    }\n', '\n', '    if (currentPhase == 3 && pre_sale_sold + _pre_sale_sold > secondPhaseAmount && pre_sale_sold + _pre_sale_sold <= thirdPhaseAmount) {\n', '      return _usd.mul(thirdPhaseDiscount).div(100);\n', '    }\n', '\n', '    if (currentPhase == 4 && pre_sale_sold + _pre_sale_sold > thirdPhaseAmount && pre_sale_sold + _pre_sale_sold <= fourPhaseAmount) {\n', '      return _usd.mul(fourPhaseDiscount).div(100);\n', '    }\n', '\n', '    return _usd;\n', '  }\n', '\n', '  function sendToAddress(address _address, uint256 _tokens, uint256 _type) canMint onlyOwner public {\n', '\n', '   if (_type != 1 && _type != 2 && _type != 3) {\n', '     revert();\n', '   }\n', '\n', '    //Founding\n', '    if (_type == 1) {\n', '      if (founding_sold + _tokens > foundingAmount) {\n', '        revert();\n', '      }\n', '\n', '      if (founding_buyers_token[_address] == 0) {\n', '        founding_investors.push(_address);\n', '      }\n', '\n', '      require(foundingAmount >= _tokens);\n', '\n', '      founding_buyers_token[_address] = founding_buyers_token[_address].add(_tokens);\n', '    \n', '      founding_sold = founding_sold + _tokens;\n', '\n', '      token.transferTokens(_address, _tokens, public_sale_start, 1);\n', '\n', '      foundingAmount = foundingAmount - _tokens;\n', '    }\n', '    // PE Investors\n', '    if (_type == 2) {\n', '      if (peInvestors_sold + _tokens > PEInvestorAmount) {\n', '        revert();\n', '      }\n', '\n', '      if (pe_buyers_token[_address] == 0) {\n', '        pe_investors.push(_address);\n', '      }\n', '\n', '      require(PEInvestorAmount >= _tokens);\n', '\n', '      pe_buyers_token[_address] = pe_buyers_token[_address].add(_tokens);\n', '    \n', '      peInvestors_sold = peInvestors_sold + _tokens;\n', '      \n', '      token.transferTokens(_address, _tokens, public_sale_start, 2);\n', '\n', '      PEInvestorAmount = PEInvestorAmount - _tokens;\n', '    }\n', '    //Core Team\n', '    if (_type == 3) {\n', '      require(coreTeamAmount >= _tokens);\n', '      token.transferTokens(coreTeamAddr, _address, _tokens, public_sale_start, 3);\n', '      coreTeamAmount = coreTeamAmount - _tokens;\n', '    } else {\n', '      soldTokens = soldTokens + _tokens;\n', '    }\n', '  }\n', '\n', '  modifier isICOFinished() {\n', '    if (now > public_sale_finish) {\n', '      finishMinting();\n', '    }\n', '    _;\n', '  }\n', '\n', '  modifier isAnyStage() {\n', '    if (now > angel_sale_finish && now > pre_sale_finish && now > public_sale_finish) {\n', '      revert();\n', '    }\n', '\n', '    if (now < angel_sale_start && now < pre_sale_start && now < public_sale_start) {\n', '      revert();\n', '    }\n', '\n', '    _;\n', '  }\n', '\n', '  function setTransferOwnership(address _address) public onlyOwner {\n', '\n', '    transferOwnership(_address);\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setAngelDate(uint256 _time) public onlyOwner {\n', '    angel_sale_start = _time;\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setPreSaleDate(uint256 _time) public onlyOwner {\n', '    pre_sale_start = _time;\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setPublicSaleDate(uint256 _time) public onlyOwner {\n', '    public_sale_start = _time;\n', '  }\n', '\n', '  function getStartDates() public constant returns(uint256 _angel_sale_start, uint256 _pre_sale_start, uint256 _public_sale_start) {\n', '    return (angel_sale_start, pre_sale_start, public_sale_start);\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setAngelFinishDate(uint256 _time) public onlyOwner {\n', '    angel_sale_finish = _time;\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setPreSaleFinishDate(uint256 _time) public onlyOwner {\n', '    pre_sale_finish = _time;\n', '  }\n', '\n', '  //only for demonstrate Test Version\n', '  function setPublicSaleFinishDate(uint256 _time) public onlyOwner {\n', '    public_sale_finish = _time;\n', '  }\n', '\n', '  function getFinishDates() public constant returns(uint256 _angel_sale_finish, uint256 _pre_sale_finish, uint256 _public_sale_finish) {\n', '    return (angel_sale_finish, pre_sale_finish, public_sale_finish);\n', '  }\n', '\n', '  function mint() public canMint isICOFinished isAnyStage payable {\n', '\n', '    if (now > angel_sale_finish && now < pre_sale_finish) {\n', '      isPreSale = true;\n', '      isAngel = false;\n', '    }\n', '\n', '    if (now > pre_sale_finish && now < public_sale_finish) {\n', '      isPreSale = false;\n', '      isAngel = false;\n', '      isPublic = true;\n', '    }\n', '\n', '    if (now > angel_sale_finish && now < pre_sale_start) {\n', '      revert();\n', '    }\n', '\n', '    if (now > pre_sale_finish && now < public_sale_start) {\n', '      revert();\n', '    }\n', '\n', '    if (isAngel && angelAmount == angel_sale_sold) {\n', '      revert();\n', '    }\n', '\n', '    if (isPreSale && preSaleAmount == pre_sale_sold) {\n', '      revert();\n', '    }\n', '\n', '    if (isPublic && publicSaleAmount == public_sale_sold) {\n', '      revert();\n', '    }\n', '\n', '    public_rate = calculateRate();\n', '\n', '    uint256 eth = msg.value * 1E18;\n', '\n', '    uint256 discountPrice = 0;\n', '\n', '    if (isPreSale) {\n', '      discountPrice = calculatePrice(public_rate, 0);\n', '      pre_sale_totalETH = pre_sale_totalETH + eth;\n', '    }\n', '\n', '    if (isAngel) {\n', '      discountPrice = public_rate.mul(angel_rate).div(100);\n', '      angel_sale_totalETH = angel_sale_totalETH + eth;\n', '    }\n', '\n', '    uint currentRate = 0;\n', '\n', '    if (isPublic) {\n', '      currentRate = public_rate;\n', '      public_sale_totalETH = public_sale_totalETH + eth;\n', '    } else {\n', '      currentRate = discountPrice;\n', '    }\n', '\n', '    if (eth < currentRate) {\n', '      revert();\n', '    }\n', '\n', '    uint256 tokens = eth.div(currentRate);\n', '\n', '    if (isPublic && !moveTokens) {\n', '      if (angelAmount > angel_sale_sold) {\n', '        uint256 angelRemainder = angelAmount - angel_sale_sold;\n', '        publicSaleAmount = publicSaleAmount + angelRemainder;\n', '      }\n', '      if (preSaleAmount > pre_sale_sold) {\n', '        uint256 preSaleRemainder = preSaleAmount - pre_sale_sold;\n', '        publicSaleAmount = publicSaleAmount + preSaleRemainder;\n', '      }\n', '      moveTokens = true;\n', '    }\n', '\n', '    if (isPreSale) {\n', '      uint256 availableTokensPhase = 0;\n', '      uint256 ethToRefundPhase = 0;\n', '\n', '      uint256 remETH = 0;\n', '\n', '      uint256 totalTokensPhase = 0;\n', '\n', '      if (currentPhase == 1 && pre_sale_sold + tokens > firstPhaseAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(firstPhaseAmount, pre_sale_sold, currentRate, tokens);\n', '        totalTokensPhase = availableTokensPhase;\n', '\n', '        remETH = ethToRefundPhase;\n', '\n', '        currentPhase = 2;\n', '\n', '        currentRate = calculatePrice(pre_sale_sold, totalTokensPhase);\n', '        tokens = remETH.div(currentRate);\n', '      }\n', '\n', '      if (currentPhase == 2 && pre_sale_sold + tokens + totalTokensPhase > secondPhaseAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(secondPhaseAmount, pre_sale_sold, currentRate, tokens);\n', '        totalTokensPhase = totalTokensPhase + availableTokensPhase;\n', '        \n', '        remETH = ethToRefundPhase;\n', '\n', '        currentPhase = 3;\n', '\n', '        currentRate = calculatePrice(pre_sale_sold, totalTokensPhase);\n', '        tokens = remETH.div(currentRate);\n', '      }\n', '\n', '      if (currentPhase == 3 && pre_sale_sold + tokens + totalTokensPhase > thirdPhaseAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(thirdPhaseAmount, pre_sale_sold, currentRate, tokens);\n', '        totalTokensPhase = totalTokensPhase + availableTokensPhase;\n', '        \n', '        remETH = ethToRefundPhase;\n', '\n', '        currentPhase = 4;\n', '\n', '        currentRate = calculatePrice(pre_sale_sold, totalTokensPhase);\n', '        tokens = remETH.div(currentRate);\n', '      }\n', '\n', '      if (currentPhase == 4 && pre_sale_sold + tokens + totalTokensPhase > fourPhaseAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(fourPhaseAmount, pre_sale_sold, currentRate, tokens);\n', '        totalTokensPhase = totalTokensPhase + availableTokensPhase;\n', '        \n', '        remETH = ethToRefundPhase;\n', '\n', '        currentPhase = 0;\n', '\n', '        currentRate = calculatePrice(pre_sale_sold, totalTokensPhase);\n', '        tokens = remETH.div(currentRate);\n', '      }\n', '\n', '      tokens = tokens + totalTokensPhase;\n', '    }\n', '\n', '    if (isPreSale) {\n', '      if (pre_sale_sold + tokens > preSaleAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(preSaleAmount, pre_sale_sold, currentRate, tokens);\n', '        tokens = availableTokensPhase;\n', '        eth = eth - ethToRefundPhase;\n', '        refund(ethToRefundPhase);\n', '      }\n', '    }\n', '\n', '    if (isAngel) {\n', '      if (angel_sale_sold + tokens > angelAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(angelAmount, angel_sale_sold, currentRate, tokens);\n', '        tokens = availableTokensPhase;\n', '        eth = eth - ethToRefundPhase;\n', '        refund(ethToRefundPhase);\n', '        \n', '      }    \n', '    }\n', '\n', '    if (isPublic) {\n', '      if (public_sale_sold + tokens > publicSaleAmount) {\n', '        (availableTokensPhase, ethToRefundPhase) = calculateMinorRefund(publicSaleAmount, public_sale_sold, currentRate, tokens);\n', '        tokens = availableTokensPhase;\n', '        eth = eth - ethToRefundPhase;\n', '        refund(ethToRefundPhase);\n', '        \n', '      }\n', '    }\n', '\n', '    saveInfoAboutInvestors(msg.sender, eth, tokens);\n', '\n', '    if (isAngel) {\n', '      token.transferTokens(msg.sender, tokens, public_sale_start, 0);\n', '    } else {\n', '      // 0 - not freeze time; 4 - not freeze type currently;\n', '      token.transferTokens(msg.sender, tokens, 0, 4);\n', '    }\n', '\n', '    soldTokens = soldTokens + tokens;\n', '    \n', '    totalETH = totalETH + eth;\n', '  }\n', '\n', '  function calculateMinorRefund(uint256 _maxcup, uint256 _sold, uint256 _rate, uint256 _tokens) private returns(uint256 _availableTokens, uint256 _ethToRefund) {\n', '    uint256 availableTokens = _maxcup - _sold;\n', '    uint256 tokensForRefund = _tokens - availableTokens;\n', '    uint256 refundETH = tokensForRefund * _rate;\n', '\n', '    return (availableTokens, refundETH);\n', '  }\n', '\n', '  function withdrowETH() public onlyOwner {\n', '    require(now > public_sale_finish);\n', '\n', '    collectAddr.transfer(this.balance);\n', '  }\n', '\n', '  function withdrowTokens() public onlyOwner {    \n', '    if (!withdrowTokensComplete) {\n', '      \n', '      token.withdrowTokens(coreTeamAddr, coreTeamAmount);\n', '      token.withdrowTokens(itDevAddr, itDevAmount);\n', '      token.withdrowTokens(futDevAddr, futDevAmount);\n', '      token.withdrowTokens(commFoundAddr, commFoundAmount);\n', '      token.withdrowTokens(socWarefareAddr, socWarefareAmount);\n', '      token.withdrowTokens(marketingAddr, marketingAmount);\n', '\n', '      withdrowTokensComplete = true;\n', '    }\n', '  }\n', '\n', '  function saveInfoAboutInvestors(address _address, uint256 _amount, uint256 _tokens) private {\n', '    if (isAngel) {\n', '      if (angel_buyers_token[_address] == 0) {\n', '        angel_investors.push(_address);\n', '      }\n', '\n', '      angel_buyers_eth[_address] = angel_buyers_eth[_address].add(_amount);\n', '\n', '      angel_buyers_token[_address] = angel_buyers_token[_address].add(_tokens);\n', '\n', '      angel_sale_sold = angel_sale_sold + _tokens;\n', '    }\n', '\n', '    if (isPreSale) {\n', '      if (pre_sale_buyers_token[_address] == 0) {\n', '        pre_sale_investors.push(_address);\n', '      }\n', '\n', '      pre_sale_buyers_eth[_address] = pre_sale_buyers_eth[_address].add(_amount);\n', '\n', '      pre_sale_buyers_token[_address] = pre_sale_buyers_token[_address].add(_tokens);\n', '    \n', '      pre_sale_sold = pre_sale_sold + _tokens;\n', '    }\n', '\n', '    if (isPublic) {\n', '      if (public_buyers_token[_address] == 0) {\n', '        public_investors.push(_address);\n', '      }\n', '\n', '      public_buyers_eth[_address] = public_buyers_eth[_address].add(_amount);\n', '\n', '      public_buyers_token[_address] = public_buyers_token[_address].add(_tokens);\n', '    \n', '      public_sale_sold = public_sale_sold + _tokens;\n', '    }\n', '  }\n', '\n', '  // Change for private when deploy to main net\n', '  function finishMinting() public onlyOwner {\n', '\n', '    if (mintingFinished) {\n', '      revert();\n', '    }\n', '\n', '    token.finishMinting();\n', '\n', '    mintingFinished = true;\n', '  }\n', '\n', '  function getFinishStatus() public constant returns(bool) {\n', '    return mintingFinished;\n', '  }\n', '\n', '  function refund(uint256 _amount) private {\n', '    msg.sender.transfer(_amount);\n', '  }\n', '\n', '  function getBalanceContract() public constant returns(uint256) {\n', '    return this.balance;\n', '  }\n', '\n', '  function getSoldToken() public constant returns(uint256 _soldTokens, uint256 _angel_sale_sold, uint256 _pre_sale_sold, uint256 _public_sale_sold, uint256 _founding_sold, uint256 _peInvestors_sold) {\n', '    return (soldTokens, angel_sale_sold, pre_sale_sold, public_sale_sold, founding_sold, peInvestors_sold);\n', '  }\n', '\n', '  function getInvestorsTokens(address _address, uint256 _type) public constant returns(uint256) {\n', '    if (_type == 0) {\n', '      return founding_buyers_token[_address];\n', '    }\n', '    if (_type == 1) {\n', '      return pre_sale_buyers_token[_address];\n', '    }\n', '    if (_type == 2) {\n', '      return angel_buyers_token[_address];\n', '    }\n', '    if (_type == 3) {\n', '      return pe_buyers_token[_address];\n', '    }\n', '    if (_type == 4) {\n', '      return public_buyers_token[_address];\n', '    }\n', '  }\n', '\n', '  function getInvestorsCount(uint256 _type) public constant returns(uint256) {\n', '    if (_type == 0) {\n', '      return founding_investors.length;\n', '    }\n', '    if (_type == 1) {\n', '      return pre_sale_investors.length;\n', '    }\n', '    if (_type == 2) {\n', '      return angel_investors.length;\n', '    }\n', '    if (_type == 3) {\n', '      return pe_investors.length;\n', '    }\n', '    if (_type == 4) {\n', '      return public_investors.length;\n', '    }\n', '  }\n', '\n', '  function getInvestorByIndex(uint256 _index, uint256 _type) public constant returns(address) {\n', '    if (_type == 0) {\n', '      return founding_investors[_index];\n', '    }\n', '    if (_type == 1) {\n', '      return pre_sale_investors[_index];\n', '    }\n', '    if (_type == 2) {\n', '      return angel_investors[_index];\n', '    }\n', '    if (_type == 3) {\n', '      return pe_investors[_index];\n', '    }\n', '    if (_type == 4) {\n', '      return public_investors[_index];\n', '    }\n', '  }\n', '\n', '  function getLeftToken() public constant returns(uint256 _all_left, uint256 _founding_left, uint256 _angel_left, uint256 _preSaleAmount_left, uint256 _PEInvestorAmount_left, uint256 _publicSaleAmount_left) {\n', '    uint256 all_left = token.totalSupply() != 0 ? token.totalSupply() - soldTokens : token.totalSupply();\n', '    uint256 founding_left = foundingAmount != 0 ? foundingAmount - founding_sold : foundingAmount;\n', '    uint256 angel_left = angelAmount != 0 ? angelAmount - angel_sale_sold : angelAmount;\n', '    uint256 preSaleAmount_left = preSaleAmount != 0 ? preSaleAmount - pre_sale_sold : preSaleAmount;\n', '    uint256 PEInvestorAmount_left = PEInvestorAmount != 0 ? PEInvestorAmount - peInvestors_sold : PEInvestorAmount;\n', '    uint256 publicSaleAmount_left = publicSaleAmount != 0 ? publicSaleAmount - public_sale_sold : publicSaleAmount;\n', '\n', '    return (all_left, founding_left, angel_left, preSaleAmount_left, PEInvestorAmount_left, publicSaleAmount_left);\n', '  }\n', '\n', '  function getTotalToken() public constant returns(uint256 _totalToken, uint256 _foundingAmount, uint256 _angelAmount, uint256 _preSaleAmount, uint256 _PEInvestorAmount, uint256 _publicSaleAmount) {\n', '    return (token.totalSupply(), foundingAmount, angelAmount, preSaleAmount, PEInvestorAmount, publicSaleAmount);\n', '  }\n', '\n', '  function getTotalETH() public constant returns(uint256 _totalETH, uint256 _angel_sale_totalETH, uint256 _pre_sale_totalETH, uint256 _public_sale_totalETH) {\n', '    return (totalETH, angel_sale_totalETH, pre_sale_totalETH, public_sale_totalETH);\n', '  }\n', '\n', '  function getCurrentPrice() public constant returns(uint256) {  \n', '    uint256 price = calculateRate();\n', '    return calculatePrice(price, 0);\n', '  }\n', '\n', '  function getContractAddress() public constant returns(address) {\n', '    return this;\n', '  }\n', '\n', '  function getOwner() public constant returns(address) {\n', '    return owner;\n', '  }\n', '\n', '  function sendOracleData() public payable {\n', '    if (msg.value != 0) {\n', '        wrapper.transfer(msg.value);\n', '    }\n', '    \n', '    wrapper.update("URL", "json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0");\n', '  }\n', '\n', '  function getWrapperData() public constant returns(bytes32) {\n', '    return wrapper.getWrapperData();\n', '  }\n', '}']