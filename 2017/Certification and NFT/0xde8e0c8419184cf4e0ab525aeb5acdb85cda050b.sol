['/*\n', '* The "Become a Billionaire" decentralized Raffle v1.0, Main-Net Release.\n', '* ~by Gluedog \n', '* -----------\n', '* \n', '* Compiler version: 0.4.19+commit.c4cbbb05.Emscripten.clang\n', '* \n', '* The weekly Become a Billionaire decentralized raffle is the basis of the deflationary mechanism for Billionaire Token\n', '* ---------------------------------------------------------------------------------------------------------------------\n', '* Every week, users can register 10 XBL to an Ethereum Smart Contract address – this is the equivalent of buying one ticket,\n', '*     more tickets mean a better chance to win. Users can buy an unlimited number of tickets to increase their chances.\n', '*     At the end of the week, the Smart Contract will choose three winners at random. First place will get 40% of\n', '*     the tokens  that were raised during that week, second place gets 20% and third place gets 10%.\n', '*     From the remaining 30% of the tokens: 10% are burned – as an offering to the market gods. The other 20% are sent\n', '*     to another Smart Contract Address that works like a twisted faucet – rewarding people for burning their own coins.\n', '* \n', '* The Become a Billionaire raffle Smart Contract will run forever, and will have an internal timer that will reset\n', '*     itself every seven days or after there have been 256 tickets registered to the Raffle. The players are registered\n', '*     by creating an internal mapping, inside the Smart Contract, a mapping of every address that registers tokens to \n', '*     it and their associated number of tickets. This mapping is reset every time the internal timer resets (every seven days).\n', '*/\n', '\n', 'pragma solidity ^0.4.8;\n', 'contract XBL_ERC20Wrapper\n', '{\n', '    function transferFrom(address from, address to, uint value) returns (bool success);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    function burn(uint256 _value) returns (bool success);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function totalSupply() constant returns (uint256 total_supply);\n', '}\n', '\n', 'contract BillionaireTokenRaffle\n', '{\n', '    address private winner1;\n', '    address private winner2;\n', '    address private winner3;\n', '\n', '    address public XBLContract_addr;\n', '    address public burner_addr;\n', '    address public raffle_addr;\n', '    address private owner_addr;\n', '\n', '    address[] private raffle_bowl; /* Holds ticket entries */\n', '    address[] private participants;\n', '    uint256[] private seeds;\n', '\n', '    uint64 public unique_players; /* Unique number of addresses registered in a week */\n', '    uint256 public total_burned_by_raffle;\n', '    uint256 public next_week_timestamp;\n', '    uint256 private minutes_in_a_week = 10080;\n', '    uint256 public raffle_balance;\n', '    uint256 public ticket_price;\n', '    uint256 public current_week;\n', '    uint256 public total_supply;\n', '    /* Initiate the XBL token wrapper */\n', '    XBL_ERC20Wrapper private ERC20_CALLS;\n', '\n', '    mapping(address => uint256) public address_to_tickets; /* Will be made private after open beta is finished. */\n', '    mapping(address => uint256) public address_to_tokens_prev_week0; /* Variables which will be made public  */\n', "    mapping(address => uint256) public address_to_tokens_prev_week1; /*  after each week's raffle has ended */\n", '\n', '    uint8 public prev_week_ID; /* Keeps track of which variable is the correct indicator of prev week mapping\n', '                                    Can only be [0] or [1]. */\n', '    address public lastweek_winner1;\n', '    address public lastweek_winner2;\n', '    address public lastweek_winner3;\n', '\n', '    /* Init */\n', '    function BillionaireTokenRaffle()\n', '    {\n', '        /* Billionaire Token contract address */\n', '        XBLContract_addr = 0x49AeC0752E68D0282Db544C677f6BA407BA17ED7;\n', '        ERC20_CALLS = XBL_ERC20Wrapper(XBLContract_addr);\n', '        total_supply = ERC20_CALLS.totalSupply();\n', '        ticket_price = 10000000000000000000; /* 10 XBL  */\n', '        raffle_addr = address(this); /* Own address                              */\n', '        owner_addr = msg.sender; /* Set the owner address as the initial sender */\n', '        next_week_timestamp = now + minutes_in_a_week * 1 minutes; /* Will get set every time resetRaffle() is called */\n', '    }\n', '\n', '    /* A modifier that can be applied to functions to only allow the owner to execute them.       */\n', '    /* This is very useful in cases where one would like to upgrade the deflationary algorithm.   */\n', '    /* We can simply use setter functions on the "Burner address",                                */\n', '    /* so that if we update the Burner, we can just point the Raffle to the new version of it.    */\n', '    modifier onlyOwner()\n', '    {\n', '        require (msg.sender == owner_addr);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBurner()\n', '    {\n', '        require(msg.sender == burner_addr);\n', '        _;\n', '    }\n', '\n', '    /* <<<--- Burner accesible functions --->>> */\n', '    /* <<<--- Burner accesible functions --->>> */\n', '    /* <<<--- Burner accesible functions --->>> */\n', '\n', '    function getLastWeekStake(address user_addr) public onlyBurner returns (uint256 last_week_stake)\n', "    {   /* The burner accesses this function to retrieve each player's stake from the previous week. */\n", '        if (prev_week_ID == 0)\n', '            return address_to_tokens_prev_week1[user_addr];\n', '        if (prev_week_ID == 1)\n', '            return address_to_tokens_prev_week0[user_addr];\n', '    }\n', '\n', '    function reduceLastWeekStake(address user_addr, uint256 amount) public onlyBurner\n', "    {   /* After a succesful burn, the burner will call this function and reduce the player's last_week_stake. */\n", '        if (prev_week_ID == 0)\n', '            address_to_tokens_prev_week1[user_addr] -= amount;\n', '        if (prev_week_ID == 1)\n', '            address_to_tokens_prev_week0[user_addr] -= amount;\n', '    }\n', '\n', '    /* <<<--- Public utility functions --->>> */\n', '    /* <<<--- Public utility functions --->>> */\n', '    /* <<<--- Public utility functions --->>> */\n', '\n', '    function registerTickets(uint256 number_of_tickets) public returns (int8 registerTickets_STATUS)\n', '    {\n', '        /*  registerTickets RETURN CODES:\n', '\n', '            [-6] - Raffle still has tickets after fillBurner() called \n', '            [-5] - fillBurner() null burner addr, raised error\n', '            [-4] - fillWeeklyArrays() prev_week_ID invalid value, raised error.\n', '            [-3] - getWinners() fail, raised error.\n', '            [-2] - ACTUAL ALLOWANCE CHECK MISMATCH.\n', '            [-1] - INVALID INPUT (zero or too many tickets).\n', '            [0 ] - REGISTERED OK.                                   */\n', '\n', '        /* Check the ticket amount limit (256 max) */\n', '        if (raffle_bowl.length > 256)\n', '        {\n', '            next_week_timestamp = now;\n', '        }\n', '\n', '        /* Check the time limit, one week is max. */\n', '        if (now >= next_week_timestamp)\n', '        {\n', '            int8 RAFFLE_STATUS = resetRaffle();\n', '            /* Error checks */\n', '            if (RAFFLE_STATUS == -2)\n', '                return -3; /* getWinners() errored, raise it! */\n', '\n', '            if (RAFFLE_STATUS == -3)\n', '                return -5; /* fillBurner() errored, raise it! */\n', '\n', '            if (RAFFLE_STATUS == -4)\n', '                return -6; /* Raffle still has tickets after fillBurner() called */\n', '        }\n', '        /* Before users will call registerTickets function,they will first have to call approve()    */\n', '        /* on the XBL contract address and approve the Raffle to spend tokens on their behalf.      */\n', '        /* After they have called approve, they will have to call this registerTickets() function  */\n', '\n', '        if ( (number_of_tickets == 0) || (number_of_tickets > 5) || (address_to_tickets[msg.sender] >= 5) )\n', '            return -1; /* Invalid Input */\n', '\n', '        if (ERC20_CALLS.allowance(msg.sender, raffle_addr) < ticket_price * number_of_tickets)\n', '            return -2; /* Allowance check mismatch */\n', '\n', '        if (ERC20_CALLS.balanceOf(msg.sender) < ticket_price * number_of_tickets) \n', '            return - 2; /* Allowance check mismatch */\n', '\n', '        /*  Reaching this point means the ticket registrant is legit  */\n', '        /*  Every ticket will add an entry to the raffle_bowl         */\n', '        if (fillWeeklyArrays(number_of_tickets, msg.sender) == -1)\n', '            return -4; /* prev_week_ID invalid value */\n', '\n', '        else\n', '        {   /* Everything checks out, transfer the coins from the user to the Raffle */\n', '            ERC20_CALLS.transferFrom(msg.sender, raffle_addr, number_of_tickets * ticket_price);\n', '            return 0; \n', '        }\n', '    }\n', '\n', '    /* <<<--- Owner functions --->>> */\n', '    /* <<<--- Owner functions --->>> */\n', '    /* <<<--- Owner functions --->>> */\n', '\n', '    function setBurnerAddress(address _burner_addr) public onlyOwner\n', '    {\n', '        burner_addr = _burner_addr;\n', '    }\n', '\n', '    function setTicketPrice(uint256 _ticket_price) public onlyOwner\n', '    {\n', '        ticket_price = _ticket_price;\n', '    }\n', '\n', '    function setOwnerAddr(address _owner_addr) public onlyOwner\n', '    {\n', '        owner_addr = _owner_addr;\n', '    }\n', '\n', '    /* <<<--- Internal functions --->>> */\n', '    /* <<<--- Internal functions --->>> */\n', '    /* <<<--- Internal functions --->>> */\n', '\n', '    function getPercent(uint8 percent, uint256 number) private returns (uint256 result)\n', '    {\n', '        return number * percent / 100;\n', '    }\n', '\n', '    function getRand(uint256 upper_limit) private returns (uint256 random_number)\n', '    {\n', '        return uint(sha256(uint256(block.blockhash(block.number-1)) * uint256(sha256(msg.sender)))) % upper_limit;\n', '    }\n', '    \n', '    function getRandWithSeed(uint256 upper_limit, uint seed) private returns (uint256 random_number)\n', '    {\n', '        return seed % upper_limit;\n', '    }\n', '\n', '    function resetWeeklyVars() private returns (bool success)\n', '    {   /*  After the weekly vars have been been reset, the player that last\n', '            registered (if this gets called from registerTickets()) will have\n', "            to have his tickets added to next week's Raffle Bowl.               */\n", '\n', '        total_supply = ERC20_CALLS.totalSupply();\n', '\n', '        /* Clear everything. */\n', '        for (uint i = 0; i < participants.length; i++)\n', '        {\n', '            address_to_tickets[participants[i]] = 0;\n', '\n', '            /* Clear the opposite of whatever prev_week_ID is */\n', '            if (prev_week_ID == 0)\n', '                address_to_tokens_prev_week1[participants[i]] = 0;\n', '            if (prev_week_ID == 1)\n', '                address_to_tokens_prev_week0[participants[i]] = 0;\n', '        }\n', '\n', '        seeds.length = 0;\n', '        raffle_bowl.length = 0;\n', '        participants.length = 0;\n', '        unique_players = 0;\n', '        \n', '        lastweek_winner1 = winner1;\n', '        lastweek_winner2 = winner2;\n', '        lastweek_winner3 = winner3;\n', '        winner1 = 0x0;\n', '        winner2 = 0x0;\n', '        winner3 = 0x0;\n', '        \n', '        prev_week_ID++;\n', '        if (prev_week_ID == 2)\n', '            prev_week_ID = 0;\n', '\n', '        return success;\n', '    }\n', '\n', '    function resetRaffle() private returns (int8 resetRaffle_STATUS)\n', '    {\n', '        /*  resetRaffle STATUS CODES:\n', '\n', '            [-5] - burnTenPercent() error            \n', '            [-4] - Raffle still has tokens after fillBurner().\n', '            [-3] - fillBurner() error.\n', '            [-2] - getWinners() error.\n', '            [-1] - We have no participants.\n', '            [0 ] - ALL OK.\n', '            [1 ] - Only one player, was refunded.\n', '            [2 ] - Two players, were refunded.\n', '            [3 ] - Three players, refunded.            */\n', '\n', '        while (now >= next_week_timestamp)\n', '        {\n', '            next_week_timestamp += minutes_in_a_week * 1 minutes;\n', '            current_week++;\n', '        }\n', '\n', '        if (raffle_bowl.length == 0)\n', '        {   /*   We have no registrants.  */\n', '            /* Reset the stats and return */\n', '            resetWeeklyVars(); \n', '            return -1;\n', '        }\n', '\n', '        if (unique_players < 4)\n', '        {   /* We have between 1 and three players in the raffle */\n', '            for (uint i = 0; i < raffle_bowl.length; i++)\n', '            { /* Refund their tokens */ \n', '                if (address_to_tickets[raffle_bowl[i]] != 0)\n', '                {\n', '                    ERC20_CALLS.transfer(raffle_bowl[i], address_to_tickets[raffle_bowl[i]] * ticket_price);\n', '                    address_to_tickets[raffle_bowl[i]] = 0;\n', '                }\n', '            }\n', '            /* Reset variables. */\n', '            resetWeeklyVars();\n', '            /* Return 1, 2 or 3 depending on how many raffle players were refunded */\n', '            return int8(unique_players);\n', '        }\n', '        /* At this point we assume that we have more than three unique players */\n', '        getWinners(); /* Choose three winners */\n', '\n', '        /* Do we have winners? */\n', '        if ( (winner1 == 0x0) || (winner2 == 0x0) || (winner3 == 0x0) )\n', '            return -2;\n', '\n', '        /* We have three winners! Proceed with rewards */\n', '        raffle_balance = ERC20_CALLS.balanceOf(raffle_addr);\n', '\n', '        /* Transfer 40%, 20% and 10% of the tokens to their respective winners */ \n', '        ERC20_CALLS.transfer(winner1, getPercent(40, raffle_balance));\n', '        ERC20_CALLS.transfer(winner2, getPercent(20, raffle_balance));\n', '        ERC20_CALLS.transfer(winner3, getPercent(10, raffle_balance));\n', '        /* Burn 10% */\n', '        if (burnTenPercent(raffle_balance) != true)\n', '            return -5;\n', '\n', '        /* Fill the burner with the rest of the tokens. */\n', '        if (fillBurner() == -1)\n', '            return -3; /* Burner addr NULL | error */ \n', '\n', '        /* Reset variables. */\n', '        resetWeeklyVars();\n', '\n', '        if (ERC20_CALLS.balanceOf(raffle_addr) > 0)\n', '            return -4; /* We still have a positive balance | error */\n', '\n', '        return 0; /* Everything OK */\n', '    }\n', '\n', '    function getWinners() private returns (int8 getWinners_STATUS)\n', '    {\n', '        /* Acquire the first random number using previous blockhash as an initial seed. */\n', '        uint initial_rand = getRand(seeds.length);\n', '\n', '        /* Use this first random number to choose one of the seeds from the array. */\n', '        uint firstwinner_rand = getRandWithSeed(seeds.length, seeds[initial_rand]);\n', '\n', "        /* This new random number is used to grab the first winner's index from raffle_bowl. */\n", '        winner1 = raffle_bowl[firstwinner_rand];\n', '\n', '        /* Find the position of winner1 in participants[] */\n', '        for (uint16 i = 0; i < participants.length; i++)\n', '        {\n', '            if (participants[i] == winner1)\n', '            {\n', '                uint16 winner1_index = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        /* Then choose two more winners, based on the initial position of winner1, looping over participants[] now. */\n', '        if (winner1_index+1 >= participants.length)\n', '        {\n', '            winner2 = participants[0];\n', '            winner3 = participants[1];\n', '\n', '            return 0;\n', '        }\n', '\n', '        if (winner1_index+2 >= participants.length)\n', '        {\n', '            winner2 = participants[winner1_index+1];\n', '            winner3 = participants[0];\n', '\n', '            return 0;\n', '        }\n', '\n', '        winner2 = participants[winner1_index+1];\n', '        winner3 = participants[winner1_index+2];\n', '\n', '        return 0;\n', '    }\n', '\n', '    function fillBurner() private returns (int8 fillBurner_STATUS)\n', '    {\n', '        /* [-1]: Burner Address NULL\n', '        *  [ 0]: OK\n', '        */\n', '        if (burner_addr == 0x0)\n', '            return -1;\n', '\n', '        ERC20_CALLS.transfer(burner_addr, ERC20_CALLS.balanceOf(raffle_addr));\n', '        return 0;\n', '    }\n', '\n', '    function fillWeeklyArrays(uint256 number_of_tickets, address user_addr) private returns (int8 fillWeeklyArrays_STATUS)\n', '    {\n', '        /*  [-1] Error with prev_week_ID\n', '        *   [0]  OK                        */\n', '\n', '        if ((prev_week_ID != 0) && (prev_week_ID != 1))\n', '            return -1;\n', '\n', '        /* Record unique players. */\n', '        if (address_to_tickets[user_addr] == 0)\n', '        {\n', '            unique_players++;\n', '            participants.push(user_addr);\n', '        }\n', '\n', '        address_to_tickets[user_addr] += number_of_tickets;\n', '        \n', '        if (prev_week_ID == 0)\n', '            address_to_tokens_prev_week0[user_addr] += number_of_tickets * ticket_price;\n', '        if (prev_week_ID == 1)\n', '            address_to_tokens_prev_week1[user_addr] += number_of_tickets * ticket_price;\n', '\n', '        uint256 _ticket_number = number_of_tickets;\n', '        while (_ticket_number > 0)\n', '        {\n', '            raffle_bowl.push(user_addr);\n', '            _ticket_number--;\n', '        }\n', '        /* Capture a seed from the user. */\n', '        seeds.push(uint(sha256(user_addr)) * uint(sha256(now)));\n', '\n', '        return 0;\n', '    }\n', '\n', '    function burnTenPercent(uint256 raffle_balance) private returns (bool success_state)\n', '    {\n', '        uint256 amount_to_burn = getPercent(10, raffle_balance);\n', '        total_burned_by_raffle += amount_to_burn;\n', '        /* Burn the coins, return success state */\n', '        if (ERC20_CALLS.burn(amount_to_burn) == true)\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', '    /* <<<--- Debug ONLY functions --->>> */\n', '    /* <<<--- Debug ONLY functions --->>> */\n', '    /* <<<--- Debug ONLY functions --->>> */\n', '\n', '    function dSET_XBL_ADDRESS(address _XBLContract_addr) public onlyOwner\n', '    {   /* These will be hardcoded in the production version. */\n', '        XBLContract_addr = _XBLContract_addr;\n', '        ERC20_CALLS = XBL_ERC20Wrapper(XBLContract_addr);\n', '        total_supply = ERC20_CALLS.totalSupply();\n', '    }\n', '\n', '    function dTRIGGER_NEXTWEEK_TIMESTAMP() public onlyOwner\n', '    {   /* Trigger end week quicker. */\n', '        next_week_timestamp = now;\n', '    }\n', '\n', '    function dKERNEL_PANIC() public onlyOwner\n', '    {   /* Out of Gas panic function. */\n', '        for (uint i = 0; i < raffle_bowl.length; i++)\n', "        { /* Refund everyone's tokens */ \n", '            if (address_to_tickets[raffle_bowl[i]] != 0)\n', '            {\n', '                ERC20_CALLS.transfer(raffle_bowl[i], address_to_tickets[raffle_bowl[i]] * ticket_price);\n', '                address_to_tickets[raffle_bowl[i]] = 0;\n', '            }\n', '        }\n', '    }\n', '}']