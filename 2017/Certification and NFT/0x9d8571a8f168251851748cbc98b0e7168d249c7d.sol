['pragma solidity ^0.4.18;\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract ReleasableToken is StandardToken, Ownable {\n', '\n', '    address public releaseAgent;\n', '\n', '    bool public released = false;\n', '\n', '    event Released();\n', '\n', '    event ReleaseAgentSet(address releaseAgent);\n', '\n', '    event TransferAgentSet(address transferAgent, bool status);\n', '\n', '    mapping (address => bool) public transferAgents;\n', '\n', '    modifier canTransfer(address _sender) {\n', '        require(released || transferAgents[_sender]);\n', '        _;\n', '    }\n', '\n', '    modifier inReleaseState(bool releaseState) {\n', '        require(releaseState == released);\n', '        _;\n', '    }\n', '\n', '    modifier onlyReleaseAgent() {\n', '        require(msg.sender == releaseAgent);\n', '        _;\n', '    }\n', '\n', '    function setReleaseAgent(address addr) public onlyOwner inReleaseState(false) {\n', '        ReleaseAgentSet(addr);\n', '        releaseAgent = addr;\n', '    }\n', '\n', '    function setTransferAgent(address addr, bool state) public onlyOwner inReleaseState(false) {\n', '        TransferAgentSet(addr, state);\n', '        transferAgents[addr] = state;\n', '    }\n', '    \n', '    function releaseTokenTransfer() public onlyReleaseAgent {\n', '        Released();\n', '        released = true;\n', '    }\n', '\n', '    function transfer(address _to, \n', '                      uint _value) public canTransfer(msg.sender) returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, \n', '                          address _to, \n', '                          uint _value) public canTransfer(_from) returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '\n', 'contract TruMintableToken is ReleasableToken {\n', '    \n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\n', '    bool public mintingFinished = false;\n', '\n', '    bool public preSaleComplete = false;\n', '\n', '    bool public saleComplete = false;\n', '\n', '    event Minted(address indexed _to, uint256 _amount);\n', '\n', '    event MintFinished(address indexed _executor);\n', '    \n', '    event PreSaleComplete(address indexed _executor);\n', '\n', '    event SaleComplete(address indexed _executor);\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n', '        require(_amount > 0);\n', '        require(_to != address(0));\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Minted(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function finishMinting(bool _presale, bool _sale) public onlyOwner returns (bool) {\n', '        require(_sale != _presale);\n', '        if (_presale == true) {\n', '            preSaleComplete = true;\n', '            PreSaleComplete(msg.sender);\n', '            return true;\n', '        }\n', '        require(preSaleComplete == true);\n', '        saleComplete = true;\n', '        SaleComplete(msg.sender);\n', '        mintingFinished = true;\n', '        MintFinished(msg.sender);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract UpgradeAgent {\n', '    \n', '    uint public originalSupply;\n', '\n', '    function isUpgradeAgent() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function upgradeFrom(address _from, uint256 _value) public;\n', '}\n', '\n', '\n', 'contract TruUpgradeableToken is StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\n', '    address public upgradeMaster;\n', '\n', '    UpgradeAgent public upgradeAgent;\n', '\n', '    uint256 public totalUpgraded;\n', '\n', '    bool private isUpgradeable = true;\n', '\n', '    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n', '\n', '    event Upgrade(address indexed from, \n', '        address indexed to, \n', '        uint256 upgradeValue);\n', '\n', '    event UpgradeAgentSet(address indexed agent, \n', '        address indexed executor);\n', '\n', '    event NewUpgradedAmount(uint256 originalBalance, \n', '        uint256 newBalance, \n', '        address indexed executor);\n', '    \n', '    modifier onlyUpgradeMaster() {\n', '        require(msg.sender == upgradeMaster);\n', '        _;\n', '    }\n', '\n', '    function TruUpgradeableToken(address _upgradeMaster) public {\n', '        require(_upgradeMaster != address(0));\n', '        upgradeMaster = _upgradeMaster;\n', '    }\n', '\n', '    function upgrade(uint256 _value) public {\n', '        UpgradeState state = getUpgradeState();\n', '        require((state == UpgradeState.ReadyToUpgrade) || (state == UpgradeState.Upgrading));\n', '        require(_value > 0);\n', '        require(balances[msg.sender] >= _value);\n', '        uint256 upgradedAmount = totalUpgraded.add(_value);\n', '        uint256 senderBalance = balances[msg.sender];\n', '        uint256 newSenderBalance = senderBalance.sub(_value);      \n', '        uint256 newTotalSupply = totalSupply.sub(_value);\n', '        balances[msg.sender] = newSenderBalance;\n', '        totalSupply = newTotalSupply;        \n', '        NewUpgradedAmount(totalUpgraded, newTotalSupply, msg.sender);\n', '        totalUpgraded = upgradedAmount;\n', '        upgradeAgent.upgradeFrom(msg.sender, _value);\n', '        Upgrade(msg.sender, upgradeAgent, _value);\n', '    }\n', '\n', '    function setUpgradeAgent(address _agent) public onlyUpgradeMaster {\n', '        require(_agent != address(0));\n', '        require(canUpgrade());\n', '        require(getUpgradeState() != UpgradeState.Upgrading);\n', '        UpgradeAgent newUAgent = UpgradeAgent(_agent);\n', '        require(newUAgent.isUpgradeAgent());\n', '        require(newUAgent.originalSupply() == totalSupply);\n', '        UpgradeAgentSet(upgradeAgent, msg.sender);\n', '        upgradeAgent = newUAgent;\n', '    }\n', '\n', '    function getUpgradeState() public constant returns(UpgradeState) {\n', '        if (!canUpgrade())\n', '            return UpgradeState.NotAllowed;\n', '        else if (upgradeAgent == address(0))\n', '            return UpgradeState.WaitingForAgent;\n', '        else if (totalUpgraded == 0)\n', '            return UpgradeState.ReadyToUpgrade;\n', '        else \n', '            return UpgradeState.Upgrading;\n', '    }\n', '\n', '    function setUpgradeMaster(address _master) public onlyUpgradeMaster {\n', '        require(_master != address(0));\n', '        upgradeMaster = _master;\n', '    }\n', '\n', '    function canUpgrade() public constant returns(bool) {\n', '        return isUpgradeable;\n', '    }\n', '}\n', '\n', '\n', 'contract TruReputationToken is TruMintableToken, TruUpgradeableToken {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\n', '    uint8 public constant decimals = 18;\n', '\n', '    string public constant name = "Tru Reputation Token";\n', '\n', '    string public constant symbol = "TRU";\n', '\n', '    address public execBoard = 0x0;\n', '\n', '    event BoardAddressChanged(address indexed oldAddress, \n', '        address indexed newAddress, \n', '        address indexed executor);\n', '\n', '    modifier onlyExecBoard() {\n', '        require(msg.sender == execBoard);\n', '        _;\n', '    }\n', '\n', '    function TruReputationToken() public TruUpgradeableToken(msg.sender) {\n', '        execBoard = msg.sender;\n', '        BoardAddressChanged(0x0, msg.sender, msg.sender);\n', '    }\n', '    \n', '    function changeBoardAddress(address _newAddress) public onlyExecBoard {\n', '        require(_newAddress != address(0));\n', '        require(_newAddress != execBoard);\n', '        address oldAddress = execBoard;\n', '        execBoard = _newAddress;\n', '        BoardAddressChanged(oldAddress, _newAddress, msg.sender);\n', '    }\n', '\n', '    function canUpgrade() public constant returns(bool) {\n', '        return released && super.canUpgrade();\n', '    }\n', '\n', '    function setUpgradeMaster(address _master) public onlyOwner {\n', '        super.setUpgradeMaster(_master);\n', '    }\n', '}']