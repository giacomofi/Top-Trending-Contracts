['pragma solidity ^0.4.19;\n', '\n', '\n', '/// @title  Bloom Token internal presale - https://hellobloom.io (BLT) - crowdfunding code\n', '/// Whitepaper:\n', '///  https://hellobloom.io/whitepaper.pdf\n', '\n', 'contract BloomToken {\n', '    string public name = "Bloom Token";\n', '    string public symbol = "BLT";\n', '    uint8 public constant decimals = 18;  \n', '    address public owner;\n', '\n', '    uint256 public constant tokensPerEth = 1;\n', '    uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether;\n', '    uint256 public constant howManyEtherInWeiToKillContract = 500 ether;\n', '    uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether;\n', '    \n', '    bool public funding = true;\n', '\n', '    // The current total token supply.\n', '    uint256 totalTokens = 1000;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n', '    event Refund(address indexed _from, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function BloomToken() public {\n', '        owner = msg.sender;\n', '        balances[owner]=1000;\n', '    }\n', '\n', '    function changeNameSymbol(string _name, string _symbol) payable external\n', '    {\n', '        if (msg.sender==owner || msg.value >=howManyEtherInWeiToChangeSymbolName)\n', '        {\n', '            name = _name;\n', '            symbol = _symbol;\n', '        }\n', '    }\n', '    \n', '    \n', '    function changeOwner (address _newowner) payable external\n', '    {\n', '        if (msg.value>=howManyEtherInWeiToBecomeOwner)\n', '        {\n', '            owner.transfer(msg.value);\n', '            owner.transfer(this.balance);\n', '            owner=_newowner;\n', '        }\n', '    }\n', '\n', '    function killContract () payable external\n', '    {\n', '        if (msg.sender==owner || msg.value >=howManyEtherInWeiToKillContract)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '    }\n', "    /// @notice Transfer `_value` tokens from sender's account\n", '    /// `msg.sender` to provided account address `_to`.\n', '    /// @notice This function is disabled during the funding.\n', '    /// @dev Required state: Operational\n', '    /// @param _to The address of the tokens recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        // Abort if not in Operational state.\n', '        \n', '        var senderBalance = balances[msg.sender];\n', '        if (senderBalance >= _value && _value > 0) {\n', '            senderBalance -= _value;\n', '            balances[msg.sender] = senderBalance;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function mintTo(address _to, uint256 _value) public returns (bool) {\n', '        // Abort if not in Operational state.\n', '        \n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '    }\n', '    \n', '\n', '    function totalSupply() external constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function balanceOf(address _owner) external constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function transferFrom(\n', '         address _from,\n', '         address _to,\n', '         uint256 _amount\n', '     ) public returns (bool success) {\n', '         if (balances[_from] >= _amount\n', '             && allowed[_from][msg.sender] >= _amount\n', '             && _amount > 0\n', '             && balances[_to] + _amount > balances[_to]) {\n', '             balances[_from] -= _amount;\n', '             allowed[_from][msg.sender] -= _amount;\n', '             balances[_to] += _amount;\n', '             return true;\n', '         } else {\n', '             return false;\n', '         }\n', '  }\n', '\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '         allowed[msg.sender][_spender] = _amount;\n', '         Approval(msg.sender, _spender, _amount);\n', '         \n', '         return true;\n', '     }\n', '// Crowdfunding:\n', '\n', '    /// @notice Create tokens when funding is active.\n', '    /// @dev Required state: Funding Active\n', '    /// @dev State transition: -> Funding Success (only if cap reached)\n', '    function () payable external {\n', '        // Abort if not in Funding Active state.\n', '        // The checks are split (instead of using or operator) because it is\n', '        // cheaper this way.\n', '        if (!funding) revert();\n', '        \n', '        // Do not allow creating 0 or more than the cap tokens.\n', '        if (msg.value == 0) revert();\n', '        \n', '        var numTokens = msg.value * (1000.0/totalTokens);\n', '        totalTokens += numTokens;\n', '\n', '        // Assign new tokens to the sender\n', '        balances[msg.sender] += numTokens;\n', '\n', '        // Log token creation event\n', '        Transfer(0, msg.sender, numTokens);\n', '    }\n', '}']