['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public paused = false;\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    modifier whenNotPaused() { require(!paused); _; }\n', '    modifier whenPaused() { require(paused); _; }\n', '\n', '    function pause() onlyOwner whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '    \n', '    function unpause() onlyOwner whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool);\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function approve(address spender, uint256 value) returns (bool);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns(bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) returns(bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) returns(bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '\n', '        if(_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        \n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BurnableToken is StandardToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', '/*\n', '    ICO Алтын\n', '    - Эмиссия токенов ограничена (всего 100 000 000 токенов)\n', '    - На Crowdsale продаются 22 000 000 токенов в 4 этапа, каждый этап ограничен по кол-ву токенов, цена токена на каждом этапе своя\n', '    - Нижная граница сборов 300 000 USD (граница никак не ограничивают контракт)\n', '    - Верхная граница сборов 5 500 000 USD (если граница достигнута токены больше не продаются, контракт дает сдачу если сумма больше)\n', '    - ICO ограничено по времени дата начала 17.10.2017 продолжительность 45 дней.\n', '    - Цена эфира 1 ETH = 300 USD, минимальная сумма инвестиций 0.03 USD\n', '    - Закрытие ICO происходит с помощью функции "withdraw()", управление токеном передаются бенефициару, не раскупленные токены сгорают, токены не участвующие в продаже отправляются бенефициару\n', '*/\n', '\n', 'contract ALTToken is BurnableToken, Ownable {\n', '    string public name = "Altyn Token";\n', '    string public symbol = "ALT";\n', '    uint256 public decimals = 18;\n', '    \n', '    uint256 public INITIAL_SUPPLY = 100000000 * 1 ether;                                        // Amount tokens\n', '\n', '    function ALTToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '}\n', '\n', 'contract ALTCrowdsale is Pausable {\n', '    using SafeMath for uint;\n', '\n', '    struct Step {\n', '        uint priceUSD;\n', '        uint amountTokens;\n', '    }\n', '\n', '    ALTToken public token;\n', '    address public beneficiary = 0x9df0be686E12ccdbE46D4177442878bf8636E89f;                    // Beneficiary\n', '\n', '    uint public collected;\n', '    uint public collectedUSD;\n', '    uint public tokensSold;\n', '    uint public maxTokensSold = 22000000 * 1 ether;                                             // Tokens for sale\n', '\n', '    uint public priceETH = 300;                                                                 // Ether price USD\n', '    uint public softCapUSD = 300000;                                                            // Soft cap USD\n', '    uint public softCap = softCapUSD / priceETH * 1 ether;\n', '    uint public hardCapUSD = 5500000;                                                           // Hard cap USD\n', '    uint public hardCap = hardCapUSD / priceETH * 1 ether;\n', '\n', '    Step[] steps;\n', '\n', '    uint public startTime = 1508225824;                                                         // Date start 01.10.2017 00:00 +0\n', '    uint public endTime = startTime + 45 days;                                                  // Date end +45 days\n', '    bool public crowdsaleFinished = false;\n', '\n', '    event SoftCapReached(uint256 etherAmount);\n', '    event HardCapReached(uint256 etherAmount);\n', '    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n', '    event Withdraw();\n', '\n', '    modifier onlyAfter(uint time) { require(now > time); _; }\n', '    modifier onlyBefore(uint time) {  require(now < time);  _; }\n', '\n', '    function ALTCrowdsale() {\n', '        token = new ALTToken();\n', '\n', '        steps.push(Step(15, 2000000));                                                          // Step 1: 0.15$; 2 000 000 ALT tokens\n', '        steps.push(Step(20, 5000000));                                                          // Step 2: 0.20$; +3 000 000 ALT tokens\n', '        steps.push(Step(25, 15000000));                                                         // Step 3: 0.25$; +10 000 000 ALT tokens\n', '        steps.push(Step(30, 22000000));                                                         // Step 4: 0.30$; +7 000 000 ALT tokens\n', '    }\n', '\n', '    function() payable {\n', '        purchase();\n', '    }\n', '    \n', '    function purchase() onlyAfter(startTime) onlyBefore(endTime) whenNotPaused payable {\n', '        require(!crowdsaleFinished);\n', '        require(msg.value >= 0.001 * 1 ether && msg.value <= 10000 * 1 ether);\n', '        require(tokensSold < maxTokensSold);\n', '\n', '        uint amount = 0;\n', '        uint sum = 0;\n', '        for(uint i = 0; i < steps.length; i++) {\n', '            if(tokensSold.add(amount) < steps[i].amountTokens * 1 ether) {\n', '                uint avail = (steps[i].amountTokens * 1 ether) - tokensSold.add(amount);\n', '                uint nece = (msg.value - sum) * priceETH / steps[i].priceUSD * 100;\n', '                uint buy = nece;\n', '\n', '                if(buy > avail) buy = avail;\n', '                \n', '                amount += buy;\n', '                sum += buy / (priceETH / steps[i].priceUSD * 100);\n', '\n', '                if(buy == nece) break;\n', '            }\n', '        }\n', '        \n', '        require(tokensSold.add(amount) <= maxTokensSold);\n', '\n', '        if(collected < softCap && collected.add(sum) >= softCap) {\n', '            SoftCapReached(collected.add(sum));\n', '        }\n', '\n', '        collected = collected.add(sum);\n', '        collectedUSD = collected * priceETH / 1 ether;\n', '        tokensSold = tokensSold.add(amount);\n', '        \n', '        require(token.transfer(msg.sender, amount));\n', '        if(sum < msg.value) require(msg.sender.send(msg.value - sum));\n', '\n', '        NewContribution(msg.sender, amount, sum);\n', '\n', '        if(collected >= hardCap) {\n', '            HardCapReached(collected);\n', '        }\n', '    }\n', '\n', '    function withdraw() onlyOwner {\n', '        require(!crowdsaleFinished);\n', '\n', '        beneficiary.transfer(collected);\n', '\n', '        if(tokensSold < maxTokensSold) token.burn(maxTokensSold - tokensSold);\n', '        token.transfer(beneficiary, token.balanceOf(this));\n', '        \n', '        token.transferOwnership(beneficiary);\n', '\n', '        crowdsaleFinished = true;\n', '\n', '        Withdraw();\n', '    }\n', '}']