['pragma solidity 0.4.18;\n', '\n', '// This contract provides the functions necessary to record ("push") & retrieve\n', '// public funding data to the Ethereum blockchain for the National Research\n', '// Council of Canada\n', '\n', 'contract DisclosureManager {\n', '\n', '\taddress public owner;\n', '\n', '\tstruct Disclosure {\n', '\t\tbytes32 organization;\n', '\t\tbytes32 recipient;\n', '\t\tbytes32 location;\n', '\t\tbytes16 amount;\n', '\t\tbytes1 fundingType;\n', '\t\tbytes16 date;\n', '\t\tbytes32 purpose;\n', '\t\tbytes32 comment;\n', '\t\tuint amended;    // if zero not amended, otherwise points to the rowNumber of the new record\n', '\t}\n', '\n', '\tDisclosure[] public disclosureList;\n', '\n', '\tevent disclosureAdded(\n', '    uint rowNumber,\n', '    bytes32 organization,\n', '    bytes32 recipient,\n', '    bytes32 location,\n', '    bytes16 amount,\n', '    bytes1 fundingType,\n', '    bytes16 date,\n', '    bytes32 purpose,\n', '    bytes32 comment);\n', '\n', '\tfunction DisclosureManager() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t// Make sure the caller of the contract is the owner\n', '\t// modifier isOwner() { if (msg.sender != owner) throw; _ ;}   // old way\n', '\tmodifier isOwner() { if (msg.sender != owner) revert(); _ ;}\n', '\n', '\t// getListCount() returns the number of records in disclosureList (not including the empty 0th record)\n', '\tfunction getListCount() public constant returns(uint listCount) {\n', '  \tif (disclosureList.length > 0) {\n', '\t\t\treturn disclosureList.length - 1;    // Returns the last rowNumber, reflecting number of records in list\n', '\t\t} else {\n', '\t\t\treturn 0;    // The case of an uninitialized list\n', '\t\t}\n', '\t}\n', '\t// Future idea: Another function to return total number of unamended Entries? (ie actual record count)\n', '\n', "\t// Create/push a new entry to our array, returns the new Entry's rowNumber\n", '\tfunction newEntry(bytes32 organization,\n', '\t\t\t\t\t  bytes32 recipient,\n', '\t\t\t\t\t  bytes32 location,\n', '\t\t\t\t\t  bytes16 amount,\n', '\t\t\t\t\t  bytes1 fundingType,\n', '\t\t\t\t\t  bytes16 date,\n', '\t\t\t\t\t  bytes32 purpose,\n', '\t\t\t\t\t  bytes32 comment) public isOwner() returns(uint rowNumber) {    // should this be public? yes, only needed isOwner()\n', '\n', '\t\t// Initialize disclosureList here as needed by putting an empty record at row 0\n', '\t\t// The first entry starts at 1 and getListCount will be in accordance with the record count\n', '\t\tif (disclosureList.length == 0) {\n', '\t\t\t// Push an empty Entry\n', '\t\t\tDisclosure memory nullEntry;\n', '\t\t\tdisclosureList.push(nullEntry);\n', '\t\t}\n', '\n', '\t\tDisclosure memory disclosure;\n', '\n', '\t\tdisclosure.organization = organization;\n', '\t\tdisclosure.recipient = recipient;\n', '\t\tdisclosure.location = location;\n', '\t\tdisclosure.amount = amount;\n', '\t\tdisclosure.fundingType = fundingType;\n', '\t\tdisclosure.date = date;\n', '\t\tdisclosure.purpose = purpose;\n', '\t\tdisclosure.comment = comment;\n', '\t\tdisclosure.amended = 0;\n', '\n', '\t\t// Push entry to the array\n', '\t\tuint index = disclosureList.push(disclosure);   // adds to end of array (of structs) and returns the new array length\n', '\t\tindex = index - 1;\n', '\n', '\t\t// Record the event\n', '\t\tdisclosureAdded(index, organization, recipient, location, amount, fundingType, date, purpose, comment);\n', '\n', '\t\treturn index;   // returning rowNumber of the record\n', '\t}\n', '\n', '\t// Amends/changes marks existing entry as amended and takes passed data to\n', '\t// create a new Entry to which the amended pointer (rowNumber) will point.\n', '\tfunction amendEntry(uint rowNumber,\n', '\t\t\t\t\t\tbytes32 organization,\n', '\t\t\t\t\t\tbytes32 recipient,\n', '\t\t\t\t\t\tbytes32 location,\n', '\t\t\t\t\t\tbytes16 amount,\n', '\t\t\t\t\t\tbytes1 fundingType,\n', '\t\t\t\t\t\tbytes16 date,\n', '\t\t\t\t\t\tbytes32 purpose,\n', '\t\t\t\t\t\tbytes32 comment) public isOwner() returns(uint newRowNumber) {    // returns the new rowNumber of amended record\n', '\n', '\t\t// Make sure passed rowNumber is in bounds\n', '\t\tif (rowNumber >= disclosureList.length) { revert(); }\n', '\t\tif (rowNumber < 1) { revert(); }\n', '\t\tif (disclosureList[rowNumber].amended > 0) { revert(); }    // This record is already amended\n', '\n', '\t\t// First create new entry\n', '\t\tDisclosure memory disclosure;\n', '\n', '\t\tdisclosure.organization = organization;\n', '\t\tdisclosure.recipient = recipient;\n', '\t\tdisclosure.location = location;\n', '\t\tdisclosure.amount = amount;\n', '\t\tdisclosure.fundingType = fundingType;\n', '\t\tdisclosure.date = date;\n', '\t\tdisclosure.purpose = purpose;\n', '\t\tdisclosure.comment = comment;\n', '\t\tdisclosure.amended = 0;\n', '\n', '\t\t// Push entry to the array\n', '\t\tuint index = disclosureList.push(disclosure);   // adds to end of array (of structs) and returns the new array length\n', '\t\tindex = index - 1;\n', '\n', '\t\t// Now that we have the newRowNumber (index), set the amended field on the old record\n', '\t\tdisclosureList[rowNumber].amended = index;\n', '\n', '\t\t// Record the event\n', '\t\tdisclosureAdded(index, organization, recipient, location, amount, fundingType, date, purpose, comment);   // a different event for amending?\n', '\n', '\t\treturn index;   // returning rowNumber of the new record\n', '\t}\n', '\n', '\t// Returns row regardless of whether or not it has been amended\n', '\tfunction pullRow(uint rowNumber) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32, uint) {\n', '\t\t// First make sure rowNumber passed is within bounds\n', '\t\tif (rowNumber >= disclosureList.length) { revert(); }\n', '\t\tif (rowNumber < 1) { revert(); }\n', '\t\t// Should not use any gas:\n', '\t\tDisclosure memory entry = disclosureList[rowNumber];\n', '\t\treturn (entry.organization, entry.recipient, entry.location, entry.amount, entry.fundingType, entry.date, entry.purpose, entry.comment, entry.amended);\n', '\t}\n', '\n', '\t// Returns latest entry of record intended to pull\n', '\tfunction pullEntry(uint rowNumber) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32) {\n', '\t\t// First make sure rowNumber passed is within bounds\n', '\t\tif (rowNumber >= disclosureList.length) { revert(); }\n', '\t\tif (rowNumber < 1) { revert(); }\n', '\t\t// If this entry has been amended, return amended entry instead (recursively)\n', "\t\t// just make sure there are never any cyclical lists (shouldn't be possible using these functions)\n", '\t\tif (disclosureList[rowNumber].amended > 0) return pullEntry(disclosureList[rowNumber].amended);\n', '\t\t// Should not require any gas to run:\n', '\t\tDisclosure memory entry = disclosureList[rowNumber];\n', '\t\treturn (entry.organization, entry.recipient, entry.location, entry.amount, entry.fundingType, entry.date, entry.purpose, entry.comment);\n', "\t\t// No event for pullEntry() since it shouldn't cost gas to call it\n", '\t}\n', '\n', '}']