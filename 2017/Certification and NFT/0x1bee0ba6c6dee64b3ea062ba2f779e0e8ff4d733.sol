['// SIMPLECOIN TOKEN\n', '// simplecoin.co\n', '//\n', '// SMP token is a virtual token, governed by ERC20-compatible Ethereum Smart Contract and secured by Ethereum Blockchain\n', '// The official website is https://www.simplecoin.co\n', '//\n', '// The uints are all in wei and WEI tokens (*10^-18)\n', '\n', '// The contract code itself, as usual, is at the end, after all the connected libraries\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    validate(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    validate(b > 0);\n', '    uint c = a / b;\n', '    validate(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    validate(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    validate(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function validate(bool validation) internal {\n', '    if (!validation) {\n', '      revert();\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/*\n', ' * ERC20Basic\n', ' * Simpler version of ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '\n', '/*\n', ' * Basic token\n', ' * Basic version of StandardToken, with no allowances\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /*\n', '   * Fix for the ERC20 short address attack  \n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       revert();\n', '     }\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  \n', '}\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint _value) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already revert() if this condition is not met\n', '    // if (value > allowance) revert();\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract SIMPLECOIN is StandardToken, Ownable {\n', '    using SafeMath for uint;\n', '\n', '    //--------------   Info for ERC20 explorers  -----------------//\n', '    string public name = "SIMPLECOIN";\n', '    string public symbol = "SIM";\n', '    uint public decimals = 18;\n', '\n', '    //---------------------   Constants   ------------------------//\n', '    uint public constant WEI = 1000000000000000000;\n', '    uint public constant INITIAL_SUPPLY = 500000000 * WEI; // 500 mln SMP. Impossible to mint more than this\n', '    uint public constant ICO_START_TIME = 1507572447;\n', '    uint public constant PRICE = 600;\n', '\n', '    uint public constant _ONE = 1 * WEI;\n', '    uint public constant _FIFTY = 50 * WEI;\n', '    uint public constant _HUNDRED = 100 * WEI;\n', '    uint public constant _FIVEHUNDRED = 500 * WEI;\n', '    uint public constant _THOUSAND = 1000 * WEI;\n', '    uint public constant _FIVETHOUSAND = 5000 * WEI;\n', '\n', '    address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50;\n', '    address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01;\n', '\n', '    //----------------------  Variables  -------------------------//\n', '    uint public current_supply = 0; // Holding the number of all the coins in existence\n', '    uint public ico_starting_supply = 0; // How many WEI tokens were available for sale at the beginning of the ICO\n', '\n', '    //-------------   Flags describing ICO stages   --------------//\n', '    bool public preMarketingSharesDistributed = false; // Prevents accidental re-distribution of shares\n', '    // private venture pre ico\n', '    bool public isPreICOPrivateOpened = false;\n', '    bool public isPreICOPrivateClosed = false;\n', '    // public pre ico\n', '    bool public isPreICOPublicOpened = false;\n', '    bool public isPreICOPublicClosed = false;\n', '    // public ico\n', '    bool public isICOOpened = false;\n', '    bool public isICOClosed = false;\n', '\n', '    //----------------------   Events  ---------------------------//\n', '    event PreICOPrivateOpened();\n', '    event PreICOPrivateClosed();\n', '    event PreICOPublicOpened();\n', '    event PreICOPublicClosed();\n', '    event ICOOpened();\n', '    event ICOClosed();\n', '    event SupplyChanged(uint supply, uint old_supply);\n', '    event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc);\n', '\n', '    // *\n', '\n', '    // Constructor\n', '    function SIMPLECOIN() {\n', '        // Some percentage of the tokens is already reserved by early employees and investors\n', "        // Here we're initializing their balances\n", '        distributeMarketingShares();\n', '    }\n', '\n', '    // Sending ether directly to the contract invokes buy() and assigns tokens to the sender\n', '    function () payable {\n', '        buy();\n', '    }\n', '\n', '    // *\n', '\n', '    // Buy token by sending ether here\n', '    //\n', '    // You can also send the ether directly to the contract address\n', '    function buy() payable {\n', '        if (msg.value == 0) {\n', '            revert();\n', '        }\n', '\n', '        // prevent from buying before starting preico or ico\n', '        if (!isPreICOPrivateOpened && !isPreICOPublicOpened && !isICOOpened) {\n', '            revert();\n', '        }\n', '\n', '        if (isICOClosed) {\n', '            revert();\n', '        }\n', '\n', '        // Deciding how many tokens can be bought with the ether received\n', '        uint tokens = getSMPTokensAmountPerEthInternal(msg.value);\n', '\n', '        // Just in case\n', '        if (tokens > balances[ICO_ADDRESS]) { \n', '            revert();\n', '        }\n', '\n', '        // Transfer from the ICO pool\n', '        balances[ICO_ADDRESS] = balances[ICO_ADDRESS].sub(tokens); // if not enough, will revert()\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '\n', '        // Broadcasting the buying event\n', '        SMPAcquired(msg.sender, msg.value, tokens);\n', '    }\n', '\n', '    // *\n', '\n', '    // Functions for the contract owner\n', '    function openPreICOPrivate() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();        \n', '\n', '        isPreICOPrivateOpened = true;\n', '\n', '        PreICOPrivateOpened();\n', '    }\n', '\n', '    function closePreICOPrivate() onlyOwner {\n', '        if (!isPreICOPrivateOpened) revert();\n', '        if (isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        isPreICOPrivateOpened = false;\n', '        isPreICOPrivateClosed = true;\n', '\n', '        PreICOPrivateClosed();\n', '    }\n', '\n', '    function openPreICOPublic() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();        \n', '\n', '        isPreICOPublicOpened = true;\n', '\n', '        PreICOPublicOpened();\n', '    }\n', '\n', '    function closePreICOPublic() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (!isPreICOPublicOpened) revert();\n', '        if (isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        isPreICOPublicOpened = false;\n', '        isPreICOPublicClosed = true;\n', '\n', '        PreICOPublicClosed();\n', '    }\n', '\n', '    function openICO() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (!isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        isICOOpened = true;\n', '\n', '        ICOOpened();\n', '    }\n', '\n', '    function closeICO() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (!isPreICOPublicClosed) revert();\n', '\n', '        if (!isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        isICOOpened = false;\n', '        isICOClosed = true;\n', '\n', '        balances[ICO_ADDRESS] = 0;\n', '\n', '        ICOClosed();\n', '    }\n', '\n', '    function pullEtherFromContractAfterPreICOPrivate() onlyOwner {       \n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        if (!TEAM_WALLET.send(this.balance)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function pullEtherFromContractAfterPreICOPublic() onlyOwner {       \n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (!isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (isICOClosed) revert();\n', '\n', '        if (!TEAM_WALLET.send(this.balance)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function pullEtherFromContractAfterICO() onlyOwner {\n', '        if (isPreICOPrivateOpened) revert();\n', '        if (!isPreICOPrivateClosed) revert();\n', '\n', '        if (isPreICOPublicOpened) revert();\n', '        if (!isPreICOPublicClosed) revert();\n', '\n', '        if (isICOOpened) revert();\n', '        if (!isICOClosed) revert();\n', '\n', '        if (!TEAM_WALLET.send(this.balance)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    // *\n', '\n', '    // Some percentage of the tokens is already reserved for marketing\n', '    function distributeMarketingShares() onlyOwner {\n', '        // Making it impossible to call this function twice\n', '        if (preMarketingSharesDistributed) {\n', '            revert();\n', '        }\n', '\n', '        preMarketingSharesDistributed = true;\n', '\n', '        // Values are in WEI tokens\n', '        balances[0xAc5C2414dae4ADB07D82d40dE71B4Bc5E2b417fd] = 100000000 * WEI; // referral\n', '        balances[0x603D3e11E88dD9aDdc4D9AbE205C7C02e9e13483] = 20000000 * WEI; // social marketing\n', '        \n', '        current_supply = (100000000 + 20000000) * WEI;\n', '\n', '        // Sending the rest to ICO pool\n', '        balances[ICO_ADDRESS] = INITIAL_SUPPLY.sub(current_supply);\n', '\n', '        // Initializing the supply variables\n', '        ico_starting_supply = balances[ICO_ADDRESS];\n', '        current_supply = INITIAL_SUPPLY;\n', '        SupplyChanged(0, current_supply);\n', '    }\n', '\n', '    // *\n', '\n', '    // Some useful getters (although you can just query the public variables)\n', '\n', '    function getPriceSMPTokensPerWei() public constant returns (uint result) {\n', '        return PRICE;\n', '    }\n', '\n', '    /* function getSMPTokensAmountPerEthInternal(uint value) public payable returns (uint result) {     \n', '        return value * PRICE;\n', '    } */\n', '\n', '    function getSMPTokensAmountPerEthInternal(uint value) public payable returns (uint result) {    \n', '        if (isPreICOPrivateOpened) {\n', '            if (value >= _FIFTY && value < _FIVEHUNDRED) {\n', '                return (value + (value * 35) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _FIVEHUNDRED && value < _THOUSAND) {\n', '                return (value + (value * 40) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _THOUSAND && value < _FIVETHOUSAND) {\n', '                return (value + (value * 60) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _FIVETHOUSAND) {\n', '                return (value + value) * PRICE;\n', '            }\n', '        }\n', '\n', '        if (isPreICOPublicOpened) {\n', '            if (value >= _ONE && value < _HUNDRED) {\n', '                return (value + (value * 20) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _HUNDRED && value < _FIVEHUNDRED) {\n', '                return (value + (value * 30) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _FIVEHUNDRED && value < _THOUSAND) {\n', '                return (value + (value * 40) / 100) * PRICE;\n', '            }\n', '\n', '            if (value >= _THOUSAND) {\n', '                return (value + (value * 50) / 100) * PRICE;\n', '            }\n', '        }\n', '\n', '        return value * PRICE;\n', '    }\n', '\n', '    function getSMPTokensAmountPerWei(uint value) public constant returns (uint result) {\n', '        return getSMPTokensAmountPerEthInternal(value);\n', '    }\n', '    function getSupply() public constant returns (uint result) {\n', '        return current_supply;\n', '    }\n', '    function getSMPTokensLeftForICO() public constant returns (uint result) {\n', '        return balances[ICO_ADDRESS];\n', '    }\n', '    function getSMPTokensBoughtInICO() public constant returns (uint result) {\n', '        return ico_starting_supply - getSMPTokensLeftForICO();\n', '    }\n', '    function getBalance(address addr) public constant returns (uint balance) {\n', '        return balances[addr];\n', '    }\n', '\n', '    // *\n', '\n', '    // Overriding payment functions to take control over the logic\n', '    modifier allowedPayments(address payer, uint value) {\n', "        // Don't allow to transfer coins until the ICO ends\n", '        if (isPreICOPrivateOpened || isPreICOPublicOpened || isICOOpened) {\n', '            revert();\n', '        }\n', '\n', '        if (!isPreICOPrivateClosed || !isPreICOPublicClosed || !isICOClosed) {\n', '            revert();\n', '        }\n', '\n', '        if (block.timestamp < ICO_START_TIME) {\n', '            revert();\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) allowedPayments(_from, _value) {\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) allowedPayments(msg.sender, _value) {\n', '        super.transfer(_to, _value);\n', '    }\n', '\n', '}']