['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract PreSaleToken {\n', '    using SafeMath for uint256;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AllowExchanger(address indexed exchanger);\n', '    event RevokeExchanger(address indexed exchanger);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '    event Exchange(address indexed from, uint256 exchangedValue, string symbol, uint256 grantedValue);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /// The owner of the contract.\n', '    address public owner;\n', '\n', '    /// The total number of minted tokens, excluding destroyed tokens.\n', '    uint256 public totalSupply;\n', '\n', '    /// The token balance of each address.\n', '    mapping(address => uint256) balances;\n', '\n', '    /// The full list of addresses we have minted tokens for, stored for\n', '    /// exchange purposes.\n', '    address[] public holders;\n', '\n', '    /// Whether the token is still mintable.\n', '    bool public mintingFinished = false;\n', '\n', '    /// Addresses allowed to exchange the presale tokens for the final\n', '    /// and/or intermediary tokens.\n', '    mapping(address => bool) public exchangers;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyExchanger() {\n', '        require(exchangers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function PreSaleToken() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function allowExchanger(address _exchanger) onlyOwner public {\n', '        require(mintingFinished);\n', '        require(_exchanger != 0x0);\n', '        require(!exchangers[_exchanger]);\n', '\n', '        exchangers[_exchanger] = true;\n', '        AllowExchanger(_exchanger);\n', '    }\n', '\n', '    function exchange(\n', '        address _from,\n', '        uint256 _amount,\n', '        string _symbol,\n', '        uint256 _grantedValue\n', '    )\n', '        onlyExchanger\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(mintingFinished); // Always true due to exchangers requiring the same condition\n', '        require(_from != 0x0);\n', '        require(!exchangers[_from]);\n', '        require(_amount > 0);\n', '        require(_amount <= balances[_from]);\n', '\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[msg.sender] = balances[msg.sender].add(_amount);\n', '        Exchange(\n', '            _from,\n', '            _amount,\n', '            _symbol,\n', '            _grantedValue\n', '        );\n', '        Transfer(_from, msg.sender, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function finishMinting() onlyOwner public returns (bool) {\n', '        require(!mintingFinished);\n', '\n', '        mintingFinished = true;\n', '        MintFinished();\n', '\n', '        return true;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '        require(_to != 0x0);\n', '        require(!mintingFinished);\n', '        require(_amount > 0);\n', '\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        holders.push(_to);\n', '        Mint(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function revokeExchanger(address _exchanger) onlyOwner public {\n', '        require(mintingFinished);\n', '        require(_exchanger != 0x0);\n', '        require(exchangers[_exchanger]);\n', '\n', '        delete exchangers[_exchanger];\n', '        RevokeExchanger(_exchanger);\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public {\n', '        require(_to != address(0));\n', '        OwnershipTransferred(owner, _to);\n', '        owner = _to;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '\n', 'contract PreSale {\n', '    using SafeMath for uint256;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event Pause();\n', '    event Unpause();\n', '    event Withdrawal(address indexed wallet, uint256 weiAmount);\n', '    event Extended(uint256 until);\n', '    event Finalized();\n', '    event Refunding();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '    event Whitelisted(address indexed participant, uint256 weiAmount);\n', '\n', '    /// The owner of the contract.\n', '    address public owner;\n', '\n', "    /// The token we're selling.\n", '    PreSaleToken public token;\n', '\n', '    /// The minimum goal to reach. If the goal is not reached, finishing\n', '    /// the sale will enable refunds.\n', '    uint256 public goal;\n', '\n', '    /// The sale period.\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    uint256 public timeExtension;\n', '\n', '    /// The numnber of tokens to mint per wei.\n', '    uint256 public rate;\n', '\n', "    /// The total number of wei raised. Note that the contract's balance may\n", '    /// differ from this value if someone has decided to forcefully send us\n', '    /// ether.\n', '    uint256 public weiRaised;\n', '\n', "    /// The wallet that will receive the contract's balance once the sale\n", '    /// finishes and the minimum goal is met.\n', '    address public wallet;\n', '\n', '    /// The list of addresses that are allowed to participate in the sale,\n', '    /// and up to what amount.\n', '    mapping(address => uint256) public whitelisted;\n', '\n', '    /// The amount of wei invested by each investor.\n', '    mapping(address => uint256) public deposited;\n', '\n', '    /// An enumerable list of investors.\n', '    address[] public investors;\n', '\n', '    /// Whether the sale is paused.\n', '    bool public paused = false;\n', '\n', '    /// Whether the sale has finished, and when.\n', '    bool public finished = false;\n', '    uint256 public finishedAt;\n', '\n', "    /// Whether we're accepting refunds.\n", '    bool public refunding = false;\n', '\n', '    /// The total number of wei refunded.\n', '    uint256 public weiRefunded;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier saleOpen() {\n', '        require(!finished);\n', '        require(!paused);\n', '        require(now >= startTime);\n', '        require(now <= endTime + timeExtension);\n', '        _;\n', '    }\n', '\n', '    function PreSale(\n', '        uint256 _goal,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _rate,\n', '        address _wallet\n', '    )\n', '        payable\n', '    {\n', '        require(msg.value > 0);\n', '        require(_goal > 0);\n', '        require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != 0x0);\n', '\n', '        owner = msg.sender;\n', '        goal = _goal;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '        token = new PreSaleToken();\n', '\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function () payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) saleOpen public payable {\n', '        require(_beneficiary != address(0));\n', '        require(msg.value > 0);\n', '\n', '        uint256 weiAmount = msg.value;\n', '        uint256 newDeposited = deposited[_beneficiary].add(weiAmount);\n', '\n', '        require(newDeposited <= whitelisted[_beneficiary]);\n', '\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        deposited[_beneficiary] = newDeposited;\n', '        investors.push(_beneficiary);\n', '\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        token.mint(_beneficiary, tokens);\n', '        TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            tokens\n', '        );\n', '    }\n', '\n', '    function extendTime(uint256 _timeExtension) onlyOwner public {\n', '        require(!finished);\n', '        require(now < endTime + timeExtension);\n', '        require(_timeExtension > 0);\n', '\n', '        timeExtension = timeExtension.add(_timeExtension);\n', '        require(timeExtension <= 7 days);\n', '\n', '        Extended(endTime.add(timeExtension));\n', '    }\n', '\n', '    function finish() onlyOwner public {\n', '        require(!finished);\n', '        require(now > endTime + timeExtension);\n', '\n', '        finished = true;\n', '        finishedAt = now;\n', '        token.finishMinting();\n', '\n', '        if (goalReached()) {\n', '            token.transferOwnership(owner);\n', '            withdraw();\n', '        } else {\n', '            refunding = true;\n', '            Refunding();\n', '        }\n', '\n', '        Finalized();\n', '    }\n', '\n', '    function pause() onlyOwner public {\n', '        require(!paused);\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    function refund(address _investor) public {\n', '        require(finished);\n', '        require(refunding);\n', '        require(deposited[_investor] > 0);\n', '\n', '        uint256 weiAmount = deposited[_investor];\n', '        deposited[_investor] = 0;\n', '        weiRefunded = weiRefunded.add(weiAmount);\n', '\n', '        // Work around a Solium linter bug by creating a variable that does\n', '        // not begin with an underscore. See [1] for more information.\n', '        //\n', '        // [1] https://github.com/duaraghav8/Solium/issues/116\n', '        address recipient = _investor;\n', '        recipient.transfer(weiAmount);\n', '\n', '        Refunded(_investor, weiAmount);\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public {\n', '        require(_to != address(0));\n', '        OwnershipTransferred(owner, _to);\n', '        owner = _to;\n', '    }\n', '\n', '    function unpause() onlyOwner public {\n', '        require(paused);\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '\n', '    function whitelist(address _participant, uint256 _weiAmount) onlyOwner public {\n', '        require(_participant != 0x0);\n', '\n', '        whitelisted[_participant] = _weiAmount;\n', '        Whitelisted(_participant, _weiAmount);\n', '    }\n', '\n', '    function withdraw() onlyOwner public {\n', '        require(goalReached() || (finished && now > finishedAt + 14 days));\n', '\n', '        uint256 weiAmount = this.balance;\n', '\n', '        if (weiAmount > 0) {\n', '            wallet.transfer(weiAmount);\n', '            Withdrawal(wallet, weiAmount);\n', '        }\n', '    }\n', '\n', '    function goalReached() public constant returns (bool) {\n', '        return weiRaised >= goal;\n', '    }\n', '}']