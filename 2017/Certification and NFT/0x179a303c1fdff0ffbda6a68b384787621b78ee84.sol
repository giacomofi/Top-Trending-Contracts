['/*\n', 'This file is part of the Open Longevity Contract.\n', '\n', 'The Open Longevity Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The Open Longevity Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the Open Longevity Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@nordavind.ru>\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function owned() public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public ;\n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public;\n', '    function approve(address spender, uint value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract PresaleOriginal is owned, ERC20 {\n', '\n', '    uint    public totalLimitUSD;\n', '    uint    public collectedUSD;\n', '    uint    public presaleStartTime;\n', '\n', '    struct Investor {\n', '        uint256 amountTokens;\n', '        uint    amountWei;\n', '    }\n', '    mapping (address => Investor) public investors;\n', '    mapping (uint => address)     public investorsIter;\n', '    uint                          public numberOfInvestors;\n', '}\n', '\n', 'contract Presale is PresaleOriginal {\n', '\n', '    uint    public etherPrice;\n', '    address public presaleOwner;\n', '\n', '    enum State { Disabled, Presale, Finished }\n', '    event NewState(State state);\n', '    State   public state;\n', '    uint    public presaleFinishTime;\n', '\n', '    uint    public migrationCounter;\n', '\n', '    function migrate(address _originalContract, uint n) public onlyOwner {\n', '        require(state == State.Disabled);\n', '        \n', '        // migrate tokens with x2 bonus\n', '        numberOfInvestors = PresaleOriginal(_originalContract).numberOfInvestors();\n', '        uint limit = migrationCounter + n;\n', '        if(limit > numberOfInvestors) {\n', '            limit = numberOfInvestors;\n', '        }\n', '        for(; migrationCounter < limit; ++migrationCounter) {\n', '            address a = PresaleOriginal(_originalContract).investorsIter(migrationCounter);\n', '            investorsIter[migrationCounter] = a;\n', '            uint256 amountTokens;\n', '            uint amountWei;\n', '            (amountTokens, amountWei) = PresaleOriginal(_originalContract).investors(a);\n', '            amountTokens *= 2;\n', '            investors[a].amountTokens = amountTokens;\n', '            investors[a].amountWei = amountWei;\n', '            totalSupply += amountTokens;\n', '            Transfer(_originalContract, a, amountTokens);\n', '        }\n', '        if(limit < numberOfInvestors) {\n', '            return;\n', '        }\n', '\n', '        // migrate main parameters\n', '        presaleStartTime = PresaleOriginal(_originalContract).presaleStartTime();\n', '        collectedUSD = PresaleOriginal(_originalContract).collectedUSD();\n', '        totalLimitUSD = PresaleOriginal(_originalContract).totalLimitUSD();\n', '\n', '        // add extra tokens for bounty\n', '        address bountyAddress = 0x59B95A5e0268Cc843e6308FEf723544BaA6676c6;\n', '        if(investors[bountyAddress].amountWei == 0 && investors[bountyAddress].amountTokens == 0) {\n', '            investorsIter[numberOfInvestors++] = bountyAddress;\n', '        }\n', '        uint bountyTokens = 5 * PresaleOriginal(_originalContract).totalSupply() / 100;\n', '        investors[bountyAddress].amountTokens += bountyTokens;\n', '        totalSupply += bountyTokens;\n', '    }\n', '\n', '    function () payable public {\n', '        require(state == State.Presale);\n', '        require(now < presaleFinishTime);\n', '\n', '        uint valueWei = msg.value;\n', '        uint valueUSD = valueWei * etherPrice / 1000000000000000000;\n', "        if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\n", '            valueUSD = totalLimitUSD - collectedUSD;\n', '            valueWei = valueUSD * 1000000000000000000 / etherPrice;\n', '            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\n', '            collectedUSD = totalLimitUSD; // to be sure!\n', '        } else {\n', '            collectedUSD += valueUSD;\n', '        }\n', '\n', '        uint256 tokensPer10USD = 130;\n', '        if (valueUSD >= 100000) {\n', '            tokensPer10USD = 150;\n', '        }\n', '\n', '        uint256 tokens = tokensPer10USD * valueUSD / 10;\n', '        require(tokens > 0);\n', '\n', '        Investor storage inv = investors[msg.sender];\n', '        if (inv.amountWei == 0) { // new investor\n', '            investorsIter[numberOfInvestors++] = msg.sender;\n', '        }\n', '        require(inv.amountTokens + tokens > inv.amountTokens); // overflow\n', '        inv.amountTokens += tokens;\n', '        inv.amountWei += valueWei;\n', '        totalSupply += tokens;\n', '        Transfer(this, msg.sender, tokens);\n', '    }\n', '    \n', '    function startPresale(address _presaleOwner, uint _etherPrice) public onlyOwner {\n', '        require(state == State.Disabled);\n', '        presaleOwner = _presaleOwner;\n', '        etherPrice = _etherPrice;\n', '        presaleFinishTime = 1526342400; // (GMT) 15 May 2018, 00:00:00\n', '        state = State.Presale;\n', '        totalLimitUSD = 500000;\n', '        NewState(state);\n', '    }\n', '\n', '    function setEtherPrice(uint _etherPrice) public onlyOwner {\n', '        require(state == State.Presale);\n', '        etherPrice = _etherPrice;\n', '    }\n', '    \n', '    function timeToFinishPresale() public constant returns(uint t) {\n', '        require(state == State.Presale);\n', '        if (now > presaleFinishTime) {\n', '            t = 0;\n', '        } else {\n', '            t = presaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishPresale() public onlyOwner {\n', '        require(state == State.Presale);\n', '        require(now >= presaleFinishTime || collectedUSD == totalLimitUSD);\n', '        require(presaleOwner.call.gas(3000000).value(this.balance)());\n', '        state = State.Finished;\n', '        NewState(state);\n', '    }\n', '    \n', '    function withdraw() public onlyOwner {\n', '        require(presaleOwner.call.gas(3000000).value(this.balance)());\n', '    }\n', '}\n', '\n', 'contract PresaleToken is Presale {\n', '    \n', "    string  public standard    = 'Token 0.1';\n", "    string  public name        = 'OpenLongevity';\n", '    string  public symbol      = "YEAR";\n', '    uint8   public decimals    = 0;\n', '\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function PresaleToken() payable public Presale() {}\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return investors[_who].amountTokens;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) {\n', '        require(investors[msg.sender].amountTokens >= _value);\n', '        require(investors[_to].amountTokens + _value >= investors[_to].amountTokens);\n', '        investors[msg.sender].amountTokens -= _value;\n', '        if(investors[_to].amountTokens == 0 && investors[_to].amountWei == 0) {\n', '            investorsIter[numberOfInvestors++] = _to;\n', '        }\n', '        investors[_to].amountTokens += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n', '        require(investors[_from].amountTokens >= _value);\n', '        require(investors[_to].amountTokens + _value >= investors[_to].amountTokens); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        investors[_from].amountTokens -= _value;\n', '        if(investors[_to].amountTokens == 0 && investors[_to].amountWei == 0) {\n', '            investorsIter[numberOfInvestors++] = _to;\n', '        }\n', '        investors[_to].amountTokens += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant\n', '        returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract OpenLongevityPresale is PresaleToken {\n', '\n', '    function OpenLongevityPresale() payable public PresaleToken() {}\n', '\n', '    function killMe() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']