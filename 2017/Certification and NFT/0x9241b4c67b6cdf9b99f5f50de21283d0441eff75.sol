['//\n', '// compiler: 0.4.19+commit.c4cbbb05.Emscripten.clang\n', '//\n', 'pragma solidity ^0.4.19;\n', '\n', '// ---------------------------------------------------------------------------\n', '// Treasury smart contract. Owner (Treasurer) is only account that can submit\n', '// proposals, yet cannot actually spend. The Treasurer appoints Trustees to\n', '// approve spending proposals. Funds are released automatically once a\n', '// proposal is approved by a simple majority of trustees.\n', '//\n', '// Trustees can be flagged as inactive by the Treasurer. An inactive Trustee\n', '// cannot vote. The Treasurer may set/reset flags. The Treasurer can replace\n', '// any Trustee, though any approvals already made will stand.\n', '// ---------------------------------------------------------------------------\n', '\n', 'contract owned\n', '{\n', '  address public treasurer;\n', '  function owned() public { treasurer = msg.sender; }\n', '  function closedown() public onlyTreasurer { selfdestruct( treasurer ); }\n', '  function setTreasurer( address newTreasurer ) public onlyTreasurer\n', '  { treasurer = newTreasurer; }\n', '  modifier onlyTreasurer {\n', '    require( msg.sender == treasurer );\n', '    _;\n', '  }\n', '}\n', '\n', 'contract Treasury is owned {\n', '\n', '  event Added( address indexed trustee );\n', '  event Flagged( address indexed trustee, bool isRaised );\n', '  event Replaced( address indexed older, address indexed newer );\n', '\n', '  event Proposal( address indexed payee, uint amt, string eref );\n', '  event Approved( address indexed approver,\n', '                  address indexed to,\n', '                  uint amount,\n', '                  string eref );\n', '  event Spent( address indexed payee, uint amt, string eref );\n', '\n', '  struct SpendProposal {\n', '    address   payee;\n', '    uint      amount;\n', '    string    eref;\n', '    address[] approvals;\n', '  }\n', '\n', '  SpendProposal[] proposals;\n', '  address[]       trustees;\n', '  bool[]          flagged; // flagging trustee disables from voting\n', '\n', '  function Treasury() public {}\n', '\n', '  function() public payable {}\n', '\n', '  function add( address trustee ) public onlyTreasurer\n', '  {\n', '    require( trustee != address(0) );\n', '    require( trustee != treasurer ); // separate Treasurer and Trustees\n', '\n', '    for (uint ix = 0; ix < trustees.length; ix++)\n', '      if (trustees[ix] == trustee) return;\n', '\n', '    trustees.push(trustee);\n', '    flagged.push(false);\n', '\n', '    Added( trustee );\n', '  }\n', '\n', '  function flag( address trustee, bool isRaised ) public onlyTreasurer\n', '  {\n', '    for( uint ix = 0; ix < trustees.length; ix++ )\n', '      if (trustees[ix] == trustee)\n', '      {\n', '        flagged[ix] = isRaised;\n', '        Flagged( trustees[ix], flagged[ix] );\n', '        break;\n', '      }\n', '  }\n', '\n', '  function replace( address older, address newer ) public onlyTreasurer\n', '  {\n', '    for( uint ix = 0; ix < trustees.length; ix++ )\n', '      if (trustees[ix] == older)\n', '      {\n', '        Replaced( trustees[ix], newer );\n', '        trustees[ix] = newer;\n', '        flagged[ix] = false;\n', '        break;\n', '      }\n', '  }\n', '\n', '  function proposal( address _payee, uint _wei, string _eref )\n', '  public onlyTreasurer\n', '  {\n', '    bytes memory erefb = bytes(_eref);\n', '    require(    _payee != address(0)\n', '             && _wei > 0\n', '             && erefb.length > 0\n', '             && erefb.length <= 32 );\n', '\n', '    uint ix = proposals.length++;\n', '    proposals[ix].payee = _payee;\n', '    proposals[ix].amount = _wei;\n', '    proposals[ix].eref = _eref;\n', '\n', '    Proposal( _payee, _wei, _eref );\n', '  }\n', '\n', '  function approve( address _payee, uint _wei, string _eref ) public\n', '  {\n', '    // ensure caller is a trustee in good standing\n', '    bool senderValid = false;\n', '    for (uint tix = 0; tix < trustees.length; tix++) {\n', '      if (msg.sender == trustees[tix]) {\n', '        if (flagged[tix])\n', '          revert();\n', '\n', '        senderValid = true;\n', '      }\n', '    }\n', '    if (!senderValid) revert();\n', '\n', '    // find the matching proposal not already actioned (amount would be 0)\n', '    for (uint pix = 0; pix < proposals.length; pix++)\n', '    {\n', '      if (    proposals[pix].payee == _payee\n', '           && proposals[pix].amount == _wei\n', '           && strcmp(proposals[pix].eref, _eref) )\n', '      {\n', '        // prevent voting twice\n', '        for (uint ap = 0; ap < proposals[pix].approvals.length; ap++)\n', '        {\n', '          if (msg.sender == proposals[pix].approvals[ap])\n', '            revert();\n', '        }\n', '\n', '        proposals[pix].approvals.push( msg.sender );\n', '\n', '        Approved( msg.sender,\n', '                  proposals[pix].payee,\n', '                  proposals[pix].amount,\n', '                  proposals[pix].eref );\n', '\n', '        if ( proposals[pix].approvals.length > (trustees.length / 2) )\n', '        {\n', '          require( this.balance >= proposals[pix].amount );\n', '\n', '          if ( proposals[pix].payee.send(proposals[pix].amount) )\n', '          {\n', '            Spent( proposals[pix].payee,\n', '                   proposals[pix].amount,\n', '                   proposals[pix].eref );\n', '\n', '            proposals[pix].amount = 0; // prevent double spend\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  function strcmp( string _a, string _b ) pure internal returns (bool)\n', '  {\n', '    return keccak256(_a) == keccak256(_b);\n', '  }\n', '}']